

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/imgfavicon.jpg">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  <title>算法进阶 - Blog</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.1.2/styles/ocean.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.5","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"copy_btn":true,"image_zoom":{"enable":true},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.2.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Main</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax=true
         style="background: url('https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/imgdefault.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="算法进阶">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-04-11 11:11" pubdate>
        2021年4月11日 上午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      23.9k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      328
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">算法进阶</h1>
            
            <div class="markdown-body">
              <h1 id="单调栈和滑动窗口"><a href="#单调栈和滑动窗口" class="headerlink" title="单调栈和滑动窗口"></a>单调栈和滑动窗口</h1><h2 id="滑动窗口是什么？"><a href="#滑动窗口是什么？" class="headerlink" title="滑动窗口是什么？"></a>滑动窗口是什么？</h2><p>滑动窗口是一种想象出来的 <strong>数据结构</strong> ：</p>
<p>滑动窗口有 <strong>左边界L和右边界R</strong> </p>
<p>在数组或者字符串或者一个序列上，记为S，窗口就是S[L..R]这一部分</p>
<p>L往右滑意味着一个样本出了窗口，R往右滑意味着一个样本进了窗口</p>
<p>L和R都只能往右滑</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210119143320.png" srcset="/img/loading.gif" alt="滑动窗口"></p>
<p>注意：任何时候 L &lt;= R，且必须往右动不回退</p>
<h2 id="滑动窗口能做什么？"><a href="#滑动窗口能做什么？" class="headerlink" title="滑动窗口能做什么？"></a>滑动窗口能做什么？</h2><p>滑动窗口、首尾指针等技巧，说白了是一种求解问题的流程设计。</p>
<h2 id="滑动内最大值和最小值的更新结构"><a href="#滑动内最大值和最小值的更新结构" class="headerlink" title="滑动内最大值和最小值的更新结构"></a>滑动内最大值和最小值的更新结构</h2><p>窗口不管L还是R滑动之后，都会让窗口呈现新状况，</p>
<p>如何能够更快的得到窗口当前状况下的最大值和最小值？</p>
<p>最好平均下来复杂度能做到O(1)</p>
<p>利用 <strong>单调双端队列！</strong> </p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210119144456.png" srcset="/img/loading.gif" alt="双端队列"></p>
<p>1⃣️ R右移加数：</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210119144535.png" srcset="/img/loading.gif" alt="Max"></p>
<p>双端队列 <strong>从大到小</strong> ，如果新的数能落就落，落不下就弹出直至能落下（相等也要弹出）</p>
<p>2⃣️ L右移减数：</p>
<p>如果当时情况为：</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210119144839.png" srcset="/img/loading.gif" alt="当时情况"></p>
<p>L右移时：</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210119145056.png" srcset="/img/loading.gif" alt="移动"></p>
<p>L右移，发现0位置不在，从双端队列 <strong>队首</strong> 开时寻找，没有0，不动；</p>
<p>L如果再次右移，发现1位置不在，从双端队列 <strong>队首</strong> 开时寻找，1为过期下标，1位置5从头部弹出；</p>
<p> <strong>双端队列头部</strong> 的数就是此时 <strong>窗口状况</strong> 的 <strong>最大值</strong> </p>
<p>双端队列的含义：</p>
<p>已经形成的窗口状况，不让R右移，只让L右移，哪些数会依次成为 <strong>最大值的优先级</strong>；</p>
<p>复杂度分析：</p>
<p>一个数最多：入一次，出一次。遍历一次O(N)， <strong>平均</strong> 下来单次代价O(1)</p>
<h2 id="题一-滑动窗口最大值"><a href="#题一-滑动窗口最大值" class="headerlink" title="题一 滑动窗口最大值"></a>题一 滑动窗口最大值</h2><p>假设一个固定大小为W的窗口，依次划过arr，<br>返回每一次滑出状况的最大值<br>例如，arr = [4,3,5,4,3,3,6,7], W = 3<br>返回：[5,5,5,4,6,7]</p>
<p class="note note-primary">对应lc239和剑指 59-1</p>

<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] getMaxWindow(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> w) &#123;
   <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || w &lt; <span class="hljs-number">1</span> || arr.length &lt; w) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
   &#125;

   <span class="hljs-comment">// LinkedList双端队列</span>
   <span class="hljs-comment">// 其中放的是位置，arr[位置]</span>
   LinkedList&lt;Integer&gt; qmax = <span class="hljs-keyword">new</span> LinkedList&lt;Integer&gt;();
   <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[arr.length - w + <span class="hljs-number">1</span>];
   <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;
   <span class="hljs-comment">// [L...R] i 表示 R 进窗口；</span>
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123; <span class="hljs-comment">// 当前让 i -&gt; [i] 进窗口 ， i 就是 r</span>
      <span class="hljs-comment">// R位置值放到双端队列比他大的数字后面，或者空后</span>
      <span class="hljs-keyword">while</span> (!qmax.isEmpty() &amp;&amp; arr[qmax.peekLast()] &lt;= arr[i]) &#123;
         qmax.pollLast();
      &#125;
      qmax.addLast(i);
      <span class="hljs-comment">// 数进来了</span>

      <span class="hljs-comment">// 如果窗口没有形成w的长度 不会弹出数字</span>
      <span class="hljs-comment">// 形成了w的长度 弹出也是弹i - w的位置的数</span>
      <span class="hljs-keyword">if</span> (qmax.peekFirst() == i - w) &#123;
         qmax.pollFirst();
      &#125;

      <span class="hljs-comment">// 窗口每一次形成w的长度，收集一次答案</span>
      <span class="hljs-keyword">if</span> (i &gt;= w - <span class="hljs-number">1</span>) &#123;
         res[index++] = arr[qmax.peekFirst()];
      &#125;
   &#125;
   <span class="hljs-keyword">return</span> res;
&#125;</code></pre></div>





<h2 id="题二-达标子数组"><a href="#题二-达标子数组" class="headerlink" title="题二 达标子数组"></a>题二 达标子数组</h2><p>给定一个整型数组arr，和一个整数num<br>某个arr中的子数组sub，如果想达标，必须满足：<br>sub中最大值 – sub中最小值 &lt;= num，<br>返回arr中达标子数组的数量</p>
<p class="note note-primary">对应lc1438</p>

<p>如果 <strong>子数组arr[L…R]达标</strong> ，内部任何 <strong>子数组</strong> 都达标</p>
<p>如果 <strong>子数组arr[L…R]不达标</strong> ，L往左或者R往右扩出来的范围也不会达标， 最大值只可能更大，最小值只可能最小</p>
<p>每一次成长到不达标位置，L右移再求到不达标位置</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210119155530.png" srcset="/img/loading.gif" alt="流程"></p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getNum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> num)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length == <span class="hljs-number">0</span>) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
   &#125;
   LinkedList&lt;Integer&gt; qmin = <span class="hljs-keyword">new</span> LinkedList&lt;Integer&gt;();
   LinkedList&lt;Integer&gt; qmax = <span class="hljs-keyword">new</span> LinkedList&lt;Integer&gt;();
   <span class="hljs-keyword">int</span> L = <span class="hljs-number">0</span>;
   <span class="hljs-keyword">int</span> R = <span class="hljs-number">0</span>;
   <span class="hljs-comment">// [L...R) -&gt; [0, 0)一个数没有 [0, 1) -&gt; [0, 0] R表示不达标的第一个位置</span>
   <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;
   <span class="hljs-keyword">while</span> (L &lt; arr.length) &#123; <span class="hljs-comment">// L是开头位置，尝试每一个开头</span>
      <span class="hljs-comment">// 如果此时窗口的开头是L,下面的while工作:R向右扩到违规为止</span>
      <span class="hljs-keyword">while</span> (R &lt; arr.length) &#123; <span class="hljs-comment">// R是最后一个达标位置的再下一个</span>
         <span class="hljs-keyword">while</span> (!qmin.isEmpty() &amp;&amp; arr[qmin.peekLast()] &gt;= arr[R]) &#123;
            qmin.pollLast();
         &#125;
         qmin.addLast(R);
         <span class="hljs-comment">// R -&gt; arr[R],</span>
         <span class="hljs-keyword">while</span> (!qmax.isEmpty() &amp;&amp; arr[qmax.peekLast()] &lt;= arr[R]) &#123;
            qmax.pollLast();
         &#125;
         qmax.addLast(R);
         <span class="hljs-keyword">if</span> (arr[qmax.getFirst()] - arr[qmin.getFirst()] &gt; num) &#123;
            <span class="hljs-keyword">break</span>;
         &#125;
         R++;
      &#125;
      <span class="hljs-comment">// R是最后一个达标位置的再下一个，第一个违规的位置</span>
      res += R - L;
      <span class="hljs-keyword">if</span> (qmin.peekFirst() == L) &#123;
         qmin.pollFirst();
      &#125;
      <span class="hljs-keyword">if</span> (qmax.peekFirst() == L) &#123;
         qmax.pollFirst();
      &#125;
      L++;
   &#125;
   <span class="hljs-keyword">return</span> res;
&#125;</code></pre></div>

<p>方法论：</p>
<p>优化题的方向：</p>
<ol>
<li><p>数据状况方向，上题本身就是一个窗口，达标内部就达标，不达标再扩充也不达标，建立了单调性</p>
</li>
<li><p>问题本身求的是什么 方向</p>
</li>
</ol>
<h2 id="单调栈是什么？"><a href="#单调栈是什么？" class="headerlink" title="单调栈是什么？"></a>单调栈是什么？</h2><p>一种特别设计的栈结构，为了解决如下的问题：</p>
<p>给定一个可能含有重复值的数组arr，i位置的数一定存在如下两个信息<br>1）arr[i]的左侧离i最近并且小于(或者大于)arr[i]的数在哪？<br>2）arr[i]的右侧离i最近并且小于(或者大于)arr[i]的数在哪？<br>如果想得到arr中所有位置的 <strong>两个信息</strong> ，怎么能让得到信息的过程尽量快。</p>
<p>那么到底怎么设计呢？</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210119162030.png" srcset="/img/loading.gif" alt="单调栈"></p>
<p>求每一个数左边和右边比它本身小的表，O(n)</p>
<blockquote>
<p>先假设数组中 <strong>没有重复值</strong> </p>
</blockquote>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210119162432.png" srcset="/img/loading.gif" alt="结构"></p>
<p>轮到 2位置的2想进去时，从栈中开始 <strong>弹出</strong> 生成 <strong>记录</strong> ；</p>
<p>1位置的4弹出，谁让它弹出，谁就是右边比他小的最近的（2位置的2）；</p>
<p>1位置的4栈下面压的数（0位置的3）就是左边比他小的最近的；</p>
<p>接着0位置3弹出生成 <strong>记录</strong> ，</p>
<p>2位置的2是右边比他小的，下面没有压数据，左边无；</p>
<p>栈空了，2压入；</p>
<p>遍历完后，单独处理栈还剩下的东西；</p>
<p>6位置1被迫弹出，右边无数据，左边为5位置的0；</p>
<p>5位置的0也被迫弹出，右边无数据，没压数，左边也无；</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[][] getNearLessNoRepeat(<span class="hljs-keyword">int</span>[] arr) &#123;
   <span class="hljs-keyword">int</span>[][] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[arr.length][<span class="hljs-number">2</span>];
   Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;
      <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; arr[stack.peek()] &gt; arr[i]) &#123;
         <span class="hljs-keyword">int</span> popIndex = stack.pop();
         <span class="hljs-keyword">int</span> leftLessIndex = stack.isEmpty() ? -<span class="hljs-number">1</span> : stack.peek();
         res[popIndex][<span class="hljs-number">0</span>] = leftLessIndex;
         res[popIndex][<span class="hljs-number">1</span>] = i;
      &#125;
      stack.push(i);
   &#125;
   <span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;
      <span class="hljs-keyword">int</span> popIndex = stack.pop();
      <span class="hljs-keyword">int</span> leftLessIndex = stack.isEmpty() ? -<span class="hljs-number">1</span> : stack.peek();
      res[popIndex][<span class="hljs-number">0</span>] = leftLessIndex;
      res[popIndex][<span class="hljs-number">1</span>] = -<span class="hljs-number">1</span>;
   &#125;
   <span class="hljs-keyword">return</span> res;
&#125;</code></pre></div>

<blockquote>
<p>假设数组中 有重复值情况</p>
</blockquote>
<p class="note note-danger">下面流程有误，第一个3、2搞错了</p>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210119164743.png" srcset="/img/loading.gif" alt="情况"></p>
<p>生成 <strong>list</strong> ，轮到2位置的3：</p>
<p>1位置的2 右边最近比他小的就是迫使它弹出的2位置的3；</p>
<p>1位置的2 左边最新比他小的就是下面list的末尾位置的值（0位置的3）；</p>
<p>相等把2位置的下标扔进list里面：</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210119164943.png" srcset="/img/loading.gif" alt="压缩"></p>
<p>直到：</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210119165006.png" srcset="/img/loading.gif" alt="情况"></p>
<p>3位置的4右边就是迫使他弹出的数，即为5位置的3；</p>
<p>3位置的4左边就是压着的list的末尾，即为2位置的3；</p>
<p>4位置的4右边还是5位置的3；</p>
<p>4位置的3右边还是压着的list的末尾；</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210119165159.png" srcset="/img/loading.gif" alt="遍历结束"></p>
<p>6位置的1压入，0，2，5位置的3记录，6右边无左边也无，结束；</p>
<p>相邻原因：</p>
<p>1）本身在一起 3445</p>
<p>2）中间的数都比其大 344553</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[][] getNearLess(<span class="hljs-keyword">int</span>[] arr) &#123;
   <span class="hljs-keyword">int</span>[][] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[arr.length][<span class="hljs-number">2</span>];
   <span class="hljs-comment">// List&lt;Integer&gt; -&gt; 放的是位置，同样值的东西，位置压在一起</span>
   Stack&lt;List&lt;Integer&gt;&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123; <span class="hljs-comment">// i -&gt; arr[i] 进栈</span>
      <span class="hljs-comment">// 底 -&gt; 顶， 小 -&gt; 大</span>
      <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; arr[stack.peek().get(<span class="hljs-number">0</span>)] &gt; arr[i]) &#123;
         List&lt;Integer&gt; popIs = stack.pop();
         <span class="hljs-comment">// 取位于下面位置的列表中，最晚加入的那个</span>
         <span class="hljs-keyword">int</span> leftLessIndex = stack.isEmpty() ? -<span class="hljs-number">1</span> : stack.peek().get(stack.peek().size() - <span class="hljs-number">1</span>);
         <span class="hljs-keyword">for</span> (Integer popi : popIs) &#123;
            res[popi][<span class="hljs-number">0</span>] = leftLessIndex;
            res[popi][<span class="hljs-number">1</span>] = i;
         &#125;
      &#125;
      <span class="hljs-comment">// 相等的、比你小的</span>
      <span class="hljs-keyword">if</span> (!stack.isEmpty() &amp;&amp; arr[stack.peek().get(<span class="hljs-number">0</span>)] == arr[i]) &#123;
         stack.peek().add(Integer.valueOf(i));
      &#125; <span class="hljs-keyword">else</span> &#123;
         ArrayList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
         list.add(i);
         stack.push(list);
      &#125;
   &#125;
   <span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;
      List&lt;Integer&gt; popIs = stack.pop();
      <span class="hljs-comment">// 取位于下面位置的列表中，最晚加入的那个</span>
      <span class="hljs-keyword">int</span> leftLessIndex = stack.isEmpty() ? -<span class="hljs-number">1</span> : stack.peek().get(stack.peek().size() - <span class="hljs-number">1</span>);
      <span class="hljs-keyword">for</span> (Integer popi : popIs) &#123;
         res[popi][<span class="hljs-number">0</span>] = leftLessIndex;
         res[popi][<span class="hljs-number">1</span>] = -<span class="hljs-number">1</span>;
      &#125;
   &#125;
   <span class="hljs-keyword">return</span> res;
&#125;</code></pre></div>

<h2 id="题目三"><a href="#题目三" class="headerlink" title="题目三"></a>题目三</h2><p>给定一个只包含正数的数组arr，arr中任何一个子数组sub，<br>一定都可以算出(sub累加和 )* (sub中的最小值)是什么，<br>那么所有子数组中，这个值最大是多少？</p>
<p>sub累加和可以用 <strong>前缀和数组</strong> 储存；sum[i]</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210119172219.png" srcset="/img/loading.gif" alt="前缀和数组"></p>
<p>arr[L … R] = arr[0, R] - arr[0, L-1];</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210119172558.png" srcset="/img/loading.gif" alt="sub最小值"></p>
<p>找到以3作最小值的最大子数组；</p>
<p>再找以4作最小值的最大子数组；</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210119172705.png" srcset="/img/loading.gif" alt="重复"></p>
<p>就是用单调栈：</p>
<p>求当前数左右比其小的数的位置就是范围：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">max2</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;
   <span class="hljs-keyword">int</span> size = arr.length;
   <span class="hljs-keyword">int</span>[] sums = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[size];
   sums[<span class="hljs-number">0</span>] = arr[<span class="hljs-number">0</span>];
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; size; i++) &#123;
      sums[i] = sums[i - <span class="hljs-number">1</span>] + arr[i];
   &#125;
   <span class="hljs-keyword">int</span> max = Integer.MIN_VALUE;
   Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;Integer&gt;();
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;
      <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; arr[stack.peek()] &gt;= arr[i]) &#123;
         <span class="hljs-keyword">int</span> j = stack.pop();
         max = Math.max(max, (stack.isEmpty() ? sums[i - <span class="hljs-number">1</span>] : (sums[i - <span class="hljs-number">1</span>] - sums[stack.peek()])) * arr[j]);
      &#125;
      stack.push(i);
   &#125;
   <span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;
      <span class="hljs-keyword">int</span> j = stack.pop();
      max = Math.max(max, (stack.isEmpty() ? sums[size - <span class="hljs-number">1</span>] : (sums[size - <span class="hljs-number">1</span>] - sums[stack.peek()])) * arr[j]);
   &#125;
   <span class="hljs-keyword">return</span> max;
&#125;</code></pre></div>



<h2 id="为什么要求题三？"><a href="#为什么要求题三？" class="headerlink" title="为什么要求题三？"></a>为什么要求题三？</h2><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210119173110.png" srcset="/img/loading.gif" alt="求面积"></p>
<p class="note note-primary">对应lc85</p>

<h2 id="动态规划-马跳象棋"><a href="#动态规划-马跳象棋" class="headerlink" title="动态规划 马跳象棋"></a>动态规划 马跳象棋</h2><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210119181235.png" srcset="/img/loading.gif" alt="暴力"></p>
<blockquote>
<p>9、10为棋盘的宽高</p>
</blockquote>
<p>改dp：</p>
<p>k == 0时，x = 0，y = 0才为 1，其他都为0</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210119181921.png" srcset="/img/loading.gif" alt="0,0,0"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210119182602.png" srcset="/img/loading.gif" alt="dp"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210119182639.png" srcset="/img/loading.gif" alt="dp"></p>
<h1 id="类似斐波那契数列"><a href="#类似斐波那契数列" class="headerlink" title="类似斐波那契数列"></a>类似斐波那契数列</h1><h2 id="优化原理"><a href="#优化原理" class="headerlink" title="优化原理"></a>优化原理</h2><ul>
<li><p>可以优化为 O(Log(N))的解法：快速幂</p>
<ul>
<li><p>斐波那契数列的线性求解（O(N)）的方式非常好理解</p>
</li>
<li><p>同时利用线性代数，也可以改写出另一种表示</p>
<p> | F(N) , F(N-1) | = | F(2), F(1) |  *  某个二阶矩阵的N-2次方</p>
<p>求出这个二阶矩阵，进而最快求出这个二阶矩阵的N-2次方</p>
</li>
</ul>
</li>
</ul>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210316145619.png" srcset="/img/loading.gif" alt="行列式"></p>
<p>第三项和第二项组成的行列式 等于 第二项和第一项的行列式乘以一个abcd的矩阵</p>
<p>第四项和第三项组成的行列式 等于 第三项和第二项的行列式乘以一个同样是abcd的矩阵</p>
<p>后面跟着的二阶矩阵是 <strong>同一个</strong> </p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210318095005.png" srcset="/img/loading.gif" alt="关系"></p>
<p>再根据下一组数据得到a=b=c=1,d=0</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210318095506.png" srcset="/img/loading.gif" alt="最终结论"></p>
<p>F2和F1分别为1，1；所以后面的矩阵算得快慢等于算法算得快慢</p>
<blockquote>
<p>先解决一个数字的次方怎么算得快？</p>
</blockquote>
<p>例如10^75次方，75拆成2进制形式，75 = 1001011</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210318100134.png" srcset="/img/loading.gif" alt="方法"></p>
<p>结果为res，先取1相乘，取t等于10^1，每次t与自己相乘，75二进制有1，乘到res里面，</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210318100333.png" srcset="/img/loading.gif" alt="进入res的数"></p>
<p>Log2(75)</p>
<blockquote>
<p>反思矩阵</p>
</blockquote>
<p>res开始为单位矩阵，对角线为1，其他全为0，</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210318100618.png" srcset="/img/loading.gif" alt="方法"></p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// 矩阵乘法</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">f3</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">1</span>) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
   &#125;
   <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span> || n == <span class="hljs-number">2</span>) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
   &#125;
   <span class="hljs-comment">// [ 1 ,1 ]</span>
   <span class="hljs-comment">// [ 1, 0 ]</span>
   <span class="hljs-keyword">int</span>[][] base = &#123;
         &#123; <span class="hljs-number">1</span>, <span class="hljs-number">1</span> &#125;,
         &#123; <span class="hljs-number">1</span>, <span class="hljs-number">0</span> &#125;
         &#125;;
   <span class="hljs-comment">// 求矩阵n-2次方</span>
   <span class="hljs-keyword">int</span>[][] res = matrixPower(base, n - <span class="hljs-number">2</span>);
   <span class="hljs-keyword">return</span> res[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] + res[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>];
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[][] matrixPower(<span class="hljs-keyword">int</span>[][] m, <span class="hljs-keyword">int</span> p) &#123;
   <span class="hljs-keyword">int</span>[][] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m.length][m[<span class="hljs-number">0</span>].length];
   <span class="hljs-comment">// res初始为单位矩阵</span>
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; res.length; i++) &#123;
      res[i][i] = <span class="hljs-number">1</span>;
   &#125;
   <span class="hljs-comment">// res = 矩阵中的1</span>

   <span class="hljs-keyword">int</span>[][] tmp = m;<span class="hljs-comment">// 矩阵1次方 t^1</span>
   <span class="hljs-comment">// 次方每次右移一位，直到为0</span>
   <span class="hljs-keyword">for</span> (; p != <span class="hljs-number">0</span>; p &gt;&gt;= <span class="hljs-number">1</span>) &#123;
      <span class="hljs-comment">// 1为 00000000000001</span>
      <span class="hljs-keyword">if</span> ((p &amp; <span class="hljs-number">1</span>) != <span class="hljs-number">0</span>) &#123;
         res = muliMatrix(res, tmp);
      &#125;
      <span class="hljs-comment">// t*t</span>
      tmp = muliMatrix(tmp, tmp);
   &#125;
   <span class="hljs-keyword">return</span> res;
&#125;
<span class="hljs-comment">// 两个矩阵相乘结果返回</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[][] muliMatrix(<span class="hljs-keyword">int</span>[][] m1, <span class="hljs-keyword">int</span>[][] m2) &#123;
   <span class="hljs-keyword">int</span>[][] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m1.length][m2[<span class="hljs-number">0</span>].length];
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m1.length; i++) &#123;
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; m2[<span class="hljs-number">0</span>].length; j++) &#123;
         <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; m2.length; k++) &#123;
            res[i][j] += m1[i][k] * m2[k][j];
         &#125;
      &#125;
   &#125;
   <span class="hljs-keyword">return</span> res;
&#125;</code></pre></div>



<h2 id="推广"><a href="#推广" class="headerlink" title="推广"></a>推广</h2><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210318102323.png" srcset="/img/loading.gif" alt="递推式"></p>
<p>C1,c2,c3…cz只要是常数，都有logn的解</p>
<p>如果某个递归，除了初始项之外，具有如下的形式</p>
<ul>
<li>F(N) = C1 * F(N) + C2 * F(N-1) + … + Ck * F(N-k) ( C1…Ck 和k都是常数)</li>
<li>并且这个递归的表达式是 <strong>严格的、不随条件转移的</strong> </li>
<li>那么都存在类似斐波那契数列的优化，时间复杂度都能优化成O(logN)</li>
</ul>
<h2 id="奶牛问题"><a href="#奶牛问题" class="headerlink" title="奶牛问题"></a>奶牛问题</h2><p>第一年农场有1只成熟的母牛A，往后的每年：</p>
<p>1）每一只成熟的母牛都会生一只母牛</p>
<p>2）每一只新出生的母牛都在出生后的第三年成熟</p>
<p>3）每一只母牛永远不会死</p>
<p>返回N年后牛的数量</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210318103032.png" srcset="/img/loading.gif" alt="牛"></p>
<p>f（n-1）为去年牛数量，f（n-3）为三年前新出生的牛</p>
<p>很明显是一个三阶问题：</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210318103243.png" srcset="/img/loading.gif" alt="三阶"></p>
<p>三阶问题求解方式：</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210318103309.png" srcset="/img/loading.gif" alt="求解"></p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">c1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">1</span>) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
   &#125;
   <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span> || n == <span class="hljs-number">2</span> || n == <span class="hljs-number">3</span>) &#123;
      <span class="hljs-keyword">return</span> n;
   &#125;
   <span class="hljs-keyword">return</span> c1(n - <span class="hljs-number">1</span>) + c1(n - <span class="hljs-number">3</span>);
&#125;

<span class="hljs-comment">// 矩阵方法</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">c3</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">1</span>) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
   &#125;
   <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span> || n == <span class="hljs-number">2</span> || n == <span class="hljs-number">3</span>) &#123;
      <span class="hljs-keyword">return</span> n;
   &#125;
   <span class="hljs-keyword">int</span>[][] base = &#123; &#123; <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span> &#125;, &#123; <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span> &#125;, &#123; <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span> &#125; &#125;;
   <span class="hljs-keyword">int</span>[][] res = matrixPower(base, n - <span class="hljs-number">3</span>);
   <span class="hljs-keyword">return</span> <span class="hljs-number">3</span> * res[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] + <span class="hljs-number">2</span> * res[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + res[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>];
&#125;</code></pre></div>

<blockquote>
<p>如果母牛十年后会死呢？</p>
</blockquote>
<p>递推式减去f(n-10)</p>
<h2 id="迈楼梯问题"><a href="#迈楼梯问题" class="headerlink" title="迈楼梯问题"></a>迈楼梯问题</h2><p>一个人可以一次往上迈1个台阶，也可以迈2个台阶</p>
<p>返回这个人迈上N级台阶的方法数</p>
<p>迈一层方法数为1，迈两层方法数为2，迈三层为f(1)+f(2);迈n层为f(n-1)+f(n-2)</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">s1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">1</span>) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
   &#125;
   <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span> || n == <span class="hljs-number">2</span>) &#123;
      <span class="hljs-keyword">return</span> n;
   &#125;
   <span class="hljs-keyword">return</span> s1(n - <span class="hljs-number">1</span>) + s1(n - <span class="hljs-number">2</span>);
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">s3</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">1</span>) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
   &#125;
   <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span> || n == <span class="hljs-number">2</span>) &#123;
      <span class="hljs-keyword">return</span> n;
   &#125;
   <span class="hljs-keyword">int</span>[][] base = &#123; &#123; <span class="hljs-number">1</span>, <span class="hljs-number">1</span> &#125;, &#123; <span class="hljs-number">1</span>, <span class="hljs-number">0</span> &#125; &#125;;
   <span class="hljs-keyword">int</span>[][] res = matrixPower(base, n - <span class="hljs-number">2</span>);
   <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * res[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] + res[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>];
&#125;</code></pre></div>

<p>其他：</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210318104617.png" srcset="/img/loading.gif" alt="迈五步"></p>
<h2 id="01字符串"><a href="#01字符串" class="headerlink" title="01字符串"></a>01字符串</h2><p>给定一个数N，想象只由0和1两种字符，组成的所有长度为N的字符串</p>
<p>如果某个字符串,任何0字符的左边都有1紧挨着,认为这个字符串达标</p>
<p>返回有多少达标的字符串</p>
<p>定义一个递归 f(i): <strong>表示字符串为i长度，规定其i长度外左边必有一个1，求f(i)可以达标数</strong> </p>
<p>N = 8时候，求f（7）即可</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210318110045.png" srcset="/img/loading.gif" alt="解法"></p>
<p>f（i） = f（i-1） + f（i-2）</p>
<h2 id="铺瓷砖问题"><a href="#铺瓷砖问题" class="headerlink" title="铺瓷砖问题"></a>铺瓷砖问题</h2><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210318110254.png" srcset="/img/loading.gif" alt="填满方法"></p>
<p>就看左上角瓷砖怎么摆</p>
<p>定义函数f(n)如果还有n列没有填满，返回方法数</p>
<p>如果一开始就竖着摆放：f(n-1)种</p>
<p>如果一开始就横着摆:只能再用一个瓷砖填满 ;</p>
<p>所以：f(n) = f(n-1) + f(n-2)</p>
<h1 id="bfprt算法与蓄水池算法"><a href="#bfprt算法与蓄水池算法" class="headerlink" title="bfprt算法与蓄水池算法"></a>bfprt算法与蓄水池算法</h1><h2 id="bfprt"><a href="#bfprt" class="headerlink" title="bfprt"></a>bfprt</h2><h2 id="笔试推荐-改写快排"><a href="#笔试推荐-改写快排" class="headerlink" title="笔试推荐 改写快排"></a>笔试推荐 改写快排</h2><p>注：bfprt笔试不用，已经有更好的替代。</p>
<p>解答问题：在一个无序数组中，怎么求第 k 小的数？ O(N)拿下</p>
<p>可以用 <strong>快排</strong> 的思想解决</p>
<p>随机选一个m，找命中k的一侧，快排两侧都要排</p>
<p>为什么是O(N)?</p>
<p>如果m打的非常正，在中间，下一次只需要划分一半，所以 T(n) = T(n/2) + O(n) 用公式求收敛于O(n)</p>
<p>如果m打的非常不正，在最边上，T(n) = T (n - 1) + O(n) 是O(n^2)的</p>
<p>因为随机，所以的概率事件，用表达式收敛，还是收敛于O(n)</p>
<p>笔试code:</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// 改写快排，时间复杂度O(N)</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minKth2</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] array, <span class="hljs-keyword">int</span> k)</span> </span>&#123;
   <span class="hljs-keyword">int</span>[] arr = copyArray(array);
   <span class="hljs-keyword">return</span> process2(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>, k - <span class="hljs-number">1</span>);
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] copyArray(<span class="hljs-keyword">int</span>[] arr) &#123;
   <span class="hljs-keyword">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[arr.length];
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i != ans.length; i++) &#123;
      ans[i] = arr[i];
   &#125;
   <span class="hljs-keyword">return</span> ans;
&#125;
<span class="hljs-comment">// 在arr[L..R]范围上，如果排序的话，找位于index位置的数</span>
<span class="hljs-comment">// index一定在[L...R]上</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">process2</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R, <span class="hljs-keyword">int</span> index)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (L == R) &#123;
      <span class="hljs-keyword">return</span> arr[L];
   &#125;
   <span class="hljs-comment">// 等概率随机选一个值作划分</span>
   <span class="hljs-keyword">int</span> pivot = arr[L + (<span class="hljs-keyword">int</span>) (Math.random() * (R - L + <span class="hljs-number">1</span>))];
   <span class="hljs-comment">// range[0] range[1]</span>
   <span class="hljs-comment">// L...R pivot在范围上的左边界和右边界</span>
   <span class="hljs-keyword">int</span>[] range = partition(arr, L, R, pivot);
   <span class="hljs-keyword">if</span> (index &gt;= range[<span class="hljs-number">0</span>] &amp;&amp; index &lt;= range[<span class="hljs-number">1</span>]) &#123;
      <span class="hljs-keyword">return</span> arr[index];
   &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (index &lt; range[<span class="hljs-number">0</span>]) &#123;
      <span class="hljs-keyword">return</span> process2(arr, L, range[<span class="hljs-number">0</span>] - <span class="hljs-number">1</span>, index);
   &#125; <span class="hljs-keyword">else</span> &#123;
      <span class="hljs-keyword">return</span> process2(arr, range[<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>, R, index);
   &#125;
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] partition(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R, <span class="hljs-keyword">int</span> pivot) &#123;
   <span class="hljs-keyword">int</span> less = L - <span class="hljs-number">1</span>;
   <span class="hljs-keyword">int</span> more = R + <span class="hljs-number">1</span>;
   <span class="hljs-keyword">int</span> cur = L;
   <span class="hljs-keyword">while</span> (cur &lt; more) &#123;
      <span class="hljs-keyword">if</span> (arr[cur] &lt; pivot) &#123;
         swap(arr, ++less, cur++);
      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[cur] &gt; pivot) &#123;
         swap(arr, cur, --more);
      &#125; <span class="hljs-keyword">else</span> &#123;
         cur++;
      &#125;
   &#125;
   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123; less + <span class="hljs-number">1</span>, more - <span class="hljs-number">1</span> &#125;;
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> i1, <span class="hljs-keyword">int</span> i2)</span> </span>&#123;
   <span class="hljs-keyword">int</span> tmp = arr[i1];
   arr[i1] = arr[i2];
   arr[i2] = tmp;
&#125;</code></pre></div>



<h2 id="bfprt是什么？"><a href="#bfprt是什么？" class="headerlink" title="bfprt是什么？"></a>bfprt是什么？</h2><p>不用概率计算，严格流程收敛于O(N)；</p>
<p>bfprt怎么选这个随机数，是很讲究的。</p>
<p>第一步：每五个数分成一组，0～4，5～9，最后不足五个凑一组</p>
<p>第二步：每组自己排序</p>
<p>第三步：每组中位数拿出来 m0，m1，m2….，最后不足就拿上中位数或下中位数，组成m数组</p>
<p>第四步：递归调用bfprt把m数组传入，找到m数组的中位数，这个数就是“天选”</p>
<p>就是把随机选择数，变成分组排序后的中位数数组取中位数</p>
<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210320144759.png" srcset="/img/loading.gif" alt="求m数组过程"></p>
<p>假设得到的c是中位数数组的中位数，一定有两个中位数大于等于c，如果整个数字个数为N，一共有N/5个中位数，一共有N/10 + (n/10) * 2 即一共  <strong>3/10倍的N</strong>  的数大于等于c</p>
<p>所以比c小的数有 7/10的N 的数，数不管在左侧还是右侧，问题只是变成至多大于等于还是小于等于m的数字有多少，反向思考至少小于或者大于的m，一定可以甩掉 3/10倍的N 的规模。</p>
<p>T(N)=O(n) + T(n/5) + T(7n/10) 数学证明为O（N）</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// 利用bfprt算法，时间复杂度O(N)</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minKth3</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] array, <span class="hljs-keyword">int</span> k)</span> </span>&#123;
   <span class="hljs-keyword">int</span>[] arr = copyArray(array);
   <span class="hljs-keyword">return</span> bfprt(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>, k - <span class="hljs-number">1</span>);
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">bfprt</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R, <span class="hljs-keyword">int</span> index)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (L == R) &#123;
      <span class="hljs-keyword">return</span> arr[L];
   &#125;
   <span class="hljs-keyword">int</span> pivot = medianOfMedians(arr, L, R);
   <span class="hljs-keyword">int</span>[] range = partition(arr, L, R, pivot);
   <span class="hljs-keyword">if</span> (index &gt;= range[<span class="hljs-number">0</span>] &amp;&amp; index &lt;= range[<span class="hljs-number">1</span>]) &#123;
      <span class="hljs-keyword">return</span> arr[index];
   &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (index &lt; range[<span class="hljs-number">0</span>]) &#123;
      <span class="hljs-keyword">return</span> bfprt(arr, L, range[<span class="hljs-number">0</span>] - <span class="hljs-number">1</span>, index);
   &#125; <span class="hljs-keyword">else</span> &#123;
      <span class="hljs-keyword">return</span> bfprt(arr, range[<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>, R, index);
   &#125;
&#125;
<span class="hljs-comment">// arr[L...R]五个一组 内部排序 得到中位数数组，求其中位数</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">medianOfMedians</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R)</span> </span>&#123;
   <span class="hljs-keyword">int</span> size = R - L + <span class="hljs-number">1</span>;
   <span class="hljs-comment">// offset表示要不要补最后一组</span>
   <span class="hljs-keyword">int</span> offset = size % <span class="hljs-number">5</span> == <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>;
   <span class="hljs-keyword">int</span>[] mArr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[size / <span class="hljs-number">5</span> + offset];
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> team = <span class="hljs-number">0</span>; team &lt; mArr.length; team++) &#123;
      <span class="hljs-keyword">int</span> teamFirst = L + team * <span class="hljs-number">5</span>;
      mArr[team] = getMedian(arr, teamFirst, Math.min(R, teamFirst + <span class="hljs-number">4</span>));
   &#125;
  <span class="hljs-comment">// 调用bfprt找到中位数数组的中位数</span>
   <span class="hljs-keyword">return</span> bfprt(mArr, <span class="hljs-number">0</span>, mArr.length - <span class="hljs-number">1</span>, mArr.length / <span class="hljs-number">2</span>);
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMedian</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R)</span> </span>&#123;
   insertionSort(arr, L, R);
   <span class="hljs-keyword">return</span> arr[(L + R) / <span class="hljs-number">2</span>];
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertionSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R)</span> </span>&#123;
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = L + <span class="hljs-number">1</span>; i &lt;= R; i++) &#123;
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i - <span class="hljs-number">1</span>; j &gt;= L &amp;&amp; arr[j] &gt; arr[j + <span class="hljs-number">1</span>]; j--) &#123;
         swap(arr, j, j + <span class="hljs-number">1</span>);
      &#125;
   &#125;
&#125;</code></pre></div>



<h3 id="bfprt应用"><a href="#bfprt应用" class="headerlink" title="bfprt应用"></a>bfprt应用</h3><p>拿一个数组前十小的数，先找第十小的数，再遍历数组</p>
<h2 id="蓄水池算法"><a href="#蓄水池算法" class="headerlink" title="蓄水池算法"></a>蓄水池算法</h2><p>一个流蓄水池，在不断吐出有编号的球，有一个只能装十个球的袋子，丢的球不能再找回，</p>
<p>要求到n号球吐出，所有球被接住的概率均等</p>
<p>流程：</p>
<p>1～10全接住，往后的每一个球出来的时候，以10/k的概率决定是否要，如果不要则丢；如果要，则等概率丢弃袋子中一个</p>
<p>例子：</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210318111942.png" srcset="/img/loading.gif" alt="例子"></p>
<p>4~10号球时，3号球在袋子里面的概率是1，当11号球到来时，以10/11的概率决定11是否入袋，并且以1/10的概率决定是否抛弃3号球，所以11号球到来后，3号球还在袋子中的概率为 1*(1-10/11乘1/10) 即为10/11</p>
<p>现在12号球到来，则为 10/11 乘 （1 * （1 - 10/12乘1/10））即为 10/12</p>
<p>所以等到17号球到来，3号球在袋子中的概率为10/17</p>
<p>怎么求当17号球到来时，13号球在袋子里的概率：</p>
<p>13号被选中为 10/13，14被选中且恰好13被踢出去为 10/14 * 1/10 </p>
<p>所以14到来，13还在的概率为 10/13 * (1 - 1/14) 即为 10/14</p>
<p>…..</p>
<p>当17号球到来时，13号球在袋子里为10/17</p>
<h3 id="蓄水池举例"><a href="#蓄水池举例" class="headerlink" title="蓄水池举例"></a>蓄水池举例</h3><p>如果有一个游戏公司，上10亿个用户，抽取100个当天登录的幸运儿：</p>
<p>传统方式：当天登录记录，去重，抽取100个；</p>
<p>蓄水池方式：取一个能装载100个用户的服务器，当当天每个用户登录时，先判断是否为第一次登录，再写一个方法，确定今天第几个登录的用户，概率就是 100/第几个登录，再利用蓄水池算法剔除，最后公布100人</p>
<h3 id="1～10概率问题"><a href="#1～10概率问题" class="headerlink" title="1～10概率问题"></a>1～10概率问题</h3><p>已知有一个黑盒，能返回1～7等概率，要求加工，使1～10也能等概率：</p>
<p>1～7如果roll到7，剔除，认为1～3为roll到0，4～6位roll到1；</p>
<p>用二进制位表示数，黑盒roll四次能保证0～15等概率；剔除10～15，重做。</p>
<p>roll出0～9就等于roll出1～10</p>
<h3 id="01概率问题"><a href="#01概率问题" class="headerlink" title="01概率问题"></a>01概率问题</h3><p>假设roll 0的概率为p，roll 1的概率为 1 - p</p>
<p>怎么roll 0，1等概率？</p>
<p>roll两次，出00和11淘汰，出01和10分别代表一个</p>
<h1 id="KMP算法及其扩展"><a href="#KMP算法及其扩展" class="headerlink" title="KMP算法及其扩展"></a>KMP算法及其扩展</h1><blockquote>
<p>思考</p>
</blockquote>
<p>假设字符串str长度为N，字符串match长度为M，M &lt;= N</p>
<p>想确定str中是否有某个 <strong>子串是等于match的</strong> 。</p>
<p>时间复杂度 <strong>O(N)</strong> </p>
<p>int f(str, match) 返回包含的开始位置</p>
<p> <strong>子串</strong> 一定是要求连续的</p>
<p>KMP算法思路仍是试每一个位置，只不过有加速。每一个位置有一个 <strong>指标</strong> ，讨论的是之前的字符串中，前缀跟后缀的 <strong>最长匹配长度</strong> 。</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210319141309.png" srcset="/img/loading.gif" alt="匹配"></p>
<p>还需要长度为4、5，不取到整体，求 <strong>相等的最大长度值为指标值</strong> 。</p>
<p>设立一个 <strong>next数组</strong> ，保存match的信息。</p>
<p>0位置信息规定为-1，1位置信息规定为0；</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210319142245.png" srcset="/img/loading.gif" alt="信息"></p>
<p>接下来用next数组加速匹配：</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210319142745.png" srcset="/img/loading.gif" alt="传统"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210319143217.png" srcset="/img/loading.gif" alt="KMP"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210319143950.png" srcset="/img/loading.gif" alt="例子"></p>
<blockquote>
<p>为什么最长前后缀之前不能配出match？</p>
</blockquote>
<p>假设可以，会得出match最后不等字符之前的最长相等前后缀长度值与得到的实际值不一致的矛盾。</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210319150718.png" srcset="/img/loading.gif" alt="流程"></p>
<h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>先对while循环进行分析，只需要分析进去while循环多少次</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210320105747.png" srcset="/img/loading.gif" alt="while"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210320105701.png" srcset="/img/loading.gif" alt="分析"></p>
<p>我们设立两个参数，第一个参数就是while中的x，最大能达到N；第二个参数为x - y，最大也只能达到n；</p>
<p>当命中第一条分支时，x上升，x - y不变；</p>
<p>以此类推，两个量最大只能达到 2N</p>
<h2 id="next数组生成"><a href="#next数组生成" class="headerlink" title="next数组生成"></a>next数组生成</h2><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210320111351.png" srcset="/img/loading.gif" alt="第一步"></p>
<p>如果相等就直接等于next[i - 1] + 1了</p>
<p>如果不等于：</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210320111604.png" srcset="/img/loading.gif" alt="不等"></p>
<p>上图打错，是 s位置的值加一</p>
<h2 id="总体算法"><a href="#总体算法" class="headerlink" title="总体算法"></a>总体算法</h2><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getIndexOf</span><span class="hljs-params">(String s, String m)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (s == <span class="hljs-keyword">null</span> || m == <span class="hljs-keyword">null</span> || m.length() &lt; <span class="hljs-number">1</span> || s.length() &lt; m.length()) &#123;
      <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
   &#125;
   <span class="hljs-keyword">char</span>[] str = s.toCharArray();
   <span class="hljs-keyword">char</span>[] match = m.toCharArray();
   <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;<span class="hljs-comment">// str中比对到的位置</span>
   <span class="hljs-keyword">int</span> y = <span class="hljs-number">0</span>;<span class="hljs-comment">// match中比对到的位置</span>
   <span class="hljs-keyword">int</span>[] next = getNextArray(match);
   <span class="hljs-keyword">while</span> (x &lt; str.length &amp;&amp; y &lt; match.length) &#123;
      <span class="hljs-keyword">if</span> (str[x] == match[y]) &#123;
         x++;
         y++;
      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (next[y] == -<span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 或者y == 0</span>
         x++;
      &#125; <span class="hljs-keyword">else</span> &#123;
         y = next[y];
      &#125;
   &#125;
   <span class="hljs-keyword">return</span> y == match.length ? x - y : -<span class="hljs-number">1</span>;
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] getNextArray(<span class="hljs-keyword">char</span>[] ms) &#123;
   <span class="hljs-keyword">if</span> (ms.length == <span class="hljs-number">1</span>) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123; -<span class="hljs-number">1</span> &#125;;
   &#125;
   <span class="hljs-keyword">int</span>[] next = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[ms.length];
   next[<span class="hljs-number">0</span>] = -<span class="hljs-number">1</span>;
   next[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;
   <span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>;
   <span class="hljs-comment">// cn代表，cn位置的字符，是当前和i-1位置比较的字符</span>
   <span class="hljs-keyword">int</span> cn = <span class="hljs-number">0</span>;
   <span class="hljs-keyword">while</span> (i &lt; next.length) &#123;
      <span class="hljs-keyword">if</span> (ms[i - <span class="hljs-number">1</span>] == ms[cn]) &#123;
         next[i++] = ++cn;
         <span class="hljs-comment">// ++cn的值必定是next[i-1]的值</span>
      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cn &gt; <span class="hljs-number">0</span>) &#123;
         cn = next[cn];
      &#125; <span class="hljs-keyword">else</span> &#123;
         next[i++] = <span class="hljs-number">0</span>;
      &#125;
   &#125;
   <span class="hljs-keyword">return</span> next;
&#125;</code></pre></div>

<p>利用分析上面while循环复杂度的方法分析next生成复杂度</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210320113033.png" srcset="/img/loading.gif" alt="复杂度"></p>
<h2 id="indexOf方法"><a href="#indexOf方法" class="headerlink" title="indexOf方法"></a>indexOf方法</h2><p>indexlof方法后台不是kmp，是比kmp拥有给小的常数的算法，时间复杂度也是O(N)</p>
<h2 id="KMP应用"><a href="#KMP应用" class="headerlink" title="KMP应用"></a>KMP应用</h2><h3 id="旋转词问题"><a href="#旋转词问题" class="headerlink" title="旋转词问题"></a>旋转词问题</h3><p>给定一个str1和str2，判断是否互为旋转词</p>
<blockquote>
<p>旋转词定义</p>
</blockquote>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210320115002.png" srcset="/img/loading.gif" alt="旋转词"></p>
<p>方法：</p>
<p>给str1增加一倍，查str2是否为子串</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210320115412.png" srcset="/img/loading.gif" alt="方法"></p>
<p>str1增加一倍从任何地方开头，长度为str1的串，一定是str1的旋转词</p>
<h3 id="二叉树子树问题"><a href="#二叉树子树问题" class="headerlink" title="二叉树子树问题"></a>二叉树子树问题</h3><p>给定两棵二叉树的头节点head1和head2</p>
<p>想知道head1中是否有某个子树的结构和head2完全一样</p>
<p>解法：先序序列化二叉树，找是否包含子串</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210320121908.png" srcset="/img/loading.gif" alt="要包含null"></p>
<p>因为先序序列化一个子串只代表一个结构，没有歧义</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> value;
   <span class="hljs-keyword">public</span> Node left;
   <span class="hljs-keyword">public</span> Node right;

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v)</span> </span>&#123;
      value = v;
   &#125;
&#125;

<span class="hljs-comment">// 暴力 big做头节点的树，其中是否有某颗子树的结构和small为头的树完全一样</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">containsTree1</span><span class="hljs-params">(Node big, Node small)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (small == <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
   &#125;
   <span class="hljs-keyword">if</span> (big == <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
   &#125;
   <span class="hljs-keyword">if</span> (isSameValueStructure(big, small)) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
   &#125;
   <span class="hljs-keyword">return</span> containsTree1(big.left, small) || containsTree1(big.right, small);
&#125;

<span class="hljs-comment">// head1为头的树是否在结构上完全和head2一样</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSameValueStructure</span><span class="hljs-params">(Node head1, Node head2)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (head1 == <span class="hljs-keyword">null</span> &amp;&amp; head2 != <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
   &#125;
   <span class="hljs-keyword">if</span> (head1 != <span class="hljs-keyword">null</span> &amp;&amp; head2 == <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
   &#125;
   <span class="hljs-keyword">if</span> (head1 == <span class="hljs-keyword">null</span> &amp;&amp; head2 == <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
   &#125;
   <span class="hljs-keyword">if</span> (head1.value != head2.value) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
   &#125;
   <span class="hljs-comment">// 1 2有值</span>
   <span class="hljs-comment">// 1左树等于2左树</span>
   <span class="hljs-keyword">return</span> isSameValueStructure(head1.left, head2.left) &amp;&amp; isSameValueStructure(head1.right, head2.right);
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">containsTree2</span><span class="hljs-params">(Node big, Node small)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (small == <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
   &#125;
   <span class="hljs-keyword">if</span> (big == <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
   &#125;
   <span class="hljs-comment">// 先序 含空的</span>
   ArrayList&lt;String&gt; b = preSerial(big);
   ArrayList&lt;String&gt; s = preSerial(small);
   String[] str = <span class="hljs-keyword">new</span> String[b.size()];
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; str.length; i++) &#123;
      str[i] = b.get(i);
   &#125;

   String[] match = <span class="hljs-keyword">new</span> String[s.size()];
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; match.length; i++) &#123;
      match[i] = s.get(i);
   &#125;
   <span class="hljs-keyword">return</span> getIndexOf(str, match) != -<span class="hljs-number">1</span>;
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ArrayList&lt;String&gt; <span class="hljs-title">preSerial</span><span class="hljs-params">(Node head)</span> </span>&#123;
   ArrayList&lt;String&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
   pres(head, ans);
   <span class="hljs-keyword">return</span> ans;
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pres</span><span class="hljs-params">(Node head, ArrayList&lt;String&gt; ans)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;
      ans.add(<span class="hljs-keyword">null</span>);
   &#125; <span class="hljs-keyword">else</span> &#123;
      ans.add(String.valueOf(head.value));
      pres(head.left, ans);
      pres(head.right, ans);
   &#125;
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getIndexOf</span><span class="hljs-params">(String[] str1, String[] str2)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (str1 == <span class="hljs-keyword">null</span> || str2 == <span class="hljs-keyword">null</span> || str1.length &lt; <span class="hljs-number">1</span> || str1.length &lt; str2.length) &#123;
      <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
   &#125;
   <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;
   <span class="hljs-keyword">int</span> y = <span class="hljs-number">0</span>;
   <span class="hljs-keyword">int</span>[] next = getNextArray(str2);
   <span class="hljs-keyword">while</span> (x &lt; str1.length &amp;&amp; y &lt; str2.length) &#123;
      <span class="hljs-keyword">if</span> (isEqual(str1[x], str2[y])) &#123;
         x++;
         y++;
      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (next[y] == -<span class="hljs-number">1</span>) &#123;
         x++;
      &#125; <span class="hljs-keyword">else</span> &#123;
         y = next[y];
      &#125;
   &#125;
   <span class="hljs-keyword">return</span> y == str2.length ? x - y : -<span class="hljs-number">1</span>;
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] getNextArray(String[] ms) &#123;
   <span class="hljs-keyword">if</span> (ms.length == <span class="hljs-number">1</span>) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123; -<span class="hljs-number">1</span> &#125;;
   &#125;
   <span class="hljs-keyword">int</span>[] next = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[ms.length];
   next[<span class="hljs-number">0</span>] = -<span class="hljs-number">1</span>;
   next[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;
   <span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>;
   <span class="hljs-keyword">int</span> cn = <span class="hljs-number">0</span>;
   <span class="hljs-keyword">while</span> (i &lt; next.length) &#123;
      <span class="hljs-keyword">if</span> (isEqual(ms[i - <span class="hljs-number">1</span>], ms[cn])) &#123;
         next[i++] = ++cn;
      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cn &gt; <span class="hljs-number">0</span>) &#123;
         cn = next[cn];
      &#125; <span class="hljs-keyword">else</span> &#123;
         next[i++] = <span class="hljs-number">0</span>;
      &#125;
   &#125;
   <span class="hljs-keyword">return</span> next;
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEqual</span><span class="hljs-params">(String a, String b)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (a == <span class="hljs-keyword">null</span> &amp;&amp; b == <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
   &#125; <span class="hljs-keyword">else</span> &#123;
      <span class="hljs-keyword">if</span> (a == <span class="hljs-keyword">null</span> || b == <span class="hljs-keyword">null</span>) &#123;
         <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
      &#125; <span class="hljs-keyword">else</span> &#123;
         <span class="hljs-keyword">return</span> a.equals(b);
      &#125;
   &#125;
&#125;</code></pre></div>

<p>改成数组形式，防止歧义：</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210320122739.png" srcset="/img/loading.gif" alt="防止歧义"></p>
<h1 id="Manacher算法及其扩展"><a href="#Manacher算法及其扩展" class="headerlink" title="Manacher算法及其扩展"></a>Manacher算法及其扩展</h1><p>假设字符串str长度为N，想返回最长回文子串的长度</p>
<p>时间复杂度O(N)</p>
<p>如果暴力定位字符左右两边扩的话，可能会遗失 “虚轴”</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210321121046.png" srcset="/img/loading.gif" alt="虚轴"></p>
<p>暴力定位要变成下面样子：</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210321121544.png" srcset="/img/loading.gif"></p>
<p>暴力法最差情况就是全都是一种字符，每次都要扩到一个边界</p>
<p>前一半是一个等差数列，后一半也是，所以是O(N^2)</p>
<h2 id="算法概念"><a href="#算法概念" class="headerlink" title="算法概念"></a>算法概念</h2><h3 id="0、回文半径、直径、区域"><a href="#0、回文半径、直径、区域" class="headerlink" title="0、回文半径、直径、区域"></a>0、回文半径、直径、区域</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210322112218.png" srcset="/img/loading.gif" alt="回文"></p>
<h3 id="1、回文半径数组-parr"><a href="#1、回文半径数组-parr" class="headerlink" title="1、回文半径数组(parr)"></a>1、回文半径数组(parr)</h3><p>前面每一步求出来的答案求加速</p>
<h3 id="2、回文最右右边界-int-R"><a href="#2、回文最右右边界-int-R" class="headerlink" title="2、回文最右右边界(int R)"></a>2、回文最右右边界(int R)</h3><h3 id="3、中心-int-c"><a href="#3、中心-int-c" class="headerlink" title="3、中心(int c)"></a>3、中心(int c)</h3><p>R和C是一组概念，一开始可以认为R C 为-1，没有意义</p>
<p>拿 #1#2#2#1#…..举例子</p>
<p>扩到第一个#时候，位置为0，回文区域最右侧到0，比-1大，更新；R更新时，谁让他更新的，就是C，此时为0</p>
<p>扩到第一个1时候，区域为#1#，右边界2位置，R更新为2；1让R更新，C为1；</p>
<h2 id="算法过程"><a href="#算法过程" class="headerlink" title="算法过程"></a>算法过程</h2><p>假设当前处于i位置</p>
<ol>
<li>i在R外</li>
</ol>
<ul>
<li>没有任何优化，暴力过程，比较i-1，i-2……</li>
</ul>
<ol start="2">
<li>i在R内，压线也算</li>
</ol>
<ul>
<li>一定存在i在C和R位置之间</li>
<li><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210322114003.png" srcset="/img/loading.gif" alt="一定存在i&#39;"></li>
<li>再细分对称点，对称点一定是已经求得答案了<ul>
<li>i’自己的回文区域彻底在L..R大范围的内部，答案 <strong>和i’一样</strong> <ul>
<li><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210322114447.png" srcset="/img/loading.gif" alt="内部"></li>
<li>如上图，为什么不会有更大区域，因为上图i’旁边的b等于i右边的b；s等于左边的s，但b不等于s，所以就是这么宽的区域</li>
</ul>
</li>
<li>i’自己的回文区域彻底在L..R大范围的外部，<strong>完全不用扩，i到R位置就是新区域</strong> <ul>
<li><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210322115624.png" srcset="/img/loading.gif" alt="在外"></li>
<li>以k为中心的只能扩到右边Y左边，i’能扩到外面，但i不能，i外面和a一定不等，不在回文内部</li>
</ul>
</li>
<li>i’自己的回文区域和L压线，可能更长，<strong>需要从R后面的字符和C相不相等</strong> <ul>
<li><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210322120612.png" srcset="/img/loading.gif" alt="压线"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="分支限定"><a href="#分支限定" class="headerlink" title="分支限定"></a>分支限定</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210322165919.png" srcset="/img/loading.gif" alt="分支"></p>
<p>假定R分析四个分支：</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210322165735.png" srcset="/img/loading.gif" alt="分析"></p>
<p>R最多跑到N，所以manacher一定是O(N)的算法</p>
<h2 id="总体算法-1"><a href="#总体算法-1" class="headerlink" title="总体算法"></a>总体算法</h2><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">manacher</span><span class="hljs-params">(String s)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (s == <span class="hljs-keyword">null</span> || s.length() == <span class="hljs-number">0</span>) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
   &#125;
   <span class="hljs-keyword">char</span>[] str = manacherString(s);
   <span class="hljs-comment">// 回文半径的大小</span>
   <span class="hljs-keyword">int</span>[] pArr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[str.length];
   <span class="hljs-keyword">int</span> C = -<span class="hljs-number">1</span>;
   <span class="hljs-keyword">int</span> R = -<span class="hljs-number">1</span>;<span class="hljs-comment">// 课上：R代表最右的扩成功的位置。代码中：最右的扩成功位置的，再下一个位置</span>
   <span class="hljs-keyword">int</span> max = Integer.MIN_VALUE;
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i != str.length; i++) &#123;
      <span class="hljs-comment">// R是第一个违规的位置 i&gt;=R就相当于第一个分支 i在R外 i至少不用验的区域是自己这个字符 为1</span>
      <span class="hljs-comment">// pArr[i] 初始表示不用验证的区域</span>
      <span class="hljs-comment">// i位置扩出来的答案，i位置扩的区域，至少是多大。</span>
      <span class="hljs-comment">// 如果R &gt; i 包括了i&#x27;区域在里面和在外面</span>
      pArr[i] = R &gt; i ? Math.min(pArr[<span class="hljs-number">2</span> * C - i], R - i) : <span class="hljs-number">1</span>;

      <span class="hljs-keyword">while</span> (i + pArr[i] &lt; str.length &amp;&amp; i - pArr[i] &gt; -<span class="hljs-number">1</span>) &#123;
         <span class="hljs-comment">// 向左向右扩充</span>
         <span class="hljs-comment">// 情况2情况3直接进while就退出</span>
         <span class="hljs-keyword">if</span> (str[i + pArr[i]] == str[i - pArr[i]])
            pArr[i]++;
         <span class="hljs-keyword">else</span> &#123;
            <span class="hljs-keyword">break</span>;
         &#125;
      &#125;

      <span class="hljs-keyword">if</span> (i + pArr[i] &gt; R) &#123;
         <span class="hljs-comment">// i位置扩出来的答案 如果刷新了R 就更新并记录中心</span>
         R = i + pArr[i];
         C = i;
      &#125;
      max = Math.max(max, pArr[i]);
   &#125;
   <span class="hljs-comment">// #1#2#1# 半径 4 - 1 （该算法记录半径）</span>
   <span class="hljs-comment">// #1#2#1# 直径 7/2</span>
   <span class="hljs-keyword">return</span> max - <span class="hljs-number">1</span>;
&#125;
<span class="hljs-comment">// 前后加 #</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">char</span>[] manacherString(String str) &#123;
   <span class="hljs-keyword">char</span>[] charArr = str.toCharArray();
   <span class="hljs-keyword">char</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[str.length() * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>];
   <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i != res.length; i++) &#123;
      res[i] = (i &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span> ? <span class="hljs-string">&#x27;#&#x27;</span> : charArr[index++];
   &#125;
   <span class="hljs-keyword">return</span> res;
&#125;</code></pre></div>



<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>给定字符串str，让字符串整体变成回文串，只能在后面添加字符，求添加最短字符数。</p>
<blockquote>
<p>思考：实际是求什么</p>
</blockquote>
<p> <strong>必须包含最后一个字符的回文串有多长</strong> </p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210322172919.png" srcset="/img/loading.gif" alt="解"></p>
<p>然后把不是的逆序，就是答案</p>
<p>找到 <strong>最左侧</strong> 哪个字符位置能包含住最后一个字符。</p>
<p>或者直接得到全部的回文半径数组。</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">shortestEnd</span><span class="hljs-params">(String str)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (str == <span class="hljs-keyword">null</span> || str.length() == <span class="hljs-number">0</span>) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
   &#125;
   <span class="hljs-keyword">char</span>[] charArr = manacherString(str);
   <span class="hljs-keyword">int</span>[] pArr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[charArr.length];
   <span class="hljs-keyword">int</span> C = -<span class="hljs-number">1</span>;
   <span class="hljs-keyword">int</span> R = -<span class="hljs-number">1</span>;
   <span class="hljs-keyword">int</span> maxContainsEnd = -<span class="hljs-number">1</span>;
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i != charArr.length; i++) &#123;
      pArr[i] = R &gt; i ? Math.min(pArr[<span class="hljs-number">2</span> * C - i], R - i) : <span class="hljs-number">1</span>;
      <span class="hljs-keyword">while</span> (i + pArr[i] &lt; charArr.length &amp;&amp; i - pArr[i] &gt; -<span class="hljs-number">1</span>) &#123;
         <span class="hljs-keyword">if</span> (charArr[i + pArr[i]] == charArr[i - pArr[i]])
            pArr[i]++;
         <span class="hljs-keyword">else</span> &#123;
            <span class="hljs-keyword">break</span>;
         &#125;
      &#125;
      <span class="hljs-keyword">if</span> (i + pArr[i] &gt; R) &#123;
         R = i + pArr[i];
         C = i;
      &#125;
      <span class="hljs-keyword">if</span> (R == charArr.length) &#123;
         maxContainsEnd = pArr[i];
         <span class="hljs-keyword">break</span>;
      &#125;
   &#125;
   <span class="hljs-keyword">char</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[str.length() - maxContainsEnd + <span class="hljs-number">1</span>];
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; res.length; i++) &#123;
      res[res.length - <span class="hljs-number">1</span> - i] = charArr[i * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>];
   &#125;
   <span class="hljs-keyword">return</span> String.valueOf(res);
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">char</span>[] manacherString(String str) &#123;
   <span class="hljs-keyword">char</span>[] charArr = str.toCharArray();
   <span class="hljs-keyword">char</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[str.length() * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>];
   <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i != res.length; i++) &#123;
      res[i] = (i &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span> ? <span class="hljs-string">&#x27;#&#x27;</span> : charArr[index++];
   &#125;
   <span class="hljs-keyword">return</span> res;
&#125;</code></pre></div>



<h1 id="Morris遍历及其相关扩展"><a href="#Morris遍历及其相关扩展" class="headerlink" title="Morris遍历及其相关扩展"></a>Morris遍历及其相关扩展</h1><h2 id="算法概念-1"><a href="#算法概念-1" class="headerlink" title="算法概念"></a>算法概念</h2><p>一种遍历二叉树的方式，并且时间复杂度O(N)， <strong>额外空间复杂度O(1)</strong> </p>
<p>通过利用原树中大量空闲指针的方式，达到节省空间的目的</p>
<p>之前递归方法拿栈花费空间，跟高度相关，O(h)。非递归自己压栈，也是O(h)</p>
<h2 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h2><p>假设来到当前节点cur，开始时cur来到 <strong>头节点</strong> 位置</p>
<ul>
<li><ol>
<li>如果cur没有左孩子，cur向右移动(cur = cur.right)</li>
</ol>
</li>
<li><ol start="2">
<li>如果cur有左孩子，找到左子树上最右的节点mostRight：</li>
</ol>
<ul>
<li>如果mostRight的右指针指向null，让其指向cur，然后cur向左移动(cur = cur.left)</li>
<li>如果mostRight的右指针指向cur，让其指向null，然后cur向右移动(cur = cur.right)</li>
</ul>
</li>
<li><ol start="3">
<li>cur为空时遍历停止</li>
</ol>
</li>
</ul>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210323082818.png" srcset="/img/loading.gif" alt="例子"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210323083705.png" srcset="/img/loading.gif" alt="例子"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210323084354.png" srcset="/img/loading.gif" alt="例子2"></p>
<p>任何一个结点有左孩子，一定来两次；</p>
<p>没有左孩子的点，只来到一次；</p>
<h2 id="算法代码"><a href="#算法代码" class="headerlink" title="算法代码"></a>算法代码</h2><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">morrisIn</span><span class="hljs-params">(Node head)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">return</span>;
   &#125;
   Node cur = head;
   Node mostRight = <span class="hljs-keyword">null</span>;
   <span class="hljs-keyword">while</span> (cur != <span class="hljs-keyword">null</span>) &#123;

      <span class="hljs-comment">// cur 有没有左树</span>
      mostRight = cur.left;

      <span class="hljs-keyword">if</span> (mostRight != <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// 有左树情况下</span>
         <span class="hljs-comment">// 找到cur左树上真实的最右节点</span>
         <span class="hljs-keyword">while</span> (mostRight.right != <span class="hljs-keyword">null</span> &amp;&amp; mostRight.right != cur) &#123;
            mostRight = mostRight.right;
         &#125;

         <span class="hljs-comment">// 找到了mostRight</span>
         <span class="hljs-comment">// mostRight指向空</span>
         <span class="hljs-keyword">if</span> (mostRight.right == <span class="hljs-keyword">null</span>) &#123;
            mostRight.right = cur;
            cur = cur.left;
            <span class="hljs-keyword">continue</span>;
         &#125; <span class="hljs-keyword">else</span> &#123;
            <span class="hljs-comment">// mostRight指向cur</span>
            mostRight.right = <span class="hljs-keyword">null</span>;
         &#125;
      &#125;
      cur = cur.right;
   &#125;
&#125;</code></pre></div>



<h2 id="morris序实现先序中序后序"><a href="#morris序实现先序中序后序" class="headerlink" title="morris序实现先序中序后序"></a>morris序实现先序中序后序</h2><h3 id="先序"><a href="#先序" class="headerlink" title="先序"></a>先序</h3><p>第一次来到就 <strong>打印</strong> </p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">morrisPre</span><span class="hljs-params">(Node head)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">return</span>;
   &#125;
   Node cur = head;
   Node mostRight = <span class="hljs-keyword">null</span>;
   <span class="hljs-keyword">while</span> (cur != <span class="hljs-keyword">null</span>) &#123;
      mostRight = cur.left;
      <span class="hljs-keyword">if</span> (mostRight != <span class="hljs-keyword">null</span>) &#123;
         <span class="hljs-keyword">while</span> (mostRight.right != <span class="hljs-keyword">null</span> &amp;&amp; mostRight.right != cur) &#123;
            mostRight = mostRight.right;
         &#125;
         <span class="hljs-keyword">if</span> (mostRight.right == <span class="hljs-keyword">null</span>) &#123;
            mostRight.right = cur;
           <span class="hljs-comment">// 有左树就第一次打印</span>
            System.out.print(cur.value + <span class="hljs-string">&quot; &quot;</span>);
            cur = cur.left;
            <span class="hljs-keyword">continue</span>;
         &#125; <span class="hljs-keyword">else</span> &#123;
            mostRight.right = <span class="hljs-keyword">null</span>;
         &#125;
      &#125; <span class="hljs-keyword">else</span> 
        <span class="hljs-comment">// 没有左树就打印</span>
         System.out.print(cur.value + <span class="hljs-string">&quot; &quot;</span>);
      &#125;
      cur = cur.right;
   &#125;
   System.out.println();
&#125;</code></pre></div>



<h3 id="中序"><a href="#中序" class="headerlink" title="中序"></a>中序</h3><p>能回到自己两次的结点（有左树），第二次打印，不能则直接打印；</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">morrisIn</span><span class="hljs-params">(Node head)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">return</span>;
   &#125;
   Node cur = head;
   Node mostRight = <span class="hljs-keyword">null</span>;
   <span class="hljs-keyword">while</span> (cur != <span class="hljs-keyword">null</span>) &#123;
      mostRight = cur.left;
      <span class="hljs-keyword">if</span> (mostRight != <span class="hljs-keyword">null</span>) &#123; 
         <span class="hljs-keyword">while</span> (mostRight.right != <span class="hljs-keyword">null</span> &amp;&amp; mostRight.right != cur) &#123;
            mostRight = mostRight.right;
         &#125;
				<span class="hljs-comment">// 能回到自己结点两次的不打印</span>
         <span class="hljs-keyword">if</span> (mostRight.right == <span class="hljs-keyword">null</span>) &#123;
            mostRight.right = cur;
            cur = cur.left;
            <span class="hljs-keyword">continue</span>;
         &#125; <span class="hljs-keyword">else</span> &#123;
            mostRight.right = <span class="hljs-keyword">null</span>;
         &#125;
      &#125;
      System.out.print(cur.value + <span class="hljs-string">&quot; &quot;</span>);
      cur = cur.right;
   &#125;
   System.out.println();
&#125;</code></pre></div>



<h3 id="后序"><a href="#后序" class="headerlink" title="后序"></a>后序</h3><p>打印时机放到能回到自己两次，且第二次回到自己的时候；</p>
<p>打左树的右边界，逆序打印，最后打印自己的最右边界；</p>
<p>用 <strong>反转链表</strong> 打印 <strong>逆序右边界</strong> </p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210323094725.png" srcset="/img/loading.gif" alt="图解"></p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">morrisPos</span><span class="hljs-params">(Node head)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">return</span>;
   &#125;
   Node cur = head;
   Node mostRight = <span class="hljs-keyword">null</span>;
   <span class="hljs-keyword">while</span> (cur != <span class="hljs-keyword">null</span>) &#123;
      mostRight = cur.left;
      <span class="hljs-keyword">if</span> (mostRight != <span class="hljs-keyword">null</span>) &#123;
         <span class="hljs-keyword">while</span> (mostRight.right != <span class="hljs-keyword">null</span> &amp;&amp; mostRight.right != cur) &#123;
            mostRight = mostRight.right;
         &#125;
         <span class="hljs-keyword">if</span> (mostRight.right == <span class="hljs-keyword">null</span>) &#123;
            mostRight.right = cur;
            cur = cur.left;
            <span class="hljs-keyword">continue</span>;
         &#125; <span class="hljs-keyword">else</span> &#123;
            <span class="hljs-comment">// 第二次回到自己 打印左树右边界</span>
            mostRight.right = <span class="hljs-keyword">null</span>;
            printEdge(cur.left);
         &#125;
      &#125;
      cur = cur.right;
   &#125;
   <span class="hljs-comment">// 最后打印整棵树的右边界</span>
   printEdge(head);
   System.out.println();
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printEdge</span><span class="hljs-params">(Node head)</span> </span>&#123;
   Node tail = reverseEdge(head);
   Node cur = tail;
   <span class="hljs-keyword">while</span> (cur != <span class="hljs-keyword">null</span>) &#123;
      System.out.print(cur.value + <span class="hljs-string">&quot; &quot;</span>);
      cur = cur.right;
   &#125;
   reverseEdge(tail);
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">reverseEdge</span><span class="hljs-params">(Node from)</span> </span>&#123;
   Node pre = <span class="hljs-keyword">null</span>;
   Node next = <span class="hljs-keyword">null</span>;
   <span class="hljs-keyword">while</span> (from != <span class="hljs-keyword">null</span>) &#123;
      next = from.right;
      from.right = pre;
      pre = from;
      from = next;
   &#125;
   <span class="hljs-keyword">return</span> pre;
&#125;</code></pre></div>



<h2 id="isBST"><a href="#isBST" class="headerlink" title="isBST"></a>isBST</h2><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210323095917.png" srcset="/img/loading.gif" alt="isBST"></p>
<p>把打印过程变成 <strong>比较过程</strong> ；</p>
<h2 id="最小高度"><a href="#最小高度" class="headerlink" title="最小高度"></a>最小高度</h2><p>给定一棵二叉树的头节点head</p>
<p>求以head为头的树中，最小深度是多少？</p>
<h3 id="二叉树递归套路"><a href="#二叉树递归套路" class="headerlink" title="二叉树递归套路"></a>二叉树递归套路</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minHeight1</span><span class="hljs-params">(Node head)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
   &#125;
   <span class="hljs-keyword">return</span> p(head);
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">p</span><span class="hljs-params">(Node x)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (x.left == <span class="hljs-keyword">null</span> &amp;&amp; x.right == <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
   &#125;
   <span class="hljs-comment">// 左右子树起码有一个不为空</span>
   <span class="hljs-keyword">int</span> leftH = Integer.MAX_VALUE;
   <span class="hljs-keyword">if</span> (x.left != <span class="hljs-keyword">null</span>) &#123;
      leftH = p(x.left);
   &#125;
   <span class="hljs-keyword">int</span> rightH = Integer.MAX_VALUE;
   <span class="hljs-keyword">if</span> (x.right != <span class="hljs-keyword">null</span>) &#123;
      rightH = p(x.right);
   &#125;
   <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + Math.min(leftH, rightH);
&#125;</code></pre></div>



<h3 id="morris遍历求解"><a href="#morris遍历求解" class="headerlink" title="morris遍历求解"></a>morris遍历求解</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minHeight2</span><span class="hljs-params">(Node head)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
   &#125;
   Node cur = head;
   Node mostRight = <span class="hljs-keyword">null</span>;
   <span class="hljs-keyword">int</span> curLevel = <span class="hljs-number">0</span>;
   <span class="hljs-keyword">int</span> minHeight = Integer.MAX_VALUE;
   <span class="hljs-keyword">while</span> (cur != <span class="hljs-keyword">null</span>) &#123;
      mostRight = cur.left;
      <span class="hljs-keyword">if</span> (mostRight != <span class="hljs-keyword">null</span>) &#123;
         <span class="hljs-comment">// 左树上右边界点的个数</span>
         <span class="hljs-keyword">int</span> leftHeight = <span class="hljs-number">1</span>;
         <span class="hljs-keyword">while</span> (mostRight.right != <span class="hljs-keyword">null</span> &amp;&amp; mostRight.right != cur) &#123;
            leftHeight++;
            mostRight = mostRight.right;
         &#125;
         <span class="hljs-keyword">if</span> (mostRight.right == <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// 第一次到达</span>
            curLevel++;
            mostRight.right = cur;
            cur = cur.left;
            <span class="hljs-keyword">continue</span>;
         &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 第二次到达</span>
            <span class="hljs-keyword">if</span> (mostRight.left == <span class="hljs-keyword">null</span>) &#123;
               <span class="hljs-comment">// 说明是叶节点，要更新curlevel，跳到上面去了</span>
               minHeight = Math.min(minHeight, curLevel);
            &#125;
            curLevel -= leftHeight;
            mostRight.right = <span class="hljs-keyword">null</span>;
         &#125;
      &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 只有一次到达</span>
         curLevel++;
      &#125;
      cur = cur.right;
   &#125;
   <span class="hljs-keyword">int</span> finalRight = <span class="hljs-number">1</span>;
   cur = head;
   <span class="hljs-keyword">while</span> (cur.right != <span class="hljs-keyword">null</span>) &#123;
      finalRight++;
      cur = cur.right;
   &#125;
   <span class="hljs-comment">// 单独跑整棵树的最右节点</span>
   <span class="hljs-keyword">if</span> (cur.left == <span class="hljs-keyword">null</span> &amp;&amp; cur.right == <span class="hljs-keyword">null</span>) &#123;
      minHeight = Math.min(minHeight, finalRight);
   &#125;
   <span class="hljs-keyword">return</span> minHeight;
&#125;</code></pre></div>



<h1 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h1><blockquote>
<p>定义</p>
</blockquote>
<ol>
<li><p>一种支持范围整体修改和范围整体查询的数据结构</p>
</li>
<li><p>解决的问题范畴：<br>大范围信息可以只由左、右两侧信息加工出，而不必遍历左右两个子范围的具体状况</p>
</li>
</ol>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210328164125.png" srcset="/img/loading.gif" alt="线段树"></p>
<p>线段树的指标三个方法的性能达到log(n)的水平</p>
<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>给定一个数组arr，用户希望你实现如下三个方法<br>1）void add(int L, int R, int V) :  让数组arr[L…R]上每个数都加上V<br>2）void update(int L, int R, int V) :  让数组arr[L…R]上每个数都变成V<br>3）int sum(int L, int R) :让返回arr[L…R]这个范围整体的累加和<br>怎么让这三个方法，时间复杂度都是O(logN)</p>
<p class="note note-danger">注意！以下所有数组的规则规定下标从 1 开始！</p>



<h2 id="build流程"><a href="#build流程" class="headerlink" title="build流程"></a>build流程</h2><p>假设有一种“格子”可以存储位置上的信息</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210328165141.png" srcset="/img/loading.gif" alt="存取"></p>
<p>二分存储信息</p>
<p>满二叉树的情况下需要格子 2*8-1，最下面8，上面8-1</p>
<p>现在让这棵树一定变成 <strong>满二叉树</strong> ，往上构建</p>
<p>假设N个数， <strong>4N</strong> 的空间，一定足够。</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210328171024.png" srcset="/img/loading.gif" alt="数组替代"></p>
<p>i位置左孩子2i，右孩子2i+1</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210328172630.png" srcset="/img/loading.gif" alt="build"></p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// 在初始化阶段，先把sum数组，填好</span>
<span class="hljs-comment">// 在arr[l~r]范围上，去build，1~N，</span>
<span class="hljs-comment">// rt :  这个范围在sum中的下标</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> rt)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (l == r) &#123;
      sum[rt] = arr[l];
      <span class="hljs-keyword">return</span>;
   &#125;
   <span class="hljs-keyword">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;
   <span class="hljs-comment">// rt * 2 下标从1开始才可以位运算</span>
   build(l, mid, rt &lt;&lt; <span class="hljs-number">1</span>);
   <span class="hljs-comment">// rt * 2 + 1</span>
   build(mid + <span class="hljs-number">1</span>, r, rt &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>);
   pushUp(rt);
&#125;
<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pushUp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rt)</span> </span>&#123;
	 sum[rt] = sum[rt &lt;&lt; <span class="hljs-number">1</span>] + sum[rt &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>];
&#125;
</code></pre></div>



<h2 id="懒更新机制"><a href="#懒更新机制" class="headerlink" title="懒更新机制"></a>懒更新机制</h2><p>不把任务彻底下发到底</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210328180943.png" srcset="/img/loading.gif" alt="懒加载"></p>
<p>就会把1～4加入lazy</p>
<p>5~8没有包含1～6，5～6放入lazy</p>
<blockquote>
<p>为什么要设置lazy？</p>
</blockquote>
<p>假设一开始设置要让1～256加7</p>
<p>下个任务设置要1~100 加3</p>
<p>lazy发现无法覆盖，下发任务至1～128和129～256</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210328193121.png" srcset="/img/loading.gif" alt="下发"></p>
<h2 id="push-down操作"><a href="#push-down操作" class="headerlink" title="push down操作"></a>push down操作</h2><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210328194721.png" srcset="/img/loading.gif" alt="流程"></p>
<p>前面已经见过两部，左边lazy3，右边lazy4，现在新任务为1 - 1000，加5</p>
<p>直接懒住</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210328194852.png" srcset="/img/loading.gif" alt="懒更新"></p>
<p>当第四个任务 1 - 1000 加1时：</p>
<p>1～1024已经懒住一个5，会把之前 <strong>懒住的5往下发</strong> ，左边子树懒8，右边懒9</p>
<p>1-1024 lazy清空 变为0 后再懒1</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210328200909.png" srcset="/img/loading.gif" alt="当第四个任务到来时"></p>
<p>1-4懒不住</p>
<p>把lazy发下去，1-2的lazy变成7更新sum，3-4的lazy变成9更新sum</p>
<p>lazy变成0</p>
<h2 id="update"><a href="#update" class="headerlink" title="update"></a>update</h2><p>update后应该更新lazy为0</p>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SegmentTree</span> </span>&#123;
   <span class="hljs-comment">// arr[]为原序列的信息从0开始，但在arr里是从1开始的</span>
   <span class="hljs-comment">// sum[]模拟线段树维护区间和</span>
   <span class="hljs-comment">// lazy[]为累加懒惰标记</span>
   <span class="hljs-comment">// change[]为更新的值</span>
   <span class="hljs-comment">// update[]为更新慵懒标记</span>
   <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> MAXN;
   <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] arr;
   <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] sum;
   <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] lazy;
   <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] change;
   <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span>[] update;

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SegmentTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] origin)</span> </span>&#123;
      MAXN = origin.length + <span class="hljs-number">1</span>;
      arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[MAXN]; <span class="hljs-comment">// arr[0] 不用  从1开始使用</span>
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; MAXN; i++) &#123;
         arr[i] = origin[i - <span class="hljs-number">1</span>];
      &#125;
      sum = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[MAXN &lt;&lt; <span class="hljs-number">2</span>]; <span class="hljs-comment">// 用来支持脑补概念中，某一个范围的累加和信息</span>
      lazy = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[MAXN &lt;&lt; <span class="hljs-number">2</span>]; <span class="hljs-comment">// 用来支持脑补概念中，某一个范围沒有往下傳遞的纍加任務</span>
      change = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[MAXN &lt;&lt; <span class="hljs-number">2</span>]; <span class="hljs-comment">// 用来支持脑补概念中，某一个范围有没有更新操作的任务</span>
      update = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[MAXN &lt;&lt; <span class="hljs-number">2</span>]; <span class="hljs-comment">// 用来支持脑补概念中，某一个范围更新任务，更新成了什么</span>
   &#125;

   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pushUp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rt)</span> </span>&#123;
      sum[rt] = sum[rt &lt;&lt; <span class="hljs-number">1</span>] + sum[rt &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>];
   &#125;

   <span class="hljs-comment">// 懒更新和懒增加的分发策略</span>
   <span class="hljs-comment">// ln表示左子树元素结点个数，rn表示右子树结点个数</span>
   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pushDown</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rt, <span class="hljs-keyword">int</span> ln, <span class="hljs-keyword">int</span> rn)</span> </span>&#123;
      <span class="hljs-keyword">if</span> (update[rt]) &#123;
         update[rt &lt;&lt; <span class="hljs-number">1</span>] = <span class="hljs-keyword">true</span>;
         update[rt &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>] = <span class="hljs-keyword">true</span>;
         change[rt &lt;&lt; <span class="hljs-number">1</span>] = change[rt];
         change[rt &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>] = change[rt];
         lazy[rt &lt;&lt; <span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;
         lazy[rt &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;
         sum[rt &lt;&lt; <span class="hljs-number">1</span>] = change[rt] * ln;
         sum[rt &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>] = change[rt] * rn;
         update[rt] = <span class="hljs-keyword">false</span>;
      &#125;
      <span class="hljs-keyword">if</span> (lazy[rt] != <span class="hljs-number">0</span>) &#123;
         lazy[rt &lt;&lt; <span class="hljs-number">1</span>] += lazy[rt];
         sum[rt &lt;&lt; <span class="hljs-number">1</span>] += lazy[rt] * ln;
         lazy[rt &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>] += lazy[rt];
         sum[rt &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>] += lazy[rt] * rn;
         lazy[rt] = <span class="hljs-number">0</span>;
      &#125;
   &#125;

   <span class="hljs-comment">// 在初始化阶段，先把sum数组，填好</span>
   <span class="hljs-comment">// 在arr[l~r]范围上，去build，1~N，</span>
   <span class="hljs-comment">// rt :  这个范围在sum中的下标</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> rt)</span> </span>&#123;
      <span class="hljs-keyword">if</span> (l == r) &#123;
         sum[rt] = arr[l];
         <span class="hljs-keyword">return</span>;
      &#125;
      <span class="hljs-keyword">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;
      <span class="hljs-comment">// rt * 2 下标从1开始才可以位运算</span>
      build(l, mid, rt &lt;&lt; <span class="hljs-number">1</span>);
      <span class="hljs-comment">// rt * 2 + 1</span>
      build(mid + <span class="hljs-number">1</span>, r, rt &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>);
      pushUp(rt);
   &#125;

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R, <span class="hljs-keyword">int</span> C, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> rt)</span> </span>&#123;
      <span class="hljs-keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) &#123;
         update[rt] = <span class="hljs-keyword">true</span>;
         change[rt] = C;
         sum[rt] = C * (r - l + <span class="hljs-number">1</span>);
         lazy[rt] = <span class="hljs-number">0</span>;
         <span class="hljs-keyword">return</span>;
      &#125;
      <span class="hljs-comment">// 当前任务躲不掉，无法懒更新，要往下发</span>
      <span class="hljs-keyword">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;
      pushDown(rt, mid - l + <span class="hljs-number">1</span>, r - mid);
      <span class="hljs-keyword">if</span> (L &lt;= mid) &#123;
         update(L, R, C, l, mid, rt &lt;&lt; <span class="hljs-number">1</span>);
      &#125;
      <span class="hljs-keyword">if</span> (R &gt; mid) &#123;
         update(L, R, C, mid + <span class="hljs-number">1</span>, r, rt &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>);
      &#125;
      pushUp(rt);
   &#125;

   <span class="hljs-comment">// L..R -&gt; 任务范围 ,所有的值累加上C  1～1000</span>
   <span class="hljs-comment">// l,r -&gt; 表达的范围  1～1024</span>
   <span class="hljs-comment">// rt  去哪找l，r范围上的信息</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R, <span class="hljs-keyword">int</span> C,</span></span>
<span class="hljs-function"><span class="hljs-params">         <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, </span></span>
<span class="hljs-function"><span class="hljs-params">         <span class="hljs-keyword">int</span> rt)</span> </span>&#123;
      <span class="hljs-comment">// 任务的范围彻底覆盖了，当前表达的范围</span>
      <span class="hljs-keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) &#123;
         sum[rt] += C * (r - l + <span class="hljs-number">1</span>);
         lazy[rt] += C;
         <span class="hljs-keyword">return</span>;
      &#125;
      <span class="hljs-comment">// 要把任务往下发</span>
      <span class="hljs-comment">// 任务  L, R  没有把本身表达范围 l,r 彻底包住</span>
      <span class="hljs-keyword">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;
      <span class="hljs-comment">// 下发之前的lazy add任务</span>
      pushDown(rt, mid - l + <span class="hljs-number">1</span>, r - mid);
      <span class="hljs-comment">// 左孩子是否需要接到任务</span>
      <span class="hljs-keyword">if</span> (L &lt;= mid) &#123;
         add(L, R, C, l, mid, rt &lt;&lt; <span class="hljs-number">1</span>);
      &#125;
      <span class="hljs-comment">// 右孩子是否需要接到任务</span>
      <span class="hljs-keyword">if</span> (R &gt; mid) &#123;
         add(L, R, C, mid + <span class="hljs-number">1</span>, r, rt &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>);
      &#125;
      <span class="hljs-comment">// 左右孩子做完任务后，我更新我的sum信息</span>
      pushUp(rt);
   &#125;

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> rt)</span> </span>&#123;
      <span class="hljs-keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) &#123;
         <span class="hljs-keyword">return</span> sum[rt];
      &#125;
      <span class="hljs-keyword">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;
      pushDown(rt, mid - l + <span class="hljs-number">1</span>, r - mid);
      <span class="hljs-keyword">long</span> ans = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">if</span> (L &lt;= mid) &#123;
         ans += query(L, R, l, mid, rt &lt;&lt; <span class="hljs-number">1</span>);
      &#125;
      <span class="hljs-keyword">if</span> (R &gt; mid) &#123;
         ans += query(L, R, mid + <span class="hljs-number">1</span>, r, rt &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>);
      &#125;
      <span class="hljs-keyword">return</span> ans;
   &#125;

&#125;</code></pre></div>



<h2 id="线段树应用"><a href="#线段树应用" class="headerlink" title="线段树应用"></a>线段树应用</h2><p>想象一下标准的俄罗斯方块游戏，X轴是积木最终下落到底的轴线<br>下面是这个游戏的简化版：<br>1）只会下落正方形积木<br>2）[a,b] -&gt; 代表一个边长为b的正方形积木，积木左边缘沿着X = a这条线从上方掉落<br>3）认为整个X轴都可能接住积木，也就是说简化版游戏是没有整体的左右边界的<br>4）没有整体的左右边界，所以简化版游戏不会消除积木，因为不会有哪一层被填满。</p>
<p>给定一个N*2的二维数组matrix，可以代表N个积木依次掉落，<br>返回每一次掉落之后的最大高度</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210329045829.png" srcset="/img/loading.gif" alt="解"></p>
<p>返回的是“结果数组”，每一步后的结果都要储存</p>
<p>假设[3,4 ]应该是3到6范围高度增加，不能增加7，下一个如果沿着7的边界，会被挡住</p>
<p>线段树的信息代表高度的信息</p>
<p>来了[ L, H]要看[L, L + H - 1]的高度是多少</p>
<p>只有update和query操作</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SegmentTree</span> </span>&#123;
   <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] max;
   <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] change;
   <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span>[] update;

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SegmentTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span> size)</span> </span>&#123;
      <span class="hljs-keyword">int</span> N = size + <span class="hljs-number">1</span>;
      max = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[N &lt;&lt; <span class="hljs-number">2</span>];
      change = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[N &lt;&lt; <span class="hljs-number">2</span>];
      update = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[N &lt;&lt; <span class="hljs-number">2</span>];
   &#125;

   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pushUp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rt)</span> </span>&#123;
      max[rt] = Math.max(max[rt &lt;&lt; <span class="hljs-number">1</span>], max[rt &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>]);
   &#125;

   <span class="hljs-comment">// ln表示左子树元素结点个数，rn表示右子树结点个数</span>
   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pushDown</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rt, <span class="hljs-keyword">int</span> ln, <span class="hljs-keyword">int</span> rn)</span> </span>&#123;
      <span class="hljs-keyword">if</span> (update[rt]) &#123;
         update[rt &lt;&lt; <span class="hljs-number">1</span>] = <span class="hljs-keyword">true</span>;
         update[rt &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>] = <span class="hljs-keyword">true</span>;
         change[rt &lt;&lt; <span class="hljs-number">1</span>] = change[rt];
         change[rt &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>] = change[rt];
         max[rt &lt;&lt; <span class="hljs-number">1</span>] = change[rt];
         max[rt &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>] = change[rt];
         update[rt] = <span class="hljs-keyword">false</span>;
      &#125;
   &#125;

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R, <span class="hljs-keyword">int</span> C, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> rt)</span> </span>&#123;
      <span class="hljs-keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) &#123;
         update[rt] = <span class="hljs-keyword">true</span>;
         change[rt] = C;
         max[rt] = C;
         <span class="hljs-keyword">return</span>;
      &#125;
      <span class="hljs-keyword">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;
      pushDown(rt, mid - l + <span class="hljs-number">1</span>, r - mid);
      <span class="hljs-keyword">if</span> (L &lt;= mid) &#123;
         update(L, R, C, l, mid, rt &lt;&lt; <span class="hljs-number">1</span>);
      &#125;
      <span class="hljs-keyword">if</span> (R &gt; mid) &#123;
         update(L, R, C, mid + <span class="hljs-number">1</span>, r, rt &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>);
      &#125;
      pushUp(rt);
   &#125;

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> rt)</span> </span>&#123;
      <span class="hljs-keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) &#123;
         <span class="hljs-keyword">return</span> max[rt];
      &#125;
      <span class="hljs-keyword">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;
      pushDown(rt, mid - l + <span class="hljs-number">1</span>, r - mid);
      <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">int</span> right = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">if</span> (L &lt;= mid) &#123;
         left = query(L, R, l, mid, rt &lt;&lt; <span class="hljs-number">1</span>);
      &#125;
      <span class="hljs-keyword">if</span> (R &gt; mid) &#123;
         right = query(L, R, mid + <span class="hljs-number">1</span>, r, rt &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>);
      &#125;
      <span class="hljs-keyword">return</span> Math.max(left, right);
   &#125;

&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> HashMap&lt;Integer, Integer&gt; <span class="hljs-title">index</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] positions)</span> </span>&#123;
   TreeSet&lt;Integer&gt; pos = <span class="hljs-keyword">new</span> TreeSet&lt;&gt;();
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] arr : positions) &#123;
      pos.add(arr[<span class="hljs-number">0</span>]);
      pos.add(arr[<span class="hljs-number">0</span>] + arr[<span class="hljs-number">1</span>] - <span class="hljs-number">1</span>);
   &#125;
   HashMap&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
   <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;
   <span class="hljs-keyword">for</span> (Integer index : pos) &#123;
      <span class="hljs-comment">// 编号排序 从1开始</span>
      map.put(index, ++count);
   &#125;
   <span class="hljs-keyword">return</span> map;
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">fallingSquares</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] positions)</span> </span>&#123;
   <span class="hljs-comment">// 位置离散化 把所有的块左右两个边界都有哪些值</span>
   <span class="hljs-comment">// [100, 7] 认为是[100, 106]为边界</span>
   HashMap&lt;Integer, Integer&gt; map = index(positions);
   <span class="hljs-keyword">int</span> N = map.size();
   <span class="hljs-comment">// 不拿x值修改，拿编好号排好序的修改</span>
   SegmentTree segmentTree = <span class="hljs-keyword">new</span> SegmentTree(N);
   <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;
   List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] arr : positions) &#123;
      <span class="hljs-keyword">int</span> L = map.get(arr[<span class="hljs-number">0</span>]);
      <span class="hljs-keyword">int</span> R = map.get(arr[<span class="hljs-number">0</span>] + arr[<span class="hljs-number">1</span>] - <span class="hljs-number">1</span>);
      <span class="hljs-keyword">int</span> height = segmentTree.query(L, R, <span class="hljs-number">1</span>, N, <span class="hljs-number">1</span>) + arr[<span class="hljs-number">1</span>];
      max = Math.max(max, height);
      res.add(max);
      segmentTree.update(L, R, height, <span class="hljs-number">1</span>, N, <span class="hljs-number">1</span>);
   &#125;
   <span class="hljs-keyword">return</span> res;
&#125;</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210329084729.png" srcset="/img/loading.gif" alt="第一次"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210329084800.png" srcset="/img/loading.gif" alt="第二次"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210329084830.png" srcset="/img/loading.gif" alt="第三次"></p>
<h2 id="线段重合问题"><a href="#线段重合问题" class="headerlink" title="线段重合问题"></a>线段重合问题</h2><p>给你一段线段，求重合线段；</p>
<p>可以用线段树做，和上面的俄罗斯方块类似，左右边界离散化，遇到线段加1；</p>
<p>更好实现的方法：</p>
<p> <strong>开始位置排个序</strong> </p>
<p>线段开始位置越早越先处理，准备一个小根堆，</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210329090901.png" srcset="/img/loading.gif" alt="开始"></p>
<p>把10放进去：堆里面一个数，</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210329091033.png" srcset="/img/loading.gif" alt="第二回"></p>
<p>两个数；</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210329091131.png" srcset="/img/loading.gif" alt="第n回合"></p>
<blockquote>
<p>小根堆的意义</p>
</blockquote>
<p>之前还有哪些线段会对此时的线段产生影响，这些线段的结尾都在这个小根堆里面；</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210329091740.png" srcset="/img/loading.gif"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210329093040.png" srcset="/img/loading.gif" alt="code"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210329093106.png" srcset="/img/loading.gif" alt="code"></p>
<h2 id="线段重合拓展"><a href="#线段重合拓展" class="headerlink" title="线段重合拓展"></a>线段重合拓展</h2><p>[1, 3, 2, 1]代表一个矩阵，矩形左上角和右下角</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210329093511.png" srcset="/img/loading.gif" alt="矩阵"></p>
<p>给很多个矩阵，N * 4</p>
<p>求哪个区域盖的矩形最多，返回数量；</p>
<blockquote>
<p>怎么遍历一个矩形？</p>
</blockquote>
<p>下底最靠下，最先遍历</p>
<p>遍历时，假设底是无限延伸的，如果固定一个矩形，下一个矩形的上边都小于底，则不可能覆盖</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210329094432.png" srcset="/img/loading.gif" alt="无限延伸"></p>
<p>再根据左边界右边界抽出来认为是一个线段，就变成了线段重合问题；</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210329094710.png" srcset="/img/loading.gif" alt="code"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210329095013.png" srcset="/img/loading.gif" alt="code2"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210329095116.png" srcset="/img/loading.gif" alt="code3"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210329100521.png" srcset="/img/loading.gif" alt="code"></p>
<blockquote>
<p> 为什么list要用treeset表示？</p>
</blockquote>
<p>要转换为线段重合问题，莫不如修改为set排序好</p>
<p>while循环是优化，如果底边一样，一票求一下</p>
<h1 id="AC自动机"><a href="#AC自动机" class="headerlink" title="AC自动机"></a>AC自动机</h1><p>解决在一个大字符串中，找到 <strong>多个候选字符串</strong> 的问题</p>
<h2 id="AC自动机算法核心"><a href="#AC自动机算法核心" class="headerlink" title="AC自动机算法核心"></a>AC自动机算法核心</h2><p>1）把所有匹配串生成一棵前缀树</p>
<p>2）前缀树节点增加 <strong>fail指针</strong> ，每一个结点都有</p>
<p>3）fail指针的含义：如果必须以当前字符结尾，当前形成的路径是str，剩下哪一个字符串的前缀和str的后缀，拥有最大的匹配长度。fail指针就指向那个字符串的最后一个字符所对应的节点。</p>
<p>头结点fail指针人为规定 <strong>指向空</strong> ，第一级孩子人为规定 <strong>指向头</strong> ；</p>
<p>加fail指针的方式是前缀树建立好后，再做一个fail指针设定过程（宽度优先遍历）</p>
<p>再接下来的 fail指针，假如来到X结点，设置孩子的指针，假设通过b到达孩子，自己的fail指针指向甲，如果甲通过b有其他的路，则X的孩子指向这里；</p>
<p>如果甲没有b的路，找甲的fail指针….直到有b的路，如果都没有，指回头</p>
<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210405004906.png" srcset="/img/loading.gif" style="zoom:50%;" />

<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210405005439.png" srcset="/img/loading.gif" style="zoom:50%;" />

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210405005039.png" srcset="/img/loading.gif"></p>
<p>​    </p>
<blockquote>
<p>意义</p>
</blockquote>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210405010227.png" srcset="/img/loading.gif"></p>
<p>Axctft可以串到xct，f可以串到xctf</p>
<p>Axctf和xctxxc，t串到xctxxc的t</p>
<p>其实是 <strong>动态规划</strong> ；</p>
<h2 id="找寻过程"><a href="#找寻过程" class="headerlink" title="找寻过程"></a>找寻过程</h2><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210405012406.png" srcset="/img/loading.gif"></p>
<p>能到达的点描黑</p>
<p>每到一个点顺着fail指针收集黑</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210405013416.png" srcset="/img/loading.gif"></p>
<p>收集到了的黑改成白色，收集只是fail指针转一圈，不是到达的结点换位置。</p>
<h2 id="code-1"><a href="#code-1" class="headerlink" title="code"></a>code</h2><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// 前缀树的节点</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;
   <span class="hljs-comment">// 如果一个node，end为空，不是结尾</span>
   <span class="hljs-comment">// 如果end不为空，表示这个点是某个字符串的结尾，end的值就是这个字符串</span>
   <span class="hljs-keyword">public</span> String end;
   <span class="hljs-comment">// 只有在上面的end变量不为空的时候，endUse才有意义</span>
   <span class="hljs-comment">// 表示，这个字符串之前有没有加入过答案</span>
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> endUse;
   <span class="hljs-keyword">public</span> Node fail;
   <span class="hljs-keyword">public</span> Node[] nexts;
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">()</span> </span>&#123;
      endUse = <span class="hljs-keyword">false</span>;
      end = <span class="hljs-keyword">null</span>;
      fail = <span class="hljs-keyword">null</span>;
      nexts = <span class="hljs-keyword">new</span> Node[<span class="hljs-number">26</span>];
   &#125;
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ACAutomation</span> </span>&#123;
   <span class="hljs-keyword">private</span> Node root;

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ACAutomation</span><span class="hljs-params">()</span> </span>&#123;
      root = <span class="hljs-keyword">new</span> Node();
   &#125;

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(String s)</span> </span>&#123;
      <span class="hljs-keyword">char</span>[] str = s.toCharArray();
      Node cur = root;
      <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; str.length; i++) &#123;
         index = str[i] - <span class="hljs-string">&#x27;a&#x27;</span>;
         <span class="hljs-keyword">if</span> (cur.nexts[index] == <span class="hljs-keyword">null</span>) &#123;
            Node next = <span class="hljs-keyword">new</span> Node();
            cur.nexts[index] = next;
         &#125;
         cur = cur.nexts[index];
      &#125;
      cur.end = s;
   &#125;

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">()</span> </span>&#123;
      Queue&lt;Node&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();
      queue.add(root);
      Node cur = <span class="hljs-keyword">null</span>;
      Node cfail = <span class="hljs-keyword">null</span>;
      <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;
         <span class="hljs-comment">// 当前节点弹出，</span>
         <span class="hljs-comment">// 当前节点的所有后代加入到队列里去，</span>
         <span class="hljs-comment">// 当前节点给它的子去设置fail指针</span>
         <span class="hljs-comment">// cur -&gt; 父亲</span>
         cur = queue.poll();
         <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++) &#123; <span class="hljs-comment">// 所有的路</span>
            <span class="hljs-keyword">if</span> (cur.nexts[i] != <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// 找到所有有效的路</span>
               cur.nexts[i].fail = root; <span class="hljs-comment">//</span>
               cfail = cur.fail;
               <span class="hljs-keyword">while</span> (cfail != <span class="hljs-keyword">null</span>) &#123;
                  <span class="hljs-keyword">if</span> (cfail.nexts[i] != <span class="hljs-keyword">null</span>) &#123;
                     cur.nexts[i].fail = cfail.nexts[i];
                     <span class="hljs-keyword">break</span>;
                  &#125;
                  cfail = cfail.fail;
               &#125;
               queue.add(cur.nexts[i]);
            &#125;
         &#125;
      &#125;
   &#125;

   <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">containWords</span><span class="hljs-params">(String content)</span> </span>&#123;
      <span class="hljs-keyword">char</span>[] str = content.toCharArray();
      Node cur = root;
      Node follow = <span class="hljs-keyword">null</span>;
      <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;
      List&lt;String&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; str.length; i++) &#123;
         index = str[i] - <span class="hljs-string">&#x27;a&#x27;</span>; <span class="hljs-comment">// 路</span>
         <span class="hljs-comment">// 如果当前字符在这条路上没配出来，就随着fail方向走向下条路径</span>
         <span class="hljs-comment">// 如果当前结点没有path的路，通过fail指针跳到别的路上</span>
         <span class="hljs-keyword">while</span> (cur.nexts[index] == <span class="hljs-keyword">null</span> &amp;&amp; cur != root) &#123;
            cur = cur.fail;
         &#125;
         <span class="hljs-comment">// 1) 现在来到的路径，是可以继续匹配的</span>
         <span class="hljs-comment">// 2) 现在来到的节点，就是前缀树的根节点 来到头了</span>
         cur = cur.nexts[index] != <span class="hljs-keyword">null</span> ? cur.nexts[index] : root;
         follow = cur;
         <span class="hljs-keyword">while</span> (follow != root) &#123;
            <span class="hljs-keyword">if</span>(follow.endUse) &#123;
               <span class="hljs-keyword">break</span>;
            &#125;
            <span class="hljs-comment">// 不同的需求，在这一段之间修改</span>
            <span class="hljs-keyword">if</span> (follow.end != <span class="hljs-keyword">null</span>) &#123;
               ans.add(follow.end);
               follow.endUse = <span class="hljs-keyword">true</span>;
            &#125;
            <span class="hljs-comment">// 不同的需求，在这一段之间修改</span>
            follow = follow.fail;
         &#125;
      &#125;
      <span class="hljs-keyword">return</span> ans;
   &#125;

&#125;</code></pre></div>





<h1 id="打表"><a href="#打表" class="headerlink" title="打表"></a>打表</h1><p>1）问题如果返回值不太多，可以用hardcode的方式列出，作为程序的一部分</p>
<p>2）一个大问题解决时底层频繁使用规模不大的小问题的解，如果小问题的返回值满足条件1），可以把小问题的解列成一张表，作为程序的一部分</p>
<p>3）打表找规律</p>
<p>打表是做出一张表，独立于程序之外，参数改变一般不会改变表的数据；</p>
<h2 id="打表规律"><a href="#打表规律" class="headerlink" title="打表规律"></a>打表规律</h2><p>1）某个面试题，输入参数类型简单，并且只有一个实际参数</p>
<p>2）要求的返回值类型也简单，并且只有一个</p>
<p>3）用暴力方法，把输入参数对应的返回值，打印出来看看，进而优化code</p>
<h2 id="题目1"><a href="#题目1" class="headerlink" title="题目1"></a>题目1</h2><p>小虎去买苹果，商店只提供两种类型的塑料袋，每种类型都有任意数量。<br>1）能装下6个苹果的袋子<br>2）能装下8个苹果的袋子<br>小虎可以自由使用两种袋子来装苹果，但是小虎有强迫症，他要求自己使用的袋子数量必须最少，且使用的每个袋子必须装满。<br>给定一个正整数N，返回至少使用多少袋子。如果N无法让使用的每个袋子必须装满，返回-1</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210329181015.png" srcset="/img/loading.gif" alt="正常解题思路"></p>
<p>解题加速：</p>
<p>8 6最大公倍数为24</p>
<p>当剩下的大于24个时，又走循环</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210329181403.png" srcset="/img/loading.gif" alt="加速"></p>
<p>剩余31个的问题等于剩余7个</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minBags</span><span class="hljs-params">(<span class="hljs-keyword">int</span> apple)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (apple &lt; <span class="hljs-number">0</span>) &#123;
      <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
   &#125;
   <span class="hljs-keyword">int</span> bag6 = -<span class="hljs-number">1</span>;
   <span class="hljs-keyword">int</span> bag8 = apple / <span class="hljs-number">8</span>;
   <span class="hljs-keyword">int</span> rest = apple - <span class="hljs-number">8</span> * bag8;
   <span class="hljs-keyword">while</span> (bag8 &gt;= <span class="hljs-number">0</span> &amp;&amp; rest &lt; <span class="hljs-number">24</span>) &#123;
      <span class="hljs-keyword">int</span> restUse6 = minBagBase6(rest);
      <span class="hljs-keyword">if</span> (restUse6 != -<span class="hljs-number">1</span>) &#123;
         bag6 = restUse6;
         <span class="hljs-keyword">break</span>;
      &#125;
      rest = apple - <span class="hljs-number">8</span> * (--bag8);
   &#125;
   <span class="hljs-keyword">return</span> bag6 == -<span class="hljs-number">1</span> ? -<span class="hljs-number">1</span> : bag6 + bag8;
&#125;

<span class="hljs-comment">// 如果剩余苹果rest可以被装6个苹果的袋子搞定，返回袋子数量</span>
<span class="hljs-comment">// 不能搞定返回-1</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minBagBase6</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rest)</span> </span>&#123;
   <span class="hljs-keyword">return</span> rest % <span class="hljs-number">6</span> == <span class="hljs-number">0</span> ? (rest / <span class="hljs-number">6</span>) : -<span class="hljs-number">1</span>;
&#125;</code></pre></div>



<h3 id="打表解题"><a href="#打表解题" class="headerlink" title="打表解题"></a>打表解题</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210329181632.png" srcset="/img/loading.gif" alt="规律"></p>
<p>18开始奇数-1，偶数3</p>
<p>26开始奇数-1，偶数4</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minBagAwesome</span><span class="hljs-params">(<span class="hljs-keyword">int</span> apple)</span> </span>&#123;
   <span class="hljs-keyword">if</span> ((apple &amp; <span class="hljs-number">1</span>) != <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 如果是奇数，返回-1</span>
      <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
   &#125;
   <span class="hljs-keyword">if</span> (apple &lt; <span class="hljs-number">18</span>) &#123;
      <span class="hljs-keyword">return</span> apple == <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : (apple == <span class="hljs-number">6</span> || apple == <span class="hljs-number">8</span>) ? <span class="hljs-number">1</span>
            : (apple == <span class="hljs-number">12</span> || apple == <span class="hljs-number">14</span> || apple == <span class="hljs-number">16</span>) ? <span class="hljs-number">2</span> : -<span class="hljs-number">1</span>;
   &#125;
   <span class="hljs-keyword">return</span> (apple - <span class="hljs-number">18</span>) / <span class="hljs-number">8</span> + <span class="hljs-number">3</span>;
&#125;</code></pre></div>



<h2 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h2><p>给定一个正整数N，表示有N份青草统一堆放在仓库里<br>有一只牛和一只羊，牛先吃，羊后吃，它俩轮流吃草<br>不管是牛还是羊，每一轮能吃的草量必须是：<br>1，4，16，64…(4的某次方)<br>谁最先把草吃完，谁获胜<br>假设牛和羊都绝顶聪明，都想赢，都会做出理性的决定<br>根据唯一的参数N，返回谁会赢</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// n份青草放在一堆</span>
<span class="hljs-comment">// 先手后手都绝顶聪明</span>
<span class="hljs-comment">// string &quot;先手&quot; &quot;后手&quot;</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">winner1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;
   <span class="hljs-comment">// 0  1  2  3 4</span>
   <span class="hljs-comment">// 后 先 后 先 先</span>
   <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">5</span>) &#123; <span class="hljs-comment">// base case</span>
      <span class="hljs-keyword">return</span> (n == <span class="hljs-number">0</span> || n == <span class="hljs-number">2</span>) ? <span class="hljs-string">&quot;后手&quot;</span> : <span class="hljs-string">&quot;先手&quot;</span>;
   &#125;
   <span class="hljs-comment">// n &gt;= 5 时</span>
   <span class="hljs-keyword">int</span> base = <span class="hljs-number">1</span>; <span class="hljs-comment">// 当前先手决定吃的草数</span>
   <span class="hljs-comment">// 当前是先手在选</span>
   <span class="hljs-keyword">while</span> (base &lt;= n) &#123;
      <span class="hljs-comment">// 当前一共n份草，先手吃掉的是base份，n - base 是留给后手的草</span>
      <span class="hljs-comment">// 母过程 先手 在子过程里是 后手</span>
      <span class="hljs-keyword">if</span> (winner1(n - base).equals(<span class="hljs-string">&quot;后手&quot;</span>)) &#123;
         <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;先手&quot;</span>;
      &#125;
      <span class="hljs-keyword">if</span> (base &gt; n / <span class="hljs-number">4</span>) &#123; <span class="hljs-comment">// 防止base*4之后溢出</span>
         <span class="hljs-keyword">break</span>;
      &#125;
      <span class="hljs-comment">// 第一次用1 下回试试4 下回试试16.....</span>
      base *= <span class="hljs-number">4</span>;
   &#125;
   <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;后手&quot;</span>;
&#125;</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210329185551.png" srcset="/img/loading.gif" alt="分析"></p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">winner2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (n % <span class="hljs-number">5</span> == <span class="hljs-number">0</span> || n % <span class="hljs-number">5</span> == <span class="hljs-number">2</span>) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;后手&quot;</span>;
   &#125; <span class="hljs-keyword">else</span> &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;先手&quot;</span>;
   &#125;
&#125;</code></pre></div>



<h2 id="题目三-1"><a href="#题目三-1" class="headerlink" title="题目三"></a>题目三</h2><p>定义一种数：可以表示成若干（数量&gt;1）连续正数和的数<br>比如:<br>5 = 2+3，5就是这样的数<br>12 = 3+4+5，12就是这样的数<br>1不是这样的数，因为要求数量大于1个、连续正数和<br>2 = 1 + 1，2也不是，因为等号右边不是连续正数<br>给定一个参数N，返回是不是可以表示成若干连续正数和的数</p>
<p>暴力：从1开始加，加到等于一百返回，大于一百从2开始加</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isMSum1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= num; i++) &#123;
      <span class="hljs-keyword">int</span> sum = i;
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt;= num; j++) &#123;
         <span class="hljs-keyword">if</span> (sum + j &gt; num) &#123;
            <span class="hljs-keyword">break</span>;
         &#125;
         <span class="hljs-keyword">if</span> (sum + j == num) &#123;
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
         &#125;
         sum += j;
      &#125;
   &#125;
   <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
&#125;</code></pre></div>



<p>找规律</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210329190329.png" srcset="/img/loading.gif" alt="规律"></p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isMSum2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (num &lt; <span class="hljs-number">3</span>) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
   &#125;
   <span class="hljs-comment">// 是2的次幂</span>
   <span class="hljs-comment">// 规律 二进制上只有一个1</span>
   <span class="hljs-keyword">return</span> (num &amp; (num - <span class="hljs-number">1</span>)) != <span class="hljs-number">0</span>;
&#125;</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210329190740.png" srcset="/img/loading.gif" alt="判断2的次幂"></p>
<h1 id="矩阵处理技巧"><a href="#矩阵处理技巧" class="headerlink" title="矩阵处理技巧"></a>矩阵处理技巧</h1><p>核心技巧：找到coding上的宏观调度，不要局限于局部坐标变换</p>
<h2 id="zigzag打印矩阵"><a href="#zigzag打印矩阵" class="headerlink" title="zigzag打印矩阵"></a>zigzag打印矩阵</h2><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210329192140.png" srcset="/img/loading.gif" alt="打印"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210329192611.png" srcset="/img/loading.gif" alt="方法"></p>
<p>A往右走，B往下走，压到一条斜线</p>
<p>当A不能往右，就往下，B不能往下，就往右</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210329192748.png" srcset="/img/loading.gif" alt="结果"></p>
<p>分别从左下到右上或者右上到左下，依次调换</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printMatrixZigZag</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix)</span> </span>&#123;
   <span class="hljs-keyword">int</span> Ar = <span class="hljs-number">0</span>;<span class="hljs-comment">// A的行号</span>
   <span class="hljs-keyword">int</span> Ac = <span class="hljs-number">0</span>;<span class="hljs-comment">// A的列号</span>
   <span class="hljs-keyword">int</span> Br = <span class="hljs-number">0</span>;<span class="hljs-comment">// B的行号</span>
   <span class="hljs-keyword">int</span> Bc = <span class="hljs-number">0</span>;<span class="hljs-comment">// B的列号</span>
   <span class="hljs-keyword">int</span> endR = matrix.length - <span class="hljs-number">1</span>;<span class="hljs-comment">// 终止位置行</span>
   <span class="hljs-keyword">int</span> endC = matrix[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span>;<span class="hljs-comment">// 终止位置列</span>
   <span class="hljs-keyword">boolean</span> fromUp = <span class="hljs-keyword">false</span>;<span class="hljs-comment">// 是不是从右上往左下打印；一开始是从左下往右上</span>
   <span class="hljs-keyword">while</span> (Ar != endR + <span class="hljs-number">1</span>) &#123;<span class="hljs-comment">// A还没来到右下角的位置 + 1</span>
      <span class="hljs-comment">// 已知斜线两端，方向，即可打印</span>
      printLevel(matrix, Ar, Ac, Br, Bc, fromUp);
      Ar = Ac == endC ? Ar + <span class="hljs-number">1</span> : Ar;
      Ac = Ac == endC ? Ac : Ac + <span class="hljs-number">1</span>;
      Bc = Br == endR ? Bc + <span class="hljs-number">1</span> : Bc;
      Br = Br == endR ? Br : Br + <span class="hljs-number">1</span>;
      fromUp = !fromUp;
   &#125;
   System.out.println();
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printLevel</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] m, <span class="hljs-keyword">int</span> tR, <span class="hljs-keyword">int</span> tC, <span class="hljs-keyword">int</span> dR, <span class="hljs-keyword">int</span> dC,</span></span>
<span class="hljs-function"><span class="hljs-params">      <span class="hljs-keyword">boolean</span> f)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (f) &#123;
      <span class="hljs-keyword">while</span> (tR != dR + <span class="hljs-number">1</span>) &#123;
         System.out.print(m[tR++][tC--] + <span class="hljs-string">&quot; &quot;</span>);
      &#125;
   &#125; <span class="hljs-keyword">else</span> &#123;
      <span class="hljs-keyword">while</span> (dR != tR - <span class="hljs-number">1</span>) &#123;
         System.out.print(m[dR--][dC++] + <span class="hljs-string">&quot; &quot;</span>);
      &#125;
   &#125;
&#125;</code></pre></div>



<h2 id="转圈打印矩阵"><a href="#转圈打印矩阵" class="headerlink" title="转圈打印矩阵"></a>转圈打印矩阵</h2><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210329195422.png" srcset="/img/loading.gif" alt="打印"></p>
<p>第一层结束的位置等于第二层开始的位置</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210329195739.png" srcset="/img/loading.gif"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210329200957.png" srcset="/img/loading.gif" alt="规定好"></p>
<p>b++但不碰到d，a++不要碰到c，d–不要碰到b，c–不要碰到a</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">spiralOrderPrint</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix)</span> </span>&#123;
   <span class="hljs-keyword">int</span> tR = <span class="hljs-number">0</span>;
   <span class="hljs-keyword">int</span> tC = <span class="hljs-number">0</span>;
   <span class="hljs-keyword">int</span> dR = matrix.length - <span class="hljs-number">1</span>;
   <span class="hljs-keyword">int</span> dC = matrix[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span>;
   <span class="hljs-keyword">while</span> (tR &lt;= dR &amp;&amp; tC &lt;= dC) &#123;
      printEdge(matrix, tR++, tC++, dR--, dC--);
   &#125;
&#125;

<span class="hljs-comment">// tR, tC 左上角</span>
<span class="hljs-comment">// dR, dC 右下角</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printEdge</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] m, <span class="hljs-keyword">int</span> tR, <span class="hljs-keyword">int</span> tC, <span class="hljs-keyword">int</span> dR, <span class="hljs-keyword">int</span> dC)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (tR == dR) &#123; <span class="hljs-comment">// 只剩一条横线</span>
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = tC; i &lt;= dC; i++) &#123;
         <span class="hljs-comment">// 打印横线</span>
         System.out.print(m[tR][i] + <span class="hljs-string">&quot; &quot;</span>);
      &#125;
   &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tC == dC) &#123;
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = tR; i &lt;= dR; i++) &#123;
         <span class="hljs-comment">// 打印竖线</span>
         System.out.print(m[i][tC] + <span class="hljs-string">&quot; &quot;</span>);
      &#125;
   &#125; <span class="hljs-keyword">else</span> &#123;
      <span class="hljs-keyword">int</span> curC = tC;
      <span class="hljs-keyword">int</span> curR = tR;
      <span class="hljs-keyword">while</span> (curC != dC) &#123;
         System.out.print(m[tR][curC] + <span class="hljs-string">&quot; &quot;</span>);
         curC++;
      &#125;
      <span class="hljs-keyword">while</span> (curR != dR) &#123;
         System.out.print(m[curR][dC] + <span class="hljs-string">&quot; &quot;</span>);
         curR++;
      &#125;
      <span class="hljs-keyword">while</span> (curC != tC) &#123;
         System.out.print(m[dR][curC] + <span class="hljs-string">&quot; &quot;</span>);
         curC--;
      &#125;
      <span class="hljs-keyword">while</span> (curR != tR) &#123;
         System.out.print(m[curR][tC] + <span class="hljs-string">&quot; &quot;</span>);
         curR--;
      &#125;
   &#125;
&#125;</code></pre></div>



<h2 id="原地旋转正方形矩阵"><a href="#原地旋转正方形矩阵" class="headerlink" title="原地旋转正方形矩阵"></a>原地旋转正方形矩阵</h2><p>一样先转外层的框</p>
<p>分圈结构！</p>
<p> <img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210329202839.png" srcset="/img/loading.gif" alt="分组"></p>
<p>4*4有3个小组；</p>
<p>小组数等于边长 - 1</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210329203434.png" srcset="/img/loading.gif" alt="四个坐标"></p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix)</span> </span>&#123;
   <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>;
   <span class="hljs-keyword">int</span> b = <span class="hljs-number">0</span>;
   <span class="hljs-keyword">int</span> c = matrix.length - <span class="hljs-number">1</span>;
   <span class="hljs-keyword">int</span> d = matrix[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span>;
   <span class="hljs-keyword">while</span> (a &lt; c) &#123;
      rotateEdge(matrix, a++, b++, c--, d--);
   &#125;
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rotateEdge</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] m, <span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> c, <span class="hljs-keyword">int</span> d)</span> </span>&#123;
   <span class="hljs-keyword">int</span> tmp = <span class="hljs-number">0</span>;
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; d - b; i++) &#123;
      <span class="hljs-comment">// i组号</span>
      tmp = m[a][b + i];
      m[a][b + i] = m[c - i][b];
      m[c - i][b] = m[c][d - i];
      m[c][d - i] = m[a + i][d];
      m[a + i][d] = tmp;
   &#125;
&#125;</code></pre></div>



<h1 id="数组累加和问题三连"><a href="#数组累加和问题三连" class="headerlink" title="数组累加和问题三连"></a>数组累加和问题三连</h1><h2 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h2><p>给定一个正整数组成的无序数组arr，给定一个正整数值K<br>找到arr的所有子数组里，哪个子数组的累加和等于K，并且是长度最大的<br>返回其长度</p>
<p> <strong>范围和累加和有严格单调性</strong> ，也就是说右扩一定增大，左缩一定减小</p>
<p>子数组、子串都是连续的；子序列才是散开的</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210330173727.png" srcset="/img/loading.gif" alt="方法"></p>
<p>设置窗口，窗口内为windowsum</p>
<p>ws&lt;sum, R右移</p>
<p>ws&gt;sum, L右移</p>
<p>ws == sum, 判断是否更新, R右移</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMaxLength</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> K)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length == <span class="hljs-number">0</span> || K &lt;= <span class="hljs-number">0</span>) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
   &#125;
   <span class="hljs-comment">// [L..R]</span>
   <span class="hljs-comment">// [0..0]上的范围</span>
   <span class="hljs-comment">// 一开始这样设置窗口内应该设置一个数 arr[0]</span>
   <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;
   <span class="hljs-keyword">int</span> right = <span class="hljs-number">0</span>;
   <span class="hljs-comment">// 这里的sum指的是windowsum k表示sum</span>
   <span class="hljs-keyword">int</span> sum = arr[<span class="hljs-number">0</span>];
   <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>;
   <span class="hljs-keyword">while</span> (right &lt; arr.length) &#123;
      <span class="hljs-keyword">if</span> (sum == K) &#123;
         len = Math.max(len, right - left + <span class="hljs-number">1</span>);
         <span class="hljs-comment">// 这里L或者R动都可以 L减，R加</span>
         sum -= arr[left++];
      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &lt; K) &#123;
         right++;
         <span class="hljs-keyword">if</span> (right == arr.length) &#123;
            <span class="hljs-keyword">break</span>;
         &#125;
         sum += arr[right];
      &#125; <span class="hljs-keyword">else</span> &#123;
         sum -= arr[left++];
      &#125;
   &#125;
   <span class="hljs-keyword">return</span> len;
&#125;</code></pre></div>



<h2 id="题目二-1"><a href="#题目二-1" class="headerlink" title="题目二"></a>题目二</h2><p>给定一个整数组成的无序数组arr，值可能正、可能负、可能0<br>给定一个整数值K<br>找到arr的所有子数组里，哪个子数组的累加和等于K，并且是长度最大的<br>返回其长度</p>
<p>假设0 - 17位置累加和为 1000；</p>
<p>0 - 5位置是第一次出现800的情况；</p>
<p>所以6 - 17累加和为200，同时又是以17结尾，200最长的，因为800是最早出现的</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210330180620.png" srcset="/img/loading.gif" alt="解"></p>
<p>假设sum为当前位置的累加和，map放累加和 <strong>最早</strong> 出现的位置</p>
<p>来到5的时候，找map里面有没有5 - 10 = - 5的位置；</p>
<p>没有，所以以5结尾的没有答案</p>
<p>把新的累加和加到map里面，5最早的累加和出现在0位置，记录 5 0</p>
<p>下一个数来到6，加上累加和为11， 找11 - 10 = 1最早出现的位置</p>
<p>说明以6结尾的没有答案，记录 11 1</p>
<p>来到4，加上累加和为15， 15 - 10 = 5，map有5</p>
<p>说明来到2位置的时候，1 - 2为当前最长答案2，15放入map。。。。</p>
<p> <strong>必须躺着一个 0 -1的键值对</strong> ，不然0 - i正好出现的时候找不到答案</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxLength</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> k)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length == <span class="hljs-number">0</span>) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
   &#125;
   HashMap&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;Integer, Integer&gt;();
   map.put(<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>); <span class="hljs-comment">// important</span>
   <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>;
   <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;
      sum += arr[i];
      <span class="hljs-keyword">if</span> (map.containsKey(sum - k)) &#123;
         len = Math.max(i - map.get(sum - k), len);
      &#125;
      <span class="hljs-keyword">if</span> (!map.containsKey(sum)) &#123;
         map.put(sum, i);
      &#125;
   &#125;
   <span class="hljs-keyword">return</span> len;
&#125;</code></pre></div>



<h3 id="题目二拓展"><a href="#题目二拓展" class="headerlink" title="题目二拓展"></a>题目二拓展</h3><p>一个数组中有正负数，返回里面1和2个数相等的最大子数组</p>
<p>解法：遇到1 和 2之外的数认为是0，遇到1变成1，遇到2变成-1</p>
<p>求累加和为0的最长子数组</p>
<h2 id="题目三-2"><a href="#题目三-2" class="headerlink" title="题目三"></a>题目三</h2><p>给定一个整数组成的无序数组arr，值可能正、可能负、可能0<br>给定一个整数值K<br>找到arr的所有子数组里，哪个子数组的累加和&lt;=K，并且是长度最大的<br>返回其长度</p>
<p>定义一个概念：</p>
<p>i开头所有的可能性中，哪一个是取得累加和最小的情况</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210330192125.png" srcset="/img/loading.gif"></p>
<p>生成好这两个数组</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210330193310.png" srcset="/img/loading.gif" alt="解"></p>
<p>就维持一个窗口看看有没有往右看的可能性，如果可能性都没有，一定不是想要的答案</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210330193550.png" srcset="/img/loading.gif"></p>
<p>当扩到1时，sum=1，超过k了</p>
<p>于是去掉 - 10，加入1 发现sum大于k</p>
<p>所以此时5开头一定得不到一个更长的答案，舍弃</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxLengthAwesome</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> k)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length == <span class="hljs-number">0</span>) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
   &#125;
   <span class="hljs-keyword">int</span>[] minSums = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[arr.length];
   <span class="hljs-keyword">int</span>[] minSumEnds = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[arr.length];
   minSums[arr.length - <span class="hljs-number">1</span>] = arr[arr.length - <span class="hljs-number">1</span>];
   minSumEnds[arr.length - <span class="hljs-number">1</span>] = arr.length - <span class="hljs-number">1</span>;
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = arr.length - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;
      <span class="hljs-keyword">if</span> (minSums[i + <span class="hljs-number">1</span>] &lt; <span class="hljs-number">0</span>) &#123;
         minSums[i] = arr[i] + minSums[i + <span class="hljs-number">1</span>];
         minSumEnds[i] = minSumEnds[i + <span class="hljs-number">1</span>];
      &#125; <span class="hljs-keyword">else</span> &#123;
         minSums[i] = arr[i];
         minSumEnds[i] = i;
      &#125;
   &#125;

   <span class="hljs-comment">// (i...)(...)(...) | (end....</span>
   <span class="hljs-comment">// end开始算不进去了</span>
   <span class="hljs-comment">// sum是i扩到end的窗口累加和</span>
   <span class="hljs-keyword">int</span> end = <span class="hljs-number">0</span>;
   <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;
   <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;
   <span class="hljs-comment">// i是窗口的最左的位置，end扩出来的最右有效块儿的最后一个位置的，再下一个位置</span>
   <span class="hljs-comment">// end也是下一块儿的开始位置</span>
   <span class="hljs-comment">// 窗口：[i~end)</span>
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;
      <span class="hljs-comment">// while循环结束之后：</span>
      <span class="hljs-comment">// 1) 如果以i开头的情况下，累加和&lt;=k的最长子数组是arr[i..end-1]，看看这个子数组长度能不能更新res；</span>
      <span class="hljs-comment">// 2) 如果以i开头的情况下，累加和&lt;=k的最长子数组比arr[i..end-1]短，更新还是不更新res都不会影响最终结果；</span>
      <span class="hljs-keyword">while</span> (end &lt; arr.length &amp;&amp; sum + minSums[end] &lt;= k) &#123;
         sum += minSums[end];
         end = minSumEnds[end] + <span class="hljs-number">1</span>;
      &#125;
      <span class="hljs-comment">// 不管越界还是累加跳出来的都对</span>
      <span class="hljs-comment">// [i....](end...x)</span>
      <span class="hljs-comment">// [i.... ] x</span>
      res = Math.max(res, end - i);
      <span class="hljs-keyword">if</span> (end &gt; i) &#123; <span class="hljs-comment">// 窗口内还有数 [i~end) [4,4)</span>
         sum -= arr[i];
      &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 窗口内已经没有数了，说明从i开头的所有子数组累加和都不可能&lt;=k</span>
         end = i + <span class="hljs-number">1</span>;
      &#125;
   &#125;
   <span class="hljs-keyword">return</span> res;
&#125;</code></pre></div>



<h1 id="哈希函数有关的结构和岛问题"><a href="#哈希函数有关的结构和岛问题" class="headerlink" title="哈希函数有关的结构和岛问题"></a>哈希函数有关的结构和岛问题</h1><h2 id="认识哈希函数"><a href="#认识哈希函数" class="headerlink" title="认识哈希函数"></a>认识哈希函数</h2><p>out  f(in data)</p>
<p>in为输入类型，out为输出类型</p>
<ol>
<li>输入参数data，假设是in类型，特征：可能性无穷大，比如str类型的参数</li>
<li>输出参数类型out，特征：可能性可以很大，但一定是有穷尽的</li>
<li>哈希函数没有任何随机的机制，固定的输入一定是固定的输出</li>
<li>输入无穷多但输出值有限，所以不同输入也可能输出相同（哈希碰撞）</li>
<li>再相似的不同输入，得到的输出值，会 <strong>几乎均匀的分布在out域</strong> 上<br>重点：第5条！</li>
</ol>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210330202849.png" srcset="/img/loading.gif"></p>
<p>假设有一个框能框住s区域，s区域不同的框框中的都差不多；</p>
<p>散列函数</p>
<p>输入很像并不能决定输出很像，输出一定会是离散；</p>
<h2 id="哈希函数作用"><a href="#哈希函数作用" class="headerlink" title="哈希函数作用"></a>哈希函数作用</h2><p>可以把数据根据不同值，几乎均匀的分开</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210330203525.png" srcset="/img/loading.gif"></p>
<p>可以用得到的out模上m，得到的也会是均匀输出</p>
<p>假设有一个四十亿个整数的文件，每一个整数四个字节，文件一行一个整数</p>
<p>假设只有1G的内存，统计哪一个数出现的次数最多</p>
<p>key出现数，value次数，都是无符号整数</p>
<p>如果1g内存都作哈希表，能放多少个数</p>
<p>一条记录8字节，key4字节，value4字节，还有内部索引空间…..(假设不算)；</p>
<p>假设都不一样，最差情况 8 * 40 亿个字节，32G，是会爆内存的</p>
<p>1G内存最多能装多少记录？</p>
<p>40亿除以32，假设再保守一点，40亿除以40也就是一亿条的时候不会爆；</p>
<p>读到一个数，用哈希函数的到返回值，让其 <strong>模上40</strong> </p>
<p>得到0 - 39范围上的数；</p>
<p>把原数据分别发送到对应的0，1，2….39号小文件里面</p>
<p>这时候就可以认为</p>
<p>0…39文件中所含有不同数字的总数， <strong>几乎均等</strong> </p>
<p>第一次统计0号文件记录，第二次统计…</p>
<p>直到得到40个top1，取最大的top</p>
<h2 id="哈希表的实现"><a href="#哈希表的实现" class="headerlink" title="哈希表的实现"></a>哈希表的实现</h2><p>增删查改 O(1)</p>
<blockquote>
<p>最传统的HashMap</p>
</blockquote>
<p>假设有17个格子的空间，一开始放入一个键值对为 abc 1</p>
<p>会把abc用哈希函数再与17去模后放入</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210331003811.png" srcset="/img/loading.gif" alt="传统"></p>
<p>左边类似于单链表串下去</p>
<p>假设有一个新串的哈希值碰撞了，abc底下再串一个，而不是覆盖</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210331004125.png" srcset="/img/loading.gif" alt="哈希碰撞"></p>
<p>查询的时候，用哈希函数找到对应格子用单链表遍历到abc</p>
<p>增删改查都类似；</p>
<p>因为是类似均匀分配，如果有一条链超过x，其他差不多也超过x；</p>
<p>后面会进行 <strong>扩容</strong> ：</p>
<p> <strong>暴力扩容</strong> ：</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210331004551.png" srcset="/img/loading.gif" alt="扩容"></p>
<p>就是暴力用原数据模新模来放进去，放完之后如果是上图数据大小的话，之后样本长度差不多为之前一半</p>
<p>log2为底的N基上为扩容的次数</p>
<p>暴力扩容总代价为(1 + 2 + 4 + 8….+ N/2)；所以扩容总代价O(N)</p>
<p>如果算上平均 均摊 就是应该为O(1)，后续有 <strong>改进</strong> </p>
<p>比如JVM可以 <strong>离线扩容</strong> ，不占用用户在线时间</p>
<p>或者桶 <strong>不按照单链表</strong> 串，而使用 <strong>有序表</strong>  ，不用链表长度为6再扩容，有序表查为logk，可以放很多</p>
<p>所以 <strong>哈希表再使用时，增删查改时间复杂度都为O(1)</strong> </p>
<h2 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h2><p>1）利用哈希函数的性质</p>
<p>2）每一条数据提取特征</p>
<p>3）加入描黑库</p>
<p>类似于没有删除的 <strong>黑名单系统</strong> </p>
<p>100亿的url构成的 <strong>黑名单</strong> （爬虫问题）</p>
<p>每一个爬虫爬到url，就塞入表；</p>
<p>假设100亿url64字节的，6400亿字节差不多640G <strong>内存</strong> ；</p>
<p>首先有一个类似于 <strong>位图</strong> 的东西，bit数组，每一个位置占用一个bit表示01</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210331012220.png" srcset="/img/loading.gif" alt="code"></p>
<p>最终得到就是：</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210331012257.png" srcset="/img/loading.gif" alt="右移"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210331012459.png" srcset="/img/loading.gif" alt="右移"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210331012701.png" srcset="/img/loading.gif" alt="设置"></p>
<p>假设申请的是整形数组，最大数字为21亿多一些，能表示21亿多一些 * 32位的位图</p>
<p>long能表示21亿多一些 * 64位的位图，因为数组长度Integer.MAX_VALUE</p>
<p>如果还不够，就可以用矩阵表示</p>
<p>找行找列</p>
<p>m长度的位图，m/8个字节数可以使用；</p>
<p> <strong>布隆过滤器</strong> 先设置一个m长度的位图，利用哈希函数算出哈希值，模上m决定一个位置描黑</p>
<p>url用另外一个独立的哈希函数算出out2，模上m得到新的位置再描黑；</p>
<p>若一共有k个哈希函数，能描黑k的位置，有可能k的位置中有重复的；</p>
<p>这个时候就说url <strong>加入过黑名单</strong> </p>
<p>查询算k个哈希值模m算k的位置，只有k的位置都黑才算在黑名单中</p>
<p> <strong>一定存在失误率</strong> ，只给1000个bit位图，100亿url搞完几乎全黑，全黑后报谁都是黑名单；</p>
<p> <strong>布隆过滤器</strong> 失误类型 <strong>不可能为是黑名单的url误报为非黑名单</strong> ，一定是非黑名单误报为黑名单。</p>
<h3 id="布隆过滤器重要的三个公式"><a href="#布隆过滤器重要的三个公式" class="headerlink" title="布隆过滤器重要的三个公式"></a>布隆过滤器重要的三个公式</h3><p>1，假设数据量为n，预期的失误率为p（布隆过滤器大小和每个样本的大小无关）<br>2，根据n和p，算出Bloom Filter一共需要多少个bit位，向上取整，记为m<br>3，根据m和n，算出Bloom Filter需要多少个哈希函数，向上取整，记为k<br>4，根据修正公式，算出真实的失误率p_true</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210331014315.png" srcset="/img/loading.gif" alt="公式"></p>
<p>如果设计一个黑名单系统，提前规定 <strong>失误率</strong> </p>
<p>m空间有理论和实际，用理论算k，k12.7时，k实际为13</p>
<p>此时就会存在真实失误率，都带入实际值，得到真实失误率， <strong>一般都更低</strong> 。</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210331015050.png" srcset="/img/loading.gif" alt="关系"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210331015107.png" srcset="/img/loading.gif" alt="关系"></p>
<p>k个哈希函数怎么得到呢？</p>
<p>找两个哈希函数就行，f和g；</p>
<p>f函数的返回值 加上 1 * g的返回值 第一个哈希函数</p>
<p>f函数的返回值 加上 2 * g的返回值….第二个哈希函数</p>
<h2 id="一致性哈希"><a href="#一致性哈希" class="headerlink" title="一致性哈希"></a>一致性哈希</h2><p>分布式 <strong>存储结构</strong> 最常见的结构</p>
<p>1）哈希域变成环的设计</p>
<p>2）虚拟节点技术</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210331185719.png" srcset="/img/loading.gif" alt="传统"></p>
<p>经典结构为：算hashcode存放到不同的数据端实现分布式；</p>
<p>如果对key作大量的索引，比如查询 ，要从不同服务器作merge(MapReduce)</p>
<p>要实现 <strong>负载均衡</strong> 高中低频key也应该均匀分布，都要有一些；</p>
<p>能作hash的key应该足够多；</p>
<blockquote>
<p>传统负载均衡底层数据服务器问题</p>
</blockquote>
<p>增加机器和减少机器会特别麻烦；</p>
<p>要重新做hash，全量迁移</p>
<h3 id="hash成环"><a href="#hash成环" class="headerlink" title="hash成环"></a>hash成环</h3><blockquote>
<p>一致性哈希解决问题</p>
</blockquote>
<p>既可以做到负载均衡，也可以解决迁移问题</p>
<p>把哈希函数的返回值想象成一个环；</p>
<p>假设有三台机器，一定有ip、hostname、mac地址不同，取出能区分的东西；</p>
<p>一致性哈希里面没有模这个问题，都是hash值；</p>
<p>假设用hostname作哈希，得到m1，m2，m3；不一定很均分</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210331191429.png" srcset="/img/loading.gif"></p>
<p>假设要存储abc，计算出hash，顺时针找到的第一台机器，就是它的归属</p>
<p>假设三台机器code足够均匀，就可以负载均衡；</p>
<p>假设m1要下线，把m1的数据给m2，数据迁移就完成</p>
<p>假设要加mk，找到属于的一段，迁移就行</p>
<blockquote>
<p>怎么找？</p>
</blockquote>
<p>m1,m2,m3算出来有hashcode</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210331192104.png" srcset="/img/loading.gif" alt="下发"></p>
<p>找刚刚大于等于abc的hashcode的机器即可（可以用二分）</p>
<blockquote>
<p>还存在问题</p>
</blockquote>
<ol>
<li><p>刚开始机器少，散列后可能不均匀</p>
</li>
<li><p>减机器的时候也可能造成负载不均匀</p>
</li>
</ol>
<h3 id="虚拟节点技术"><a href="#虚拟节点技术" class="headerlink" title="虚拟节点技术"></a>虚拟节点技术</h3><p>例如给m1,m2,m3分别分配1000个字符串，是能够找到字符串归属于哪一台机器的，</p>
<p>用每台数据储存服务器的字符串去抢环</p>
<p>虚拟节点抢到的数据归属于本身机器</p>
<p>增加机器的时候，一样分配一千个字符串去抢环，然后归属</p>
<p> <strong>字符串数量没到万亿级别，几乎不会出现碰撞</strong> </p>
<p>也能实现 <strong>负载管理</strong> ，如果一个机器性能更强，相对给予更多的字符串，抢更多的点</p>
<h1 id="并行算法"><a href="#并行算法" class="headerlink" title="并行算法"></a>并行算法</h1><h2 id="岛问题"><a href="#岛问题" class="headerlink" title="岛问题"></a>岛问题</h2><blockquote>
<p> 岛问题只是一种启发性的说明</p>
</blockquote>
<p>一个只有0和1两种数字的二维矩阵中，<br>上下左右能练成一片的1，算一个岛<br>返回矩阵中，一共有几个岛(上下左右相连)</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">countIslands1</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] m)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (m == <span class="hljs-keyword">null</span> || m[<span class="hljs-number">0</span>] == <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
   &#125;
   <span class="hljs-keyword">int</span> N = m.length;
   <span class="hljs-keyword">int</span> M = m[<span class="hljs-number">0</span>].length;
   <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; M; j++) &#123;
         <span class="hljs-keyword">if</span> (m[i][j] == <span class="hljs-number">1</span>) &#123;
            res++;
            infect(m, i, j, N, M);
         &#125;
      &#125;
   &#125;
   <span class="hljs-keyword">return</span> res;
&#125;

<span class="hljs-comment">// 感染函数 来到i，j 把上下左右所到之路感染为2</span>
<span class="hljs-comment">// N行 M列</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">infect</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] m, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j, <span class="hljs-keyword">int</span> N, <span class="hljs-keyword">int</span> M)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || i &gt;= N || j &lt; <span class="hljs-number">0</span> || j &gt;= M || m[i][j] != <span class="hljs-number">1</span>) &#123;
      <span class="hljs-keyword">return</span>;
   &#125;
   <span class="hljs-comment">// i j不越界也是1</span>
   m[i][j] = <span class="hljs-number">2</span>;
   infect(m, i + <span class="hljs-number">1</span>, j, N, M);
   infect(m, i - <span class="hljs-number">1</span>, j, N, M);
   infect(m, i, j + <span class="hljs-number">1</span>, N, M);
   infect(m, i, j - <span class="hljs-number">1</span>, N, M);
&#125;</code></pre></div>



<blockquote>
<p>问题</p>
</blockquote>
<p>O(N * M)</p>
<p>矩阵如果很大，单cpu运行很乏力；</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210331202150.png" srcset="/img/loading.gif" alt="分两个cpu"></p>
<p>分两个cpu处理，建立分割记录</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210331202700.png" srcset="/img/loading.gif"></p>
<p>只关心左右两边都是1的情况</p>
<p>遇到则判断是否一个集合，是的话下一个，不是的话union</p>
<p>可以分为很多个部分，分配cpu</p>
<h1 id="资源限制技巧汇总"><a href="#资源限制技巧汇总" class="headerlink" title="资源限制技巧汇总"></a>资源限制技巧汇总</h1><p>1）布隆过滤器用于集合的建立与查询，并可以节省大量空间（已讲）<br>2）一致性哈希解决数据服务器的负载管理问题（已讲）<br>3）利用并查集结构做岛问题的并行计算（已讲）<br>4）哈希函数可以把数据按照种类均匀分流<br>5）位图解决某一范围上数字的出现情况，并可以节省大量空间<br>6）利用分段统计思想、并进一步节省大量空间<br>7）利用堆、外排序来做多个处理单元的结果合并</p>
<h2 id="题目一-1"><a href="#题目一-1" class="headerlink" title="题目一"></a>题目一</h2><p>32位无符号整数的范围是0~4,294,967,295，<br>现在有一个正好包含40亿个无符号整数的文件，<br>可以使用最多1GB的内存，怎么找到出现次数最多的数？</p>
<p> <strong>上面哈希章节</strong> </p>
<h2 id="题目二-2"><a href="#题目二-2" class="headerlink" title="题目二"></a>题目二</h2><p>32位无符号整数的范围是0~4,294,967,295，<br>现在有一个正好包含40亿个无符号整数的文件，<br>所以在整个范围中必然存在没出现过的数。<br>可以使用最多1GB的内存，怎么找到所有未出现过的数？</p>
<p>用哈希表 42亿 * 4字节 差不多16G</p>
<p>用 <strong>位图</strong> ，0 - 2^ 32 -1 用2^ 32个bit表示一个数出现过没有</p>
<p>哈希表是4个字节表示是否出现，位图一个bit表示一个数是否出现，16G/32差不多500多M</p>
<p>【进阶】<br>内存限制为 10MB，但是只用找到一个没出现过的数即可</p>
<p>内存限制为 3kb，但是只用找到一个没出现过的数即可</p>
<p> <strong>3kb转化为int数组</strong> ，比如找到3k / 4 = 3 * 256 ，找离这个数最近的2的次方，即为 2^ 9；</p>
<p>所以吧数组定成512长度的话，一定不会爆空间；</p>
<p>int[512]:  0~2^32 - 1数字，2^32能均分512，均分一份是2^32 / 512 = 8388608</p>
<p>第0份统计8388608出现了多少个数；</p>
<p>遍历所有数组，中了范围在counts[i]++</p>
<p>必在某一个范围内词频统计不够8388608，则在这个范围上必缺数字，</p>
<p>找到L…R，继续重复拿3kb分，直到3kb能单独做到统计数组；</p>
<p>内存限制为 3个变量，但是只用找到一个没出现过的数即可</p>
<p> <strong>二分</strong> </p>
<p>遍历左侧，判断哪边数字小于一半，继续二分小于一半的区域….</p>
<h2 id="题目三-3"><a href="#题目三-3" class="headerlink" title="题目三"></a>题目三</h2><p>有一个包含100亿个URL的大文件，假设每个URL占用64B，<br>请找出其中所有重复的URL<br>【补充】<br>某搜索公司一天的用户搜索词汇是海量的(百亿数据量)，<br>请设计一种求出每天热门Top100词汇的可行办法</p>
<p>补充和重复是一样的问题</p>
<p>用 <strong>哈希</strong> 发配到不同机器上，如果一个机器种类过多，继续哈希；</p>
<p> <strong>不怕重复的多，怕种类多</strong> </p>
<p>top100就是哈希分机器，哈希分文件，统计文件top100</p>
<p>总体都是mapper和reducer</p>
<p> <strong>外排</strong> ，各个文件top1 pk弹出，再pk新顶部和其他的….</p>
<p>也可以用 <strong>二维堆</strong> 找出来</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210401172823.png" srcset="/img/loading.gif" alt="二维堆"></p>
<p>每个大根堆的结点还是一个大根堆</p>
<h2 id="题目四"><a href="#题目四" class="headerlink" title="题目四"></a>题目四</h2><p>32位无符号整数的范围是0~4294967295，<br>现在有40亿个无符号整数，<br>可以使用最多1GB的内存，<br>找出所有出现了两次的数。</p>
<p>用两个bit表示一个数字出现的频率；00表示初始状态，出现多一次变成01，再多10…出现更多次都是11</p>
<p>16G/32 * 2 = 1G左右</p>
<h2 id="题目五"><a href="#题目五" class="headerlink" title="题目五"></a>题目五</h2><p>32位无符号整数的范围是0~4294967295，现在有40亿个无符号整数<br>可以使用最多10MB的内存，怎么找到这40亿个整数的中位数？</p>
<p>用题目二的方式用3kb开整型数组，int[512]，每一份8388608，求第二十亿小的数；</p>
<p>遍历统计，定位到第二十亿位数的空间</p>
<h2 id="题目六"><a href="#题目六" class="headerlink" title="题目六"></a>题目六</h2><p>32位无符号整数的范围是0~4294967295，<br>有一个10G大小的文件，每一行都装着这种类型的数字，<br>整个文件是无序的，给你5G的内存空间，<br>请你输出一个10G大小的文件，就是原文件所有数字排序的结果</p>
<p> <strong>小根堆</strong> 记录目前为止最大的两个数，并记录出现次数，哈希表记录在小根堆出现的位置；</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210401181749.png" srcset="/img/loading.gif" alt="例子"></p>
<p>能统计全局最大前两个及次数，下一次重复行为，大于等于第二大的数不再统计；</p>
<blockquote>
<p>10G文件，5G内存</p>
</blockquote>
<p>估算map和小根堆能堆放的记录，去怼文件排序就行</p>
<h1 id="有序表的原理、应用、扩展"><a href="#有序表的原理、应用、扩展" class="headerlink" title="有序表的原理、应用、扩展"></a>有序表的原理、应用、扩展</h1><p class="note note-primary">代码传github</p>

<h2 id="搜索二叉树"><a href="#搜索二叉树" class="headerlink" title="搜索二叉树"></a>搜索二叉树</h2><p>搜索二叉树一定要说明以什么标准来排序</p>
<p>经典的搜索二叉树，树上 <strong>没有重复</strong> 的用来排序的key值</p>
<p>(没有重复因为 <strong>平衡性调整问题</strong> ，无法控制一律放在哪边的问题)</p>
<p>如果有重复节点的需求，可以在一个节点 <strong>内部增加数据项</strong> </p>
<h3 id="搜索二叉树查询key"><a href="#搜索二叉树查询key" class="headerlink" title="搜索二叉树查询key"></a>搜索二叉树查询key</h3><p>1）如果当前节点的value==key，返回true<br>2）如果当前节点的value&lt;key，当前节点向左移动<br>3）如果当前节点的value&gt;key，当前节点向右移动<br>4）如果当前节点变成null，返回false</p>
<h3 id="搜索二叉树插入新的key"><a href="#搜索二叉树插入新的key" class="headerlink" title="搜索二叉树插入新的key"></a>搜索二叉树插入新的key</h3><p>和查询过程一样，但当前节点滑到空的时候，就插入在这里</p>
<h3 id="搜索二叉树删除key"><a href="#搜索二叉树删除key" class="headerlink" title="搜索二叉树删除key"></a>搜索二叉树删除key</h3><p>0）先找到key所在的节点<br>1）如果该节点没有左孩子、没有右孩子，直接删除即可<br>2）如果该节点有左孩子、没有右孩子，直接用左孩子顶替该节点<br>3）如果该节点没有左孩子、有右孩子，直接用右孩子顶替该节点<br>4）如果该节点有左孩子、有右孩子，用该节点 <strong>后继节点</strong> 顶替该节点</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210401193315.png" srcset="/img/loading.gif" alt="右树最左"></p>
<p>6有右孩子扔给8即可</p>
<p>删除要判断后继结点的父节点是否为待删除节点；</p>
<h3 id="裸搜索二叉树问题"><a href="#裸搜索二叉树问题" class="headerlink" title="裸搜索二叉树问题"></a>裸搜索二叉树问题</h3><p> <strong>输入状况决定性能</strong> </p>
<p>输入状况很好，左右均分，logN</p>
<p>输入状况不好，全左全右，N</p>
<p>1）基础的搜索二叉树，添加、删除时候 <strong>不照顾平衡性</strong> </p>
<p>2）数据状况很差时，性能就很差</p>
<p>给搜索二叉树引入两个动作：<strong>左旋、右旋</strong> ，log(N)</p>
<p>对 X 进行右旋， X倒向右方</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210401200133.png" srcset="/img/loading.gif" alt="对a右旋"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210401200409.png" srcset="/img/loading.gif" alt="左旋"></p>
<p>有序表特殊功能</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210401201836.png" srcset="/img/loading.gif"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210401201936.png" srcset="/img/loading.gif"></p>
<p>TreeMap底层平衡搜索二叉树</p>
<p>hashMap增删改查O(1)</p>
<p>TreeMap O(logN)</p>
<h2 id="AVL树、SB树、红黑树的共性"><a href="#AVL树、SB树、红黑树的共性" class="headerlink" title="AVL树、SB树、红黑树的共性"></a>AVL树、SB树、红黑树的共性</h2><p>1）都是搜索二叉树</p>
<p>2）插入、删除、查询（一切查询）搜索二叉树怎么做，这些结构都这么做</p>
<p>3）使用调整的基本动作都只有左旋、右旋</p>
<p>4）插入、删除时，从最底层被影响到的节点开始，对往上路径的节点做平衡性检查</p>
<p>5）因为只对一条向上路径的每个节点做O(1)的检查和调整，所以可以做到O(logN)</p>
<p>性能指标完全一样，有差别的是常数时间、跳表、实现</p>
<h2 id="AVL树、SB树、红黑树的不同"><a href="#AVL树、SB树、红黑树的不同" class="headerlink" title="AVL树、SB树、红黑树的不同"></a>AVL树、SB树、红黑树的不同</h2><p>1）平衡性的约束不同</p>
<p>AVL树最严格（ <strong>左树高 - 右树高 的绝对值 &lt; 2</strong> ）、</p>
<p>SB树稍宽松（任何一个 <strong>叔结点</strong> 所拥有的结点数不少于它的任何一个 <strong>侄子结点</strong> ）、</p>
<p>这样左树跟右树数量关系 维持到 <strong>至多多一倍 + 1</strong> </p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210401202616.png" srcset="/img/loading.gif"></p>
<p>红黑树最宽松</p>
<blockquote>
<p>红黑树特性</p>
</blockquote>
<ol>
<li>每一个结点红 或者 黑</li>
<li>头结点黑 叶节点黑</li>
<li>红结点的子结点为黑（两红不相邻）</li>
<li>从任何一个结点到每一个子的所有路径上黑结点一样多</li>
</ol>
<p>最长的链一定是黑红交替，最短的一定是全黑，所以也不会超过一半</p>
<p>2）插入、删除和搜索二叉树一样，但是额外，做各自的平衡性调整。各自的平衡性调整所使用的动作都是 <strong>左旋或者右旋</strong> </p>
<p>三种树都是从 <strong>受影响的结点</strong> 开始检查，只不过到具体一个结点的 <strong>检查的动作不一样</strong> 。</p>
<h2 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h2><p>1）最严格的平衡性，任何节点左树高度和右树高度差不超过1</p>
<p>2） <strong>受影响的结点</strong> 开始（删除、插入），往上沿途检查每个节点时，都去检查四种违规情况：LL、RR、LR、RL</p>
<p>​        如果删除时，用了后继结点替代，则从 <strong>后继结点原位置</strong> 开始网上检查。</p>
<p>3）不同情况虽然看起来复杂，但是核心点是：<br>LL（做一次右旋）、RR（做一次左旋）<br>LR和RL（利用旋转让底层那个上到顶部）</p>
<p>| 左树高度 - 右树高度 | &lt; 2 不违规；</p>
<p>| 左树高度 - 右树高度 | &gt; 1；</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210401225201.png" srcset="/img/loading.gif" alt="LL型"></p>
<p>LL型，左树的左树导致不平</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210401225412.png" srcset="/img/loading.gif" alt="LR型"></p>
<p>LR型，左树的右树不平….</p>
<p>RR..RL</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210401225814.png" srcset="/img/loading.gif">假设左边为7右边为6，只可能左树的左子树为6或者右子树为6，不可能都为6，都为6之前就已经违规了</p>
<blockquote>
<p>如何旋转</p>
</blockquote>
<ul>
<li>LL型x右旋即可,RR型x左旋即可，一次动作</li>
</ul>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210401230223.png" srcset="/img/loading.gif" alt="右旋"></p>
<ul>
<li><p>LR型</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210401230440.png" srcset="/img/loading.gif"></p>
<p>让底下的 <strong>孙结点</strong> 上到顶部</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210401230704.png" srcset="/img/loading.gif" alt="先让左边c代替a"></p>
<p>再让x右旋</p>
<p>所插的点一路插到最顶</p>
<p>转两次，每个节点都是O(1)的代价，一路往上每个节点都查找，O(log(N))的复杂度</p>
</li>
</ul>
<h2 id="SB树（size-balance-tree）"><a href="#SB树（size-balance-tree）" class="headerlink" title="SB树（size-balance-tree）"></a>SB树（size-balance-tree）</h2><p>AVL维护 <strong>高度</strong> ，sb树维护 <strong>节点数</strong> ，不算重复的key，只算种类</p>
<p>1）让每一个叔叔节点为头的数，节点个数都不少于其任何一个侄子节点<br>2）也是从底层被影响节点开始向上做路径每个节点检查<br>3）与AVL树非常像，也是四种违规类型：LL、RR、LR、RL<br>4）与AVL树非常像，核心点是：<br>LL（做一次右旋）、RR（做一次左旋）<br>LR和RL（利用旋转让底层那个上到顶部）<br>5）与AVL树不同的是，每轮经过调整后，谁的孩子发生变化了，谁就再查</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210402000039.png" srcset="/img/loading.gif" alt="sb RL型"></p>
<p>查到x时，发现左孩子没有右孩子的左孩子多，RL；</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210402000133.png" srcset="/img/loading.gif" alt="RR"></p>
<p>没有右孩子的右孩子多，RR；</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210402000251.png" srcset="/img/loading.gif"></p>
<blockquote>
<p>平衡调整</p>
</blockquote>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210402001131.png" srcset="/img/loading.gif" alt="LL"></p>
<p>进行一波右旋后，要找到子孩子改变的结点（x和b）进行递归调用m（x）调整平衡性</p>
<p>m(x)函数的意义是在x上进行检查孩子和孩子的孩子违规情况</p>
<p>是一个递归套递归的过程</p>
<p>因为 <strong>换了孩子后，孩子pk的对象改变了</strong> ，要重复执行m(x)和m(b)防止孩子出现问题；</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210402002011.png" srcset="/img/loading.gif" alt="RR"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210402192028.png" srcset="/img/loading.gif" alt="LR"></p>
<h3 id="SB树在使用时候的改进"><a href="#SB树在使用时候的改进" class="headerlink" title="SB树在使用时候的改进"></a>SB树在使用时候的改进</h3><p>1）删除时候 <strong>可以不用检查</strong> </p>
<p>2）就把平衡性的调整放在 <strong>插入</strong> 的时候</p>
<p>3）因为这种只要变就递归的特性，别的树没有</p>
<p>4）可以在节点上封装别的数据项，来增加功能</p>
<h2 id="跳表（skiplist）"><a href="#跳表（skiplist）" class="headerlink" title="跳表（skiplist）"></a>跳表（skiplist）</h2><p>实现机制和二叉树没关系</p>
<p>1）结构上根本和 <strong>搜索二叉树无关</strong> </p>
<p>2）利用随机概率分布来使得高层索引可以无视数据规律，做到整体性能优良</p>
<p>3） <strong>思想</strong> 是所有有序表中最 <strong>先进</strong> 的</p>
<p>4）结构简单就是 <strong>多级单链表</strong> </p>
<p>最初的node，最顶部天然存在，全局最小值为null</p>
<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210403192343.png" srcset="/img/loading.gif" alt="node" style="zoom:25%;" />

<p>假设要加（3，abc），会生成一个node，并且本身有一条指针，然后掷骰子决定</p>
<p>掷出0，加一条指针，直到掷1；</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210403192548.png" srcset="/img/loading.gif" alt="掷骰子"></p>
<p>自己结点不会再拓展了，只会拓展初始的</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210403192833.png" srcset="/img/loading.gif" alt="拓展"></p>
<p>然后依次从第一层（最高层）找到小于等于3的key，没有，则指向(3, abc)</p>
<p>从第二层找…第三层…</p>
<p>直到</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210403193053.png" srcset="/img/loading.gif"></p>
<p>有高层一定有底层，不会断层</p>
<p>假设再加一个5，假设5只有2层，左侧三层，不需要扩；</p>
<p>从最高层开始找，遍历最高层单链表，找到小于等于5最晚的结点3，但是5没有三层，3此时不指向5</p>
<p>直接往下跳，3第二层指针指向5；</p>
<p>往下走，3第三层指向5；</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210403193403.png" srcset="/img/loading.gif"></p>
<p>假设一个结点2，只有一层，</p>
<p>最高层开始，小于等于2最晚的key在大结点上，无法跳到3，</p>
<p>2没有三层结点，往下跳，往下跳，在最后一层</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210403193510.png" srcset="/img/loading.gif"></p>
<blockquote>
<p>查询过程</p>
</blockquote>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210403193900.png" srcset="/img/loading.gif" alt="查询"></p>
<p>找都是从最高层开始找；</p>
<blockquote>
<p>好在哪？</p>
</blockquote>
<p>假设加入了N个记录，第一层一定是N个，拥有第二个期望是 N/2，第三层 N/4……</p>
<p>从最高层开始找…..</p>
<p> <strong>由高层到底层建立了索引关系</strong> </p>
<p>可以收敛到 logN</p>
<h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><ol>
<li>每一个结点非红即黑</li>
<li>头结点黑 叶节点黑</li>
<li>红结点的子结点为黑（两红不相邻）</li>
<li>从任何一个结点到每一个叶节点的所有路径上黑结点一样多</li>
<li>最长链黑红黑红黑红黑…最短链黑黑黑黑</li>
</ol>
<p>1）平衡性规定非常诡异<br>2）平衡性调整最为复杂（插入5种，删除8种）<br>3）优点在于每次插入删除扰动较好，但是在今天看来这个优势也极其微弱了<br>原因：贪图插入频繁 扰动小的话，底层硬盘组织的 B+树、2-3-4树可能更好，还是那句话，到底图什么<br>4）除此之外，红黑树并不比AVL树、SB树、跳表更加优秀</p>
<p>红黑树在纯插入和纯查询这两者之间达到了一种平衡</p>
<p>redis为什么用跳表？</p>
<p>可能有序列化要求，skiplist好序列化</p>
<h2 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h2><h3 id="数组区间问题"><a href="#数组区间问题" class="headerlink" title="数组区间问题"></a>数组区间问题</h3><p>二维数组，每一行都有序，想找到一个左闭右闭的区间。</p>
<p>使每一个数组总有一个数字命中在区间里面；</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210404202146.png" srcset="/img/loading.gif"></p>
<blockquote>
<p>流程</p>
</blockquote>
<p>第一回把数组中第0个数放到有序表里面</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210404202449.png" srcset="/img/loading.gif"></p>
<p>找到了有序表中的一个区间，最小值和最大构成 [1, 5]</p>
<p>有序表中弹出最小的，来自于谁，把谁的下一个数字扔进来，拍完后[3, 5]</p>
<p>比原来更窄，记上新答案；</p>
<p>再弹出，把来源下一个数字9加入，[4, 9]</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210404202708.png" srcset="/img/loading.gif"></p>
<h3 id="改写有序表（子数组累加和区间问题）"><a href="#改写有序表（子数组累加和区间问题）" class="headerlink" title="改写有序表（子数组累加和区间问题）"></a>改写有序表（子数组累加和区间问题）</h3><p>给定一个数组arr，和两个整数a和b（a&lt;=b）<br>求arr中有多少个子数组，累加和在[a,b]这个范围上<br>返回达标的子数组数量</p>
<p>假设 0 - i整体累加和是100，如果 0 -j的累加和是 80， j + 1 - i的累加和是20</p>
<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210404233611.png" srcset="/img/loading.gif" style="zoom:50%;" />

<p>如果子数组必须以i位置数结尾的情况下，多少子数组最后累加和可以 10 - 30？</p>
<p>等于求 0 - i - 1 多少前缀和范围在 70 - 90 范围上</p>
<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210404233846.png" srcset="/img/loading.gif" style="zoom:50%;" />

<p>问题就转化为了求前缀和</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210404234149.png" srcset="/img/loading.gif"></p>
<p>就变成找到一种结构，存储前缀和</p>
<p>这种结构可以add() 允许重复值，给一个上界和下界求范围上多少个</p>
<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210404234741.png" srcset="/img/loading.gif" style="zoom:50%;" />

<p>求[L, R]可以先求小于R + 1；再求小于 L，减一下即可；</p>
<blockquote>
<p>怎么让有序表允许增加重复</p>
</blockquote>
<p>增加一个字段 all，计算到达次数。</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210404235507.png" srcset="/img/loading.gif"></p>
<p>往左滑 ans不获得任何数据</p>
<p>往右滑 ans获得头结点减去右的信息</p>
<p>找到6 不用滑了 如果6有左树加上左树的量</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SBTNode</span> </span>&#123;
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> key;
   <span class="hljs-keyword">public</span> SBTNode l;
   <span class="hljs-keyword">public</span> SBTNode r;
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> size; <span class="hljs-comment">// 不同key的size</span>
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> all; <span class="hljs-comment">// 总的size</span>

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SBTNode</span><span class="hljs-params">(<span class="hljs-keyword">long</span> k)</span> </span>&#123;
      key = k;
      size = <span class="hljs-number">1</span>;
      all = <span class="hljs-number">1</span>;
   &#125;
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SizeBalancedTreeSet</span> </span>&#123;
   <span class="hljs-keyword">private</span> SBTNode root;
   <span class="hljs-keyword">private</span> HashSet&lt;Long&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();

   <span class="hljs-function"><span class="hljs-keyword">private</span> SBTNode <span class="hljs-title">rightRotate</span><span class="hljs-params">(SBTNode cur)</span> </span>&#123;
      <span class="hljs-keyword">long</span> same = cur.all - (cur.l != <span class="hljs-keyword">null</span> ? cur.l.all : <span class="hljs-number">0</span>) - (cur.r != <span class="hljs-keyword">null</span> ? cur.r.all : <span class="hljs-number">0</span>);
      SBTNode leftNode = cur.l;
      cur.l = leftNode.r;
      leftNode.r = cur;
      leftNode.size = cur.size;
      cur.size = (cur.l != <span class="hljs-keyword">null</span> ? cur.l.size : <span class="hljs-number">0</span>) + (cur.r != <span class="hljs-keyword">null</span> ? cur.r.size : <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>;
      <span class="hljs-comment">// all modify</span>
      leftNode.all = cur.all;
      cur.all = (cur.l != <span class="hljs-keyword">null</span> ? cur.l.all : <span class="hljs-number">0</span>) + (cur.r != <span class="hljs-keyword">null</span> ? cur.r.all : <span class="hljs-number">0</span>) + same;
      <span class="hljs-keyword">return</span> leftNode;
   &#125;

   <span class="hljs-function"><span class="hljs-keyword">private</span> SBTNode <span class="hljs-title">leftRotate</span><span class="hljs-params">(SBTNode cur)</span> </span>&#123;
      <span class="hljs-keyword">long</span> same = cur.all - (cur.l != <span class="hljs-keyword">null</span> ? cur.l.all : <span class="hljs-number">0</span>) - (cur.r != <span class="hljs-keyword">null</span> ? cur.r.all : <span class="hljs-number">0</span>);
      SBTNode rightNode = cur.r;
      cur.r = rightNode.l;
      rightNode.l = cur;
      rightNode.size = cur.size;
      cur.size = (cur.l != <span class="hljs-keyword">null</span> ? cur.l.size : <span class="hljs-number">0</span>) + (cur.r != <span class="hljs-keyword">null</span> ? cur.r.size : <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>;
      <span class="hljs-comment">// all modify</span>
      rightNode.all = cur.all;
      cur.all = (cur.l != <span class="hljs-keyword">null</span> ? cur.l.all : <span class="hljs-number">0</span>) + (cur.r != <span class="hljs-keyword">null</span> ? cur.r.all : <span class="hljs-number">0</span>) + same;
      <span class="hljs-keyword">return</span> rightNode;
   &#125;

   <span class="hljs-function"><span class="hljs-keyword">private</span> SBTNode <span class="hljs-title">matain</span><span class="hljs-params">(SBTNode cur)</span> </span>&#123;
      <span class="hljs-keyword">if</span> (cur == <span class="hljs-keyword">null</span>) &#123;
         <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
      &#125;
      <span class="hljs-keyword">if</span> (cur.l != <span class="hljs-keyword">null</span> &amp;&amp; cur.l.l != <span class="hljs-keyword">null</span> &amp;&amp; cur.r != <span class="hljs-keyword">null</span> &amp;&amp; cur.l.l.size &gt; cur.r.size) &#123;
         cur = rightRotate(cur);
         cur.r = matain(cur.r);
         cur = matain(cur);
      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cur.l != <span class="hljs-keyword">null</span> &amp;&amp; cur.l.r != <span class="hljs-keyword">null</span> &amp;&amp; cur.r != <span class="hljs-keyword">null</span> &amp;&amp; cur.l.r.size &gt; cur.r.size) &#123;
         cur.l = leftRotate(cur.l);
         cur = rightRotate(cur);
         cur.l = matain(cur.l);
         cur.r = matain(cur.r);
         cur = matain(cur);
      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cur.r != <span class="hljs-keyword">null</span> &amp;&amp; cur.r.r != <span class="hljs-keyword">null</span> &amp;&amp; cur.l != <span class="hljs-keyword">null</span> &amp;&amp; cur.r.r.size &gt; cur.l.size) &#123;
         cur = leftRotate(cur);
         cur.l = matain(cur.l);
         cur = matain(cur);
      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cur.r != <span class="hljs-keyword">null</span> &amp;&amp; cur.r.l != <span class="hljs-keyword">null</span> &amp;&amp; cur.l != <span class="hljs-keyword">null</span> &amp;&amp; cur.r.l.size &gt; cur.l.size) &#123;
         cur.r = rightRotate(cur.r);
         cur = leftRotate(cur);
         cur.l = matain(cur.l);
         cur.r = matain(cur.r);
         cur = matain(cur);
      &#125;
      <span class="hljs-keyword">return</span> cur;
   &#125;

   <span class="hljs-function"><span class="hljs-keyword">private</span> SBTNode <span class="hljs-title">add</span><span class="hljs-params">(SBTNode cur, <span class="hljs-keyword">long</span> key, <span class="hljs-keyword">boolean</span> contains)</span> </span>&#123;
      <span class="hljs-keyword">if</span> (cur == <span class="hljs-keyword">null</span>) &#123;
         <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SBTNode(key);
      &#125; <span class="hljs-keyword">else</span> &#123;
         cur.all++;
         <span class="hljs-keyword">if</span> (key == cur.key) &#123;
            <span class="hljs-keyword">return</span> cur;
         &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 还在左滑或者右滑</span>
            <span class="hljs-keyword">if</span> (!contains) &#123;
               cur.size++;
            &#125;
            <span class="hljs-keyword">if</span> (key &lt; cur.key) &#123;
               cur.l = add(cur.l, key, contains);
            &#125; <span class="hljs-keyword">else</span> &#123;
               cur.r = add(cur.r, key, contains);
            &#125;
            <span class="hljs-keyword">return</span> matain(cur);
         &#125;
      &#125;
   &#125;

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">long</span> sum)</span> </span>&#123;
      <span class="hljs-keyword">boolean</span> contains = set.contains(sum);
      root = add(root, sum, contains);
      set.add(sum);
   &#125;

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">lessKeySize</span><span class="hljs-params">(<span class="hljs-keyword">long</span> key)</span> </span>&#123;
      SBTNode cur = root;
      <span class="hljs-keyword">long</span> ans = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">while</span> (cur != <span class="hljs-keyword">null</span>) &#123;
         <span class="hljs-keyword">if</span> (key == cur.key) &#123;
            <span class="hljs-keyword">return</span> ans + (cur.l != <span class="hljs-keyword">null</span> ? cur.l.all : <span class="hljs-number">0</span>);
         &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key &lt; cur.key) &#123;
            cur = cur.l;
         &#125; <span class="hljs-keyword">else</span> &#123;
            ans += cur.all - (cur.r != <span class="hljs-keyword">null</span> ? cur.r.all : <span class="hljs-number">0</span>);
            cur = cur.r;
         &#125;
      &#125;
      <span class="hljs-keyword">return</span> ans;
   &#125;

   <span class="hljs-comment">// &gt; 7 8...</span>
   <span class="hljs-comment">// &lt;8 ...&lt;=7</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">moreKeySize</span><span class="hljs-params">(<span class="hljs-keyword">long</span> key)</span> </span>&#123;
      <span class="hljs-keyword">return</span> root != <span class="hljs-keyword">null</span> ? (root.all - lessKeySize(key + <span class="hljs-number">1</span>)) : <span class="hljs-number">0</span>;
   &#125;

&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">countRangeSum2</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> lower, <span class="hljs-keyword">int</span> upper)</span> </span>&#123;
   SizeBalancedTreeSet treeSet = <span class="hljs-keyword">new</span> SizeBalancedTreeSet();
   <span class="hljs-keyword">long</span> sum = <span class="hljs-number">0</span>;
   <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;
   treeSet.add(<span class="hljs-number">0</span>);<span class="hljs-comment">// 一个数都没有 已经有一个前缀和0</span>
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;
      sum += nums[i];
      <span class="hljs-comment">// sum i结尾的时候[lower, upper]</span>
      <span class="hljs-comment">// 先求之前有多少在[sum - upper, sum - lower]</span>
      <span class="hljs-comment">// 查 ? &lt; sum - lower + 1 a</span>
      <span class="hljs-comment">// 查 ? &lt; sum - upper b</span>
      <span class="hljs-comment">// a - b</span>
      <span class="hljs-keyword">long</span> a = treeSet.lessKeySize(sum - lower + <span class="hljs-number">1</span>);
      <span class="hljs-keyword">long</span> b = treeSet.lessKeySize(sum - upper);
      ans += a - b;
      treeSet.add(sum);
   &#125;
   <span class="hljs-keyword">return</span> ans;
&#125;</code></pre></div>



<h3 id="滑动窗口中位数"><a href="#滑动窗口中位数" class="headerlink" title="滑动窗口中位数"></a>滑动窗口中位数</h3><p>有一个滑动窗口（讲过的）：</p>
<p>1）L是滑动窗口最左位置、R是滑动窗口最右位置，一开始LR都在数组左侧<br>2）任何一步都可能R往右动，表示某个数进了窗口<br>3）任何一步都可能L往右动，表示某个数出了窗口</p>
<p>想知道每一个窗口状态的中位数(严格的中位数)</p>
<p>增加重复数字，允许删掉一次，得到第小K的函数就行</p>
<p>从头部开始滑，左孩子如果都小K，看自己，再看右边….</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SBTNode</span>&lt;<span class="hljs-title">K</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">K</span>&gt;&gt; </span>&#123;
   <span class="hljs-keyword">public</span> K key;
   <span class="hljs-keyword">public</span> SBTNode&lt;K&gt; l;
   <span class="hljs-keyword">public</span> SBTNode&lt;K&gt; r;
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> size;

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SBTNode</span><span class="hljs-params">(K k)</span> </span>&#123;
      key = k;
      size = <span class="hljs-number">1</span>;
   &#125;
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SizeBalancedTreeMap</span>&lt;<span class="hljs-title">K</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">K</span>&gt;&gt; </span>&#123;
   <span class="hljs-keyword">private</span> SBTNode&lt;K&gt; root;

   <span class="hljs-function"><span class="hljs-keyword">private</span> SBTNode&lt;K&gt; <span class="hljs-title">rightRotate</span><span class="hljs-params">(SBTNode&lt;K&gt; cur)</span> </span>&#123;
      SBTNode&lt;K&gt; leftNode = cur.l;
      cur.l = leftNode.r;
      leftNode.r = cur;
      leftNode.size = cur.size;
      cur.size = (cur.l != <span class="hljs-keyword">null</span> ? cur.l.size : <span class="hljs-number">0</span>) + (cur.r != <span class="hljs-keyword">null</span> ? cur.r.size : <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>;
      <span class="hljs-keyword">return</span> leftNode;
   &#125;

   <span class="hljs-function"><span class="hljs-keyword">private</span> SBTNode&lt;K&gt; <span class="hljs-title">leftRotate</span><span class="hljs-params">(SBTNode&lt;K&gt; cur)</span> </span>&#123;
      SBTNode&lt;K&gt; rightNode = cur.r;
      cur.r = rightNode.l;
      rightNode.l = cur;
      rightNode.size = cur.size;
      cur.size = (cur.l != <span class="hljs-keyword">null</span> ? cur.l.size : <span class="hljs-number">0</span>) + (cur.r != <span class="hljs-keyword">null</span> ? cur.r.size : <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>;
      <span class="hljs-keyword">return</span> rightNode;
   &#125;

   <span class="hljs-function"><span class="hljs-keyword">private</span> SBTNode&lt;K&gt; <span class="hljs-title">matain</span><span class="hljs-params">(SBTNode&lt;K&gt; cur)</span> </span>&#123;
      <span class="hljs-keyword">if</span> (cur == <span class="hljs-keyword">null</span>) &#123;
         <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
      &#125;
      <span class="hljs-keyword">if</span> (cur.l != <span class="hljs-keyword">null</span> &amp;&amp; cur.l.l != <span class="hljs-keyword">null</span> &amp;&amp; cur.r != <span class="hljs-keyword">null</span> &amp;&amp; cur.l.l.size &gt; cur.r.size) &#123;
         cur = rightRotate(cur);
         cur.r = matain(cur.r);
         cur = matain(cur);
      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cur.l != <span class="hljs-keyword">null</span> &amp;&amp; cur.l.r != <span class="hljs-keyword">null</span> &amp;&amp; cur.r != <span class="hljs-keyword">null</span> &amp;&amp; cur.l.r.size &gt; cur.r.size) &#123;
         cur.l = leftRotate(cur.l);
         cur = rightRotate(cur);
         cur.l = matain(cur.l);
         cur.r = matain(cur.r);
         cur = matain(cur);
      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cur.r != <span class="hljs-keyword">null</span> &amp;&amp; cur.r.r != <span class="hljs-keyword">null</span> &amp;&amp; cur.l != <span class="hljs-keyword">null</span> &amp;&amp; cur.r.r.size &gt; cur.l.size) &#123;
         cur = leftRotate(cur);
         cur.l = matain(cur.l);
         cur = matain(cur);
      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cur.r != <span class="hljs-keyword">null</span> &amp;&amp; cur.r.l != <span class="hljs-keyword">null</span> &amp;&amp; cur.l != <span class="hljs-keyword">null</span> &amp;&amp; cur.r.l.size &gt; cur.l.size) &#123;
         cur.r = rightRotate(cur.r);
         cur = leftRotate(cur);
         cur.l = matain(cur.l);
         cur.r = matain(cur.r);
         cur = matain(cur);
      &#125;
      <span class="hljs-keyword">return</span> cur;
   &#125;

   <span class="hljs-function"><span class="hljs-keyword">private</span> SBTNode&lt;K&gt; <span class="hljs-title">findLastIndex</span><span class="hljs-params">(K key)</span> </span>&#123;
      SBTNode&lt;K&gt; pre = root;
      SBTNode&lt;K&gt; cur = root;
      <span class="hljs-keyword">while</span> (cur != <span class="hljs-keyword">null</span>) &#123;
         pre = cur;
         <span class="hljs-keyword">if</span> (key.compareTo(cur.key) == <span class="hljs-number">0</span>) &#123;
            <span class="hljs-keyword">break</span>;
         &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key.compareTo(cur.key) &lt; <span class="hljs-number">0</span>) &#123;
            cur = cur.l;
         &#125; <span class="hljs-keyword">else</span> &#123;
            cur = cur.r;
         &#125;
      &#125;
      <span class="hljs-keyword">return</span> pre;
   &#125;

   <span class="hljs-function"><span class="hljs-keyword">private</span> SBTNode&lt;K&gt; <span class="hljs-title">add</span><span class="hljs-params">(SBTNode&lt;K&gt; cur, K key)</span> </span>&#123;
      <span class="hljs-keyword">if</span> (cur == <span class="hljs-keyword">null</span>) &#123;
         <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SBTNode&lt;K&gt;(key);
      &#125; <span class="hljs-keyword">else</span> &#123;
         cur.size++;
         <span class="hljs-keyword">if</span> (key.compareTo(cur.key) &lt; <span class="hljs-number">0</span>) &#123;
            cur.l = add(cur.l, key);
         &#125; <span class="hljs-keyword">else</span> &#123;
            cur.r = add(cur.r, key);
         &#125;
         <span class="hljs-keyword">return</span> matain(cur);
      &#125;
   &#125;

   <span class="hljs-function"><span class="hljs-keyword">private</span> SBTNode&lt;K&gt; <span class="hljs-title">delete</span><span class="hljs-params">(SBTNode&lt;K&gt; cur, K key)</span> </span>&#123;
      cur.size--;
      <span class="hljs-keyword">if</span> (key.compareTo(cur.key) &gt; <span class="hljs-number">0</span>) &#123;
         cur.r = delete(cur.r, key);
      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key.compareTo(cur.key) &lt; <span class="hljs-number">0</span>) &#123;
         cur.l = delete(cur.l, key);
      &#125; <span class="hljs-keyword">else</span> &#123;
         <span class="hljs-keyword">if</span> (cur.l == <span class="hljs-keyword">null</span> &amp;&amp; cur.r == <span class="hljs-keyword">null</span>) &#123;
            <span class="hljs-comment">// free cur memory -&gt; C++</span>
            cur = <span class="hljs-keyword">null</span>;
         &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cur.l == <span class="hljs-keyword">null</span> &amp;&amp; cur.r != <span class="hljs-keyword">null</span>) &#123;
            <span class="hljs-comment">// free cur memory -&gt; C++</span>
            cur = cur.r;
         &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cur.l != <span class="hljs-keyword">null</span> &amp;&amp; cur.r == <span class="hljs-keyword">null</span>) &#123;
            <span class="hljs-comment">// free cur memory -&gt; C++</span>
            cur = cur.l;
         &#125; <span class="hljs-keyword">else</span> &#123;
            SBTNode&lt;K&gt; pre = <span class="hljs-keyword">null</span>;
            SBTNode&lt;K&gt; des = cur.r;
            des.size--;
            <span class="hljs-keyword">while</span> (des.l != <span class="hljs-keyword">null</span>) &#123;
               pre = des;
               des = des.l;
               des.size--;
            &#125;
            <span class="hljs-keyword">if</span> (pre != <span class="hljs-keyword">null</span>) &#123;
               pre.l = des.r;
               des.r = cur.r;
            &#125;
            des.l = cur.l;
            des.size = des.l.size + (des.r == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : des.r.size) + <span class="hljs-number">1</span>;
            <span class="hljs-comment">// free cur memory -&gt; C++</span>
            cur = des;
         &#125;
      &#125;
      <span class="hljs-keyword">return</span> cur;
   &#125;

   <span class="hljs-function"><span class="hljs-keyword">private</span> SBTNode&lt;K&gt; <span class="hljs-title">getIndex</span><span class="hljs-params">(SBTNode&lt;K&gt; cur, <span class="hljs-keyword">int</span> kth)</span> </span>&#123;
      <span class="hljs-keyword">if</span> (kth == (cur.l != <span class="hljs-keyword">null</span> ? cur.l.size : <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>) &#123;
         <span class="hljs-keyword">return</span> cur;
      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (kth &lt;= (cur.l != <span class="hljs-keyword">null</span> ? cur.l.size : <span class="hljs-number">0</span>)) &#123;
         <span class="hljs-keyword">return</span> getIndex(cur.l, kth);
      &#125; <span class="hljs-keyword">else</span> &#123;
         <span class="hljs-keyword">return</span> getIndex(cur.r, kth - (cur.l != <span class="hljs-keyword">null</span> ? cur.l.size : <span class="hljs-number">0</span>) - <span class="hljs-number">1</span>);
      &#125;
   &#125;

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;
      <span class="hljs-keyword">return</span> root == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : root.size;
   &#125;

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">containsKey</span><span class="hljs-params">(K key)</span> </span>&#123;
      <span class="hljs-keyword">if</span> (key == <span class="hljs-keyword">null</span>) &#123;
         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;invalid parameter.&quot;</span>);
      &#125;
      SBTNode&lt;K&gt; lastNode = findLastIndex(key);
      <span class="hljs-keyword">return</span> lastNode != <span class="hljs-keyword">null</span> &amp;&amp; key.compareTo(lastNode.key) == <span class="hljs-number">0</span> ? <span class="hljs-keyword">true</span> : <span class="hljs-keyword">false</span>;
   &#125;

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(K key)</span> </span>&#123;
      <span class="hljs-keyword">if</span> (key == <span class="hljs-keyword">null</span>) &#123;
         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;invalid parameter.&quot;</span>);
      &#125;
      SBTNode&lt;K&gt; lastNode = findLastIndex(key);
      <span class="hljs-keyword">if</span> (lastNode == <span class="hljs-keyword">null</span> || key.compareTo(lastNode.key) != <span class="hljs-number">0</span>) &#123;
         root = add(root, key);
      &#125;
   &#125;

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(K key)</span> </span>&#123;
      <span class="hljs-keyword">if</span> (key == <span class="hljs-keyword">null</span>) &#123;
         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;invalid parameter.&quot;</span>);
      &#125;
      <span class="hljs-keyword">if</span> (containsKey(key)) &#123;
         root = delete(root, key);
      &#125;
   &#125;

   <span class="hljs-function"><span class="hljs-keyword">public</span> K <span class="hljs-title">getIndexKey</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;
      <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt;= <span class="hljs-keyword">this</span>.size()) &#123;
         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;invalid parameter.&quot;</span>);
      &#125;
      <span class="hljs-keyword">return</span> getIndex(root, index + <span class="hljs-number">1</span>).key;
   &#125;

&#125;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">Node</span>&gt; </span>&#123;
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> index;
   <span class="hljs-comment">// 先根据value排序，再排序index</span>
   <span class="hljs-comment">// 5第一次出现 再5第二次出现前面</span>
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> value;

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> v)</span> </span>&#123;
      index = i;
      value = v;
   &#125;

   <span class="hljs-meta">@Override</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(Node o)</span> </span>&#123;
      <span class="hljs-keyword">return</span> value != o.value ? Integer.valueOf(value).compareTo(o.value)
            : Integer.valueOf(index).compareTo(o.index);
   &#125;
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">double</span>[] medianSlidingWindow(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k) &#123;
   SizeBalancedTreeMap&lt;Node&gt; map = <span class="hljs-keyword">new</span> SizeBalancedTreeMap&lt;&gt;();
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k - <span class="hljs-number">1</span>; i++) &#123;
      map.add(<span class="hljs-keyword">new</span> Node(i, nums[i]));
   &#125;
   <span class="hljs-keyword">double</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-keyword">double</span>[nums.length - k + <span class="hljs-number">1</span>];
   <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = k - <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;
      map.add(<span class="hljs-keyword">new</span> Node(i, nums[i]));
      <span class="hljs-keyword">if</span> (map.size() % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;
         Node upmid = map.getIndexKey(map.size() / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>);
         Node downmid = map.getIndexKey(map.size() / <span class="hljs-number">2</span>);
         ans[index++] = ((<span class="hljs-keyword">double</span>) upmid.value + (<span class="hljs-keyword">double</span>) downmid.value) / <span class="hljs-number">2</span>;
      &#125; <span class="hljs-keyword">else</span> &#123;
         Node mid = map.getIndexKey(map.size() / <span class="hljs-number">2</span>);
         ans[index++] = (<span class="hljs-keyword">double</span>) mid.value;
      &#125;
      map.remove(<span class="hljs-keyword">new</span> Node(i - k + <span class="hljs-number">1</span>, nums[i - k + <span class="hljs-number">1</span>]));
   &#125;
   <span class="hljs-keyword">return</span> ans;
&#125;</code></pre></div>


            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/04/11/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%983/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">高频面试题2</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/04/11/JVM%E8%A7%A3%E5%AF%86/">
                        <span class="hidden-mobile">JVM解密</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments">
                
                

              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":200})
    NProgress.start()
    document.addEventListener('DOMContentLoaded', function() {
      window.NProgress && window.NProgress.inc();
    })
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.staticfile.org/jquery/3.5.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.staticfile.org/tocbot/4.12.0/tocbot.min.js" ></script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>





  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      var inputArea = document.querySelector("#local-search-input");
      inputArea.onclick = function () {
        searchFunc(path, 'local-search-input', 'local-search-result');
        this.onclick = null
      }
    })()
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>



<!-- hexo injector body_end start -->
  <script src="/js/custom.js"></script>
<!-- hexo injector body_end end --></body>
</html>
