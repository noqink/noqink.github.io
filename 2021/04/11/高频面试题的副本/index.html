

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/imgfavicon.jpg">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  <title>高频面试题 - Blog</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.1.2/styles/ocean.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.5","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"copy_btn":true,"image_zoom":{"enable":true},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.2.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Main</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax=true
         style="background: url('https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/imgdefault.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="高频面试题">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-04-11 11:11" pubdate>
        2021年4月11日 上午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      36.4k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      434
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">高频面试题</h1>
            
            <div class="markdown-body">
              <ul>
<li>JUC（java.util.concurrent）<ul>
<li><strong>进程和线程</strong> <ul>
<li>进程：后台运行的程序（我们打开的一个软件，就是进程）</li>
<li>线程：轻量级的进程，并且一个进程包含多个线程（同在一个软件内，同时运行窗口，就是线程）</li>
</ul>
</li>
<li>并发和并行<ul>
<li>并发：同时访问某个东西，就是并发</li>
<li>并行：一起做某些事情，就是并行</li>
</ul>
</li>
</ul>
</li>
<li>JUC下的三个包<ul>
<li>java.util.concurrent<ul>
<li>java.util.concurrent.atomic</li>
<li>java.util.concurrent.locks</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="谈谈Volatile"><a href="#谈谈Volatile" class="headerlink" title="谈谈Volatile"></a>谈谈Volatile</h1><h2 id="Volatile-理解"><a href="#Volatile-理解" class="headerlink" title="Volatile 理解"></a>Volatile 理解</h2><blockquote>
<p>volatile是JVM提供的轻量级的同步机制</p>
</blockquote>
<ol>
<li>保证可见性</li>
<li>不保证原子性</li>
<li>禁止 <strong>指令重排</strong> （保证有序性）</li>
</ol>
<h2 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h2><p>JMM是Java内存模型，也就是Java Memory Model，简称JMM，本身是一种抽象的概念，实际上 <strong>并不存在</strong> ，它描述的是一组 <strong>规则或规范</strong> ，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式</p>
<p>JMM关于同步的规定：</p>
<ul>
<li>线程 <strong>解锁</strong> 前，必须把共享变量的值 <strong>刷新回主内存</strong> </li>
<li>线程 <strong>加锁</strong> 前，必须读取主内存的最新值，到自己的 <strong>工作内存</strong> </li>
<li>加锁和解锁是 <strong>同一把锁</strong> </li>
</ul>
<p>由于JVM运行程序的实体是线程，而 <strong>每个线程</strong> 创建时 <strong>JVM</strong> 都会为其创建一个 <strong>工作内存</strong> （有些地方称为栈空间），工作内存是每个线程的 <strong>私有数据区域</strong> ，而Java内存模型中规定所有变量都存储在 <strong>主内存</strong> ，主内存是 <strong>共享内存区域</strong> ，所有线程都可以访问，<code>但线程对变量的操作（读取赋值等）必须在工作内存中进行，首先要将变量从主内存拷贝到自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写会主内存</code>，不能直接操作主内存中的变量，各个线程中的工作内存中存储着主内存中的 <strong>变量副本拷贝</strong> ，因此不同的线程间无法访问对方的工作内存，线程间的通信（传值）必须通过主内存来完成，其简要访问过程：</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210406170735.png" srcset="/img/loading.gif"></p>
<p>数据传输速率：硬盘 &lt; 内存 &lt; &lt; cache &lt; CPU</p>
<p>上面提到了两个概念：主内存 和 工作内存</p>
<ul>
<li>主内存：就是计算机的内存，也就是经常提到的8G内存，16G内存</li>
<li>工作内存：但我们实例化 new student，那么 age = 25 也是存储在主内存中<ul>
<li>当同时有三个线程同时访问 student中的age变量时，那么每个线程都会拷贝一份，到各自的工作内存，从而实现了 <strong>变量的拷贝</strong> </li>
</ul>
</li>
</ul>
<h3 id="JMM内存模型的可见性"><a href="#JMM内存模型的可见性" class="headerlink" title="JMM内存模型的可见性"></a>JMM内存模型的可见性</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210406171943.png" srcset="/img/loading.gif"></p>
<p>即： <strong>JMM内存模型的可见性</strong> ，指的是当主内存区域中的值被某个线程写入更改后，其它线程会马上知晓更改后的值，并重新得到更改后的值。</p>
<h3 id="JMM的三大特性"><a href="#JMM的三大特性" class="headerlink" title="JMM的三大特性"></a>JMM的三大特性</h3><p>JMM的三大特性，volatile只保证了两个，即可见性和有序性，不满足原子性，</p>
<ul>
<li>可见性</li>
<li>原子性</li>
<li>有序性</li>
</ul>
<h3 id="JMM可见性code"><a href="#JMM可见性code" class="headerlink" title="JMM可见性code"></a>JMM可见性code</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 假设是主物理内存</span>
<span class="hljs-comment"> */</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyData</span> </span>&#123;

    <span class="hljs-keyword">int</span> number = <span class="hljs-number">0</span>;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addTo60</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">this</span>.number = <span class="hljs-number">60</span>;
    &#125;
&#125;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 验证volatile的可见性</span>
<span class="hljs-comment"> * 1. 假设int number = 0， number变量之前没有添加volatile关键字修饰</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Code1_volatile</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args [])</span> </span>&#123;

        <span class="hljs-comment">// 资源类</span>
        MyData myData = <span class="hljs-keyword">new</span> MyData();

        <span class="hljs-comment">// AAA线程 实现了Runnable接口的，lambda表达式</span>
        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;

            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t come in&quot;</span>);

            <span class="hljs-comment">// 线程睡眠3秒，假设在进行运算</span>
            <span class="hljs-keyword">try</span> &#123;
                TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>);
            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
            <span class="hljs-comment">// 修改number的值</span>
            myData.addTo60();

            <span class="hljs-comment">// 输出修改后的值</span>
            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t update number value:&quot;</span> + myData.number);

        &#125;, <span class="hljs-string">&quot;AAA&quot;</span>).start();

        <span class="hljs-keyword">while</span>(myData.number == <span class="hljs-number">0</span>) &#123;
            <span class="hljs-comment">// main线程就一直在这里等待循环，直到number的值不等于零</span>
        &#125;

        <span class="hljs-comment">// 按道理这个值是不可能打印出来的，因为主线程运行的时候，number的值为0，所以一直在循环</span>
        <span class="hljs-comment">// 如果能输出这句话，说明AAA线程在睡眠3秒后，更新的number的值，重新写入到主内存，并被main线程感知到了</span>
        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t mission is over&quot;</span>);

        <span class="hljs-comment">/**</span>
<span class="hljs-comment">         * 最后输出结果：</span>
<span class="hljs-comment">         * AAA  come in</span>
<span class="hljs-comment">         * AAA  update number value:60</span>
<span class="hljs-comment">         * 最后线程没有停止，并行没有输出  mission is over 这句话，说明没有用volatile修饰的变量，是没有可见性</span>
<span class="hljs-comment">         */</span>

    &#125;
&#125;</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210407185933.png" srcset="/img/loading.gif"></p>
<p>main线程没有得知number变成了60；</p>
<p>如果加上volatile关键字：</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210407190056.png" srcset="/img/loading.gif"></p>
<p>volatile 修饰的关键字，是为了增加 主线程和线程之间的可见性，只要有一个线程修改了内存中的值，其它线程也能马上感知。</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/Oa3tcfAFO9IgsbE22C5TEg">拓展区域</a></p>
<h2 id="Volatile不保证原子性"><a href="#Volatile不保证原子性" class="headerlink" title="Volatile不保证原子性"></a>Volatile不保证原子性</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>通过前面对JMM的介绍，我们知道，各个线程对主内存中共享变量的操作都是各个线程各自拷贝到自己的工作内存进行操作后在写回到主内存中的。</p>
<p>这就可能存在一个 <strong>线程AAA</strong> 修改了共享变量X的值，但是还未写入主内存时，另外一个 <strong>线程BBB</strong> 又对主内存中同一共享变量X进行操作，但此时 <strong>A线程工作内存中共享变量X对线程B来说是不可见</strong> ，这种工作内存与主内存同步延迟现象就造成了 <strong>可见性问题</strong> 。</p>
<h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>不可分割，完整性，也就是说某个线程正在做某个具体业务时，中间 <strong>不可以被加塞或者被分割</strong> ，需要具体完成，要么 <strong>同时成功，要么同时失败</strong> 。</p>
<p>数据库也经常提到事务具备原子性 </p>
<h3 id="原子性代码测试"><a href="#原子性代码测试" class="headerlink" title="原子性代码测试"></a>原子性代码测试</h3><p>首先给MyDate资源类添加方法</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 注意，此时number 前面是加了volatile修饰</span>
<span class="hljs-comment"> */</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addPlusPlus</span><span class="hljs-params">()</span> </span>&#123;
    number ++;
&#125;</code></pre></div>

<p>为了测试volatile是否保证原子性，我们创建了20个线程，然后每个线程分别循环1000次，来调用number++的方法</p>
<p>最后通过 Thread.activeCount()，来感知20个线程是否执行完毕，这里判断线程数是否大于2；</p>
<p> <strong>为什么是2？因为默认是有两个线程的，一个main线程，一个gc线程</strong> </p>
<div class="hljs"><pre><code class="hljs java">MyData myData = <span class="hljs-keyword">new</span> MyData();

<span class="hljs-comment">// 创建10个线程，线程里面进行1000次循环</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;
    <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
        <span class="hljs-comment">// 里面</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">1000</span>; j++) &#123;
            myData.addPlusPlus();
        &#125;
    &#125;, String.valueOf(i)).start();
&#125;
<span class="hljs-comment">// 需要等待上面20个线程都计算完成后，在用main线程取得最终的结果值</span>
<span class="hljs-keyword">while</span>(Thread.activeCount() &gt; <span class="hljs-number">2</span>) &#123;
    <span class="hljs-comment">// yield表示不执行</span>
    Thread.yield();
&#125;
<span class="hljs-comment">// 查看最终的值</span>
<span class="hljs-comment">// 假设volatile保证原子性，那么输出的值应该为：  20 * 1000 = 20000</span>
System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t finally number value: &quot;</span> + myData.number);</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210407192017.png" srcset="/img/loading.gif"></p>
<h3 id="为什么不能保证原子性"><a href="#为什么不能保证原子性" class="headerlink" title="为什么不能保证原子性"></a>为什么不能保证原子性</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210407193224.png" srcset="/img/loading.gif"></p>
<p>各自线程在写入主内存的时候，出现了数据的丢失，而引起的数值缺失的问题</p>
<p>下面我们将一个简单的number++操作，转换为字节码文件一探究竟</p>
<p>.java -&gt; .class -&gt; JVM字节码</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210407193959.png" srcset="/img/loading.gif"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210407194057.png" srcset="/img/loading.gif"></p>
<p>我们能够发现 n++这条命令，被拆分成了 <strong>3个指令</strong> </p>
<ul>
<li>执行<code>getfield</code> 从主内存拿到原始n</li>
<li>执行<code>iadd</code> 进行加1操作</li>
<li>执行<code>putfileld</code> 把累加后的值写回主内存</li>
</ul>
<p>假设我们没有加 <code>synchronized</code>那么第一步就可能存在着， <strong>三个线程同时通过getfield命令</strong> ，拿到主存中的 n值，然后三个线程，各自在自己的工作内存中进行加1操作，但他们并发进行 <code>iadd</code> 命令的时候，因为只能一个进行写，所以其它操作会被 <strong>挂起</strong> ，假设1线程，先进行了写操作，在写完后，volatile的可见性，应该需要告诉其它两个线程，主内存的值已经被修改了，但是 <strong>因为太快了</strong> ， <strong>没有来得及获取最新值</strong> ，其它两个线程，陆续执行 <code>iadd</code>命令，进行写入操作，这就造成了其他线程没有接受到主内存n的改变，从而覆盖了原来的值，出现写丢失，这样也就让最终的结果少于20000</p>
<p> <strong>写覆盖问题</strong> ；</p>
<h3 id="如何解决？"><a href="#如何解决？" class="headerlink" title="如何解决？"></a>如何解决？</h3><p>因此这也说明，在 <strong>多线程环境</strong> 下 number ++ 在多线程环境下是 <strong>非线程安全</strong> 的，解决的方法有哪些呢？</p>
<ul>
<li><p>在方法上加入 synchronized</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addPlusPlus</span><span class="hljs-params">()</span> </span>&#123;
        number ++;
    &#125;</code></pre></div>

<p>引入synchronized关键字后， 保证了该方法 <strong>每次只能够一个线程</strong> 进行访问和操作，最终输出的结果也就为20000</p>
</li>
</ul>
<p>上面的方法引入synchronized，虽然能够保证原子性，但是为了解决number++，而引入 <strong>重量级</strong> 的同步机制，有种  <strong>杀鸡焉用牛刀</strong> </p>
<ul>
<li><p>可以使用JUC下面的 <strong>原子包装类</strong> ，即刚刚的int类型的number，可以使用AtomicInteger来代替，最小单位不可分割</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment">    *  创建一个原子Integer包装类，默认为0</span>
<span class="hljs-comment">     */</span>
   AtomicInteger atomicInteger = <span class="hljs-keyword">new</span> AtomicInteger();
  
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addAtomic</span><span class="hljs-params">()</span> </span>&#123;
       <span class="hljs-comment">// 相当于 atomicInter ++</span>
       atomicInteger.getAndIncrement();
   &#125;</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210407195719.png" srcset="/img/loading.gif"></p>
</li>
</ul>
<h3 id="字节码表"><a href="#字节码表" class="headerlink" title="字节码表"></a>字节码表</h3><p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000008722128">表</a></p>
<h2 id="Volatile禁止指令重排"><a href="#Volatile禁止指令重排" class="headerlink" title="Volatile禁止指令重排"></a>Volatile禁止指令重排</h2><p>计算机在执行程序时，为了提高性能， <strong>编译器和处理器</strong> 常常会对 <strong>指令重排</strong> ，一般分为以下三种：</p>
<div class="hljs"><pre><code class="hljs clean">源代码 -&gt; 编译器优化的重排 -&gt; 指令并行的重排 -&gt; 内存系统的重排 -&gt; 最终执行指令</code></pre></div>

<ul>
<li> <strong>单线程环境</strong> 里面确保最终执行结果和代码顺序的结果一致</li>
<li>处理器在进行重排序时，必须要考虑指令之间的<code>数据依赖性</code></li>
<li> <strong>多线程环境</strong> 中线程交替执行，由于编译器优化重排的存在，两个线程中使用的变量能否保证一致性是无法确定的， <strong>结果无法预测</strong> 。</li>
</ul>
<h3 id="指令重排-example-1"><a href="#指令重排-example-1" class="headerlink" title="指令重排 - example 1"></a>指令重排 - example 1</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mySort</span><span class="hljs-params">()</span> </span>&#123;
  <span class="hljs-keyword">int</span> x = <span class="hljs-number">11</span>;
  <span class="hljs-keyword">int</span> y = <span class="hljs-number">12</span>;
  x = x + <span class="hljs-number">5</span>;
  y = x * x;
&#125;</code></pre></div>

<ul>
<li><p>按照正常 <strong>单线程环境</strong> ，执行顺序是 1 2 3 4 </p>
</li>
<li><p>但是在 <strong>多线程环境</strong> 下，可能出现以下的顺序： </p>
<ul>
<li>2 1 3 4</li>
<li>1 3 2 4</li>
</ul>
</li>
</ul>
<p>上述的过程就可以当做是 <strong>指令的重排</strong> ，即内部执行顺序，和我们的代码顺序不一样</p>
<p>但是指令重排也是有 <strong>限制</strong> 的，即不会出现下面的顺序</p>
<ul>
<li>4 3 2 1</li>
</ul>
<p>因为处理器在进行重排时候，必须考虑到指令之间的<code>数据依赖性</code></p>
<p>因为步骤 4：需要依赖于 y的申明，以及x的申明，故因为存在数据依赖，无法首先执行</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p> <strong>int a,b,x,y = 0</strong> </p>
<table>
<thead>
<tr>
<th>线程1</th>
<th>线程2</th>
</tr>
</thead>
<tbody><tr>
<td>x = a;</td>
<td>y = b;</td>
</tr>
<tr>
<td>b = 1;</td>
<td>a = 2;</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>x = 0; y = 0</td>
<td></td>
</tr>
</tbody></table>
<p>因为上面的代码，不存在数据的依赖性，因此编译器可能对数据进行重排</p>
<table>
<thead>
<tr>
<th>线程1</th>
<th>线程2</th>
</tr>
</thead>
<tbody><tr>
<td>b = 1;</td>
<td>a = 2;</td>
</tr>
<tr>
<td>x = a;</td>
<td>y = b;</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>x = 2; y = 1</td>
<td></td>
</tr>
</tbody></table>
<p>这样造成的结果，和最开始的就不一致了，这就是导致重排后，结果和最开始的不一样，因此为了防止这种结果出现， <strong>volatile就规定禁止指令重排</strong> ，为了 <strong>保证数据的一致性</strong> </p>
<h3 id="指令重排-example-2"><a href="#指令重排-example-2" class="headerlink" title="指令重排 - example 2"></a>指令重排 - example 2</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ResortSeqDemo</span> </span>&#123;
    <span class="hljs-keyword">int</span> a= <span class="hljs-number">0</span>;
    <span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">false</span>;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method01</span><span class="hljs-params">()</span> </span>&#123;
        a = <span class="hljs-number">1</span>;
        flag = <span class="hljs-keyword">true</span>;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method02</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">if</span>(flag) &#123;
            a = a + <span class="hljs-number">5</span>;
            System.out.println(<span class="hljs-string">&quot;reValue:&quot;</span> + a);
        &#125;
    &#125;
&#125;</code></pre></div>

<p>我们按照正常的顺序，分别调用method01() 和 method02() 那么，最终输出就是 a = 6</p>
<p>但是如果在多线程环境下，因为方法1 和 方法2，他们之间不能存在数据依赖的问题，因此原先的顺序可能是</p>
<div class="hljs"><pre><code class="hljs java">a = <span class="hljs-number">1</span>;
flag = <span class="hljs-keyword">true</span>;

a = a + <span class="hljs-number">5</span>;
System.out.println(<span class="hljs-string">&quot;reValue:&quot;</span> + a);</code></pre></div>

<p>但是在经过编译器，指令，或者内存的重排后，可能会出现这样的情况</p>
<div class="hljs"><pre><code class="hljs java">flag = <span class="hljs-keyword">true</span>;

a = a + <span class="hljs-number">5</span>;
System.out.println(<span class="hljs-string">&quot;reValue:&quot;</span> + a);

a = <span class="hljs-number">1</span>;</code></pre></div>

<p>也就是先执行 flag = true后，另外一个线程马上调用方法2，满足 flag的判断，最终让a + 5，结果为5，这样同样出现了数据不一致的问题</p>
<p>为什么会出现这个结果：多线程环境中线程交替执行，由于编译器优化重排的存在，两个线程中使用的变量能否保证一致性是无法确定的，结果无法预测。</p>
<p>这样就需要通过 <strong>volatile来修饰</strong> ，来保证线程安全性</p>
<h3 id="Volatile针对指令重排做了啥"><a href="#Volatile针对指令重排做了啥" class="headerlink" title="Volatile针对指令重排做了啥"></a>Volatile针对指令重排做了啥</h3><p>Volatile实现 <strong>禁止指令重排优化</strong> ，从而避免了多线程环境下程序出现乱序执行的现象</p>
<p>首先了解一个概念， <strong>内存屏障</strong> （Memory Barrier）又称 <strong>内存栅栏</strong> ，是一个 <strong>CPU指令</strong> ，它的作用有两个：</p>
<ul>
<li><p>保证特定操作的顺序</p>
</li>
<li><p>保证某些变量的内存可见性（利用该特性 <strong>实现volatile的内存可见性</strong> ）</p>
<p>由于编译器和处理器都能执行指令重排的优化，如果在指令间插入一条Memory Barrier则会告诉编译器和CPU，不管什么指令都不能和这条Memory Barrier指令重排序，也就是说 <code>通过插入内存屏障禁止在内存屏障前后的指令执行重排序优化</code>。 内存屏障另外一个作用是 <strong>刷新出各种CPU的缓存数据</strong> ，因此任何CPU上的线程都能读取到这些数据的最新版本。</p>
</li>
</ul>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210407202835.png" srcset="/img/loading.gif"></p>
<p>也就是在Volatile的写 和 读的时候，加入屏障，防止出现指令重排的</p>
<h3 id="线程安全获得保证"><a href="#线程安全获得保证" class="headerlink" title="线程安全获得保证"></a>线程安全获得保证</h3><p>工作内存与主内存同步延迟现象导致的 <strong>可见性问题</strong> </p>
<ul>
<li>可通过synchronized或volatile关键字解决，他们都可以使一个线程修改后的变量立即对其它线程可见</li>
</ul>
<p>对于 <strong>指令重排导致的可见性问题和有序性问题</strong> </p>
<ul>
<li>可以使用volatile关键字解决，因为volatile关键字的另一个作用就是禁止重排序优化</li>
</ul>
<h2 id="Volatile的应用"><a href="#Volatile的应用" class="headerlink" title="Volatile的应用"></a>Volatile的应用</h2><h3 id="单例模式DCL代码"><a href="#单例模式DCL代码" class="headerlink" title="单例模式DCL代码"></a>单例模式DCL代码</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// 单例模式DCL代码</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Code2_SingletonDemo</span> </span>&#123;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Code2_SingletonDemo instance = <span class="hljs-keyword">null</span>;

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Code2_SingletonDemo</span><span class="hljs-params">()</span></span>&#123;
        System.out.println(<span class="hljs-string">&quot;构造方法&quot;</span>);
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Code2_SingletonDemo <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;
        <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>)&#123;
            instance = <span class="hljs-keyword">new</span> Code2_SingletonDemo();
        &#125;
        <span class="hljs-keyword">return</span> instance;
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        <span class="hljs-comment">// 单线程(main 线程操作)</span>
        System.out.println(Code2_SingletonDemo.getInstance() == Code2_SingletonDemo.getInstance());
        System.out.println(Code2_SingletonDemo.getInstance() == Code2_SingletonDemo.getInstance());
        System.out.println(Code2_SingletonDemo.getInstance() == Code2_SingletonDemo.getInstance());
    &#125;
&#125;</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210408185446.png" srcset="/img/loading.gif"></p>
<p>改变后</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
    <span class="hljs-comment">// 并发后 情况有所改变</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;
        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
            Code2_SingletonDemo.getInstance();
        &#125;, String.valueOf(i)).start();
    &#125;
&#125;</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210408185546.png" srcset="/img/loading.gif"></p>
<p>从上面的结果我们可以看出，我们通过SingletonDemo.getInstance() 获取到的对象，并不是同一个，而是被下面几个线程都进行了创建，那么在多线程环境下， <strong>单例模式如何保证呢</strong> ？</p>
<h4 id="解决方法1"><a href="#解决方法1" class="headerlink" title="解决方法1"></a>解决方法1</h4><ul>
<li><p>引入synchronized关键字</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> SingletonDemo <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">if</span>(instance == <span class="hljs-keyword">null</span>) &#123;
            instance = <span class="hljs-keyword">new</span> SingletonDemo();
        &#125;
        <span class="hljs-keyword">return</span> instance;
    &#125;</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210408185857.png" srcset="/img/loading.gif"></p>
</li>
</ul>
<p>我们能够发现，通过引入Synchronized关键字，能够 <strong>解决高并发环境下的单例模式问题</strong> </p>
<p>但是synchronized属于 <strong>重量级</strong> 的同步机制，它只允许一个线程同时访问获取实例的方法，但是为了保证数据一致性，而 <strong>减低了并发性</strong> ，因此采用的比较少</p>
<h4 id="解决方法2"><a href="#解决方法2" class="headerlink" title="解决方法2"></a>解决方法2</h4><ul>
<li><p>通过引入 <strong>DCL</strong>  Double Check Lock 双端检锁机制</p>
<p>就是在进来和出去的时候，进行检测</p>
</li>
</ul>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingletonDemo <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">if</span>(instance == <span class="hljs-keyword">null</span>) &#123;
        <span class="hljs-comment">// 同步代码段的时候，进行检测</span>
        <span class="hljs-keyword">synchronized</span> (SingletonDemo.class) &#123;
            <span class="hljs-keyword">if</span>(instance == <span class="hljs-keyword">null</span>) &#123;
                instance = <span class="hljs-keyword">new</span> SingletonDemo();
            &#125;
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> instance;
&#125;</code></pre></div>

<p>​   </p>
<p>从输出结果来看，确实能够保证单例模式的正确性，但是上面的方法还是 <strong>存在问题的</strong> </p>
<p>DCL（双端检锁）机制不一定是线程安全的，原因是有 <strong>指令重排</strong> 的存在，加入volatile可以禁止指令重排</p>
<p>原因是在某一个线程执行到第一次检测的时候，读取到 instance 不为null，instance的引用对象 <strong>可能没有完成实例化</strong> 。</p>
<p>因为 instance = new SingletonDemo()；可以分为以下 <strong>三步</strong> 进行完成：</p>
<ul>
<li>memory = allocate(); // 1、分配对象内存空间</li>
<li>instance(memory); // 2、初始化对象</li>
<li>instance = memory; // 3、设置instance指向刚刚分配的内存地址，此时instance != null</li>
</ul>
<p>步骤2、步骤3 <strong>不存在数据依赖关系</strong> ，重排前和重排后对单线程模式下的程序运行没有结果改变，所以这种重排优化是被允许的。</p>
<ul>
<li>memory = allocate(); // 1、分配对象内存空间</li>
<li>instance = memory; // 3、设置instance指向刚刚分配的内存地址，此时instance != null， <strong>但是对象还没有初始化完成</strong> </li>
<li>instance(memory); // 2、初始化对象</li>
</ul>
<p>这样就会造成什么问题呢？</p>
<p>也就是当我们执行到重排后的步骤2，试图获取instance的时候，会得到null，因为对象的初始化还没有完成，而是在重排后的步骤3才完成，因此执行单例模式的代码时候，就会 <strong>重新</strong> 创建一个instance实例</p>
<p><code>指令重排只会保证串行语义的执行一致性（单线程），但并不会关系多线程间的语义一致性</code></p>
<p>所以当一条线程访问instance不为null时， <strong>由于instance实例未必已初始化完成</strong> ，这就造成了 <strong>线程安全</strong> 的问题</p>
<p>所以需要引入volatile，来保证出现指令重排的问题，从而保证单例模式的线程安全性</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> SingletonDemo instance = <span class="hljs-keyword">null</span>;</code></pre></div>



<h4 id="最终代码"><a href="#最终代码" class="headerlink" title="最终代码"></a>最终代码</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonDemo</span> </span>&#123;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> SingletonDemo instance = <span class="hljs-keyword">null</span>;

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">SingletonDemo</span> <span class="hljs-params">()</span> </span>&#123;
        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 我是构造方法SingletonDemo&quot;</span>);
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingletonDemo <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">if</span>(instance == <span class="hljs-keyword">null</span>) &#123;
            <span class="hljs-comment">// a 双重检查加锁多线程情况下会出现某个线程虽然这里已经为空，但是另外一个线程已经执行到d处</span>
            <span class="hljs-keyword">synchronized</span> (SingletonDemo.class) <span class="hljs-comment">//b</span>
            &#123; 
           <span class="hljs-comment">//c不加volitale关键字的话有可能会出现尚未完全初始化就获取到的情况。原因是内存模型允许无序写入</span>
                <span class="hljs-keyword">if</span>(instance == <span class="hljs-keyword">null</span>) &#123; 
                  <span class="hljs-comment">// d 此时才开始初始化</span>
                    instance = <span class="hljs-keyword">new</span> SingletonDemo();
                &#125;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> instance;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;
            <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
                SingletonDemo.getInstance();
            &#125;, String.valueOf(i)).start();
        &#125;
    &#125;
&#125;</code></pre></div>



<h1 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p> 比较并交换；</p>
<p>CAS的全称是 <strong>Compare-And-Swap</strong> ，它是 <strong>CPU并发原语</strong> </p>
<p>它的功能是 <strong>判断内存某个位置的值是否为预期值</strong> ，如果是则更改为新的值，这个过程是 <strong>原子的</strong> </p>
<p>CAS并发原语体现在Java语言中就是 <strong>sun.misc.Unsafe类</strong> 的各个方法。调用UnSafe类中的 <strong>CAS方法</strong> ， <strong>JVM</strong> 会帮我们实现出 <strong>CAS汇编指令</strong> ，这是一种完全依赖于 <strong>硬件</strong> 的功能，通过它实现了原子操作，再次强调，由于CAS是一种系统原语，原语属于操作系统用于范畴，是由若干条指令组成，用于完成某个功能的一个过程，并且原语的执行必须是连续的，在执行过程中不允许被中断，也就是说 <strong>CAS是一条CPU的原子指令</strong> ，不会造成所谓的数据不一致的问题，也就是说 <strong>CAS是线程安全的</strong> 。</p>
<h2 id="代码使用"><a href="#代码使用" class="headerlink" title="代码使用"></a>代码使用</h2><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
    <span class="hljs-comment">// 创建一个原子类</span>
    AtomicInteger atomicInteger = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">5</span>);

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 一个是期望值，一个是更新值，但期望值和原来的值相同时，才能够更改</span>
<span class="hljs-comment">     * 假设三秒前，我拿的是5，也就是expect为5，然后我需要更新成 2019</span>
<span class="hljs-comment">     */</span>
    System.out.println(atomicInteger.compareAndSet(<span class="hljs-number">5</span>, <span class="hljs-number">2019</span>) + <span class="hljs-string">&quot;\t current data: &quot;</span> + atomicInteger.get());

    System.out.println(atomicInteger.compareAndSet(<span class="hljs-number">5</span>, <span class="hljs-number">1024</span>) + <span class="hljs-string">&quot;\t current data: &quot;</span> + atomicInteger.get());
&#125;</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210408195319.png" srcset="/img/loading.gif"></p>
<p>这是因为我们执行第一个的时候，期望值和原本值是满足的，因此修改成功，</p>
<p>但是第二次后，主内存的值已经修改成了2019， <strong>不满足期望值</strong> ，因此返回了false，本次写入失败。</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210408195413.png" srcset="/img/loading.gif"></p>
<p>这个就类似于 <strong>SVN或者Git的版本号</strong> ，如果没有人更改过，就能够正常提交，否者需要先将代码pull下来，合并代码后，然后提交</p>
<h2 id="CAS底层原理"><a href="#CAS底层原理" class="headerlink" title="CAS底层原理"></a>CAS底层原理</h2><h3 id="atomicInteger源码"><a href="#atomicInteger源码" class="headerlink" title="atomicInteger源码"></a>atomicInteger源码</h3><p>首先我们先看看 atomicInteger.getAndIncrement()方法的源码</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210408201048.png" srcset="/img/loading.gif"></p>
<p>从这里能够看到，底层又调用了一个unsafe类的getAndAddInt方法</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210408201332.png" srcset="/img/loading.gif"></p>
<h3 id="unsafe类源码"><a href="#unsafe类源码" class="headerlink" title="unsafe类源码"></a>unsafe类源码</h3><p>继续深挖</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210408201458.png" srcset="/img/loading.gif"></p>
<p>进入sun.misc.Unsafe；</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210408201631.png" srcset="/img/loading.gif" alt="JDK"></p>
<p>JDK自带的native方法</p>
<p>先回到aotomicInteger</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210408201930.png" srcset="/img/loading.gif"></p>
<p>objectFieldOffset得到对象偏移量</p>
<p>Unsafe是CAS的 <strong>核心类</strong> ，CAS靠的是Unsafe的原子性，由于Java方法无法直接访问底层系统，需要通过本地（Native）方法来访问，Unsafe相当于一个 <strong>后门</strong> ，基于该类可以直接操作特定的内存数据。Unsafe类存在sun.misc包中，其内部方法操作可以像C的指针一样直接操作内存，因为Java中的 <strong>CAS操作的执行依赖于Unsafe类的方法</strong> 。</p>
<div class="hljs"><pre><code class="hljs oxygene">注意<span class="hljs-keyword">Unsafe</span>类的所有方法都是native修饰的，也就是说<span class="hljs-keyword">unsafe</span>类中的方法都直接调用操作系统底层资源执行相应的任务</code></pre></div>

<p>为什么Atomic修饰的包装类，能够保证原子性，依靠的就是底层的unsafe类</p>
<h3 id="变量valueOffset"><a href="#变量valueOffset" class="headerlink" title="变量valueOffset"></a>变量valueOffset</h3><p>表示该变量值在 <strong>内存中的偏移地址</strong> ，因为Unsafe就是根据内存偏移地址获取数据的。</p>
<p>从这里我们能够看到，通过valueOffset，直接通过内存地址，获取到值，然后进行加1的操作</p>
<h3 id="变量value"><a href="#变量value" class="headerlink" title="变量value"></a>变量value</h3><p>用 <strong>volatile</strong> 修饰</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210408202836.png" srcset="/img/loading.gif"></p>
<p>var5：就是我们从主内存中拷贝到 <strong>工作内存中的值</strong>  (每次都要从主内存拿到 <strong>最新的值</strong> 到自己的本地内存，然后执行compareAndSwapInt()再和主内存的值进行比较。因为线程不可以直接越过高速缓存，直接操作主内存，所以执行上述方法需要比较一次，在执行加1操作)</p>
<p>那么操作的时候，需要比较 <strong>工作内存中的值</strong> ，和 <strong>主内存中的值</strong> 进行比较</p>
<p>假设执行 compareAndSwapInt返回false，那么就一直执行 while方法，直到期望的值和真实值一样</p>
<ul>
<li>val1：AtomicInteger对象本身</li>
<li>var2：该对象值的 <strong>引用地址</strong> （内存偏移量）</li>
<li>var4：需要变动的数量</li>
<li>var5：用var1和var2找到的内存中的真实值<ul>
<li>用该对象当前的值与var5比较</li>
<li>如果相同，更新var5 + var4 并返回true</li>
<li>如果不同，继续取值（取得 <strong>最新的值</strong> ）然后再比较，直到更新完成</li>
</ul>
</li>
</ul>
<p>这里没有用synchronized，而用CAS，这样 <strong>提高了并发性</strong> ，也能够 <strong>实现一致性</strong> ，是因为每个线程进来后，进入的do while循环，然后不断的获取内存中的值，判断是否为最新，然后在进行更新操作。</p>
<p>假设 <strong>线程A和线程B</strong> 同时执行getAndInt操作（分别跑在不同的CPU上）</p>
<ol>
<li><p>AtomicInteger里面的value原始值为3，即主内存中AtomicInteger的 value 为3，根据JMM模型，线程A和线程B各自持有一份价值为3的副本，分别存储在各自的工作内存</p>
</li>
<li><p>线程A通过getIntVolatile(var1 , var2) 拿到value值3，这是 <strong>线程A被挂起</strong> （该线程失去CPU执行权）</p>
</li>
<li><p>线程B也通过getIntVolatile(var1, var2)方法获取到value值也是3，此时刚好线程B <strong>没有被挂起</strong> ，并执行了compareAndSwapInt方法，比较内存的值也是3，成功修改内存值为4，线程B打完收工，一切OK</p>
</li>
<li><p>这是线程A恢复，执行CAS方法，比较发现自己手里的数字3和主内存中的数字4 <strong>不一致</strong> ，说明该值已经被其它线程抢先一步修改过了，那么A线程本次修改失败，只能够 <strong>重新读取</strong> 后在来一遍了，也就是在执行do while</p>
</li>
<li><p>线程A重新获取value值， <strong>因为变量value被volatile修饰</strong> ，（unsafe.getAndAddInt(this, valueOffset, 1)传入的this是当前atomicInteger对象，修改的是里面的value字段 ）所以其它线程对它的修改，线程A总能够看到，线程A继续执行compareAndSwapInt进行比较替换，直到成功。</p>
</li>
</ol>
<p>Unsafe类 + CAS思想： 也就是 <strong>自旋</strong> ，自我旋转</p>
<h2 id="底层汇编"><a href="#底层汇编" class="headerlink" title="底层汇编"></a>底层汇编</h2><p>Unsafe类中的compareAndSwapInt是一个 <strong>本地方法</strong> ，该方法的实现位于 <strong>unsafe.cpp</strong> 中</p>
<ul>
<li>先想办法拿到变量value在内存中的地址</li>
<li>通过Atomic::cmpxchg(x, addr, e) 实现比较替换，其中参数X是即将更新的值，参数e是原内存的值</li>
</ul>
<h2 id="CAS缺点"><a href="#CAS缺点" class="headerlink" title="CAS缺点"></a>CAS缺点</h2><p>CAS <strong>不加锁</strong> ，保证一次性，但是 <strong>需要多次比较</strong> </p>
<ul>
<li>循环时间长，开销大（因为执行的是do while，如果比较不成功一直在循环，最差的情况，就是某个线程一直取到的值和预期值都不一样，这样就会 <strong>无限循环</strong> ）</li>
<li>只能 <strong>保证一个共享变量的原子操作</strong> <ul>
<li>当对一个共享变量执行操作时，我们可以通过循环CAS的方式来保证原子操作</li>
<li>但是对于多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候 <strong>只能用锁</strong> 来保证原子性</li>
</ul>
</li>
<li>引出来ABA问题？</li>
</ul>
<h1 id="原子类AtomicInteger的ABA问题"><a href="#原子类AtomicInteger的ABA问题" class="headerlink" title="原子类AtomicInteger的ABA问题"></a>原子类AtomicInteger的ABA问题</h1><h2 id="前提引入"><a href="#前提引入" class="headerlink" title="前提引入"></a>前提引入</h2><p>从AtomicInteger引出下面的问题</p>
<p>CAS -&gt; Unsafe -&gt; CAS底层思想 -&gt; ABA -&gt; 原子引用更新 -&gt; 如何规避ABA问题</p>
<h2 id="ABA问题是什么"><a href="#ABA问题是什么" class="headerlink" title="ABA问题是什么"></a>ABA问题是什么</h2><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210408232736.png" srcset="/img/loading.gif"></p>
<p>假设现在有两个线程，分别是T1 和 T2，然后T1执行某个操作的时间为 <strong>10秒</strong> ，T2执行某个时间的操作是 <strong>2秒</strong> ，最开始AB两个线程，分别从主内存中获取A值，但是因为B的执行速度更快，他先把A的值改成B，然后在修改成A，然后执行完毕，T1线程在10秒后，执行完毕，判断内存中的值为A，并且和自己预期的值一样，它就认为没有人更改了主内存中的值，就快乐的修改成B，但是实际上 可能中间经历了 ABCDEFA 这个变换，也就是中间的值经历了 <strong>狸猫换太子</strong> 。</p>
<p>所以ABA问题就是，在进行获取主内存值的时候，该内存值在我们写入主内存的时候， <strong>已经被修改了N次</strong> ，但是最终又改成原来的值了</p>
<h2 id="CAS导致ABA问题"><a href="#CAS导致ABA问题" class="headerlink" title="CAS导致ABA问题"></a>CAS导致ABA问题</h2><p>CAS算法实现了一个重要的前提，需要取出内存中某时刻的数据，并在当下时刻比较并替换，那么这个时间差会导致数据的变化。</p>
<p>比如说一个线程one从内存位置V中取出A，这时候另外一个线程two也从内存中取出A，并且线程two进行了一些操作将值变成了B，然后线程two又将V位置的数据变成A，这时候线程one进行CAS操作发现内存中仍然是A，然后线程one操作成功</p>
<p><code>尽管线程one的CAS操作成功，但是不代表这个过程就是没有问题的</code></p>
<p>CAS只管开头和结尾，也就是头和尾是一样，那就修改成功， <strong>中间的这个过程，可能会被人修改过</strong> </p>
<h2 id="AtomicReference原子引用"><a href="#AtomicReference原子引用" class="headerlink" title="AtomicReference原子引用"></a>AtomicReference原子引用</h2><p> <strong>原子引用</strong> 其实和 <strong>原子包装类</strong> 是差不多的概念，就是将一个java类， <strong>用原子引用类进行包装起来</strong> ，那么这个类就具备了 <strong>原子性</strong> </p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;
    String userName;
    <span class="hljs-keyword">int</span> age;
    ....
&#125;</code></pre></div>

<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;

    User z3 = <span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;zhangsan&quot;</span>, <span class="hljs-number">22</span>);

    User l4 = <span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;lisi&quot;</span>, <span class="hljs-number">25</span>);

    <span class="hljs-comment">// 创建原子引用包装类</span>
    AtomicReference&lt;User&gt; atomicReference = <span class="hljs-keyword">new</span> AtomicReference&lt;&gt;();

    <span class="hljs-comment">// 现在主物理内存的共享变量，为z3</span>
    atomicReference.set(z3);

    <span class="hljs-comment">// 比较并交换，如果现在主物理内存的值为z3，那么交换成l4</span>
    System.out.println(atomicReference.compareAndSet(z3, l4) + <span class="hljs-string">&quot;\t &quot;</span> + atomicReference.get().toString());

    <span class="hljs-comment">// 比较并交换，现在主物理内存的值是l4了，但是预期为z3，因此交换失败</span>
    System.out.println(atomicReference.compareAndSet(z3, l4) + <span class="hljs-string">&quot;\t &quot;</span> + atomicReference.get().toString());
&#125;</code></pre></div>



<h2 id="基于原子引用的ABA问题"><a href="#基于原子引用的ABA问题" class="headerlink" title="基于原子引用的ABA问题"></a>基于原子引用的ABA问题</h2><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// 测试ABA问题</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Code5_ABADemo</span> </span>&#123;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 普通的原子引用包装类</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-keyword">static</span> AtomicReference&lt;Integer&gt; atomicReference = <span class="hljs-keyword">new</span> AtomicReference&lt;&gt;(<span class="hljs-number">100</span>);

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;

        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
            <span class="hljs-comment">// 把100 改成 101 然后在改成100，也就是ABA</span>
            atomicReference.compareAndSet(<span class="hljs-number">100</span>, <span class="hljs-number">101</span>);
            atomicReference.compareAndSet(<span class="hljs-number">101</span>, <span class="hljs-number">100</span>);
        &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();

        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
            <span class="hljs-keyword">try</span> &#123;
                <span class="hljs-comment">// 睡眠一秒，保证t1线程，完成了ABA操作</span>
                TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);
            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
            <span class="hljs-comment">// 把100 改成 101 然后在改成100，也就是ABA</span>
            System.out.println(atomicReference.compareAndSet(<span class="hljs-number">100</span>, <span class="hljs-number">2019</span>) + <span class="hljs-string">&quot;\t&quot;</span> + atomicReference.get());

        &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();
    &#125;
&#125;</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210408235035.png" srcset="/img/loading.gif"></p>
<p>创建两个线程，然后T1线程，执行一次ABA的操作，T2线程在一秒后修改主内存的值</p>
<h2 id="解决ABA问题"><a href="#解决ABA问题" class="headerlink" title="解决ABA问题"></a>解决ABA问题</h2><p>新增一种机制，也就是 <strong>修改版本号</strong> ，类似于 <strong>时间戳</strong> 的概念</p>
<p>T1： 100 1         （拿到100改成2019） 2</p>
<p>T2： 100 1   101 2   100 3</p>
<p>如果T1修改的时候，版本号为2， <strong>落后于</strong> 现在的版本号3，所以要重新获取最新值，这里就提出了一个使用时间戳版本号，来解决ABA问题的思路</p>
<h2 id="AtomicStampedReference"><a href="#AtomicStampedReference" class="headerlink" title="AtomicStampedReference"></a>AtomicStampedReference</h2><p> <strong>时间戳原子引用</strong> ，来这里应用于版本号的更新，也就是每次更新的时候，需要比较期望值和当前值，以及 <strong>期望版本号和当前版本号</strong> </p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210409000130.png" srcset="/img/loading.gif"></p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// ABA问题的解决</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Code6_ABASolution</span> </span>&#123;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 普通的原子引用包装类</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-keyword">static</span> AtomicReference&lt;Integer&gt; atomicReference = <span class="hljs-keyword">new</span> AtomicReference&lt;&gt;(<span class="hljs-number">100</span>);

    <span class="hljs-comment">// 传递两个值，一个是初始值，一个是初始版本号</span>
    <span class="hljs-keyword">static</span> AtomicStampedReference&lt;Integer&gt; atomicStampedReference = <span class="hljs-keyword">new</span> AtomicStampedReference&lt;&gt;(<span class="hljs-number">100</span>, <span class="hljs-number">1</span>);

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;

        System.out.println(<span class="hljs-string">&quot;============以下是ABA问题的产生==========&quot;</span>);

        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
            <span class="hljs-comment">// 把100 改成 101 然后在改成100，也就是ABA</span>
            atomicReference.compareAndSet(<span class="hljs-number">100</span>, <span class="hljs-number">101</span>);
            atomicReference.compareAndSet(<span class="hljs-number">101</span>, <span class="hljs-number">100</span>);
        &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();

        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
            <span class="hljs-keyword">try</span> &#123;
                <span class="hljs-comment">// 睡眠一秒，保证t1线程，完成了ABA操作</span>
                TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);
            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
            <span class="hljs-comment">// 把100 改成 101 然后在改成100，也就是ABA</span>
            System.out.println(atomicReference.compareAndSet(<span class="hljs-number">100</span>, <span class="hljs-number">2019</span>) + <span class="hljs-string">&quot;\t&quot;</span> + atomicReference.get());

        &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();

        System.out.println(<span class="hljs-string">&quot;============以下是ABA问题的解决==========&quot;</span>);

        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;

            <span class="hljs-comment">// 获取版本号</span>
            <span class="hljs-keyword">int</span> stamp = atomicStampedReference.getStamp();
            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 第一次版本号&quot;</span> + stamp);

            <span class="hljs-comment">// 暂停t3一秒钟</span>
            <span class="hljs-keyword">try</span> &#123;
                TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);
            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;

            <span class="hljs-comment">// 传入4个值，期望值，更新值，期望版本号，更新版本号</span>
            atomicStampedReference.compareAndSet(<span class="hljs-number">100</span>, <span class="hljs-number">101</span>, atomicStampedReference.getStamp(), atomicStampedReference.getStamp()+<span class="hljs-number">1</span>);

            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 第二次版本号&quot;</span> + atomicStampedReference.getStamp());

            atomicStampedReference.compareAndSet(<span class="hljs-number">101</span>, <span class="hljs-number">100</span>, atomicStampedReference.getStamp(), atomicStampedReference.getStamp()+<span class="hljs-number">1</span>);

            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 第三次版本号&quot;</span> + atomicStampedReference.getStamp());

        &#125;, <span class="hljs-string">&quot;t3&quot;</span>).start();

        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;

            <span class="hljs-comment">// 获取版本号</span>
            <span class="hljs-keyword">int</span> stamp = atomicStampedReference.getStamp();
            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 第一次版本号&quot;</span> + stamp);

            <span class="hljs-comment">// 暂停t4 3秒钟，保证t3线程也进行一次ABA问题</span>
            <span class="hljs-keyword">try</span> &#123;
                TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>);
            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;

            <span class="hljs-keyword">boolean</span> result = atomicStampedReference.compareAndSet(<span class="hljs-number">100</span>, <span class="hljs-number">2019</span>, stamp, stamp+<span class="hljs-number">1</span>);

            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 修改成功否：&quot;</span> + result + <span class="hljs-string">&quot;\t 当前最新实际版本号：&quot;</span> + atomicStampedReference.getStamp());

            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 当前实际最新值&quot;</span> + atomicStampedReference.getReference());


        &#125;, <span class="hljs-string">&quot;t4&quot;</span>).start();

    &#125;
&#125;</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210409000627.png" srcset="/img/loading.gif"></p>
<p>我们能够发现，线程t3，在进行ABA操作后，版本号变更成了3，而线程t4在进行操作的时候，就出现操作失败了，因为版本号和当初拿到的不一样， <strong>无法修改</strong> 。</p>
<h2 id="CAS拓展优化"><a href="#CAS拓展优化" class="headerlink" title="CAS拓展优化"></a>CAS拓展优化</h2><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/eluanshi12/article/details/84871879">AtomicLong与LongAdder（CAS机制的优化）</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/KFsqsCVgyiiTDXMR-Hu1-Q">大白话聊聊Java并发面试问题之Java 8如何优化CAS性能？</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/wolf_love666/article/details/87693771">https://blog.csdn.net/wolf_love666/article/details/87693771</a></p>
<h1 id="集合类不安全问题"><a href="#集合类不安全问题" class="headerlink" title="集合类不安全问题"></a>集合类不安全问题</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>当我们执行下面语句的时候，底层进行了什么操作</li>
</ul>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();</code></pre></div>

<p>底层创建了一个空的数组，伴随着初始值为10</p>
<ul>
<li>当执行add方法后，如果超过了10，那么会进行扩容，扩容的大小为原值的一半，也就是5个，使用下列方法扩容</li>
</ul>
<div class="hljs"><pre><code class="hljs java">Arrays.copyOf(elementData, netCapacity);</code></pre></div>



<h2 id="ArrayList单线程环境下"><a href="#ArrayList单线程环境下" class="headerlink" title="ArrayList单线程环境下"></a>ArrayList单线程环境下</h2><p>单线程环境的ArrayList是不会有问题的</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayListNotSafeDemo</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;

        List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
        list.add(<span class="hljs-string">&quot;a&quot;</span>);
        list.add(<span class="hljs-string">&quot;b&quot;</span>);
        list.add(<span class="hljs-string">&quot;c&quot;</span>);

        <span class="hljs-keyword">for</span>(String element : list) &#123;
            System.out.println(element);
        &#125;
    &#125;
&#125;</code></pre></div>

<h2 id="多线程环境"><a href="#多线程环境" class="headerlink" title="多线程环境"></a>多线程环境</h2><p>为什么ArrayList是 <strong>线程不安全</strong> 的？因为在进行写操作的时候，方法上为了保证并发性，是 <strong>没有添加synchronized修饰</strong> ，所以并发写的时候，就会出现问题</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210412170344.png" srcset="/img/loading.gif"></p>
<p>当我们同时启动30个线程去操作List的时候</p>
<div class="hljs"><pre><code class="hljs java">
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayListNotSafeDemo</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;

        List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">30</span>; i++) &#123;
            <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
                list.add(UUID.randomUUID().toString().substring(<span class="hljs-number">0</span>, <span class="hljs-number">8</span>));
                System.out.println(list);
            &#125;, String.valueOf(i)).start();
        &#125;
    &#125;
&#125;</code></pre></div>

<p>这个时候出现了错误，也就是java.util.ConcurrentModificationException</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210412170505.png" srcset="/img/loading.gif"></p>
<p>这个异常是  <strong>并发修改的异常</strong> </p>
<h2 id="ArrayList解决方案"><a href="#ArrayList解决方案" class="headerlink" title="ArrayList解决方案"></a>ArrayList解决方案</h2><h3 id="方案一：Vector"><a href="#方案一：Vector" class="headerlink" title="方案一：Vector"></a>方案一：Vector</h3><p>第一种方法，就是不用ArrayList这种不安全的List实现类，而 <strong>采用Vector</strong> ，线程安全的</p>
<p>关于Vector如何实现线程安全的，而是在方法上加了锁，即synchronized</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210412171057.png" srcset="/img/loading.gif"></p>
<p>这样就每次只能够一个线程进行操作，所以不会出现线程不安全的问题，但是因为加锁了，导致 <strong>并发性下降</strong> </p>
<h3 id="方案二：Collections-synchronized"><a href="#方案二：Collections-synchronized" class="headerlink" title="方案二：Collections.synchronized()"></a>方案二：Collections.synchronized()</h3><div class="hljs"><pre><code class="hljs java">List&lt;String&gt; list = Collections.synchronizedList(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;());</code></pre></div>

<p>采用Collections集合工具类，在ArrayList外面包装一层 同步 机制</p>
<h3 id="方案三：采用JUC里面的方法"><a href="#方案三：采用JUC里面的方法" class="headerlink" title="方案三：采用JUC里面的方法"></a>方案三：采用JUC里面的方法</h3><p>CopyOnWriteArrayList：写时复制，主要是一种 <strong>读写分离</strong> 的思想</p>
<p>写时复制，CopyOnWrite容器即写时复制的容器，往一个容器中添加元素的时候，不直接往 <strong>当前容器</strong> Object[]添加，而是先将Object[]进行copy， <strong>复制出一个新的容器</strong> object[] newElements，然后新的容器Object[] newElements里添加原始，添加元素完后，在将原容器的引用 <strong>指向新的容器</strong>  setArray(newElements)；这样做的好处是可以对copyOnWrite容器进行并发的度，而不需要加锁，因为当前容器不需要添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器</p>
<p>就是写的时候，把ArrayList扩容一个出来，然后把值填写上去，在通知其他的线程，ArrayList的引用指向扩容后的</p>
<p>查看底层add方法源码</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210412172516.png" srcset="/img/loading.gif"></p>
<p>首先需要加锁</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">this</span>.lock;
lock.lock();</code></pre></div>

<p>然后在末尾扩容一个单位</p>
<div class="hljs"><pre><code class="hljs java">Object[] elements = getArray();
<span class="hljs-keyword">int</span> len = elements.length;
Object[] newElements = Arrays.copyOf(elements, len + <span class="hljs-number">1</span>);</code></pre></div>

<p>然后在把扩容后的空间，填写上需要add的内容</p>
<div class="hljs"><pre><code class="hljs java">newElements[len] = e;</code></pre></div>

<p>最后把内容set到Array中</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210412172718.png" srcset="/img/loading.gif"></p>
<h2 id="HashSet线程不安全"><a href="#HashSet线程不安全" class="headerlink" title="HashSet线程不安全"></a>HashSet线程不安全</h2><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210412174134.png" srcset="/img/loading.gif"></p>
<p>原因也是没有同步机制</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210412174244.png" srcset="/img/loading.gif"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210412174310.png" srcset="/img/loading.gif"></p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="CopyOnWriteArraySet"><a href="#CopyOnWriteArraySet" class="headerlink" title="CopyOnWriteArraySet"></a>CopyOnWriteArraySet</h4><p>底层还是使用CopyOnWriteArrayList进行实例化</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210412174358.png" srcset="/img/loading.gif"></p>
<h4 id="Collections-synchronizedSet"><a href="#Collections-synchronizedSet" class="headerlink" title="Collections.synchronizedSet"></a>Collections.synchronizedSet</h4><h3 id="HashSet底层结构"><a href="#HashSet底层结构" class="headerlink" title="HashSet底层结构"></a>HashSet底层结构</h3><p>HashSet的底层结构就是HashMap</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210412174705.png" srcset="/img/loading.gif"></p>
<p>但是为什么我调用 HashSet.add()的方法，只需要传递一个元素，而HashMap是需要 <strong>传递key-value键值对</strong> ？</p>
<p>首先我们查看hashSet的 <strong>add方法</strong> </p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;
    <span class="hljs-keyword">return</span> map.put(e, PRESENT)==<span class="hljs-keyword">null</span>;
&#125;</code></pre></div>

<p>我们能发现但我们调用add的时候，存储一个值进入map中，只是作为 <strong>key</strong> 进行存储，而 <strong>value</strong> 存储的是一个Object类型的常量，也就是说HashSet只关心key，而不关心value</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210412174839.png" srcset="/img/loading.gif"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210412174858.png" srcset="/img/loading.gif"></p>
<h2 id="HashMap线程不安全"><a href="#HashMap线程不安全" class="headerlink" title="HashMap线程不安全"></a>HashMap线程不安全</h2><p>同理HashMap在多线程环境下，也是不安全的</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>1、使用Collections.synchronizedMap(new HashMap&lt;&gt;());</p>
<p>2、使用 ConcurrentHashMap</p>
<div class="hljs"><pre><code class="hljs java">Map&lt;String, String&gt; map = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;&gt;();</code></pre></div>



<h1 id="TransferValue是什么"><a href="#TransferValue是什么" class="headerlink" title="TransferValue是什么"></a><strong>TransferValue是什么</strong></h1><h2 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h2><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;
    <span class="hljs-keyword">private</span> Integer id;
    <span class="hljs-keyword">private</span> String personName;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(String personName)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.personName = personName;
    &#125;
&#125;
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TransferValueDemo</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">changeValue1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;
        age = <span class="hljs-number">30</span>;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">changeValue2</span><span class="hljs-params">(Person person)</span> </span>&#123;
        person.setPersonName(<span class="hljs-string">&quot;XXXX&quot;</span>);
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">changeValue3</span><span class="hljs-params">(String str)</span> </span>&#123;
        str = <span class="hljs-string">&quot;XXX&quot;</span>;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        TransferValueDemo test = <span class="hljs-keyword">new</span> TransferValueDemo();

        <span class="hljs-comment">// 定义基本数据类型</span>
        <span class="hljs-keyword">int</span> age = <span class="hljs-number">20</span>;
        test.changeValue1(age);
        System.out.println(<span class="hljs-string">&quot;age ----&quot;</span> + age);

        <span class="hljs-comment">// 实例化person类</span>
        Person person = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;abc&quot;</span>);
        test.changeValue2(person);
        System.out.println(<span class="hljs-string">&quot;personName-----&quot;</span> + person.getPersonName());

        <span class="hljs-comment">// String</span>
        String str = <span class="hljs-string">&quot;abc&quot;</span>;
        test.changeValue3(str);
        System.out.println(<span class="hljs-string">&quot;string-----&quot;</span> + str);

    &#125;
&#125;</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210412175818.png" srcset="/img/loading.gif"></p>
<h2 id="changeValue1的执行过程"><a href="#changeValue1的执行过程" class="headerlink" title="changeValue1的执行过程"></a>changeValue1的执行过程</h2><p>八种基本数据类型，在栈里面分配内存，属于 <strong>值传递</strong> </p>
<div class="hljs"><pre><code class="hljs plain">栈管运行，堆管存储</code></pre></div>

<p>当们执行 changeValue1的时候，因为int是基本数据类型，所以传递的是int = 20这个值，相当于传递的是一个 <strong>副本</strong> ，main方法里面的age并没有改变，因此输出的结果 age还是20，属于值传递</p>
<p>打印的age一直都是main方法的，传入函数的age是一个副本；</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210412180107.png" srcset="/img/loading.gif"></p>
<h2 id="changeValue2的执行过程"><a href="#changeValue2的执行过程" class="headerlink" title="changeValue2的执行过程"></a>changeValue2的执行过程</h2><p>因为Person是属于对象， <strong>传递的是内存地址</strong> ，当执行changeValue2的时候，会改变内存中的Person的值，属于 <strong>引用传递</strong> ，两个指针都是指向同一个地址</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210412180148.png" srcset="/img/loading.gif"></p>
<h2 id="changeValue3的执行过程"><a href="#changeValue3的执行过程" class="headerlink" title="changeValue3的执行过程"></a>changeValue3的执行过程</h2><p>String不属于基本数据类型，但是为什么执行完成后，还是abc呢？</p>
<p>这是因为String的特殊性，当我们执行String str = “abc”的时候，它会把 <code>abc</code> 放入常量池中</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210412180300.png" srcset="/img/loading.gif"></p>
<p>当我们执行changeValue3的时候，会重新 <strong>新建一个xxx</strong> ，并 <strong>没有销毁abc</strong> ，然后指向xxx，然后最后我们输出的是   <strong>main中的引用</strong> ，还是指向的abc，因此最后输出结果还是abc</p>
<h1 id="Java的锁"><a href="#Java的锁" class="headerlink" title="Java的锁"></a><strong>Java的锁</strong></h1><h2 id="lock和Synchronized的区别"><a href="#lock和Synchronized的区别" class="headerlink" title="lock和Synchronized的区别"></a>lock和Synchronized的区别</h2><ol>
<li><p>synchronized属于JVM层面，属于java的 <strong>关键字</strong> </p>
<ul>
<li><p>monitorenter（底层是通过monitor对象来完成，其实wait/notify等方法也依赖于monitor对象 只能在 <strong>同步块或者方法中</strong> 才能调用 wait/ notify等方法）</p>
</li>
<li><p>Lock是 <strong>具体类</strong> （java.util.concurrent.locks.Lock）是api层面的锁<br><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210415100641.png" srcset="/img/loading.gif"></p>
</li>
<li><p>synchronized底层的monitor有两种退出方式，正常和异常退出，保证不会产生死锁</p>
</li>
<li><p>lock是new出来的</p>
</li>
</ul>
</li>
<li><p>使用方法：</p>
<ul>
<li>synchronized： <strong>不需要用户去手动释放锁</strong> ，当synchronized代码执行后，系统会自动让线程释放对锁的占用。</li>
<li>ReentrantLock：则需要用户去手动释放锁，若没有主动释放锁，就有可能出现死锁的现象，需要lock() 和 unlock() 配置try catch语句来完成</li>
</ul>
</li>
<li><p>等待是否中断</p>
<ul>
<li>synchronized：不可中断，除非抛出异常或者正常运行完成。</li>
<li>ReentrantLock： <strong>可中断</strong> ，可以设置 <strong>超时方法</strong> <ul>
<li>设置超时方法，trylock(long timeout, TimeUnit unit)</li>
<li>lockInterrupible() 放代码块中，调用interrupt() 方法可以中断</li>
</ul>
</li>
</ul>
</li>
<li><p>加锁是否公平<br>synchronized：非公平锁<br>ReentrantLock：默认非公平锁，构造函数可以传递boolean值，true为公平锁，false为非公平锁</p>
</li>
<li><p>锁绑定多个条件Condition<br>synchronized：没有，要么随机，要么全部唤醒<br>ReentrantLock：用来实现分组唤醒需要唤醒的线程，可以 <strong>精确唤醒</strong> ，而不是像synchronized那样，要么随机，要么全部唤醒</p>
</li>
</ol>
<h3 id="锁绑定多个条件Condition"><a href="#锁绑定多个条件Condition" class="headerlink" title="锁绑定多个条件Condition"></a>锁绑定多个条件Condition</h3><p><strong>实现场景</strong></p>
<p>多线程之间按顺序调用，实现 A-&gt; B -&gt; C 三个线程启动，要求如下：<br>AA打印5次，BB打印10次，CC打印15次<br>紧接着<br>AA打印5次，BB打印10次，CC打印15次<br>…<br>来10轮</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Code17_MoreConditionDemo</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        ShareNewData shareResource = <span class="hljs-keyword">new</span> ShareNewData();
        <span class="hljs-keyword">int</span> num = <span class="hljs-number">10</span>;

        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; num; i++) &#123;
                shareResource.print5();
            &#125;
        &#125;, <span class="hljs-string">&quot;A&quot;</span>).start();

        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; num; i++) &#123;
                shareResource.print10();
            &#125;
        &#125;, <span class="hljs-string">&quot;B&quot;</span>).start();

        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; num; i++) &#123;
                shareResource.print15();
            &#125;
        &#125;, <span class="hljs-string">&quot;C&quot;</span>).start();
    &#125;
&#125;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShareNewData</span> </span>&#123;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> number = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">private</span> Lock lock = <span class="hljs-keyword">new</span> ReentrantLock();

    <span class="hljs-comment">// 设置三把钥匙</span>
    Condition condition1 = lock.newCondition();
    Condition condition2 = lock.newCondition();
    Condition condition3 = lock.newCondition();

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print5</span><span class="hljs-params">()</span></span>&#123;

        lock.lock();
        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-comment">// 判断</span>
            <span class="hljs-keyword">while</span> (number != <span class="hljs-number">1</span>)&#123;
                <span class="hljs-comment">// 等待</span>
                condition1.await();
            &#125;
            <span class="hljs-comment">// 干活</span>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;
                System.out.println(Thread.currentThread() + <span class="hljs-string">&quot;优先级&quot;</span> + number +<span class="hljs-string">&quot; 打印5&quot;</span>);

            &#125;
            <span class="hljs-comment">// 唤醒</span>
            number = <span class="hljs-number">2</span>;
            condition2.signal();
        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;<span class="hljs-keyword">finally</span> &#123;
            lock.unlock();
        &#125;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print10</span><span class="hljs-params">()</span></span>&#123;

        lock.lock();
        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-keyword">while</span> (number != <span class="hljs-number">2</span>)&#123;
                condition2.await();
            &#125;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;
                System.out.println(Thread.currentThread() + <span class="hljs-string">&quot;优先级&quot;</span> + number +<span class="hljs-string">&quot; 打印10&quot;</span>);
            &#125;
            number = <span class="hljs-number">3</span>;
            condition3.signal();
        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;<span class="hljs-keyword">finally</span> &#123;
            lock.unlock();
        &#125;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print15</span><span class="hljs-params">()</span></span>&#123;

        lock.lock();
        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-keyword">while</span> (number != <span class="hljs-number">3</span>)&#123;
                condition3.await();
            &#125;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">15</span>; i++) &#123;
                System.out.println(Thread.currentThread() + <span class="hljs-string">&quot;优先级&quot;</span> + number +<span class="hljs-string">&quot; 打印15&quot;</span>);
            &#125;number = <span class="hljs-number">1</span>;
            condition1.signal();
        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;<span class="hljs-keyword">finally</span> &#123;
            lock.unlock();
        &#125;
    &#125;
&#125;</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210415102711.png" srcset="/img/loading.gif"></p>
<h2 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><h4 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h4><p>是指多个线程按照 <strong>申请锁的顺序</strong> 来获取锁，类似于排队买饭，先来后到，先来先服务，就是公平的，也就是 <strong>队列</strong> </p>
<h4 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a>非公平锁</h4><p>是指多个线程获取锁的顺序，并不是按照申请锁的顺序，有可能申请的线程比先申请的线程优先获取锁，在高并发环境下，有可能造成 <strong>优先级翻转</strong> ，或者 <strong>饥饿</strong> 的线程（也就是某个线程一直得不到锁）</p>
<h3 id="如何创建"><a href="#如何创建" class="headerlink" title="如何创建"></a>如何创建</h3><p>并发包中 <strong>ReentrantLock</strong> 的创建可以指定 <strong>析构函数</strong> 的boolean类型来得到公平锁或者非公平锁，默认是非公平锁</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment">* 创建一个可重入锁，true 表示公平锁，false 表示非公平锁。默认非公平锁</span>
<span class="hljs-comment">*/</span>
Lock lock = <span class="hljs-keyword">new</span> ReentrantLock(<span class="hljs-keyword">true</span>);</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210412192606.png" srcset="/img/loading.gif"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210412192713.png" srcset="/img/loading.gif"></p>
<h3 id="两者区别"><a href="#两者区别" class="headerlink" title="两者区别"></a>两者区别</h3><p><strong>公平锁</strong>：就是很公平，在并发环境中，每个线程在获取锁时会先查看此锁维护的等待队列，如果为空，或者当前线程是等待队列中的第一个，就占用锁，否者就会加入到等待队列中，以后按照 <strong>FIFO</strong> 的规则从队列中取到自己</p>
<p><strong>非公平锁：</strong> 非公平锁比较粗鲁，上来就直接尝试占有锁，如果尝试失败，就 <strong>再采用类似公平锁</strong> 那种方式。</p>
<h3 id="题外"><a href="#题外" class="headerlink" title="题外"></a>题外</h3><p>Java ReenttrantLock通过构造函数指定该锁是否公平，默认是非公平锁，因为非公平锁的优点在于 <strong>吞吐量</strong> 比公平锁大；</p>
<p><code>对于synchronized而言，也是一种非公平锁</code></p>
<h2 id="可重入锁-递归锁"><a href="#可重入锁-递归锁" class="headerlink" title="可重入锁(递归锁)"></a>可重入锁(递归锁)</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><p>可重入锁就是 <strong>递归锁</strong> </p>
<p>指的是同一线程外层函数获得锁之后，内层递归函数仍然能获取到该锁的代码，在同一线程在外层方法获取锁的时候，在进入内层方法会自动获取锁</p>
<p>也就是说：<code>线程可以进入任何一个它已经拥有的锁所同步的代码块</code></p>
<p> <strong>ReentrantLock / Synchronized</strong> 就是一个典型的可重入锁</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>可重入锁就是，在一个method1方法中加入一把锁，方法2也加锁了，那么他们拥有的是 <strong>同一把锁</strong> </p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">// 大门锁</span>
  method2();<span class="hljs-comment">// 大门锁和小门锁变成一把锁</span>
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">// 小门锁</span>
  
&#125;</code></pre></div>

<p>也就是说我们只需要进入method1后，那么它也能直接进入method2方法，因为他们所拥有的锁，是同一把。</p>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>可重入锁的最大作用就是 <strong>避免死锁</strong> </p>
<h3 id="可重入锁验证"><a href="#可重入锁验证" class="headerlink" title="可重入锁验证"></a>可重入锁验证</h3><h4 id="证明Synchronized"><a href="#证明Synchronized" class="headerlink" title="证明Synchronized"></a>证明Synchronized</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 资源类</span>
<span class="hljs-comment"> */</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Phone</span> </span>&#123;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 发送短信</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendSMS</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;
        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t invoked sendSMS()&quot;</span>);

        <span class="hljs-comment">// 在同步方法中，调用另外一个同步方法</span>
        sendEmail();
    &#125;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 发邮件</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendEmail</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;
        System.out.println(Thread.currentThread().getId() + <span class="hljs-string">&quot;\t invoked sendEmail()&quot;</span>);
    &#125;
&#125;
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReenterLockDemo</span> </span>&#123;


    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        Phone phone = <span class="hljs-keyword">new</span> Phone();

        <span class="hljs-comment">// 两个线程操作资源列</span>
        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
            <span class="hljs-keyword">try</span> &#123;
                phone.sendSMS();
            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
                e.printStackTrace();
            &#125;
        &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();

        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
            <span class="hljs-keyword">try</span> &#123;
                phone.sendSMS();
            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
                e.printStackTrace();
            &#125;
        &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();
    &#125;
&#125;</code></pre></div>

<p>在这里，我们编写了一个资源类phone，拥有两个加了synchronized的同步方法，分别是sendSMS 和 sendEmail，我们在sendSMS方法中，调用sendEmail。最后在主线程同时开启了两个线程进行测试，最后得到的结果为：</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210413105219.png" srcset="/img/loading.gif"></p>
<p>这就说明当 t1 线程进入sendSMS的时候，拥有了一把锁，同时t2线程无法进入，直到t1线程拿着锁，执行了sendEmail 方法后，才释放锁，这样t2才能够进入</p>
<div class="hljs"><pre><code class="hljs javascript">t1   invoked sendSMS()      t1线程在外层方法获取锁的时候
t1   invoked sendEmail()    t1在进入内层方法会自动获取锁

t2   invoked sendSMS()      t2线程在外层方法获取锁的时候
t2   invoked sendEmail()    t2在进入内层方法会自动获取锁</code></pre></div>



<h4 id="证明ReentrantLock"><a href="#证明ReentrantLock" class="headerlink" title="证明ReentrantLock"></a>证明ReentrantLock</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 资源类</span>
<span class="hljs-comment"> */</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Phone</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;

    Lock lock = <span class="hljs-keyword">new</span> ReentrantLock();

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * set进去的时候，就加锁，调用set方法的时候，能否访问另外一个加锁的set方法</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getLock</span><span class="hljs-params">()</span> </span>&#123;
        lock.lock();
        <span class="hljs-keyword">try</span> &#123;
            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t get Lock&quot;</span>);
            setLock();
        &#125; <span class="hljs-keyword">finally</span> &#123;
            lock.unlock();
        &#125;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLock</span><span class="hljs-params">()</span> </span>&#123;
        lock.lock();
        <span class="hljs-keyword">try</span> &#123;
            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t set Lock&quot;</span>);
        &#125; <span class="hljs-keyword">finally</span> &#123;
            lock.unlock();
        &#125;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;
        getLock();
    &#125;
&#125;
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReenterLockDemo</span> </span>&#123;


    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        Phone phone = <span class="hljs-keyword">new</span> Phone();

        <span class="hljs-comment">/**</span>
<span class="hljs-comment">         * 因为Phone实现了Runnable接口</span>
<span class="hljs-comment">         */</span>
        Thread t3 = <span class="hljs-keyword">new</span> Thread(phone, <span class="hljs-string">&quot;t3&quot;</span>);
        Thread t4 = <span class="hljs-keyword">new</span> Thread(phone, <span class="hljs-string">&quot;t4&quot;</span>);
        t3.start();
        t4.start();
    &#125;
&#125;</code></pre></div>

<p>我们使用ReentrantLock进行验证，首先资源类实现了Runnable接口，重写Run方法，里面调用get方法，get方法在进入的时候，就加了锁</p>
<p>然后在方法里面，又调用另外一个加了锁的setLock方法</p>
<p>最后输出结果我们能发现，结果和加synchronized方法是一致的，都是在 <strong>外层的方法获取锁之后，线程能够直接进入里层</strong> </p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210413105930.png" srcset="/img/loading.gif"></p>
<blockquote>
<p>如果加两把锁</p>
</blockquote>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210414075812.png" srcset="/img/loading.gif"></p>
<p>Lock, unlock只要配对就行了；</p>
<p>最后得到的结果也是一样的，因为里面不管有几把锁，其它他们都是同一把锁，也就是说用同一个钥匙都能够打开</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210414075933.png" srcset="/img/loading.gif"></p>
<blockquote>
<p>如果缺一个unlock</p>
</blockquote>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210414080126.png" srcset="/img/loading.gif"></p>
<p>也就是说程序直接卡死，线程不能出来，也就说明我们申请几把锁，最后需要解除几把锁</p>
<p> <strong>当我们只加一把锁，但是用两把锁来解锁的时候，又会出现什么情况呢？</strong> </p>
<p>这个时候，运行程序会直接报错</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210414080330.png" srcset="/img/loading.gif"></p>
<h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><p>自旋锁：spinlock，是指尝试获取锁的线程不会立即阻塞，而是采用 <strong>循环</strong> 的方式去尝试 <strong>获取锁</strong> ，这样的好处是 <strong>减少线程上下文切换的消耗</strong> ，缺点是 <strong>循环会消耗CPU</strong> </p>
<p>原来提到的CAS，底层使用的就是自旋，自旋就是多次尝试，多次访问， <strong>不会阻塞</strong> 的状态就是自旋。</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210414081207.png" srcset="/img/loading.gif"></p>
<h3 id="手写自旋锁"><a href="#手写自旋锁" class="headerlink" title="手写自旋锁"></a>手写自旋锁</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Code10_SpinLockDemo</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        SpinLockDemo lock = <span class="hljs-keyword">new</span> SpinLockDemo();
        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
            lock.myLock();
            <span class="hljs-comment">// t1等待5s</span>
            <span class="hljs-keyword">try</span> &#123;
                TimeUnit.SECONDS.sleep(<span class="hljs-number">5</span>);
            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
            lock.unLock();
        &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();

        <span class="hljs-keyword">try</span> &#123;
            TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);
        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;

        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
            lock.myLock();
            lock.unLock();
        &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();
    &#125;
&#125;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpinLockDemo</span></span>&#123;

    <span class="hljs-comment">// 持有锁的线程，null表示锁未被线程持有</span>

    AtomicReference&lt;Thread&gt; atomicReference = <span class="hljs-keyword">new</span> AtomicReference&lt;&gt;();

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">myLock</span><span class="hljs-params">()</span></span>&#123;
        Thread thread = Thread.currentThread();
        System.out.println(thread.getName() + <span class="hljs-string">&quot;: come in!&quot;</span>);
        <span class="hljs-keyword">while</span> (!atomicReference.compareAndSet(<span class="hljs-keyword">null</span>, thread))&#123;
            <span class="hljs-comment">//当atomicReference为null的时候compareAndSet返回true，反之为false</span>
            <span class="hljs-comment">//通过循环不断的自旋判断锁是否被其他线程持有</span>
            System.out.println(thread.getName() + <span class="hljs-string">&quot; 自旋....&quot;</span>);
        &#125;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unLock</span><span class="hljs-params">()</span></span>&#123;
        Thread thread = Thread.currentThread();
        <span class="hljs-comment">// 解锁可以追加判断是否为当前线程 单CAS可以预判断期待值</span>
        atomicReference.compareAndSet(thread, <span class="hljs-keyword">null</span>);
        System.out.println(thread.getName() + <span class="hljs-string">&quot;: destory!&quot;</span>);
    &#125;
&#125;</code></pre></div>

<p>输出结果：</p>
<p>一开始：</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210414084139.png" srcset="/img/loading.gif"></p>
<p>t1进去占用线程，t2也进去，但循环判断，开始自旋</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210414084243.png" srcset="/img/loading.gif"></p>
<p>然后1秒后，t2线程启动，发现锁被t1占有，所有不断的执行 compareAndSet方法，来进行比较，直到t1释放锁后，也就是5秒后，t2成功获取到锁，然后释放</p>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：循环比较获取直到成功为止， <strong>没有</strong> 类似于wait的 <strong>阻塞</strong> </p>
<p>缺点：当不断自旋的线程越来越多的时候，会因为执行while循环不断的消耗CPU资源</p>
<h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><h3 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h3><p> <strong>独占锁</strong> ：指该锁一次只能被 <strong>一个线程</strong> 所持有。对ReentrantLock和Synchronized而言都是独占锁</p>
<p> <strong>共享锁</strong> ：指该锁可以被 <strong>多个线程锁持有</strong> </p>
<p>对ReentrantReadWriteLock其 <strong>读锁</strong> 是共享，其 <strong>写锁</strong> 是独占</p>
<p>写的时候只能一个人写，但是读的时候，可以多个人同时读</p>
<h3 id="为什么会有写锁和读锁"><a href="#为什么会有写锁和读锁" class="headerlink" title="为什么会有写锁和读锁"></a>为什么会有写锁和读锁</h3><p>原来我们使用ReentrantLock创建锁的时候，是独占锁，也就是说一次只能一个线程访问，但是有一个读写分离场景，读的时候想同时进行，因此原来独占锁的并发性就没这么好了，因为 <strong>读锁并不会造成数据不一致</strong> 的问题，因此可以多个人 <strong>共享读</strong> </p>
<div class="hljs"><pre><code class="hljs plain">多个线程 同时读一个资源类没有任何问题，所以为了满足并发量，读取共享资源应该可以同时进行，但是如果一个线程想去写共享资源，就不应该再有其它线程可以对该资源进行读或写</code></pre></div>

<p>读-读：能共存</p>
<p>读-写：不能共存</p>
<p>写-写：不能共存</p>
<h3 id="手写代码"><a href="#手写代码" class="headerlink" title="手写代码"></a>手写代码</h3><p>实现一个 <strong>读写缓存的操作</strong> ，假设开始 <strong>没有加锁</strong> 的时候，会出现什么情况</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 读写锁</span>
<span class="hljs-comment"> * 多个线程 同时读一个资源类没有任何问题，所以为了满足并发量，读取共享资源应该可以同时进行</span>
<span class="hljs-comment"> * 但是，如果一个线程想去写共享资源，就不应该再有其它线程可以对该资源进行读或写</span>
<span class="hljs-comment"> *</span>
<span class="hljs-comment"> */</span>

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 资源类</span>
<span class="hljs-comment"> */</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCache</span> </span>&#123;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
    <span class="hljs-comment">// private Lock lock = null;</span>

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 定义写操作</span>
<span class="hljs-comment">     * 满足：原子 + 独占</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(String key, Object value)</span> </span>&#123;
        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 正在写入：&quot;</span> + key);
        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-comment">// 模拟网络拥堵，延迟0.3秒</span>
            TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">300</span>);
        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
        map.put(key, value);
        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 写入完成&quot;</span>);
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">get</span><span class="hljs-params">(String key)</span> </span>&#123;
        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 正在读取:&quot;</span>);
        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-comment">// 模拟网络拥堵，延迟0.3秒</span>
            TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">300</span>);
        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
        Object value = map.get(key);
        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 读取完成：&quot;</span> + value);
    &#125;


&#125;
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Code11_ReadWriteLockDemo</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;

        MyCache myCache = <span class="hljs-keyword">new</span> MyCache();
        <span class="hljs-comment">// 线程操作资源类，5个线程写</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;
            <span class="hljs-comment">// lambda表达式内部必须是final</span>
            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> tempInt = i;
            <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
                myCache.put(tempInt + <span class="hljs-string">&quot;&quot;</span>, tempInt +  <span class="hljs-string">&quot;&quot;</span>);
            &#125;, String.valueOf(i)).start();
        &#125;
        <span class="hljs-comment">// 线程操作资源类， 5个线程读</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;
            <span class="hljs-comment">// lambda表达式内部必须是final</span>
            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> tempInt = i;
            <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
                myCache.get(tempInt + <span class="hljs-string">&quot;&quot;</span>);
            &#125;, String.valueOf(i)).start();
        &#125;
    &#125;
&#125;</code></pre></div>

<p>没有加锁的情况下：</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210414160436.png" srcset="/img/loading.gif"></p>
<p>在写入的时候，写操作都没完成，其它线程就打断了，这就造成了，还没写完，其它线程又开始读，这样就造成数据不一致</p>
<h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><p>上面的代码是 <strong>没有加锁</strong> 的，这样就会造成线程在进行写入操作的时候，被其它线程频繁打断，从而不具备原子性，这个时候，我们就需要用到 <strong>读写锁</strong> 来解决了</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 资源类</span>
<span class="hljs-comment"> */</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyNewCache</span> </span>&#123;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 缓存中的东西，必须保持可见性，因此使用volatile修饰</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 创建一个读写锁</span>
<span class="hljs-comment">     * 它是一个读写融为一体的锁，在使用的时候，需要转换</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-keyword">private</span> ReentrantReadWriteLock rwLock = <span class="hljs-keyword">new</span> ReentrantReadWriteLock();

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 定义写操作</span>
<span class="hljs-comment">     * 满足：原子 + 独占</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(String key, Object value)</span> </span>&#123;

        <span class="hljs-comment">// 创建一个写锁</span>
        rwLock.writeLock().lock();

        <span class="hljs-keyword">try</span> &#123;

            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 正在写入：&quot;</span> + key);

            <span class="hljs-keyword">try</span> &#123;
                <span class="hljs-comment">// 模拟网络拥堵，延迟0.3秒</span>
                TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">300</span>);
            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;

            map.put(key, value);

            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 写入完成&quot;</span>);

        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
            e.printStackTrace();
        &#125; <span class="hljs-keyword">finally</span> &#123;
            <span class="hljs-comment">// 写锁 释放</span>
            rwLock.writeLock().unlock();
        &#125;
    &#125;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 获取</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">get</span><span class="hljs-params">(String key)</span> </span>&#123;

        <span class="hljs-comment">// 读锁</span>
        rwLock.readLock().lock();
        <span class="hljs-keyword">try</span> &#123;

            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 正在读取:&quot;</span>);

            <span class="hljs-keyword">try</span> &#123;
                <span class="hljs-comment">// 模拟网络拥堵，延迟0.3秒</span>
                TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">300</span>);
            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;

            Object value = map.get(key);

            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 读取完成：&quot;</span> + value);

        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
            e.printStackTrace();
        &#125; <span class="hljs-keyword">finally</span> &#123;
            <span class="hljs-comment">// 读锁释放</span>
            rwLock.readLock().unlock();
        &#125;
    &#125;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 清空缓存</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clean</span><span class="hljs-params">()</span> </span>&#123;
        map.clear();
    &#125;
    
&#125;</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210414160844.png" srcset="/img/loading.gif"></p>
<p>从运行结果我们可以看出，写入操作是 <strong>一个一个线程</strong> 进行执行的，并且中间不会被打断，而读操作的时候，是 <strong>同时5个线程进入</strong> ，然后 <strong>并发读</strong> 取操作</p>
<h1 id="JUC一些包"><a href="#JUC一些包" class="headerlink" title="JUC一些包"></a>JUC一些包</h1><h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><h3 id="概念-4"><a href="#概念-4" class="headerlink" title="概念"></a>概念</h3><p>让一些 <strong>线程阻塞</strong> 直到另一些线程完成一系列操作才被 <strong>唤醒</strong> </p>
<p>CountDownLatch主要有 <strong>两个方法</strong> ，当一个或多个线程调用await方法时，调用线程就会被阻塞。其它线程调用CountDown方法会将计数器减1（调用CountDown方法的线程不会被阻塞），当计数器的值变成零时，因调用await方法被阻塞的线程会被唤醒，继续执行</p>
<h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>现在有这样一个场景，假设一个自习室里有7个人，其中有一个是班长，班长的主要职责就是在其它6个同学走了后，关灯，锁教室门，然后走人，因此班长是需要最后一个走的，那么有什么方法能够控制班长这个线程是最后一个执行，而其它线程是随机执行的</p>
<h3 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h3><p>这个时候就用到了CountDownLatch，计数器了。我们一共创建 <strong>6个线程</strong> ，然后 <strong>计数器</strong> 的值也设置成6</p>
<p>然后每次学生线程执行完，就让计数器的值减1</p>
<p>最后我们需要通过CountDownLatch的await方法来控制班长主线程的执行，这里 countDownLatch.await()可以想成是一道墙，只有当计数器的值为0的时候，墙才会消失，主线程才能继续往下执行</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;

    <span class="hljs-comment">// 计数器</span>
    CountDownLatch countDownLatch = <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">6</span>);

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">6</span>; i++) &#123;
        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 上完自习，离开教室&quot;</span>);
            countDownLatch.countDown();
        &#125;, String.valueOf(i)).start();
    &#125;

    countDownLatch.await();

    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 班长最后关门&quot;</span>);
&#125;</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210414164311.png" srcset="/img/loading.gif"></p>
<p>引入CountDownLatch后的执行结果，我们能够控制住main方法的执行，这样能够保证前提任务的执行</p>
<h3 id="枚举优化拓展"><a href="#枚举优化拓展" class="headerlink" title="枚举优化拓展"></a>枚举优化拓展</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210414165748.png" srcset="/img/loading.gif"></p>
<h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><h3 id="概念-5"><a href="#概念-5" class="headerlink" title="概念"></a>概念</h3><p>和CountDownLatch相反，需要集齐七颗龙珠，召唤神龙。也就是 <strong>做加法</strong> ，开始是0，加到某个值的时候就执行</p>
<p>CyclicBarrier的字面意思就是可循环（cyclic）使用的屏障（Barrier）。它要求做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活，线程进入屏障通过CyclicBarrier的await方法</p>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>集齐7个龙珠，召唤神龙的Demo，我们需要首先创建CyclicBarrier（ <strong>第二个参数为被阻塞的线程</strong> ）</p>
<p>然后同时编写七个线程，进行龙珠收集，但一个线程收集到了的时候，我们需要让他执行await方法，等待到7个线程全部执行完毕后，我们就执行原来定义好的方法</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 定义一个循环屏障，参数1：需要累加的值，参数2 需要执行的方法</span>
<span class="hljs-comment">     */</span>
    CyclicBarrier cyclicBarrier = <span class="hljs-keyword">new</span> CyclicBarrier(<span class="hljs-number">7</span>, () -&gt; &#123;
        System.out.println(<span class="hljs-string">&quot;召唤神龙&quot;</span>);
    &#125;);

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">7</span>; i++) &#123;
        <span class="hljs-keyword">final</span> Integer tempInt = i;
        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 收集到 第&quot;</span> + tempInt + <span class="hljs-string">&quot;颗龙珠&quot;</span>);

            <span class="hljs-keyword">try</span> &#123;
                <span class="hljs-comment">// 先到的被阻塞，等全部线程完成后，才能执行方法</span>
                cyclicBarrier.await();
            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
                e.printStackTrace();
            &#125; <span class="hljs-keyword">catch</span> (BrokenBarrierException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;, String.valueOf(i)).start();
    &#125;
&#125;</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210414165944.png" srcset="/img/loading.gif"></p>
<h2 id="Semaphore：信号量"><a href="#Semaphore：信号量" class="headerlink" title="Semaphore：信号量"></a>Semaphore：信号量</h2><h3 id="概念-6"><a href="#概念-6" class="headerlink" title="概念"></a>概念</h3><p>信号量主要用于两个目的</p>
<ul>
<li>一个是用于 <strong>共享资源</strong> 的 <strong>互斥</strong> 使用</li>
<li>另一个用于 <strong>并发线程数</strong> 的控制</li>
</ul>
<h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><p>我们模拟一个抢车位的场景，假设一共有 <strong>6个车，3个停车位</strong> </p>
<p>那么我们首先需要定义信号量为3，也就是3个停车位</p>
<p>然后我们模拟6辆车同时并发抢占停车位，但第一个车辆抢占到停车位后， <strong>信号量需要减1</strong> </p>
<p>同时车辆假设需要等待3秒后， <strong>释放信号量</strong> </p>
<p>最后车辆离开，释放信号量</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 初始化一个信号量为3，默认是false 非公平锁， 模拟3个停车位</span>
<span class="hljs-comment">     */</span>
    Semaphore semaphore = <span class="hljs-keyword">new</span> Semaphore(<span class="hljs-number">3</span>, <span class="hljs-keyword">false</span>);

    <span class="hljs-comment">// 模拟6部车</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; i++) &#123;
        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
            <span class="hljs-keyword">try</span> &#123;
                <span class="hljs-comment">// 代表一辆车，已经占用了该车位</span>
                semaphore.acquire(); <span class="hljs-comment">// 抢占</span>

                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 抢到车位&quot;</span>);

                <span class="hljs-comment">// 每个车停3秒</span>
                <span class="hljs-keyword">try</span> &#123;
                    TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>);
                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;

                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 离开车位&quot;</span>);

            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
                e.printStackTrace();
            &#125; <span class="hljs-keyword">finally</span> &#123;
                <span class="hljs-comment">// 释放停车位</span>
                semaphore.release();
            &#125;
        &#125;, String.valueOf(i)).start();
    &#125;
&#125;</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210414170931.png" srcset="/img/loading.gif"></p>
<h1 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h1><h2 id="概念-7"><a href="#概念-7" class="headerlink" title="概念"></a>概念</h2><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>队列就可以想成是一个数组，从一头进入，一头出去，排队买饭</p>
<h3 id="阻塞队列-1"><a href="#阻塞队列-1" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><p>BlockingQueue 阻塞队列，排队拥堵，首先它是一个队列，而一个阻塞队列在数据结构中所起的作用大致如下图所示：</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210414171141.png" srcset="/img/loading.gif"></p>
<p>线程1往阻塞队列中 <strong>添加元素</strong> ，而线程2从阻塞队列中 <strong>移除元素</strong> </p>
<ul>
<li><code>当阻塞队列是空时，从队列中获取元素的操作将会被阻塞</code><ul>
<li>当蛋糕店的柜子空的时候， <strong>无法</strong> 从柜子里面获取蛋糕</li>
</ul>
</li>
<li><code>当阻塞队列是满时，从队列中添加元素的操作将会被阻塞</code><ul>
<li>当蛋糕店的柜子满的时候， <strong>无法</strong> 继续向柜子里面添加蛋糕了</li>
</ul>
</li>
</ul>
<p>也就是说 试图从空的阻塞队列中获取元素的线程将会被阻塞，直到其它线程往空的队列插入新的元素</p>
<p>同理，试图往已经满的阻塞队列中添加新元素的线程，直到其它线程往满的队列中移除一个或多个元素，或者完全清空队列后，使队列重新变得空闲起来，并后续新增</p>
<h2 id="为什么要用？"><a href="#为什么要用？" class="headerlink" title="为什么要用？"></a>为什么要用？</h2><p>去海底捞吃饭，大厅满了，需要进候厅等待，但是这些等待的客户能够对商家带来利润，因此我们非常欢迎他们阻塞</p>
<p>在多线程领域：所谓的阻塞，在某些清空下会 <strong>挂起线程（即阻塞）</strong> ，一旦条件满足，被挂起的线程又会 <strong>自动唤醒</strong> </p>
<h3 id="为什么需要BlockingQueue"><a href="#为什么需要BlockingQueue" class="headerlink" title="为什么需要BlockingQueue"></a>为什么需要BlockingQueue</h3><p>好处是我们 <strong>不需要关心什么时候</strong> 需要阻塞线程，什么时候需要唤醒线程，因为这一切BlockingQueue都帮你一手包办了</p>
<p>在concurrent包发布以前，在多线程环境下，我们每个程序员都必须自己取控制这些细节，尤其还要兼顾效率和线程安全，而这会给我们的程序带来不小的复杂度。</p>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>BlockingQueue阻塞队列是属于一个 <strong>接口</strong> ，底下有 <strong>七个实现类</strong> </p>
<ul>
<li> <strong>ArrayBlockQueue</strong> ：由数组结构组成的 <strong>有界阻塞队列</strong> (数组该有个初始值)</li>
<li><strong>LinkedBlockingQueue</strong> ：由链表结构组成的 <strong>有界</strong> （但是默认大小  <strong>Integer.MAX_VALUE</strong> ）的阻塞队列<ul>
<li>有界，但是界限非常大，相当于无界，可以当成无界</li>
</ul>
</li>
<li>PriorityBlockQueue：支持优先级排序的无界阻塞队列</li>
<li>DelayQueue：使用优先级队列实现的延迟无界阻塞队列</li>
<li><strong>SynchronousQueue</strong> ： <strong>不存储元素</strong> 的阻塞队列，也即单个元素的队列<ul>
<li>生产一个，消费一个，不存储元素，不消费不生产</li>
</ul>
</li>
<li>LinkedTransferQueue：由链表结构组成的无界阻塞队列</li>
<li>LinkedBlockingDeque：由链表结构组成的 <strong>双向</strong> 阻塞队列</li>
</ul>
<p>这里需要掌握的是：ArrayBlockQueue、LinkedBlockingQueue、SynchronousQueue</p>
<h2 id="BlockingQueue核心方法"><a href="#BlockingQueue核心方法" class="headerlink" title="BlockingQueue核心方法"></a>BlockingQueue核心方法</h2><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210415084245.png" srcset="/img/loading.gif"></p>
<table>
<thead>
<tr>
<th>抛出异常</th>
<th>当阻塞队列满时：在往队列中add插入元素会抛出 IIIegalStateException：Queue full 当阻塞队列空时：再往队列中remove移除元素，会抛出NoSuchException</th>
</tr>
</thead>
<tbody><tr>
<td>特殊性</td>
<td>插入方法，成功true，失败false 移除方法：成功返回出队列元素，队列没有就返回空</td>
</tr>
<tr>
<td>一直阻塞</td>
<td>当阻塞队列满时，生产者继续往队列里put元素，队列会一直阻塞生产线程直到put数据or响应中断退出， 当阻塞队列空时，消费者线程试图从队列里take元素，队列会一直阻塞消费者线程直到队列可用。</td>
</tr>
<tr>
<td>超时退出</td>
<td>当阻塞队列满时，队里会阻塞生产者线程一定时间，超过限时后生产者线程会退出</td>
</tr>
</tbody></table>
<h3 id="抛出异常组"><a href="#抛出异常组" class="headerlink" title="抛出异常组"></a>抛出异常组</h3><h4 id="add-异常"><a href="#add-异常" class="headerlink" title="add 异常"></a>add 异常</h4><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210415084733.png" srcset="/img/loading.gif"></p>
<p>执行add方法，向 <strong>已经满的</strong> ArrayBlockingQueue中添加元素时候，会抛出异常</p>
<h4 id="remove异常"><a href="#remove异常" class="headerlink" title="remove异常"></a>remove异常</h4><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210415084912.png" srcset="/img/loading.gif"></p>
<p>如果我们 <strong>多取出</strong> 元素的时候，也会抛出异常，我们假设只存储了3个值，但是取的时候，取了四次</p>
<h4 id="element"><a href="#element" class="headerlink" title="element"></a>element</h4><p>element首先检测队列是否为空，再返回队首</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210415085205.png" srcset="/img/loading.gif"></p>
<h3 id="特殊值组"><a href="#特殊值组" class="headerlink" title="特殊值组"></a>特殊值组</h3><h4 id="offer和poll"><a href="#offer和poll" class="headerlink" title="offer和poll"></a>offer和poll</h4><p>我们使用 offer的方法，添加元素时候，如果阻塞队列满了后，会返回false，否者返回true</p>
<p>同时在取的时候，如果队列已空，那么会返回null</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210415085420.png" srcset="/img/loading.gif"></p>
<h3 id="阻塞队列组"><a href="#阻塞队列组" class="headerlink" title="阻塞队列组"></a>阻塞队列组</h3><p>我们使用 put的方法，添加元素时候，如果阻塞队列满了后，添加消息的线程，会一直 <strong>阻塞</strong> ，直到队列元素减少，会被清空，才会 <strong>唤醒</strong> </p>
<p>一般在消息中间件，比如 <strong>RabbitMQ</strong> 中会使用到，因为需要保证消息 <strong>百分百不丢失</strong> ，因此只有让它阻塞</p>
<p>同时使用take取消息的时候，如果内容不存在的时候， <strong>也会被阻塞</strong> </p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210415085722.png" srcset="/img/loading.gif"></p>
<h3 id="不见不散组"><a href="#不见不散组" class="headerlink" title="不见不散组"></a>不见不散组</h3><p>offer( ) ， poll 加时间</p>
<p>使用offer插入的时候，需要 <strong>指定时间</strong> ，如果2秒还没有插入，那么就放弃插入</p>
<div class="hljs"><pre><code class="hljs java">BlockingQueue&lt;String&gt; blockingQueue = <span class="hljs-keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="hljs-number">3</span>);
System.out.println(blockingQueue.offer(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-number">2L</span>, TimeUnit.SECONDS));
System.out.println(blockingQueue.offer(<span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-number">2L</span>, TimeUnit.SECONDS));
System.out.println(blockingQueue.offer(<span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-number">2L</span>, TimeUnit.SECONDS));
System.out.println(blockingQueue.offer(<span class="hljs-string">&quot;d&quot;</span>, <span class="hljs-number">2L</span>, TimeUnit.SECONDS));</code></pre></div>

<p>同时取的时候也进行判断,如果2秒内取不出来，那么就返回null</p>
<h2 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h2><p>SynchronousQueue <strong>没有容量</strong> ，与其他BlockingQueue不同，SynchronousQueue是一个不存储的BlockingQueue， <strong>每一个put操作必须等待一个take操作</strong> ，否者不能继续添加元素</p>
<p>下面我们测试SynchronousQueue添加元素的过程</p>
<p>首先我们创建了两个线程，一个线程用于生产，一个线程用于消费</p>
<p>生产的线程分别put了 A、B、C这三个字段</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSynchronousQueue</span><span class="hljs-params">()</span> </span>&#123;
    BlockingQueue&lt;String&gt; blockingQueue = <span class="hljs-keyword">new</span> SynchronousQueue&lt;&gt;();

    <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
        <span class="hljs-keyword">try</span> &#123;
            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t put A &quot;</span>);
            blockingQueue.put(<span class="hljs-string">&quot;A&quot;</span>);

            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t put B &quot;</span>);
            blockingQueue.put(<span class="hljs-string">&quot;B&quot;</span>);

            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t put C &quot;</span>);
            blockingQueue.put(<span class="hljs-string">&quot;C&quot;</span>);

        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();
    <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
        <span class="hljs-keyword">try</span> &#123;

            <span class="hljs-keyword">try</span> &#123;
                TimeUnit.SECONDS.sleep(<span class="hljs-number">5</span>);
            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
            blockingQueue.take();
            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t take A &quot;</span>);

            <span class="hljs-keyword">try</span> &#123;
                TimeUnit.SECONDS.sleep(<span class="hljs-number">5</span>);
            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
            blockingQueue.take();
            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t take B &quot;</span>);

            <span class="hljs-keyword">try</span> &#123;
                TimeUnit.SECONDS.sleep(<span class="hljs-number">5</span>);
            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
            blockingQueue.take();
            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t take C &quot;</span>);

        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();
&#125;</code></pre></div>

<p>最后结果输出为：</p>
<div class="hljs"><pre><code class="hljs js">t1   put A 
t2   take A 

<span class="hljs-number">5</span>秒后...

t1   put B 
t2   take B 

<span class="hljs-number">5</span>秒后...

t1   put C 
t2   take C</code></pre></div>



<p>我们从最后的运行结果可以看出，每次t1线程向队列中添加阻塞队列添加元素后，t1输入线程就会 <strong>等待</strong>  t2消费线程，t2消费后，t2处于 <strong>挂起状态</strong> ，等待t1在存入，从而周而复始，形成 一存一取的状态</p>
<h2 id="阻塞队列的用处"><a href="#阻塞队列的用处" class="headerlink" title="阻塞队列的用处"></a>阻塞队列的用处</h2><h3 id="生产者消费者模式"><a href="#生产者消费者模式" class="headerlink" title="生产者消费者模式"></a>生产者消费者模式</h3><h5 id="版本区别"><a href="#版本区别" class="headerlink" title="版本区别"></a>版本区别</h5><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210415091117.png" srcset="/img/loading.gif"></p>
<p>一个初始值为0的变量，两个线程对其 <strong>交替操作</strong> ，一个加1，一个减1，来5轮</p>
<p>关于多线程的操作，我们需要记住下面几句</p>
<ul>
<li>线程 操作  <strong>资源类</strong> </li>
<li>判断 干活 通知</li>
<li>防止虚假唤醒机制</li>
</ul>
<p>我们下面实现一个简单的生产者消费者模式，首先有 <strong>资源类ShareData</strong></p>
<h5 id="传统模式"><a href="#传统模式" class="headerlink" title="传统模式"></a>传统模式</h5><p>里面有一个number变量，同时提供了increment 和 decrement的方法，分别让number 加1和减1</p>
<p>但是我们在进行判断的时候，为了防止出现 <strong>虚假唤醒机制</strong> ，不能使用if来进行判断，而应该使用while</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210415095911.png" srcset="/img/loading.gif"></p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// 判断</span>
<span class="hljs-keyword">while</span>(number != <span class="hljs-number">0</span>) &#123;
    <span class="hljs-comment">// 等待不能生产</span>
    condition.await();
&#125;</code></pre></div>

<p>不能使用 if判断</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// 判断</span>
<span class="hljs-keyword">if</span>(number != <span class="hljs-number">0</span>) &#123;
    <span class="hljs-comment">// 等待不能生产</span>
    condition.await();
&#125;</code></pre></div>

<p>完整代码</p>
<p>一个进行生产，一个进行消费</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// 生产与消费者 传统模式</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Code16_ProdConsumerTraditionDemo</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;

        <span class="hljs-comment">// 高内聚，低耦合    内聚指的是，一个空调，自身带有调节温度高低的方法</span>

        ShareData shareData = <span class="hljs-keyword">new</span> ShareData();

        <span class="hljs-comment">// t1线程，生产</span>
        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;
                <span class="hljs-keyword">try</span> &#123;
                    shareData.increment();
                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
        &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();

        <span class="hljs-comment">// t2线程，消费</span>
        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;
                <span class="hljs-keyword">try</span> &#123;
                    shareData.decrement();
                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
        &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();
    &#125;
&#125;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShareData</span> </span>&#123;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> number; <span class="hljs-comment">// 资源类数量</span>
    <span class="hljs-keyword">private</span> Lock lock = <span class="hljs-keyword">new</span> ReentrantLock();
    <span class="hljs-keyword">private</span> Condition condition = lock.newCondition();

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increment</span> <span class="hljs-params">()</span></span>&#123;
        <span class="hljs-comment">// 同步代码块，加锁</span>
        lock.lock();

        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-comment">// 循环判断</span>
            <span class="hljs-keyword">while</span> (number != <span class="hljs-number">0</span>)&#123;
                <span class="hljs-comment">// 等待不能生产</span>
                condition.await();
            &#125;
            <span class="hljs-comment">// 干活</span>
            number ++; <span class="hljs-comment">// 生产</span>
            System.out.println(Thread.currentThread() + <span class="hljs-string">&quot;生产&quot;</span> + number);
            <span class="hljs-comment">// 通知 唤醒</span>
            condition.signalAll();
        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;<span class="hljs-keyword">finally</span> &#123;
            lock.unlock();
        &#125;

    &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decrement</span> <span class="hljs-params">()</span></span>&#123;
        lock.lock();

        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-comment">// 循环判断</span>
            <span class="hljs-keyword">while</span> (number == <span class="hljs-number">0</span>)&#123;
                condition.await();
            &#125;
            number --; <span class="hljs-comment">//  消费</span>
            System.out.println(Thread.currentThread() + <span class="hljs-string">&quot;消费&quot;</span> + number);
            condition.signalAll();
        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;<span class="hljs-keyword">finally</span> &#123;
            lock.unlock();
        &#125;

    &#125;
&#125;</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210415095629.png" srcset="/img/loading.gif"></p>
<h2 id="生成者和消费者3-0"><a href="#生成者和消费者3-0" class="headerlink" title="生成者和消费者3.0"></a>生成者和消费者3.0</h2><p>在concurrent包发布以前，在多线程环境下，我们每个程序员都必须自己去控制这些细节，尤其还要兼顾效率和线程安全，则这会给我们的程序带来不小的时间复杂度</p>
<p>现在我们使用新版的阻塞队列版生产者和消费者，使用：volatile、CAS、atomicInteger、BlockQueue、线程交互、原子引用</p>
<h5 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h5><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210415103425.png" srcset="/img/loading.gif"></p>
<p>设置开关，打开可以生产一个消费一个，关闭可以不再生产消费；</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Code18_ProdConsumerBlockingQueueDemo</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        <span class="hljs-comment">// 传入具体的实现类， ArrayBlockingQueue</span>
        MyResource myResource = <span class="hljs-keyword">new</span> MyResource(<span class="hljs-keyword">new</span> ArrayBlockingQueue&lt;String&gt;(<span class="hljs-number">10</span>));

        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 生产线程启动&quot;</span>);
            System.out.println(<span class="hljs-string">&quot;&quot;</span>);
            System.out.println(<span class="hljs-string">&quot;&quot;</span>);
            <span class="hljs-keyword">try</span> &#123;
                myResource.myProd();
                System.out.println(<span class="hljs-string">&quot;&quot;</span>);
                System.out.println(<span class="hljs-string">&quot;&quot;</span>);
            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
                e.printStackTrace();
            &#125;
        &#125;, <span class="hljs-string">&quot;prod&quot;</span>).start();


        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 消费线程启动&quot;</span>);

            <span class="hljs-keyword">try</span> &#123;
                myResource.myConsumer();
            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
                e.printStackTrace();
            &#125;
        &#125;, <span class="hljs-string">&quot;consumer&quot;</span>).start();

        <span class="hljs-comment">// 5秒后，停止生产和消费</span>
        <span class="hljs-keyword">try</span> &#123;
            TimeUnit.SECONDS.sleep(<span class="hljs-number">5</span>);
        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;

        System.out.println(<span class="hljs-string">&quot;&quot;</span>);
        System.out.println(<span class="hljs-string">&quot;&quot;</span>);
        System.out.println(<span class="hljs-string">&quot;5秒中后，生产和消费线程停止，线程结束&quot;</span>);
        myResource.stop();
    &#125;
&#125;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyResource</span> </span>&#123;
    <span class="hljs-comment">// 默认开启，进行生产消费</span>
    <span class="hljs-comment">// 这里用到了volatile是为了保持数据的可见性，也就是当FLAG修改时，要马上通知其它线程进行修改</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> FLAG = <span class="hljs-keyword">true</span>;
    <span class="hljs-comment">// 使用原子包装类，而不用number++</span>
    <span class="hljs-keyword">private</span> AtomicInteger atomicInteger = <span class="hljs-keyword">new</span> AtomicInteger();

    <span class="hljs-comment">// 这里不能为了满足条件，而实例化一个具体的SynchronousBlockingQueue</span>
    BlockingQueue&lt;String&gt; blockingQueue = <span class="hljs-keyword">null</span>;

    <span class="hljs-comment">// 而应该采用依赖注入里面的，构造注入方法传入</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyResource</span><span class="hljs-params">(BlockingQueue&lt;String&gt; blockingQueue)</span></span>&#123;
        <span class="hljs-keyword">this</span>.blockingQueue = blockingQueue;
        <span class="hljs-comment">// 查询出传入的class是什么</span>
        System.out.println(blockingQueue.getClass().getName());
    &#125;
    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 生产</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">myProd</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;
        String data = <span class="hljs-keyword">null</span>;
        <span class="hljs-keyword">boolean</span> retValue;
        <span class="hljs-comment">// 多线程环境的判断，一定要使用while进行，防止出现虚假唤醒</span>
        <span class="hljs-comment">// 当FLAG为true的时候，开始生产</span>
        <span class="hljs-keyword">while</span>(FLAG) &#123;
            data = atomicInteger.incrementAndGet() + <span class="hljs-string">&quot;&quot;</span>;

            <span class="hljs-comment">// 2秒存入1个data</span>
            retValue = blockingQueue.offer(data, <span class="hljs-number">2L</span>, TimeUnit.SECONDS);
            <span class="hljs-keyword">if</span>(retValue) &#123;
                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 插入队列:&quot;</span> + data  + <span class="hljs-string">&quot;成功&quot;</span> );
            &#125; <span class="hljs-keyword">else</span> &#123;
                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 插入队列:&quot;</span> + data  + <span class="hljs-string">&quot;失败&quot;</span> );
            &#125;

            <span class="hljs-keyword">try</span> &#123;
                TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);
            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;

        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 停止生产，表示FLAG=false，生产介绍&quot;</span>);
    &#125;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 消费</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">myConsumer</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;
        String retValue;
        <span class="hljs-comment">// 多线程环境的判断，一定要使用while进行，防止出现虚假唤醒</span>
        <span class="hljs-comment">// 当FLAG为true的时候，开始生产</span>
        <span class="hljs-keyword">while</span>(FLAG) &#123;
            <span class="hljs-comment">// 2秒取出1个data</span>
            retValue = blockingQueue.poll(<span class="hljs-number">2L</span>, TimeUnit.SECONDS);
            <span class="hljs-keyword">if</span>(retValue != <span class="hljs-keyword">null</span> &amp;&amp; retValue != <span class="hljs-string">&quot;&quot;</span>) &#123;
                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 消费队列:&quot;</span> + retValue  + <span class="hljs-string">&quot;成功&quot;</span> );
            &#125; <span class="hljs-keyword">else</span> &#123;
                FLAG = <span class="hljs-keyword">false</span>;
                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 消费失败，队列中已为空，退出&quot;</span> );

                <span class="hljs-comment">// 退出消费队列</span>
                <span class="hljs-keyword">return</span>;
            &#125;
        &#125;
    &#125;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 停止生产的判断</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">this</span>.FLAG = <span class="hljs-keyword">false</span>;
    &#125;
&#125;</code></pre></div>



<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210415105340.png" srcset="/img/loading.gif"></p>
<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><h2 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h2><p>获取多线程的方法，我们都知道有三种，还有一种是实现Callable接口</p>
<ul>
<li>实现Runnable接口</li>
<li>实现Callable接口</li>
<li>实例化Thread类</li>
<li>使用线程池获取</li>
</ul>
<h2 id="Callable接口"><a href="#Callable接口" class="headerlink" title="Callable接口"></a>Callable接口</h2><p>Callable接口，是一种让线程执行完成后，能够返回结果的</p>
<p>在说到Callable接口的时候，我们不得不提到 <strong>Runnable接口</strong> </p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 实现Runnable接口</span>
<span class="hljs-comment"> */</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;

    &#125;
&#125;</code></pre></div>

<p>我们知道，实现Runnable接口的时候，需要 <strong>重写run方法</strong> ，也就是线程在启动的时候，会 <strong>自动调用</strong> 的方法</p>
<p>同理，我们实现Callable接口，也需要 <strong>实现call方法</strong> ，但是这个时候我们还需要 <strong>有返回值</strong> ，这个Callable接口的应用场景一般就在于批处理业务，比如转账的时候，需要给一会返回结果的状态码回来，代表本次操作成功还是失败</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * Callable有返回值</span>
<span class="hljs-comment"> * 批量处理的时候，需要带返回值的接口（例如支付失败的时候，需要返回错误状态）</span>
<span class="hljs-comment"> */</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Callable</span>&lt;<span class="hljs-title">Integer</span>&gt; </span>&#123;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        System.out.println(<span class="hljs-string">&quot;come in Callable&quot;</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-number">1024</span>;
    &#125;
&#125;</code></pre></div>

<p>最后我们需要做的就是通过Thread线程， 将MyThread2实现Callable接口的类包装起来</p>
<p>这里需要用到的是 <strong>FutureTask类</strong> ，他 <strong>实现了Runnable接口</strong> ，并且还需要传递一个实现Callable接口的类作为 <strong>构造函数</strong> </p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// FutureTask：实现了Runnable接口，构造函数又需要传入 Callable接口</span>
<span class="hljs-comment">// 这里通过了FutureTask接触了Callable接口</span>
FutureTask&lt;Integer&gt; futureTask = <span class="hljs-keyword">new</span> FutureTask&lt;&gt;(<span class="hljs-keyword">new</span> MyThread2());</code></pre></div>

<p>然后在用Thread进行实例化，传入实现Runnabnle接口的FutureTask的类</p>
<div class="hljs"><pre><code class="hljs java">Thread t1 = <span class="hljs-keyword">new</span> Thread(futureTask, <span class="hljs-string">&quot;aaa&quot;</span>);
t1.start();</code></pre></div>

<p>最后通过 futureTask.get() 获取到返回值</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// 输出FutureTask的返回值</span>
System.out.println(<span class="hljs-string">&quot;result FutureTask &quot;</span> + futureTask.get());</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210415110635.png" srcset="/img/loading.gif"></p>
<p>这就相当于原来我们的方式是main方法一条龙，后面在引入Callable后，对于执行比较久的线程，可以 <strong>单独新开一个线程</strong> 进行执行，最后在进行 <strong>汇总输出</strong> </p>
<p>最后需要注意的是 要求获得Callable线程的计算结果，如果没有计算完成就要去强求，会 <strong>导致阻塞</strong> ，直到计算完成</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210415112328.png" srcset="/img/loading.gif"></p>
<p>也就是说 futureTask.get() 需要 <strong>放在最后执行</strong> ，这样 <strong>不会导致主线程阻塞</strong> </p>
<p>也可以使用下面算法，使用类似于自旋锁的方式来进行判断是否运行完毕</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// 判断futureTask是否计算完成</span>
<span class="hljs-keyword">while</span>(!futureTask.isDone()) &#123;

&#125;</code></pre></div>

<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>多个线程执行 一个FutureTask的时候，只会 <strong>计算一次</strong> </p>
<div class="hljs"><pre><code class="hljs java">FutureTask futureTask = <span class="hljs-keyword">new</span> FutureTask(<span class="hljs-keyword">new</span> CallableThread());
Thread t1 = <span class="hljs-keyword">new</span> Thread(futureTask, <span class="hljs-string">&quot;aaa&quot;</span>);
Thread t2 = <span class="hljs-keyword">new</span> Thread(futureTask, <span class="hljs-string">&quot;bbb&quot;</span>);
t1.start();
t2.start();</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210415112613.png" srcset="/img/loading.gif"></p>
<p>如果我们要两个线程同时计算任务的话，那么需要这样写，需要 <strong>定义两个futureTask</strong> </p>
<div class="hljs"><pre><code class="hljs java">FutureTask futureTask = <span class="hljs-keyword">new</span> FutureTask(<span class="hljs-keyword">new</span> CallableThread());
FutureTask futureTaskOther = <span class="hljs-keyword">new</span> FutureTask(<span class="hljs-keyword">new</span> CallableThread());
Thread t1 = <span class="hljs-keyword">new</span> Thread(futureTask, <span class="hljs-string">&quot;aaa&quot;</span>);
Thread t2 = <span class="hljs-keyword">new</span> Thread(futureTaskOther, <span class="hljs-string">&quot;bbb&quot;</span>);
t1.start();
t2.start();</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210415112745.png" srcset="/img/loading.gif"></p>
<h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><h3 id="为什么用线程池"><a href="#为什么用线程池" class="headerlink" title="为什么用线程池"></a>为什么用线程池</h3><p>线程池做的主要工作就是 <strong>控制运行的线程的数量</strong> ，处理过程中，将任务放入到队列中，然后线程创建后，启动这些任务，如果线程数量超过了最大数量的线程排队等候，等其它线程执行完毕，再从队列中取出任务来执行。</p>
<p>它的主要特点为： <strong>线程复用</strong> 、 <strong>控制最大并发数</strong> 、 <strong>管理线程</strong> </p>
<div class="hljs"><pre><code class="hljs java">Runtime.getRuntime().availableProcessors();
<span class="hljs-comment">// 查找线程数</span></code></pre></div>

<h3 id="线程池的好处"><a href="#线程池的好处" class="headerlink" title="线程池的好处"></a>线程池的好处</h3><p>多核处理的好处是： <strong>省略的上下文的切换开销</strong> </p>
<p>原来我们实例化对象的时候，是使用 new关键字进行创建，到了Spring后，我们学了IOC依赖注入，发现Spring帮我们将对象已经加载到了Spring容器中，只需要通过@Autowrite注解，就能够自动注入，从而使用</p>
<p>因此使用多线程有下列的好处</p>
<ul>
<li> <strong>降低资源消耗</strong> 。通过重复利用已创建的线程，降低线程创建和销毁造成的消耗</li>
<li> <strong>提高响应速度</strong> 。当任务到达时，任务可以不需要等到线程创建就立即执行</li>
<li> <strong>提高线程的可管理性</strong> 。线程是稀缺资源，如果无线创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控</li>
</ul>
<h3 id="架构说明"><a href="#架构说明" class="headerlink" title="架构说明"></a>架构说明</h3><p>Java中线程池是通过Executor框架实现的，该框架中用到了 <strong>Executor</strong> ， <strong>Executors（代表工具类）</strong> ， <strong>ExecutorService</strong> ， <strong>ThreadPoolExecutor</strong> 这几个类。</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210416100920.png" srcset="/img/loading.gif"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210416100937.png" srcset="/img/loading.gif"></p>
<h3 id="创建线程池"><a href="#创建线程池" class="headerlink" title="创建线程池"></a>创建线程池</h3><ul>
<li>Executors.newFixedThreadPool(int i) ： 创建一个 <strong>固定</strong> 拥有 i 个线程的线程池<ul>
<li>执行长期的任务，性能好很多</li>
<li>创建一个 <strong>定长线程池</strong> ，可控制线程数最大并发数，超出的线程会在队列中等待</li>
</ul>
</li>
<li>Executors.newSingleThreadExecutor：创建一个 <strong>只有1个线程</strong> 的 单线程池<ul>
<li>一个任务一个任务执行的场景</li>
<li>创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序执行</li>
</ul>
</li>
<li>Executors.newCacheThreadPool(); 创建一个 <strong>可扩容</strong> 的线程池<ul>
<li>执行很多短期异步的小程序或者负载教轻的服务器</li>
<li>创建一个可缓存线程池，如果线程长度超过处理需要，可灵活回收空闲线程，如无可回收，则新建新线程</li>
</ul>
</li>
<li>Executors.newScheduledThreadPool(int corePoolSize)：线程池支持 <strong>定时以及周期性执行</strong> 任务，创建一个corePoolSize为传入参数，最大线程数为整形的最大数的线程池</li>
</ul>
<p>具体使用，首先我们需要使用 <strong>Executors工具类，进行创建线程池</strong> ，这里创建了一个拥有5个线程的线程池</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// 一池5个处理线程（用池化技术，一定要记得关闭）</span>
ExecutorService threadPool = Executors.newFixedThreadPool(<span class="hljs-number">5</span>);

<span class="hljs-comment">// 创建一个只有一个线程的线程池</span>
ExecutorService threadPool = Executors.newSingleThreadExecutor();

<span class="hljs-comment">// 创建一个拥有N个线程的线程池，根据调度创建合适的线程</span>
ExecutorService threadPool = Executors.newCacheThreadPool();</code></pre></div>

<p>然后我们执行下面的的应用场景</p>
<div class="hljs"><pre><code class="hljs js">模拟<span class="hljs-number">10</span>个用户来办理业务，每个用户就是一个来自外部请求线程</code></pre></div>

<p>我们需要使用 threadPool.execute执行业务，execute需要传入一个实现了 <strong>Runnable接口</strong> 的线程</p>
<div class="hljs"><pre><code class="hljs java">threadPool.execute(() -&gt; &#123;
  System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 给用户办理业务&quot;</span>);
&#125;);</code></pre></div>

<p>然后我们使用完毕后关闭线程池</p>
<div class="hljs"><pre><code class="hljs java">threadPool.shutdown();</code></pre></div>

<p>完整代码为：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">create</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-comment">// Array  Arrays(辅助工具类)</span>
    <span class="hljs-comment">// Collection Collections(辅助工具类)</span>
    <span class="hljs-comment">// Executor Executors(辅助工具类)</span>

    <span class="hljs-comment">// 一池5个处理线程（用池化技术，一定要记得关闭）</span>
    ExecutorService threadPool = Executors.newFixedThreadPool(<span class="hljs-number">5</span>);

    <span class="hljs-comment">// 模拟10个用户来办理业务，每个用户就是一个来自外部请求线程</span>
    <span class="hljs-keyword">try</span> &#123;

        <span class="hljs-comment">// 循环十次，模拟业务办理，让5个线程处理这10个请求</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;
            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> tempInt = i;
            threadPool.execute(() -&gt; &#123;
                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 给用户:&quot;</span> + tempInt + <span class="hljs-string">&quot; 办理业务&quot;</span>);
            &#125;);
        &#125;
    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
        e.printStackTrace();
    &#125; <span class="hljs-keyword">finally</span> &#123;
        threadPool.shutdown();
    &#125;
&#125;</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210416102056.png" srcset="/img/loading.gif"></p>
<h3 id="创建周期性执行任务的线程池"><a href="#创建周期性执行任务的线程池" class="headerlink" title="创建周期性执行任务的线程池"></a>创建周期性执行任务的线程池</h3><p>Executors.newScheduledThreadPool(int corePoolSize)：</p>
<p><strong>线程池支持定时以及周期性执行任务，创建一个corePoolSize为传入参数，最大线程数为整形的最大数的线程池</strong></p>
<p>底层使用 ScheduledThreadPoolExecutor 来实现, ScheduledThreadPoolExecutor 为ThreadPoolExecutor子类</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ScheduledExecutorService <span class="hljs-title">newScheduledThreadPool</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize)</span> </span>&#123;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);
&#125;</code></pre></div>

<p>点进查看</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ScheduledThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize)</span> </span>&#123;
    <span class="hljs-keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="hljs-number">0</span>, NANOSECONDS,
          <span class="hljs-keyword">new</span> DelayedWorkQueue());
&#125;</code></pre></div>

<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ScheduledThreadPoolExecutor</span></span>
<span class="hljs-class">        <span class="hljs-keyword">extends</span> <span class="hljs-title">ThreadPoolExecutor</span></span>
<span class="hljs-class">        <span class="hljs-keyword">implements</span> <span class="hljs-title">ScheduledExecutorService</span> </span>&#123;
  ....
&#125;</code></pre></div>

<h4 id="执行方法"><a href="#执行方法" class="headerlink" title="执行方法"></a>执行方法</h4><div class="hljs"><pre><code class="hljs java"> <span class="hljs-comment">/**</span>
<span class="hljs-comment">  * <span class="hljs-doctag">@throws</span> RejectedExecutionException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span>
<span class="hljs-comment">  * <span class="hljs-doctag">@throws</span> NullPointerException       &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span>
<span class="hljs-comment">  * command：执行的任务 Callable或Runnable接口实现类</span>
<span class="hljs-comment">* delay：延时执行任务的时间</span>
<span class="hljs-comment">* unit：延迟时间单位</span>
<span class="hljs-comment">  */</span>
 <span class="hljs-keyword">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable command,
                                    <span class="hljs-keyword">long</span> delay,
                                    TimeUnit unit)
 <span class="hljs-comment">/**</span>
<span class="hljs-comment">  * <span class="hljs-doctag">@throws</span> RejectedExecutionException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span>
<span class="hljs-comment">  * <span class="hljs-doctag">@throws</span> NullPointerException       &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span>
<span class="hljs-comment">  * <span class="hljs-doctag">@throws</span> IllegalArgumentException   &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span>
<span class="hljs-comment">  * command：执行的任务 Callable或Runnable接口实现类</span>
<span class="hljs-comment">* initialDelay 第一次执行任务延迟时间</span>
<span class="hljs-comment">* period 连续执行任务之间的周期，从上一个任务开始执行时计算延迟多少开始执行下一个任务，但是还会等上一个任务结束之后。</span>
<span class="hljs-comment">* unit：延迟时间单位</span>
<span class="hljs-comment">  */</span>
 <span class="hljs-keyword">public</span> ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,
                                               <span class="hljs-keyword">long</span> initialDelay,
                                               <span class="hljs-keyword">long</span> period,
                                               TimeUnit unit)
 <span class="hljs-comment">/**</span>
<span class="hljs-comment">  * <span class="hljs-doctag">@throws</span> RejectedExecutionException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span>
<span class="hljs-comment">  * <span class="hljs-doctag">@throws</span> NullPointerException       &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span>
<span class="hljs-comment">  * <span class="hljs-doctag">@throws</span> IllegalArgumentException   &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span>
<span class="hljs-comment">  * command：执行的任务 Callable或Runnable接口实现类</span>
<span class="hljs-comment">* initialDelay 第一次执行任务延迟时间</span>
<span class="hljs-comment">* delay：连续执行任务之间的周期，从上一个任务全部执行完成时计算延迟多少开始执行下一个任务</span>
<span class="hljs-comment">* unit：延迟时间单位</span>
<span class="hljs-comment">  */</span>
 <span class="hljs-keyword">public</span> ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command,
                                                  <span class="hljs-keyword">long</span> initialDelay,
                                                  <span class="hljs-keyword">long</span> delay,
                                                  TimeUnit unit)</code></pre></div>

<h2 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h2><p>我们通过查看源码，点击了Executors.newSingleThreadExecutor 和 Executors.newFixedThreadPool能够发现底层都是使用了 <strong>ThreadPoolExecutor</strong> </p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210416103013.png" srcset="/img/loading.gif"></p>
<p>我们可以看到线程池的内部，还使用到了 <strong>LinkedBlockingQueue</strong>  链表阻塞队列</p>
<p>同时在查看Executors.newCacheThreadPool 看到底层用的是  <strong>SynchronousBlockingQueue</strong> 阻塞队列</p>
<p>最后查看一下，完整的三个创建线程的方法</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210416103304.png" srcset="/img/loading.gif"></p>
<h2 id="线程池的重要参数"><a href="#线程池的重要参数" class="headerlink" title="线程池的重要参数"></a>线程池的重要参数</h2><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210416103728.png" srcset="/img/loading.gif"></p>
<p>线程池在创建的时候，一共有 <strong>7大参数</strong> </p>
<ul>
<li><p>corePoolSize： <strong>核心线程数</strong> ，线程池中的常驻核心线程数</p>
<ul>
<li>在创建线程池后，当有请求任务来之后，就会安排池中的线程去执行请求任务，近似理解为今日当值线程</li>
<li>当线程池中的线程数目达到corePoolSize后，就会把到达的 <strong>队列放到缓存队列</strong> 中</li>
</ul>
</li>
<li><p>maximumPoolSize：线程池能够容纳同时执行的 <strong>最大线程数</strong> ，此值必须大于等于1、</p>
<ul>
<li>相当有扩容后的线程数，这个线程池能容纳的最多线程数</li>
</ul>
</li>
<li><p>keepAliveTime：多余的空闲线程存活时间</p>
<ul>
<li>当线程池数量超过corePoolSize时，当空闲时间达到keepAliveTime值时，多余的空闲线程会被 <strong>销毁</strong> ，直到只剩下corePoolSize个线程为止</li>
<li>默认情况下，只有当线程池中的线程数大于corePoolSize时，keepAliveTime才会起作用</li>
</ul>
</li>
<li><p>unit：keepAliveTime的单位</p>
</li>
<li><p>workQueue： <strong>任务队列，被提交的但未被执行的任务</strong> （类似于银行里面的候客区）</p>
<ul>
<li>LinkedBlockingQueue：链表阻塞队列</li>
<li>SynchronousBlockingQueue：同步阻塞队列</li>
</ul>
</li>
<li><p>threadFactory：表示生成线程池中工作线程的 <strong>线程工厂</strong> ，用于创建线程池 一般用默认即可</p>
</li>
<li><p>handler：拒绝策略，表示当 <strong>队列满了并且工作线程大于线程池的最大线程数</strong> （maximumPoolSize3）时，如何来拒绝请求执行的Runnable的策略</p>
<p>当营业窗口最大值和阻塞队列中都满了时候，就需要设置拒绝策略</p>
</li>
</ul>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210416105326.png" srcset="/img/loading.gif"></p>
<h2 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h2><p>以下所有拒绝策略都实现了 <strong>RejectedExecutionHandler</strong> 接口</p>
<ul>
<li>AbortPolicy：默认，直接抛出RejectedExcutionException异常，阻止系统正常运行</li>
<li>DiscardPolicy：直接 <strong>丢弃</strong> 任务，不予任何处理也不抛出异常，如果运行任务丢失，这是一种好方案</li>
<li>CallerRunsPolicy：该策略既不会抛弃任务，也不会抛出异常，而是将某些任务 <strong>回退</strong> 到调用者</li>
<li>DiscardOldestPolicy： <strong>抛弃</strong> 队列中 <strong>等待最久</strong> 的任务，然后把当前任务加入队列中尝试再次提交当前任务</li>
</ul>
<p>ThreadPoolExecutor中源代码：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> RejectedExecutionHandler defaultHandler =
    <span class="hljs-keyword">new</span> AbortPolicy();</code></pre></div>



<h2 id="线程池底层工作原理"><a href="#线程池底层工作原理" class="headerlink" title="线程池底层工作原理"></a>线程池底层工作原理</h2><h3 id="线程池运行架构图"><a href="#线程池运行架构图" class="headerlink" title="线程池运行架构图"></a>线程池运行架构图</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210416110149.png" srcset="/img/loading.gif"></p>
<p>文字说明</p>
<ol>
<li>在创建了线程池后，等待提交过来的 <strong>任务请求</strong> </li>
<li>当调用execute()方法添加一个请求任务时，线程池会做出如下判断<ol>
<li>如果正在运行的线程池数量小于corePoolSize，那么马上创建线程运行这个任务</li>
<li>如果正在运行的线程数量大于或等于corePoolSize，那么将这个任务 <strong>放入队列</strong> </li>
<li>如果这时候 <strong>队列满了</strong> ，并且正在运行的线程数量还 <strong>小于maximumPoolSize</strong> ，那么还是创建非核心线程like运行这个任务；</li>
<li>如果队列满了并且正在运行的线程数量 <strong>大于或等于maximumPoolSize</strong> ，那么线程池会启动 <strong>饱和拒绝策略</strong> 来执行</li>
</ol>
</li>
<li>当一个线程完成任务时，它会从队列中取下一个任务来执行</li>
<li>当一个线程无事可做操作一定的时间 <strong>(keepAliveTime)</strong> 时，线程池会判断：<ol>
<li>如果当前运行的线程数大于corePoolSize，那么这个线程就 <strong>被停掉</strong> </li>
<li>所以线程池的所有任务完成后，它会最终 <strong>收缩到corePoolSize的大小</strong> </li>
</ol>
</li>
</ol>
<p>以顾客去银行办理业务为例，谈谈线程池的底层工作原理</p>
<ol>
<li>最开始假设来了两个顾客，因为corePoolSize为2，因此这两个顾客直接能够去窗口办理</li>
<li>后面又来了三个顾客，因为corePool已经被顾客占用了，因此只有去候客区，也就是阻塞队列中等待</li>
<li>后面的人又陆陆续续来了，候客区可能不够用了，因此需要申请增加处理请求的窗口，这里的窗口指的是线程池中的线程数，以此来解决线程不够用的问题</li>
<li>假设受理窗口已经达到最大数，并且请求数还是不断递增，此时候客区和线程池都已经满了，为了防止大量请求冲垮线程池，已经需要开启拒绝策略</li>
<li>临时增加的线程会因为超过了最大存活时间，就会销毁，最后从最大数削减到核心数</li>
</ol>
<h2 id="为什么不用默认创建的线程池？"><a href="#为什么不用默认创建的线程池？" class="headerlink" title="为什么不用默认创建的线程池？"></a>为什么不用默认创建的线程池？</h2><p>线程池创建的方法有： <strong>固定数的</strong> ， <strong>单一的</strong> ， <strong>可变的</strong> ，那么在实际开发中，应该使用哪个？</p>
<p>我们一个都不用，在生产环境中是使用自己 <strong>自定义的</strong> </p>
<p>为什么不用 Executors 中JDK提供的？</p>
<p>根据 <strong>阿里巴巴手册</strong> ：并发控制这章</p>
<ul>
<li>线程资源必须通过线程池提供， <strong>不允许在应用中自行显式创建线程</strong> <ul>
<li>使用线程池的好处是 <strong>减少</strong> 在创建和销毁线程上所消耗的时间以及系统资源的 <strong>开销</strong> ，解决资源不足的问题，如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题</li>
</ul>
</li>
<li>线程池 <strong>不允许使用Executors去创建</strong> ，而是通过  <strong>ThreadPoolExecutor</strong>  的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险<ul>
<li>Executors返回的线程池对象弊端如下：<ul>
<li>FixedThreadPool和SingleThreadPool：<ul>
<li>运行的请求队列长度为：Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 <strong>OOM</strong> </li>
</ul>
</li>
<li>CacheThreadPool和ScheduledThreadPool<ul>
<li>运行的请求队列长度为：Integer.MAX_VALUE，可能会堆积大量的请求，从而导致OOM</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="手写线程池"><a href="#手写线程池" class="headerlink" title="手写线程池"></a>手写线程池</h2><h3 id="采用默认拒绝策略"><a href="#采用默认拒绝策略" class="headerlink" title="采用默认拒绝策略"></a>采用默认拒绝策略</h3><p>从上面我们知道，因为默认的Executors创建的线程池，底层都是使用LinkBlockingQueue作为阻塞队列的，而LinkBlockingQueue虽然是有界的，但是它的界限是 Integer.MAX_VALUE 大概有20多亿，可以相当是无界的了，因此我们要使用ThreadPoolExecutor自己 <strong>手动创建线程池，然后指定阻塞队列的大小</strong> </p>
<p>下面我们创建了一个 核心线程数为2，最大线程数为5，并且阻塞队列数为3的线程池</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// 手写线程池</span>
<span class="hljs-keyword">final</span> Integer corePoolSize = <span class="hljs-number">2</span>;
<span class="hljs-keyword">final</span> Integer maximumPoolSize = <span class="hljs-number">5</span>;
<span class="hljs-keyword">final</span> Long keepAliveTime = <span class="hljs-number">1L</span>;
ExecutorService threadPool = <span class="hljs-keyword">new</span> ThreadPoolExecutor(
        corePoolSize,
        maximumPoolSize,
        keepAliveTime,
        TimeUnit.SECONDS,
        <span class="hljs-keyword">new</span> LinkedBlockingDeque&lt;Runnable&gt;(<span class="hljs-number">3</span>),
        Executors.defaultThreadFactory(),
        <span class="hljs-keyword">new</span> ThreadPoolExecutor.AbortPolicy()
);</code></pre></div>

<p>然后使用for循环，模拟15个用户来进行请求</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;

    <span class="hljs-comment">// 循环十次，模拟业务办理，让5个线程处理这15个请求</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">15</span>; i++) &#123;
        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> tempInt = i;
        threadPool.execute(() -&gt; &#123;
            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 给用户:&quot;</span> + tempInt + <span class="hljs-string">&quot; 办理业务&quot;</span>);
        &#125;);
    &#125;
&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
    e.printStackTrace();
&#125; <span class="hljs-keyword">finally</span> &#123;
    threadPool.shutdown();
&#125;</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210416141103.png" srcset="/img/loading.gif"></p>
<p>这是因为触发了拒绝策略，而我们设置的拒绝策略是默认的AbortPolicy，也就是抛异常的</p>
<p>触发条件是， <strong>请求的线程</strong> 大于 <strong>阻塞队列大小 + 最大线程数 = 8</strong>  的时候，也就是说第9个线程来获取线程池中的线程时，就会抛出异常从而报错退出。</p>
<h3 id="采用CallerRunsPolicy拒绝策略"><a href="#采用CallerRunsPolicy拒绝策略" class="headerlink" title="采用CallerRunsPolicy拒绝策略"></a>采用CallerRunsPolicy拒绝策略</h3><p>当我们更好其它的拒绝策略时，采用CallerRunsPolicy拒绝策略，也称为 <strong>回退策略</strong> ，就是把任务丢回原来的请求开启线程着，我们看运行结果</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210416141242.png" srcset="/img/loading.gif"></p>
<p>我们发现，输出的结果里面出现了main线程，因为线程池出发了拒绝策略，把任务回退到main线程，然后main线程对任务进行处理</p>
<h3 id="采用-DiscardPolicy-拒绝策略"><a href="#采用-DiscardPolicy-拒绝策略" class="headerlink" title="采用 DiscardPolicy 拒绝策略"></a>采用 DiscardPolicy 拒绝策略</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210416141344.png" srcset="/img/loading.gif"></p>
<p>采用DiscardPolicy拒绝策略会，线程池会自动把后面的任务都直接丢弃，也不报异常，当任务无关紧要的时候，可以采用这个方式</p>
<h3 id="采用DiscardOldestPolicy拒绝策略"><a href="#采用DiscardOldestPolicy拒绝策略" class="headerlink" title="采用DiscardOldestPolicy拒绝策略"></a>采用DiscardOldestPolicy拒绝策略</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210416141411.png" srcset="/img/loading.gif"></p>
<p>这个策略和刚刚差不多，会把 <strong>最久</strong> 的队列中的任务替换掉</p>
<h2 id="线程池的合理参数"><a href="#线程池的合理参数" class="headerlink" title="线程池的合理参数"></a>线程池的合理参数</h2><p>生产环境中如何配置 corePoolSize 和 maximumPoolSize</p>
<p>这个是根据具体业务来配置的，分为CPU密集型和IO密集型</p>
<ul>
<li> <strong>CPU密集型</strong> </li>
</ul>
<p>CPU密集的意思是该任务需要大量的运算，而没有阻塞，CPU一直全速运行</p>
<p>CPU密集任务只有在真正的多核CPU上才可能得到加速（通过多线程）</p>
<p>而在单核CPU上，无论你开几个模拟的多线程该任务都不可能得到加速，因为CPU总的运算能力就那些</p>
<p>CPU密集型任务配置尽可能少的线程数量：</p>
<p>一般公式： <strong>CPU核数 + 1个线程数</strong> </p>
<ul>
<li> <strong>IO密集型</strong> </li>
</ul>
<p>由于IO密集型任务线程并不是一直在执行任务，则可能多的线程，如 CPU核数 * 2</p>
<p>IO密集型，即该任务需要大量的IO操作，即大量的阻塞</p>
<p>在单线程上运行IO密集型的任务会导致浪费大量的CPU运算能力花费在等待上</p>
<p>所以IO密集型任务中使用多线程可以大大的加速程序的运行，即使在单核CPU上，这种加速主要就是利用了被浪费掉的阻塞时间。</p>
<p>IO密集时，大部分线程都被阻塞，故需要多配置线程数：</p>
<p>参考公式： <strong>CPU核数 / (1 - 阻塞系数) 阻塞系数在0.8 ~ 0.9左右</strong> </p>
<p>例如：8核CPU：8/ (1 - 0.9) = 80个线程数</p>
<h1 id="死锁编码及定位分析"><a href="#死锁编码及定位分析" class="headerlink" title="死锁编码及定位分析"></a>死锁编码及定位分析</h1><h2 id="概念-8"><a href="#概念-8" class="headerlink" title="概念"></a>概念</h2><p>死锁是指两个或多个以上的进程在执行过程中，因争夺资源而造成一种 <strong>互相等待</strong> 的现象，若无外力干涉那他们都将无法推进下去。如果资源充足，进程的资源请求都能够得到满足，死锁出现的可能性就很低，否则就会因争夺有限的资源而陷入死锁。</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210416142259.png" srcset="/img/loading.gif"></p>
<h2 id="死锁产生的四个必要条件"><a href="#死锁产生的四个必要条件" class="headerlink" title="死锁产生的四个必要条件"></a>死锁产生的四个必要条件</h2><ul>
<li><strong>互斥</strong> <ul>
<li>解决方法：把互斥的共享资源封装成可同时访问</li>
</ul>
</li>
<li><strong>占有且等待</strong> <ul>
<li>解决方法：进程请求资源时，要求它不占有任何其它资源，也就是它必须一次性申请到所有的资源，这种方式会导致资源效率低。</li>
</ul>
</li>
<li><strong>非抢占式</strong> <ul>
<li>解决方法：如果进程不能立即分配资源，要求它不占有任何其他资源，也就是只能够同时获得所有需要资源时，才执行分配操作</li>
</ul>
</li>
<li><strong>循环等待</strong> <ul>
<li>解决方法：对资源进行排序，要求进程按顺序请求资源。</li>
</ul>
</li>
</ul>
<h2 id="死锁代码"><a href="#死锁代码" class="headerlink" title="死锁代码"></a>死锁代码</h2><p>我们创建了一个资源类，然后让两个线程分别持有自己的锁，同时在尝试获取别人的，就会出现死锁现象</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Code21_DeadLockDemo</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        String lockA = <span class="hljs-string">&quot;lockA&quot;</span>;
        String lockB = <span class="hljs-string">&quot;lockB&quot;</span>;

        <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> HoldLockThread(lockA, lockB), <span class="hljs-string">&quot;t1&quot;</span>).start();

        <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> HoldLockThread(lockB, lockA), <span class="hljs-string">&quot;t2&quot;</span>).start();
    &#125;
&#125;
<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 资源类</span>
<span class="hljs-comment"> */</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HoldLockThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;

    <span class="hljs-keyword">private</span> String lockA;
    <span class="hljs-keyword">private</span> String lockB;

    <span class="hljs-comment">// 持有自己的锁，还想得到别人的锁</span>

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HoldLockThread</span><span class="hljs-params">(String lockA, String lockB)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.lockA = lockA;
        <span class="hljs-keyword">this</span>.lockB = lockB;
    &#125;


    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">synchronized</span> (lockA) &#123;
            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 自己持有&quot;</span> + lockA + <span class="hljs-string">&quot;\t 尝试获取：&quot;</span> + lockB);

            <span class="hljs-keyword">try</span> &#123;
                TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);
            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;

            <span class="hljs-keyword">synchronized</span> (lockB) &#123;
                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 自己持有&quot;</span> + lockB + <span class="hljs-string">&quot;\t 尝试获取：&quot;</span> + lockA);
            &#125;
        &#125;
    &#125;
&#125;</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210416142630.png" srcset="/img/loading.gif"></p>
<h2 id="如何排查死锁"><a href="#如何排查死锁" class="headerlink" title="如何排查死锁"></a>如何排查死锁</h2><p>当我们出现死锁的时候，首先需要使用jps命令查看运行的程序</p>
<ul>
<li><p>jps - l</p>
<p>我们能看到DeadLockDemo这个类，一直在运行</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210416142816.png" srcset="/img/loading.gif"></p>
</li>
</ul>
<p>在使用jstack查看堆栈信息</p>
<ul>
<li><p>jstack  xxxx   # 后面参数是 jps输出的该类的pid</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210416142928.png" srcset="/img/loading.gif"></p>
</li>
</ul>
<p>最终结果：</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210416142958.png" srcset="/img/loading.gif"></p>
<p>定位</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210416143945.png" srcset="/img/loading.gif"></p>
<h1 id="JVM体系结构"><a href="#JVM体系结构" class="headerlink" title="JVM体系结构"></a>JVM体系结构</h1><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210416144354.png" srcset="/img/loading.gif"></p>
<p>java gc 主要回收的是 <strong>方法区</strong>  和 <strong>堆</strong> 中的内容</p>
<p>灰色线程私有，几乎不存在垃圾回收</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210416144526.png" srcset="/img/loading.gif"></p>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><ul>
<li>类加载器是什么</li>
<li>双亲委派机制</li>
<li>Java类加载的沙箱安全机制</li>
</ul>
<h2 id="常见的垃圾回收算法"><a href="#常见的垃圾回收算法" class="headerlink" title="常见的垃圾回收算法"></a>常见的垃圾回收算法</h2><ul>
<li><p>引用计数</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210416144610.png" srcset="/img/loading.gif"></p>
</li>
</ul>
<p>在双端循环，互相引用的时候，容易报错，目前很少使用这种方式了</p>
<ul>
<li><p>复制</p>
<p>复制算法在年轻代的时候，进行使用，复制时候有交换</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210416144654.png" srcset="/img/loading.gif"></p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95/JUC/12_JVM/JVM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/images/image-20200318184820787.png" srcset="/img/loading.gif"></p>
</li>
</ul>
<p>优点：没有产生内存碎片</p>
<ul>
<li><p>标记清除</p>
<p>先标记，后清除，缺点是会产生内存碎片，用于老年代多一些</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210416144748.png" srcset="/img/loading.gif"></p>
</li>
<li><p>标记整理</p>
<p>标记清除整理</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210416144820.png" srcset="/img/loading.gif"></p>
<p>但是需要付出代价，因为移动对象需要成本</p>
</li>
</ul>
<h1 id="JVM面试汇总"><a href="#JVM面试汇总" class="headerlink" title="JVM面试汇总"></a>JVM面试汇总</h1><h2 id="JVM垃圾回收的时候如何确定垃圾？是否知道什么是GC-Roots"><a href="#JVM垃圾回收的时候如何确定垃圾？是否知道什么是GC-Roots" class="headerlink" title="JVM垃圾回收的时候如何确定垃圾？是否知道什么是GC Roots"></a>JVM垃圾回收的时候如何确定垃圾？是否知道什么是GC Roots</h2><h3 id="什么是垃圾"><a href="#什么是垃圾" class="headerlink" title="什么是垃圾"></a>什么是垃圾</h3><p>简单来说就是 <strong>内存中已经不再被使用的空间就是垃圾</strong> </p>
<h3 id="如何判断一个对象是否可以被回收"><a href="#如何判断一个对象是否可以被回收" class="headerlink" title="如何判断一个对象是否可以被回收"></a>如何判断一个对象是否可以被回收</h3><h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><p>Java中，引用和对象是有关联的。如果要操作对象则必须用引用进行。</p>
<p>因此，很显然一个简单的办法就是通过引用计数来判断一个对象是否可以回收。简单说，给对象中添加一个引用计数器</p>
<p>每当有一个地方引用它，计数器值加1</p>
<p>每当有一个引用失效，计数器值减1</p>
<p>任何时刻计数器值为零的对象就是不可能再被使用的，那么这个对象就是可回收对象。</p>
<p>那么为什么主流的Java虚拟机里面都没有选用这个方法呢？其中最主要的原因是它很难解决对象之间相互循环引用的问题。 <strong>循环互相引用问题</strong> </p>
<p>该算法存在但目前无人用了，解决不了 <strong>循环引用</strong> 的问题，了解即可。</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210416150640.png" srcset="/img/loading.gif"></p>
<h4 id="枚举根节点做可达性分析"><a href="#枚举根节点做可达性分析" class="headerlink" title="枚举根节点做可达性分析"></a>枚举根节点做可达性分析</h4><p>为了解决 <strong>循环引用</strong> 的问题</p>
<p>根搜索路径算法</p>
<p>为了解决引用计数法的循环引用个问题，Java使用了可达性分析的方法：</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210416150837.png" srcset="/img/loading.gif"></p>
<p>所谓 <strong>GC Roots</strong> 或者说 <strong>Tracing Roots</strong> 的“根集合” 就是一组必须活跃的引用(上图对象C没有被GC可达)</p>
<p>基本思路就是 <strong>通过一系列名为 GC Roots的对象作为起始点</strong> ，从这个被称为GC Roots的对象开始向下搜索，如果一个对象到GC Roots没有任何引用链相连，则说明此对象不可用。也即给定一个集合的引用作为根出发，通过引用关系 <strong>遍历对象图</strong> ，能被遍历到的（可到达的）对象就被判定为 <strong>存活</strong> ，没有被遍历到的对象就被判定为 <strong>死亡</strong> </p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210416151128.png" srcset="/img/loading.gif"></p>
<p>必须从GC Roots对象开始，这个类似于linux的 / 也就是根目录</p>
<p>蓝色部分是从GC Roots出发，能够循环可达</p>
<p>而白色部分，从GC Roots出发，无法到达</p>
<h4 id="一句话理解GC-Roots"><a href="#一句话理解GC-Roots" class="headerlink" title="一句话理解GC Roots"></a>一句话理解GC Roots</h4><p>假设我们现在有三个实体，分别是 人，狗，毛衣</p>
<p>然后他们之间的关系是：人 牵着 狗，狗穿着毛衣，他们之间是强连接的关系</p>
<p>有一天人消失了，只剩下狗狗 和 毛衣，这个时候，把人想象成 GC Roots，因为 人 和 狗之间失去了绳子连接，</p>
<p>那么狗可能被回收，也就是被警察抓起来，被送到流浪狗寄养所</p>
<p>假设狗和人有强连接的时候，狗狗就不会被当成是流浪狗</p>
<h4 id="那些对象可以当做GC-Roots"><a href="#那些对象可以当做GC-Roots" class="headerlink" title="那些对象可以当做GC Roots"></a>那些对象可以当做GC Roots</h4><ul>
<li>虚拟机栈（栈帧中的局部变量区，也叫做局部变量表）中的引用对象</li>
<li>方法区中的类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中的JNI（Native方法）的引用对象</li>
</ul>
<h4 id="代码说明"><a href="#代码说明" class="headerlink" title="代码说明"></a>代码说明</h4><div class="hljs"><pre><code class="hljs java">jpublic <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GCRootDemo</span> </span>&#123;


    <span class="hljs-comment">// 方法区中的类静态属性引用的对象</span>
    <span class="hljs-comment">// private static GCRootDemo2 t2;</span>

    <span class="hljs-comment">// 方法区中的常量引用，GC Roots 也会以这个为起点，进行遍历</span>
    <span class="hljs-comment">// private static final GCRootDemo3 t3 = new GCRootDemo3(8);</span>

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m1</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-comment">// 第一种，虚拟机栈中的引用对象</span>
        GCRootDemo t1 = <span class="hljs-keyword">new</span> GCRootDemo();
        System.gc();
        System.out.println(<span class="hljs-string">&quot;第一次GC完成&quot;</span>);
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        m1();
    &#125;
&#125;</code></pre></div>



<h2 id="JVM参数调优"><a href="#JVM参数调优" class="headerlink" title="JVM参数调优"></a>JVM参数调优</h2><h3 id="前言-2"><a href="#前言-2" class="headerlink" title="前言"></a>前言</h3><p>你说你做过JVM调优和参数配置，请问如何盘点查看 <strong>JVM系统默认值</strong> </p>
<p>使用jps和jinfo进行查看</p>
<div class="hljs"><pre><code class="hljs diff"><span class="hljs-deletion">-Xms：初始堆空间</span>
<span class="hljs-deletion">-Xmx：堆最大值</span>
<span class="hljs-deletion">-Xss：栈空间</span></code></pre></div>

<p>-Xms 和 -Xmx最好调整一致，防止JVM频繁进行收集和回收</p>
<h3 id="JVM参数类型"><a href="#JVM参数类型" class="headerlink" title="JVM参数类型"></a>JVM参数类型</h3><ul>
<li>标配参数（从JDK1.0 - Java12都在，很稳定）<ul>
<li>-version</li>
<li>-help</li>
<li>java -showversion</li>
</ul>
</li>
<li>X参数（了解）<ul>
<li>-Xint：解释执行</li>
<li>-Xcomp：第一次使用就编译成本地代码</li>
<li>-Xmixed：混合模式</li>
</ul>
</li>
<li><strong>XX参数</strong> （重点）<ul>
<li>Boolean类型<ul>
<li>公式：-XX:+ 或者-某个属性 + 表示开启，-表示关闭</li>
<li>Case：-XX:-PrintGCDetails：表示关闭了GC详情输出</li>
</ul>
</li>
<li>key-value类型<ul>
<li>公式：-XX:属性key=属性value</li>
<li>不满意初始值，可以通过下列命令调整</li>
<li>case：如何：-XX:MetaspaceSize=21807104：查看Java元空间的值</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="查看运行的Java程序，JVM参数是否开启，具体值为多少？"><a href="#查看运行的Java程序，JVM参数是否开启，具体值为多少？" class="headerlink" title="查看运行的Java程序，JVM参数是否开启，具体值为多少？"></a>查看运行的Java程序，JVM参数是否开启，具体值为多少？</h3><h4 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h4><p>首先我们运行一个HelloGC的java程序</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Code22_HelloGC</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;
        System.out.println(<span class="hljs-string">&quot;hello GC&quot;</span>);
        Thread.sleep(Integer.MAX_VALUE);
    &#125;
&#125;</code></pre></div>

<p>然后使用下列命令查看它的默认参数</p>
<div class="hljs"><pre><code class="hljs shell">jps：查看java的后台进程
jinfo：查看正在运行的java程序</code></pre></div>

<p>具体使用：</p>
<div class="hljs"><pre><code class="hljs shell">jps -l得到进程号</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210419090019.png" srcset="/img/loading.gif"></p>
<p>查看到HelloGC的进程号为：95447</p>
<p>我们使用jinfo -flag 然后查看是否开启PrintGCDetails这个参数</p>
<div class="hljs"><pre><code class="hljs js">qiukedeMacBook-Pro-<span class="hljs-number">2</span>:meeting qiuke$ jps -l
<span class="hljs-number">95634</span> sun.tools.jps.Jps
<span class="hljs-number">95447</span> Code22_HelloGC
<span class="hljs-number">95446</span> org.jetbrains.jps.cmdline.Launcher
<span class="hljs-number">11256</span> 
qiukedeMacBook-Pro-<span class="hljs-number">2</span>:meeting qiuke$ jinfo -flag PrintGCDetails <span class="hljs-number">95447</span>
-XX:-PrintGCDetails</code></pre></div>

<p>上面提到了，-号表示关闭，即没有开启PrintGCDetails这个参数</p>
<p>下面我们需要在启动HelloGC的时候， <strong>增加</strong>  PrintGCDetails这个参数，需要在运行程序的时候配置JVM参数</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210419090223.png" srcset="/img/loading.gif"></p>
<p>再次如上操作：</p>
<div class="hljs"><pre><code class="hljs js">qiukedeMacBook-Pro-<span class="hljs-number">2</span>:meeting qiuke$ jps -l
<span class="hljs-number">96100</span> sun.tools.jps.Jps
<span class="hljs-number">11256</span> 
<span class="hljs-number">96045</span> Code22_HelloGC
<span class="hljs-number">96044</span> org.jetbrains.jps.cmdline.Launcher
qiukedeMacBook-Pro-<span class="hljs-number">2</span>:meeting qiuke$ jinfo -flag PrintGCDetails <span class="hljs-number">96045</span>
-XX:+PrintGCDetails</code></pre></div>

<p>我们看到原来的-号变成了+号，说明我们通过 VM Options配置的JVM参数已经生效了</p>
<p>使用下列命令，会把jvm的 <strong>全部默认参数输出</strong> </p>
<div class="hljs"><pre><code class="hljs shell">jinfo -flags ***</code></pre></div>



<h4 id="KV设置类型"><a href="#KV设置类型" class="headerlink" title="KV设置类型"></a>KV设置类型</h4><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210419092534.png" srcset="/img/loading.gif"></p>
<div class="hljs"><pre><code class="hljs js">qiukedeMacBook-Pro-<span class="hljs-number">2</span>:meeting qiuke$ jps -l
<span class="hljs-number">11256</span> 
<span class="hljs-number">99069</span> sun.tools.jps.Jps
<span class="hljs-number">98911</span> Code22_HelloGC
<span class="hljs-number">98910</span> org.jetbrains.jps.cmdline.Launcher
qiukedeMacBook-Pro-<span class="hljs-number">2</span>:meeting qiuke$ jinfo -flag MetaspaceSize <span class="hljs-number">98911</span>
-XX:MetaspaceSize=<span class="hljs-number">21807104</span></code></pre></div>



<h3 id="题外话（坑题）"><a href="#题外话（坑题）" class="headerlink" title="题外话（坑题）"></a>题外话（坑题）</h3><p>两个经典参数：-Xms 和 -Xmx，这两个参数 如何解释</p>
<p>这两个参数，还是属于XX参数，因为取了别名</p>
<ul>
<li>-Xms 等价于 -XX:InitialHeapSize ：初始化堆内存（默认只会用最大物理内存的64分1）</li>
<li>-Xmx 等价于 -XX:MaxHeapSize ：最大堆内存（默认只会用最大物理内存的4分1）</li>
</ul>
<h3 id="查看JVM默认参数"><a href="#查看JVM默认参数" class="headerlink" title="查看JVM默认参数"></a>查看JVM默认参数</h3><ul>
<li><p>-XX:+PrintFlagsInitial</p>
<ul>
<li><p>主要是查看初始默认值</p>
</li>
<li><p>公式</p>
<ul>
<li><p>java -XX:+PrintFlagsInitial -version</p>
</li>
<li><p>java -XX:+PrintFlagsInitial（重要参数）</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210419094429.png" srcset="/img/loading.gif"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>-XX:+PrintFlagsFinal：表示修改以后，最终的值</p>
<p>会将JVM的各个结果都进行打印</p>
<p>如果有 := 表示 <strong>修改过的</strong> ， = 表示没有修改过的</p>
</li>
</ul>
<h3 id="修改变更JVM参数"><a href="#修改变更JVM参数" class="headerlink" title="修改变更JVM参数"></a>修改变更JVM参数</h3><p>PrintFlagsFinal举例，运行java命令的同时打印出参数</p>
<div class="hljs"><pre><code class="hljs js">java -XX:+PrintFlagsFinal -XX:MetaspaceSize=512m HelloWorld</code></pre></div>

<p>打印命令行参数</p>
<p>-XX:+PrintCommandLineFlags</p>
<h3 id="工作中常用的JVM基本配置参数"><a href="#工作中常用的JVM基本配置参数" class="headerlink" title="工作中常用的JVM基本配置参数"></a>工作中常用的JVM基本配置参数</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210419094934.png" srcset="/img/loading.gif"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210419100741.png" srcset="/img/loading.gif"></p>
<h4 id="Xms-Xmx"><a href="#Xms-Xmx" class="headerlink" title="Xms Xmx"></a>Xms Xmx</h4><p>查看JVM的初始化堆内存 -Xms 和最大堆内存 Xmx</p>
<p>-XX:InitialHeapSize 和 -XX:MaxHeapSize</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">checkJVM</span><span class="hljs-params">()</span></span>&#123;
    <span class="hljs-comment">// 返回Java虚拟机中内存的总量</span>
    <span class="hljs-keyword">long</span> totalMemory = Runtime.getRuntime().totalMemory();

    <span class="hljs-comment">// 返回Java虚拟机中试图使用的最大内存量</span>
    <span class="hljs-keyword">long</span> maxMemory = Runtime.getRuntime().maxMemory();

    System.out.println(<span class="hljs-string">&quot;TOTAL_MEMORY(-Xms) = &quot;</span> + totalMemory + <span class="hljs-string">&quot;(字节)、&quot;</span> + (totalMemory / (<span class="hljs-keyword">double</span>)<span class="hljs-number">1024</span> / <span class="hljs-number">1024</span>) + <span class="hljs-string">&quot;MB&quot;</span>);
    System.out.println(<span class="hljs-string">&quot;MAX_MEMORY(-Xmx) = &quot;</span> + maxMemory + <span class="hljs-string">&quot;(字节)、&quot;</span> + (maxMemory / (<span class="hljs-keyword">double</span>)<span class="hljs-number">1024</span> / <span class="hljs-number">1024</span>) + <span class="hljs-string">&quot;MB&quot;</span>);

&#125;</code></pre></div>



<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210419101152.png" srcset="/img/loading.gif"></p>
<p>-Xms 初始堆内存为：物理内存的1/64 -Xmx 最大堆内存为：系统物理内存的 1/4</p>
<h4 id="Xss"><a href="#Xss" class="headerlink" title="Xss"></a>Xss</h4><p>设置单个线程栈的大小，一般默认为512k~1024K</p>
<p>等价于-XX:ThreadStackSize</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210419102115.png" srcset="/img/loading.gif"></p>
<p>0 128都能运行</p>
<blockquote>
<p>-XX:ThreadStackSize=size</p>
<p>Sets the thread stack size (in bytes). Append the letter k or K to indicate kilobytes, m or M to indicate megabytes, g or G to indicate gigabytes. The default value depends on virtual memory.</p>
<p>The following examples show how to set the thread stack size to 1024 KB in different units:</p>
<p>1 -XX:ThreadStackSize=1m<br>2 -XX:ThreadStackSize=1024k<br>3 -XX:ThreadStackSize=1048576</p>
<p>This option is equivalent to -Xss.</p>
<p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/technotes/tools/windows/java.html#BGBCIEFC">官方文档</a></p>
</blockquote>
<h4 id="xmn"><a href="#xmn" class="headerlink" title="xmn"></a>xmn</h4><p>-Xmn：设置年轻代大小</p>
<p>-XX:MetaspaceSize 设置 <strong>元空间</strong> 大小</p>
<p>元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制</p>
<h4 id="典型设置案例"><a href="#典型设置案例" class="headerlink" title="典型设置案例"></a>典型设置案例</h4><p>-Xms128m -Xmx4096m -Xss1024k -XX:MetaspaceSize=512m -XX:+PrintCommandLineFlags -XX:+PrintGCDetails-XX:+UseSerialGC</p>
<h4 id="PrintGCDetails"><a href="#PrintGCDetails" class="headerlink" title="PrintGCDetails"></a>PrintGCDetails</h4><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210419104448.png" srcset="/img/loading.gif"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210419104518.png" srcset="/img/loading.gif"></p>
<h4 id="GC查看"><a href="#GC查看" class="headerlink" title="GC查看"></a>GC查看</h4><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210419104643.png" srcset="/img/loading.gif"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210419104643.png" srcset="/img/loading.gif"></p>
<h4 id="XX-SurvivorRatio"><a href="#XX-SurvivorRatio" class="headerlink" title="-XX:SurvivorRatio"></a>-XX:SurvivorRatio</h4><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210419105325.png" srcset="/img/loading.gif"></p>
<p>调节新生代中 eden 和 S0、S1的空间比例，默认为 -XX:SuriviorRatio=8，Eden:S0:S1 =  <strong>8:1:1</strong> </p>
<p>假如设置成 -XX:SurvivorRatio=4，则为 Eden:S0:S1 = 4:1:1</p>
<p>SurvivorRatio值就是设置eden区的比例占多少，S0和S1相同。</p>
<ul>
<li>eden、SurvivorFrom复制到SurvivorTo，年龄 + 1</li>
</ul>
<p>首先，当Eden区满的时候会触发第一次GC，把还活着的对象拷贝到SurvivorFrom去，当Eden区再次触发GC的时候会扫描Eden区合From区域，对这两个区域进行垃圾回收，经过这次回收后还存活的对象，则直接复制到To区域（如果对象的年龄已经到达老年的标准，则赋值到老年代区），通知把这些对象的年龄 + 1</p>
<ul>
<li>清空eden、SurvivorFrom</li>
</ul>
<p>然后，清空eden，SurvivorFrom中的对象，也即复制之后有交换，谁空谁是to</p>
<ul>
<li>SurvivorTo和SurvivorFrom互换</li>
</ul>
<p>最后，SurvivorTo和SurvivorFrom互换，原SurvivorTo成为下一次GC时的SurvivorFrom区，部分对象会在From和To区域中复制来复制去，如此 <strong>交换15次</strong> （由JVM参数 <strong>MaxTenuringThreshold</strong> 决定，这个参数默认为15），最终如果还是存活，就存入老年代</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210419105920.png" srcset="/img/loading.gif"></p>
<h4 id="XX-NewRatio（了解）"><a href="#XX-NewRatio（了解）" class="headerlink" title="-XX:NewRatio（了解）"></a>-XX:NewRatio（了解）</h4><p>配置年轻代new 和老年代old 在堆结构的占比</p>
<p>默认： -XX:NewRatio=2 新生代占1，老年代2，年轻代占整个堆的1/3</p>
<p>-XX:NewRatio=4：新生代占1，老年代占4，年轻代占整个堆的1/5，NewRadio值就是设置老年代的占比，剩下的1个新生代</p>
<p>新生代特别小，会造成频繁的进行GC收集</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210419110844.png" srcset="/img/loading.gif"></p>
<h4 id="XX-MaxTenuringThreshold"><a href="#XX-MaxTenuringThreshold" class="headerlink" title="-XX:MaxTenuringThreshold"></a>-XX:MaxTenuringThreshold</h4><p>设置垃圾最大年龄，SurvivorTo和SurvivorFrom互换，原SurvivorTo成为下一次GC时的SurvivorFrom区，部分对象会在From和To区域中复制来复制去，如此交换15次（由JVM参数MaxTenuringThreshold决定，这个参数默认为15），最终如果还是存活，就存入老年代</p>
<p>这里就是调整这个次数的，默认是15，并且设置的值 在 0~15之间</p>
<p>查看默认进入老年代年龄：jinfo -flag MaxTenuringThreshold 17344</p>
<p>-XX:MaxTenuringThreshold=0：设置垃圾最大年龄。如果设置为0的话，则年轻对象不经过Survivor区，直接进入老年代。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大的值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概念</p>
<h2 id="Java中的引用"><a href="#Java中的引用" class="headerlink" title="Java中的引用"></a>Java中的引用</h2><h3 id="前言-3"><a href="#前言-3" class="headerlink" title="前言"></a>前言</h3><p>在原来的时候，我们谈到一个类的实例化</p>
<div class="hljs"><pre><code class="hljs haxe">Person p = <span class="hljs-keyword">new</span> <span class="hljs-type">Person</span>()</code></pre></div>

<p>在等号的左边，就是一个对象的引用，存储在 **栈中 **</p>
<p>而等号右边，就是实例化的对象，存储在 <strong>堆中</strong> </p>
<p>其实这样的一个引用关系，就被称为强引用</p>
<h3 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210421080219.png" srcset="/img/loading.gif"></p>
<h3 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h3><p>当内存不足的时候，JVM开始垃圾回收， <strong>对于强引用的对象，就算是出现了OOM也不会对该对象进行回收</strong> ，打死也不回收！</p>
<p>强引用是我们最常见的普通对象引用，只要还有 <strong>一个强引用指向一个对象，就能表明对象还“活着”</strong> ，垃圾收集器不会碰这种对象。在Java中最常见的就是强引用，把一个对象赋给一个引用变量，这个引用变量就是一个强引用。当一个对象被强引用变量引用时，它处于 <strong>可达状态</strong> ，它是不可能被垃圾回收机制回收的，即使该对象以后永远都不会被用到，JVM也不会回收，因此 <strong>强引用是造成Java内存泄漏的主要原因之一</strong> 。</p>
<p>对于一个普通的对象，如果没有其它的引用关系，只要超过了引用的作用域或者显示地将相应（强）引用赋值为null，一般可以认为就是可以被垃圾收集的了（当然具体回收时机还是要看垃圾回收策略）</p>
<p>强引用小例子：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">StrongReferenceDemo</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-comment">// 这样定义的默认就是强应用</span>
    Object obj1 = <span class="hljs-keyword">new</span> Object();

    <span class="hljs-comment">// 使用第二个引用，指向刚刚创建的Object对象</span>
    Object obj2 = obj1;

    <span class="hljs-comment">// 置空</span>
    obj1 = <span class="hljs-keyword">null</span>;

    <span class="hljs-comment">// 垃圾回收</span>
    System.gc();

    System.out.println(obj1);

    System.out.println(obj2);
&#125;</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210421080832.png" srcset="/img/loading.gif"></p>
<p>输出结果我们能够发现，即使 obj1 被设置成了null，然后调用gc进行回收，但是也没有回收实例出来的对象，obj2还是能够指向该地址，也就是说垃圾回收器，并 <strong>没有将该对象进行垃圾回收</strong> </p>
<h3 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h3><p>软引用是一种相对弱化了一些的引用，需要用Java.lang.ref.SoftReference类来实现，可以让对象豁免一些垃圾收集，对于只有软引用的对象来讲：</p>
<ul>
<li>当系统内存充足时，它不会被回收</li>
<li>当系统 <strong>内存不足时，它会被回收</strong> </li>
</ul>
<p>软引用通常在对内存敏感的程序中，比如 <strong>高速缓存就用到了软引用</strong> ，内存够用 的时候就保留，不够用就回收</p>
<p>具体使用</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 内存够用的时候</span>
<span class="hljs-comment"> */</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">softRefMemoryEnough</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-comment">// 创建一个强应用</span>
    Object o1 = <span class="hljs-keyword">new</span> Object();
    <span class="hljs-comment">// 创建一个软引用</span>
    SoftReference&lt;Object&gt; softReference = <span class="hljs-keyword">new</span> SoftReference&lt;&gt;(o1);
    System.out.println(o1);
    System.out.println(softReference.get());

    o1 = <span class="hljs-keyword">null</span>;
    <span class="hljs-comment">// 手动GC</span>
    System.gc();

    System.out.println(o1);
    System.out.println(softReference.get());
&#125;</code></pre></div>

<p>得到结果：</p>
<p>我们写了两个方法，一个是内存够用的时候，一个是内存不够用的时候</p>
<p>我们首先查看内存够用的时候，首先输出的是 o1 和 软引用的 softReference，我们都能够看到值</p>
<p>然后我们把o1设置为null，执行手动GC后，我们发现 <strong>softReference的值还存在</strong> ，说明内存充足的时候，软引用的对象不会被回收</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210421081338.png" srcset="/img/loading.gif"></p>
<p>更改代码，手动OOM：</p>
<p>使用了JVM启动参数配置，给初始化堆内存为5M，创建了一个30M的大对象；</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * JVM配置，故意产生大对象并配置小的内存，让它的内存不够用了导致OOM，看软引用的回收情况</span>
<span class="hljs-comment"> * -Xms5m -Xmx5m -XX:+PrintGCDetails</span>
<span class="hljs-comment"> */</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">softRefMemoryNoEnough</span><span class="hljs-params">()</span> </span>&#123;

    System.out.println(<span class="hljs-string">&quot;========================&quot;</span>);
    <span class="hljs-comment">// 创建一个强应用</span>
    Object o1 = <span class="hljs-keyword">new</span> Object();
    <span class="hljs-comment">// 创建一个软引用</span>
    SoftReference&lt;Object&gt; softReference = <span class="hljs-keyword">new</span> SoftReference&lt;&gt;(o1);
    System.out.println(o1);
    System.out.println(softReference.get());

    o1 = <span class="hljs-keyword">null</span>;

    <span class="hljs-comment">// 模拟OOM自动GC</span>
    <span class="hljs-keyword">try</span> &#123;
        <span class="hljs-comment">// 创建30M的大对象</span>
        <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">30</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>];
    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
        e.printStackTrace();
    &#125; <span class="hljs-keyword">finally</span> &#123;
        System.out.println(o1);
        System.out.println(softReference.get());
    &#125;
&#125;</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210421081449.png" srcset="/img/loading.gif"></p>
<p>这就必然会触发垃圾回收机制，这也是中间出现的垃圾回收过程，最后看结果我们发现，o1 和 softReference都被回收了，因此说明， <strong>软引用</strong> 在 <strong>内存不足</strong> 的时候， <strong>会自动回收</strong> </p>
<h3 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h3><p>不管内存是否够，只要有GC操作就会进行回收</p>
<p>弱引用需要用 <code>java.lang.ref.WeakReference</code> 类来实现，它比软引用生存期更短</p>
<p>对于只有弱引用的对象来说，只要垃圾回收机制一运行，不管JVM的内存空间是否足够， <strong>都会回收</strong> 该对象占用的空间。</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">weakReferenceDemo</span><span class="hljs-params">()</span> </span>&#123;
    Object o1 = <span class="hljs-keyword">new</span> Object();
    WeakReference&lt;Object&gt; weakReference = <span class="hljs-keyword">new</span> WeakReference&lt;&gt;(o1);
    System.out.println(o1);
    System.out.println(weakReference.get());
    o1 = <span class="hljs-keyword">null</span>;
    System.gc();
    System.out.println(o1);
    System.out.println(weakReference.get());
&#125;</code></pre></div>

<p>我们并没有制造出OOM内存溢出，而只是调用了一下GC操作，垃圾回收就把它给收集了</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210421081830.png" srcset="/img/loading.gif"></p>
<h3 id="软引用和弱引用的使用场景"><a href="#软引用和弱引用的使用场景" class="headerlink" title="软引用和弱引用的使用场景"></a>软引用和弱引用的使用场景</h3><p>场景：假如有一个应用需要读取大量的本地图片</p>
<ul>
<li>如果每次读取图片都从硬盘读取则会严重 <strong>影响性能</strong> </li>
<li>如果一次性全部加载到内存中，又可能造成 <strong>内存溢出</strong> </li>
</ul>
<p>此时使用软引用可以解决这个问题</p>
<p>设计思路：使用HashMap来保存 <strong>图片的路径</strong> 和相应 <strong>图片对象关联的软引用</strong> 之间的映射关系，在内存不足时，JVM会自动回收这些缓存图片对象所占的空间，从而有效地避免了OOM的问题</p>
<div class="hljs"><pre><code class="hljs java">Map&lt;String, SoftReference&lt;String&gt;&gt; imageCache = <span class="hljs-keyword">new</span> HashMap&lt;String, SoftReference&lt;Bitmap&gt;&gt;();</code></pre></div>



<h3 id="WeakHashMap是什么？"><a href="#WeakHashMap是什么？" class="headerlink" title="WeakHashMap是什么？"></a>WeakHashMap是什么？</h3><p>比如一些常常和底层打交道的， <strong>mybatis</strong> 等，底层都应用到了 <strong>WeakHashMap</strong> </p>
<p>WeakHashMap和HashMap类似，只不过它的 <strong>Key是使用了弱引用的</strong> ，也就是说，当执行GC的时候，HashMap中的key会进行回收，下面我们使用例子来测试一下</p>
<p>我们使用了两个方法，一个是普通的HashMap方法</p>
<p>测试：</p>
<p>我们输入一个Key-Value键值对，然后让它的key置空，然后在查看结果</p>
<p>第二个是使用了WeakHashMap，完整代码如下</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">myHashMap</span><span class="hljs-params">()</span> </span>&#123;
        Map&lt;Integer, String&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
        Integer key = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">1</span>);
        String value = <span class="hljs-string">&quot;HashMap&quot;</span>;

        map.put(key, value);
        System.out.println(map);

        key = <span class="hljs-keyword">null</span>;

        System.gc();

        System.out.println(map);
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">myWeakHashMap</span><span class="hljs-params">()</span> </span>&#123;
        Map&lt;Integer, String&gt; map = <span class="hljs-keyword">new</span> WeakHashMap&lt;&gt;();
        Integer key = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">1</span>);
        String value = <span class="hljs-string">&quot;WeakHashMap&quot;</span>;

        map.put(key, value);
        System.out.println(map);

        key = <span class="hljs-keyword">null</span>;

        System.gc();

        System.out.println(map);
    &#125;</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210421083335.png" srcset="/img/loading.gif"></p>
<p>从这里我们看到，对于普通的HashMap来说，key置空并不会影响，HashMap的键值对，因为这个属于强引用，不会被垃圾回收。</p>
<p>但是WeakHashMap，在进行GC操作后， <strong>弱引用的就会被回收</strong> </p>
<h3 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h3><h4 id="概念-9"><a href="#概念-9" class="headerlink" title="概念"></a>概念</h4><p>虚引用又称为 <strong>幽灵引用</strong> ，需要<code>java.lang.ref.PhantomReference</code> 类来实现</p>
<p>顾名思义，就是形同虚设，与其他几种引用都不同， <strong>虚引用并不会决定对象的生命周期</strong> 。</p>
<p>如果一个对象持有虚引用，那么 <strong>它就和没有任何引用一样</strong> ，在 <strong>任何时候都可能被垃圾回收器回收</strong> ，它 <strong>不能单独使用</strong> 也不能通过它访问对象，虚引用 <strong>必须和引用队列ReferenceQueue联合使用</strong> 。</p>
<p>虚引用的主要作用是 <strong><em>跟踪对象被垃圾回收的状态</em></strong> ，仅仅是提供一种确保对象被finalize以后，做某些事情的机制。</p>
<p>PhantomReference的get方法总是返回null，因此 <strong>无法访问对象的引用对象</strong> 。其意义在于说明一个对象已经进入finalization阶段，可以被gc回收，用来实现比finalization机制更灵活的回收操作</p>
<p>换句话说，设置虚引用关联的唯一目的，就是 <strong><em>在这个对象被收集器回收的时候，收到一个系统通知或者后续添加进一步的处理，Java技术允许使用finalize()方法在垃圾收集器将对象从内存中清除出去之前，做必要的清理工作</em></strong> </p>
<p>这个就相当于Spring AOP里面的 <strong>后置通知</strong> </p>
<h4 id="场景-1"><a href="#场景-1" class="headerlink" title="场景"></a>场景</h4><p>一般用于在回收时候做通知相关操作</p>
<h3 id="引用队列-ReferenceQueue"><a href="#引用队列-ReferenceQueue" class="headerlink" title="引用队列 ReferenceQueue"></a>引用队列 ReferenceQueue</h3><p>软引用，弱引用，虚引用在回收之前，需要在 <strong>引用队列保存一下</strong> </p>
<p>我们在初始化的弱引用或者虚引用的时候，可以传入一个引用队列</p>
<p>那么在进行GC回收的时候， <strong>弱引用和虚引用的对象都会被回收</strong> ，但是在回收之前，它会被送至引用队列中</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">referenceQueueDemo</span><span class="hljs-params">()</span> </span>&#123;
        Object o1 = <span class="hljs-keyword">new</span> Object();

        <span class="hljs-comment">// 创建引用队列</span>
        ReferenceQueue&lt;Object&gt; referenceQueue = <span class="hljs-keyword">new</span> ReferenceQueue&lt;&gt;();

        <span class="hljs-comment">// 创建一个弱引用</span>
        WeakReference&lt;Object&gt; weakReference = <span class="hljs-keyword">new</span> WeakReference&lt;&gt;(o1, referenceQueue);

        <span class="hljs-comment">// 创建一个虚引用</span>
<span class="hljs-comment">//        PhantomReference&lt;Object&gt; reference = new PhantomReference&lt;&gt;(o1, referenceQueue);</span>

        System.out.println(o1);
        System.out.println(weakReference.get());
        <span class="hljs-comment">// 取队列中的内容</span>
        System.out.println(referenceQueue.poll());

        o1 = <span class="hljs-keyword">null</span>;
        System.gc();
        System.out.println(<span class="hljs-string">&quot;执行GC操作&quot;</span>);

        <span class="hljs-keyword">try</span> &#123;
            TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);
        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;

        System.out.println(o1);
        System.out.println(weakReference.get());
        <span class="hljs-comment">// 取队列中的内容</span>
        System.out.println(referenceQueue.poll());
    &#125;</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210421085733.png" srcset="/img/loading.gif"></p>
<p>从这里我们能看到，在进行垃圾回收后，我们弱引用对象，也被设置成null，但是在队列中还能够导出该引用的实例，这就说明在回收之前，该弱引用的实例 <strong>被放置引用队列中</strong> 了，我们可以通过引用队列进行一些后置操作</p>
<p>如果把上列代码换成虚引用：</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210421090517.png" srcset="/img/loading.gif"></p>
<h3 id="GCRoots和四大引用小总结"><a href="#GCRoots和四大引用小总结" class="headerlink" title="GCRoots和四大引用小总结"></a>GCRoots和四大引用小总结</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210421090816.png" srcset="/img/loading.gif"></p>
<h2 id="Java内存溢出OOM"><a href="#Java内存溢出OOM" class="headerlink" title="Java内存溢出OOM"></a>Java内存溢出OOM</h2><h3 id="经典错误"><a href="#经典错误" class="headerlink" title="经典错误"></a>经典错误</h3><p>JVM中常见的两个错误</p>
<p>StackoverFlowError ：栈溢出</p>
<p>OutofMemoryError: java heap space：堆溢出</p>
<p>除此之外，还有以下的错误</p>
<ul>
<li>java.lang.StackOverflowError</li>
<li>java.lang.OutOfMemoryError：java heap space</li>
<li>java.lang.OutOfMemoryError：GC overhead limit exceeeded</li>
<li>java.lang.OutOfMemoryError：Direct buffer memory</li>
<li>java.lang.OutOfMemoryError：unable to create new native thread</li>
<li>java.lang.OutOfMemoryError：Metaspace</li>
</ul>
<h3 id="架构-1"><a href="#架构-1" class="headerlink" title="架构"></a>架构</h3><p>OutOfMemoryError和StackOverflowError是属于Error，不是Exception</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210421091320.png" srcset="/img/loading.gif"></p>
<h3 id="StackoverFlowError"><a href="#StackoverFlowError" class="headerlink" title="StackoverFlowError"></a>StackoverFlowError</h3><p>堆栈溢出，栈管方法，我们有最简单的一个递归调用，就会造成堆栈溢出，也就是深度的方法调用</p>
<p>栈一般是512K，不断的深度调用，直到栈被撑破</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 栈一般是512K，不断的深度调用，直到栈被撑破</span>
<span class="hljs-comment"> * Exception in thread &quot;main&quot; java.lang.StackOverflowError</span>
<span class="hljs-comment"> */</span>
<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stackOverflowError</span><span class="hljs-params">()</span> </span>&#123;
    stackOverflowError();
&#125;</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210421091659.png" srcset="/img/loading.gif"></p>
<h3 id="OutOfMemoryError"><a href="#OutOfMemoryError" class="headerlink" title="OutOfMemoryError"></a>OutOfMemoryError</h3><h4 id="java-heap-space"><a href="#java-heap-space" class="headerlink" title="java heap space"></a>java heap space</h4><p>创建了很多对象，导致堆空间不够存储</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">heapSpaceDemo</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-comment">// 堆空间的大小 -Xms10m -Xmx10m</span>
    <span class="hljs-comment">// 创建一个 80M的字节数组</span>
    <span class="hljs-keyword">byte</span> [] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">80</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>];
&#125;</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210421094730.png" srcset="/img/loading.gif"></p>
<h4 id="GC-overhead-limit-exceeded"><a href="#GC-overhead-limit-exceeded" class="headerlink" title="GC overhead limit exceeded"></a>GC overhead limit exceeded</h4><p>GC回收时间过长时会抛出OutOfMemoryError，过长的定义是，超过了98%的时间用来做GC，并且回收了不到2%的堆内存</p>
<p>连续多次GC都只回收了不到2%的极端情况下，才会抛出。假设不抛出GC overhead limit 错误会造成什么情况呢？</p>
<p>那就是GC清理的这点内存很快会再次被填满，迫使GC再次执行，这样就形成了恶性循环，CPU的使用率一直都是100%，而GC却没有任何成果。</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210421095832.png" srcset="/img/loading.gif"></p>
<p>代码演示：</p>
<p>为了更快的达到效果，我们首先需要设置JVM启动参数</p>
<div class="hljs"><pre><code class="hljs java">-Xms10m -Xmx10m -XX:+PrintGCDetails -XX:MaxDirectMemorySize=5m</code></pre></div>

<p>这个异常出现的步骤就是，我们不断的向list中插入String对象，直到启动GC回收</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// -Xms10m -Xmx10m -XX:+PrintGCDetails -XX:MaxDirectMemorySize=5m</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">GClimit</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;
    List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
    <span class="hljs-keyword">try</span> &#123;
        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;
            list.add(String.valueOf(++i).intern());
        &#125;
    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
        System.out.println(<span class="hljs-string">&quot;***************i:&quot;</span> + i);
        e.printStackTrace();
        <span class="hljs-keyword">throw</span> e;
    &#125; <span class="hljs-keyword">finally</span> &#123;

    &#125;
&#125;</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210421100931.png" srcset="/img/loading.gif"></p>
<p>我们能够看到 多次Full GC，并没有清理出空间，在多次执行GC操作后，就抛出异常 GC overhead limit</p>
<h4 id="Direct-buffer-memory"><a href="#Direct-buffer-memory" class="headerlink" title="Direct buffer memory"></a>Direct buffer memory</h4><p>Netty + NIO：这是由于 <strong>NIO引起的</strong> </p>
<p>写NIO程序的时候经常会使用 <strong>ByteBuffer</strong> 来读取或写入数据，这是一种基于通道(Channel) 与 缓冲区(Buffer)的I/O方式，它可以使用Native 函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。</p>
<p> <strong>ByteBuffer.allocate(capability)</strong> ：第一种方式是分配JVM堆内存，属于GC管辖范围，由于需要拷贝所以速度相对较慢</p>
<p> <strong>ByteBuffer.allocteDirect(capability)</strong> ：第二种方式是分配OS本地内存，不属于GC管辖范围，由于不需要内存的拷贝，所以速度相对较快</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210421102643.png" srcset="/img/loading.gif"></p>
<p>但如果不断分配本地内存，堆内存很少使用，那么JVM就不需要执行GC，DirectByteBuffer对象就不会被回收，这时候怼内存充足，但本地内存可能已经使用光了，再次尝试分配本地内存就会出现OutOfMemoryError，那么程序就奔溃了。</p>
<p>一句话说： <strong>本地内存不足，但是堆内存充足的时候</strong> ，就会出现这个问题</p>
<p>我们使用 -XX:MaxDirectMemorySize=5m 配置能使用的堆外物理内存为5M</p>
<div class="hljs"><pre><code class="hljs java">-Xms10m -Xmx10m -XX:+PrintGCDetails -XX:MaxDirectMemorySize=5m</code></pre></div>

<p>然后我们申请一个6M的空间</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// 只设置了5M的物理内存使用，但是却分配 6M的空间</span>
ByteBuffer bb = ByteBuffer.allocateDirect(<span class="hljs-number">6</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>);</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210421101944.png" srcset="/img/loading.gif"></p>
<h4 id="unable-to-create-new-native-thread"><a href="#unable-to-create-new-native-thread" class="headerlink" title="unable to create new native thread"></a>unable to create new native thread</h4><p>不能够创建更多的新的线程了，也就是说 <strong>创建线程的上限达到了</strong> </p>
<p>在高并发场景的时候，会应用到</p>
<p>高并发请求服务器时，经常会出现如下异常<code>java.lang.OutOfMemoryError:unable to create new native thread</code>，准确说该native thread异常与对应的平台有关</p>
<p>导致原因：</p>
<ul>
<li>应用 <strong>创建了太多线程</strong> ，一个应用进程创建多个线程，超过系统承载极限</li>
<li> <strong>服务器并不允许你的应用程序创建这么多线程</strong> ，linux系统默认运行单个进程可以创建的线程为 <strong>1024个</strong> ，如果应用创建超过这个数量，就会报 <code>java.lang.OutOfMemoryError:unable to create new native thread</code></li>
</ul>
<p>解决方法：</p>
<ol>
<li>想办法 <strong>降低你应用程序创建线程的数量</strong> ，分析应用是否真的需要创建这么多线程，如果不是，改代码将线程数降到最低</li>
<li>对于有的应用，确实需要创建很多线程，远超过linux系统默认1024个线程限制，可以通过 <strong>修改linux服务器配置</strong> ，扩大linux默认限制</li>
</ol>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unableCreateNewThreadDemo</span><span class="hljs-params">()</span></span>&#123;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; ; i++) &#123;
        System.out.println(<span class="hljs-string">&quot;************** i = &quot;</span> + i);
        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
            <span class="hljs-keyword">try</span> &#123;
                TimeUnit.SECONDS.sleep(Integer.MAX_VALUE);
            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;, String.valueOf(i)).start();
    &#125;
&#125;</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210421102303.png" srcset="/img/loading.gif"></p>
<p>如何查看线程数</p>
<div class="hljs"><pre><code class="hljs java">ulimit -u</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210421104732.png" srcset="/img/loading.gif"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210421104805.png" srcset="/img/loading.gif"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210421104849.png" srcset="/img/loading.gif"></p>
<h4 id="Metaspace"><a href="#Metaspace" class="headerlink" title="Metaspace"></a>Metaspace</h4><p>元空间内存不足，Matespace元空间应用的是本地内存</p>
<p><code>-XX:MetaspaceSize</code> 的处理化大小为20M</p>
<h5 id="元空间是什么"><a href="#元空间是什么" class="headerlink" title="元空间是什么"></a>元空间是什么</h5><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210421105112.png" srcset="/img/loading.gif"></p>
<p>元空间就是我们的 <strong>方法区</strong> ，存放的是 <strong>类模板，类信息，常量池</strong> 等</p>
<p>Metaspace是方法区HotSpot中的实现，它与持久代最大的区别在于：Metaspace并不在虚拟内存中，而是使用本地内存，也即在java8中，class metadata（the virtual machines internal presentation of Java class），被存储在叫做Matespace的native memory</p>
<p>永久代（java8后被元空间Metaspace取代了）存放了以下信息：</p>
<ul>
<li>虚拟机加载的类信息</li>
<li>常量池</li>
<li>静态变量</li>
<li>即时编译后的代码</li>
</ul>
<p>模拟Metaspace空间溢出，我们不断生成类 往元空间里灌输，类占据的空间总会超过Metaspace指定的空间大小</p>
<h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><p>在模拟异常生成时候，因为初始化的元空间为20M，因此我们使用JVM参数调整元空间的大小，为了更好的效果</p>
<div class="hljs"><pre><code class="hljs java">-XX:MetaspaceSize=8m -XX:MaxMetaspaceSize=8m</code></pre></div>

<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// 静态类</span>
<span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OOMTest</span> </span>&#123;

&#125;

<span class="hljs-comment">// -XX:MetaspaceSize=8m -XX:MaxMetaspaceSize=8m</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">metaspaceOutOfMemoryDemo</span><span class="hljs-params">()</span></span>&#123;
    <span class="hljs-comment">// 模拟计数多少次以后发生异常</span>
    <span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>;
    <span class="hljs-keyword">try</span> &#123;
        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;
            i++;
            <span class="hljs-comment">// 使用Spring的动态字节码技术</span>
            Enhancer enhancer = <span class="hljs-keyword">new</span> Enhancer();
            enhancer.setSuperclass(OOMTest.class);
            enhancer.setUseCache(<span class="hljs-keyword">false</span>);
            enhancer.setCallback(<span class="hljs-keyword">new</span> MethodInterceptor() &#123;
                <span class="hljs-meta">@Override</span>
                <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">intercept</span><span class="hljs-params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;
                    <span class="hljs-keyword">return</span> methodProxy.invokeSuper(o, args);
                &#125;
            &#125;);
        &#125;
    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
        System.out.println(<span class="hljs-string">&quot;发生异常的次数:&quot;</span> + i);
        e.printStackTrace();
    &#125; <span class="hljs-keyword">finally</span> &#123;

    &#125;
&#125;</code></pre></div>

<p>会出现以下错误：</p>
<div class="hljs"><pre><code class="hljs java">发生异常的次数: <span class="hljs-number">201</span>
java.lang.OutOfMemoryError:Metaspace</code></pre></div>



<h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><h3 id="GC垃圾回收算法和垃圾收集器关系"><a href="#GC垃圾回收算法和垃圾收集器关系" class="headerlink" title="GC垃圾回收算法和垃圾收集器关系"></a>GC垃圾回收算法和垃圾收集器关系</h3><blockquote>
<p>天上飞的理念，要有落地的实现（垃圾收集器就是GC垃圾回收算法的实现）</p>
<p>GC算法是内存回收的方法论，垃圾收集器就是算法的落地实现</p>
</blockquote>
<p>GC算法主要有以下几种</p>
<ul>
<li>引用计数（几乎不用，无法解决循环引用的问题）</li>
<li>复制拷贝（用于新生代）</li>
<li>标记清除（用于老年代）</li>
<li>标记整理（用于老年代）</li>
</ul>
<p>因为目前为止还没有完美的收集器出现，更没有万能的收集器，只是针对具体应用最合适的收集器，进行分代收集（那个代用什么收集器）</p>
<h3 id="四种主要的垃圾收集器"><a href="#四种主要的垃圾收集器" class="headerlink" title="四种主要的垃圾收集器"></a>四种主要的垃圾收集器</h3><ul>
<li>Serial：串行回收 <code>-XX:+UseSeriallGC</code></li>
<li>Parallel：并行回收 <code>-XX:+UseParallelGC</code></li>
<li>CMS：并发标记清除</li>
<li>G1</li>
<li>ZGC：（java 11 出现的）</li>
</ul>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210421110535.png" srcset="/img/loading.gif"></p>
<h4 id="Serial"><a href="#Serial" class="headerlink" title="Serial"></a>Serial</h4><p>串行垃圾回收器，它为 <strong>单线程环境</strong> 设计且值使用一个线程进行垃圾收集，会 <strong>暂停所有的用户线程</strong> ，只有当垃圾回收完成时，才会重新唤醒主线程继续执行。所以 <strong>不适合</strong> 服务器环境</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210422094624.png" srcset="/img/loading.gif"></p>
<h4 id="Parallel"><a href="#Parallel" class="headerlink" title="Parallel"></a>Parallel</h4><p>并行垃圾收集器，多个垃圾收集线程并行工作，此时 <strong>用户线程也是阻塞</strong> 的，适用于科学计算 / 大数据处理等弱交互场景，也就是说 <strong>Serial 和 Parallel其实是类似的，不过是多了几个线程进行垃圾收集，但是主线程都会被暂停</strong> ，但是并行垃圾收集器处理时间，肯定比串行的垃圾收集器要更短</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210422094811.png" srcset="/img/loading.gif"></p>
<h4 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h4><p>并发标记清除，用户线程和垃圾收集线程 <strong>同时执行</strong> （不一定是并行，可能是交替执行），不需要停顿用户线程，互联网公司都在使用，适用于响应时间有要求的场景。并发是可以有交互的，也就是说可以一边进行收集，一边执行应用程序。</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210422095000.png" srcset="/img/loading.gif"></p>
<h4 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h4><p>G1垃圾回收器将堆内存分割成不同区域，然后 <strong>并发</strong> 的进行垃圾回收</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210422095045.png" srcset="/img/loading.gif"></p>
<h3 id="垃圾收集器总结"><a href="#垃圾收集器总结" class="headerlink" title="垃圾收集器总结"></a>垃圾收集器总结</h3><p>注意：并行垃圾回收在单核CPU下可能会更慢</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210422095236.png" srcset="/img/loading.gif"></p>
<h3 id="查看默认垃圾收集器"><a href="#查看默认垃圾收集器" class="headerlink" title="查看默认垃圾收集器"></a>查看默认垃圾收集器</h3><p>使用下面JVM命令，查看配置的初始参数</p>
<div class="hljs"><pre><code class="hljs java">-XX:+PrintCommandLineFlags</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210422100102.png" srcset="/img/loading.gif"></p>
<p>或者：</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210422100248.png" srcset="/img/loading.gif"></p>
<p>然后运行一个程序后，能够看到它的一些初始配置信息</p>
<div class="hljs"><pre><code class="hljs java">-XX:InitialHeapSize=<span class="hljs-number">266376000</span> -XX:MaxHeapSize=<span class="hljs-number">4262016000</span> -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:-UseLargePagesIndividualAllocation -XX:+UseParallelGC</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210422100110.png" srcset="/img/loading.gif"></p>
<p>移动到最后一句，就能看到 <code>-XX:+UseParallelGC</code> 说明使用的是并行垃圾回收</p>
<div class="hljs"><pre><code class="hljs java">-XX:+UseParallelGC</code></pre></div>



<h3 id="默认垃圾收集器有哪些"><a href="#默认垃圾收集器有哪些" class="headerlink" title="默认垃圾收集器有哪些"></a>默认垃圾收集器有哪些</h3><p>Java中一共有7大垃圾收集器</p>
<ul>
<li>UseSerialGC：串行垃圾收集器</li>
<li>UseParallelGC：并行垃圾收集器</li>
<li>UseConcMarkSweepGC：（CMS）并发标记清除</li>
<li>UseParNewGC：年轻代的并行垃圾回收器</li>
<li>UseParallelOldGC：老年代的并行垃圾回收器</li>
<li>UseG1GC：G1垃圾收集器</li>
<li>UserSerialOldGC：串行老年代垃圾收集器（已经被移除）</li>
</ul>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210422100753.png" srcset="/img/loading.gif"></p>
<p>如何修改：</p>
<p>我们先设置参数</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210422101215.png" srcset="/img/loading.gif"></p>
<p>再运行查看：</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210422101444.png" srcset="/img/loading.gif"></p>
<h3 id="各垃圾收集器的使用范围"><a href="#各垃圾收集器的使用范围" class="headerlink" title="各垃圾收集器的使用范围"></a>各垃圾收集器的使用范围</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210422101637.png" srcset="/img/loading.gif"></p>
<p> <strong>新生代</strong> 使用的：</p>
<ul>
<li>Serial Copying： UserSerialGC，串行垃圾回收器</li>
<li>Parallel Scavenge：UserParallelGC，并行垃圾收集器</li>
<li>ParNew：UserParNewGC，新生代并行垃圾收集器</li>
</ul>
<p> <strong>老年区</strong> 使用的：</p>
<ul>
<li>Serial Old：UseSerialOldGC，老年代串行垃圾收集器</li>
<li>Parallel Compacting（Parallel Old）：UseParallelOldGC，老年代并行垃圾收集器</li>
<li> <strong>CMS</strong> ：UseConcMarkSwepp，并行标记清除垃圾收集器</li>
</ul>
<p> <strong>各区都能使用</strong> 的：</p>
<p> <strong>G1</strong> ：UseG1GC，G1垃圾收集器</p>
<p>垃圾收集器就来具体实现这些GC算法并实现内存回收，不同厂商，不同版本的虚拟机实现差别很大，HotSpot中包含的收集器如下图所示：</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210422102139.png" srcset="/img/loading.gif"></p>
<h3 id="部分参数说明"><a href="#部分参数说明" class="headerlink" title="部分参数说明"></a>部分参数说明</h3><ul>
<li>DefNew：Default New Generation</li>
<li>Tenured：Old</li>
<li>ParNew：Parallel New Generation</li>
<li>PSYoungGen：Parallel Scavenge</li>
<li>ParOldGen：Parallel Old Generation</li>
</ul>
<h3 id="Java中的Server和Client模式"><a href="#Java中的Server和Client模式" class="headerlink" title="Java中的Server和Client模式"></a>Java中的Server和Client模式</h3><p>使用范围：一般使用Server模式，Client模式基本不会使用</p>
<p>操作系统</p>
<ul>
<li>32位的Window操作系统，不论硬件如何都默认使用Client的JVM模式</li>
<li>32位的其它操作系统，2G内存同时有2个cpu以上用Server模式，低于该配置还是Client模式</li>
<li>64位只有Server模式</li>
</ul>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210422102723.png" srcset="/img/loading.gif"></p>
<h3 id="新生代下的垃圾收集器"><a href="#新生代下的垃圾收集器" class="headerlink" title="新生代下的垃圾收集器"></a>新生代下的垃圾收集器</h3><h4 id="串行GC-Serial"><a href="#串行GC-Serial" class="headerlink" title="串行GC(Serial)"></a>串行GC(Serial)</h4><p>串行GC（Serial）（Serial Copying）</p>
<p>是一个 <strong>单线程的收集器</strong> ，在进行垃圾收集时候，必须暂停其他所有的工作线程直到它收集结束。</p>
<p>由上面的图会自动激活serial old</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210422103104.png" srcset="/img/loading.gif"></p>
<p>串行收集器是 <strong>最古老，最稳定以及效率高</strong> 的收集器，只使用一个线程去回收但其在垃圾收集过程中可能会产生较长的停顿( <strong>top-The-World 状态</strong> )。 虽然在收集垃圾过程中需要暂停所有其它的工作线程，但是它简单高效，对于限定单个CPU环境来说，没有线程交互的开销可以 <strong>获得最高的单线程垃圾收集效率</strong> ，因此Serial垃圾收集器依然是Java虚拟机运行在 <strong>client模式下默认的新生代垃圾收集器</strong> </p>
<p>对应JVM参数是：-XX:+UseSerialGC</p>
<p>开启后会使用： <strong>Serial(Young区用) + Serial Old(Old区用) 的收集器组合</strong> </p>
<p>表示：新生代、老年代都会使用串行回收收集器，新生代使用复制算法，老年代使用标记-整理算法</p>
<div class="hljs"><pre><code class="hljs java">-Xms10m -Xmx10m -XX:+PrintGCDetails -XX:+PrintCommandLineFlags -XX:+UseSerialGC</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210422104815.png" srcset="/img/loading.gif"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210422105455.png" srcset="/img/loading.gif"></p>
<h4 id="并行GC-ParNew"><a href="#并行GC-ParNew" class="headerlink" title="并行GC(ParNew)"></a>并行GC(ParNew)</h4><p>并行收集器，使用 <strong>多线程</strong> 进行垃圾回收，在垃圾收集，会 <strong>Stop-the-World暂停</strong> 其他所有的工作线程直到它收集结束</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210422103943.png" srcset="/img/loading.gif"></p>
<p>ParNew收集器其实就是Serial收集器新生代的 <strong>并行多线程版本</strong> ，最常见的应用场景时配合老年代的CMS GC工作，其余的行为和Serial收集器完全一样，ParNew垃圾收集器在垃圾收集过程中同样也要暂停所有其他的工作线程。它是很多Java虚拟机运行在Server模式下新生代的默认垃圾收集器。</p>
<p>常见对应JVM参数：-XX:+UseParNewGC 启动ParNew收集器， <strong>只影响新生代的收集</strong> ，不影响老年代</p>
<p>开启上述参数后，会使用： <strong>ParNew（Young区用） + Serial Old</strong> 的收集器组合，新生代使用复制算法，老年代采用标记-整理算法</p>
<div class="hljs"><pre><code class="hljs java">-Xms10m -Xmx10m -XX:+PrintGCDetails -XX:+PrintCommandLineFlags -XX:+UseParNewGC</code></pre></div>

<p>但是会出现警告，即 ParNew 和 Serial Old 这样搭配，Java8已经 <strong>不再被推荐</strong> </p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210422105142.png" srcset="/img/loading.gif"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210422105402.png" srcset="/img/loading.gif"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210422105423.png" srcset="/img/loading.gif"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210422105559.png" srcset="/img/loading.gif"></p>
<p>备注： -XX:ParallelGCThreads 限制线程数量，默认开启和CPU数目相同的线程数</p>
<h4 id="并行回收GC（Parallel）-（Parallel-Scavenge）"><a href="#并行回收GC（Parallel）-（Parallel-Scavenge）" class="headerlink" title="并行回收GC（Parallel）/ （Parallel Scavenge）"></a>并行回收GC（Parallel）/ （Parallel Scavenge）</h4><p>因为Serial 和 ParNew都不推荐使用了，因此现在新生代默认使用的是Parallel Scavenge，也就是 <strong>新生代和老年代都是使用并行</strong> </p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210422110254.png" srcset="/img/loading.gif"></p>
<p>Parallel Scavenge收集器类似ParNew也是一个新生代垃圾收集器，使用 <strong>复制算法</strong> ，也是一个并行的多线程的垃圾收集器，俗称吞吐量优先收集器。一句话： <strong>串行收集器在新生代和老年代的并行化</strong> </p>
<p>它关注的重点是：</p>
<p> <strong>可控制的吞吐量</strong> （Thoughput = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间) ），也即比如程序运行100分钟，垃圾收集时间1分钟，吞吐量就是99%。高吞吐量意味着高效利用CPU时间，它多用于在后台运算而不需要太多交互的任务。</p>
<p> <strong>自适应调节策略</strong> 也是ParallelScavenge收集器与ParNew收集器的一个重要区别。（自适应调节策略：虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供 <strong>最合适的停顿时间</strong> ( -XX:MaxGCPauseMills)）或最大的吞吐量。</p>
<p>常用JVM参数： <strong>-XX:+UseParallelGC 或 -XX:+UseParallelOldGC</strong> （可互相激活）使用Parallel Scanvenge收集器</p>
<p>开启该参数后：新生代使用复制算法，老年代使用标记-整理算法</p>
<div class="hljs"><pre><code class="hljs java">-Xms10m -Xmx10m -XX:+PrintGCDetails -XX:+PrintCommandLineFlags -XX:+UseParallelGC</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210422111001.png" srcset="/img/loading.gif"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210422111021.png" srcset="/img/loading.gif"></p>
<h3 id="老年代下的垃圾收集器"><a href="#老年代下的垃圾收集器" class="headerlink" title="老年代下的垃圾收集器"></a>老年代下的垃圾收集器</h3><h4 id="串行GC（Serial-Old）-Serial-MSC"><a href="#串行GC（Serial-Old）-Serial-MSC" class="headerlink" title="串行GC（Serial Old） / (Serial MSC)"></a>串行GC（Serial Old） / (Serial MSC)</h4><p>Serial Old是Serial垃圾收集器 <strong>老年代版本</strong> ，它同样是一个单线程的收集器，使用标记-整理算法，这个收集器也主要是运行在Client默认的Java虚拟机中默认的老年代垃圾收集器</p>
<p>在Server模式下，主要有两个用途（了解，版本已经到8及以后）</p>
<ul>
<li>在JDK1.5之前版本中与新生代的Parallel Scavenge收集器 <strong>搭配</strong> 使用（Parallel Scavenge + Serial Old）</li>
<li>作为老年代版中使用CMS收集器的 <strong>后备垃圾收集方案</strong> 。</li>
</ul>
<p>配置方法：</p>
<div class="hljs"><pre><code class="hljs java">-Xms10m -Xmx10m -XX:+PrintGCDetails -XX:+PrintCommandLineFlags -XX:+UseSerialOldlGC</code></pre></div>

<p>该垃圾收集器，目前已经 <strong>不推荐使用</strong> 了</p>
<h4 id="并行GC（Parallel-Old）-（Parallel-MSC）"><a href="#并行GC（Parallel-Old）-（Parallel-MSC）" class="headerlink" title="并行GC（Parallel Old）/ （Parallel MSC）"></a>并行GC（Parallel Old）/ （Parallel MSC）</h4><p>Parallel Old收集器是Parallel Scavenge的老年代版本，使用多线程的标记-整理算法，Parallel Old收集器在JDK1.6才开始提供。</p>
<p>在JDK1.6之前，新生代使用ParallelScavenge收集器只能搭配老年代的Serial Old收集器，只能保证新生代的吞吐量优先，无法保证整体的吞吐量。在JDK1.6以前(Parallel Scavenge + Serial Old)</p>
<p>Parallel Old正是 <strong>为了在老年代同样提供吞吐量优先的垃圾收集器</strong> ，如果系统对吞吐量要求比较高，JDK1.8后可以考虑新生代Parallel Scavenge和老年代Parallel Old 收集器的搭配策略。在JDK1.8及后（Parallel Scavenge + Parallel Old）</p>
<p>JVM常用参数：</p>
<div class="hljs"><pre><code class="hljs java">-XX +UseParallelOldGC：使用Parallel Old收集器，设置该参数后，新生代Parallel+老年代 Parallel Old</code></pre></div>

<p>或者使用老年代并行收集器：</p>
<div class="hljs"><pre><code class="hljs java">-Xms10m -Xmx10m -XX:+PrintGCDetails -XX:+PrintCommandLineFlags -XX:+UseParallelOldlGC</code></pre></div>



<h4 id="并发标记清除GC（CMS）"><a href="#并发标记清除GC（CMS）" class="headerlink" title="并发标记清除GC（CMS）"></a>并发标记清除GC（CMS）</h4><p>CMS收集器（Concurrent Mark Sweep： <strong>并发标记清除</strong> (节约内存空间 容易留下内存碎片) ）是一种以 <strong>最短回收停顿时间为目标</strong> 的收集器</p>
<p>适合应用在互联网或者B/S系统的服务器上，这类应用尤其重视服务器的响应速度，希望系统停顿时间最短。</p>
<p>CMS非常适合堆内存大，CPU核数多的服务器端应用，也是G1出现之前大型应用的首选收集器。</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210422111728.png" srcset="/img/loading.gif"></p>
<p>四个步骤，1、3停顿，2、4交替执行</p>
<p>Concurrent Mark Sweep：并发标记清除，并发收集 <strong>低停顿</strong> ，并发指的是与用户线程一起执行</p>
<p>开启该收集器的JVM参数： -XX:+UseConcMarkSweepGC 开启该参数后，会自动将 -XX:+UseParNewGC打开，开启该参数后，使用ParNew(young 区用）+ CMS（Old 区用） + Serial Old 的收集器组合，Serial Old将作为CMS出错的后备收集器</p>
<div class="hljs"><pre><code class="hljs java">-Xms10m -Xmx10m -XX:+PrintGCDetails -XX:+UseConcMarkSweepGC</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210422112140.png" srcset="/img/loading.gif"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210422112204.png" srcset="/img/loading.gif"></p>
<h4 id="CMS-四个步骤"><a href="#CMS-四个步骤" class="headerlink" title="CMS 四个步骤"></a>CMS 四个步骤</h4><ul>
<li>初始标记（CMS initial mark）<ul>
<li>只是标记一个GC Roots 能直接关联的对象，速度很快，仍然 <strong>需要暂停</strong> 所有的工作线程</li>
</ul>
</li>
<li>并发标记（CMS concurrent mark）和用户线程一起<ul>
<li>进行GC Roots跟踪过程，和用户线程一起工作， <strong>不需要暂停</strong> 工作线程。主要标记过程，标记全部对象</li>
</ul>
</li>
<li>重新标记（CMS remark）<ul>
<li>为了修正在并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，仍然需要 <strong>暂停</strong> 所有的工作线程，由于并发标记时，用户线程依然运行，因此在正式清理前，再做修正</li>
</ul>
</li>
<li>并发清除（CMS concurrent sweep）和用户线程一起<ul>
<li>清除GC Roots不可达对象，和用户线程一起工作， <strong>不需要暂停</strong> 工作线程。基于标记结果，直接清理对象，由于耗时最长的并发标记和并发清除过程中，垃圾收集线程可以和用户现在一起并发工作，所以总体上来看CMS收集器的内存回收和用户线程是一起并发地执行。</li>
</ul>
</li>
</ul>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210422112630.png" srcset="/img/loading.gif"></p>
<p> <strong>优点</strong> ：并发收集低停顿</p>
<p> <strong>缺点</strong> ：并发执行，对 <em>CPU资源压力大</em>，采用的标记清除算法会  <strong><em>导致大量碎片</em></strong> </p>
<p>由于并发进行，CMS在收集与应用线程会同时 <strong>增加对堆内存的占用</strong> ，也就是说，CMS <strong>必须在老年代堆内存用尽之前完成垃圾回收</strong> ，否则CMS回收失败时，将 <strong>触发担保机制</strong> ，串行老年代收集器将会以 <strong>STW方式进行一次GC</strong> ，从而造成较大的停顿时间</p>
<p> <strong><em>标记清除算法无法整理空间碎片</em></strong> ，老年代空间会随着应用时长被逐步耗尽，最后将 <strong><em>不得不通过担保机制对堆内存进行压缩</em></strong> ，CMS也提供了参数 -XX:CMSFullGCSBeForeCompaction（默认0，即每次都进行内存整理）来指定多少次CMS收集之后，进行一次压缩的Full GC</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210422113429.png" srcset="/img/loading.gif"></p>
<h3 id="为什么新生代采用复制算法，老年代采用标整算法"><a href="#为什么新生代采用复制算法，老年代采用标整算法" class="headerlink" title="为什么新生代采用复制算法，老年代采用标整算法"></a>为什么新生代采用复制算法，老年代采用标整算法</h3><h4 id="新生代使用复制算法"><a href="#新生代使用复制算法" class="headerlink" title="新生代使用复制算法"></a>新生代使用复制算法</h4><p>因为新生代对象的生存时间比较短，80%的都要回收的对象，采用标记-清除算法则内存碎片化比较严重，采用复制算法可以灵活高效，且便与整理空间</p>
<h4 id="老年代采用标记整理"><a href="#老年代采用标记整理" class="headerlink" title="老年代采用标记整理"></a>老年代采用标记整理</h4><p>标记整理算法主要是为了解决标记清除算法存在内存碎片的问题，又解决了复制算法两个Survivor区的问题，因为老年代的空间比较大，不可能采用复制算法，特别占用内存空间</p>
<h3 id="垃圾收集器如何选择"><a href="#垃圾收集器如何选择" class="headerlink" title="垃圾收集器如何选择"></a>垃圾收集器如何选择</h3><ul>
<li>单CPU或者小内存，单机程序<ul>
<li>-XX:+UseSerialGC</li>
</ul>
</li>
<li>多CPU，需要最大的吞吐量，如后台计算型应用(大数据)<ul>
<li>-XX:+UseParallelGC（这两个相互激活）</li>
<li>-XX:+UseParallelOldGC</li>
</ul>
</li>
<li>多CPU，追求低停顿时间，需要快速响应如互联网应用<ul>
<li>-XX:+UseConcMarkSweepGC</li>
<li>-XX:+ParNewGC</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>参数</th>
<th>新生代垃圾收集器</th>
<th>新生代算法</th>
<th>老年代垃圾收集器</th>
<th>老年代算法</th>
</tr>
</thead>
<tbody><tr>
<td>-XX:+UseSerialGC</td>
<td>SerialGC</td>
<td>复制</td>
<td>SerialOldGC</td>
<td>标记整理</td>
</tr>
<tr>
<td>-XX:+UseParNewGC</td>
<td>ParNew</td>
<td>复制</td>
<td>SerialOldGC</td>
<td>标记整理</td>
</tr>
<tr>
<td>-XX:+UseParallelGC</td>
<td>Parallel [Scavenge]</td>
<td>复制</td>
<td>Parallel Old</td>
<td>标记整理</td>
</tr>
<tr>
<td>-XX:+UseConcMarkSweepGC</td>
<td>ParNew</td>
<td>复制</td>
<td>CMS + Serial Old的收集器组合，Serial Old作为CMS出错的后备收集器</td>
<td>标记清除</td>
</tr>
<tr>
<td>-XX:+UseG1GC</td>
<td>G1整体上采用标记整理算法</td>
<td>局部复制</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="G1垃圾收集器"><a href="#G1垃圾收集器" class="headerlink" title="G1垃圾收集器"></a>G1垃圾收集器</h3><h4 id="开启G1垃圾收集器"><a href="#开启G1垃圾收集器" class="headerlink" title="开启G1垃圾收集器"></a>开启G1垃圾收集器</h4><div class="hljs"><pre><code class="hljs java">-XX:+UseG1GC</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210423082401.png" srcset="/img/loading.gif"></p>
<p>heap区只有 garbage - first ，然后就是metaspace</p>
<h4 id="以前收集器的特点"><a href="#以前收集器的特点" class="headerlink" title="以前收集器的特点"></a>以前收集器的特点</h4><ul>
<li>年轻代和老年代是各自独立且连续的内存块</li>
<li>年轻代收集使用单eden + S0 + S1 进行复制算法</li>
<li>老年代收集必须扫描珍整个老年代区域</li>
<li>都是以尽可能少而快速地执行GC为设计原则</li>
</ul>
<h4 id="G1是什么"><a href="#G1是什么" class="headerlink" title="G1是什么"></a>G1是什么</h4><p>G1： <strong>Garbage-First 收集器</strong> ，是一款面向 <strong>服务端应用</strong> 的收集器，应用在多处理器和大容量内存环境中，在实现高吞吐量的同时，尽可能满足垃圾收集暂停时间的要求。另外，它还具有一下特征：</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210423082915.png" srcset="/img/loading.gif"></p>
<ul>
<li>像CMS收集器一样，能与应用程序 <strong>并发</strong> 执行</li>
<li>整理空闲空间更快</li>
<li> <strong>需要更多的时间来预测GC停顿时间</strong> </li>
<li>不希望牺牲大量的 <strong>吞吐量</strong> 性能</li>
<li>不需要更大的Java  <strong>Heap</strong> </li>
</ul>
<p>G1收集器设计目标是取代CMS收集器，它同CMS相比，在以下方面表现的 <strong>更出色</strong> </p>
<ul>
<li>G1是一个有整理内存过程的垃圾收集器， <strong>不会产生很多内存碎片</strong> 。</li>
<li>G1的Stop The World（STW） <strong>更可控</strong> ，G1在停顿时间上添加了 <strong>预测机制</strong> ，用户可以指定期望停顿时间。</li>
</ul>
<p> <strong>CMS垃圾收集器</strong> 虽然减少了暂停应用程序的运行时间，但是它还存在着内存碎片问题。于是，为了去除内存碎片问题，同时又保留CMS垃圾收集器低暂停时间的优点，JAVA7发布了一个新的垃圾收集器-G1垃圾收集器</p>
<p>G1是在2012年才在JDK1.7中可用，Oracle官方计划在JDK9中将G1变成默认的垃圾收集器以替代CMS，它是一款面向服务端应用的收集器，主要应用在多CPU和大内存服务器环境下，极大减少垃圾收集的停顿时间，全面提升服务器的性能，逐步替换Java8以前的CMS收集器</p>
<p>主要改变是：Eden，Survivor和Tenured等内存区域不再是连续了，而是变成一个个大小一样的 <strong>region</strong> ，每个region从1M到32M不等。一个region有可能属于Eden，Survivor或者Tenured内存区域。</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li>G1能充分利用多CPU，多核环境硬件优势，尽量 <strong>缩短STW</strong> </li>
<li>G1整体上采用标记-整理算法，局部是通过复制算法， <strong>不会产生内存碎片</strong> </li>
<li> <strong>宏观上</strong> 看G1之中 <strong>不再区分年轻代和老年代</strong> 。把内存划分成多个独立的子区域（Region），可以近似理解为一个围棋的棋盘</li>
<li>G1收集器里面将整个内存区域都混合在一起了，但其本身依然在 <strong>小范围内要进行年轻代和老年代的区分</strong> ，保留了新生代和老年代，但他们不再是物理隔离的，而是通过一部分Region的集合且不需要Region是连续的，也就是说依然会采取不同的GC方式来处理不同的区域</li>
<li>G1虽然也是分代收集器，但整个内存分区不存在物理上的年轻代和老年代的区别，也不需要完全独立的Survivor（to space）堆做复制准备，G1只有逻辑上的分代概念，或者说 <strong>每个分区都可能随G1的运行在不同代之间前后切换</strong> 。</li>
</ul>
<h4 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h4><p>Region区域化垃圾收集器，化整为零， <strong>打破了原来新生区和老年区的壁垒</strong> ，避免了全内存扫描，只需要按照区域来进行扫描即可。</p>
<p>区域化内存划片Region，整体遍为了一些列不连续的内存区域，避免了全内存区的GC操作。</p>
<p>核心思想是将整个堆内存区域分成大小相同的子区域（Region），在JVM启动时会自动设置子区域大小</p>
<p>在堆的使用上，G1并不要求对象的存储一定是物理上连续的，只要 <strong>逻辑上连续</strong> 即可，每个分区也不会固定地为某个代服务，可以按需在年轻代和老年代之间切换。启动时可以通过参数<code>-XX:G1HeapRegionSize=n</code> 可指定分区大小（1MB~32MB，且必须是2的幂），默认将整堆划分为2048个分区。</p>
<p>大小范围在1MB~32MB，最多能设置2048个区域，也即能够支持的最大内存为：32MB*2048 = 64G内存</p>
<h4 id="Region区域化垃圾收集器"><a href="#Region区域化垃圾收集器" class="headerlink" title="Region区域化垃圾收集器"></a>Region区域化垃圾收集器</h4><p>G1将新生代、老年代的物理空间划分取消了</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210423084628.png" srcset="/img/loading.gif"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210423084658.png" srcset="/img/loading.gif"></p>
<p>G1算法将堆划分为若干个区域（Reign），它仍然属于分代收集器。</p>
<p>这些Region的一部分包含 <strong>新生代</strong> ，新生代的垃圾收集依然采用暂停所有应用线程的方式，将存活对象拷贝到老年代或者Survivor空间</p>
<p>这些Region的一部分包含 <strong>老年代</strong> ，G1收集器通过将对象从一个区域复制到另外一个区域，完成了清理工作。这就意味着，在正常的处理过程中，G1完成了堆的压缩（至少是部分堆的压缩），这样也就不会有CMS内存碎片的问题存在了。</p>
<p>在G1中，还有一种特殊的区域，叫做 <strong>Humongous（巨大的）区域</strong> ，如果一个对象占用了空间超过了分区容量50%以上，G1收集器就认为这是一个 <strong>巨型对象</strong> ，这些巨型对象默认直接分配在老年代，但是如果他是一个短期存在的巨型对象，就会对垃圾收集器造成负面影响，为了解决这个问题，G1划分了一个 <strong>Humongous区</strong> ，它用来专门存放巨型对象。如果一个H区装不下一个巨型对象，那么G1会寻找连续的H区来存储，为了能找到连续的H区，有时候不得不启动Full GC。</p>
<h4 id="回收步骤"><a href="#回收步骤" class="headerlink" title="回收步骤"></a>回收步骤</h4><p>针对Eden区进行收集，Eden区耗尽后会被触发，主要是小区域收集 + 形成连续的内存块，避免内碎片</p>
<ul>
<li>Eden区的数据移动到Survivor区，加入出现Survivor区空间不够，Eden区数据会晋升到Old区</li>
<li>Survivor区的数据移动到新的Survivor区，部分数据晋升到Old区</li>
<li>最后Eden区收拾干净了，GC结束，用户的应用程序继续执行</li>
</ul>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210423085314.png" srcset="/img/loading.gif"></p>
<p>回收完成后</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210423085339.png" srcset="/img/loading.gif"></p>
<p>小区域收集 + 形成连续的内存块，最后在收集完成后，就会形成连续的内存空间，这样就解决了内存碎片的问题</p>
<h4 id="四步过程"><a href="#四步过程" class="headerlink" title="四步过程"></a>四步过程</h4><ul>
<li>初始标记：只标记GC Roots能直接关联到的对象</li>
<li>并发标记：进行GC Roots Tracing（链路扫描）的过程</li>
<li>最终标记：修正并发标记期间，因为程序运行导致标记发生变化的那一部分对象</li>
<li>筛选回收：根据时间来进行价值最大化回收</li>
</ul>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210423085542.png" srcset="/img/loading.gif"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210423085637.png" srcset="/img/loading.gif"></p>
<h4 id="参数配置"><a href="#参数配置" class="headerlink" title="参数配置"></a>参数配置</h4><p>开发人员仅仅需要申明以下参数即可</p>
<p>三步归纳：<code>-XX:+UseG1GC -Xmx32G -XX:MaxGCPauseMillis=100</code></p>
<p> <strong>开始G1+设置最大内存+设置最大停顿时间</strong> </p>
<p>-XX:MaxGCPauseMillis=n： <strong>最大GC停顿时间</strong> 单位 <strong>毫秒</strong> ，这是个软目标，JVM尽可能停顿小于这个时间</p>
<ul>
<li>-XX:+UseG1GC</li>
<li>-XX:G1HeapRegionSize=n：设置的G1区域的大小。值是2的幂，范围是1MB到32MB。目标是根据最小的Java堆大小划分出约2048个区域。</li>
<li>-XX:MaxGCPauseMillis=n：最大GC停顿时间，这是个软目标，JVM将尽可能（但不保证）停顿小于这个时间。</li>
<li>-XX:InitiatingHeapOccupancyPercent=n：堆占用了多少的时候就触发GC，默认为45。</li>
<li>-XX:ConcGCThreads=n：并发GC使用的线程数。</li>
<li>-XX:G1ReservePercent=n：设置作为空闲空间的预留内存百分比，以降低目标空间溢出的风险，默认值是10%。</li>
</ul>
<h4 id="G1和CMS比较"><a href="#G1和CMS比较" class="headerlink" title="G1和CMS比较"></a>G1和CMS比较</h4><ul>
<li>G1不会产生内碎片</li>
<li>是可以精准控制停顿。该收集器是把整个堆（新生代、老年代）划分成多个固定大小的区域，每次根据允许停顿的时间去收集垃圾最多的区域。</li>
</ul>
<h4 id="SpringBoot结合JVMGC"><a href="#SpringBoot结合JVMGC" class="headerlink" title="SpringBoot结合JVMGC"></a>SpringBoot结合JVMGC</h4><p>启动微服务时候，就可以带上JVM和GC的参数</p>
<ul>
<li>IDEA开发完微服务工程</li>
<li>maven进行clean package</li>
<li>要求微服务启动的时候，同时配置我们的JVM/GC的调优参数<ul>
<li>我们就可以根据具体的业务配置我们启动的JVM参数</li>
</ul>
</li>
<li>公式：<code>java -server jvm的各种参数 -jar 第1步上面的jar/war包名</code>。</li>
</ul>
<p>例如：</p>
<div class="hljs"><pre><code class="hljs java">java -Xms1024m -Xmx1024 -XX:UseG1GC -jar   xxx.jar</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210423090654.png" srcset="/img/loading.gif"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210423090628.png" srcset="/img/loading.gif"></p>
<h1 id="Linux相关命令"><a href="#Linux相关命令" class="headerlink" title="Linux相关命令"></a>Linux相关命令</h1><h2 id="Linux诊断原因"><a href="#Linux诊断原因" class="headerlink" title="Linux诊断原因"></a>Linux诊断原因</h2><h3 id="命令集合"><a href="#命令集合" class="headerlink" title="命令集合"></a>命令集合</h3><h4 id="整机：top，查看整机系统新能"><a href="#整机：top，查看整机系统新能" class="headerlink" title="整机：top，查看整机系统新能"></a>整机：top，查看整机系统新能</h4><blockquote>
<p>load average表示系统负载，即任务队列的平均长度。 三个数值分别为 1分钟、5分钟、15分钟前到现在的平均值。</p>
<p>load average: 如果这个数除以逻辑CPU的数量，结果高于5的时候就表明系统在超负荷运转了。</p>
<p><a target="_blank" rel="noopener" href="https://yjclsx.blog.csdn.net/article/details/81508455">Linux中top命令参数详解</a></p>
</blockquote>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210423095131.png" srcset="/img/loading.gif"></p>
<p>q退出，uptime精简版</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210423095451.png" srcset="/img/loading.gif"></p>
<p>使用top命令的话，重点关注的是  <strong>%CPU、%MEM 、load average</strong>  三个指标</p>
<ul>
<li>load average三个指标：分别代表1、5、15分钟的负载情况</li>
</ul>
<p>在这个命令下，按1的话，可以看到每个CPU的占用情况</p>
<p>uptime：系统性能命令的精简版</p>
<h4 id="CPU：vmstat"><a href="#CPU：vmstat" class="headerlink" title="CPU：vmstat"></a>CPU：vmstat</h4><ul>
<li><p>查看CPU（包含但是不限于）</p>
</li>
<li><p>查看额外</p>
<ul>
<li><p>查看所有CPU核信息：mpstat -P ALL 2</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210423101245.png" srcset="/img/loading.gif"></p>
</li>
<li><p>每个进程使用CPU的用量分解信息：pidstat -u 1 -p 进程编号</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210423101443.png" srcset="/img/loading.gif"></p>
</li>
</ul>
</li>
</ul>
<p>命令格式：<code>vmstat -n 2 3</code> 每 <strong>两秒</strong> 采样一次，共计 <strong>采样三次</strong> </p>
<p>一般vmstat工具的使用是通过两个数字参数来完成的，第一个参数是残阳的时间间隔数（单位秒），第二个参数是采样的次数</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210423095949.png" srcset="/img/loading.gif"></p>
<p><strong>procs</strong></p>
<p> r：运行和等待的CPU时间片的进程数，原则上1核的CPU的运行队列不要超过2，整个系统的运行队列不超过总核数的2倍，否则代表系统压力过大</p>
<p> b：等待资源的进程数，比如正在等待磁盘I/O、网络I/O等</p>
<p><strong>cpu</strong></p>
<p> us：用户进程消耗CPU时间百分比，us值高，用户进程消耗CPU时间多，如果长期大于50%，优化程序</p>
<p> sy：内核进程消耗的CPU时间百分比</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210423100524.png" srcset="/img/loading.gif"></p>
<p> us + sy 参考值为80%，如果us + sy 大于80%，说明可能存在CPU不足，从上面的图片可以看出，us + sy还没有超过百分80，因此说明CPU消耗不是很高</p>
<p> id：处于空闲的CPU百分比</p>
<p> wa：系统等待IO的CPU时间百分比</p>
<p> st：来自于一个虚拟机偷取的CPU时间比</p>
<h4 id="内存：free"><a href="#内存：free" class="headerlink" title="内存：free"></a>内存：free</h4><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210423101611.png" srcset="/img/loading.gif"></p>
<ul>
<li>应用程序可用内存数：free -m</li>
<li>应用程序可用内存/系统物理内存 &gt; 70% 内存充足</li>
<li>应用程序可用内存/系统物理内存 &lt; 20% 内存不足，需要增加内存</li>
<li>20% &lt; 应用程序可用内存/系统物理内存 &lt; 70%，表示内存基本够用</li>
</ul>
<p>free -h：以人类能看懂的方式查看物理内存</p>
<p>free -m：以MB为单位，查看物理内存</p>
<p>free -g：以GB为单位，查看物理内存(会取整)</p>
<p>查看额外</p>
<div class="hljs"><pre><code class="hljs java">pidstat -p 进程号 -r 采样间隔秒数</code></pre></div>

<h4 id="硬盘：df"><a href="#硬盘：df" class="headerlink" title="硬盘：df"></a>硬盘：df</h4><p>格式：<code>df -h /</code> (-h：human，表示以人类能看到的方式换算)</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210423102033.png" srcset="/img/loading.gif"></p>
<h4 id="磁盘IO：iostat"><a href="#磁盘IO：iostat" class="headerlink" title="磁盘IO：iostat"></a>磁盘IO：iostat</h4><p>系统慢有两种原因引起的，一个是CPU高，一个是大量IO操作</p>
<p>格式：<code>iostat -xdk 2 3</code></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210423102221.png" srcset="/img/loading.gif"></p>
<p>磁盘块设备分布</p>
<p>rkB /s：每秒读取数据量kB；</p>
<p>wkB/s：每秒写入数据量kB；</p>
<p>svctm I/O：请求的平均服务时间，单位毫秒</p>
<p>await I/O：请求的平均等待时间，单位毫秒，值越小，性能越好</p>
<p> <strong>util：一秒钟有百分几的时间用于I/O操作。接近100%时，表示磁盘带宽跑满，需要优化程序或者增加磁盘</strong> ；</p>
<p>rkB/s，wkB/s根据系统应用不同会有不同的值，但有规律遵循：长期、超大数据读写，肯定不正常，需要优化程序读取。</p>
<p>svctm的值与await的值很接近，表示几乎没有I/O等待，磁盘性能好，如果await的值远高于svctm的值，则表示I/O队列等待太长，需要优化程序或更换更快磁盘</p>
<h4 id="网络IO：ifstat"><a href="#网络IO：ifstat" class="headerlink" title="网络IO：ifstat"></a>网络IO：ifstat</h4><ul>
<li>默认本地没有，下载ifstat</li>
</ul>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210423102358.png" srcset="/img/loading.gif"></p>
<h2 id="CPU占用过高的定位分析思路"><a href="#CPU占用过高的定位分析思路" class="headerlink" title="CPU占用过高的定位分析思路"></a>CPU占用过高的定位分析思路</h2><p>记一次印象深刻的故障？</p>
<p>结合Linux 和 JDK命令一起分析，步骤如下</p>
<ul>
<li><p>使用top命令找出CPU占比最高的</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210423103045.png" srcset="/img/loading.gif"></p>
<p>我们先写一个死循环</p>
<p>然后用top查看</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210423103137.png" srcset="/img/loading.gif"></p>
</li>
<li><p>ps -ef 或者 jps 进一步定位，得知是一个怎么样的后台程序出的问题</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210423103251.png" srcset="/img/loading.gif"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210423103310.png" srcset="/img/loading.gif"></p>
<p>30296 TestCpu</p>
</li>
<li><p>定位到具体线程或者代码</p>
<ul>
<li><p>ps -mp 进程 -o THREAD，tid，time</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210423103453.png" srcset="/img/loading.gif"></p>
<p>root     98.7  19    - -         -      - 30307 00:04:51</p>
<p>30307是线程id</p>
</li>
<li><p>参数解释</p>
<ul>
<li>-m：显示所有的线程</li>
<li>-p：pid进程使用CPU的时间</li>
<li>-o：该参数后是用户自定义格式</li>
</ul>
</li>
</ul>
</li>
<li><p>将需要的线程ID转换为16进制格式（英文小写格式）</p>
<ul>
<li><p>printf “%x\n” 有问题的线程ID</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210423103714.png" srcset="/img/loading.gif"></p>
</li>
</ul>
</li>
<li><p>jstack 进程ID | grep tid（16进制线程ID小写英文） -A60</p>
<p>精准定位到错误的地方</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210423104317.png" srcset="/img/loading.gif"></p>
</li>
</ul>
<h2 id="JDK-自带工具排查"><a href="#JDK-自带工具排查" class="headerlink" title="JDK 自带工具排查"></a>JDK 自带工具排查</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u011863024/article/details/106651068">jdk</a></p>
<h1 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h1><h2 id="常用词含义"><a href="#常用词含义" class="headerlink" title="常用词含义"></a>常用词含义</h2><ul>
<li>watch：会持续收到该项目的 <strong>动态</strong> </li>
<li>fork： <strong>复制</strong> 某个仓库到自己的Github仓库中</li>
<li>star：可以理解为点赞</li>
<li>clone：将项目下载至本地</li>
<li>follow：关注你感兴趣的作者，会收到他们的动态</li>
</ul>
<h2 id="in关键字限制搜索范围"><a href="#in关键字限制搜索范围" class="headerlink" title="in关键字限制搜索范围"></a>in关键字限制搜索范围</h2><ul>
<li>公式：<code>XXX关键字 in:name 或 description 或 readme</code></li>
<li>xxx in:name 项目名称含有XXX的</li>
<li>xxx in:description 项目描述含有XXX的</li>
<li>xxx in:readme 项目的readme文件中包含XXX的</li>
<li>组合使用<ul>
<li>xxx in:name,readme 项目的名称和readme中包含xxx的</li>
</ul>
</li>
</ul>
<h2 id="stars或fork数量关键字查找"><a href="#stars或fork数量关键字查找" class="headerlink" title="stars或fork数量关键字查找"></a>stars或fork数量关键字查找</h2><ul>
<li>公式：<ul>
<li><code>xxx关键字 stars 通配符</code> :&gt; 或者 :&gt;=</li>
<li>区间范围数字： <code>stars:数字1..数字2</code></li>
</ul>
</li>
<li>案例<ul>
<li>查找stars数大于等于5000的Springboot项目：springboot stars:&gt;=5000</li>
<li>查找forks数在1000~2000之间的springboot项目：springboot forks:1000..5000</li>
</ul>
</li>
<li>组合使用<ul>
<li>查找star大于1000，fork数在500到1000：<code>springboot stars:&gt;1000 forks:500..1000</code></li>
</ul>
</li>
</ul>
<h2 id="awesome加强搜索"><a href="#awesome加强搜索" class="headerlink" title="awesome加强搜索"></a>awesome加强搜索</h2><ul>
<li>公式：<code>awesome 关键字</code>：awesome系列，一般用来收集学习、工具、书籍类相关的项目</li>
<li>搜索优秀的redis相关的项目，包括框架，教程等 awesome redis</li>
</ul>
<h2 id="高亮显示某行代码"><a href="#高亮显示某行代码" class="headerlink" title="高亮显示某行代码"></a>高亮显示某行代码</h2><ul>
<li>一行：地址后面紧跟 #L10<ul>
<li><code>https://github.com/moxi624/mogu_blog_v2/blob/master/mogu_admin/pom.xml#L13</code></li>
</ul>
</li>
<li>多行：地址后面紧跟 #Lx - #Ln<ul>
<li><code>https://github.com/moxi624/mogu_blog_v2/blob/master/mogu_admin/pom.xml#L13-L30</code></li>
</ul>
</li>
</ul>
<h2 id="项目内搜索"><a href="#项目内搜索" class="headerlink" title="项目内搜索"></a>项目内搜索</h2><ul>
<li>使用英文字母 <code>t</code> ,开启项目内搜索</li>
</ul>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/04/11/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%983/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">高频面试题2</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/01/11/%E2%80%9C%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6%E2%80%9D%E7%9A%84%E5%89%AF%E6%9C%AC%202/">
                        <span class="hidden-mobile">算法进阶</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments">
                
                

              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":200})
    NProgress.start()
    document.addEventListener('DOMContentLoaded', function() {
      window.NProgress && window.NProgress.inc();
    })
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.staticfile.org/jquery/3.5.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.staticfile.org/tocbot/4.12.0/tocbot.min.js" ></script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>





  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      var inputArea = document.querySelector("#local-search-input");
      inputArea.onclick = function () {
        searchFunc(path, 'local-search-input', 'local-search-result');
        this.onclick = null
      }
    })()
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>



<!-- hexo injector body_end start -->
  <script src="/js/custom.js"></script>
<!-- hexo injector body_end end --></body>
</html>
