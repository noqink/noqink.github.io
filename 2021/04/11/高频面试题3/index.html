

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/imgfavicon.jpg">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  <title>高频面试题2 - Blog</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.1.2/styles/ocean.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.5","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"copy_btn":true,"image_zoom":{"enable":true},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.2.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Main</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax=true
         style="background: url('https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/imgdefault.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="高频面试题2">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-04-11 11:11" pubdate>
        2021年4月11日 上午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      19.3k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      245
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">高频面试题2</h1>
            
            <div class="markdown-body">
              <h1 id="String-intern-的作用"><a href="#String-intern-的作用" class="headerlink" title="String.intern()的作用"></a>String.intern()的作用</h1><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> String <span class="hljs-title">intern</span><span class="hljs-params">()</span></span>;</code></pre></div>

<p>由于<code>运行时常量池</code>是<code>方法区</code>的一部分，所以这两个区域的溢出测试可以放到一起进行。HotSpot从JDK 7开始逐步“去永久代”的计划，并在JDK 8中完全使用元空间来代替永久代的背景故事，在此我们就以测试代码来观察一下，使用”永久代”还是“元空间”来实现方法区，对程序有什么实际的影响。</p>
<p>读一遍 <code>intern()</code> 方法的注释：当 <code>intern()</code> 方法被调用时</p>
<ol>
<li>如果字符串常量池中已经包含了此字符串（通过 <code>equals()</code> 方法判断），那么就将此字符串返回</li>
<li>否则，该字符串将被添加至字符串常量池中，并且返回该字符串在常量池中的引用</li>
</ol>
<p>在JDK 6或更早之前的HotSpot虚拟机中，常量池都是分配在永久代中，我们可以通过-XX:PermSize和-XX:MaxPermSize限制永久代的大小，即可间接限制其中常量池的容量。</p>
<h2 id="1-Demo-测试"><a href="#1-Demo-测试" class="headerlink" title="1. Demo 测试"></a>1. Demo 测试</h2><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringPool58Demo</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;

        String str1 = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-string">&quot;58&quot;</span>).append(<span class="hljs-string">&quot;tongcheng&quot;</span>).toString();
        System.out.println(str1);
        System.out.println(str1.intern());
        System.out.println(str1 == str1.intern());

        System.out.println(<span class="hljs-string">&quot;------------&quot;</span>);

        String str2 = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-string">&quot;ja&quot;</span>).append(<span class="hljs-string">&quot;va&quot;</span>).toString();
        System.out.println(str2);
        System.out.println(str2.intern());
        System.out.println(str2 == str2.intern());
				<span class="hljs-comment">// 只有java是false</span>
    &#125;
&#125;</code></pre></div>

<div class="hljs"><pre><code class="hljs java">58tongcheng
58tongcheng
<span class="hljs-keyword">true</span>
------------
java
java
<span class="hljs-keyword">false</span> <span class="hljs-comment">// 只有java是false</span></code></pre></div>

<blockquote>
<p>为什么java是false？</p>
</blockquote>
<p>有一个初始化的 <code>&quot;java&quot;</code> 字符串(JDK 出娘胎自带的)， 在加载 <code>sun.misc.Version</code> 这个类的时候进入常量池</p>
<h2 id="2-问题推导"><a href="#2-问题推导" class="headerlink" title="2. 问题推导"></a>2. 问题推导</h2><p><code>System</code> 类 → <code>initializeSystemClass()</code> 方法 → <code>Version</code> 类 → 类加载器和 rt.jar → OpenJDK8源码</p>
<h3 id="1）System类"><a href="#1）System类" class="headerlink" title="1）System类"></a>1）System类</h3><p>虚拟机会调用 <code>System.initializeSystemClass()</code> 方法完成对 <code>System</code> 类的初始化</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210511091135.png" srcset="/img/loading.gif"></p>
<h3 id="2）initializeSystemClass-方法"><a href="#2）initializeSystemClass-方法" class="headerlink" title="2）initializeSystemClass()方法"></a>2）initializeSystemClass()方法</h3><p>在 <code>initializeSystemClass()</code> 方法中调用 <code>sun.misc.Version.init()</code> 完成了一些初始化工作</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210511091516.png" srcset="/img/loading.gif"></p>
<h3 id="3）Version类"><a href="#3）Version类" class="headerlink" title="3）Version类"></a>3）Version类</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210511091552.png" srcset="/img/loading.gif"></p>
<h3 id="4）类加载器和-rt-jar"><a href="#4）类加载器和-rt-jar" class="headerlink" title="4）类加载器和 rt.jar"></a>4）类加载器和 rt.jar</h3><p>根加载器 bootstrap 会提前部署加载 rt.jar，Version 这个类就在 rt.jar 包中，位于 sun.misc 包下</p>
<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210511091655.png" srcset="/img/loading.gif" style="zoom:50%;" />

<h3 id="5）OpenJDK8源码"><a href="#5）OpenJDK8源码" class="headerlink" title="5）OpenJDK8源码"></a>5）OpenJDK8源码</h3><p>官网地址：<a target="_blank" rel="noopener" href="http://openjdk.java.net/">http://openjdk.java.net/</a></p>
<p>类所在的路径：openjdk8\jdk\srclshare\classes\sun\misc</p>
<h3 id="6）JVM书籍"><a href="#6）JVM书籍" class="headerlink" title="6）JVM书籍"></a>6）JVM书籍</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210511093939.png" srcset="/img/loading.gif"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210511094219.png" srcset="/img/loading.gif"></p>
<h1 id="AQS面试"><a href="#AQS面试" class="headerlink" title="AQS面试"></a>AQS面试</h1><h2 id="1-题型"><a href="#1-题型" class="headerlink" title="1. 题型"></a>1. 题型</h2><ul>
<li>Synchronized 用过吗，其原理是什么？</li>
<li>你刚才提到获取对象的锁，这个“锁”到底是什么？如何确定对象的锁</li>
<li>什么是可重入性，为什么说Synchronized 是可重入锁？</li>
<li>JVM对Java的原生锁做了哪些优化？</li>
<li>为什么说Synchronized是非公平锁？</li>
<li>什么是锁消除和锁粗化？</li>
<li>为什么说Synchronized是一个悲观锁？乐观锁的实现原理又是什么？什么是CAS，它有什么优点和缺点？</li>
<li>乐观锁一定就是好的吗？</li>
</ul>
<h2 id="2-可重入锁"><a href="#2-可重入锁" class="headerlink" title="2. 可重入锁"></a>2. 可重入锁</h2><ol>
<li>跟Synchronized相比，可重入锁ReentrantLock 其实现原理有什么不同？</li>
<li>那么请谈谈AQS框架是怎么回事儿？</li>
<li>请尽可能详尽地对比下Synchronized 和ReentrantLock的异同。</li>
<li>ReentrantLock 是如何实现可重入性的？</li>
</ol>
<h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1) 概念"></a>1) 概念</h3><p>可重入锁又名<code>递归锁</code>，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁(前提，<code>锁对象得是同一个对象</code>)，不会因为之前已经获取过还没释放而阻塞。</p>
<p>一个线程中的多个流程可以获取同一把锁，持有这把同步锁可以再次进入。即自己可以获取自己的内部锁</p>
<p>Java中ReentrantLock和synchronized都是可重入锁，可重入锁的一个优点是<code>可一定程度避免死锁</code>。</p>
<h3 id="2-可重入锁种类"><a href="#2-可重入锁种类" class="headerlink" title="2) 可重入锁种类"></a>2) 可重入锁种类</h3><h4 id="隐式锁"><a href="#隐式锁" class="headerlink" title="隐式锁"></a>隐式锁</h4><p>隐式锁（即synchronized关键字使用的锁）默认是可重入锁</p>
<ul>
<li>同步代码块代码测试</li>
</ul>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReEnterLockDemo</span> </span>&#123;
    
    <span class="hljs-comment">// synchronized 同步代码块可重入演示</span>
    <span class="hljs-keyword">static</span> Object objectLockA = <span class="hljs-keyword">new</span> Object();

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m1</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
            <span class="hljs-keyword">synchronized</span> (objectLockA) &#123;
                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t&quot;</span> + <span class="hljs-string">&quot;------外层调用&quot;</span>);
                <span class="hljs-keyword">synchronized</span> (objectLockA) &#123;
                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t&quot;</span> + <span class="hljs-string">&quot;------中层调用&quot;</span>);
                    <span class="hljs-keyword">synchronized</span> (objectLockA) &#123;
                        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t&quot;</span> + <span class="hljs-string">&quot;------内层调用&quot;</span>);
                    &#125;
                &#125;
            &#125;
        &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();

    &#125;
&#125;</code></pre></div>

<p>程序运行结果：在同一个线程内部成功获取同一把锁</p>
<ul>
<li>同步方法</li>
</ul>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReEnterLockDemo</span> </span>&#123;
    <span class="hljs-comment">// synchronized 同步方法可重入演示</span>

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m1</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;=====外层&quot;</span>);
        m2();
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m2</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;=====中层&quot;</span>);
        m3();
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m3</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;=====内层&quot;</span>);
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        <span class="hljs-keyword">new</span> ReEnterLockDemo().m1();
    &#125;
&#125;</code></pre></div>

<ul>
<li>原理</li>
</ul>
<p>使用 <code>javap -c xxx.class</code> 指令反编译字节码文件，可以看到有一对配对出现的 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，一个对应于加锁，一个对应于解锁</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210511095744.png" srcset="/img/loading.gif"></p>
<p>为什么会多出来一个 <code>monitorexit</code> 指令呢？</p>
<p>如果同步代码块中出现Exception或者Error，则会调用第二个<code>monitorexit</code>指令来保证释放锁</p>
<blockquote>
<p>结论</p>
</blockquote>
<p>每个锁对象拥有一个<code>锁计数器</code>和一个<code>指向持有该锁的线程的指针</code>。</p>
<p>当执行monitorenter时，如果目标锁对象的计数器为零，那么说明它没有被其他线程所持有，Java虚拟机会将该锁对象的持有线程设置为当前线程，并且将其计数器加1。</p>
<p>在目标锁对象的计数器不为零的情况下，如果锁对象的持有线程<code>是当前线程</code>，那么Java虚拟机可以将其计数器加1，否则需要等待，直至持有线程释放该锁。</p>
<p>当执行monitorexit时，Java虚拟机则需将锁对象的计数器减1。计数器为零代表锁已被释放。</p>
<h4 id="显示锁"><a href="#显示锁" class="headerlink" title="显示锁"></a>显示锁</h4><p>显式锁（即Lock）也有ReentrantLock这样的可重入锁。</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReEnterLockDemo</span> </span>&#123;
    <span class="hljs-comment">// ReentrantLock 可重入演示</span>
    <span class="hljs-keyword">static</span> Lock lock = <span class="hljs-keyword">new</span> ReentrantLock();

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
            lock.lock();
            <span class="hljs-keyword">try</span> &#123;
                System.out.println(<span class="hljs-string">&quot;=======外层&quot;</span>);
                lock.lock();
                <span class="hljs-keyword">try</span> &#123;
                    System.out.println(<span class="hljs-string">&quot;=======内层&quot;</span>);
                &#125; <span class="hljs-keyword">finally</span> &#123;
                    lock.unlock(); <span class="hljs-comment">//正常情况，加锁几次就要解锁几次</span>
                &#125;
            &#125; <span class="hljs-keyword">finally</span> &#123;
                lock.unlock(); <span class="hljs-comment">//正常情况，加锁几次就要解锁几次</span>
            &#125;
        &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();       
    &#125;
&#125;</code></pre></div>

<p>程序运行结果：在同一个线程内部成功获取同一把锁</p>
<blockquote>
<p>注意： <strong>加锁几次就要解锁几次</strong> </p>
</blockquote>
<h2 id="3-LockSupport"><a href="#3-LockSupport" class="headerlink" title="3. LockSupport"></a>3. LockSupport</h2><h3 id="1-概念-1"><a href="#1-概念-1" class="headerlink" title="1) 概念"></a>1) 概念</h3><p>LockSupport是<code>用来创建锁和其他同步类的基本线程阻塞原语</code>。</p>
<p>LockSupport中的park()和unpark()的作用分别是阻塞线程和解除阻塞线程，可以将其看作是线程等待唤醒机制(wait/notify)的加强版</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210511100807.png" srcset="/img/loading.gif"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210511102443.png" srcset="/img/loading.gif"></p>
<h3 id="2-3种线程等待唤醒的方法"><a href="#2-3种线程等待唤醒的方法" class="headerlink" title="2) 3种线程等待唤醒的方法"></a>2) 3种线程等待唤醒的方法</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210511102720.png" srcset="/img/loading.gif"></p>
<ul>
<li><p>方式1: 使用Object中的wait()方法让线程等待， 使用Object中的notify()方法唤醒线程</p>
</li>
<li><p>方式2: 使用JUC包中Condition的await()方法让线程等待，使用signal()方法唤醒线程</p>
</li>
<li><p>方式3: LockSupport类可以阻塞当前线程以及唤醒指定被阻塞的线程</p>
</li>
</ul>
<h4 id="Object-类"><a href="#Object-类" class="headerlink" title="Object 类"></a>Object 类</h4><p>Object类中的wait和notify方法实现线程等待和唤醒</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">static</span> Object objectLock = <span class="hljs-keyword">new</span> Object();

<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">synchronizedWaitNotify</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
        <span class="hljs-keyword">synchronized</span> (objectLock) &#123;
            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t&quot;</span> + <span class="hljs-string">&quot;------come in&quot;</span>);
            <span class="hljs-keyword">try</span> &#123;
                objectLock.wait(); <span class="hljs-comment">// 等待</span>
            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t&quot;</span> + <span class="hljs-string">&quot;------被唤醒&quot;</span>);
        &#125;
    &#125;, <span class="hljs-string">&quot;A&quot;</span>).start();

    <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
        <span class="hljs-keyword">synchronized</span> (objectLock) &#123;
            objectLock.notify(); <span class="hljs-comment">// 唤醒</span>
            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t&quot;</span> + <span class="hljs-string">&quot;------通知&quot;</span>);
        &#125;
    &#125;, <span class="hljs-string">&quot;B&quot;</span>).start();
&#125;</code></pre></div>

<p>程序运行结果：A 线程先执行，执行 <code>objectLock.wait()</code> 后被阻塞，B 线程在 A 线程之后执行 <code>objectLock.notify()</code> 将 A线程唤醒</p>
<p> <strong>不在 synchronized 关键字中使用 wait() 和 notify() 方法</strong> </p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">static</span> Object objectLock = <span class="hljs-keyword">new</span> Object();

<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">synchronizedWaitNotify</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
        <span class="hljs-comment">//synchronized (objectLock) &#123;</span>
        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t&quot;</span> + <span class="hljs-string">&quot;------come in&quot;</span>);
        <span class="hljs-keyword">try</span> &#123;
            objectLock.wait(); <span class="hljs-comment">// 等待</span>
        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t&quot;</span> + <span class="hljs-string">&quot;------被唤醒&quot;</span>);
        <span class="hljs-comment">//&#125;</span>
    &#125;, <span class="hljs-string">&quot;A&quot;</span>).start();

    <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
        <span class="hljs-comment">//synchronized (objectLock) &#123;</span>
        objectLock.notify(); <span class="hljs-comment">// 唤醒</span>
        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t&quot;</span> + <span class="hljs-string">&quot;------通知&quot;</span>);
        <span class="hljs-comment">//&#125;</span>
    &#125;, <span class="hljs-string">&quot;B&quot;</span>).start();
&#125;</code></pre></div>

<p>不在 synchronized 关键字中使用 wait() 和 notify() 方法 ，将抛出 <code>java.lang.IllegalMonitorStateException</code> 异常</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210511102925.png" srcset="/img/loading.gif"></p>
<p> <strong>先 notify() 后 wait()</strong> </p>
<p>B 线程先执行 <code>objectLock.notify()</code>，A 线程再执行 <code>objectLock.wait()</code>，这样 A 线程无法被唤醒</p>
<blockquote>
<p>总结</p>
<p>wait和notify方法必须要在 <code>同步块或者方法</code> 里面且成对出现使用</p>
<p>先wait后notify才OK</p>
</blockquote>
<h4 id="Condition接口"><a href="#Condition接口" class="headerlink" title="Condition接口"></a>Condition接口</h4><p>Condition接口中的await后signal方法实现线程的等待和唤醒</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">static</span> Lock lock = <span class="hljs-keyword">new</span> ReentrantLock();
<span class="hljs-keyword">static</span> Condition condition = lock.newCondition();

<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lockAwaitSignal</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
        lock.lock();
        <span class="hljs-keyword">try</span> &#123;
            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t&quot;</span> + <span class="hljs-string">&quot;------come in&quot;</span>);
            <span class="hljs-keyword">try</span> &#123;
                condition.await();
            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t&quot;</span> + <span class="hljs-string">&quot;------被唤醒&quot;</span>);
        &#125; <span class="hljs-keyword">finally</span> &#123;
            lock.unlock();
        &#125;
    &#125;, <span class="hljs-string">&quot;A&quot;</span>).start();


    <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
        lock.lock();
        <span class="hljs-keyword">try</span> &#123;
            condition.signal();
            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t&quot;</span> + <span class="hljs-string">&quot;------通知&quot;</span>);
        &#125; <span class="hljs-keyword">finally</span> &#123;
            lock.unlock();
        &#125;
    &#125;, <span class="hljs-string">&quot;B&quot;</span>).start();
&#125;</code></pre></div>

<p>A 线程先执行，执行 <code>condition.await()</code> 后被阻塞，B 线程在 A 线程之后执行 <code>condition.signal()</code> 将 A线程唤醒</p>
<p> <strong>不在 lock() 和 unlock() 方法内使用 await() 和 signal() 方法</strong> </p>
<p>不在 lock() 和 unlock() 方法内使用 await() 和 signal() 方法，将抛出 <code>java.lang.IllegalMonitorStateException</code> 异常</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210511103115.png" srcset="/img/loading.gif"></p>
<h4 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h4><p><strong>传统的 synchronized 和 Lock 实现等待唤醒通知的约束</strong> </p>
<ul>
<li><p>线程先要获得并持有锁，必须在锁块（synchronized或lock）中</p>
</li>
<li><p>必须要先等待后唤醒，线程才能够被唤醒</p>
</li>
</ul>
<h4 id="LockSupport-类"><a href="#LockSupport-类" class="headerlink" title="LockSupport 类"></a>LockSupport 类</h4><p>LockSupport 类使用了一种名为<code>permit（许可）</code>的概念来做到<code>阻塞和唤醒线程</code>的功能，每个线程都有一个许可（permit），permit 只有两个值 1 和零，默认是零。</p>
<p>可以把许可看成是一种（0, 1）信号量（Semaphore），但与 Semaphore 不同的是，许可的累加上限是 1。</p>
<h5 id="LockSupport-的主要方法"><a href="#LockSupport-的主要方法" class="headerlink" title="LockSupport 的主要方法"></a>LockSupport 的主要方法</h5><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210511103622.png" srcset="/img/loading.gif"></p>
<h5 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h5><p>park()/park(Object blocker)</p>
<p>park() 方法的作用：阻塞当前线程/阻塞传入的具体线程</p>
<p>permit 默认是 0，所以一开始调用 park() 方法，当前线程就会阻塞，直到别的线程将当前线程的 permit 设置为 1 时，park() 方法会被唤醒，然后会将 permit 再次设置为 0 并返回。</p>
<p><code>park()</code> 方法通过 <code>Unsafe 类实现</code></p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// Disables the current thread for thread scheduling purposes unless the permit is available.</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">park</span><span class="hljs-params">()</span> </span>&#123;
    UNSAFE.park(<span class="hljs-keyword">false</span>, <span class="hljs-number">0L</span>);
&#125;</code></pre></div>

<h5 id="唤醒"><a href="#唤醒" class="headerlink" title="唤醒"></a>唤醒</h5><p>unpark(Thread thread)</p>
<p>unpark() 方法的作用：唤醒处于阻断状态的指定线程</p>
<p>调用 unpark(thread) 方法后，就会将 thread 线程的许可 permit 设置成 1（注意多次调用 unpark()方法，不会累加，permit 值还是 1），这会自动唤醒 thread 线程，即之前阻塞中的LockSupport.park()方法会立即返回。</p>
<p><code>unpark()</code> 方法通过 <code>Unsafe 类实现</code></p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// Makes available the permit for the given thread</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unpark</span><span class="hljs-params">(Thread thread)</span> </span>&#123;
    <span class="hljs-keyword">if</span> (thread != <span class="hljs-keyword">null</span>)
        UNSAFE.unpark(thread);
&#125;</code></pre></div>

<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lockSupportParkUnpark</span><span class="hljs-params">()</span> </span>&#123;
    Thread a = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t&quot;</span> + <span class="hljs-string">&quot;------come in&quot;</span>);
        LockSupport.park(); <span class="hljs-comment">// 线程 A 阻塞</span>
        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t&quot;</span> + <span class="hljs-string">&quot;------被唤醒&quot;</span>);
    &#125;, <span class="hljs-string">&quot;A&quot;</span>);
    a.start();

    <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
        LockSupport.unpark(a); <span class="hljs-comment">// B 线程唤醒线程 A</span>
        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t&quot;</span> + <span class="hljs-string">&quot;------通知&quot;</span>);
    &#125;, <span class="hljs-string">&quot;B&quot;</span>).start();
&#125;</code></pre></div>

<p>A 线程先执行 <code>LockSupport.park()</code> 方法将通行证（permit）设置为 0，其实这并没有什么鸟用，因为 permit 初始值本来就为 0，然后 B 线程执行 <code>LockSupport.unpark(a)</code> 方法将 permit 设置为 1，此时 A 线程可以通行</p>
<blockquote>
<p>如果先unpark？</p>
</blockquote>
<p>因为引入了通行证的概念，所以先唤醒（<code>unpark()</code>）其实并不会有什么影响，从程序运行结果可以看出，A 线程执行 <code>LockSupport.park()</code> 时并没有被阻塞</p>
<h5 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h5><p>  **没有考虑到 permit 上限值为 1 **</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lockSupportParkUnpark</span><span class="hljs-params">()</span> </span>&#123;
    Thread a = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
        <span class="hljs-keyword">try</span> &#123;
            TimeUnit.SECONDS.sleep(<span class="hljs-number">3L</span>);
        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t&quot;</span> + <span class="hljs-string">&quot;------come in&quot;</span> + System.currentTimeMillis());
        LockSupport.park();
        LockSupport.park();
        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t&quot;</span> + <span class="hljs-string">&quot;------被唤醒&quot;</span> + System.currentTimeMillis());
    &#125;, <span class="hljs-string">&quot;A&quot;</span>);
    a.start();

    <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
        LockSupport.unpark(a);
        LockSupport.unpark(a);
        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t&quot;</span> + <span class="hljs-string">&quot;------通知&quot;</span>);
    &#125;, <span class="hljs-string">&quot;B&quot;</span>).start();
&#125;</code></pre></div>

<p>由于 permit 的上限值为 1，所以执行两次 <code>LockSupport.park()</code> 操作将导致 A 线程阻塞:<code>线程阻塞需要消耗凭证(permit)，这个凭证最多只有1个。</code></p>
<h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3) 总结"></a>3) 总结</h3><blockquote>
<p> 1、LockSupport是用来创建锁和其他同步类的基本线程阻塞原语</p>
</blockquote>
<p>LockSupport是一个线程阻塞工具类，所有的方法都是<code>静态方法</code>，可以让线程在任意位置阻塞，阻塞之后也有对应的唤醒方法。归根结底，<code>LockSupport调用的Unsafe中的native代码</code>。</p>
<blockquote>
<p>2、LockSupport提供park()和unpark()方法实现阻塞线程和解除线程阻塞的过程</p>
</blockquote>
<p>LockSupport和每个使用它的线程都有一个许可(permit)关联。permit相当于1，0的开关，默认是0，调用一次unpark就加1变成1，调用一次park会消费permit，也就是将1变成0，同时park立即返回。</p>
<p>如再次调用park会变成阻塞(因为permit为零了会阻塞在这里，一直到permit变为1)，这时调用unpark会把permit置为1。</p>
<p>每个线程都有一个相关的permit，<code>permit最多只有一个，重复调用unpark也不会积累凭证</code>。</p>
<blockquote>
<p>3、形象的理解</p>
</blockquote>
<p><code>线程阻塞需要消耗凭证(permit)，这个凭证最多只有1个。</code></p>
<ul>
<li>当调用park方法时<ul>
<li>如果有凭证，则会<code>直接消耗掉</code>这个凭证然后正常退出;</li>
<li>如果无凭证，就必须阻塞等待凭证可用;</li>
</ul>
</li>
<li>而unpark则相反，它<code>会增加一个凭证，但凭证最多只能有1个</code>，累加无效。</li>
</ul>
<h3 id="4-LockSupport-面试题"><a href="#4-LockSupport-面试题" class="headerlink" title="4) LockSupport 面试题"></a>4) LockSupport 面试题</h3><blockquote>
<p>为什么可以先唤醒线程后阻塞线程?</p>
</blockquote>
<p>因为unpark获得了一个凭证，之后再调用park方法，就可以名正言顺的凭证消费，故不会阻塞。</p>
<blockquote>
<p>为什么唤醒两次后阻塞两次，但最终结果还会阻塞线程?</p>
</blockquote>
<p>因为凭证的数量最多为1，连续调用两次unpark和调用一次unpark效果一样，只会增加一个凭证；而调用两次park却需要消费两个凭证，证不够，不能放行。</p>
<h2 id="4-AbstractQueuedSynchronizer"><a href="#4-AbstractQueuedSynchronizer" class="headerlink" title="4. AbstractQueuedSynchronizer"></a>4. AbstractQueuedSynchronizer</h2><p>AbstractQueuedSynchronizer之AQS：抽象的队列同步器</p>
<h3 id="1-AQS-前置知识"><a href="#1-AQS-前置知识" class="headerlink" title="1) AQS 前置知识"></a>1) AQS 前置知识</h3><blockquote>
<p><strong>前置知识</strong></p>
</blockquote>
<ol>
<li>公平锁和非公平锁</li>
<li>可重入锁</li>
<li>LockSupport</li>
<li>自旋锁</li>
<li>数据结构之链表</li>
<li>设计模式之模板设计模式</li>
</ol>
<h3 id="2-AQS-是什么？"><a href="#2-AQS-是什么？" class="headerlink" title="2) AQS 是什么？"></a>2) AQS 是什么？</h3><p>一般我们说的 AQS 指的是 java.util.concurrent.locks 包下的 AbstractQueuedSynchronizer，但其实还有共三种抽象队列同步器：</p>
<ul>
<li><p>AbstractOwnableSynchronizer、</p>
</li>
<li><p>AbstractQueuedLongSynchronizer </p>
</li>
<li><p>AbstractQueuedSynchronizer</p>
</li>
</ul>
<p>AQS 是<code>用来构建锁或者其它同步器组件的重量级基础框架</code>及整个JUC体系的基石， 通过<code>内置的FIFO队列</code>来完成<code>资源获取线程的排队工作</code>，并通过一个<code>int类变量（state）表示持有锁的状态</code></p>
<p>CLH：Craig、Landin and Hagersten 队列，是一个双向链表，AQS中的队列是CLH变体的虚拟双向队列FIFO<br><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210511110959.png" srcset="/img/loading.gif"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210511111015.png" srcset="/img/loading.gif"></p>
<h3 id="3-锁和同步器的关系"><a href="#3-锁和同步器的关系" class="headerlink" title="3) 锁和同步器的关系"></a>3) 锁和同步器的关系</h3><ul>
<li><p><code>锁，面向锁的使用者</code>。定义了程序员和锁交互的使用层API，隐藏了实现细节，你调用即可，可以理解为用户层面的 API。</p>
</li>
<li><p><code>同步器，面向锁的实现者</code>。比如Java并发大神Douglee，提出统一规范并简化了锁的实现，屏蔽了同步状态管理、阻塞线程排队和通知、唤醒机制等，Java 中有那么多的锁，就能简化锁的实现啦。</p>
</li>
</ul>
<h3 id="4-AQS能干嘛"><a href="#4-AQS能干嘛" class="headerlink" title="4) AQS能干嘛"></a>4) AQS能干嘛</h3><blockquote>
<p> <strong>AQS：加锁会导致阻塞</strong> </p>
</blockquote>
<p>有阻塞就需要排队，<code>实现排队必然需要有某种形式的队列</code>来进行管理</p>
<ul>
<li><p> <strong>抢到资源的线程</strong> 直接使用办理业务，</p>
</li>
<li><p><strong>抢占不到资源的线程</strong> 的必然涉及一种排队等候机制，</p>
</li>
<li><p><strong>抢占资源失败的线程</strong> 继续去等待（类似办理窗口都满了，暂时没有受理窗口的顾客只能去候客区排队等候）， <strong>仍然保留</strong> 获取锁的可能且获取锁流程仍在继续（候客区的顾客也在等着叫号，轮到了再去受理窗口办理业务）。</p>
</li>
</ul>
<p>既然说到了<code>排队等候机制</code>，那么就一定 会有某种队列形成，这样的队列是什么数据结构呢？</p>
<p>如果共享资源被占用，就需要一定的阻塞等待唤醒机制来保证锁分配。</p>
<p>这个机制主要用的是<code>CLH队列</code>的变体实现的，将暂时获取不到锁的线程加入到队列中，这个队列就是AQS的抽象表现。它将请求共享资源的线程封装成队列的结点（Node） ，通过CAS、自旋以及LockSuport.park()的方式，<code>维护state变量的状态</code>，使并发达到同步的效果。<br><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210511111909.png" srcset="/img/loading.gif"></p>
<h3 id="5-初始AQS"><a href="#5-初始AQS" class="headerlink" title="5) 初始AQS"></a>5) 初始AQS</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210511112023.png" srcset="/img/loading.gif"></p>
<p>有阻塞就需要排队，实现排队必然需要<code>队列</code></p>
<ul>
<li>AQS使用一个<code>volatile的int类型</code>的成员变量来表示同步状态，通过内置的 FIFO队列来完成资源获取的排队工作将每条要去抢占资源的线程封装成 <code>一个Node节点</code>来实现锁的分配，通过CAS完成对State值的修改。</li>
<li>Node 节点是啥？ HashMap 的 Node ;JDK 用 static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; { 来封装我们传入的 KV 键值对。这里也是一样的道理，JDK 使用 Node 来封装（管理）Thread</li>
<li>可以将 Node 和 Thread 类比于候客区的椅子和等待用餐的顾客</li>
</ul>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210511112219.png" srcset="/img/loading.gif"></p>
<h4 id="AQS内部体系架构"><a href="#AQS内部体系架构" class="headerlink" title="AQS内部体系架构"></a>AQS内部体系架构</h4><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210511112331.png" srcset="/img/loading.gif"></p>
<h4 id="AQS的int变量"><a href="#AQS的int变量" class="headerlink" title="AQS的int变量"></a>AQS的int变量</h4><p>AQS的同步状态State成员变量，类似于银行办理业务的受理窗口状态：</p>
<p>零就是没人，自由状态可以办理；大于等于1，有人占用窗口，等着去</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * The synchronization state.</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> state;</code></pre></div>

<h4 id="AQS的CLH队列"><a href="#AQS的CLH队列" class="headerlink" title="AQS的CLH队列"></a>AQS的CLH队列</h4><p>CLH队列（三个大牛的名字组成），为一个双向队列，类似于银行侯客区的等待顾客</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210511112603.png" srcset="/img/loading.gif"></p>
<h4 id="内部类Node（Node类在AQS类内部）"><a href="#内部类Node（Node类在AQS类内部）" class="headerlink" title="内部类Node（Node类在AQS类内部）"></a>内部类Node（Node类在AQS类内部）</h4><p>Node的等待状态waitState成员变量，类似于等候区其它顾客(其它线程)的等待状态，队列中每个排队的个体就是一个Node</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> waitStatus;</code></pre></div>

<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span></span>&#123;
    <span class="hljs-comment">//共享</span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Node SHARED = <span class="hljs-keyword">new</span> Node();
    
    <span class="hljs-comment">//独占</span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Node EXCLUSIVE = <span class="hljs-keyword">null</span>;
    
    <span class="hljs-comment">//线程被取消了</span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CANCELLED = <span class="hljs-number">1</span>;
    
    <span class="hljs-comment">//后继线程需要唤醒</span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SIGNAL = -<span class="hljs-number">1</span>;
    
    <span class="hljs-comment">//等待condition唤醒</span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CONDITION = -<span class="hljs-number">2</span>;
    
    <span class="hljs-comment">//共享式同步状态获取将会无条件地传播下去</span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> PROPAGATE = -<span class="hljs-number">3</span>;
    
    <span class="hljs-comment">// 初始为e，状态是上面的几种</span>
    <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> waitStatus;
    
    <span class="hljs-comment">// 前置节点</span>
    <span class="hljs-keyword">volatile</span> Node prev;
    
    <span class="hljs-comment">// 后继节点</span>
    <span class="hljs-keyword">volatile</span> Node next;

    <span class="hljs-comment">// ...</span></code></pre></div>

<p>有阻塞就需要排队，实现排队必然需要队列，通过state 变量 + CLH双端 Node 队列实现</p>
<h4 id="AQS同步队列的基本结构"><a href="#AQS同步队列的基本结构" class="headerlink" title="AQS同步队列的基本结构"></a>AQS同步队列的基本结构</h4><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210511113551.png" srcset="/img/loading.gif"></p>
<h3 id="6-从-ReentrantLock-进入-AQS"><a href="#6-从-ReentrantLock-进入-AQS" class="headerlink" title="6) 从 ReentrantLock 进入 AQS"></a>6) 从 ReentrantLock 进入 AQS</h3><blockquote>
<p>ReentrantLock 锁是个啥玩意儿？</p>
</blockquote>
<p>ReentrantLock 类是 Lock 接口的实现类，基本都是通过 <strong>【聚合】</strong> 了一个 <strong>【队列同步器】</strong> 的子类完成线程访问控制的</p>
<blockquote>
<p>ReentrantLock 的原理</p>
</blockquote>
<p>ReentrantLock 实现了 Lock 接口，在 ReentrantLock  <strong>内部聚合了一个 AbstractQueuedSynchronizer 的实现类</strong><br><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210511114110.png" srcset="/img/loading.gif"></p>
<h4 id="公平锁-amp-非公平锁"><a href="#公平锁-amp-非公平锁" class="headerlink" title="公平锁 &amp; 非公平锁"></a>公平锁 &amp; 非公平锁</h4><p>在 <code>ReentrantLock</code> 内定义了静态内部类，分别为 <code>NoFairSync</code>（非公平锁）和 <code>FairSync</code>（公平锁）</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210511130943.png" srcset="/img/loading.gif"></p>
<p><code>ReentrantLock</code> 的构造函数：不传参数表示创建非公平锁；参数为 true 表示创建公平锁；参数为 false 表示创建非公平锁</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210511131008.png" srcset="/img/loading.gif"></p>
<h4 id="lock"><a href="#lock" class="headerlink" title="lock()"></a>lock()</h4><p>捞一眼 <code>lock()</code> 方法的执行流程：以 <code>NonfairSync</code> 为例</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210511131111.png" srcset="/img/loading.gif"></p>
<p>在 <code>ReentrantLock</code> 中，<code>NoFairSync</code> 和 <code>FairSync</code> 中 <code>tryAcquire()</code> 方法的区别，可以明显看出公平锁与非公平锁的<code>lock()</code>方法唯一的区别就在于公平锁在获取同步状态时多了一个限制条件:<br><code>hasQueuedPredecessors()</code></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210511131323.png" srcset="/img/loading.gif"></p>
<p><code>hasQueuedPredecessors()</code> 方法是公平锁加锁时判断等待队列中是否存在有效节点的方法</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210511131341.png" srcset="/img/loading.gif"></p>
<blockquote>
<p> <strong>公平锁与非公平锁的总结</strong> </p>
</blockquote>
<p>对比公平锁和非公平锁的<code>tryAcqure()</code>方法的实现代码， 其实差别就在于非公平锁获取锁时比公平锁中少了一个判断<code>!hasQueuedPredecessors()</code>，hasQueuedPredecessors()中判断了是否需要排队，导致公平锁和非公平锁的差异如下:</p>
<ul>
<li><p>公平锁：公平锁讲究先来先到，线程在获取锁时，如果这个锁的等待队列中已经有线程在等待，那么当前线程就会进入等待队列中；</p>
</li>
<li><p>非公平锁：不管是否有等待队列，如果可以获取锁，则立刻占有锁对象。也就是说队列的第一个排队线程在unpark()，之后还是需要竞争锁(存在线程竞争的情况下)</p>
</li>
</ul>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210511131623.png" srcset="/img/loading.gif"></p>
<p>而 <code>acquire()</code> 方法最终都会调用 <code>tryAcquire()</code> 方法</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210511131714.png" srcset="/img/loading.gif"></p>
<p>在 <code>NonfairSync</code> 和 <code>FairSync</code> 中均重写了其父类 <code>AbstractQueuedSynchronizer</code> 中的 <code>tryAcquire()</code> 方法</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210511131733.png" srcset="/img/loading.gif"></p>
<h3 id="7-银行业务理解AQS"><a href="#7-银行业务理解AQS" class="headerlink" title="7) 银行业务理解AQS"></a>7) 银行业务理解AQS</h3><p>假设 A、B、C 三个人都要去银行窗口办理业务，但是银行窗口只有一个，我们使用 <code>lock.lock()</code> 模拟这种情况</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AQSDemo</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;

        ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();

        <span class="hljs-comment">// 带入一个银行办理业务的案例来模拟我们的AQS如何进行线程的管理和通知唤醒机制</span>
        <span class="hljs-comment">// 3个线程模拟3个来银行网点，受理窗口办理业务的顾客</span>
        <span class="hljs-comment">// A顾客就是第一个顾客，此时受理窗口没有任何人，A可以直接去办理</span>
        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
            lock.lock();
            <span class="hljs-keyword">try</span> &#123;
                System.out.println(<span class="hljs-string">&quot;-----A thread come in&quot;</span>);
                <span class="hljs-keyword">try</span> &#123;
                    TimeUnit.MINUTES.sleep(<span class="hljs-number">20</span>);
                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
                    e.printStackTrace();
                &#125;
            &#125; <span class="hljs-keyword">finally</span> &#123;
                lock.unlock();
            &#125;
        &#125;, <span class="hljs-string">&quot;A&quot;</span>).start();

        <span class="hljs-comment">// 第二个顾客，第二个线程---》由于受理业务的窗口只有一个(只能一个线程持有锁)，此时B只能等待，</span>
        <span class="hljs-comment">// 进入候客区</span>
        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
            lock.lock();
            <span class="hljs-keyword">try</span> &#123;
                System.out.println(<span class="hljs-string">&quot;-----B thread come in&quot;</span>);
            &#125; <span class="hljs-keyword">finally</span> &#123;
                lock.unlock();
            &#125;
        &#125;, <span class="hljs-string">&quot;B&quot;</span>).start();

        <span class="hljs-comment">// 第三个顾客，第三个线程---》由于受理业务的窗口只有一个(只能一个线程持有锁)，此时C只能等待，</span>
        <span class="hljs-comment">// 进入候客区</span>
        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
            lock.lock();
            <span class="hljs-keyword">try</span> &#123;
                System.out.println(<span class="hljs-string">&quot;-----C thread come in&quot;</span>);
            &#125; <span class="hljs-keyword">finally</span> &#123;
                lock.unlock();
            &#125;
        &#125;, <span class="hljs-string">&quot;C&quot;</span>).start();
    &#125;
&#125;</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210512075342.png" srcset="/img/loading.gif"></p>
<h4 id="客户-A"><a href="#客户-A" class="headerlink" title="客户 A"></a>客户 A</h4><p>之前已经讲到过，new ReentrantLock() 不传参默认是<code>非公平锁</code>，调用 lock.lock() 方法最终都会执行 <code>NonfairSync 重写后的 lock() </code>方法</p>
<p> <strong>第一次执行 lock() 方法</strong> </p>
<p>由于第一次执行 lock() 方法，state 变量的值等于 0，表示 lock 锁没有被占用，此时执行 compareAndSetState(0, 1) CAS 判断，可得 state == expected == 0，因此 CAS 成功，将 state 的值修改为 1<br><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210512075638.png" srcset="/img/loading.gif"></p>
<p>再来复习下 <code>CAS</code>：通过 <code>Unsafe</code> 提供的 <code>compareAndSwapXxx() </code>方法保证修改操作的原子性（通过 CPU 原语保证），如果变量的值等于期望值，则修改变量的值为 update，并返回 true；若不等，则返回 false。this 代表当前对象，<code>stateOffset</code> 表示 state 变量在该对象中的<code>偏移量</code><br><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210512075742.png" srcset="/img/loading.gif"></p>
<p>再来看看 <code>setExclusiveOwnerThread()</code> 方法做了啥：将拥有 lock 锁的线程修改为线程 A</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210512075857.png" srcset="/img/loading.gif"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210512075921.png" srcset="/img/loading.gif"></p>
<h4 id="客户-B"><a href="#客户-B" class="headerlink" title="客户 B"></a>客户 B</h4><p>第二次执行 lock() 方法</p>
<p>由于第二次执行 lock() 方法，state 变量的值等于 1，表示 lock 锁没有被占用，此时执行     <code>compareAndSetState(0, 1)</code> CAS 判断，可得 state != expected，因此 CAS 失败，进入 <code>acquire()</code> 方法</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210512080022.png" srcset="/img/loading.gif"></p>
<p><code>acquire()</code> 方法主要包含如下几个方法:</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210512080320.png" srcset="/img/loading.gif"></p>
<h5 id="tryAcquire-arg-方法"><a href="#tryAcquire-arg-方法" class="headerlink" title="tryAcquire(arg) 方法"></a>tryAcquire(arg) 方法</h5><p>先来看看 <code>tryAcquire()</code> 方法，为什么要抛个异常？</p>
<ul>
<li>是 <code>AbstractQueuedSynchronizer</code> 抽象队列同步器中定义的方法，既然抛出了异常，就<code>证明父类强制要求子类去实现</code>(模版设计模式)</li>
</ul>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210512080220.png" srcset="/img/loading.gif"></p>
<p>这里以非公平锁 <code>NonfairSync</code> 为例，在 <code>tryAcquire()</code> 方法中调用了 <code>nonfairTryAcquire()</code> 方法，注意，这里传入的参数都是 1</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210512080421.png" srcset="/img/loading.gif"></p>
<h5 id="nonfairTryAcquire-int-acquires"><a href="#nonfairTryAcquire-int-acquires" class="headerlink" title="nonfairTryAcquire(int acquires)"></a>nonfairTryAcquire(int acquires)</h5><p>在 nonfairTryAcquire() 方法中，大多数情况都是如下的执行流程：</p>
<ol>
<li><p>线程 B 执行 int c = getState() 时，获取到 state 变量的值为 1，表示 lock 锁正在被占用；</p>
</li>
<li><p>于是执行 if (c == 0) { 发现条件不成立，接着执行下一个判断条件 ；</p>
</li>
<li><p>else if (current == getExclusiveOwnerThread()) {，current 线程为线程 B，而 getExclusiveOwnerThread() 方法返回正在占用 lock 锁的线程，为线程 A；</p>
</li>
<li><p>因此 tryAcquire() 方法最后会 <code>return false</code>，表示并没有抢占到 lock 锁</p>
</li>
</ol>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210512080744.png" srcset="/img/loading.gif"></p>
<blockquote>
<p>补充</p>
</blockquote>
<p><code>getExclusiveOwnerThread()</code> 方法返回正在占用 lock 锁的线程（排他锁，exclusive）</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210512080919.png" srcset="/img/loading.gif"></p>
<h5 id="nonfairTryAcquire-acquires-特殊流程："><a href="#nonfairTryAcquire-acquires-特殊流程：" class="headerlink" title="nonfairTryAcquire(acquires)特殊流程："></a>nonfairTryAcquire(acquires)特殊流程：</h5><ul>
<li><code>第一种情况</code>是，走到 int c = getState() 语句时，此时<code>线程 A</code> 恰好执行完成，<code>让出了 lock 锁</code>，那么 state 变量的值为 0，当然发生这种情况的概率很小，那么线程 B 执行 CAS 操作成功后，将占用 lock 锁的线程修改为自己，然后返回 true，表示抢占锁成功。其实这里还有一种情况，需要留到 unlock() 方法才能说清楚</li>
<li><code>第二种情况</code>为<code>可重入锁</code>的表现，假设 A 线程又再次抢占 lock 锁（当然示例代码里面并没有体现出来），这时 current == getExclusiveOwnerThread() 条件成立，将 state 变量的值加上 acquire，这种情况下也应该 return true，表示线程 A 正在占用 lock 锁。因此，state 变量的值是可以大于 1 的</li>
</ul>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210512081151.png" srcset="/img/loading.gif"></p>
<h5 id="addWaiter"><a href="#addWaiter" class="headerlink" title="addWaiter()"></a>addWaiter()</h5><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210512080320.png" srcset="/img/loading.gif"></p>
<p>在 <code>tryAcquire()</code> 方法返回 <code>false</code> 之后，进行 <code>!</code> 操作后为 <code>true</code>，那么会继续执行 <code>addWaiter()</code> 方法</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210512081449.png" srcset="/img/loading.gif"></p>
<p><code>Node</code> 节点用于封装用户线程，这里将当前正在执行的线程通过 <code>Node</code> 封装起来（当前线程正是抢占 lock 锁没有抢占到的线程）</p>
<p>判断 tail 尾指针是否为空，双端队列此时还没有元素，那么执行 <code>enq(node)</code> 方法，将封装了线程 B 的 <code>Node</code> 节点入队</p>
<h5 id="enq-Node-方法"><a href="#enq-Node-方法" class="headerlink" title="enq(Node)方法"></a>enq(Node)方法</h5><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210512081638.png" srcset="/img/loading.gif"></p>
<p> <strong>构建双端同步队列</strong> </p>
<p>第一个if是让系统判断队列为空时，new一个哨兵结点</p>
<p>在双端同步队列中，<code>第一个节点为虚节点（也叫哨兵节点）</code>，其实并不存储任何信息，只是<code>占位</code>。 真正的第一个有数据的节点，是从第二个节点开始的。</p>
<p>第一次执行 for 循环：</p>
<ul>
<li><p>当线程 B 进来时，双端同步队列为空，此时肯定<code>要先构建一个哨兵节点</code>。此时 tail == null，因此进入 if(t == null) { 的分支，头指针指向哨兵节点，此时队列中只有一个节点，尾节点即是头结点，因此尾指针也指向该哨兵节点</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210512081945.png" srcset="/img/loading.gif"></p>
</li>
</ul>
<p>第二次执行 for 循环：</p>
<ul>
<li>现在该将装着线程 B 的节点放入双端同步队列中，此时 tail 指向了哨兵节点，并不等于 null，因此 if (t == null) 不成立，<code>进入 else 分支</code>。</li>
<li>以<code>尾插法</code>的方式，先将 node（装着线程 B 的节点）的 prev 指向之前的 tail，再将 node 设置为尾节点（执行 compareAndSetTail(t, node)），最后将 t.next 指向 node，最后执行 return t结束 for 循环<br><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210512082134.png" srcset="/img/loading.gif"></li>
</ul>
<p>哨兵节点和 <code>nodeB</code> 节点的 <code>waitStatus</code> 均为 0，表示在等待队列中</p>
<h5 id="acquireQueued-方法"><a href="#acquireQueued-方法" class="headerlink" title="acquireQueued()方法"></a>acquireQueued()方法</h5><p>注意看：两个 <code>if</code> 判断中的代码都放在 <code>for( ; ; )</code> 中执行，这样可以实现自旋的操作</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210512082745.png" srcset="/img/loading.gif"></p>
<p>线程 B 执行 addWaiter() 方法之后，就进入了 <code>acquireQueued() </code>方法中，此时传入的参数为封装了线程 B 的 nodeB 节点，nodeB 的前驱结点为哨兵节点。</p>
<ul>
<li>因此<code>final Node p = node.predecessor() </code>执行完后，p 将指向哨兵节点。</li>
<li>哨兵节点满足 <code>p == head</code>，但是线程 <code>B 执行 tryAcquire(arg) </code>方法尝试抢占 lock 锁时还会失败；</li>
<li>因此会执行下面 if 判断中的 <code>shouldParkAfterFailedAcquire(p, node)</code> 方法，该方法的代码如下：<br><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210512083640.png" srcset="/img/loading.gif"></li>
</ul>
<p>哨兵节点的 <code>waitStatus == 0</code>，因此执行 CAS 操作将哨兵节点的 <code>waitStatus</code> 改为 <code>Node.SIGNAL(-1)</code></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210512083742.png" srcset="/img/loading.gif"></p>
<ul>
<li>执行完毕将退出 <code>if</code> 判断，又会重新进入 <code>for( ; ; )</code> 循环，此时执行 <code>shouldParkAfterFailedAcquire(p, node)</code> 方法时会返回 <code>true</code>，因此此时会接着执行 <code>parkAndCheckInterrupt()</code> 方法</li>
</ul>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210512083837.png" srcset="/img/loading.gif"></p>
<p>第二次执行</p>
<p>线程 B 调用 <code>park()</code> 方法后被挂起，程序不会然续向下执行，程序就在这儿排队等待</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210512083901.png" srcset="/img/loading.gif"></p>
<h4 id="客户-C"><a href="#客户-C" class="headerlink" title="客户 C"></a>客户 C</h4><p>线程 C 和线程 B 的执行流程很类似，都是执行 <code>acquire()</code> 中的方法</p>
<p>但是在 <code>addWaiter()</code> 方法中，执行流程有些区别。此时 <code>tail != null</code>，因此在 <code>addWaiter()</code> 方法中就已经将 <code>nodeC</code> 添加至队尾了</p>
<p>执行完 <code>addWaiter()</code> 方法后，就已经将 nodeC 挂在了双端同步队列的队尾，不需要再执行 <code>enq(node)</code> 方法</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210512082615.png" srcset="/img/loading.gif"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210512082625.png" srcset="/img/loading.gif"></p>
<p>线程 C 最终也会执行到 <code>LockSupport.park(this);</code> 处，然后被挂起，进入等待区</p>
<p>如果<code>前驱节点</code>的 waitstatus 是 SIGNAL 状态（-1），即 shouldParkAfterFailedAcquire() 方法会返回 true，程序会继续向下执行<code>parkAndCheckInterrupt()</code>方法，用于将当前线程挂起</p>
<p>根据 park() 方法 API 描述，程序在下面三种情况会继续向下执行：</p>
<ul>
<li>被 unpark</li>
<li>被中断（interrupt）</li>
<li>其他不合逻辑的返回才会然续向下执行</li>
</ul>
<p>因上述三种情况程序执行至此，返回当前线程的中断状态，并清空中断状态。如果程序由于被中断，该方法会返回 true</p>
<h4 id="unlock"><a href="#unlock" class="headerlink" title="unlock()"></a>unlock()</h4><p>之前我们得到结论:</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210512084242.png" srcset="/img/loading.gif"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210512084405.png" srcset="/img/loading.gif"></p>
<h5 id="release"><a href="#release" class="headerlink" title="release()"></a>release()</h5><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210512084516.png" srcset="/img/loading.gif"></p>
<p>其实主要就是看看 tryRelease(arg) 方法和 unparkSuccessor(h) 方法的执行流程，这里先大概说以下，能有个印象：</p>
<ul>
<li>线程 A 即将让出 lock 锁，因此 tryRelease() 执行后将返回 true，表示礼让成功，</li>
<li>head 指针指向哨兵节点，并且 if 条件满足，可执行 <code>unparkSuccessor(h) </code>方法</li>
</ul>
<h5 id="tryRelease-arg"><a href="#tryRelease-arg" class="headerlink" title="tryRelease(arg)"></a>tryRelease(arg)</h5><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210512084531.png" srcset="/img/loading.gif"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210512084620.png" srcset="/img/loading.gif"></p>
<p>线程 A 只加锁过一次，因此 <code>state</code> 的值为 1，参数 <code>release</code> 的值也为 1，因此 <code>c == 0</code>。将 <code>free</code> 设置为 <code>true</code>，表示当前 lock 锁已被释放，将排他锁占有的线程设置为 <code>null</code>，表示没有任何线程占用 lock 锁</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210512085116.png" srcset="/img/loading.gif"></p>
<h5 id="unparkSuccessor-h"><a href="#unparkSuccessor-h" class="headerlink" title="unparkSuccessor(h)"></a>unparkSuccessor(h)</h5><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210512085442.png" srcset="/img/loading.gif"></p>
<p>在 release() 方法中获取到的头结点 h 为哨兵节点，h.waitStatus == -1，</p>
<ul>
<li>因此执行 CAS操作将哨兵节点的 waitStatus 设置为 0;</li>
<li>并将哨兵节点的下一个节点（s = node.next = nodeB)获取出来，并唤醒 nodeB 中封装的线程（if (s == null || s.waitStatus &gt; 0) 不成立，只有 if (s != null) 成立）</li>
</ul>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210512085618.png" srcset="/img/loading.gif"></p>
<p>返回到Park处</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210512085759.png" srcset="/img/loading.gif"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210512085850.png" srcset="/img/loading.gif"></p>
<p>返回true：p == head &amp;&amp; true</p>
<p>接着来研究下 <code>setHead(node)</code> 方法：传入的节点为 <code>nodeB</code>，头指针指向 <code>nodeB</code> 节点；将 <code>nodeB</code> 中封装的线程置为 <code>null</code>（因为已经获得锁了）；<code>nodeB</code> 不再指向其前驱节点（哨兵节点）。这一切都是为了将 <code>nodeB</code> 作为新的哨兵节点</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210512090115.png" srcset="/img/loading.gif"></p>
<p>执行完 <code>setHead(node)</code> 方法的状态如下图所示</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210512090131.png" srcset="/img/loading.gif"></p>
<p>将 <code>p.next</code> 设置为 <code>null</code>，这是原来的哨兵节点就是完全孤立的一个节点，此时 <code>nodeB</code> 作为新的哨兵节点</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210512090154.png" srcset="/img/loading.gif"></p>
<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><blockquote>
<p> <strong>为什么要使用 Redis 6.0.8</strong> </p>
</blockquote>
<p>Redis突然发布了紧急版本 6.0.8 ，之前消息称 6.0.7 被称作最后一个 6.x 版本，但 Redis 团队表示 6.0.8 版本升级迫切性等级为高：任何将 Redis 6.0.7 与 Sentinel 或 CONFIG REWRITE 命令配合使用的人都会受到影响，应尽快升级。<br><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210512095758.png" srcset="/img/loading.gif"></p>
<div class="hljs"><pre><code class="hljs java">qiukedeMacBook-Pro-<span class="hljs-number">2</span>:~ qiuke$ redis-server -v
Redis server v=<span class="hljs-number">5.0</span><span class="hljs-number">.4</span> sha=<span class="hljs-number">00000000</span>:<span class="hljs-number">0</span> malloc=libc bits=<span class="hljs-number">64</span> build=be37d4d566447fc</code></pre></div>

<div class="hljs"><pre><code class="hljs java"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; info
# Server
redis_version:<span class="hljs-number">5.0</span><span class="hljs-number">.4</span>
redis_git_sha1:<span class="hljs-number">00000000</span>
redis_git_dirty:<span class="hljs-number">0</span></code></pre></div>



<p> <strong><a target="_blank" rel="noopener" href="http://www.redis.cn/commands.html">官网命令大全</a></strong> </p>
<p>直接搜索即可</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210512100125.png" srcset="/img/loading.gif"></p>
<p> <strong>注</strong> ：命令不区分大小写，而key是区分大小写的，可使用 <code>help @类型名词</code> 查看</p>
<h2 id="Redis-基本数据类型"><a href="#Redis-基本数据类型" class="headerlink" title="Redis 基本数据类型"></a>Redis 基本数据类型</h2><ol>
<li>String(字符类型)</li>
<li>Hash(散列类型)</li>
<li>List(列表类型)</li>
<li>Set(集合类型)</li>
<li>SortedSet(有序集合类型，简称zset)</li>
<li>Bitmap(位图)</li>
<li>HyperLogLog(统计)</li>
<li>GEO(地理)</li>
</ol>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><h4 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h4><p> <strong>设置</strong> ：<code>SET key value</code></p>
<p> <strong>获取</strong> ：<code>SET key</code></p>
<p> <strong>设置</strong> ：<code>MSET key value [key value ....]</code></p>
<p> <strong>获取</strong> ：<code>MGET key [key ....]</code></p>
<p> <strong>递增数字</strong> ：<code>INCR key</code></p>
<p> <strong>增加指定的整数</strong> ：<code>INCRBY key increment</code></p>
<p> <strong>递减数值</strong> ：<code>DECR key</code></p>
<p> <strong>减少指定的整数</strong> ：<code>DECRBY key decrement</code></p>
<p> <strong>字符串长度</strong> ：<code>STRLEN key</code></p>
<h4 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h4><p>设置分布式锁：<code>set key value [Ex seconds][PX milliseconds][NX|XX]</code></p>
<p>参数解释：</p>
<p>EX：key 在多少秒之后过期<br>PX：key 在多少毫秒之后过期<br>NX：当 key 不存在的时候，才创建 key，效果<code>等同于setnx key value</code><br>XX：当 key 存在的时候，覆盖 key<br><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210512101145.png" srcset="/img/loading.gif"></p>
<p>ttl可查看剩余时间</p>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p> <strong>1、商品编号、订单号采用 INCR 命令生成</strong> </p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210512101331.png" srcset="/img/loading.gif"></p>
<p> <strong>2、文章阅读量、点赞数和在看数</strong> </p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210512101350.png" srcset="/img/loading.gif"></p>
<h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h3><h4 id="基础-1"><a href="#基础-1" class="headerlink" title="基础"></a>基础</h4><p>redis 中的 hash 类似于 java 中的 <code>Map&lt;String,Map&lt;Object,object&gt;&gt;</code> 数据结构，即以字符串为 key，以 Map 对象为 value</p>
<p> <strong>添加一个 hash 对象</strong> ：<code>HSET key field value</code></p>
<p> <strong>获取 hash 对象的字段值</strong> ：<code>HGET key field</code></p>
<p> <strong>添加多个 hash 对象</strong> ：<code>HMSET key field value [field value ...]</code></p>
<p><strong>获取多个 hash 对象的字段值</strong> ：<code>HMGET key field [field ....]</code></p>
<p>获取 key 所对应所有的 hash 对象：<code>HGETALL key</code></p>
<p>获取 key 对应的所有 hash 对象个数：<code>HLEN key</code></p>
<p>判断字段名为 field 的 hash 对象是否存在：<code>HEXISTS key field</code></p>
<p>删除一个 hash 对象：<code>HDEL key</code></p>
<p>如果key 和 field 不存在，则初始值为 0，否则在之前的数值上递增：<code>HINCRBY key field increment</code></p>
<h4 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h4><p>购物车早期版本，可在小中厂项目中使用</p>
<p>新增商品：hset shopcar:uid1024 334488 1<br>新增商品：hset shopcar:uid1024 334477 1<br>增加商品数量：hincrby shopcar:uid1024 334477 1<br>商品总数：hlen shopcar:uid1024<br>全部选择：hgetall shopcar:uid1024<br><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210512101843.png" srcset="/img/loading.gif" style="zoom:50%;" /></p>
<h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><h4 id="基础-2"><a href="#基础-2" class="headerlink" title="基础"></a>基础</h4><p>与其说 list 是个集合，还不如说 list 是个双端队列</p>
<blockquote>
<p>添加</p>
</blockquote>
<ol>
<li>向 list 左边添加元素，如果 list 不存在则创建该 list：LPUSH key value [value …]</li>
<li>向 list 右边添加元素，如果 list 不存在则创建该 list：RPUSH key value [value ….]</li>
<li>查看 list 中包含的元素：LRANGE key start stop，注：LRANGE key 0 -1 表示查看 list 中所有的元素</li>
</ol>
<blockquote>
<p>删除</p>
</blockquote>
<ol>
<li>从左边出队：<code>LPOP key</code></li>
<li>从右边出队：<code>RPOP key</code></li>
</ol>
<blockquote>
<p> <strong>获取列表中元素的个数</strong> </p>
</blockquote>
<p>查看 list 中包含几个元素：<code>LLEN key</code></p>
<h4 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h4><p>微信文章订阅公众号</p>
<ul>
<li>比如我订阅了如下两个公众号，他们发布了两篇文章，文章 ID 分别为 666 和 888，可以通过执行 LPUSH likearticle:onebyId 666 888 命令推送给我</li>
<li>查看我自己的号订阅的全部文章，类似分页，下面0~10就是一次显示10条：LPUSH likearticle:onebyId 0 10</li>
</ul>
<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210512102341.png" srcset="/img/loading.gif" style="zoom:33%;" />



<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><h4 id="基础-3"><a href="#基础-3" class="headerlink" title="基础"></a>基础</h4><blockquote>
<p> <strong>添加元素 &amp; 删除元素 &amp; 查看元素</strong> </p>
</blockquote>
<ol>
<li>向 set 中添加一个元素：<code>SADD key member[member ...]</code></li>
<li>删除 set 中的指定元素：<code>SREM key member [member ...]</code></li>
<li>获取 set 中的所有元素：<code>SMEMBERS key</code></li>
</ol>
<blockquote>
<p> <strong>判断元素是否在集合中</strong> </p>
</blockquote>
<p>判断指定元素是否在 set 中：<code>SISMEMBER key member</code></p>
<blockquote>
<p> <strong>获取集合中的元素个数</strong> </p>
</blockquote>
<p>获取 set 中元素的个数：<code>SCARD key</code></p>
<blockquote>
<p> <strong>从集合中随机弹出元素</strong> </p>
</blockquote>
<ol>
<li>从集合中随机弹出元素，元素不删除：<code>SRANDMEMBER key [数字]</code></li>
<li>从集合中随机弹出一个元素，出几个删几个：<code>SPOP key[数字]</code></li>
</ol>
<blockquote>
<p> <strong>集合运算</strong> </p>
</blockquote>
<ul>
<li>集合的差集运算A-B：<code>SDIFF key [key ...]</code>，属于A但不属于B的元素构成的集合</li>
<li>集合的交集运算A∩B：<code>SINTER key [key ...]</code>，属于A同时也属于B的共同拥有的元素构成的集合</li>
<li>集合的并集运算AUB：<code>SUNION key [key ...]</code>，属于A或者属于B的元素合并后的集合</li>
</ul>
<h4 id="应用场景-3"><a href="#应用场景-3" class="headerlink" title="应用场景"></a><strong>应用场景</strong></h4><p> <strong>1、微信抽奖小程序</strong> </p>
<ul>
<li>如果某个用户点击了立即参与按钮，则执行 sadd key useId 命令将该用户 ID 添加至 set 中</li>
<li>显示已经有多少人参与了抽奖：SCARD key</li>
<li>抽奖(从set中任意选取N个中奖人)<ul>
<li>随机抽奖2个人，元素不删除：SRANDMEMBER key 2</li>
<li>随机抽奖3个人，元素会删除：SPOP key 3</li>
</ul>
</li>
</ul>
<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210512102946.png" srcset="/img/loading.gif" style="zoom:33%;" />

<p> <strong>2、微信朋友圈点赞</strong> </p>
<ul>
<li>新增点赞：SADD pub:msgID 点赞用户ID1 点赞用户ID2</li>
<li>取消点赞：SREM pub:msgID 点赞用户ID</li>
<li>展现所有点赞过的用户：SMEMBERS pub:msgID</li>
<li>点赞用户数统计，就是常见的点赞红色数字：SCARD pub.msgID</li>
<li>判断某个朋友是否对楼主点赞过：SISMEMBER pub:msgID 用户ID</li>
</ul>
<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210512103914.png" srcset="/img/loading.gif" style="zoom:33%;" />

<p> <strong>3、Bilibili 共同关注的好友</strong> </p>
<p>共同关注的好友：<code>SINTER 我关注的人 Ta关注的人</code></p>
<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210512104309.png" srcset="/img/loading.gif" style="zoom:33%;" />

<p> <strong>4、QQ内推可能认识的人</strong> </p>
<h3 id="zset"><a href="#zset" class="headerlink" title="zset"></a>zset</h3><h4 id="基础-4"><a href="#基础-4" class="headerlink" title="基础"></a>基础</h4><p>形象理解 zset：向有序集合中加入一个元素和该元素的分数</p>
<blockquote>
<p> <strong>添加元素 &amp; 删除元素 &amp; 获取元素</strong> </p>
</blockquote>
<ol>
<li>向 zset 中添加一个<code>带分数（权值</code>）的元素：ZADD key score member [score member …]</li>
<li>删除 zset 中的指定元素：ZREM key member [member …]</li>
<li>返回索引从start到stop之间的所有元素，并按照元素分数<code>从小到大的顺序</code>：ZRANGE key start stop [WITHSCORES]，注：如果想要获取所有元素并且从小到大排序，可写为 ZRANGE key 0 -1</li>
</ol>
<blockquote>
<p> <strong>获取元素的分数</strong> </p>
</blockquote>
<p>获取指定元素的分数：<code>ZSCORE key member</code> </p>
<blockquote>
<p><strong>获取指定分数范围的元素</strong></p>
</blockquote>
<p>获取指定分数范围的元素：<code>ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</code></p>
<blockquote>
<p> <strong>获取集合中元素的数量</strong> </p>
</blockquote>
<p>获取集合中元素的数量：<code>ZCARD key</code></p>
<blockquote>
<p> <strong>获得指定分数范围内的元素个数</strong> </p>
</blockquote>
<p>获得指定分数范围内的元素个数：<code>ZCOUNT key min max</code></p>
<blockquote>
<p> <strong>增加某个元素的分数</strong> </p>
</blockquote>
<p>增加某个元素的分数：<code>ZINCRBY key increment member</code></p>
<blockquote>
<p> <strong>按照排名范围删除元素</strong> </p>
</blockquote>
<p>按照排名范围删除元素：<code>ZREMRANGEBYRANK key start stop</code></p>
<blockquote>
<p> <strong>获取元素的排名</strong> </p>
</blockquote>
<p>从小到大：<code>ZRANK key member</code></p>
<p>从大到小：<code>ZREVRANK key member</code></p>
<h4 id="应用场景-4"><a href="#应用场景-4" class="headerlink" title="应用场景"></a><strong>应用场景</strong></h4><p>  **1、根据商品销售对商品进行排序显示 ** </p>
<p>思路:定义商品销售排行榜(sorted set集合)，key为goods:sellsort，分数为商品销售数量。</p>
<ol>
<li>商品编号1001的销量是9，商品编号1002的销量是15：ZADD goods:sellsort 9 1001 15 1002</li>
<li>有一个客户又买了2件商品1001，商品编号1001销量加2：ZINCRBY goods:sellsort 2 1001</li>
<li>求商品销量前10名：ZRANGE goods:sellsort 0 10 WITHSCORES</li>
</ol>
<p> <strong>2、抖音热搜</strong> </p>
<ol>
<li>点击视频增加播放量：<code>ZINCRBY hotvcr:20200919 1八佰</code>，<code>ZINCRBY hotvcr:20200919 15 八佰 2 花木兰</code></li>
<li>展示当日排行前10条：<code>ZREVRANGE hotvcr:20200919 0 9 WITHSCORES</code></li>
</ol>
<h2 id="Redis-分布式锁"><a href="#Redis-分布式锁" class="headerlink" title="Redis 分布式锁"></a>Redis 分布式锁</h2><ol>
<li>JVM层面的加锁</li>
<li>分布式微服务架构，拆分后各个微服务之间为了避免冲突和数据故障而加入的一种锁，分布式锁</li>
</ol>
<p>Redis -&gt; redlock -&gt; redisson lock/unlock分布式锁</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210512110218.png" srcset="/img/loading.gif"></p>
<h3 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h3><p>Redis除了拿来做缓存，你还见过基于Redis的什么用法?</p>
<p>Redis做分布式锁的时候有需要注意的问题?</p>
<p>如果是Redis是单点部署的，会带来什么问题? 那你准备怎么解决单点问题呢?</p>
<p>集群模式下，比如主从模式，有没有什么问题呢?</p>
<p>那你简单的介绍一下Redlock吧? 你简历上写redisson，你谈谈</p>
<p>Redis分布式锁如何续期?看门狗知道吗?</p>
<h3 id="搭建超卖工程"><a href="#搭建超卖工程" class="headerlink" title="搭建超卖工程"></a>搭建超卖工程</h3><p> <strong>Redis 分布式锁测试说明</strong> </p>
<p> <strong>测试目的</strong> ：多个服务间保证同一时刻同一时间段内同一用户只能有一个请求(防止关键业务出现并发攻击)</p>
<p> <strong>两个 Module</strong> ：boot_redis01 和 boot_redis02</p>
<h4 id="搭建-SpringBoot-工程"><a href="#搭建-SpringBoot-工程" class="headerlink" title="搭建 SpringBoot 工程"></a>搭建 SpringBoot 工程</h4><ol>
<li>新建 Module 或者 Maven 子工程</li>
<li>编写 pom.xml 管理工程依赖</li>
<li>编写 application.yml 配置文件（或者 application.properties 配置文件）</li>
<li>编写主启动类</li>
<li>编写配置类</li>
<li>编写业务类</li>
<li>代码测试</li>
</ol>
<blockquote>
<p> <strong>boot_redis01 工程</strong> </p>
</blockquote>
<ol>
<li>xml</li>
</ol>
<div class="hljs"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span>
<span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span>
<span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.3.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>/&gt;</span> <span class="hljs-comment">&lt;!-- lookup parent from repository --&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.qiuke<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>boot_redis01<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

        <span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-actuator --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

        <span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-data-redis --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

        <span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.commons/commons-pool2 --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.commons<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-pool2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

        <span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/redis.clients/jedis --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>redis.clients<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jedis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

        <span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-aop --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

        <span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.redisson/redisson --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.redisson<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>redisson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.13.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-devtools<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.12<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></code></pre></div>

<ol start="2">
<li>YAML</li>
</ol>
<div class="hljs"><pre><code class="hljs YAML"><span class="hljs-string">server.port=1111</span>

<span class="hljs-string">spring.redis.database=0</span>
<span class="hljs-string">spring.redis.host=127.0.0.1</span>
<span class="hljs-string">spring.redis.port=6379</span>
<span class="hljs-comment">#连接池最大连接数（使用负值表示没有限制）默认8</span>
<span class="hljs-string">spring.redis.lettuce.pool.max-active=8</span>
<span class="hljs-comment">#连接池最大阻塞等待时间（使用负值表示没有限制）默认-1</span>
<span class="hljs-string">spring.redis.lettuce.pool.max-wait=-1</span>
<span class="hljs-comment">#连接池中的最大空闲连接默认8</span>
<span class="hljs-string">spring.redis.lettuce.pool.max-idle=8</span>
<span class="hljs-comment">#连接池中的最小空闲连接默认0</span>
<span class="hljs-string">spring.redis.lettuce.pool.min-idle=0</span></code></pre></div>

<ol start="3">
<li>主启动类</li>
</ol>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication(exclude = &#123;DataSourceAutoConfiguration.class&#125;)</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BootRedis01Application</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        SpringApplication.run(BootRedis01Application.class);
    &#125;
&#125;</code></pre></div>

<ol start="4">
<li>配置类</li>
</ol>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisConfig</span> </span>&#123;

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> RedisTemplate&lt;String, Serializable&gt; <span class="hljs-title">redisTemplate</span><span class="hljs-params">(LettuceConnectionFactory connectionFactory)</span></span>&#123;
        <span class="hljs-comment">// 新建 RedisTemplate 对象，key 为 String 对象，value 为 Serializable（可序列化的）对象</span>
        RedisTemplate&lt;String, Serializable&gt; redisTemplate = <span class="hljs-keyword">new</span> RedisTemplate&lt;&gt;();
        <span class="hljs-comment">// key 值使用字符串序列化器</span>
        redisTemplate.setKeySerializer(<span class="hljs-keyword">new</span> StringRedisSerializer());
        <span class="hljs-comment">// value 值使用 json 序列化器</span>
        redisTemplate.setValueSerializer(<span class="hljs-keyword">new</span> GenericJackson2JsonRedisSerializer());
        <span class="hljs-comment">// 传入连接工厂</span>
        redisTemplate.setConnectionFactory(connectionFactory);
        <span class="hljs-comment">// 返回 redisTemplate 对象</span>
        <span class="hljs-keyword">return</span> redisTemplate;
    &#125;

&#125;</code></pre></div>

<ol start="5">
<li>Controller</li>
</ol>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GoodController</span> </span>&#123;

    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> StringRedisTemplate stringRedisTemplate;

    <span class="hljs-meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span>
    <span class="hljs-keyword">private</span> String serverPort;

    <span class="hljs-meta">@GetMapping(&quot;/buy_goods&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">buy_Goods</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-comment">// 从 redis 中获取商品的剩余数量</span>
        String result = stringRedisTemplate.opsForValue().get(<span class="hljs-string">&quot;goods:001&quot;</span>);
        <span class="hljs-keyword">int</span> goodsNumber = result == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : Integer.parseInt(result);
        String retStr = <span class="hljs-keyword">null</span>;

        <span class="hljs-comment">// 商品数量大于零才能出售</span>
        <span class="hljs-keyword">if</span> (goodsNumber &gt; <span class="hljs-number">0</span>) &#123;
            <span class="hljs-keyword">int</span> realNumber = goodsNumber - <span class="hljs-number">1</span>;
            stringRedisTemplate.opsForValue().set(<span class="hljs-string">&quot;goods:001&quot;</span>, realNumber + <span class="hljs-string">&quot;&quot;</span>);
            retStr = <span class="hljs-string">&quot;你已经成功秒杀商品，此时还剩余：&quot;</span> + realNumber + <span class="hljs-string">&quot;件&quot;</span> + <span class="hljs-string">&quot;\t 服务器端口: &quot;</span> + serverPort;
        &#125; <span class="hljs-keyword">else</span> &#123;
            retStr = <span class="hljs-string">&quot;商品已经售罄/活动结束/调用超时，欢迎下次光临&quot;</span> + <span class="hljs-string">&quot;\t 服务器端口: &quot;</span> + serverPort;
        &#125;
        System.out.println(retStr);
        <span class="hljs-keyword">return</span> retStr;
    &#125;

&#125;</code></pre></div>

<h4 id="代码测试"><a href="#代码测试" class="headerlink" title="代码测试"></a>代码测试</h4><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210513110632.png" srcset="/img/loading.gif"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210513110657.png" srcset="/img/loading.gif"></p>
<h4 id="问题发现"><a href="#问题发现" class="headerlink" title="问题发现"></a>问题发现</h4><blockquote>
<p> <strong>1、单机版程序没加锁存在什么问题？</strong> </p>
</blockquote>
<p> <code>问题</code>：单机版程序没有加锁，在并发测试下数字不对，会出现超卖现象</p>
<p> <code>解决</code>：加锁，那么问题又来了，加 synchronized 锁还是 ReentrantLock 锁呢？</p>
<ul>
<li>synchronized：不见不散，等不到锁就会死等</li>
<li>ReentrantLock：过时不候，lock.tryLock() 提供一个过时时间的参数，时间一到自动放弃锁</li>
<li><code>如何选择</code>：根据业务需求来选；<ul>
<li>如果非要抢到锁不可，就使用 synchronized 锁；</li>
<li>如果可以暂时放弃锁，等会再来强，就使用 ReentrantLock 锁</li>
</ul>
</li>
</ul>
<blockquote>
<p> <strong>2.0 版本的代码：使用 <code>synchronized</code> 锁保证单机版程序在并发下的安全性</strong> </p>
</blockquote>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210513111727.png" srcset="/img/loading.gif"></p>
<blockquote>
<p> <strong>注意事项</strong> </p>
</blockquote>
<ol>
<li><p>在单机环境下，<code>可以使用 synchronized 锁或 Lock 锁</code>来实现。</p>
</li>
<li><p>但是在分布式系统中，因为竞争的线程可能不在同一个节点上（<code>同一个 jvm 中</code>），所以<code>需要一个让所有进程都能访问到的锁</code>来实现，比如 redis 或者 zookeeper 来构建;</p>
</li>
<li><p>不同进程 jvm 层面的锁就不管用了，那么可以利用第三方的一个组件，来获取锁，未获取到锁，则阻塞当前想要运行的线程</p>
</li>
</ol>
<h4 id="配置nginx-实现分布式"><a href="#配置nginx-实现分布式" class="headerlink" title="配置nginx 实现分布式"></a>配置nginx 实现分布式</h4><p>分布式部署之后，单机版的锁失效，单机版的锁还是会导致超卖现象，这时就需要需要分布式锁</p>
<p>如下，在我们的两个微服务之上，挡了一个 nginx 服务器，用于实现负载均衡的功能</p>
<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210513112453.png" srcset="/img/loading.gif" style="zoom:50%;" />

<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210513113810.png" srcset="/img/loading.gif" style="zoom:50%;" />

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210513113835.png" srcset="/img/loading.gif"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210513113846.png" srcset="/img/loading.gif"></p>
<p>默认 <code>轮询</code></p>
<h4 id="jmeter打满"><a href="#jmeter打满" class="headerlink" title="jmeter打满"></a>jmeter打满</h4><p>在【Test Plan】上右击，选择【Add】–&gt;【Threads】–&gt;【Thread Group】，添加线程组</p>
<p>设置如下四个参数</p>
<ol>
<li>Name：线程组的名称</li>
<li>Number of Threads(users)：打出去的线程数量</li>
<li>Ramp-up period(seconds)：在多长时间内需要将这些线程打出去</li>
<li>Loop Count：循环次数，选择 Infinite 表示无限重复执行</li>
</ol>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210513114350.png" srcset="/img/loading.gif"></p>
<p>在线程组之上右击，选择【Add】–&gt;【Sampler】–&gt;【HTTP Request】，添加 HTTP 请求</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210513114409.png" srcset="/img/loading.gif"></p>
<p>设置如下三个参数</p>
<ol>
<li>Server Name or IP：服务器名称或者 IP 地址</li>
<li>Port Number：访问的端口号</li>
<li>Path：访问的路径</li>
</ol>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210513114514.png" srcset="/img/loading.gif"></p>
<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210513114929.png" srcset="/img/loading.gif" style="zoom:50%;" />

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210513114920.png" srcset="/img/loading.gif"></p>
<p>出现重复还剩余，就是超卖</p>
<h4 id="使用-redis-分布式锁"><a href="#使用-redis-分布式锁" class="headerlink" title="使用 redis 分布式锁"></a>使用 redis 分布式锁</h4><p>  <strong>1、SET 命令</strong> </p>
<p><a target="_blank" rel="noopener" href="https://redis.io/commands/set">set</a></p>
<p>Redis具有极高的性能，且其命令对<code>分布式锁</code>支持友好，借助 SET 命令即可实现加锁处理</p>
<p>The SET command supports a set of options that modify its behavior:</p>
<ol>
<li>EX seconds – Set the specified expire time, in seconds.</li>
<li>PX milliseconds – Set the specified expire time, in milliseconds.</li>
<li>EXAT timestamp-seconds – Set the specified Unix time at which the key will expire, in seconds.</li>
<li>PXAT timestamp-milliseconds – Set the specified Unix time at which the key will expire, in milliseconds.</li>
<li>NX – Only set the key if it does not already exist.</li>
<li>XX – Only set the key if it already exist.</li>
<li>KEEPTTL – Retain the time to live associated with the key.</li>
<li>GET – Return the old value stored at key, or nil when key did not exist.</li>
</ol>
<p>  <strong>2、在代码中使用分布式锁</strong> </p>
<ul>
<li>使用<code>当前请求的 UUID + 线程名</code>作为<code>分布式锁的 value</code></li>
<li>执行 <code>stringRedisTemplate.opsForValue().setIfAbsent(REDIS_LOCK_KEY, value) </code>方法尝试<code>抢占锁</code><ul>
<li>如果抢占失败，则返回值为 false；</li>
<li>如果抢占成功，则返回值为 true。</li>
</ul>
</li>
<li>最后记得调用 <code>stringRedisTemplate.delete(REDIS_LOCK_KEY)</code> 方法<code>释放分布式锁</code></li>
</ul>
<p>setIfAbsent 和 NX意思一致，Only set the key if it does not already exist.</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> StringRedisTemplate stringRedisTemplate;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String REDIS_LOCK_KEY = <span class="hljs-string">&quot;lockOneby&quot;</span>;

    <span class="hljs-meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span>
    <span class="hljs-keyword">private</span> String serverPort;

    <span class="hljs-meta">@GetMapping(&quot;/buy_goods&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">buy_Goods</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-comment">// 当前请求的 UUID + 线程名</span>
        String value = UUID.randomUUID().toString()+Thread.currentThread().getName();
        <span class="hljs-comment">// setIfAbsent() 就相当于 setnx，如果不存在就新建锁</span>
        Boolean lockFlag = stringRedisTemplate.opsForValue().setIfAbsent(REDIS_LOCK_KEY, value);

        <span class="hljs-comment">// 抢锁失败</span>
        <span class="hljs-keyword">if</span>(lockFlag == <span class="hljs-keyword">false</span>)&#123;
            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;抢锁失败 o(╥﹏╥)o&quot;</span>;
        &#125;

        <span class="hljs-comment">// 从 redis 中获取商品的剩余数量</span>
        String result = stringRedisTemplate.opsForValue().get(<span class="hljs-string">&quot;goods:001&quot;</span>);
        <span class="hljs-keyword">int</span> goodsNumber = result == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : Integer.parseInt(result);
        String retStr = <span class="hljs-keyword">null</span>;

        <span class="hljs-comment">// 商品数量大于零才能出售</span>
        <span class="hljs-keyword">if</span> (goodsNumber &gt; <span class="hljs-number">0</span>) &#123;
            <span class="hljs-keyword">int</span> realNumber = goodsNumber - <span class="hljs-number">1</span>;
            stringRedisTemplate.opsForValue().set(<span class="hljs-string">&quot;goods:001&quot;</span>, realNumber + <span class="hljs-string">&quot;&quot;</span>);
            retStr = <span class="hljs-string">&quot;你已经成功秒杀商品，此时还剩余：&quot;</span> + realNumber + <span class="hljs-string">&quot;件&quot;</span> + <span class="hljs-string">&quot;\t 服务器端口: &quot;</span> + serverPort;
        &#125; <span class="hljs-keyword">else</span> &#123;
            retStr = <span class="hljs-string">&quot;商品已经售罄/活动结束/调用超时，欢迎下次光临&quot;</span> + <span class="hljs-string">&quot;\t 服务器端口: &quot;</span> + serverPort;
        &#125;
        System.out.println(retStr);
        stringRedisTemplate.delete(REDIS_LOCK_KEY); <span class="hljs-comment">// 释放分布式锁</span>
        <span class="hljs-keyword">return</span> retStr;
    &#125;</code></pre></div>

<p>解决超卖现象</p>
<p>但还是存在问题</p>
<p> <strong>存在的问题</strong> </p>
<p>如果代码在执行的过程中出现异常，那么就可能无法释放锁，因此必须要在代码层面加上 <code>finally</code> 代码块，保证锁的释放</p>
<h4 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span>
<span class="hljs-keyword">private</span> StringRedisTemplate stringRedisTemplate;

<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String REDIS_LOCK_KEY = <span class="hljs-string">&quot;lockOneby&quot;</span>;

<span class="hljs-meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span>
<span class="hljs-keyword">private</span> String serverPort;

<span class="hljs-meta">@GetMapping(&quot;/buy_goods&quot;)</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">buy_Goods</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">try</span> &#123;
        <span class="hljs-comment">// 当前请求的 UUID + 线程名</span>
        String value = UUID.randomUUID().toString()+Thread.currentThread().getName();
        <span class="hljs-comment">// setIfAbsent() 就相当于 setnx，如果不存在就新建锁</span>
        Boolean lockFlag = stringRedisTemplate.opsForValue().setIfAbsent(REDIS_LOCK_KEY, value);

        <span class="hljs-comment">// 抢锁失败</span>
        <span class="hljs-keyword">if</span>(lockFlag == <span class="hljs-keyword">false</span>)&#123;
            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;抢锁失败 o(╥﹏╥)o&quot;</span>;
        &#125;

        <span class="hljs-comment">// 从 redis 中获取商品的剩余数量</span>
        String result = stringRedisTemplate.opsForValue().get(<span class="hljs-string">&quot;goods:001&quot;</span>);
        <span class="hljs-keyword">int</span> goodsNumber = result == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : Integer.parseInt(result);
        String retStr = <span class="hljs-keyword">null</span>;

        <span class="hljs-comment">// 商品数量大于零才能出售</span>
        <span class="hljs-keyword">if</span> (goodsNumber &gt; <span class="hljs-number">0</span>) &#123;
            <span class="hljs-keyword">int</span> realNumber = goodsNumber - <span class="hljs-number">1</span>;
            stringRedisTemplate.opsForValue().set(<span class="hljs-string">&quot;goods:001&quot;</span>, realNumber + <span class="hljs-string">&quot;&quot;</span>);
            retStr = <span class="hljs-string">&quot;你已经成功秒杀商品，此时还剩余：&quot;</span> + realNumber + <span class="hljs-string">&quot;件&quot;</span> + <span class="hljs-string">&quot;\t 服务器端口: &quot;</span> + serverPort;
        &#125; <span class="hljs-keyword">else</span> &#123;
            retStr = <span class="hljs-string">&quot;商品已经售罄/活动结束/调用超时，欢迎下次光临&quot;</span> + <span class="hljs-string">&quot;\t 服务器端口: &quot;</span> + serverPort;
        &#125;
        System.out.println(retStr);
        <span class="hljs-keyword">return</span> retStr;
    &#125;<span class="hljs-keyword">finally</span> &#123;
        stringRedisTemplate.delete(REDIS_LOCK_KEY); <span class="hljs-comment">// 释放分布式锁</span>
    &#125;
&#125;</code></pre></div>

<h4 id="过期时间版"><a href="#过期时间版" class="headerlink" title="过期时间版"></a>过期时间版</h4><blockquote>
<p> <strong>存在的问题</strong> </p>
</blockquote>
<p>假设部署了微服务 jar 包的服务器挂了，代码层面根本没有走到 finally 这块，也没办法保证解锁。这个 key 没有被删除，其他微服务就一直抢不到锁，因此我们需要加入一个过期时间限定的 key</p>
<blockquote>
<p> <strong>5.0 版本的代码：设置带过期时间的 key</strong> </p>
</blockquote>
<p>执行 <code>stringRedisTemplate.expire(REDIS_LOCK_KEY, 10L, TimeUnit.SECONDS);</code> 方法为分布式锁设置过期时间，保证锁的释放</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> StringRedisTemplate stringRedisTemplate;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String REDIS_LOCK_KEY = <span class="hljs-string">&quot;lockOneby&quot;</span>;

    <span class="hljs-meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span>
    <span class="hljs-keyword">private</span> String serverPort;

    <span class="hljs-meta">@GetMapping(&quot;/buy_goods&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">buy_Goods</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-comment">// 当前请求的 UUID + 线程名</span>
            String value = UUID.randomUUID().toString()+Thread.currentThread().getName();
            <span class="hljs-comment">// setIfAbsent() 就相当于 setnx，如果不存在就新建锁</span>
            Boolean lockFlag = stringRedisTemplate.opsForValue().setIfAbsent(REDIS_LOCK_KEY, value);
            <span class="hljs-comment">// 设置过期时间为 10s</span>
            stringRedisTemplate.expire(REDIS_LOCK_KEY, <span class="hljs-number">10L</span>, TimeUnit.SECONDS);
            
            <span class="hljs-comment">// 抢锁失败</span>
            <span class="hljs-keyword">if</span>(lockFlag == <span class="hljs-keyword">false</span>)&#123;
                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;抢锁失败 o(╥﹏╥)o&quot;</span>;
            &#125;

            <span class="hljs-comment">// 从 redis 中获取商品的剩余数量</span>
            String result = stringRedisTemplate.opsForValue().get(<span class="hljs-string">&quot;goods:001&quot;</span>);
            <span class="hljs-keyword">int</span> goodsNumber = result == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : Integer.parseInt(result);
            String retStr = <span class="hljs-keyword">null</span>;

            <span class="hljs-comment">// 商品数量大于零才能出售</span>
            <span class="hljs-keyword">if</span> (goodsNumber &gt; <span class="hljs-number">0</span>) &#123;
                <span class="hljs-keyword">int</span> realNumber = goodsNumber - <span class="hljs-number">1</span>;
                stringRedisTemplate.opsForValue().set(<span class="hljs-string">&quot;goods:001&quot;</span>, realNumber + <span class="hljs-string">&quot;&quot;</span>);
                retStr = <span class="hljs-string">&quot;你已经成功秒杀商品，此时还剩余：&quot;</span> + realNumber + <span class="hljs-string">&quot;件&quot;</span> + <span class="hljs-string">&quot;\t 服务器端口: &quot;</span> + serverPort;
            &#125; <span class="hljs-keyword">else</span> &#123;
                retStr = <span class="hljs-string">&quot;商品已经售罄/活动结束/调用超时，欢迎下次光临&quot;</span> + <span class="hljs-string">&quot;\t 服务器端口: &quot;</span> + serverPort;
            &#125;
            System.out.println(retStr);
            <span class="hljs-keyword">return</span> retStr;
        &#125;<span class="hljs-keyword">finally</span> &#123;
            stringRedisTemplate.delete(REDIS_LOCK_KEY); <span class="hljs-comment">// 释放分布式锁</span>
        &#125;
    &#125;</code></pre></div>

<h4 id="加锁原子版"><a href="#加锁原子版" class="headerlink" title="加锁原子版"></a>加锁原子版</h4><blockquote>
<p> 存在的问题</p>
</blockquote>
<p><code>加锁与设置过期时间</code>的操作分开了，假设服务器刚刚执行了加锁操作，然后宕机了，也没办法保证解锁。</p>
<blockquote>
<p> 6.0 版本的代码：保证加锁和设置过期时间为原子操作</p>
</blockquote>
<p>使用 stringRedisTemplate.opsForValue().setIfAbsent(REDIS_LOCK_KEY, value, 10L, TimeUnit.SECONDS) 方法，在加锁的同时设置过期时间，保证这两个操作的原子性</p>
<div class="hljs"><pre><code class="hljs java">Boolean lockFlag = stringRedisTemplate.opsForValue().setIfAbsent(REDIS_LOCK_KEY, value, <span class="hljs-number">10L</span>, TimeUnit.SECONDS);</code></pre></div>

<h4 id="动自己奶酪版"><a href="#动自己奶酪版" class="headerlink" title="动自己奶酪版"></a>动自己奶酪版</h4><blockquote>
<p> 存在的问题</p>
</blockquote>
<p>张冠李戴，删除了别人的锁：我们无法保证一个业务的执行时间，有可能是 10s，有可能是 20s，也有可能更长。因为执行业务的时候可能会调用其他服务，我们并不能保证其他服务的调用时间。如果设置的锁过期了，当前业务还正在执行，那么就有可能出现超卖问题，并且还有可能出现当前业务执行完成后，释放了其他业务的锁</p>
<p>如下图，假设进程 A 在 T2 时刻设置了一把过期时间为 30s 的锁，在 T5 时刻该锁过期被释放，在 T5 和 T6 期间，Test 这把锁已经失效了，并不能保证进程 A 业务的原子性了。于是进程 B 在 T6 时刻能够获取 Test 这把锁，但是进程 A 在 T7 时刻删除了进程 B 加的锁，进程 B 在 T8 时刻删除锁的时候就蒙蔽了，我 TM 锁呢？<br><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210513144712.png" srcset="/img/loading.gif"></p>
<blockquote>
<p> <strong>7.0 版本的代码：只允许删除自己的锁，不允许删除别人的锁</strong> </p>
</blockquote>
<p>在释放锁之前，执行 <code>value.equalsIgnoreCase(stringRedisTemplate.opsForValue().get(REDIS_LOCK_KEY))</code> 方法判断是否为自己加的锁</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> StringRedisTemplate stringRedisTemplate;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String REDIS_LOCK_KEY = <span class="hljs-string">&quot;lockOneby&quot;</span>;

    <span class="hljs-meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span>
    <span class="hljs-keyword">private</span> String serverPort;

    <span class="hljs-meta">@GetMapping(&quot;/buy_goods&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">buy_Goods</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-comment">// 当前请求的 UUID + 线程名</span>
        String value = UUID.randomUUID().toString()+Thread.currentThread().getName();
        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-comment">// setIfAbsent() 就相当于 setnx，如果不存在就新建锁</span>
            <span class="hljs-comment">// setIfAbsent() 就相当于 setnx，如果不存在就新建锁，同时加上过期时间保证原子性</span>
            Boolean lockFlag = stringRedisTemplate.opsForValue().setIfAbsent(REDIS_LOCK_KEY, value, <span class="hljs-number">10L</span>, TimeUnit.SECONDS);
            
            <span class="hljs-comment">// 抢锁失败</span>
            <span class="hljs-keyword">if</span>(lockFlag == <span class="hljs-keyword">false</span>)&#123;
                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;抢锁失败 o(╥﹏╥)o&quot;</span>;
            &#125;

            <span class="hljs-comment">// 从 redis 中获取商品的剩余数量</span>
            String result = stringRedisTemplate.opsForValue().get(<span class="hljs-string">&quot;goods:001&quot;</span>);
            <span class="hljs-keyword">int</span> goodsNumber = result == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : Integer.parseInt(result);
            String retStr = <span class="hljs-keyword">null</span>;

            <span class="hljs-comment">// 商品数量大于零才能出售</span>
            <span class="hljs-keyword">if</span> (goodsNumber &gt; <span class="hljs-number">0</span>) &#123;
                <span class="hljs-keyword">int</span> realNumber = goodsNumber - <span class="hljs-number">1</span>;
                stringRedisTemplate.opsForValue().set(<span class="hljs-string">&quot;goods:001&quot;</span>, realNumber + <span class="hljs-string">&quot;&quot;</span>);
                retStr = <span class="hljs-string">&quot;你已经成功秒杀商品，此时还剩余：&quot;</span> + realNumber + <span class="hljs-string">&quot;件&quot;</span> + <span class="hljs-string">&quot;\t 服务器端口: &quot;</span> + serverPort;
            &#125; <span class="hljs-keyword">else</span> &#123;
                retStr = <span class="hljs-string">&quot;商品已经售罄/活动结束/调用超时，欢迎下次光临&quot;</span> + <span class="hljs-string">&quot;\t 服务器端口: &quot;</span> + serverPort;
            &#125;
            System.out.println(retStr);
            <span class="hljs-keyword">return</span> retStr;
        &#125;<span class="hljs-keyword">finally</span> &#123;
            <span class="hljs-comment">// 判断是否是自己加的锁</span>
            <span class="hljs-keyword">if</span>(value.equalsIgnoreCase(stringRedisTemplate.opsForValue().get(REDIS_LOCK_KEY)))&#123;
                stringRedisTemplate.delete(REDIS_LOCK_KEY); <span class="hljs-comment">// 释放分布式锁</span>
            &#125;
        &#125;
    &#125;</code></pre></div>

<h4 id="解锁原子版"><a href="#解锁原子版" class="headerlink" title="解锁原子版"></a>解锁原子版</h4><blockquote>
<p> <strong>存在的问题</strong> </p>
</blockquote>
<p>在 finally 代码块中的<code>判断与删除</code>并不是原子操作，假设执行 <code>if</code> 判断的时候，这把锁还是属于当前业务，但是有可能刚执行完 <code>if</code> 判断，这把锁就被其他业务给释放了，还是会出现误删锁的情况</p>
<blockquote>
<p> <strong>8.1 版本的代码：使用 redis 自身事务保证原子性操作</strong> </p>
</blockquote>
<p>redis 事务相关命令复习</p>
<p>1、事务介绍</p>
<ol>
<li><p>Redis的事务是通过<code>MULTl，EXEC，DISCARD和WATCH</code>这四个命令来完成。</p>
</li>
<li><p>Redis的单个命令都是原子性的，所以这里确保事务性的对象是命令集合。</p>
</li>
<li><p>Redis将命令集合序列化并确保处于一事务的命令集合连续且不被打断的执行。</p>
</li>
<li><p>Redis<code>不支持回滚</code>的操作。</p>
</li>
</ol>
<p>2、相关命令</p>
<ul>
<li><code>MULTI</code><ul>
<li>用于标记事务块的开始。</li>
<li>Redis会将后续的命令逐个放入队列中，然后使用EXEC命令原子化地执行这个命令序列。</li>
<li>语法：MULTI</li>
</ul>
</li>
<li>EXEC<ul>
<li>在一个事务中执行所有先前放入队列的命令，然后恢复正常的连接状态。</li>
<li>语法：EXEC</li>
</ul>
</li>
<li>DISCARD<ul>
<li>清除所有先前在一个事务中放入队列的命令，然后恢复正常的连接状态。</li>
<li>语法：DISCARD</li>
</ul>
</li>
<li>WATCH<ul>
<li>当某个事务需要按条件执行时，就要使用这个命令将给定的键设置为受监控的状态。</li>
<li>语法：<code>WATCH key[key..…]</code></li>
<li>注：该命令可以实现<code>redis的乐观锁</code></li>
</ul>
</li>
<li>UNWATCH<ul>
<li>清除所有先前为一个事务监控的键。</li>
<li>语法：UNWATCH</li>
</ul>
</li>
</ul>
<p> <strong>演示事务的使用</strong> </p>
<p>ClienA 使用 <code>MULTI</code> 命令开启一个事务，并执行 <code>SET lock 1</code> 命令，当开启事务之后，执行命令返回 QUEUED，表示已经将该命令压入队列</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210513145742.png" srcset="/img/loading.gif"></p>
<p>ClientB 执行 <code>SET lock 2</code> 命令将 <code>lock</code> 的值设置为 <code>2</code></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210513145755.png" srcset="/img/loading.gif"></p>
<p>ClientA 执行 <code>EXEC</code> 命令提交事务，执行 <code>get lock</code> 命令获取到 <code>lock</code> 的值为 <code>1</code>（ClientB 虽然加塞，但不影响 ClientA 的事务，但这不是我们想要的效果）</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210513145810.png" srcset="/img/loading.gif"></p>
<p> <strong>演示 WATCH 的使用</strong> </p>
<p>ClientA 先使用 <code>WATCH lock</code> 命令见监视 <code>lock</code> 这把锁，然后使用 <code>MULTI</code> 命令开启事务修改 <code>lock</code> 的值</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210513145830.png" srcset="/img/loading.gif"></p>
<p>ClientB 执行 <code>set lock 4</code> 命令将 <code>lock</code> 的值修改为 <code>4</code></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210513145849.png" srcset="/img/loading.gif"></p>
<p>ClientA 执行 <code>EXEC</code> 命令提交事务，发现命令的返回值为 <code>nil</code>，表示事务执行失败，使用 <code>GET lock</code> 获取 <code>lock</code> 变量的值为 <code>4</code>（修改失败），<code>WATCH</code> 之后记得使用 <code>UNWATCH</code> 解除监视</p>
<h5 id="code"><a href="#code" class="headerlink" title="code"></a>code</h5><p>开启事务不断监视 <code>REDIS_LOCK_KEY</code> 这把锁有没有被别人动过，如果已经被别人动过了，那么继续重新执行删除操作，否则就解除监视</p>
<div class="hljs"><pre><code class="hljs java">&#125;<span class="hljs-keyword">finally</span> &#123;
            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;
                <span class="hljs-comment">//加事务，乐观锁</span>
                stringRedisTemplate.watch(REDIS_LOCK_KEY);
                <span class="hljs-comment">// 判断是否是自己加的锁</span>
                <span class="hljs-keyword">if</span> (value.equalsIgnoreCase(stringRedisTemplate.opsForValue().get(REDIS_LOCK_KEY))) &#123;
                    <span class="hljs-comment">// 开启事务</span>
                    stringRedisTemplate.setEnableTransactionSupport(<span class="hljs-keyword">true</span>);
                    stringRedisTemplate.multi();
                    stringRedisTemplate.delete(REDIS_LOCK_KEY);
                    <span class="hljs-comment">// 判断事务是否执行成功，如果等于 null，就是没有删掉，删除失败，再回去 while 循环那再重新执行删除</span>
                    List&lt;Object&gt; list = stringRedisTemplate.exec();
                    <span class="hljs-keyword">if</span> (list == <span class="hljs-keyword">null</span>) &#123;
                        <span class="hljs-keyword">continue</span>;
                    &#125;
                &#125;
                <span class="hljs-comment">//如果删除成功，释放监控器，并且 break 跳出当前循环</span>
                stringRedisTemplate.unwatch();
                <span class="hljs-keyword">break</span>;
            &#125;
        &#125;</code></pre></div>

<blockquote>
<p> <strong>8.1 版本的代码：使用 lua 脚本保证原子性操作</strong> </p>
</blockquote>
<p>redis 可以通过 <code>eval</code> 命令保证代码执行的原子性</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210513151456.png" srcset="/img/loading.gif"></p>
<p> <strong>1、RedisUtils 工具类</strong> </p>
<p><code>getJedis()</code> 方法用于从 <code>jedisPool</code> 中获取一个连接块对象</p>
<p>  <strong>2、使用 lua 脚本保证解锁操作的原子性</strong> </p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">finally</span> &#123;
    <span class="hljs-comment">// 获取连接对象</span>
    Jedis jedis = RedisUtils.getJedis();
    <span class="hljs-comment">// lua 脚本，摘自官网</span>
    String script = <span class="hljs-string">&quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1]&quot;</span> + <span class="hljs-string">&quot;then &quot;</span>
            + <span class="hljs-string">&quot;return redis.call(&#x27;del&#x27;, KEYS[1])&quot;</span> + <span class="hljs-string">&quot;else &quot;</span> + <span class="hljs-string">&quot;  return 0 &quot;</span> + <span class="hljs-string">&quot;end&quot;</span>;
    <span class="hljs-keyword">try</span> &#123;
        <span class="hljs-comment">// 执行 lua 脚本</span>
        Object result = jedis.eval(script, Collections.singletonList(REDIS_LOCK_KEY), Collections.singletonList(value));
        <span class="hljs-comment">// 获取 lua 脚本的执行结果</span>
        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;1&quot;</span>.equals(result.toString())) &#123;
            System.out.println(<span class="hljs-string">&quot;------del REDIS_LOCK_KEY success&quot;</span>);
        &#125; <span class="hljs-keyword">else</span> &#123;
            System.out.println(<span class="hljs-string">&quot;------del REDIS_LOCK_KEY error&quot;</span>);
        &#125;
    &#125; <span class="hljs-keyword">finally</span> &#123;
        <span class="hljs-comment">// 关闭链接</span>
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != jedis) &#123;
            jedis.close();
        &#125;
    &#125;
&#125;</code></pre></div>

<p>使用 lua 脚本可以防止别人动我们自己的锁</p>
<h4 id="自动续期版"><a href="#自动续期版" class="headerlink" title="自动续期版"></a>自动续期版</h4><blockquote>
<p> 存在的问题</p>
</blockquote>
<p>前面已经讲过了：我们<code>无法保证一个业务的执行时间</code>，有可能是 10s，有可能是 20s，也有可能更长。因为执行业务的时候可能会调用其他服务，我们并不能保证其他服务的调用时间。如果设置的锁过期了，当前业务还正在执行，那么之前设置的锁就失效了，就有可能出现超卖问题。</p>
<p>因此我们需要确保 redisLock 过期时间大于业务执行时间的问题，即面临如何对 Redis 分布式锁进行续期的问题</p>
<blockquote>
<p> redis 与 zookeeper 在 CAP 方面的对比</p>
</blockquote>
<ul>
<li>redis. AP</li>
</ul>
<p>redis <code>异步复制造成的锁丢失</code>， 比如：主节点没来的及把刚刚 set 进来这条数据给从节点，就挂了，那么主节点和从节点的数据就不一致。此时如果集群模式下，就得上 <code>Redisson</code> 来解决</p>
<ul>
<li>zookeeper. CP</li>
</ul>
<p>zookeeper 保持强一致性原则，对于集群中所有节点来说，要么同时更新成功，要么失败，因此使用 zookeeper 集群并不存在主从节点数据丢失的问题，但丢失了速度方面的性能</p>
<blockquote>
<p> 9.0 版本的代码：使用 Redisson 实现自动续期功能</p>
</blockquote>
<p>redis 集群环境下，我们自己写的也不OK，直接上 RedLock 之 Redisson 落地实现</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://redis.io/topics/distlock">redis 分布式锁</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/redisson/redisson">redisson GitHub 地址</a></li>
</ol>
<p> <strong>1、注入 Redisson 对象</strong> </p>
<p>在 <code>RedisConfig</code> 配置类中注入 <code>Redisson</code> 对象</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisConfig</span> </span>&#123;

    <span class="hljs-meta">@Value(&quot;$&#123;spring.redis.host&#125;&quot;)</span>
    <span class="hljs-keyword">private</span> String redisHost;

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Redisson <span class="hljs-title">redisson</span><span class="hljs-params">()</span> </span>&#123;
        Config config = <span class="hljs-keyword">new</span> Config();
        config.useSingleServer().setAddress(<span class="hljs-string">&quot;redis://&quot;</span> + redisHost + <span class="hljs-string">&quot;:6379&quot;</span>).setDatabase(<span class="hljs-number">0</span>);
        <span class="hljs-keyword">return</span> (Redisson) Redisson.create(config);
    &#125;

&#125;</code></pre></div>

<p> <strong>2、业务逻辑</strong> </p>
<p>直接 <code>redissonLock.lock()</code>、<code>redissonLock.unlock()</code> 完事儿，这就是 juc 版本的 redis 分布式锁啊</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String REDIS_LOCK_KEY = <span class="hljs-string">&quot;lockOneby&quot;</span>;

    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> StringRedisTemplate stringRedisTemplate;

    <span class="hljs-meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span>
    <span class="hljs-keyword">private</span> String serverPort;

    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> Redisson redisson;

    <span class="hljs-meta">@GetMapping(&quot;/buy_goods&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">buy_Goods</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        <span class="hljs-comment">// 获取锁</span>
        RLock redissonLock = redisson.getLock(REDIS_LOCK_KEY);
        <span class="hljs-comment">// 上锁</span>
        redissonLock.lock();

        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-comment">// 从 redis 中获取商品的剩余数量</span>
            String result = stringRedisTemplate.opsForValue().get(<span class="hljs-string">&quot;goods:001&quot;</span>);
            <span class="hljs-keyword">int</span> goodsNumber = result == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : Integer.parseInt(result);
            String retStr = <span class="hljs-keyword">null</span>;

            <span class="hljs-comment">// 商品数量大于零才能出售</span>
            <span class="hljs-keyword">if</span> (goodsNumber &gt; <span class="hljs-number">0</span>) &#123;
                <span class="hljs-keyword">int</span> realNumber = goodsNumber - <span class="hljs-number">1</span>;
                stringRedisTemplate.opsForValue().set(<span class="hljs-string">&quot;goods:001&quot;</span>, realNumber + <span class="hljs-string">&quot;&quot;</span>);
                retStr = <span class="hljs-string">&quot;你已经成功秒杀商品，此时还剩余：&quot;</span> + realNumber + <span class="hljs-string">&quot;件&quot;</span> + <span class="hljs-string">&quot;\t 服务器端口: &quot;</span> + serverPort;
            &#125; <span class="hljs-keyword">else</span> &#123;
                retStr = <span class="hljs-string">&quot;商品已经售罄/活动结束/调用超时，欢迎下次光临&quot;</span> + <span class="hljs-string">&quot;\t 服务器端口: &quot;</span> + serverPort;
            &#125;
            System.out.println(retStr);
            <span class="hljs-keyword">return</span> retStr;
        &#125; <span class="hljs-keyword">finally</span> &#123;
            <span class="hljs-comment">// 解锁</span>
            redissonLock.unlock();
        &#125;
    &#125;</code></pre></div>

<blockquote>
<p> <strong>9.1 版本的代码：Bug 的完善</strong> </p>
</blockquote>
<p>在超高并发的情况下，可能会抛出如下异常，原因是解锁 lock 的线程并不是当前线程</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210513154524.png" srcset="/img/loading.gif"></p>
<p>在释放锁之前加一个判断：还在持有锁的状态，并且是当前线程持有的锁再解锁</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">finally</span> &#123;
            <span class="hljs-comment">// 还在持有锁的状态，并且是当前线程持有的锁再解锁</span>
            <span class="hljs-keyword">if</span> (redissonLock.isLocked() &amp;&amp; redissonLock.isHeldByCurrentThread())&#123;
                redissonLock.unlock();
            &#125;
        &#125;</code></pre></div>

<h3 id="分布式锁总结"><a href="#分布式锁总结" class="headerlink" title="分布式锁总结"></a>分布式锁总结</h3><ol>
<li>synchronized 锁：单机版 OK，上 nginx分布式微服务，单机锁就不 OK,</li>
<li>分布式锁：取消单机锁，上 redis 分布式锁 SETNX</li>
<li>如果出异常的话，可能无法释放锁， 必须要在 finally 代码块中释放锁</li>
<li>如果宕机了，部署了微服务代码层面根本没有走到 finally 这块，也没办法保证解锁，因此需要有设置锁的过期时间</li>
<li>除了增加过期时间之外，还必须要 SETNX 操作和设置过期时间的操作必须为原子性操作</li>
<li>规定只能自己删除自己的锁，你不能把别人的锁删除了，防止张冠李戴，可使用 lua 脚本或者事务</li>
<li>判断锁所属业务与删除锁的操作也需要是原子性操作</li>
<li>redis 集群环境下，我们自己写的也不 OK，直接上 RedLock 之 Redisson 落地实现</li>
</ol>
<h2 id="Redis-缓存淘汰策略"><a href="#Redis-缓存淘汰策略" class="headerlink" title="Redis 缓存淘汰策略"></a>Redis 缓存淘汰策略</h2><blockquote>
<p> <strong>Redis 缓存淘汰策略相关的面试题</strong> </p>
</blockquote>
<ol>
<li>生产上你们的redis内存设置多少？</li>
<li>如何配置、修改redis的内存大小？</li>
<li>如果内存满了你怎么办？</li>
<li>redis 清理内存的方式？ <code>定期删除和惰性删除</code>了解过吗</li>
<li>redis 的 <code>缓存淘汰策略</code></li>
<li>redis 的 <code> LRU 淘汰机制</code>了解过吗？可否手写一个 LRU 算法</li>
</ol>
<h3 id="redis-内存满了怎么办"><a href="#redis-内存满了怎么办" class="headerlink" title="redis 内存满了怎么办"></a>redis 内存满了怎么办</h3><blockquote>
<p> <strong>redis 默认内存多少？在哪里查看? 如何设置修改?</strong> </p>
</blockquote>
<h4 id="1-如何查看-redis-最大占用内存"><a href="#1-如何查看-redis-最大占用内存" class="headerlink" title="1. 如何查看 redis 最大占用内存"></a>1. 如何查看 redis 最大占用内存</h4><p>在 redis.conf 配置文件中有一个，输入 <code>:set nu</code> 显示行号，大约在 800 多行有一个 <code>maxmemory</code> 字段，用预设值 redis 的最大占用内存</p>
<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210520095553.png" srcset="/img/loading.gif" style="zoom:50%;" />

<p>默认是字节类型，</p>
<h4 id="2-redis-会占用物理机器多少内存？"><a href="#2-redis-会占用物理机器多少内存？" class="headerlink" title="2. redis 会占用物理机器多少内存？"></a>2. redis 会占用物理机器多少内存？</h4><p>如果不设置最大内存大小或者设置最大内存大小为 0，在 64 位操作系统下不限制内存大小，在32位操作系统下最多使用 3GB 内存</p>
<h4 id="3-一般生产上如何配置-redis-的内存"><a href="#3-一般生产上如何配置-redis-的内存" class="headerlink" title="3. 一般生产上如何配置 redis 的内存"></a>3. 一般生产上如何配置 redis 的内存</h4><p>一般推荐Redis设置内存为最大物理内存的四分之三，也就是 <code>0.75</code></p>
<h4 id="4-如何修改-redis-内存设置"><a href="#4-如何修改-redis-内存设置" class="headerlink" title="4. 如何修改 redis 内存设置"></a>4. 如何修改 redis 内存设置</h4><ul>
<li>通过修改文件配置（永久生效）：修改 maxmemory 字段，单位为字节</li>
<li>通过命令修改（重启失效）：<code>config set maxmemory 104857600</code> 设置 redis 最大占用内存为 100MB，<code>config get maxmemory</code> 获取 redis 最大占用内存</li>
</ul>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210520095806.png" srcset="/img/loading.gif"></p>
<h4 id="5-通过命令查看-redis-内存使用情况"><a href="#5-通过命令查看-redis-内存使用情况" class="headerlink" title="5. 通过命令查看 redis 内存使用情况?"></a>5. 通过命令查看 redis 内存使用情况?</h4><p>通过 info 指令可以查看 redis 内存使用情况：<code>used_memory_human</code> 表示实际已经占用的内存，<code>maxmemory</code> 表示 redis 最大占用内存</p>
<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210520095925.png" srcset="/img/loading.gif" style="zoom:50%;" />

<blockquote>
<p> <strong>如果把 redis 内存打满了会发生什么? 如果 redis 内存使用超出了设置的最大值会怎样?</strong> </p>
</blockquote>
<p>修改配置，故意把最大内存设置为 1byte，再通过 <code>set k1 v1</code> 命令下 redis 中写入数据，redis 将会报错：<code>(error) OOM command not allowed when used memory &gt; ‘maxmemory’</code></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210520100023.png" srcset="/img/loading.gif"></p>
<blockquote>
<p> <strong>总结 &amp; 结论</strong> </p>
</blockquote>
<p>如果设置了 <code>maxmemory</code> 的选项，假如 redis 内存使用达到上限，并且 key 都没有加上过期时间，就会导致数据写爆 redis 内存。</p>
<p>为了避免类似情况，于是引出下一部分的内存淘汰策略</p>
<h3 id="redis-缓存淘汰策略"><a href="#redis-缓存淘汰策略" class="headerlink" title="redis 缓存淘汰策略"></a>redis 缓存淘汰策略</h3><blockquote>
<p> <strong>redis 如何删除设置了过期时间的 key</strong> </p>
</blockquote>
<h4 id="1-redis过期键的删除策略"><a href="#1-redis过期键的删除策略" class="headerlink" title="1. redis过期键的删除策略"></a>1. redis过期键的删除策略</h4><p>如果一个键是过期的，那它到了过期时间之后是不是马上就从内存中被删除呢？那么过期后到底什么时候被删除呢？redis 如何操作的呢？</p>
<p>通过查看 redis 配置文件可知，默认淘汰策略是    <code>【noeviction（Don’t evict anything, just return an error on write operations.）】</code>，如果 redis 内存被写爆了，直接返回 error</p>
<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210520100833.png" srcset="/img/loading.gif" style="zoom:50%;" />

<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210520101019.png" srcset="/img/loading.gif" style="zoom:50%;" />

<blockquote>
<p> <strong>redis 对于过期 key 的三种不同删除策略</strong> </p>
</blockquote>
<h5 id="定时删除"><a href="#定时删除" class="headerlink" title="定时删除"></a>定时删除</h5><p>立即删除能 <code>保证内存中数据的最大新鲜度</code>，因为它保证过期键值会在过期后马上被删除，其所占用的内存也会随之释放。但是立即删除对 CPU 是最不友好的。因为删除操作会占用 CPU 的时间，如果刚好碰上了 CPU 很忙的时候，比如正在做交集或排序等计算的时候，就会<code>给 CPU 造成额外的压力</code>，让 CPU 心累，时时需要删除，忙死，这会产生大量的性能消耗，同时也会影响数据的读取操作。</p>
<p>总结：定时删除对 CPU 不友好，但对 memory 友好，用<code>处理器性能换取存储空间（拿时间换空间）</code></p>
<h5 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h5><p>惰性删除的策略刚好和定时删除相反，惰性删除在数据到达过期时间后不做处理，<code>等下次访问该数据时发现已过期</code>，并将其删除，并返回不存在。</p>
<p>使用惰性删除访问数据的<code>特点</code>：访问一个数据，如果发现其在过期时间之内，则返回改数据；如果发现已经过了过期时间，则将其删除，并返回不存在</p>
<p>如果一个键已经过期，而这个键又仍然保留在数据库中，那么只要这个过期键不被删除，它所占用的内存就不会释放。因此惰性删除策略的缺点是：<code>它对内存是最不友好的</code>。</p>
<p>在使用惰性删除策略时，如果数据库中有非常多的过期键，而这些过期键又恰好没有被访问到的话，那么它们也许永远也不会被删除（除非用户手动执行 FLUSHDB），我们甚至可以将这种情况看作是一种内存泄漏——无用的垃圾数据占用了大量的内存，而服务器却不会自己去释放它们，这对于运行状态非常依赖于内存的 redis 服务器来说，肯定不是一个好消息</p>
<p>总结：惰性删除<code>对 memory 不友好</code>，但对 CPU 友好，用存储空间换取处理器性能（拿空间换时间）</p>
<h5 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a>定期删除</h5><blockquote>
<p> 折中方案：定期删除</p>
</blockquote>
<p>上面两种删除策略都走极端，因此引出我们的定期删除策略。</p>
<p>定期删除策略是前两种策略的折中：定期删除策略<code>每隔一段时间执行一次删除过期键操作，并通过限制删除操作执行的时长和频率来减少删除操作对 CPU 时间的影响</code>。其做法为：周期性轮询 redis 库中的时效性数据，采用随机抽取的策略，利用过期数据占比的方式控制删除频度。</p>
<blockquote>
<p> 定期删除的特点</p>
</blockquote>
<p>特点1：CPU 性能占用设置有峰值，检测频度可自定义设置</p>
<p>特点2：内存压力不是很大，长期占用内存的冷数据会被持续清理</p>
<p>总结：周期性抽查存储空间（随机抽查，重点抽查)</p>
<blockquote>
<p>定期删除的举例</p>
</blockquote>
<p>redis 默认每间隔 100ms 检查是否有过期的 key，如果有过期 key 则删除。注意：redis 不是每隔100ms 将所有的 key 检查一次而是随机抽取进行检查（如果每隔 100ms，全部 key 进行检查，redis 直接进去ICU）。因此，<code>如果只采用定期删除策略，会导致很多 key 到时间没有删除</code>。</p>
<blockquote>
<p>定期删除的难点</p>
</blockquote>
<p>定期删除策略的难点是<code>确定删除操作执行的时长和频率</code>：redis 不可能时时刻刻遍历所有被设置了生存时间的 key，来检测数据是否已经到达过期时间，然后对它进行删除。</p>
<p>如果删除操作执行得太频繁，或者执行的时间太长，定期删除策略就会退化成定时删除策略，以至于将 CPU 时间过多地消耗在删除过期键上面。</p>
<p>如果删除操作执行得太少，或者执行的时间太短，定期删除策略又会和惰性删除束略一样，出现浪费内存的情况。</p>
<p>因此，如果采用定期删除策略的话，服务器必须根据情况，合理地设置删除操作的执行时长和执行频率。</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>惰性删除和定期删除都存在数据没有被抽到的情况，如果这些数据已经到了过期时间，没有任何作用，这会导致大量过期的 key 堆积在内存中，导致 redis 内存空间紧张或者很快耗尽</p>
<p>因此必须要有一个更好的兜底方案，接下来引出 <code>redis 内存淘汰策略</code></p>
<h4 id="2-redis-内存淘汰策略"><a href="#2-redis-内存淘汰策略" class="headerlink" title="2. redis 内存淘汰策略"></a>2. redis 内存淘汰策略</h4><blockquote>
<p> <strong>redis 6.0.8 版本的内存淘汰策略有哪些？</strong> </p>
</blockquote>
<p> <strong>8 种内存淘汰策略</strong> </p>
<ol>
<li>noeviction：不会驱逐任何key</li>
<li>allkeys-lru：对所有key使用LRU算法进行删除</li>
<li>volatile-lru：对所有设置了过期时间的key使用LRU算法进行删除</li>
<li>allkeys-random：对所有key随机删除</li>
<li>volatile-random：对所有设置了过期时间的key随机删除</li>
<li>volatile-ttl：删除马上要过期的key</li>
<li>allkeys-lfu：对所有key使用LFU算法进行删除</li>
<li>volatile-lfu：对所有设置了过期时间的key使用LFU算法进行删除</li>
</ol>
<ol>
<li><code>2个维度</code><ol>
<li>过期键中筛选</li>
<li>所有键中筛选</li>
</ol>
</li>
<li><code>4个方面</code><ol>
<li>LRU (Least Recently Used)</li>
<li>LFU (LEast Frequently Used)</li>
<li>random</li>
<li>ttl</li>
</ol>
</li>
</ol>
<blockquote>
<p>如何配置 redis 的内存淘汰策略</p>
</blockquote>
<ul>
<li><p>通过修改文件配置（永久生效）：配置 <code>maxmemory-policy</code> 字段</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210520102048.png" srcset="/img/loading.gif"></p>
</li>
<li><p>通过命令修改（重启失效）：<code>config set maxmemory-policy allkeys-lru</code> 命令设置内存淘汰策略，<code>config get maxmemory-policy</code> 命令获取当前采用的内存淘汰策略</p>
</li>
</ul>
<h3 id="redis-LRU-算法"><a href="#redis-LRU-算法" class="headerlink" title="redis LRU 算法"></a>redis LRU 算法</h3><p>LRU 是 Least Recently Used 的缩写，即最近最少使用，是一种常用的 <code>页面置换算法</code>，每次选择<code>最近最久未使用的页面予以淘汰</code></p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lru-cache/">146. LRU 缓存机制</a></p>
<p>运用你所掌握的数据结构，设计和实现一个 LRU (最近最少使用) 缓存机制 。</p>
<p>实现 <code>LRUCache</code> 类：</p>
<ol>
<li><code>LRUCache(int capacity)</code> 以正整数作为容量 <code>capacity </code>初始化 LRU 缓存</li>
<li><code>int get(int key)</code> 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。</li>
<li><code>void put(int key, int value) </code>如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它<code>应该在写入新数据之前删除最久未使用的数据值</code>，从而为新的数据值留出空间。</li>
</ol>
<p> <strong>进阶</strong> ：你是否可以在 <code>O(1)</code> 时间复杂度内完成这两种操作？</p>
<h4 id="LRU-算法设计思想"><a href="#LRU-算法设计思想" class="headerlink" title="LRU 算法设计思想"></a>LRU 算法设计思想</h4><p>查找和插入的时间复杂度为 <code>O(1)</code>，HashMap 没得跑了，但是 HashMap 是无序的集合，怎么样将其改造为有序集合呢？答案就是在各个 Node 节点之间增加 <code>prev</code> 指针和 <code>next</code> 指针，构成双向链表</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210520103035.png" srcset="/img/loading.gif"></p>
<p>LRU 的算法核心是哈希链表，本质就是 <code>HashMap+DoubleLinkedList</code> 时间复杂度是O(1)，哈希表+双向链表的结合体，下面这幅动图完美诠释了 HashMap+DoubleLinkedList 的工作原理</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/imgLRU.gif" srcset="/img/loading.gif"></p>
<h4 id="LRU-算法编码实现"><a href="#LRU-算法编码实现" class="headerlink" title="LRU 算法编码实现"></a>LRU 算法编码实现</h4><h5 id="1-借助-JDK-自带的-LinkedHashMap"><a href="#1-借助-JDK-自带的-LinkedHashMap" class="headerlink" title="1. 借助 JDK 自带的 LinkedHashMap"></a>1. 借助 JDK 自带的 LinkedHashMap</h5><p><code>LinkedHashMap</code> 的注释中写明了： <code>LinkedHashMap</code> 非常适合用来构建 LRU 缓存</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210520103419.png" srcset="/img/loading.gif"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210520103911.png" srcset="/img/loading.gif"></p>
<p>通过继承 <code>LinkedHashMap</code>，重写 <code>boolean removeEldestEntry(Map.Entry&lt;K, V&gt; eldest)</code> 方法就完事</p>
<p>构造方法</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210520104136.png" srcset="/img/loading.gif"></p>
<p>false 插入顺序，true 访问顺序</p>
<h6 id="code-1"><a href="#code-1" class="headerlink" title="code"></a>code</h6><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LRUCacheDemo</span>&lt;<span class="hljs-title">K</span>, <span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">LinkedHashMap</span>&lt;<span class="hljs-title">K</span>, <span class="hljs-title">V</span>&gt; </span>&#123;

    <span class="hljs-keyword">int</span> capacity;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LRUCacheDemo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>&#123;
        <span class="hljs-keyword">super</span>(capacity, <span class="hljs-number">0.75F</span>, <span class="hljs-keyword">true</span>);
        <span class="hljs-keyword">this</span>.capacity = capacity;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">removeEldestEntry</span><span class="hljs-params">(Map.Entry&lt;K, V&gt; eldest)</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.size() &gt; capacity;
    &#125;
&#125;</code></pre></div>

<h6 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h6><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
    LRUCacheDemo lruCacheDemo = <span class="hljs-keyword">new</span> LRUCacheDemo(<span class="hljs-number">3</span>);

    lruCacheDemo.put(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;a&quot;</span>);
    lruCacheDemo.put(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;b&quot;</span>);
    lruCacheDemo.put(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;c&quot;</span>);
    System.out.println(lruCacheDemo.keySet());

    lruCacheDemo.put(<span class="hljs-number">4</span>, <span class="hljs-string">&quot;d&quot;</span>);
    System.out.println(lruCacheDemo.keySet());

    lruCacheDemo.put(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;c&quot;</span>);
    System.out.println(lruCacheDemo.keySet());
    lruCacheDemo.put(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;c&quot;</span>);
    System.out.println(lruCacheDemo.keySet());
    lruCacheDemo.put(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;c&quot;</span>);
    System.out.println(lruCacheDemo.keySet());
    lruCacheDemo.put(<span class="hljs-number">5</span>, <span class="hljs-string">&quot;x&quot;</span>);
    System.out.println(lruCacheDemo.keySet());
&#125;</code></pre></div>

<div class="hljs"><pre><code class="hljs ruby">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]
[<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]
[<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>]
[<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>]
[<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>]
[<span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>]</code></pre></div>

<h6 id="重写removeEldestEntry"><a href="#重写removeEldestEntry" class="headerlink" title="重写removeEldestEntry"></a>重写removeEldestEntry</h6><blockquote>
<p> 为何要重写 boolean removeEldestEntry(Map.Entry&lt;K, V&gt; eldest) 方法</p>
</blockquote>
<p>先来看看 <code>LinkedHashMap</code> 中的 <code>boolean removeEldestEntry(Map.Entry&lt;K, V&gt; eldest)</code> 方法，直接<code> return false</code>，缓存爆就爆，反正就是不会删除 EldestEntry</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">removeEldestEntry</span><span class="hljs-params">(Map.Entry&lt;K,V&gt; eldest)</span> </span>&#123;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
&#125;</code></pre></div>

<p><code>boolean removeEldestEntry(Map.Entry&lt;K, V&gt; eldest)</code> 方法在 <code>void afterNodeInsertion(boolean evict) </code>方法中被调用，只有当 boolean removeEldestEntry(Map.Entry&lt;K, V&gt; eldest) 方法返回<code> true</code> 时，才能够删除 EldestEntry</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">afterNodeInsertion</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> evict)</span> </span>&#123; <span class="hljs-comment">// possibly remove eldest</span>
    LinkedHashMap.Entry&lt;K,V&gt; first;
    <span class="hljs-keyword">if</span> (evict &amp;&amp; (first = head) != <span class="hljs-keyword">null</span> &amp;&amp; removeEldestEntry(first)) &#123;
        K key = first.key;
        removeNode(hash(key), key, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>);
    &#125;
&#125;</code></pre></div>

<p>因此我们重写之后的判断条件为：如果 <code>LinkedHashMap</code> 中存储的元素个数已经大于缓存容量 <code>capacity</code>，则返回 <code>true</code>，表示允许删除 <code>EldestEntry</code>；否则返回 <code>false</code>，表示无需删除 <code>EldestEntry</code></p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">removeEldestEntry</span><span class="hljs-params">(Map.Entry&lt;K, V&gt; eldest)</span> </span>&#123;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.size() &gt; capacity;
&#125;</code></pre></div>

<h6 id="accessOrder构造含义"><a href="#accessOrder构造含义" class="headerlink" title="accessOrder构造含义"></a>accessOrder构造含义</h6><p><strong>举例说明构造函数中的 <code>accessOrder</code> 的含义</strong> </p>
<p> <strong>构造函数中的 <code>accessOrder</code> 字段</strong> </p>
<p>在 <code>LRUCacheDemo</code> 的构造方法中，我们调用了 <code>LinkedHashMap</code> 的构造方法，其中有一个字段为 <code>accessOrder</code></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210520105153.png" srcset="/img/loading.gif"></p>
<ul>
<li>accessOrder = true 和 accessOrder = false 的情况<ul>
<li>当 accessOrder = true 时，每次使用 key 时（put 或者 get 时），都将 key 对应的数据移动到队尾（右边），表示最近经常使用；</li>
<li>当 accessOrder = false 时，key 的顺序为插入双向链表时的顺序<br><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210520105242.png" srcset="/img/loading.gif"></li>
</ul>
</li>
</ul>
<h6 id="put方法区别"><a href="#put方法区别" class="headerlink" title="put方法区别"></a>put方法区别</h6><p><strong><code>LinkedHashMap</code> 的 <code>put()</code> 方法</strong></p>
<p><code>LinkedHashMap</code> 的 <code>put()</code> 方法其实就是 <code>HashMap</code> 的 <code>put()</code> 方法，<code>LinkedHashMap</code> 就是 <code>HashMap</code>？</p>
<ul>
<li>其实并不是。</li>
</ul>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210520105943.png" srcset="/img/loading.gif"></p>
<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210520110053.png" srcset="/img/loading.gif" style="zoom:50%;" />

<p>在 <code>putval()</code> 方法的调用了两个方法：<code>afterNodeAccess(e)</code> 方法和 <code>afterNodeInsertion(evict)</code> 方法，这两个方法就是专门针对于 <code>LinkedHashMap</code> 写的方法</p>
<p>在 HashMap 中这些方法均为空实现的方法，没有任何代码逻辑，需要推迟到子类 <code>LinkedHashMap</code> 中去实现，就是<code>模板方法设计模式</code>嘛</p>
<h6 id="afterNodeAccess"><a href="#afterNodeAccess" class="headerlink" title="afterNodeAccess"></a>afterNodeAccess</h6><p>在 LinkedHashMap 的 <code>void afterNodeAccess(Node&lt;K,V&gt; e) </code>方法中：如果设置了 accessOrder = true 时，则每次使用 key 时（put 或者 get 时），都将 key 对应的数据移动到<code>队尾（右边）</code>，表示这是最近经常使用的节点<br><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210520110428.png" srcset="/img/loading.gif"></p>
<h6 id="afterNodeInsertion"><a href="#afterNodeInsertion" class="headerlink" title="afterNodeInsertion"></a>afterNodeInsertion</h6><p>在 LinkedHashMap 的 <code>void afterNodeInsertion(boolean evict)</code> 方法中：如果头指针不为空并且当前需要删除老节点，则执行<code>removeNode(hash(key), key, null, false, true)</code>方法删除 <code>EldestEntry</code>（若 accessOrder = true 时，EldestEntry 表示最近最少使用的数据，若 accessOrder = false 时，EldestEntry 表示<code>最先插入链表的节点</code>）</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">afterNodeInsertion</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> evict)</span> </span>&#123; <span class="hljs-comment">// possibly remove eldest</span>
    LinkedHashMap.Entry&lt;K,V&gt; first;
    <span class="hljs-keyword">if</span> (evict &amp;&amp; (first = head) != <span class="hljs-keyword">null</span> &amp;&amp; removeEldestEntry(first)) &#123;
        K key = first.key;
        removeNode(hash(key), key, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>);
    &#125;
&#125;</code></pre></div>

<h6 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h6><p>在 <code>LinkedHashMap</code> 的 <code>get()</code> 方法中：若 <code>accessOrder = true</code> 时，则每次 <code>get(key)</code> 之后都会将 key 对应的数据移动至双向链表的尾部</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">get</span><span class="hljs-params">(Object key)</span> </span>&#123;
    Node&lt;K,V&gt; e;
    <span class="hljs-keyword">if</span> ((e = getNode(hash(key), key)) == <span class="hljs-keyword">null</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    <span class="hljs-keyword">if</span> (accessOrder)
        afterNodeAccess(e);
    <span class="hljs-keyword">return</span> e.value;
&#125;</code></pre></div>

<p> <strong>LinkedHashMap 中如何构造双向链表？</strong> </p>
<p><code>Entry&lt;K,V&gt;</code> 继承了 <code>HashMap.Node&lt;K,V&gt;</code>，并且有 <code>Entry&lt;K,V&gt; before, after;</code> 两个字段，这不就是双线链表的标配嘛</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * HashMap.Node subclass for normal LinkedHashMap entries.</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">HashMap</span>.<span class="hljs-title">Node</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>&#123;
    Entry&lt;K,V&gt; before, after;
    Entry(<span class="hljs-keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;
        <span class="hljs-keyword">super</span>(hash, key, value, next);
    &#125;
&#125;</code></pre></div>

<p>在 LinkedHashMap 中定义了 head 和 tail ，分别指向双向链表的头部和尾部，人家注释中也说了，head 用于指向双向链表中最老的节点，tail 用于指向最年轻的节点，至于最老和最年轻的定义，就得看 accessOrder 字段的值了：如果 accessOrder = true，那么<code>最老的节点就是最久没有被使用过的节点</code>，最年轻的节点就是最近被刚被使用过的节点；如果 accessOrder = true，那么<code>最老的节点就是链表头部的节点</code>，最年轻的节点就是链表尾部的节点</p>
<h5 id="2-完全自己手写"><a href="#2-完全自己手写" class="headerlink" title="2. 完全自己手写"></a>2. <strong>完全自己手写</strong></h5><ul>
<li><code>DoubleLinkedList</code> 双向链表的初始化</li>
</ul>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210520112845.png" srcset="/img/loading.gif"></p>
<ul>
<li>双向链表插入节点</li>
</ul>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210520113020.png" srcset="/img/loading.gif"></p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// 3.添加到头</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addHead</span><span class="hljs-params">(Node&lt;K, V&gt; node)</span> </span>&#123;
    node.next = head.next;
    node.prev = head;
    head.next.prev = node;
    head.next = node;
&#125;</code></pre></div>
<ul>
<li>双向链表删除节点</li>
</ul>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210520113101.png" srcset="/img/loading.gif"></p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// 4.删除节点</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeNode</span><span class="hljs-params">(Node&lt;K, V&gt; node)</span> </span>&#123;
    node.next.prev = node.prev;
    node.prev.next = node.next;
    node.prev = <span class="hljs-keyword">null</span>;
    node.next = <span class="hljs-keyword">null</span>;
&#125;</code></pre></div>



<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LRUCache</span> </span>&#123;
    <span class="hljs-comment">// map 负责查找，构建一个虚拟的双向链表，它里面装的就是一个个 Node 节点，作为数据载体</span>

    <span class="hljs-comment">// 1.构造一个node节点作为数据载体</span>
    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">K</span>, <span class="hljs-title">V</span>&gt; </span>&#123;
        K key;
        V value;
        Node&lt;K, V&gt; prev;
        Node&lt;K, V&gt; next;

        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">()</span> </span>&#123;
            <span class="hljs-keyword">this</span>.prev = <span class="hljs-keyword">this</span>.next = <span class="hljs-keyword">null</span>;
        &#125;

        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(K key, V value)</span> </span>&#123;
            <span class="hljs-keyword">this</span>.key = key;
            <span class="hljs-keyword">this</span>.value = value;
            <span class="hljs-keyword">this</span>.prev = <span class="hljs-keyword">this</span>.next = <span class="hljs-keyword">null</span>;
        &#125;
    &#125;

    <span class="hljs-comment">// 2.构建一个虚拟的双向链表,,里面安放的就是我们的Node</span>
    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DoubleLinkedList</span>&lt;<span class="hljs-title">K</span>, <span class="hljs-title">V</span>&gt; </span>&#123;
        Node&lt;K, V&gt; head;
        Node&lt;K, V&gt; tail;

        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DoubleLinkedList</span><span class="hljs-params">()</span> </span>&#123;
            head = <span class="hljs-keyword">new</span> Node&lt;&gt;();
            tail = <span class="hljs-keyword">new</span> Node&lt;&gt;();
            head.next = tail;
            tail.prev = head;
        &#125;

        <span class="hljs-comment">// 3.添加到头</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addHead</span><span class="hljs-params">(Node&lt;K, V&gt; node)</span> </span>&#123;
            node.next = head.next;
            node.prev = head;
            head.next.prev = node;
            head.next = node;
        &#125;

        <span class="hljs-comment">// 4.删除节点</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeNode</span><span class="hljs-params">(Node&lt;K, V&gt; node)</span> </span>&#123;
            node.next.prev = node.prev;
            node.prev.next = node.next;
            node.prev = <span class="hljs-keyword">null</span>;
            node.next = <span class="hljs-keyword">null</span>;
        &#125;

        <span class="hljs-comment">// 5.获得最后一个节点</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> Node <span class="hljs-title">getLast</span><span class="hljs-params">()</span> </span>&#123;
            <span class="hljs-keyword">return</span> tail.prev;
        &#125;
    &#125;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> cacheSize;
    Map&lt;Integer, Node&lt;Integer, Integer&gt;&gt; map;
    DoubleLinkedList&lt;Integer, Integer&gt; doubleLinkedList;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LRUCache</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cacheSize)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.cacheSize = cacheSize;<span class="hljs-comment">//坑位</span>
        map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<span class="hljs-comment">//查找</span>
        doubleLinkedList = <span class="hljs-keyword">new</span> DoubleLinkedList&lt;&gt;();
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (!map.containsKey(key)) &#123;
            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
        &#125;

        Node&lt;Integer, Integer&gt; node = map.get(key);
        doubleLinkedList.removeNode(node);
        doubleLinkedList.addHead(node);

        <span class="hljs-keyword">return</span> node.value;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> value)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (map.containsKey(key)) &#123;  <span class="hljs-comment">//update</span>
            Node&lt;Integer, Integer&gt; node = map.get(key);
            node.value = value;
            map.put(key, node);

            doubleLinkedList.removeNode(node);
            doubleLinkedList.addHead(node);
        &#125; <span class="hljs-keyword">else</span> &#123;
            <span class="hljs-keyword">if</span> (map.size() == cacheSize)  <span class="hljs-comment">//坑位满了</span>
            &#123;
                Node&lt;Integer, Integer&gt; lastNode = doubleLinkedList.getLast();
                map.remove(lastNode.key);
                doubleLinkedList.removeNode(lastNode);
            &#125;

            <span class="hljs-comment">//新增一个</span>
            Node&lt;Integer, Integer&gt; newNode = <span class="hljs-keyword">new</span> Node&lt;&gt;(key, value);
            map.put(key, newNode);
            doubleLinkedList.addHead(newNode);
        &#125;
    &#125;
&#125;</code></pre></div>


            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/04/22/mysql/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">mysql索引</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/04/11/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9A%84%E5%89%AF%E6%9C%AC/">
                        <span class="hidden-mobile">高频面试题</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments">
                
                

              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":200})
    NProgress.start()
    document.addEventListener('DOMContentLoaded', function() {
      window.NProgress && window.NProgress.inc();
    })
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.staticfile.org/jquery/3.5.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.staticfile.org/tocbot/4.12.0/tocbot.min.js" ></script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>





  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      var inputArea = document.querySelector("#local-search-input");
      inputArea.onclick = function () {
        searchFunc(path, 'local-search-input', 'local-search-result');
        this.onclick = null
      }
    })()
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>



<!-- hexo injector body_end start -->
  <script src="/js/custom.js"></script>
<!-- hexo injector body_end end --></body>
</html>
