

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/imgfavicon.jpg">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  <title>mysql索引 - Blog</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.1.2/styles/ocean.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.5","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"copy_btn":true,"image_zoom":{"enable":true},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.2.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Main</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax=true
         style="background: url('https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/imgdefault.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="mysql索引">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-04-22 11:11" pubdate>
        2021年4月22日 上午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      26.6k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      329
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">mysql索引</h1>
            
            <div class="markdown-body">
              <h1 id="Mysql高级-day01"><a href="#Mysql高级-day01" class="headerlink" title="Mysql高级-day01"></a>Mysql高级-day01</h1><h2 id="MySQL高级课程简介"><a href="#MySQL高级课程简介" class="headerlink" title="MySQL高级课程简介"></a>MySQL高级课程简介</h2><table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>序号</td>
<td>Day01</td>
<td>Day02</td>
<td>Day03</td>
<td>Day04</td>
</tr>
<tr>
<td>1</td>
<td>Linux系统安装MySQL</td>
<td>体系结构</td>
<td>应用优化</td>
<td>MySQL 常用工具</td>
</tr>
<tr>
<td>2</td>
<td>索引</td>
<td>存储引擎</td>
<td>查询缓存优化</td>
<td>MySQL 日志</td>
</tr>
<tr>
<td>3</td>
<td>视图</td>
<td>优化SQL步骤</td>
<td>内存管理及优化</td>
<td>MySQL 主从复制</td>
</tr>
<tr>
<td>4</td>
<td>存储过程和函数</td>
<td>索引使用</td>
<td>MySQL锁问题</td>
<td>综合案例</td>
</tr>
<tr>
<td>5</td>
<td>触发器</td>
<td>SQL优化</td>
<td>常用SQL技巧</td>
<td></td>
</tr>
</tbody></table>
<h2 id="1-Linux-系统安装MySQL"><a href="#1-Linux-系统安装MySQL" class="headerlink" title="1. Linux 系统安装MySQL"></a>1. Linux 系统安装MySQL</h2><h3 id="1-1-下载Linux-安装包"><a href="#1-1-下载Linux-安装包" class="headerlink" title="1.1 下载Linux 安装包"></a>1.1 下载Linux 安装包</h3><div class="hljs"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>dev.mysql.com<span class="hljs-regexp">/downloads/my</span>sql/<span class="hljs-number">5.7</span>.html<span class="hljs-comment">#downloads</span></code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210521100936.png" srcset="/img/loading.gif"></p>
<h3 id="1-2-安装MySQL"><a href="#1-2-安装MySQL" class="headerlink" title="1.2 安装MySQL"></a>1.2 安装MySQL</h3><div class="hljs"><pre><code class="hljs markdown">1). 卸载 centos 中预安装的 mysql
  rpm -qa | grep -i mysql
  rpm -e mysql-libs-5.1.71-1.el6.x86<span class="hljs-emphasis">_64 --nodeps</span>
<span class="hljs-emphasis">2). 上传 mysql 的安装包</span>
<span class="hljs-emphasis">	alt + p -------&gt; put E:/test/MySQL-5.6.22-1.el6.i686.rpm-bundle.tar</span>
<span class="hljs-emphasis">3). 解压 mysql 的安装包</span>
<span class="hljs-emphasis">  mkdir mysql</span>
<span class="hljs-emphasis">  tar -xvf MySQL-5.6.22-1.el6.i686.rpm-bundle.tar -C /root/mysql</span>
<span class="hljs-emphasis">4). 安装依赖包</span>
<span class="hljs-emphasis">  yum -y install libaio.so.1 libgcc_</span>s.so.1 libstdc++.so.6 libncurses.so.5 --
  setopt=protected<span class="hljs-emphasis">_</span>
<span class="hljs-emphasis">  multilib=false</span>
<span class="hljs-emphasis">  yum update libstdc++-4.4.7-4.el6.x86_</span>64
5). 安装 mysql-client
  rpm -ivh MySQL-client-5.6.22-1.el6.i686.rpm
6). 安装 mysql-server
  rpm -ivh MySQL-server-5.6.22-1.el6.i686.rpm</code></pre></div>

<h3 id="1-3-启动-MySQL-服务"><a href="#1-3-启动-MySQL-服务" class="headerlink" title="1.3 启动 MySQL 服务"></a>1.3 启动 MySQL 服务</h3><div class="hljs"><pre><code class="hljs markdown">service mysql start

service mysql stop

service mysql status

service mysql restart</code></pre></div>

<h3 id="1-4-登录MySQL"><a href="#1-4-登录MySQL" class="headerlink" title="1.4 登录MySQL"></a>1.4 登录MySQL</h3><div class="hljs"><pre><code class="hljs markdown">mysql 安装完成之后, 会自动生成一个随机的密码, 并且保存在一个密码文件中 : /root/.mysql<span class="hljs-emphasis">_secret</span>
<span class="hljs-emphasis"></span>
<span class="hljs-emphasis">mysql -u root -p </span>
<span class="hljs-emphasis"></span>
<span class="hljs-emphasis">登录之后, 修改密码 :</span>
<span class="hljs-emphasis"></span>
<span class="hljs-emphasis">set password = password(&#x27;itcast&#x27;);</span>
<span class="hljs-emphasis"></span>
<span class="hljs-emphasis">授权远程访问 : </span>
<span class="hljs-emphasis"></span>
<span class="hljs-emphasis">grant all privileges on *.* to &#x27;root&#x27; @&#x27;%&#x27; identified by &#x27;itcast&#x27;;</span>
<span class="hljs-emphasis">flush privileges;</span></code></pre></div>

<h2 id="2-索引"><a href="#2-索引" class="headerlink" title="2. 索引"></a>2. 索引</h2><h3 id="2-1-索引概述"><a href="#2-1-索引概述" class="headerlink" title="2.1 索引概述"></a>2.1 索引概述</h3><p>MySQL官方对索引的定义为：</p>
<p>​        索引（index）是帮助MySQL<code>高效获取数据的数据结构（有序）</code>。在数据之外，数据库系统还维护者满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据， 这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。如下面的==示意图==所示 :</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210521101335.png" srcset="/img/loading.gif"></p>
<p>左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址（注意逻辑上相邻的记录在磁盘上也并不是一定物理相邻的），查找会自上而下的遍历。为了加快Col2的查找，可以维护一个右边所示的<code>二叉查找树</code>，每个节点分别包含<code>索引键值</code>和<code>一个指向对应数据记录物理地址的指针</code>，这样就可以运用二叉查找快速获取到相应数据。</p>
<ul>
<li>一般来说索引本身也很大，不可能全部存储在内存中。</li>
<li>因此<code>索引往往以索引文件的形式存储在磁盘上</code>。</li>
<li>索引是数据库中用来提高性能的最常用的工具。</li>
</ul>
<h3 id="2-2-索引优势劣势"><a href="#2-2-索引优势劣势" class="headerlink" title="2.2 索引优势劣势"></a>2.2 索引优势劣势</h3><blockquote>
<p>优势</p>
</blockquote>
<p>1） 类似于书籍的目录索引，提高数据检索的效率，降低数据库的IO成本。</p>
<p>2） 通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗。</p>
<blockquote>
<p>劣势</p>
</blockquote>
<p>1） 实际上索引也是一张表，该表中保存了主键与索引字段，并指向实体类的记录，所以索引列也是要<code>占用空间</code>的。</p>
<p>2） 虽然索引大大提高了查询效率，同时却也<code>降低更新表的速度</code>，如对表进行INSERT、UPDATE、DELETE。因为更新表时，MySQL 不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段，都会调整因为更新所带来的键值变化后的索引信息。</p>
<h3 id="2-3-索引结构"><a href="#2-3-索引结构" class="headerlink" title="2.3 索引结构"></a>2.3 索引结构</h3><p>索引是在MySQL的<code>存储引擎层</code>中实现的，而<code>不是在服务器层</code>实现的。所以每种存储引擎的索引都不一定完全相同，也不是所有的存储引擎都支持所有的索引类型的。MySQL目前提供了以下4种索引：</p>
<ul>
<li><code>BTREE 索引</code> ： 最常见的索引类型，大部分索引都支持 B 树索引。</li>
<li><code>HASH 索引</code>：只有Memory引擎支持 ， 使用场景简单 。</li>
<li><code>R-tree 索引</code>（空间索引）：空间索引是MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少，不做特别介绍。</li>
<li><code>Full-text </code>（全文索引） ：全文索引也是MyISAM的一个特殊索引类型，主要用于全文索引，InnoDB从Mysql5.6版本开始支持全文索引。</li>
</ul>
<p> <strong>MyISAM、InnoDB、Memory三种存储引擎对各种索引类型的支持</strong> </p>
<table>
<thead>
<tr>
<th>索引</th>
<th>InnoDB引擎</th>
<th>MyISAM引擎</th>
<th>Memory引擎</th>
</tr>
</thead>
<tbody><tr>
<td>BTREE索引</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>HASH 索引</td>
<td>不支持</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>R-tree 索引</td>
<td>不支持</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>Full-text</td>
<td>5.6版本之后支持</td>
<td>支持</td>
<td>不支持</td>
</tr>
</tbody></table>
<p>我们平常所说的索引，如果没有特别指明，都是指 <code>B+树（多路搜索树，并不一定是二叉的）</code>结构组织的索引。其中<code>聚集索引、复合索引、前缀索引、唯一索引默认都是使用 B+tree 索引</code>，统称为 索引。</p>
<h4 id="2-3-1-BTREE-结构"><a href="#2-3-1-BTREE-结构" class="headerlink" title="2.3.1 BTREE 结构"></a>2.3.1 BTREE 结构</h4><p>BTree又叫<code>多路平衡搜索树</code>，一颗<code>m叉</code>的BTree特性如下：</p>
<ul>
<li>树中每个节点最多包含<code>m个孩子</code>。</li>
<li>除根节点与叶子节点外，每个节点至少有[ceil(m/2)] (向上取整)个孩子。</li>
<li>若根节点不是叶子节点，则至少有两个孩子。</li>
<li>所有的叶子节点都在同一层。</li>
<li>每个非叶子节点由n个key与n+1个指针组成，其中[ceil(m/2)-1] &lt;= n &lt;= m-1</li>
</ul>
<p>以<code>5叉BTree为例</code>，每个节点最多<code>5</code>个分支，key的数量：公式推导[ceil(m/2)-1] &lt;= n &lt;= m-1。所以 2 &lt;= n &lt;=4 。</p>
<p><code>当n&gt;4时，中间节点分裂到父节点，两边节点分裂</code>。</p>
<h4 id="2-3-2-BTREE-插入演示"><a href="#2-3-2-BTREE-插入演示" class="headerlink" title="2.3.2 BTREE 插入演示"></a>2.3.2 BTREE 插入演示</h4><p><a target="_blank" rel="noopener" href="https://www.cs.usfca.edu/~galles/visualization/">演示网站</a></p>
<p>插入 C N G A H E K Q M F W L T Z D P R X Y S 数据为例。</p>
<p>演变过程如下：</p>
<p>1). 插入前4个字母 C N G A (<code>每个非叶子节点由n个key与n+1个指针组成</code>)</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210521103038.png" srcset="/img/loading.gif"></p>
<p>2). 插入H，n&gt;4，中间元素G字母向上分裂到新的节点 (中间结点分裂到父节点)</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210521103211.png" srcset="/img/loading.gif"></p>
<p>3). 插入E，K，Q不需要分裂</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210521103231.png" srcset="/img/loading.gif"></p>
<p>4). 插入M，中间元素M字母向上分裂到父节点G</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210521103340.png" srcset="/img/loading.gif"></p>
<p>5). 插入F，W，L，T不需要分裂</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210521103515.png" srcset="/img/loading.gif"></p>
<p>6). 插入Z，中间元素T向上分裂到父节点中</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210521103536.png" srcset="/img/loading.gif"></p>
<p>7). 插入D，中间元素D向上分裂到父节点中。然后插入P，R，X，Y不需要分裂</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210521103619.png" srcset="/img/loading.gif"></p>
<p>8). 最后插入S，NPQR节点n&gt;5，中间节点Q向上分裂，但分裂后父节点DGMT的n&gt;5，中间节点M向上分裂</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210521103733.png" srcset="/img/loading.gif"></p>
<p>到此，该BTREE树就已经构建完成了， BTREE树 和 二叉树 相比， 查询数据的效率更高， 因为对于相同的数据量来说，<code>BTREE的层级结构比二叉树小</code>，因此搜索速度快。但有<code>回旋查找问题</code>。</p>
<h4 id="2-3-3-B-TREE-结构"><a href="#2-3-3-B-TREE-结构" class="headerlink" title="2.3.3 B+TREE 结构"></a>2.3.3 B+TREE 结构</h4><p>B+Tree为BTree的变种，B+Tree与BTree的区别为：</p>
<p>1). <code>n叉B+Tree最多含有m个key，而BTree最多含有m-1个key</code>。</p>
<p>2). B+Tree的<code>叶子节点保存所有的key信息</code>，依key大小顺序排列。</p>
<p>3). 所有的<code>非叶子节点</code>都可以看作是<code>key的索引</code>部分。</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210521104236.png" srcset="/img/loading.gif"></p>
<p>由于B+Tree只有叶子节点保存key信息，查询任何key都要从root走到叶子。所以B+Tree的<code>查询效率更加稳定</code>。</p>
<h4 id="2-3-4-MySQL中的B-Tree"><a href="#2-3-4-MySQL中的B-Tree" class="headerlink" title="2.3.4 MySQL中的B+Tree"></a>2.3.4 MySQL中的B+Tree</h4><p>MySql索引数据结构对经典的B+Tree进行了优化。在原B+Tree的基础上，<code>增加一个指向相邻叶子节点的链表指针</code>，就形成了<code>带有顺序指针的B+Tree</code>，提高区间访问的性能。</p>
<p>MySQL中的 B+Tree 索引结构示意图:</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210521104742.png" srcset="/img/loading.gif"></p>
<p>便于进行范围搜索，没有回旋查找问题。</p>
<h3 id="2-4-索引分类"><a href="#2-4-索引分类" class="headerlink" title="2.4 索引分类"></a>2.4 索引分类</h3><p>1） 单值索引 ：即一个索引只包含单个列，一个表可以有多个单列索引</p>
<p>2） 唯一索引 ：索引列的值必须唯一（字段唯一），但允许有空值</p>
<p>3） 复合索引 ：即一个索引包含多个列</p>
<h3 id="2-5-索引语法"><a href="#2-5-索引语法" class="headerlink" title="2.5 索引语法"></a>2.5 索引语法</h3><p>索引在创建表的时候，可以同时创建， 也可以随时增加新的索引。</p>
<p>准备环境:</p>
<div class="hljs"><pre><code class="hljs mysql">create database demo_01 default charset&#x3D;utf8mb4;

use demo_01;

CREATE TABLE &#96;city&#96; (
  &#96;city_id&#96; int(11) NOT NULL AUTO_INCREMENT,
  &#96;city_name&#96; varchar(50) NOT NULL,
  &#96;country_id&#96; int(11) NOT NULL,
  PRIMARY KEY (&#96;city_id&#96;)
) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8;

CREATE TABLE &#96;country&#96; (
  &#96;country_id&#96; int(11) NOT NULL AUTO_INCREMENT,
  &#96;country_name&#96; varchar(100) NOT NULL,
  PRIMARY KEY (&#96;country_id&#96;)
) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8;


insert into &#96;city&#96; (&#96;city_id&#96;, &#96;city_name&#96;, &#96;country_id&#96;) values(1,&#39;西安&#39;,1);
insert into &#96;city&#96; (&#96;city_id&#96;, &#96;city_name&#96;, &#96;country_id&#96;) values(2,&#39;NewYork&#39;,2);
insert into &#96;city&#96; (&#96;city_id&#96;, &#96;city_name&#96;, &#96;country_id&#96;) values(3,&#39;北京&#39;,1);
insert into &#96;city&#96; (&#96;city_id&#96;, &#96;city_name&#96;, &#96;country_id&#96;) values(4,&#39;上海&#39;,1);

insert into &#96;country&#96; (&#96;country_id&#96;, &#96;country_name&#96;) values(1,&#39;China&#39;);
insert into &#96;country&#96; (&#96;country_id&#96;, &#96;country_name&#96;) values(2,&#39;America&#39;);
insert into &#96;country&#96; (&#96;country_id&#96;, &#96;country_name&#96;) values(3,&#39;Japan&#39;);
insert into &#96;country&#96; (&#96;country_id&#96;, &#96;country_name&#96;) values(4,&#39;UK&#39;);</code></pre></div>

<h4 id="2-5-1-创建索引"><a href="#2-5-1-创建索引" class="headerlink" title="2.5.1 创建索引"></a>2.5.1 创建索引</h4><p>语法 ：</p>
<div class="hljs"><pre><code class="hljs mysql">CREATE 	[UNIQUE|FULLTEXT|SPATIAL]（可选）  INDEX index_name 
[USING  index_type](默认b+tree)
ON tbl_name(index_col_name,...)

index_col_name : column_name[(length)][ASC | DESC]</code></pre></div>

<p>示例 ： 为city表中的city_name字段创建索引 ；</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210521114042.png" srcset="/img/loading.gif"></p>
<p>注意：字段为主键，默认有主键索引</p>
<h4 id="2-5-2-查看索引"><a href="#2-5-2-查看索引" class="headerlink" title="2.5.2 查看索引"></a>2.5.2 查看索引</h4><div class="hljs"><pre><code class="hljs mysql">show index  from  table_name;</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210521135534.png" srcset="/img/loading.gif"></p>
<div class="hljs"><pre><code class="hljs mysql">show index  from  table_name\G;</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210521135619.png" srcset="/img/loading.gif"></p>
<h4 id="2-5-3-删除索引"><a href="#2-5-3-删除索引" class="headerlink" title="2.5.3 删除索引"></a>2.5.3 删除索引</h4><div class="hljs"><pre><code class="hljs mysql">DROP  INDEX  index_name  ON  tbl_name;</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210521135755.png" srcset="/img/loading.gif"></p>
<h4 id="2-5-4-ALTER命令"><a href="#2-5-4-ALTER命令" class="headerlink" title="2.5.4 ALTER命令"></a>2.5.4 ALTER命令</h4><div class="hljs"><pre><code class="hljs mysql">1). alter  table  tb_name  add  primary  key(column_list); 

	该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL
	
2). alter  table  tb_name  add  unique index_name(column_list);
	
	这条语句创建索引的值必须是唯一的(唯一索引)（除了NULL外，NULL可能会出现多次）
	
3). alter  table  tb_name  add  index index_name(column_list);

	添加普通索引， 索引值可以出现多次。
	
4). alter  table  tb_name  add  fulltext  index_name(column_list);
	
	该语句指定了索引为FULLTEXT， 用于全文索引</code></pre></div>

<h3 id="2-6-索引设计原则"><a href="#2-6-索引设计原则" class="headerlink" title="2.6 索引设计原则"></a>2.6 索引设计原则</h3><p> 索引的设计可以遵循一些已有的<code>原则</code>，创建索引的时候请尽量考虑符合这些原则，便于提升索引的使用效率，更高效的使用索引。</p>
<ul>
<li>对 <strong>查询频次较高，且数据量比较大</strong> 的表建立索引。</li>
<li>索引字段的选择，最佳候选列应当 <strong>从where子句的条件中提取</strong> ，如果where子句中的组合比较多，那么应当挑选 <strong>最常用、过滤效果最好的列</strong> 的组合。</li>
<li>使用唯一索引，区分度越高，使用索引的效率越高。</li>
<li>索引可以有效的提升查询数据的效率，但索引数量不是多多益善，索引越多，维护索引的代价自然也就水涨船高。对于 <strong>插入、更新、删除等DML操作比较频繁的表来说，索引过多，会引入相当高的维护代价，降低DML操作的效率，增加相应操作的时间消耗</strong> 。另外索引过多的话，MySQL也会犯选择困难病，虽然最终仍然会找到一个可用的索引，但无疑提高了选择的代价。</li>
<li>使用短索引，索引创建之后也是使用硬盘来存储的，因此 <strong>提升索引访问的I/O效率</strong> ，也可以提升总体的访问效率。假如构成索引的字段总长度比较短，那么在给定大小的存储块内可以存储更多的索引值，相应的可以有效的提升MySQL访问索引的I/O效率。</li>
<li>利用最左前缀， <strong>N个列组合</strong> 而成的组合索引，那么 <strong>相当于是创建了N个索引</strong> ，如果查询时where子句中使用了组成该索引的前几个字段，那么这条查询SQL可以利用组合索引来提升查询效率。</li>
</ul>
<div class="hljs"><pre><code class="hljs mysql">创建复合索引:

	CREATE INDEX idx_name_email_status ON tb_seller(NAME,email,STATUS);

就相当于
	对name 创建索引 ;
	对name , email 创建了索引 ;
	对name , email, status 创建了索引 ;</code></pre></div>



<h3 id="2-7-索引失效"><a href="#2-7-索引失效" class="headerlink" title="2.7 索引失效"></a>2.7 索引失效</h3><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Sp4y1e7W6/?spm_id_from=333.788.recommend_more_video.-1">索引失效</a></p>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000021464570">索引失效情况</a></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210521111035.png" srcset="/img/loading.gif"></p>
<p>联合索引，通过a排序，a相等情况下通过b排序</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210521111140.png" srcset="/img/loading.gif"></p>
<p>索引情况</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210521111254.png" srcset="/img/loading.gif"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210521111359.png" srcset="/img/loading.gif"></p>
<p>a没有的情况下，无法在无序的b+tree上找到值</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210521111626.png" srcset="/img/loading.gif"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210521111652.png" srcset="/img/loading.gif"></p>
<p>b还是没有序</p>
<p>不能通过二分查找找到b的确定数据</p>
<p>like失效问题：</p>
<p>%放在右边某些情况下才会走索引</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210521111901.png" srcset="/img/loading.gif"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210521111913.png" srcset="/img/loading.gif"></p>
<p>索引查找就是二分。凡是不能二分查找的情况都属于索引失效的情况</p>
<h2 id="3-视图"><a href="#3-视图" class="headerlink" title="3. 视图"></a>3. 视图</h2><h3 id="3-1-视图概述"><a href="#3-1-视图概述" class="headerlink" title="3.1 视图概述"></a>3.1 视图概述</h3><p> 视图（View）是 <code>一种虚拟存在的表</code>。视图并不在数据库中实际存在，行和列数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成的。通俗的讲，<code>视图就是一条SELECT语句执行后返回的结果集</code>。所以我们在创建视图的时候，主要的工作就落在创建这条SQL查询语句上。</p>
<p>视图相对于普通的表的优势主要包括以下几项。</p>
<ul>
<li>简单：使用视图的用户完全不需要关心后面对应的表的结构、关联条件和筛选条件，对用户来说 <strong>已经是过滤好的复合条件的结果集</strong> 。</li>
<li>安全：使用视图的用户 <strong>只能访问他们被允许查询的结果集</strong> ，对表的权限管理并不能限制到某个行某个列，但是通过视图就可以简单的实现。</li>
<li>数据独立：一旦视图的结构确定了，可以屏蔽表结构变化对用户的影响，源表增加列对视图没有影响；源表修改列名，则可以通过修改视图来解决，不会造成对访问者的影响。</li>
</ul>
<h3 id="3-2-创建或者修改视图"><a href="#3-2-创建或者修改视图" class="headerlink" title="3.2 创建或者修改视图"></a>3.2 创建或者修改视图</h3><p>创建视图的语法为：</p>
<div class="hljs"><pre><code class="hljs mysql">CREATE [OR REPLACE] [ALGORITHM &#x3D; &#123;UNDEFINED | MERGE | TEMPTABLE&#125;]

VIEW view_name [(column_list)]

AS select_statement

[WITH [CASCADED | LOCAL] CHECK OPTION]</code></pre></div>

<p>修改视图的语法为：</p>
<div class="hljs"><pre><code class="hljs mysql">ALTER [ALGORITHM &#x3D; &#123;UNDEFINED | MERGE | TEMPTABLE&#125;]

VIEW view_name [(column_list)]

AS select_statement

[WITH [CASCADED | LOCAL] CHECK OPTION]</code></pre></div>

<p>查询截图:</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210521141025.png" srcset="/img/loading.gif"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210521141159.png" srcset="/img/loading.gif">视图是可以更新的，但基础表也会随之更新</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210521141414.png" srcset="/img/loading.gif"></p>
<div class="hljs"><pre><code class="hljs mysql">选项 : 
	WITH [CASCADED | LOCAL] CHECK OPTION 决定了是否允许更新数据使记录不再满足视图的条件。
	
	LOCAL ： 只要满足本视图的条件就可以更新。
	CASCADED ： 必须满足所有针对该视图的所有视图的条件才可以更新。 默认值.</code></pre></div>

<p>视图简化查询操作，不建议更新；</p>
<h3 id="3-3-查看视图"><a href="#3-3-查看视图" class="headerlink" title="3.3 查看视图"></a>3.3 查看视图</h3><p>从 MySQL 5.1 版本开始，使用 <code>SHOW TABLES</code> 命令的时候不仅显示表的名字，同时也会显示视图的名字，而不存在单独显示视图的 <code>SHOW VIEWS</code> 命令。</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210521141616.png" srcset="/img/loading.gif"></p>
<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210521141645.png" srcset="/img/loading.gif" style="zoom:50%;" />

<p>同样，在使用 SHOW TABLE STATUS 命令的时候，不但可以显示表的信息，同时也可以显示视图的信息。</p>
<p>如果需要查询某个视图的定义，可以使用 SHOW CREATE VIEW 命令进行查看 ：</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210521141854.png" srcset="/img/loading.gif"></p>
<h3 id="3-4-删除视图"><a href="#3-4-删除视图" class="headerlink" title="3.4 删除视图"></a>3.4 删除视图</h3><div class="hljs"><pre><code class="hljs mysql">DROP VIEW [IF EXISTS] view_name [, view_name] ...[RESTRICT | CASCADE]</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210521141955.png" srcset="/img/loading.gif"></p>
<h2 id="4-存储过程和函数"><a href="#4-存储过程和函数" class="headerlink" title="4. 存储过程和函数"></a>4. 存储过程和函数</h2><h3 id="4-1-存储过程和函数概述"><a href="#4-1-存储过程和函数概述" class="headerlink" title="4.1 存储过程和函数概述"></a>4.1 存储过程和函数概述</h3><p>存储过程和函数是 <code>事先经过编译并存储在数据库中的一段 SQL 语句的集合</code>，调用存储过程和函数可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。</p>
<p> 存储过程和函数的区别在于函数必须有返回值，而存储过程没有。</p>
<p> 函数 ： 是一个 <strong>有返回值</strong> 的过程 ；</p>
<p> 过程 ： 是一个 <strong>没有返回值</strong> 的函数 ；</p>
<h3 id="4-2-创建存储过程"><a href="#4-2-创建存储过程" class="headerlink" title="4.2 创建存储过程"></a>4.2 创建存储过程</h3><div class="hljs"><pre><code class="hljs mysql">CREATE PROCEDURE procedure_name ([proc_parameter[,...]])
begin
	-- SQL语句
end ;</code></pre></div>

<p>示例 ：</p>
<div class="hljs"><pre><code class="hljs mysql">delimiter $

create procedure pro_test1()
begin
	select &#39;Hello Mysql&#39; ;
end$

delimiter ;</code></pre></div>

<p> <strong>知识小贴士</strong> </p>
<p>DELIMITER</p>
<p> 该关键字用来声明SQL语句的分隔符 , 告诉 MySQL 解释器，该段命令是否已经结束了，mysql是否可以执行了。<code>默认情况下，delimiter是分号;</code>。在命令行客户端中，如果有一行命令以分号结束，那么回车后，mysql将会执行该命令。</p>
<h3 id="4-3-调用存储过程"><a href="#4-3-调用存储过程" class="headerlink" title="4.3 调用存储过程"></a>4.3 调用存储过程</h3><div class="hljs"><pre><code class="hljs mysql">call procedure_name() ;</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210521142939.png" srcset="/img/loading.gif"></p>
<h3 id="4-4-查看存储过程"><a href="#4-4-查看存储过程" class="headerlink" title="4.4 查看存储过程"></a>4.4 查看存储过程</h3><div class="hljs"><pre><code class="hljs mysql">-- 查询db_name数据库中的所有的存储过程
select name from mysql.proc where db&#x3D;&#39;db_name&#39;;

-- 查询存储过程的状态信息
show procedure status;

-- 查询某个存储过程的定义
show create procedure test.pro_test1 \G;</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210521143104.png" srcset="/img/loading.gif"></p>
<p>其实是从mysql下面的proc表中查询的</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210521143148.png" srcset="/img/loading.gif"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210521143536.png" srcset="/img/loading.gif"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210521143611.png" srcset="/img/loading.gif"></p>
<h3 id="4-5-删除存储过程"><a href="#4-5-删除存储过程" class="headerlink" title="4.5 删除存储过程"></a>4.5 删除存储过程</h3><div class="hljs"><pre><code class="hljs mysql">DROP PROCEDURE  [IF EXISTS] sp_name;</code></pre></div>

<h3 id="4-6-语法"><a href="#4-6-语法" class="headerlink" title="4.6 语法"></a>4.6 语法</h3><p>存储过程是可以编程的，意味着可以使用变量，表达式，控制结构 ， 来完成比较复杂的功能。</p>
<h4 id="4-6-1-变量"><a href="#4-6-1-变量" class="headerlink" title="4.6.1 变量"></a>4.6.1 变量</h4><ul>
<li>DECLARE</li>
</ul>
<p>通过 DECLARE 可以定义一个 <code>局部变量</code>，该变量的作用范围只能在 <code>BEGIN…END</code> 块中。</p>
<div class="hljs"><pre><code class="hljs mysql">DECLARE var_name[,...] type [DEFAULT value]</code></pre></div>

<p>示例 :</p>
<div class="hljs"><pre><code class="hljs mysql">delimiter $

create procedure pro_test2() 
begin 
	declare num int default 5;
	select num+ 10; 
end$

delimiter ;</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210521143841.png" srcset="/img/loading.gif"></p>
<ul>
<li>SET</li>
</ul>
<p>直接赋值使用 SET，可以<code>赋常量或者赋表达式</code>，具体语法如下：</p>
<div class="hljs"><pre><code class="hljs mysql">SET var_name &#x3D; expr [, var_name &#x3D; expr] ...</code></pre></div>

<p>示例 :</p>
<div class="hljs"><pre><code class="hljs mysql">DELIMITER $

CREATE  PROCEDURE pro_test3()
BEGIN
	DECLARE NAME VARCHAR(20);
	SET NAME &#x3D; &#39;MYSQL&#39;;
	SELECT concat(&#39;NAME的值为：&#39;, NAME) ;
END$

DELIMITER ;</code></pre></div>

<p>也可以通过select … into 方式进行赋值操作 :</p>
<div class="hljs"><pre><code class="hljs mysql">DELIMITER $

CREATE  PROCEDURE pro_test5()
BEGIN
	declare  countnum int;
	select count(*) into countnum from city;
	select countnum;
END$

DELIMITER ;</code></pre></div>

<p>​    select count(*)  from city;是查询数量，再into countnum赋值给countnum；</p>
<h3 id="4-7-存储函数"><a href="#4-7-存储函数" class="headerlink" title="4.7 存储函数"></a>4.7 存储函数</h3><p>语法结构:</p>
<div class="hljs"><pre><code class="hljs mysql">CREATE FUNCTION function_name([param type ... ]) 
RETURNS type 
BEGIN
	...
END;</code></pre></div>

<p>案例 :</p>
<p>定义一个存储过程, 请求满足条件的总记录数 ;</p>
<div class="hljs"><pre><code class="hljs mysql">
delimiter $

create function count_city(countryId int)
returns int
begin
  declare cnum int ;
  
  select count(*) into cnum from city where country_id &#x3D; countryId;
  
  return cnum;
end$

delimiter ;</code></pre></div>

<p>调用:</p>
<div class="hljs"><pre><code class="hljs mysql">select count_city(1);

select count_city(2);</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210521144848.png" srcset="/img/loading.gif"></p>
<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210521144909.png" srcset="/img/loading.gif" style="zoom:50%;" />

<h2 id="5-触发器"><a href="#5-触发器" class="headerlink" title="5. 触发器"></a>5. 触发器</h2><h3 id="5-1-介绍"><a href="#5-1-介绍" class="headerlink" title="5.1 介绍"></a>5.1 介绍</h3><p>触发器是 <strong>与表有关的数据库对象</strong> ，指在 insert/update/delete 之前或之后，触发并执行触发器中定义的SQL语句集合。触发器的这种特性可以 <code>协助应用在数据库端确保数据的完整性 , 日志记录 , 数据校验等操作 </code> 。</p>
<p>使用别名 OLD 和 NEW (行记录变量)来引用触发器中发生变化的记录内容，这与其他的数据库是相似的。<code>现在触发器还只支持行级触发，不支持语句级触发</code>。</p>
<table>
<thead>
<tr>
<th>触发器类型</th>
<th>NEW 和 OLD的使用</th>
</tr>
</thead>
<tbody><tr>
<td>INSERT 型触发器</td>
<td>NEW 表示将要或者已经新增的数据</td>
</tr>
<tr>
<td>UPDATE 型触发器</td>
<td>OLD 表示修改之前的数据 , NEW 表示将要或已经修改后的数据</td>
</tr>
<tr>
<td>DELETE 型触发器</td>
<td>OLD 表示将要或者已经删除的数据</td>
</tr>
</tbody></table>
<h3 id="5-2-创建触发器"><a href="#5-2-创建触发器" class="headerlink" title="5.2 创建触发器"></a>5.2 创建触发器</h3><p>语法结构 :</p>
<div class="hljs"><pre><code class="hljs mysql">create trigger trigger_name 

before&#x2F;after insert&#x2F;update&#x2F;delete

on tbl_name 

[ for each row ]  -- 行级触发器

begin

	trigger_stmt ;

end;</code></pre></div>

<p>示例: 需求:</p>
<div class="hljs"><pre><code class="hljs markdown">通过触发器记录 emp 表的数据变更日志 , 包含增加, 修改 , 删除 ;</code></pre></div>

<p>首先创建一张日志表 :</p>
<div class="hljs"><pre><code class="hljs mysql">create table emp_logs(
  id int(11) not null auto_increment,
  operation varchar(20) not null comment &#39;操作类型, insert&#x2F;update&#x2F;delete&#39;,
  operate_time datetime not null comment &#39;操作时间&#39;,
  operate_id int(11) not null comment &#39;操作表的ID&#39;,
  operate_params varchar(500) comment &#39;操作参数&#39;,
  primary key(&#96;id&#96;)
)engine&#x3D;innodb default charset&#x3D;utf8;</code></pre></div>

<ul>
<li>创建 insert 型触发器，完成插入数据时的日志记录 :</li>
</ul>
<div class="hljs"><pre><code class="hljs mysql">DELIMITER $

create trigger emp_logs_insert_trigger
after insert 
on emp 
for each row 
begin
  insert into emp_logs (id,operation,operate_time,operate_id,operate_params) values(null,&#39;insert&#39;,now(),new.id,concat(&#39;插入后(id:&#39;,new.id,&#39;, name:&#39;,new.name,&#39;, age:&#39;,new.age,&#39;, salary:&#39;,new.salary,&#39;)&#39;));	
end $

DELIMITER ;</code></pre></div>

<ul>
<li>创建 update 型触发器，完成更新数据时的日志记录 :</li>
</ul>
<div class="hljs"><pre><code class="hljs mysql">DELIMITER $

create trigger emp_logs_update_trigger
after update 
on emp 
for each row 
begin
  insert into emp_logs (id,operation,operate_time,operate_id,operate_params) values(null,&#39;update&#39;,now(),new.id,concat(&#39;修改前(id:&#39;,old.id,&#39;, name:&#39;,old.name,&#39;, age:&#39;,old.age,&#39;, salary:&#39;,old.salary,&#39;) , 修改后(id&#39;,new.id, &#39;name:&#39;,new.name,&#39;, age:&#39;,new.age,&#39;, salary:&#39;,new.salary,&#39;)&#39;));                                                                      
end $

DELIMITER ;</code></pre></div>

<ul>
<li>创建delete 行的触发器 , 完成删除数据时的日志记录 :</li>
</ul>
<div class="hljs"><pre><code class="hljs mysql">DELIMITER $

create trigger emp_logs_delete_trigger
after delete 
on emp 
for each row 
begin
  insert into emp_logs (id,operation,operate_time,operate_id,operate_params) values(null,&#39;delete&#39;,now(),old.id,concat(&#39;删除前(id:&#39;,old.id,&#39;, name:&#39;,old.name,&#39;, age:&#39;,old.age,&#39;, salary:&#39;,old.salary,&#39;)&#39;));                                                                      
end $

DELIMITER ;</code></pre></div>

<ul>
<li>测试：</li>
</ul>
<div class="hljs"><pre><code class="hljs mysql">insert into emp(id,name,age,salary) values(null, &#39;光明左使&#39;,30,3500);
insert into emp(id,name,age,salary) values(null, &#39;光明右使&#39;,33,3200);

update emp set age &#x3D; 39 where id &#x3D; 3;

delete from emp where id &#x3D; 5;</code></pre></div>

<p>查看：</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210521150148.png" srcset="/img/loading.gif"></p>
<h3 id="5-3-删除触发器"><a href="#5-3-删除触发器" class="headerlink" title="5.3 删除触发器"></a>5.3 删除触发器</h3><p>语法结构 :</p>
<div class="hljs"><pre><code class="hljs mysql">drop trigger [schema_name.]trigger_name</code></pre></div>

<p>如果没有指定 schema_name，默认为当前数据库 。</p>
<h3 id="5-4-查看触发器"><a href="#5-4-查看触发器" class="headerlink" title="5.4 查看触发器"></a>5.4 查看触发器</h3><p>可以通过执行 SHOW TRIGGERS 命令查看触发器的状态、语法等信息。</p>
<p>语法结构 ：</p>
<div class="hljs"><pre><code class="hljs mysql">show triggers ；</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210521150453.png" srcset="/img/loading.gif"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210521151129.png" srcset="/img/loading.gif"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210521151154.png" srcset="/img/loading.gif"></p>
<h1 id="Mysql高级-day02"><a href="#Mysql高级-day02" class="headerlink" title="Mysql高级-day02"></a>Mysql高级-day02</h1><h2 id="1-Mysql的体系结构概览"><a href="#1-Mysql的体系结构概览" class="headerlink" title="1. Mysql的体系结构概览"></a>1. Mysql的体系结构概览</h2><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210521151353.png" srcset="/img/loading.gif"></p>
<p>整个MySQL Server由以下组成</p>
<ul>
<li>Connection Pool : 连接池组件</li>
<li>Management Services &amp; Utilities : 管理服务和工具组件(数据备份、恢复、集群安全)</li>
<li>SQL Interface : SQL接口组件(DDL DML 存储过程 触发器 函数 储存视图…)</li>
<li>Parser : 查询分析器组件(解析客户端发起的请求, 客户端的sql)</li>
<li>Optimizer : 优化器组件(优化SQL)</li>
<li>Caches &amp; Buffers : 缓冲池组件(缓存操作)</li>
<li>Pluggable Storage Engines : 存储引擎(5.5后默认innoDB)</li>
<li>File System : 文件系统</li>
</ul>
<p>1） 连接层</p>
<p>最上层是一些客户端和链接服务，包含本地sock 通信和大多数基于客户端/服务端工具实现的类似于 TCP/IP的通信。主要完成一些类似于 <code>连接处理、授权认证、及相关的安全方案</code>。在该层上引入了<code>线程池</code>的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。</p>
<p>2） 服务层</p>
<p>第二层架构主要完成大多数的核心服务功能，如<code>SQL接口，并完成缓存的查询，SQL的分析和优化，部分内置函数的执行</code>。所有跨存储引擎的功能也在这一层实现，如 过程、函数等。在该层，服务器会解析查询并创建相应的内部解析树，并对其完成相应的优化如确定表的查询的顺序，是否利用索引等， 最后生成相应的执行操作。如果是select语句，服务器<code>还会查询内部的缓存</code>，如果缓存空间足够大，这样在解决大量读操作的环境中能够很好的提升系统的性能。</p>
<p>3） 引擎层</p>
<p>存储引擎层， 存储引擎真正的<code>负责了MySQL中数据的存储和提取</code>，服务器通过API和存储引擎进行通信。不同的存储引擎具有不同的功能，这样我们可以根据自己的需要，来选取合适的存储引擎。</p>
<p>4）存储层</p>
<p>数据存储层， 主要是将数据<code>存储</code>在文件系统之上，并完成与存储引擎的交互。</p>
<p>和其他数据库相比，MySQL有点与众不同，它的架构可以在多种不同场景中应用并发挥良好作用。<code>主要体现在存储引擎上，插件式的存储引擎架构，将查询处理和其他的系统任务以及数据的存储提取分离</code>。这种架构可以根据业务的需求和实际需要选择合适的存储引擎。</p>
<h2 id="2-存储引擎"><a href="#2-存储引擎" class="headerlink" title="2. 存储引擎"></a>2. 存储引擎</h2><h3 id="2-1-存储引擎概述"><a href="#2-1-存储引擎概述" class="headerlink" title="2.1 存储引擎概述"></a>2.1 存储引擎概述</h3><p> 和大多数的数据库不同, MySQL中有一个存储引擎的概念, 针对不同的存储需求可以选择最优的存储引擎。</p>
<p> 存储引擎就是<code>存储数据，建立索引，更新查询数据等等技术</code>的实现方式 。<code>存储引擎是基于表的</code>，而不是基于库的。所以存储引擎也可被称为表类型。</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210525075604.png" srcset="/img/loading.gif"></p>
<p> Oracle，SqlServer等数据库只有一种存储引擎。 <strong>MySQL提供了插件式的存储引擎架构</strong> 。所以MySQL存在多种存储引擎，可以根据需要使用相应引擎，或者编写存储引擎。</p>
<p> MySQL5.0支持的存储引擎包含 ： InnoDB 、MyISAM 、BDB、MEMORY、MERGE、EXAMPLE、NDB Cluster、ARCHIVE、CSV、BLACKHOLE、FEDERATED等，其中InnoDB和BDB提供事务安全表，其他存储引擎是非事务安全表。</p>
<p>可以通过指定 <code>show engines</code> ， 来查询当前数据库支持的存储引擎 ：</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210525075729.png" srcset="/img/loading.gif"></p>
<p><code> Supports transactions, row-level locking, and foreign keys</code></p>
<p>事务、行及锁、外键</p>
<p>创建新表时如果不指定存储引擎，那么系统就会使用默认的存储引擎，MySQL5.5之前的默认存储引擎是MyISAM，5.5之后就改为了InnoDB。</p>
<p>查看Mysql数据库默认的存储引擎 ， 指令 ：</p>
<div class="hljs"><pre><code class="hljs mysql">show variables like &#39;%storage_engine%&#39; ；</code></pre></div>

<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210525075900.png" srcset="/img/loading.gif" style="zoom:50%;" />

<h3 id="2-2-各种存储引擎特性"><a href="#2-2-各种存储引擎特性" class="headerlink" title="2.2 各种存储引擎特性"></a>2.2 各种存储引擎特性</h3><p>下面重点介绍几种常用的存储引擎， 并对比各个存储引擎之间的区别， 如下表所示 ：</p>
<table>
<thead>
<tr>
<th>特点</th>
<th>InnoDB</th>
<th>MyISAM</th>
<th>MEMORY</th>
<th>MERGE</th>
<th>NDB</th>
</tr>
</thead>
<tbody><tr>
<td>存储限制</td>
<td>64TB</td>
<td>有</td>
<td>有</td>
<td>没有</td>
<td>有</td>
</tr>
<tr>
<td>事务安全</td>
<td>==支持==</td>
<td>否</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>锁机制</td>
<td>==行锁(适合高并发)==</td>
<td>==表锁==</td>
<td>表锁</td>
<td>表锁</td>
<td>行锁</td>
</tr>
<tr>
<td>B树索引</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>哈希索引</td>
<td></td>
<td></td>
<td>支持</td>
<td></td>
<td></td>
</tr>
<tr>
<td>全文索引</td>
<td>支持(5.6版本之后)</td>
<td>支持</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>集群索引</td>
<td>支持</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>数据索引</td>
<td>支持</td>
<td></td>
<td>支持</td>
<td></td>
<td>支持</td>
</tr>
<tr>
<td>索引缓存</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>数据可压缩</td>
<td></td>
<td>支持</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>空间使用</td>
<td>高</td>
<td>低</td>
<td>N/A</td>
<td>低</td>
<td>低</td>
</tr>
<tr>
<td>内存使用</td>
<td>高</td>
<td>低</td>
<td>中等</td>
<td>低</td>
<td>高</td>
</tr>
<tr>
<td>批量插入速度</td>
<td>低</td>
<td>高</td>
<td>高</td>
<td>高</td>
<td>高</td>
</tr>
<tr>
<td>支持外键</td>
<td>==支持==</td>
<td>否</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h4 id="2-2-1-InnoDB"><a href="#2-2-1-InnoDB" class="headerlink" title="2.2.1 InnoDB"></a>2.2.1 InnoDB</h4><p> InnoDB存储引擎是Mysql的默认存储引擎。InnoDB存储引擎提供了<code>具有提交、回滚、崩溃恢复能力的事务安全</code>。但是对比MyISAM的存储引擎，InnoDB写的处理效率差一些，并且会占用更多的磁盘空间以保留数据和索引。</p>
<p>InnoDB存储引擎不同于其他存储引擎的特点 ：</p>
<h5 id="事务控制"><a href="#事务控制" class="headerlink" title="事务控制"></a>事务控制</h5><div class="hljs"><pre><code class="hljs mysql">create table goods_innodb(
	id int NOT NULL AUTO_INCREMENT,
	name varchar(20) NOT NULL,
    primary key(id)
)ENGINE&#x3D;innodb DEFAULT CHARSET&#x3D;utf8;</code></pre></div>

<div class="hljs"><pre><code class="hljs mysql">start transaction;

insert into goods_innodb(id,name)values(null,&#39;Meta20&#39;);

commit;&#x2F;&#x2F; 默认隔离级别是可重复读</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210525081049.png" srcset="/img/loading.gif"></p>
<h5 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h5><p> <strong>MySQL支持外键的存储引擎只有InnoDB</strong>  ， 在创建外键的时候，  <strong>要求父表必须有对应的索引</strong>  ， 子表在创建外键的时候， 也会自动的创建对应的索引。</p>
<p> 下面两张表中 ， country_innodb是父表 ， country_id为主键索引，city_innodb表是子表，country_id字段为外键，对应于country_innodb表的主键country_id 。</p>
<div class="hljs"><pre><code class="hljs mysql">create table country_innodb(
	country_id int NOT NULL AUTO_INCREMENT,
    country_name varchar(100) NOT NULL,
    primary key(country_id)
)ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8;

create table city_innodb(
	city_id int NOT NULL AUTO_INCREMENT,
    city_name varchar(50) NOT NULL,
    country_id int NOT NULL,
    primary key(city_id),
    key idx_fk_country_id(country_id),
    CONSTRAINT &#96;fk_city_country&#96; FOREIGN KEY(country_id) REFERENCES country_innodb(country_id) ON DELETE RESTRICT ON UPDATE CASCADE
)ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8;

insert into country_innodb values(null,&#39;China&#39;),(null,&#39;America&#39;),(null,&#39;Japan&#39;);
insert into city_innodb values(null,&#39;Xian&#39;,1),(null,&#39;NewYork&#39;,2),(null,&#39;BeiJing&#39;,1);</code></pre></div>

<p>ON DELETE RESTRICT  删除主表数据时，有关联记录则不删除</p>
<p>ON UPDATE CASCADE 更新主表数据，有子表关联记录则更新子表记录</p>
<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210525081625.png" srcset="/img/loading.gif" style="zoom:50%;" />


<p>在创建索引时， 可以指定在删除、更新父表时，对子表进行的相应操作，包括 <code>RESTRICT</code>、<code>CASCADE</code>、<code>SET NULL</code> 和 <code>NO ACTION</code>。</p>
<ul>
<li><p><code>RESTRICT和NO ACTION相同</code>， 是指限制在子表有关联记录的情况下， 父表不能更新；</p>
</li>
<li><p><code>CASCADE</code>表示父表在更新或者删除时，更新或者删除子表对应的记录；</p>
</li>
<li><p><code>SET NULL</code> 则表示父表在更新或者删除的时候，子表的对应字段被SET NULL 。</p>
</li>
</ul>
<p>针对上面创建的两个表， 子表的外键指定是ON DELETE RESTRICT ON UPDATE CASCADE 方式的， 那么在主表删除记录的时候， 如果子表有对应记录， 则不允许删除， 主表在更新记录的时候， 如果子表有对应记录， 则子表对应更新 。</p>
<p>外键信息可以使用如下两种方式查看 ：</p>
<ol>
<li>尝试删除country_id为1 的country数据：</li>
</ol>
<div class="hljs"><pre><code class="hljs mysql">delete from country_innodb where country_id &#x3D; 1;</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210525081928.png" srcset="/img/loading.gif"></p>
<ol start="2">
<li>更新主表country表的字段 country_id :</li>
</ol>
<div class="hljs"><pre><code class="hljs mysql">update country_innodb set country_id &#x3D; 100 where country_id &#x3D; 1;</code></pre></div>

<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210525082029.png" srcset="/img/loading.gif" style="zoom:50%;" />

<h5 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h5><p>InnoDB 存储表和索引有以下两种方式 ：</p>
<p>①. 使用 <strong>共享表空间存储</strong> ， 这种方式创建的表的表结构保存在.frm文件中， 数据和索引保存在 innodb_data_home_dir 和 innodb_data_file_path定义的表空间中，可以是多个文件。</p>
<p>②. 使用 <strong>多表空间存储</strong> ， 这种方式创建的表的表结构仍然存在 .frm 文件中，但是每个表的数据和索引单独保存在 .ibd 中。</p>
<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210525082410.png" srcset="/img/loading.gif" style="zoom:50%;" />

<h4 id="2-2-2-MyISAM"><a href="#2-2-2-MyISAM" class="headerlink" title="2.2.2 MyISAM"></a>2.2.2 MyISAM</h4><p> MyISAM <code>不支持事务、也不支持外键，其优势是访问的速度快</code>，对事务的完整性没有要求或者以SELECT、INSERT为主的应用基本上都可以使用这个引擎来创建表 。有以下两个比较重要的特点：</p>
<h5 id="不支持事务"><a href="#不支持事务" class="headerlink" title="不支持事务"></a>不支持事务</h5><div class="hljs"><pre><code class="hljs mysql">create table goods_myisam(
	id int NOT NULL AUTO_INCREMENT,
	name varchar(20) NOT NULL,
    primary key(id)
)ENGINE&#x3D;myisam DEFAULT CHARSET&#x3D;utf8;</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210525082544.png" srcset="/img/loading.gif"></p>
<h5 id="文件存储方式"><a href="#文件存储方式" class="headerlink" title="文件存储方式"></a>文件存储方式</h5><p>每个MyISAM在磁盘上存储成3个文件，其文件名都和表名相同，但拓展名分别是 ：</p>
<ul>
<li><p>.frm (存储表定义)；</p>
</li>
<li><p>.MYD(MYData , 存储数据)；</p>
</li>
<li><p>.MYI(MYIndex , 存储索引)；</p>
</li>
</ul>
<h4 id="2-2-3-MEMORY"><a href="#2-2-3-MEMORY" class="headerlink" title="2.2.3 MEMORY"></a>2.2.3 MEMORY</h4><p> Memory存储引擎将表的数据存放在 <code>内存</code> 中。每个MEMORY表实际对应一个磁盘文件，格式是.frm ，该文件中只存储表的结构，而其数据文件，都是存储在内存中，这样有利于数据的快速处理，提高整个表的效率。MEMORY 类型的表访问非常地快，因为他的数据是存放在内存中的，并且默认使用HASH索引 ， 但是服务一旦关闭，表中的数据就会丢失。</p>
<h4 id="2-2-4-MERGE"><a href="#2-2-4-MERGE" class="headerlink" title="2.2.4 MERGE"></a>2.2.4 MERGE</h4><p> MERGE存储引擎是 <code>一组MyISAM表的组合</code>，这些MyISAM表必须结构完全相同，MERGE表本身并没有存储数据，对MERGE类型的表可以进行查询、更新、删除操作，这些操作实际上是对内部的MyISAM表进行的。</p>
<p> 对于MERGE类型表的插入操作，是通过INSERT_METHOD子句定义插入的表，可以有3个不同的值，<code>使用FIRST 或 LAST 值使得插入操作被相应地作用在第一或者最后一个表上</code>，不定义这个子句或者定义为NO，表示不能对这个MERGE表执行插入操作。</p>
<p> 可以对MERGE表进行DROP操作，但是这个操作只是删除MERGE表的定义，对内部的表是没有任何影响的。</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210525082931.png" srcset="/img/loading.gif"></p>
<div class="hljs"><pre><code class="hljs mysql">create table order_1990(
	order_id int ,
	order_money double(10,2),
	order_address varchar(50),
	primary key (order_id)
)engine &#x3D; myisam default charset&#x3D;utf8;


create table order_1991(
	order_id int ,
	order_money double(10,2),
	order_address varchar(50),
	primary key (order_id)
)engine &#x3D; myisam default charset&#x3D;utf8;


create table order_all(
	order_id int ,
	order_money double(10,2),
	order_address varchar(50),
	primary key (order_id)
)engine &#x3D; merge union &#x3D; (order_1990,order_1991) INSERT_METHOD&#x3D;LAST default charset&#x3D;utf8;</code></pre></div>

<ol>
<li>分别向两张表中插入记录</li>
</ol>
<div class="hljs"><pre><code class="hljs mysql">insert into order_1990 values(1,100.0,&#39;北京&#39;);
insert into order_1990 values(2,100.0,&#39;上海&#39;);

insert into order_1991 values(10,200.0,&#39;北京&#39;);
insert into order_1991 values(11,200.0,&#39;上海&#39;);</code></pre></div>

<ol start="2">
<li><p>查询3张表中的数据。</p>
<p>order_1990中的数据 ：</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210525083222.png" srcset="/img/loading.gif"></p>
<p>order_1991中的数据 ：</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210525083238.png" srcset="/img/loading.gif"></p>
<p>order_all中的数据 ：</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210525083254.png" srcset="/img/loading.gif"></p>
</li>
<li><p>往order_all中插入一条记录 ，由于在MERGE表定义时，INSERT_METHOD 选择的是LAST，那么插入的数据会想<code>最后一张表中插入</code>。</p>
<div class="hljs"><pre><code class="hljs mysql">insert into order_all values(100,10000.0,&#39;西安&#39;)；</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210525083341.png" srcset="/img/loading.gif"></p>
</li>
</ol>
<h3 id="2-3-存储引擎的选择"><a href="#2-3-存储引擎的选择" class="headerlink" title="2.3 存储引擎的选择"></a>2.3 存储引擎的选择</h3><p> 在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组合。以下是几种常用的存储引擎的使用环境。</p>
<ul>
<li> <strong>InnoDB</strong>  : 是Mysql的 <strong>默认</strong> 存储引擎，用于 <code>事务处理应用程序，支持外键</code>。如果应用对事务的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询意外，还包含很多的更新、删除操作，那么InnoDB存储引擎是比较合适的选择。InnoDB存储引擎除了有效的降低由于删除和更新导致的锁定， 还可以确保事务的完整提交和回滚，对于类似于计费系统或者财务系统等对数据准确性要求比较高的系统，InnoDB是最合适的选择。</li>
<li>MyISAM ： 如果应用是以<code>读操作和插入操作</code>为主，只有<code>很少的更新和删除操作</code>，并且对事务的完整性、并发性要求不是很高，那么选择这个存储引擎是非常合适的。</li>
<li>MEMORY：将所有数据保存在RAM中，在需要快速定位记录和其他类似数据环境下，可以提供几块的访问。MEMORY的缺陷就是对表的大小有限制，太大的表无法缓存在内存中，其次是要确保表的数据可以恢复，数据库异常终止后表中的数据是可以恢复的。MEMORY表通常用于更新不太频繁的小表，用以快速得到访问结果。</li>
<li>MERGE：用于将一系列等同的MyISAM表以逻辑方式组合在一起，并作为一个对象引用他们。MERGE表的优点在于可以突破对单个MyISAM表的大小限制，并且通过将不同的表分布在多个磁盘上，可以有效的改善MERGE表的访问效率。这对于存储诸如数据仓储等VLDB环境十分合适。</li>
</ul>
<h2 id="3-优化SQL步骤"><a href="#3-优化SQL步骤" class="headerlink" title="3. 优化SQL步骤"></a>3. 优化SQL步骤</h2><p>在应用的的开发过程中，由于初期数据量小，开发人员写 SQL 语句时更重视功能上的实现，但是当应用系统正式上线后，随着生产数据量的急剧增长，很多 SQL 语句开始逐渐显露出性能问题，对生产的影响也越来越大，此时这些有问题的 SQL 语句就成为整个系统性能的瓶颈，因此我们必须要对它们进行优化，本章将详细介绍在 MySQL 中优化 SQL 语句的方法。</p>
<p>当面对一个有 SQL 性能问题的数据库时，我们应该从何处入手来进行系统的分析，使得能够尽快定位问题 SQL 并尽快解决问题。</p>
<h3 id="3-1-查看SQL执行频率"><a href="#3-1-查看SQL执行频率" class="headerlink" title="3.1 查看SQL执行频率"></a>3.1 查看SQL执行频率</h3><p>MySQL 客户端连接成功后，通过 <code>show [session|global] status</code> 命令可以提供<code>服务器状态信息</code>。show [session|global] status 可以根据需要加上参数“session”或者“global”来显示 <code>session 级（当前连接）</code>的计结果和 <code>global 级（自数据库上次启动至今）</code>的统计结果。如果不写，默认使用参数是“session”。</p>
<p>下面的命令显示了当前 session 中所有统计参数的值：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>Com_select</td>
<td>执行 select 操作的次数，一次查询只累加 1。</td>
</tr>
<tr>
<td>Com_insert</td>
<td>执行 INSERT 操作的次数，对于批量插入的 INSERT 操作，只累加一次。</td>
</tr>
<tr>
<td>Com_update</td>
<td>执行 UPDATE 操作的次数。</td>
</tr>
<tr>
<td>Com_delete</td>
<td>执行 DELETE 操作的次数。</td>
</tr>
<tr>
<td>Innodb_rows_read</td>
<td>select 查询返回的行数。</td>
</tr>
<tr>
<td>Innodb_rows_inserted</td>
<td>执行 INSERT 操作插入的行数。</td>
</tr>
<tr>
<td>Innodb_rows_updated</td>
<td>执行 UPDATE 操作更新的行数。</td>
</tr>
<tr>
<td>Innodb_rows_deleted</td>
<td>执行 DELETE 操作删除的行数。</td>
</tr>
<tr>
<td>Connections</td>
<td>试图连接 MySQL 服务器的次数。</td>
</tr>
<tr>
<td>Uptime</td>
<td>服务器工作时间。</td>
</tr>
<tr>
<td>Slow_queries</td>
<td>慢查询的次数。</td>
</tr>
</tbody></table>
<div class="hljs"><pre><code class="hljs mysql">show status like &#39;Com_______&#39;;</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210525083736.png" srcset="/img/loading.gif"></p>
<div class="hljs"><pre><code class="hljs mysql">show status like &#39;Innodb_rows_%&#39;;</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210525083826.png" srcset="/img/loading.gif"></p>
<ul>
<li><p>Com_*** : 这些参数对于 <code>所有存储引擎</code> 的表操作都会进行累计。</p>
</li>
<li><p>Innodb_*** : 这几个参数只是针对 <code>InnoDB 存储引擎</code> 的，累加的算法也略有不同。</p>
</li>
</ul>
<h3 id="3-2-定位低效率执行SQL"><a href="#3-2-定位低效率执行SQL" class="headerlink" title="3.2 定位低效率执行SQL"></a>3.2 定位低效率执行SQL</h3><p>可以通过以下两种方式定位执行效率较低的 SQL 语句。</p>
<ul>
<li> <strong>慢查询日志</strong>  : 通过慢查询日志定位那些执行效率较低的 SQL 语句，用–log-slow-queries[=file_name]选项启动时，mysqld 写一个包含所有执行时间超过 long_query_time 秒的 SQL 语句的日志文件。具体可以查看本书第 26 章中日志管理的相关部分。</li>
<li> <strong>show processlist</strong>  : 慢查询日志在查询结束以后才纪录，所以在应用反映执行效率出现问题的时候查询慢查询日志并不能定位问题，可以使用show processlist命令<code>查看当前MySQL在进行的线程</code>，包括线程的状态、是否锁表等，可以实时地查看 SQL 的执行情况，同时对一些锁表操作进行优化。</li>
</ul>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210525084448.png" srcset="/img/loading.gif"></p>
<p>navicat会占用</p>
<div class="hljs"><pre><code class="hljs markdown">1） id列，用户登录mysql时，系统分配的&quot;connection<span class="hljs-emphasis">_id&quot;，可以使用函数connection_</span>id()查看

2） user列，显示当前用户。如果不是root，这个命令就只显示用户权限范围的sql语句

3） host列，显示这个语句是从哪个ip的哪个端口上发的，可以用来跟踪出现问题语句的用户

4） db列，显示这个进程目前连接的是哪个数据库

5） command列，显示当前连接的执行的命令，一般取值为休眠（sleep），查询（query），连接（connect）等

6） time列，显示这个状态持续的时间，单位是秒

7） state列，显示使用当前连接的sql语句的状态，很重要的列。state描述的是语句执行中的某一个状态。一个sql语句，以查询为例，可能需要经过copying to tmp table、sorting result、sending data等状态才可以完成

8） info列，显示这个sql语句，是判断问题语句的一个重要依据</code></pre></div>

<p>测试一个有三百万条数据的表：</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210525084651.png" srcset="/img/loading.gif"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210525084730.png" srcset="/img/loading.gif"></p>
<h3 id="3-3-explain分析执行计划"><a href="#3-3-explain分析执行计划" class="headerlink" title="3.3 explain分析执行计划"></a>3.3 explain分析执行计划</h3><p>通过以上步骤查询到效率低的 SQL 语句后，可以通过 <code>EXPLAIN或者 DESC命令</code>获取 MySQL如何执行 SELECT 语句的信息，包括在 <code>SELECT 语句执行过程中表如何连接和连接的顺序</code>。</p>
<p>查询SQL语句的执行计划 ：</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210525085403.png" srcset="/img/loading.gif"></p>
<table>
<thead>
<tr>
<th>字段</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>select查询的序列号，是一组数字，表示的是查询中执行select子句或者是操作表的顺序。</td>
</tr>
<tr>
<td>select_type</td>
<td>表示 SELECT 的类型，常见的取值有 SIMPLE（简单表，即不使用表连接或者子查询）、PRIMARY（主查询，即外层的查询）、UNION（UNION 中的第二个或者后面的查询语句）、SUBQUERY（子查询中的第一个 SELECT）等</td>
</tr>
<tr>
<td>table</td>
<td>输出结果集的表</td>
</tr>
<tr>
<td>type</td>
<td>表示表的连接类型，性能由好到差的连接类型为( system —&gt; const —–&gt; eq_ref ——&gt; ref ——-&gt; ref_or_null—-&gt; index_merge —&gt; index_subquery —–&gt; range —–&gt; index ——&gt; all )</td>
</tr>
<tr>
<td>possible_keys</td>
<td>表示查询时，可能使用的索引</td>
</tr>
<tr>
<td>key</td>
<td>表示实际使用的索引</td>
</tr>
<tr>
<td>key_len</td>
<td>索引字段的长度</td>
</tr>
<tr>
<td>rows</td>
<td>扫描行的数量</td>
</tr>
<tr>
<td>extra</td>
<td>执行情况的说明和描述</td>
</tr>
</tbody></table>
<h4 id="3-3-1-环境准备"><a href="#3-3-1-环境准备" class="headerlink" title="3.3.1 环境准备"></a>3.3.1 环境准备</h4><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210525085554.png" srcset="/img/loading.gif"></p>
<div class="hljs"><pre><code class="hljs mysql">CREATE TABLE &#96;t_role&#96; (
  &#96;id&#96; varchar(32) NOT NULL,
  &#96;role_name&#96; varchar(255) DEFAULT NULL,
  &#96;role_code&#96; varchar(255) DEFAULT NULL,
  &#96;description&#96; varchar(255) DEFAULT NULL,
  PRIMARY KEY (&#96;id&#96;),
  UNIQUE KEY &#96;unique_role_name&#96; (&#96;role_name&#96;)
) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8;


CREATE TABLE &#96;t_user&#96; (
  &#96;id&#96; varchar(32) NOT NULL,
  &#96;username&#96; varchar(45) NOT NULL,
  &#96;password&#96; varchar(96) NOT NULL,
  &#96;name&#96; varchar(45) NOT NULL,
  PRIMARY KEY (&#96;id&#96;),
  UNIQUE KEY &#96;unique_user_username&#96; (&#96;username&#96;)
) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8;


CREATE TABLE &#96;user_role&#96; (
  &#96;id&#96; int(11) NOT NULL auto_increment ,
  &#96;user_id&#96; varchar(32) DEFAULT NULL,
  &#96;role_id&#96; varchar(32) DEFAULT NULL,
  PRIMARY KEY (&#96;id&#96;),
  KEY &#96;fk_ur_user_id&#96; (&#96;user_id&#96;),
  KEY &#96;fk_ur_role_id&#96; (&#96;role_id&#96;),
  CONSTRAINT &#96;fk_ur_role_id&#96; FOREIGN KEY (&#96;role_id&#96;) REFERENCES &#96;t_role&#96; (&#96;id&#96;) ON DELETE NO ACTION ON UPDATE NO ACTION,
  CONSTRAINT &#96;fk_ur_user_id&#96; FOREIGN KEY (&#96;user_id&#96;) REFERENCES &#96;t_user&#96; (&#96;id&#96;) ON DELETE NO ACTION ON UPDATE NO ACTION
) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8;</code></pre></div>

<div class="hljs"><pre><code class="hljs mysql">
insert into &#96;t_user&#96; (&#96;id&#96;, &#96;username&#96;, &#96;password&#96;, &#96;name&#96;) values(&#39;1&#39;,&#39;super&#39;,&#39;$2a$10$TJ4TmCdK.X4wv&#x2F;tCqHW14.w70U3CC33CeVncD3SLmyMXMknstqKRe&#39;,&#39;超级管理员&#39;);
insert into &#96;t_user&#96; (&#96;id&#96;, &#96;username&#96;, &#96;password&#96;, &#96;name&#96;) values(&#39;2&#39;,&#39;admin&#39;,&#39;$2a$10$TJ4TmCdK.X4wv&#x2F;tCqHW14.w70U3CC33CeVncD3SLmyMXMknstqKRe&#39;,&#39;系统管理员&#39;);
insert into &#96;t_user&#96; (&#96;id&#96;, &#96;username&#96;, &#96;password&#96;, &#96;name&#96;) values(&#39;3&#39;,&#39;itcast&#39;,&#39;$2a$10$8qmaHgUFUAmPR5pOuWhYWOr291WJYjHelUlYn07k5ELF8ZCrW0Cui&#39;,&#39;test02&#39;);
insert into &#96;t_user&#96; (&#96;id&#96;, &#96;username&#96;, &#96;password&#96;, &#96;name&#96;) values(&#39;4&#39;,&#39;stu1&#39;,&#39;$2a$10$pLtt2KDAFpwTWLjNsmTEi.oU1yOZyIn9XkziK&#x2F;y&#x2F;spH5rftCpUMZa&#39;,&#39;学生1&#39;);
insert into &#96;t_user&#96; (&#96;id&#96;, &#96;username&#96;, &#96;password&#96;, &#96;name&#96;) values(&#39;5&#39;,&#39;stu2&#39;,&#39;$2a$10$nxPKkYSez7uz2YQYUnwhR.z57km3yqKn3Hr&#x2F;p1FR6ZKgc18u.Tvqm&#39;,&#39;学生2&#39;);
insert into &#96;t_user&#96; (&#96;id&#96;, &#96;username&#96;, &#96;password&#96;, &#96;name&#96;) values(&#39;6&#39;,&#39;t1&#39;,&#39;$2a$10$TJ4TmCdK.X4wv&#x2F;tCqHW14.w70U3CC33CeVncD3SLmyMXMknstqKRe&#39;,&#39;老师1&#39;);



INSERT INTO &#96;t_role&#96; (&#96;id&#96;, &#96;role_name&#96;, &#96;role_code&#96;, &#96;description&#96;) VALUES(&#39;5&#39;,&#39;学生&#39;,&#39;student&#39;,&#39;学生&#39;);
INSERT INTO &#96;t_role&#96; (&#96;id&#96;, &#96;role_name&#96;, &#96;role_code&#96;, &#96;description&#96;) VALUES(&#39;7&#39;,&#39;老师&#39;,&#39;teacher&#39;,&#39;老师&#39;);
INSERT INTO &#96;t_role&#96; (&#96;id&#96;, &#96;role_name&#96;, &#96;role_code&#96;, &#96;description&#96;) VALUES(&#39;8&#39;,&#39;教学管理员&#39;,&#39;teachmanager&#39;,&#39;教学管理员&#39;);
INSERT INTO &#96;t_role&#96; (&#96;id&#96;, &#96;role_name&#96;, &#96;role_code&#96;, &#96;description&#96;) VALUES(&#39;9&#39;,&#39;管理员&#39;,&#39;admin&#39;,&#39;管理员&#39;);
INSERT INTO &#96;t_role&#96; (&#96;id&#96;, &#96;role_name&#96;, &#96;role_code&#96;, &#96;description&#96;) VALUES(&#39;10&#39;,&#39;超级管理员&#39;,&#39;super&#39;,&#39;超级管理员&#39;);


INSERT INTO user_role(id,user_id,role_id) VALUES(NULL, &#39;1&#39;, &#39;5&#39;),(NULL, &#39;1&#39;, &#39;7&#39;),(NULL, &#39;2&#39;, &#39;8&#39;),(NULL, &#39;3&#39;, &#39;9&#39;),(NULL, &#39;4&#39;, &#39;8&#39;),(NULL, &#39;5&#39;, &#39;10&#39;) ;
</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210525090031.png" srcset="/img/loading.gif"></p>
<h4 id="3-3-2-explain-之-id"><a href="#3-3-2-explain-之-id" class="headerlink" title="3.3.2 explain 之 id"></a>3.3.2 explain 之 id</h4><p>id 字段是 select查询的序列号，是一组数字，表示的是查询中执行select子句或者是操作表的顺序。id 情况有三种 ：</p>
<p>1） <code>id 相同</code>表示加载表的顺序是 <code>从上到下</code>。</p>
<div class="hljs"><pre><code class="hljs mysql">explain select * from t_role r, t_user u, user_role ur where r.id &#x3D; ur.role_id and u.id &#x3D; ur.user_id ;</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210525090252.png" srcset="/img/loading.gif"></p>
<p>2） <code>id 不同</code> <code>id值越大，优先级越高</code>，越先被执行。</p>
<div class="hljs"><pre><code class="hljs Mysql">EXPLAIN SELECT * FROM t_role WHERE id &#x3D; (SELECT role_id FROM user_role WHERE user_id &#x3D; (SELECT id FROM t_user WHERE username &#x3D; &#39;stu1&#39;))</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210525090409.png" srcset="/img/loading.gif"></p>
<p>3） id 有相同，也有不同，同时存在。id相同的可以认为是一组，从上往下顺序执行；在所有的组中，id的值越大，优先级越高，越先执行。</p>
<div class="hljs"><pre><code class="hljs mysql">EXPLAIN SELECT * FROM t_role r , (SELECT * FROM user_role ur WHERE ur.&#96;user_id&#96; &#x3D; &#39;2&#39;) a WHERE r.id &#x3D; a.role_id ;</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210525090508.png" srcset="/img/loading.gif"></p>
<h4 id="3-3-3-explain-之-select-type"><a href="#3-3-3-explain-之-select-type" class="headerlink" title="3.3.3 explain 之 select_type"></a>3.3.3 explain 之 select_type</h4><p>表示 SELECT 的类型，常见的取值，如下表所示：</p>
<table>
<thead>
<tr>
<th>select_type</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>SIMPLE</td>
<td>简单的select查询，查询中不包含子查询或者UNION</td>
</tr>
<tr>
<td>PRIMARY</td>
<td>查询中若包含任何复杂的子查询，最外层查询标记为该标识</td>
</tr>
<tr>
<td>SUBQUERY</td>
<td>在SELECT 或 WHERE 列表中包含了子查询</td>
</tr>
<tr>
<td>DERIVED</td>
<td>在FROM 列表中包含的子查询，被标记为 DERIVED（衍生） MYSQL会递归执行这些子查询，把结果放在 <strong>临时表</strong> 中</td>
</tr>
<tr>
<td>UNION</td>
<td>若第二个SELECT出现在UNION之后，则标记为UNION ； 若UNION包含在FROM子句的子查询中，外层SELECT将被标记为 ： DERIVED</td>
</tr>
<tr>
<td>UNION RESULT</td>
<td>从UNION表获取结果的SELECT</td>
</tr>
</tbody></table>
<p>效率越来越低</p>
<h4 id="3-3-4-explain-之-table"><a href="#3-3-4-explain-之-table" class="headerlink" title="3.3.4 explain 之 table"></a>3.3.4 explain 之 table</h4><p>展示这一行的数据是关于哪一张表的</p>
<h4 id="3-3-5-explain-之-type"><a href="#3-3-5-explain-之-type" class="headerlink" title="3.3.5 explain 之 type"></a>3.3.5 explain 之 type</h4><p>type 显示的是访问类型，是较为重要的一个指标，可取值为：</p>
<table>
<thead>
<tr>
<th>type</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>NULL</td>
<td>MySQL不访问任何表，索引，直接返回结果</td>
</tr>
<tr>
<td>system</td>
<td>表只有一行记录(等于系统表)，这是const类型的特例，一般不会出现</td>
</tr>
<tr>
<td>const</td>
<td>表示通过 <code>索引一次</code> 就找到了，const 用于比较primary key 或者 unique 索引。因为 <code>只匹配一行数据</code> ，所以很快。如将主键置于where列表中，MySQL 就能将该查询转换为一个常量。const于将 “主键” 或 “唯一” 索引的所有部分与常量值进行比较</td>
</tr>
<tr>
<td>eq_ref</td>
<td>类似ref，区别在于使用的是唯一索引，使用主键的关联查询，关联查询出的记录只有一条。常见于主键或唯一索引扫描</td>
</tr>
<tr>
<td>ref</td>
<td>非唯一性索引扫描，返回匹配某个单独值的所有行。本质上也是一种索引访问，返回所有匹配某个单独值的所有行（多个）</td>
</tr>
<tr>
<td>range</td>
<td>只检索给定返回的行，使用一个索引来选择行。 where 之后出现 between ， &lt; , &gt; , in 等操作。</td>
</tr>
<tr>
<td>index</td>
<td>index 与 ALL的区别为 index 类型只是遍历了索引树， 通常比ALL 快， ALL 是遍历数据文件。</td>
</tr>
<tr>
<td>all</td>
<td>将遍历全表以找到匹配的行</td>
</tr>
</tbody></table>
<p>结果值从最好到最坏以此是：</p>
<div class="hljs"><pre><code class="hljs pgsql"><span class="hljs-keyword">NULL</span> &gt; <span class="hljs-keyword">system</span> &gt; const &gt; eq_ref &gt; <span class="hljs-keyword">ref</span> &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; <span class="hljs-keyword">index</span> &gt; <span class="hljs-keyword">ALL</span>


<span class="hljs-keyword">system</span> &gt; const &gt; eq_ref &gt; <span class="hljs-keyword">ref</span> &gt; range &gt; <span class="hljs-keyword">index</span> &gt; <span class="hljs-keyword">ALL</span></code></pre></div>

<p>==一般来说， 我们需要保证查询至少达到 range 级别， 最好达到ref 。==</p>
<h4 id="3-3-6-explain-之-key"><a href="#3-3-6-explain-之-key" class="headerlink" title="3.3.6 explain 之 key"></a>3.3.6 explain 之 key</h4><div class="hljs"><pre><code class="hljs markdown">possible<span class="hljs-emphasis">_keys : 显示可能应用在这张表的索引， 一个或多个。 </span>
<span class="hljs-emphasis"></span>
<span class="hljs-emphasis">key ： 实际使用的索引， 如果为NULL， 则没有使用索引。</span>
<span class="hljs-emphasis"></span>
<span class="hljs-emphasis">key_</span>len : 表示索引中使用的字节数， 该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下， 长度越短越好 。</code></pre></div>

<h4 id="3-3-7-explain-之-rows"><a href="#3-3-7-explain-之-rows" class="headerlink" title="3.3.7 explain 之 rows"></a>3.3.7 explain 之 rows</h4><p>扫描行的数量。</p>
<h4 id="3-3-8-explain-之-extra"><a href="#3-3-8-explain-之-extra" class="headerlink" title="3.3.8 explain 之 extra"></a>3.3.8 explain 之 extra</h4><p>其他的额外的执行计划信息，在该列展示 。</p>
<table>
<thead>
<tr>
<th>extra</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>using filesort</td>
<td>说明mysql会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取， 称为 “文件排序”, 效率低。</td>
</tr>
<tr>
<td>using temporary</td>
<td>使用了临时表保存中间结果，MySQL在对查询结果排序时使用临时表。常见于 order by 和 group by； 效率低</td>
</tr>
<tr>
<td>using index</td>
<td>表示相应的select操作使用了覆盖索引， 避免访问表的数据行， 效率不错。</td>
</tr>
</tbody></table>
<p>前面两个出现，则需要优化；</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210525092012.png" srcset="/img/loading.gif"></p>
<p>效率低，需要扫描文件内容；</p>
<p>解决：对password建立索引</p>
<p>例如对name建立了索引后，查询name字段并排序</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210525092103.png" srcset="/img/loading.gif"></p>
<h3 id="3-4-show-profile分析SQL"><a href="#3-4-show-profile分析SQL" class="headerlink" title="3.4 show profile分析SQL"></a>3.4 show profile分析SQL</h3><p>Mysql从5.0.37版本开始增加了对 show profiles 和 show profile 语句的支持。show profiles 能够在做SQL优化时帮助我们了解时间都耗费到哪里去了。</p>
<p>通过 have_profiling 参数，能够看到当前MySQL是否支持profile：</p>
<div class="hljs"><pre><code class="hljs mysql">select @@have_profiling;</code></pre></div>

<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210525103616.png" srcset="/img/loading.gif" style="zoom:50%;" />

<p>默认profiling是关闭的，可以通过set语句在Session级别开启profiling：</p>
<div class="hljs"><pre><code class="hljs mysql">select @@profiling;</code></pre></div>

<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210525103715.png" srcset="/img/loading.gif" style="zoom:50%;" />

<div class="hljs"><pre><code class="hljs mysql">set profiling&#x3D;1; &#x2F;&#x2F;开启profiling 开关；</code></pre></div>

<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210525103738.png" srcset="/img/loading.gif" style="zoom:50%;" />

<p>通过profile，我们能够更清楚地了解SQL执行的过程。</p>
<p>首先，我们可以执行一系列的操作，如下图所示：</p>
<div class="hljs"><pre><code class="hljs mysql">show databases;

use demo_01;

show tables;

select * from ....</code></pre></div>

<p>执行完上述命令之后，再执行<code>show profiles</code> 指令， 来查看SQL语句执行的耗时：</p>
<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210525103929.png" srcset="/img/loading.gif" style="zoom:50%;" />

<p>通过<code>show profile for query query_id</code> 语句可以查看到该SQL执行过程中每个线程的状态和消耗的时间：</p>
<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210525104038.png" srcset="/img/loading.gif" style="zoom:50%;" />

<div class="hljs"><pre><code class="hljs markdown">TIP ：
<span class="hljs-code">	Sending data 状态表示MySQL线程开始访问数据行并把结果返回给客户端，而不仅仅是返回客户端。由于在Sending data状态下，MySQL线程往往需要做大量的磁盘读取操作，所以经常是整各查询中耗时最长的状态。</span></code></pre></div>

<p>在获取到最消耗时间的线程状态后，MySQL支持进一步选择all、cpu、block io 、context switch、page faults等明细类型类查看MySQL在使用什么资源上耗费了过高的时间。例如，选择查看CPU的耗费时间 ：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>Status</td>
<td>sql 语句执行的状态</td>
</tr>
<tr>
<td>Duration</td>
<td>sql 执行过程中每一个步骤的耗时</td>
</tr>
<tr>
<td>CPU_user</td>
<td>当前用户占有的cpu</td>
</tr>
<tr>
<td>CPU_system</td>
<td>系统占有的cpu</td>
</tr>
</tbody></table>
<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210525104352.png" srcset="/img/loading.gif" style="zoom:50%;" />

<h3 id="3-5-trace分析优化器执行计划"><a href="#3-5-trace分析优化器执行计划" class="headerlink" title="3.5 trace分析优化器执行计划"></a>3.5 trace分析优化器执行计划</h3><p>MySQL5.6提供了对SQL的跟踪trace, 通过trace文件能够进一步了解为什么优化器选择A计划, 而不是选择B计划。</p>
<p>打开trace ， 设置格式为 JSON，并设置trace最大能够使用的内存大小，避免解析过程中因为默认内存过小而不能够完整展示。</p>
<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210525104428.png" srcset="/img/loading.gif" style="zoom:50%;" />

<div class="hljs"><pre><code class="hljs mysql">SET optimizer_trace&#x3D;&quot;enabled&#x3D;on&quot;,end_markers_in_json&#x3D;on;
set optimizer_trace_max_mem_size&#x3D;1000000;</code></pre></div>

<p>执行SQL语句 ：</p>
<div class="hljs"><pre><code class="hljs mysql">select * from ..</code></pre></div>

<p>最后， 检查information_schema.optimizer_trace就可以知道MySQL是如何执行SQL的 ：</p>
<div class="hljs"><pre><code class="hljs mysql">select * from information_schema.optimizer_trace\G;</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210525104717.png" srcset="/img/loading.gif"></p>
<h2 id="4-索引的使用"><a href="#4-索引的使用" class="headerlink" title="4. 索引的使用"></a>4. 索引的使用</h2><p>索引是数据库优化最常用也是最重要的手段之一, 通过索引通常可以帮助用户解决大多数的MySQL的性能优化问题。</p>
<h3 id="4-1-验证索引提升查询效率"><a href="#4-1-验证索引提升查询效率" class="headerlink" title="4.1 验证索引提升查询效率"></a>4.1 验证索引提升查询效率</h3><p>在我们准备的表结构tb_item 中， 一共存储了 300 万记录；</p>
<ol>
<li><p>根据ID查询</p>
<div class="hljs"><pre><code class="hljs mysql">select * from tb_item where id &#x3D; 1999;</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210525111516.png" srcset="/img/loading.gif"></p>
<p>查询速度很快， 接近0s ， 主要的原因是因为id为主键， 有索引；</p>
</li>
<li><p>根据 title 进行精确查询</p>
<div class="hljs"><pre><code class="hljs mysql">select * from tb_item where title &#x3D; &#39;iphoneX 移动3G 32G941&#39;;</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210525112311.png" srcset="/img/loading.gif"></p>
<p>处理方案 ， 针对title字段， 创建索引 ：</p>
<div class="hljs"><pre><code class="hljs mysql">create index idx_item_title on tb_item(title);</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210525112428.png" srcset="/img/loading.gif"></p>
<p>索引创建完成之后，再次进行查询 ：</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210525112455.png" srcset="/img/loading.gif"></p>
</li>
</ol>
<h3 id="4-2-索引的使用"><a href="#4-2-索引的使用" class="headerlink" title="4.2 索引的使用"></a>4.2 索引的使用</h3><h4 id="4-2-1-准备环境"><a href="#4-2-1-准备环境" class="headerlink" title="4.2.1 准备环境"></a>4.2.1 准备环境</h4><div class="hljs"><pre><code class="hljs mysql">create table &#96;tb_seller&#96; (
	&#96;sellerid&#96; varchar (100),
	&#96;name&#96; varchar (100),
	&#96;nickname&#96; varchar (50),
	&#96;password&#96; varchar (60),
	&#96;status&#96; varchar (1),
	&#96;address&#96; varchar (100),
	&#96;createtime&#96; datetime,
    primary key(&#96;sellerid&#96;)
)engine&#x3D;innodb default charset&#x3D;utf8mb4; 

insert into &#96;tb_seller&#96; (&#96;sellerid&#96;, &#96;name&#96;, &#96;nickname&#96;, &#96;password&#96;, &#96;status&#96;, &#96;address&#96;, &#96;createtime&#96;) values(&#39;alibaba&#39;,&#39;阿里巴巴&#39;,&#39;阿里小店&#39;,&#39;e10adc3949ba59abbe56e057f20f883e&#39;,&#39;1&#39;,&#39;北京市&#39;,&#39;2088-01-01 12:00:00&#39;);
insert into &#96;tb_seller&#96; (&#96;sellerid&#96;, &#96;name&#96;, &#96;nickname&#96;, &#96;password&#96;, &#96;status&#96;, &#96;address&#96;, &#96;createtime&#96;) values(&#39;baidu&#39;,&#39;百度科技有限公司&#39;,&#39;百度小店&#39;,&#39;e10adc3949ba59abbe56e057f20f883e&#39;,&#39;1&#39;,&#39;北京市&#39;,&#39;2088-01-01 12:00:00&#39;);
insert into &#96;tb_seller&#96; (&#96;sellerid&#96;, &#96;name&#96;, &#96;nickname&#96;, &#96;password&#96;, &#96;status&#96;, &#96;address&#96;, &#96;createtime&#96;) values(&#39;huawei&#39;,&#39;华为科技有限公司&#39;,&#39;华为小店&#39;,&#39;e10adc3949ba59abbe56e057f20f883e&#39;,&#39;0&#39;,&#39;北京市&#39;,&#39;2088-01-01 12:00:00&#39;);
insert into &#96;tb_seller&#96; (&#96;sellerid&#96;, &#96;name&#96;, &#96;nickname&#96;, &#96;password&#96;, &#96;status&#96;, &#96;address&#96;, &#96;createtime&#96;) values(&#39;itcast&#39;,&#39;传智播客教育科技有限公司&#39;,&#39;传智播客&#39;,&#39;e10adc3949ba59abbe56e057f20f883e&#39;,&#39;1&#39;,&#39;北京市&#39;,&#39;2088-01-01 12:00:00&#39;);
insert into &#96;tb_seller&#96; (&#96;sellerid&#96;, &#96;name&#96;, &#96;nickname&#96;, &#96;password&#96;, &#96;status&#96;, &#96;address&#96;, &#96;createtime&#96;) values(&#39;itheima&#39;,&#39;黑马程序员&#39;,&#39;黑马程序员&#39;,&#39;e10adc3949ba59abbe56e057f20f883e&#39;,&#39;0&#39;,&#39;北京市&#39;,&#39;2088-01-01 12:00:00&#39;);
insert into &#96;tb_seller&#96; (&#96;sellerid&#96;, &#96;name&#96;, &#96;nickname&#96;, &#96;password&#96;, &#96;status&#96;, &#96;address&#96;, &#96;createtime&#96;) values(&#39;luoji&#39;,&#39;罗技科技有限公司&#39;,&#39;罗技小店&#39;,&#39;e10adc3949ba59abbe56e057f20f883e&#39;,&#39;1&#39;,&#39;北京市&#39;,&#39;2088-01-01 12:00:00&#39;);
insert into &#96;tb_seller&#96; (&#96;sellerid&#96;, &#96;name&#96;, &#96;nickname&#96;, &#96;password&#96;, &#96;status&#96;, &#96;address&#96;, &#96;createtime&#96;) values(&#39;oppo&#39;,&#39;OPPO科技有限公司&#39;,&#39;OPPO官方旗舰店&#39;,&#39;e10adc3949ba59abbe56e057f20f883e&#39;,&#39;0&#39;,&#39;北京市&#39;,&#39;2088-01-01 12:00:00&#39;);
insert into &#96;tb_seller&#96; (&#96;sellerid&#96;, &#96;name&#96;, &#96;nickname&#96;, &#96;password&#96;, &#96;status&#96;, &#96;address&#96;, &#96;createtime&#96;) values(&#39;ourpalm&#39;,&#39;掌趣科技股份有限公司&#39;,&#39;掌趣小店&#39;,&#39;e10adc3949ba59abbe56e057f20f883e&#39;,&#39;1&#39;,&#39;北京市&#39;,&#39;2088-01-01 12:00:00&#39;);
insert into &#96;tb_seller&#96; (&#96;sellerid&#96;, &#96;name&#96;, &#96;nickname&#96;, &#96;password&#96;, &#96;status&#96;, &#96;address&#96;, &#96;createtime&#96;) values(&#39;qiandu&#39;,&#39;千度科技&#39;,&#39;千度小店&#39;,&#39;e10adc3949ba59abbe56e057f20f883e&#39;,&#39;2&#39;,&#39;北京市&#39;,&#39;2088-01-01 12:00:00&#39;);
insert into &#96;tb_seller&#96; (&#96;sellerid&#96;, &#96;name&#96;, &#96;nickname&#96;, &#96;password&#96;, &#96;status&#96;, &#96;address&#96;, &#96;createtime&#96;) values(&#39;sina&#39;,&#39;新浪科技有限公司&#39;,&#39;新浪官方旗舰店&#39;,&#39;e10adc3949ba59abbe56e057f20f883e&#39;,&#39;1&#39;,&#39;北京市&#39;,&#39;2088-01-01 12:00:00&#39;);
insert into &#96;tb_seller&#96; (&#96;sellerid&#96;, &#96;name&#96;, &#96;nickname&#96;, &#96;password&#96;, &#96;status&#96;, &#96;address&#96;, &#96;createtime&#96;) values(&#39;xiaomi&#39;,&#39;小米科技&#39;,&#39;小米官方旗舰店&#39;,&#39;e10adc3949ba59abbe56e057f20f883e&#39;,&#39;1&#39;,&#39;西安市&#39;,&#39;2088-01-01 12:00:00&#39;);
insert into &#96;tb_seller&#96; (&#96;sellerid&#96;, &#96;name&#96;, &#96;nickname&#96;, &#96;password&#96;, &#96;status&#96;, &#96;address&#96;, &#96;createtime&#96;) values(&#39;yijia&#39;,&#39;宜家家居&#39;,&#39;宜家家居旗舰店&#39;,&#39;e10adc3949ba59abbe56e057f20f883e&#39;,&#39;1&#39;,&#39;北京市&#39;,&#39;2088-01-01 12:00:00&#39;);


create index idx_seller_name_sta_addr on tb_seller(name,status,address);</code></pre></div>

<h4 id="4-2-2-避免索引失效"><a href="#4-2-2-避免索引失效" class="headerlink" title="4.2.2 避免索引失效"></a>4.2.2 避免索引失效</h4><ol>
<li><p>全值匹配 ，对索引中所有列都指定具体值。</p>
<p>该情况下，索引生效，执行效率高。</p>
<div class="hljs"><pre><code class="hljs mysql">explain select * from tb_seller where name&#x3D;&#39;小米科技&#39; and status&#x3D;&#39;1&#39; and address&#x3D;&#39;北京市&#39;</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210525113211.png" srcset="/img/loading.gif"></p>
</li>
<li><p>最左前缀法则</p>
<p>如果索引了多列，要遵守最左前缀法则。指的是查询从索引的最左前列开始，并且不跳过索引中的列。</p>
<ul>
<li>匹配最左前缀法则，走索引(name,status,address)：</li>
</ul>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210525113334.png" srcset="/img/loading.gif"></p>
<ul>
<li>违法最左前缀法则 ， 索引失效：</li>
</ul>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210525113412.png" srcset="/img/loading.gif"></p>
<ul>
<li>如果符合最左法则，但是出现跳跃某一列，只有<code>最左列索引</code>生效：</li>
</ul>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210525113434.png" srcset="/img/loading.gif"></p>
<ul>
<li>name在最后也是会走索引的</li>
</ul>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210525113730.png" srcset="/img/loading.gif"></p>
</li>
<li><p>范围查询右边的列，不能使用索引 。</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210525113503.png" srcset="/img/loading.gif"></p>
<p>根据前面的两个字段name ， status 查询是走索引的， 但是最后一个条件address 没有用到索引。</p>
</li>
<li><p>不要在索引列上进行运算操作， 索引将失效。</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210525114044.png" srcset="/img/loading.gif"></p>
</li>
<li><p>字符串不加单引号，造成索引失效。</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210525114104.png" srcset="/img/loading.gif"></p>
<p>在查询时，没有对字符串加单引号，MySQL的查询优化器，会自动的进行类型转换，造成索引失效。</p>
</li>
<li><p>尽量使用覆盖索引，避免select *</p>
<p>尽量使用覆盖索引（只访问索引的查询（索引列完全包含查询列）），减少select * 。</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210525114309.png" srcset="/img/loading.gif"></p>
<p>如果查询列，超出索引列，也会降低性能。（using index condition）</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210525114347.png" srcset="/img/loading.gif"></p>
</li>
</ol>
<div class="hljs"><pre><code class="hljs markdown">TIP : 
<span class="hljs-code">	</span>
<span class="hljs-code">    using index ：使用覆盖索引的时候就会出现</span>
<span class="hljs-code"></span>
<span class="hljs-code">    using where：在查找使用索引的情况下，需要回表去查询所需的数据</span>
<span class="hljs-code"></span>
<span class="hljs-code">    using index condition：查找使用了索引，但是需要回表查询数据(获取数据的时候还需要到表结构里面查询这一整行)</span>
<span class="hljs-code"></span>
<span class="hljs-code">    using index ; using where：查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询数据</span></code></pre></div>

<ol start="7">
<li><p>用or分割开的条件， 如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到。</p>
<p>示例，name字段是索引列 ， 而createtime不是索引列，中间是or进行连接是不走索引的 ：</p>
<div class="hljs"><pre><code class="hljs mysql">explain select * from tb_seller where name&#x3D;&#39;黑马程序员&#39; or createtime &#x3D; &#39;2088-01-01 12:00:00&#39;;</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210526080344.png" srcset="/img/loading.gif"></p>
</li>
<li><p>以%开头的Like模糊查询，索引失效。</p>
<p>如果仅仅是尾部模糊匹配，索引不会失效。如果是头部模糊匹配，索引失效。</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210526080436.png" srcset="/img/loading.gif"></p>
<p>解决方案 ：</p>
<p>通过覆盖索引来解决</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210526080505.png" srcset="/img/loading.gif"></p>
</li>
<li><p>如果MySQL评估使用索引比全表更慢，则不使用索引。</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210526080830.png" srcset="/img/loading.gif"></p>
<p>一开始没走索引，因为该表为复合索引：</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210526080919.png" srcset="/img/loading.gif"></p>
<p>如果给address单独加上索引，就会走索引(但是基本上数据覆盖全表，走全表)</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210526080944.png" srcset="/img/loading.gif"></p>
</li>
<li><p>is NULL ， is NOT NULL 有时索引失效（根据数据覆盖程度自动判断）。</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210526081010.png" srcset="/img/loading.gif"></p>
</li>
<li><p>in ， not in 有时索引失效。</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210526081027.png" srcset="/img/loading.gif"></p>
</li>
<li><p>单列索引和复合索引。</p>
<p>尽量使用复合索引，而少使用单列索引 。</p>
<p>创建复合索引</p>
<div class="hljs"><pre><code class="hljs mysql">create index idx_name_sta_address on tb_seller(name, status, address);

就相当于创建了三个索引 ： 
	name
	name + status
	name + status + address</code></pre></div>

<p>创建单列索引</p>
<div class="hljs"><pre><code class="hljs mysql">create index idx_seller_name on tb_seller(name);
create index idx_seller_status on tb_seller(status);
create index idx_seller_address on tb_seller(address);</code></pre></div>

<p>数据库会选择一个最优的索引（辨识度最高索引）来使用，并不会使用全部索引 。</p>
</li>
</ol>
<h3 id="4-3-查看索引使用情况"><a href="#4-3-查看索引使用情况" class="headerlink" title="4.3 查看索引使用情况"></a>4.3 查看索引使用情况</h3><div class="hljs"><pre><code class="hljs mysql">show status like &#39;Handler_read%&#39;;	

show global status like &#39;Handler_read%&#39;;</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210526081737.png" srcset="/img/loading.gif"></p>
<div class="hljs"><pre><code class="hljs markdown"><span class="hljs-bullet">-</span> Handler<span class="hljs-emphasis">_read_</span>first：索引中第一条被读的次数。如果较高，表示服务器正执行大量全索引扫描（这个值越低越好）。

<span class="hljs-bullet">-</span> Handler<span class="hljs-emphasis">_read_</span>key：如果索引正在工作，这个值代表一个行被索引值读的次数，如果值越低，表示索引得到的性能改善不高，因为索引不经常使用（这个值越高越好）。

<span class="hljs-bullet">-</span> Handler<span class="hljs-emphasis">_read_</span>next ：按照键顺序读下一行的请求数。如果你用范围约束或如果执行索引扫描来查询索引列，该值增加。

<span class="hljs-bullet">-</span> Handler<span class="hljs-emphasis">_read_</span>prev：按照键顺序读前一行的请求数。该读方法主要用于优化ORDER BY ... DESC。

<span class="hljs-bullet">-</span> Handler<span class="hljs-emphasis">_read_</span>rnd ：根据固定位置读一行的请求数。如果你正执行大量查询并需要对结果进行排序该值较高。你可能使用了大量需要MySQL扫描整个表的查询或你的连接没有正确使用键。这个值较高，意味着运行效率低，应该建立索引来补救。

<span class="hljs-bullet">-</span> Handler<span class="hljs-emphasis">_read_</span>rnd<span class="hljs-emphasis">_next：在数据文件中读下一行的请求数。如果你正进行大量的表扫描，该值较高。通常说明你的表索引不正确或写入的查询没有利用索引。</span></code></pre></div>

<h2 id="5-SQL优化"><a href="#5-SQL优化" class="headerlink" title="5. SQL优化"></a>5. SQL优化</h2><h3 id="5-1-大批量插入数据"><a href="#5-1-大批量插入数据" class="headerlink" title="5.1 大批量插入数据"></a>5.1 大批量插入数据</h3><p>环境准备 ：</p>
<div class="hljs"><pre><code class="hljs mysql">CREATE TABLE &#96;tb_user_2&#96; (
  &#96;id&#96; int(11) NOT NULL AUTO_INCREMENT,
  &#96;username&#96; varchar(45) NOT NULL,
  &#96;password&#96; varchar(96) NOT NULL,
  &#96;name&#96; varchar(45) NOT NULL,
  &#96;birthday&#96; datetime DEFAULT NULL,
  &#96;sex&#96; char(1) DEFAULT NULL,
  &#96;email&#96; varchar(45) DEFAULT NULL,
  &#96;phone&#96; varchar(45) DEFAULT NULL,
  &#96;qq&#96; varchar(32) DEFAULT NULL,
  &#96;status&#96; varchar(32) NOT NULL COMMENT &#39;用户状态&#39;,
  &#96;create_time&#96; datetime NOT NULL,
  &#96;update_time&#96; datetime DEFAULT NULL,
  PRIMARY KEY (&#96;id&#96;),
  UNIQUE KEY &#96;unique_user_username&#96; (&#96;username&#96;)
) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8 ;</code></pre></div>

<p>创建同样的结构的tb_user_1和tb_user_2；</p>
<p>当使用 <code>load 命令</code> 导入数据的时候，适当的设置可以提高导入的效率。</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210526082554.png" srcset="/img/loading.gif"></p>
<p>对于 <code>InnoDB 类型的表</code>，有以下几种方式可以提高导入的效率：</p>
<p>1） 主键顺序插入</p>
<p>因为InnoDB类型的表是按照<code>主键的顺序</code>保存的，所以将导入的数据按照主键的顺序排列，可以有效的提高导入数据的效率。如果InnoDB表没有主键，那么系统会自动默认创建一个内部列作为主键，所以如果可以给表创建一个主键，将可以利用这点，来提高导入数据的效率。</p>
<div class="hljs"><pre><code class="hljs xl">脚本文件介绍 :
	<span class="hljs-function"><span class="hljs-title">sql1</span>.<span class="hljs-built_in">log</span>  ----&gt;</span> 主键有序
	<span class="hljs-function"><span class="hljs-title">sql2</span>.<span class="hljs-built_in">log</span>  ----&gt;</span> 主键无序</code></pre></div>

<p>Sql1.log文件：(主键有序)，sql2.log文件：主键无序</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210526083341.png" srcset="/img/loading.gif"></p>
<ul>
<li>插入ID顺序排列数据：</li>
</ul>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210526083425.png" srcset="/img/loading.gif"></p>
<ul>
<li>插入ID无序排列数据：</li>
</ul>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210526083459.png" srcset="/img/loading.gif"></p>
<p>2） 关闭唯一性校验</p>
<p>在导入数据前执行 SET UNIQUE_CHECKS=0，关闭唯一性校验，在导入结束后执行SET UNIQUE_CHECKS=1，恢复唯一性校验，可以提高导入的效率。</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210526083742.png" srcset="/img/loading.gif"></p>
<p>3） 手动提交事务</p>
<p>如果应用使用自动提交的方式，建议在导入前执行 SET AUTOCOMMIT=0，关闭自动提交，导入结束后再执行 SET AUTOCOMMIT=1，打开自动提交，也可以提高导入的效率。</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210526083801.png" srcset="/img/loading.gif"></p>
<h3 id="5-2-优化insert语句"><a href="#5-2-优化insert语句" class="headerlink" title="5.2 优化insert语句"></a>5.2 优化insert语句</h3><p>当进行数据的insert操作的时候，可以考虑采用以下几种优化方案。</p>
<ul>
<li><p>如果需要同时对一张表插入很多行数据时，应该尽量使用多个值表的insert语句，这种方式将大大的<code>缩减客户端与数据库之间的连接、关闭等消耗</code>。使得效率比分开执行的单个insert语句快。</p>
<p>示例， 原始方式为：</p>
<div class="hljs"><pre><code class="hljs mysql">insert into tb_test values(1,&#39;Tom&#39;);
insert into tb_test values(2,&#39;Cat&#39;);
insert into tb_test values(3,&#39;Jerry&#39;);</code></pre></div>

<p>优化后的方案为 ：</p>
<div class="hljs"><pre><code class="hljs mysql">insert into tb_test values(1,&#39;Tom&#39;),(2,&#39;Cat&#39;)，(3,&#39;Jerry&#39;);</code></pre></div>
</li>
<li><p>在事务中进行数据插入。</p>
<div class="hljs"><pre><code class="hljs mysql">start transaction;
insert into tb_test values(1,&#39;Tom&#39;);
insert into tb_test values(2,&#39;Cat&#39;);
insert into tb_test values(3,&#39;Jerry&#39;);
commit;</code></pre></div>
</li>
<li><p>数据有序插入</p>
<div class="hljs"><pre><code class="hljs mysql">insert into tb_test values(4,&#39;Tim&#39;);
insert into tb_test values(1,&#39;Tom&#39;);
insert into tb_test values(3,&#39;Jerry&#39;);
insert into tb_test values(5,&#39;Rose&#39;);
insert into tb_test values(2,&#39;Cat&#39;);</code></pre></div>

<p>优化后</p>
<div class="hljs"><pre><code class="hljs mysql">insert into tb_test values(1,&#39;Tom&#39;);
insert into tb_test values(2,&#39;Cat&#39;);
insert into tb_test values(3,&#39;Jerry&#39;);
insert into tb_test values(4,&#39;Tim&#39;);
insert into tb_test values(5,&#39;Rose&#39;);</code></pre></div>

</li>
</ul>
<h3 id="5-3-优化order-by语句"><a href="#5-3-优化order-by语句" class="headerlink" title="5.3 优化order by语句"></a>5.3 优化order by语句</h3><h4 id="5-3-1-环境准备"><a href="#5-3-1-环境准备" class="headerlink" title="5.3.1 环境准备"></a>5.3.1 环境准备</h4><div class="hljs"><pre><code class="hljs mysql">CREATE TABLE &#96;emp&#96; (
  &#96;id&#96; int(11) NOT NULL AUTO_INCREMENT,
  &#96;name&#96; varchar(100) NOT NULL,
  &#96;age&#96; int(3) NOT NULL,
  &#96;salary&#96; int(11) DEFAULT NULL,
  PRIMARY KEY (&#96;id&#96;)
) ENGINE&#x3D;InnoDB  DEFAULT CHARSET&#x3D;utf8mb4;

insert into &#96;emp&#96; (&#96;id&#96;, &#96;name&#96;, &#96;age&#96;, &#96;salary&#96;) values(&#39;1&#39;,&#39;Tom&#39;,&#39;25&#39;,&#39;2300&#39;);
insert into &#96;emp&#96; (&#96;id&#96;, &#96;name&#96;, &#96;age&#96;, &#96;salary&#96;) values(&#39;2&#39;,&#39;Jerry&#39;,&#39;30&#39;,&#39;3500&#39;);
insert into &#96;emp&#96; (&#96;id&#96;, &#96;name&#96;, &#96;age&#96;, &#96;salary&#96;) values(&#39;3&#39;,&#39;Luci&#39;,&#39;25&#39;,&#39;2800&#39;);
insert into &#96;emp&#96; (&#96;id&#96;, &#96;name&#96;, &#96;age&#96;, &#96;salary&#96;) values(&#39;4&#39;,&#39;Jay&#39;,&#39;36&#39;,&#39;3500&#39;);
insert into &#96;emp&#96; (&#96;id&#96;, &#96;name&#96;, &#96;age&#96;, &#96;salary&#96;) values(&#39;5&#39;,&#39;Tom2&#39;,&#39;21&#39;,&#39;2200&#39;);
insert into &#96;emp&#96; (&#96;id&#96;, &#96;name&#96;, &#96;age&#96;, &#96;salary&#96;) values(&#39;6&#39;,&#39;Jerry2&#39;,&#39;31&#39;,&#39;3300&#39;);
insert into &#96;emp&#96; (&#96;id&#96;, &#96;name&#96;, &#96;age&#96;, &#96;salary&#96;) values(&#39;7&#39;,&#39;Luci2&#39;,&#39;26&#39;,&#39;2700&#39;);
insert into &#96;emp&#96; (&#96;id&#96;, &#96;name&#96;, &#96;age&#96;, &#96;salary&#96;) values(&#39;8&#39;,&#39;Jay2&#39;,&#39;33&#39;,&#39;3500&#39;);
insert into &#96;emp&#96; (&#96;id&#96;, &#96;name&#96;, &#96;age&#96;, &#96;salary&#96;) values(&#39;9&#39;,&#39;Tom3&#39;,&#39;23&#39;,&#39;2400&#39;);
insert into &#96;emp&#96; (&#96;id&#96;, &#96;name&#96;, &#96;age&#96;, &#96;salary&#96;) values(&#39;10&#39;,&#39;Jerry3&#39;,&#39;32&#39;,&#39;3100&#39;);
insert into &#96;emp&#96; (&#96;id&#96;, &#96;name&#96;, &#96;age&#96;, &#96;salary&#96;) values(&#39;11&#39;,&#39;Luci3&#39;,&#39;26&#39;,&#39;2900&#39;);
insert into &#96;emp&#96; (&#96;id&#96;, &#96;name&#96;, &#96;age&#96;, &#96;salary&#96;) values(&#39;12&#39;,&#39;Jay3&#39;,&#39;37&#39;,&#39;4500&#39;);

create index idx_emp_age_salary on emp(age,salary);</code></pre></div>

<h4 id="5-3-2-两种排序方式"><a href="#5-3-2-两种排序方式" class="headerlink" title="5.3.2 两种排序方式"></a>5.3.2 两种排序方式</h4><ol>
<li><p>第一种是通过对返回数据进行排序，也就是通常说的<code>filesort</code>排序，所有不是通过索引直接返回排序结果的排序都叫 FileSort 排序。(单字段、多字段都是filesort)</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210526084236.png" srcset="/img/loading.gif"></p>
</li>
<li><p>第二种通过有序索引顺序扫描直接返回有序数据，这种情况即为 <code>using index</code>，不需要额外排序，操作效率高。（返回字段是覆盖索引）</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210526084341.png" srcset="/img/loading.gif"></p>
</li>
<li><p>多字段排序( <code>要么统一升序、统一降序，排序字段要和索引字段保持一致顺序</code> )</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210526084809.png" srcset="/img/loading.gif"></p>
</li>
</ol>
<p>了解了MySQL的排序方式，优化目标就清晰了：</p>
<ul>
<li>尽量减少额外的排序，通过索引直接返回有序数据。</li>
<li>where 条件和Order by 使用相同的索引，并且Order By 的顺序和索引顺序相同， 并且Order by 的字段都是升序，或者都是降序。</li>
<li>否则肯定需要额外的操作，这样就会出现FileSort。</li>
</ul>
<h4 id="5-3-3-Filesort-的优化"><a href="#5-3-3-Filesort-的优化" class="headerlink" title="5.3.3 Filesort 的优化"></a>5.3.3 Filesort 的优化</h4><p>通过创建合适的索引，能够减少 Filesort 的出现，但是在某些情况下，条件限制不能让Filesort消失，那就需要加快 Filesort的排序操作。对于Filesort ， MySQL 有两种排序算法：</p>
<p>1） 两次扫描算法 ：<code>MySQL4.1 之前</code>，使用该方式排序。首先根据条件取出排序字段和行指针信息，然后在排序区 sort buffer 中排序，如果sort buffer不够，则在临时表 temporary table 中存储排序结果。完成排序之后，再根据行指针回表读取记录，该操作可能会 <code>导致大量随机I/O操作</code>。</p>
<p>2）一次扫描算法：一次性取出满足条件的所有字段，然后在排序区 sort buffer 中排序后直接输出结果集。排序时 <code>内存开销较大 </code>，但是排序效率比两次扫描算法要高。</p>
<p>MySQL 通过比较系统变量 <code>max_length_for_sort_data</code> 的大小和<code>Query语句取出的字段总大小</code>， 来判定是否那种排序算法;</p>
<ul>
<li><p>如果max_length_for_sort_data 更大，那么使用第二种优化之后的算法；</p>
</li>
<li><p>否则使用第一种。</p>
</li>
<li><p>可以适当提高 <code>sort_buffer_size</code> 和 <code>max_length_for_sort_data</code> 系统变量，来增大排序区的大小，提高排序的效率。</p>
</li>
</ul>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210526085153.png" srcset="/img/loading.gif"></p>
<h3 id="5-4-优化group-by-语句"><a href="#5-4-优化group-by-语句" class="headerlink" title="5.4 优化group by 语句"></a>5.4 优化group by 语句</h3><p>由于GROUP BY 实际上也同样会进行排序操作，而且与ORDER BY 相比，GROUP BY 主要只是多了排序之后的分组操作。当然，如果在分组的时候还使用了其他的一些<code>聚合函数</code>，那么还需要一些聚合函数的计算。所以，在GROUP BY 的实现过程中，与 ORDER BY 一样也可以利用到索引。</p>
<p>如果查询包含 group by 但是用户想要避免排序结果的消耗， 则可以执行order by null 禁止排序。如下 ：</p>
<div class="hljs"><pre><code class="hljs mysql">drop index idx_emp_age_salary on emp;

explain select age,count(*) from emp group by age;</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210526085359.png" srcset="/img/loading.gif"></p>
<p>优化后</p>
<div class="hljs"><pre><code class="hljs mysql">explain select age,count(*) from emp group by age order by null;</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210526085418.png" srcset="/img/loading.gif"></p>
<p>从上面的例子可以看出，第一个SQL语句需要进行”filesort”，而第二个SQL由于order by null 不需要进行 “filesort”， 而上文提过Filesort往往非常耗费时间。</p>
<p>创建索引 ：</p>
<div class="hljs"><pre><code class="hljs mysql">create index idx_emp_age_salary on emp(age,salary)；</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210526085439.png" srcset="/img/loading.gif"></p>
<h3 id="5-5-优化嵌套查询"><a href="#5-5-优化嵌套查询" class="headerlink" title="5.5 优化嵌套查询"></a>5.5 优化嵌套查询</h3><p>Mysql4.1版本之后，开始支持SQL的子查询。这个技术可以使用SELECT语句来创建一个单列的查询结果，然后把这个结果作为过滤条件用在另一个查询中。使用子查询可以一次性的完成很多逻辑上需要多个步骤才能完成的SQL操作，同时也可以避免事务或者表锁死，并且写起来也很容易。但是，有些情况下，子查询是可以被更高效的连接（JOIN）替代。</p>
<p>示例 ，查找有角色的所有的用户信息 :</p>
<div class="hljs"><pre><code class="hljs mysql">explain select * from t_user where id in (select user_id from user_role );</code></pre></div>

<p>执行计划为 :</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210526085612.png" srcset="/img/loading.gif"></p>
<p>优化后 :</p>
<div class="hljs"><pre><code class="hljs mysql">explain select * from t_user u , user_role ur where u.id &#x3D; ur.user_id;</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210526085642.png" srcset="/img/loading.gif"></p>
<p>连接(Join)查询之所以更有效率一些 ，是因为MySQL<code>不需要在内存中创建临时表</code>来完成这个逻辑上需要两个步骤的查询工作。</p>
<h3 id="5-6-优化OR条件"><a href="#5-6-优化OR条件" class="headerlink" title="5.6 优化OR条件"></a>5.6 优化OR条件</h3><p>对于包含OR的查询子句，如果要利用索引，则OR之间的每个条件列都必须用到索引 ， 而且不能使用到复合索引； 如果没有索引，则应该考虑增加索引。</p>
<p>获取 emp 表中的所有的索引 ：</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210526085728.png" srcset="/img/loading.gif"></p>
<p>示例 ：</p>
<div class="hljs"><pre><code class="hljs mysql">explain select * from emp where id &#x3D; 1 or age &#x3D; 30;</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210526085753.png" srcset="/img/loading.gif"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210526085830.png" srcset="/img/loading.gif"></p>
<p>建议使用 union 替换 or ：</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210526085858.png" srcset="/img/loading.gif"></p>
<p>我们来比较下重要指标，发现主要差别是 <code>type 和 ref</code> 这两项</p>
<p>type 显示的是访问类型，是较为重要的一个指标，结果值从好到坏依次是：</p>
<div class="hljs"><pre><code class="hljs pgsql"><span class="hljs-keyword">system</span> &gt; const &gt; eq_ref &gt; <span class="hljs-keyword">ref</span> &gt; fulltext &gt; ref_or_null  &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; <span class="hljs-keyword">index</span> &gt; <span class="hljs-keyword">ALL</span></code></pre></div>

<ul>
<li><p>UNION 语句的 type 值为 ref，OR 语句的 type 值为 range，可以看到这是一个很明显的差距</p>
</li>
<li><p>UNION 语句的 ref 值为 const，OR 语句的 type 值为 null，const 表示是常量值引用，非常快</p>
</li>
</ul>
<p>这两项的差距就说明了 UNION 要优于 OR 。</p>
<h3 id="5-7-优化分页查询"><a href="#5-7-优化分页查询" class="headerlink" title="5.7 优化分页查询"></a>5.7 优化分页查询</h3><p>一般分页查询时，通过创建覆盖索引能够比较好地提高性能。一个常见又非常头疼的问题就是 limit 2000000,10 ，此时需要MySQL排序前2000010 记录，仅仅返回2000000 - 2000010 的记录，其他记录丢弃，查询排序的代价非常大 。</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210526090038.png" srcset="/img/loading.gif"></p>
<h4 id="5-7-1-优化思路一"><a href="#5-7-1-优化思路一" class="headerlink" title="5.7.1 优化思路一"></a>5.7.1 优化思路一</h4><p>在索引上完成排序分页操作，最后根据主键关联回原表查询所需要的其他列内容。</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210526090206.png" srcset="/img/loading.gif"></p>
<h4 id="5-7-2-优化思路二"><a href="#5-7-2-优化思路二" class="headerlink" title="5.7.2 优化思路二"></a>5.7.2 优化思路二</h4><p>该方案适用于主键自增的表，可以把Limit 查询转换成某个位置的查询 。</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210526090226.png" srcset="/img/loading.gif"></p>
<h3 id="5-8-使用SQL提示"><a href="#5-8-使用SQL提示" class="headerlink" title="5.8 使用SQL提示"></a>5.8 使用SQL提示</h3><p>SQL提示，是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优化操作的目的。</p>
<h4 id="5-8-1-USE-INDEX"><a href="#5-8-1-USE-INDEX" class="headerlink" title="5.8.1 USE INDEX"></a>5.8.1 USE INDEX</h4><p>在查询语句中表名的后面，添加 use index 来提供希望MySQL去参考的索引列表，就可以让MySQL不再考虑其他可用的索引。</p>
<div class="hljs"><pre><code class="hljs mysql">create index idx_seller_name on tb_seller(name);</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210526090328.png" srcset="/img/loading.gif"></p>
<h4 id="5-8-2-IGNORE-INDEX"><a href="#5-8-2-IGNORE-INDEX" class="headerlink" title="5.8.2 IGNORE INDEX"></a>5.8.2 IGNORE INDEX</h4><p>如果用户只是单纯的想让MySQL忽略一个或者多个索引，则可以使用 ignore index 作为 hint 。</p>
<div class="hljs"><pre><code class="hljs mysql">explain select * from tb_seller ignore index(idx_seller_name) where name &#x3D; &#39;小米科技&#39;;</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210526090358.png" srcset="/img/loading.gif"></p>
<h4 id="5-8-3-FORCE-INDEX"><a href="#5-8-3-FORCE-INDEX" class="headerlink" title="5.8.3 FORCE INDEX"></a>5.8.3 FORCE INDEX</h4><p>为强制MySQL使用一个特定的索引，可在查询中使用 force index 作为hint 。</p>
<div class="hljs"><pre><code class="hljs mysql">create index idx_seller_address on tb_seller(address);</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210526090438.png" srcset="/img/loading.gif"></p>
<h1 id="Mysql高级-day03"><a href="#Mysql高级-day03" class="headerlink" title="Mysql高级-day03"></a>Mysql高级-day03</h1><h2 id="1-应用优化"><a href="#1-应用优化" class="headerlink" title="1. 应用优化"></a>1. 应用优化</h2><p>在实际生产环境中，由于数据库本身的性能局限，就必须要对前台的应用进行一些优化，来降低数据库的访问压力。</p>
<h3 id="1-1-使用连接池"><a href="#1-1-使用连接池" class="headerlink" title="1.1 使用连接池"></a>1.1 使用连接池</h3><p>对于访问数据库来说，建立连接的代价是比较昂贵的，因为我们频繁的创建关闭连接，是比较耗费资源的，我们有必要建立 数据库连接池，以提高访问的性能。</p>
<h3 id="1-2-减少对MySQL的访问"><a href="#1-2-减少对MySQL的访问" class="headerlink" title="1.2 减少对MySQL的访问"></a>1.2 减少对MySQL的访问</h3><h4 id="1-2-1-避免对数据进行重复检索"><a href="#1-2-1-避免对数据进行重复检索" class="headerlink" title="1.2.1 避免对数据进行重复检索"></a>1.2.1 避免对数据进行重复检索</h4><p>在编写应用代码时，需要能够理清对数据库的访问逻辑。能够一次连接就获取到结果的，就不用两次连接，这样可以大大减少对数据库无用的重复请求。</p>
<p>比如 ，需要获取书籍的id 和name字段 ， 则查询如下：</p>
<div class="hljs"><pre><code class="hljs mysql">select id , name from tb_book;</code></pre></div>

<p>之后，在业务逻辑中有需要获取到书籍状态信息， 则查询如下：</p>
<div class="hljs"><pre><code class="hljs mysql">select id , status from tb_book;</code></pre></div>

<p>这样，就需要向数据库提交两次请求，数据库就要做两次查询操作。其实完全可以用一条SQL语句得到想要的结果。</p>
<div class="hljs"><pre><code class="hljs mysql">select id, name , status from tb_book;</code></pre></div>

<h4 id="1-2-2-增加cache层"><a href="#1-2-2-增加cache层" class="headerlink" title="1.2.2 增加cache层"></a>1.2.2 增加cache层</h4><p>在应用中，我们可以在应用中增加 <code>缓存层</code> 来达到减轻数据库负担的目的。缓存层有很多种，也有很多实现方式，只要能达到降低数据库的负担又能满足应用需求就可以。</p>
<p>因此可以部分数据从<code>数据库中抽取出来放到应用端以文本方式</code>存储， 或者使用<code>框架(Mybatis, Hibernate)提供的一级缓存/二级缓存</code>，或者使用<code>redis数据库</code>来缓存数据 。</p>
<h3 id="1-3-负载均衡"><a href="#1-3-负载均衡" class="headerlink" title="1.3 负载均衡"></a>1.3 负载均衡</h3><p>负载均衡是应用中使用非常普遍的一种优化方法，它的机制就是利用某种均衡算法，将固定的负载量分布到不同的服务器上， 以此来降低单台服务器的负载，达到优化的效果。</p>
<h4 id="1-3-1-利用MySQL复制分流查询"><a href="#1-3-1-利用MySQL复制分流查询" class="headerlink" title="1.3.1 利用MySQL复制分流查询"></a>1.3.1 利用MySQL复制分流查询</h4><p>通过MySQL的主从复制，实现读写分离，使增删改操作走主节点，查询操作走从节点，从而可以降低单台服务器的读写压力。</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210526090924.png" srcset="/img/loading.gif"></p>
<h4 id="1-3-2-采用分布式数据库架构"><a href="#1-3-2-采用分布式数据库架构" class="headerlink" title="1.3.2 采用分布式数据库架构"></a>1.3.2 采用分布式数据库架构</h4><p>分布式数据库架构适合大数据量、负载高的情况，它有良好的拓展性和高可用性。通过在多台服务器之间分布数据，可以实现在多台服务器之间的负载均衡，提高访问效率。</p>
<h2 id="2-Mysql中查询缓存优化"><a href="#2-Mysql中查询缓存优化" class="headerlink" title="2. Mysql中查询缓存优化"></a>2. Mysql中查询缓存优化</h2><h3 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h3><p>开启Mysql的查询缓存，当执行完全相同的SQL语句的时候，服务器就会直接从缓存中读取结果，<code>当数据被修改，之前的缓存会失效</code>，修改比较频繁的表不适合做查询缓存。</p>
<h3 id="2-2-操作流程"><a href="#2-2-操作流程" class="headerlink" title="2.2 操作流程"></a>2.2 操作流程</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210526091045.png" srcset="/img/loading.gif"></p>
<ol>
<li>客户端发送一条查询给服务器；</li>
<li>服务器先会检查查询缓存，如果命中了缓存，则立即返回存储在缓存中的结果。否则进入下一阶段；</li>
<li>服务器端进行SQL解析、预处理，再由优化器生成对应的执行计划；</li>
<li>MySQL根据优化器生成的执行计划，调用存储引擎的API来执行查询；</li>
<li>将结果返回给客户端。</li>
</ol>
<h3 id="2-3-查询缓存配置"><a href="#2-3-查询缓存配置" class="headerlink" title="2.3 查询缓存配置"></a>2.3 查询缓存配置</h3><ol>
<li>查看当前的MySQL数据库是否支持查询缓存：</li>
</ol>
<div class="hljs"><pre><code class="hljs mysql">SHOW VARIABLES LIKE &#39;have_query_cache&#39;;</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210526093959.png" srcset="/img/loading.gif"></p>
<ol start="2">
<li>查看当前MySQL是否开启了查询缓存 ：</li>
</ol>
<div class="hljs"><pre><code class="hljs mysql">SHOW VARIABLES LIKE &#39;query_cache_type&#39;;</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210526094134.png" srcset="/img/loading.gif"></p>
<ol start="3">
<li>查看查询缓存的占用大小 ：</li>
</ol>
<div class="hljs"><pre><code class="hljs mysql">SHOW VARIABLES LIKE &#39;query_cache_size&#39;;</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210526094201.png" srcset="/img/loading.gif"></p>
<p>单位为字节</p>
<ol start="4">
<li>查看查询缓存的状态变量：</li>
</ol>
<div class="hljs"><pre><code class="hljs mysql">SHOW STATUS LIKE &#39;Qcache%&#39;;</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210526094305.png" srcset="/img/loading.gif"></p>
<p>各个变量的含义如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>Qcache_free_blocks</td>
<td>查询缓存中的可用内存块数</td>
</tr>
<tr>
<td>Qcache_free_memory</td>
<td>查询缓存的可用内存量</td>
</tr>
<tr>
<td>Qcache_hits</td>
<td>查询缓存命中数</td>
</tr>
<tr>
<td>Qcache_inserts</td>
<td>添加到查询缓存的查询数</td>
</tr>
<tr>
<td>Qcache_lowmen_prunes</td>
<td>由于内存不足而从查询缓存中删除的查询数</td>
</tr>
<tr>
<td>Qcache_not_cached</td>
<td>非缓存查询的数量（由于 query_cache_type 设置而无法缓存或未缓存）</td>
</tr>
<tr>
<td>Qcache_queries_in_cache</td>
<td>查询缓存中注册的查询数</td>
</tr>
<tr>
<td>Qcache_total_blocks</td>
<td>查询缓存中的块总数</td>
</tr>
</tbody></table>
<h3 id="2-4-开启查询缓存"><a href="#2-4-开启查询缓存" class="headerlink" title="2.4 开启查询缓存"></a>2.4 开启查询缓存</h3><p>MySQL的查询缓存默认是关闭的，需要手动配置参数 <code>query_cache_type</code> ， 来开启查询缓存。query_cache_type 该参数的可取值有三个 ：</p>
<table>
<thead>
<tr>
<th>值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>OFF 或 0</td>
<td>查询缓存功能关闭</td>
</tr>
<tr>
<td>ON 或 1</td>
<td>查询缓存功能打开，SELECT的结果符合缓存条件即会缓存，否则，不予缓存，显式指定 SQL_NO_CACHE，不予缓存</td>
</tr>
<tr>
<td>DEMAND 或 2</td>
<td>查询缓存功能按需进行，显式指定 SQL_CACHE 的SELECT语句才会缓存；其它均不予缓存</td>
</tr>
</tbody></table>
<p>在 /usr/my.cnf (linux)配置中，增加以下配置 ：</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210526095134.png" srcset="/img/loading.gif"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210526095207.png" srcset="/img/loading.gif"></p>
<p>配置完毕之后，重启服务既可生效 ；</p>
<p>然后就可以在命令行执行SQL语句进行验证 ，执行一条比较耗时的SQL语句，然后再多执行几次，查看后面几次的执行时间；获取通过查看查询缓存的缓存命中数，来判定是否走查询缓存。</p>
<h3 id="2-5-查询缓存SELECT选项"><a href="#2-5-查询缓存SELECT选项" class="headerlink" title="2.5 查询缓存SELECT选项"></a>2.5 查询缓存SELECT选项</h3><p>可以在SELECT语句中指定两个与查询缓存相关的选项 ：</p>
<p>SQL_CACHE : 如果查询结果是可缓存的，并且 query_cache_type 系统变量的值为ON或 DEMAND ，则缓存查询结果 。</p>
<p>SQL_NO_CACHE : 服务器不使用查询缓存。它既不检查查询缓存，也不检查结果是否已缓存，也不缓存查询结果。</p>
<p>例子：</p>
<div class="hljs"><pre><code class="hljs mysql">SELECT SQL_CACHE id, name FROM customer;
SELECT SQL_NO_CACHE id, name FROM customer;</code></pre></div>

<h3 id="2-6-查询缓存失效的情况"><a href="#2-6-查询缓存失效的情况" class="headerlink" title="2.6 查询缓存失效的情况"></a>2.6 查询缓存失效的情况</h3><p>1） SQL 语句不一致的情况， 要想命中查询缓存，查询的SQL语句必须一致。</p>
<div class="hljs"><pre><code class="hljs mysql">SQL1 : select count(*) from tb_item;
SQL2 : Select count(*) from tb_item;</code></pre></div>

<p>2） 当查询语句中有一些不确定的时，则不会缓存。如 ： now() , current_date() , curdate() , curtime() , rand() , uuid() , user() , database() 。</p>
<div class="hljs"><pre><code class="hljs mysql">SQL1 : select * from tb_item where updatetime &lt; now() limit 1;
SQL2 : select user();
SQL3 : select database();</code></pre></div>

<p>3） 不使用任何表查询语句。</p>
<div class="hljs"><pre><code class="hljs mysql">select &#39;A&#39;;</code></pre></div>

<p>4） 查询 mysql， information_schema或 performance_schema 数据库中的表时，不会走查询缓存。</p>
<div class="hljs"><pre><code class="hljs mysql">select * from information_schema.engines;</code></pre></div>

<p>5） 在 <code>存储的函数，触发器或事件的主体内</code> 执行的查询。</p>
<p>6） 如果表更改，则使用该表的所有高速缓存查询都将变为无效并从高速缓存中删除。这包括使用<code>MERGE</code>映射到已更改表的表的查询。一个表可以被许多类型的语句，如被改变 INSERT， UPDATE， DELETE， TRUNCATE TABLE， ALTER TABLE， DROP TABLE，或 DROP DATABASE 。</p>
<h2 id="3-Mysql内存管理及优化"><a href="#3-Mysql内存管理及优化" class="headerlink" title="3. Mysql内存管理及优化"></a>3. Mysql内存管理及优化</h2><h3 id="3-1-内存优化原则"><a href="#3-1-内存优化原则" class="headerlink" title="3.1 内存优化原则"></a>3.1 内存优化原则</h3><p>1） 将尽量多的内存分配给MySQL做缓存，但要给操作系统和其他程序预留足够内存。</p>
<p>2） <code>MyISAM 存储引擎的数据文件读取依赖于操作系统自身的IO缓存</code>，因此，如果有MyISAM表，就要预留更多的内存给操作系统做IO缓存。</p>
<p>3） 排序区、连接区等缓存是分配给每个数据库会话（session）专用的，其默认值的设置要根据最大连接数合理分配，如果设置太大，不但浪费资源，而且在并发连接较高时会导致物理内存耗尽。</p>
<h3 id="3-2-MyISAM-内存优化"><a href="#3-2-MyISAM-内存优化" class="headerlink" title="3.2 MyISAM 内存优化"></a>3.2 MyISAM 内存优化</h3><p>myisam存储引擎使用 <code>key_buffer 缓存索引块</code>，加速myisam索引的读写速度。对于myisam表的数据块，mysql没有特别的缓存机制，完全依赖于操作系统的IO缓存。(缓存索引，数据依赖OS的IO缓存)</p>
<h4 id="key-buffer-size"><a href="#key-buffer-size" class="headerlink" title="key_buffer_size"></a>key_buffer_size</h4><p>key_buffer_size决定MyISAM<code>索引块缓存区</code>的大小，直接影响到MyISAM表的存取效率。可以在MySQL参数文件中设置key_buffer_size的值，对于一般MyISAM数据库，建议至少将1/4可用内存分配给key_buffer_size。</p>
<p>在/usr/my.cnf 中做如下配置：</p>
<div class="hljs"><pre><code class="hljs ini"><span class="hljs-attr">key_buffer_size</span>=<span class="hljs-number">512</span>M</code></pre></div>

<h4 id="read-buffer-size"><a href="#read-buffer-size" class="headerlink" title="read_buffer_size"></a>read_buffer_size</h4><p>如果需要经常顺序扫描myisam表，可以通过增大read_buffer_size的值来改善性能。但需要注意的是read_buffer_size是每个session独占的，如果默认值设置太大，就会造成内存浪费。</p>
<h4 id="read-rnd-buffer-size"><a href="#read-rnd-buffer-size" class="headerlink" title="read_rnd_buffer_size"></a>read_rnd_buffer_size</h4><p>对于需要<code>做排序</code>的myisam表的查询，如带有order by子句的sql，适当增加 read_rnd_buffer_size 的值，可以改善此类的sql性能。但需要注意的是 read_rnd_buffer_size 是<code>每个session独占的</code>，如果默认值设置太大，就会造成内存浪费。</p>
<h3 id="3-3-InnoDB-内存优化"><a href="#3-3-InnoDB-内存优化" class="headerlink" title="3.3 InnoDB 内存优化"></a>3.3 InnoDB 内存优化</h3><p>innodb用一块内存区做IO缓存池，该缓存池<code>不仅用来缓存innodb的索引块</code>，<code>而且也用来缓存innodb的数据块</code>。</p>
<h4 id="innodb-buffer-pool-size"><a href="#innodb-buffer-pool-size" class="headerlink" title="innodb_buffer_pool_size"></a>innodb_buffer_pool_size</h4><p>该变量决定了 innodb 存储引擎表<code>数据和索引数据</code>的最大缓存区大小。在保证操作系统及其他程序有足够内存可用的情况下，innodb_buffer_pool_size 的值越大，缓存命中率越高，访问InnoDB表需要的磁盘I/O 就越少，性能也就越高。</p>
<div class="hljs"><pre><code class="hljs ini"><span class="hljs-attr">innodb_buffer_pool_size</span>=<span class="hljs-number">512</span>M</code></pre></div>

<h4 id="innodb-log-buffer-size"><a href="#innodb-log-buffer-size" class="headerlink" title="innodb_log_buffer_size"></a>innodb_log_buffer_size</h4><p>决定了innodb重做<code>日志缓存的大小</code>，对于可能产生大量更新记录的大事务，增加innodb_log_buffer_size的大小，可以避免innodb在事务提交前就执行不必要的日志写入磁盘操作。</p>
<div class="hljs"><pre><code class="hljs ini"><span class="hljs-attr">innodb_log_buffer_size</span>=<span class="hljs-number">10</span>M</code></pre></div>

<h2 id="4-Mysql并发参数调整"><a href="#4-Mysql并发参数调整" class="headerlink" title="4. Mysql并发参数调整"></a>4. Mysql并发参数调整</h2><p>从实现上来说，MySQL Server 是多线程结构，包括 <code>后台线程</code>和 <code>客户服务线程</code>。多线程可以有效利用服务器资源，提高数据库的并发性能。在Mysql中，控制并发连接和线程的主要参数包括 max_connections、back_log、thread_cache_size、table_open_cahce。</p>
<h3 id="4-1-max-connections"><a href="#4-1-max-connections" class="headerlink" title="4.1 max_connections"></a>4.1 max_connections</h3><p>采用max_connections 控制允许连接到 <code>MySQL数据库的最大数量</code> ，默认值是 151。如果状态变量 connection_errors_max_connections 不为零，并且一直增长，则说明不断有连接请求因数据库连接数已达到允许最大值而失败，这是可以考虑增大max_connections 的值。(没有则等待)</p>
<p>Mysql 最大可支持的连接数，取决于很多因素，包括给定操作系统平台的线程库的质量、内存大小、每个连接的负荷、CPU的处理速度，期望的响应时间等。在Linux 平台下，性能好的服务器，支持 500-1000 个连接不是难事，需要根据服务器性能进行评估设定。</p>
<h3 id="4-2-back-log"><a href="#4-2-back-log" class="headerlink" title="4.2 back_log"></a>4.2 back_log</h3><p>back_log 参数控制MySQL监听TCP端口时设置的积压请求栈大小。如果MySql的连接数达到max_connections时，新来的请求将会被存在 <strong>堆栈</strong> 中，以等待某一连接释放资源，该堆栈的数量即back_log，如果等待连接的数量超过back_log，将不被授予连接资源，将会报错。5.6.6 版本之前默认值为 50 ， 之后的版本默认为 50 + （max_connections / 5）， 但最大不超过900。</p>
<p>如果需要数据库在较短的时间内处理大量连接请求， 可以考虑适当增大back_log 的值。</p>
<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210526101930.png" srcset="/img/loading.gif" style="zoom:50%;" />

<h3 id="4-3-table-open-cache"><a href="#4-3-table-open-cache" class="headerlink" title="4.3 table_open_cache"></a>4.3 table_open_cache</h3><p>(针对所有的线程)该参数用来控制所有SQL语句执行线程可打开表缓存的数量， 而在执行SQL语句时，每一个SQL执行线程至少要打开 1 个表缓存。该参数的值应该根据设置的最大连接数 max_connections 以及每个连接执行关联查询中涉及的表的最大数量来设定 ：</p>
<p> max_connections x N ；</p>
<h3 id="4-4-thread-cache-size"><a href="#4-4-thread-cache-size" class="headerlink" title="4.4 thread_cache_size"></a>4.4 thread_cache_size</h3><p>为了加快连接数据库的速度，MySQL 会缓存一定数量的客户服务线程以备重用，通过参数 thread_cache_size 可控制 MySQL 缓存客户服务线程的数量。</p>
<h3 id="4-5-innodb-lock-wait-timeout"><a href="#4-5-innodb-lock-wait-timeout" class="headerlink" title="4.5 innodb_lock_wait_timeout"></a>4.5 innodb_lock_wait_timeout</h3><p>该参数是用来设置InnoDB 事务等待行锁的时间，默认值是50ms ， 可以根据需要进行动态设置。对于需要快速反馈的业务系统来说，可以将行锁的等待时间调小，以避免事务长时间挂起； 对于后台运行的批量处理程序来说， 可以将行锁的等待时间调大， 以避免发生大的回滚操作。</p>
<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210526102224.png" srcset="/img/loading.gif" style="zoom:50%;" />

<h2 id="5-Mysql锁问题"><a href="#5-Mysql锁问题" class="headerlink" title="5. Mysql锁问题"></a>5. Mysql锁问题</h2><h3 id="5-1-锁概述"><a href="#5-1-锁概述" class="headerlink" title="5.1 锁概述"></a>5.1 锁概述</h3><p>锁是计算机协调多个进程或线程并发访问某一资源的机制（避免争抢）。</p>
<p>在数据库中，除传统的计算资源（如 CPU、RAM、I/O 等）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。</p>
<h3 id="5-2-锁分类"><a href="#5-2-锁分类" class="headerlink" title="5.2 锁分类"></a>5.2 锁分类</h3><p>从对 <code>数据操作的粒度</code> 分 ：</p>
<p>1） 表锁：操作时，会<code>锁定整个表</code>。</p>
<p>2） 行锁：操作时，会<code>锁定当前操作行</code>。</p>
<p>从对数据操作的类型分：</p>
<p>1） 读锁（共享锁）：针对同一份数据，多个读操作可以同时进行而不会互相影响。</p>
<p>2） 写锁（排它锁）：当前操作没有完成之前，它会阻断其他写锁和读锁。</p>
<h3 id="5-3-Mysql-锁"><a href="#5-3-Mysql-锁" class="headerlink" title="5.3 Mysql 锁"></a>5.3 Mysql 锁</h3><p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000014071758#articleHeader3">锁</a></p>
<p>相对其他数据库而言，MySQL的锁机制比较简单，其最显著的特点是不同的存储引擎支持不同的锁机制。下表中罗列出了各存储引擎对锁的支持情况：</p>
<table>
<thead>
<tr>
<th>存储引擎</th>
<th>表级锁</th>
<th>行级锁</th>
<th>页面锁</th>
</tr>
</thead>
<tbody><tr>
<td>MyISAM</td>
<td>支持</td>
<td>不支持</td>
<td>不支持</td>
</tr>
<tr>
<td>InnoDB</td>
<td>支持</td>
<td>==支持==</td>
<td>不支持</td>
</tr>
<tr>
<td>MEMORY</td>
<td>支持</td>
<td>不支持</td>
<td>不支持</td>
</tr>
<tr>
<td>BDB</td>
<td>支持</td>
<td>不支持</td>
<td>支持</td>
</tr>
</tbody></table>
<p>MySQL这3种锁的特性可大致归纳如下 ：</p>
<table>
<thead>
<tr>
<th>锁类型</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>表级锁</td>
<td>偏向MyISAM 存储引擎，开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。</td>
</tr>
<tr>
<td>行级锁</td>
<td>偏向InnoDB 存储引擎，开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。</td>
</tr>
<tr>
<td>页面锁</td>
<td>开销和加锁时间界于表锁和行锁之间；<code>会出现死锁</code>；锁定粒度界于表锁和行锁之间，并发度一般。</td>
</tr>
</tbody></table>
<p>从上述特点可见，很难笼统地说哪种锁更好，只能就具体应用的特点来说哪种锁更合适！仅从锁的角度来说：</p>
<ul>
<li>表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用，如Web 应用；</li>
<li>而行级锁则更适合于有大量按索引条件并发更新少量不同数据，同时又有并查询的应用，如一些在线事务处理（OLTP）系统。</li>
</ul>
<h3 id="5-2-MyISAM-表锁"><a href="#5-2-MyISAM-表锁" class="headerlink" title="5.2 MyISAM 表锁"></a>5.2 MyISAM 表锁</h3><p>MyISAM 存储引擎只支持表锁，这也是MySQL开始几个版本中唯一支持的锁类型。</p>
<h4 id="5-2-1-如何加表锁"><a href="#5-2-1-如何加表锁" class="headerlink" title="5.2.1 如何加表锁"></a>5.2.1 如何加表锁</h4><ul>
<li>MyISAM 在执行查询语句（SELECT）前，会自动给涉及的所有表加 <code>读锁</code> ，</li>
<li>在执行更新操作（UPDATE、DELETE、INSERT 等）前，会自动给涉及的表加 <code>写锁</code> ，</li>
<li>这个过程并不需要用户干预，因此，用户一般不需要直接用 <code>LOCK TABLE 命令</code> 给 MyISAM 表<code>显式加锁</code>。</li>
</ul>
<p>显示加表锁语法：</p>
<div class="hljs"><pre><code class="hljs mysql">加读锁 ： lock table table_name read;

加写锁 ： lock table table_name write；</code></pre></div>

<h4 id="5-2-2-读锁案例"><a href="#5-2-2-读锁案例" class="headerlink" title="5.2.2 读锁案例"></a>5.2.2 读锁案例</h4><p>准备环境</p>
<div class="hljs"><pre><code class="hljs mysql">create database demo_03 default charset&#x3D;utf8mb4;

use demo_03;

CREATE TABLE &#96;tb_book&#96; (
  &#96;id&#96; INT(11) auto_increment,
  &#96;name&#96; VARCHAR(50) DEFAULT NULL,
  &#96;publish_time&#96; DATE DEFAULT NULL,
  &#96;status&#96; CHAR(1) DEFAULT NULL,
  PRIMARY KEY (&#96;id&#96;)
) ENGINE&#x3D;myisam DEFAULT CHARSET&#x3D;utf8 ;

INSERT INTO tb_book (id, name, publish_time, status) VALUES(NULL,&#39;java编程思想&#39;,&#39;2088-08-01&#39;,&#39;1&#39;);
INSERT INTO tb_book (id, name, publish_time, status) VALUES(NULL,&#39;solr编程思想&#39;,&#39;2088-08-08&#39;,&#39;0&#39;);



CREATE TABLE &#96;tb_user&#96; (
  &#96;id&#96; INT(11) auto_increment,
  &#96;name&#96; VARCHAR(50) DEFAULT NULL,
  PRIMARY KEY (&#96;id&#96;)
) ENGINE&#x3D;myisam DEFAULT CHARSET&#x3D;utf8 ;

INSERT INTO tb_user (id, name) VALUES(NULL,&#39;令狐冲&#39;);
INSERT INTO tb_user (id, name) VALUES(NULL,&#39;田伯光&#39;);</code></pre></div>

<ul>
<li>客户端 一 ：</li>
</ul>
<p>1）获得tb_book 表的读锁</p>
<div class="hljs"><pre><code class="hljs mysql">lock table tb_book read;</code></pre></div>

<p>2） 客户端二 执行查询操作</p>
<div class="hljs"><pre><code class="hljs mysql">select * from tb_book;</code></pre></div>

<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210526103155.png" srcset="/img/loading.gif" style="zoom:50%;" />

<p>3）客户端一查询别的未上锁的表</p>
<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210526103413.png" srcset="/img/loading.gif" style="zoom:50%;" />

<p>4）客户端二查询未上锁的表</p>
<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210526103432.png" srcset="/img/loading.gif" style="zoom:50%;" />

<p>5）客户端一执行插入操作</p>
<div class="hljs"><pre><code class="hljs mysql">insert into tb_book values(null,&#39;Mysql高级&#39;,&#39;2088-01-01&#39;,&#39;1&#39;);</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210526103551.png" srcset="/img/loading.gif"></p>
<p>执行插入， 直接报错 ， 由于当前tb_book 获得的是 读锁， 不能执行更新操作。</p>
<p>6）客户端二执行插入操作</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210526103743.png" srcset="/img/loading.gif"></p>
<p>当在客户端一中释放锁指令 unlock tables 后 ， 客户端二中的 inesrt 语句 ， 立即执行 ；</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210526103826.png" srcset="/img/loading.gif"></p>
<h4 id="5-2-3-写锁案例"><a href="#5-2-3-写锁案例" class="headerlink" title="5.2.3 写锁案例"></a>5.2.3 写锁案例</h4><p>客户端 一 :</p>
<p>1）获得tb_book 表的写锁</p>
<div class="hljs"><pre><code class="hljs mysql">lock table tb_book write ;</code></pre></div>

<p>2）执行查询操作</p>
<div class="hljs"><pre><code class="hljs mysql">select * from tb_book ;</code></pre></div>

<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210526103952.png" srcset="/img/loading.gif" style="zoom:50%;" />

<p>查询操作执行成功；</p>
<p>客户端 二 :</p>
<p>3）执行查询操作</p>
<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210526104055.png" srcset="/img/loading.gif" style="zoom:50%;" />

<p>4）客户端一释放锁后立即执行</p>
<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210526104155.png" srcset="/img/loading.gif" style="zoom:50%;" />

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210526104554.png" srcset="/img/loading.gif"></p>
<h4 id="5-2-4-结论"><a href="#5-2-4-结论" class="headerlink" title="5.2.4 结论"></a>5.2.4 结论</h4><p>锁模式的相互兼容性如表中所示：</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210526104254.png" srcset="/img/loading.gif"></p>
<p>由上表可见：</p>
<p> 1） 对MyISAM 表的 <code>读操作</code>， <strong>不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求</strong> ；</p>
<p> 2） 对MyISAM 表的 <code>写操作</code>， <strong>则会阻塞其他用户对同一表的读和写操作</strong> ；</p>
<p> 简而言之，就是读锁会阻塞写，但是不会阻塞读。而写锁，则既会阻塞读，又会阻塞写。</p>
<p>此外，MyISAM 的读写锁调度是 <strong>写优先</strong> ，这也是MyISAM不适合做写为主的表的存储引擎的原因。因为写锁后，其他线程不能做任何操作，大量的更新会使查询很难得到锁，从而造成永远阻塞。</p>
<h4 id="5-2-5-查看锁的争用情况"><a href="#5-2-5-查看锁的争用情况" class="headerlink" title="5.2.5 查看锁的争用情况"></a>5.2.5 查看锁的争用情况</h4><div class="hljs"><pre><code class="hljs mysql">show open tables;</code></pre></div>

<p>In_user : 表当前被查询使用的次数。如果该数为零，则表是打开的，但是当前没有被使用。</p>
<p>Name_locked：表名称是否被锁定。名称锁定用于取消表或对表进行重命名等操作。</p>
<div class="hljs"><pre><code class="hljs mysql">show status like &#39;Table_locks%&#39;;</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210526105236.png" srcset="/img/loading.gif"></p>
<p>Table_locks_immediate ： 指的是能够立即获得表级锁的次数，每立即获取锁，值加1。</p>
<p>Table_locks_waited ： 指的是不能立即获取表级锁而需要等待的次数，每等待一次，该值加1，此值高说明存在着较为严重的表级锁争用情况。</p>
<h3 id="5-3-InnoDB-行锁"><a href="#5-3-InnoDB-行锁" class="headerlink" title="5.3 InnoDB 行锁"></a>5.3 InnoDB 行锁</h3><h4 id="5-3-1-行锁介绍"><a href="#5-3-1-行锁介绍" class="headerlink" title="5.3.1 行锁介绍"></a>5.3.1 行锁介绍</h4><p>行锁特点 ：</p>
<ul>
<li>偏向InnoDB 存储引擎，开销大，加锁慢；</li>
<li>会出现死锁；</li>
<li>锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</li>
</ul>
<p>InnoDB 与 MyISAM 的最大不同有两点：<code>一是支持事务；二是 采用了行级锁</code>。</p>
<h4 id="5-3-2-背景知识"><a href="#5-3-2-背景知识" class="headerlink" title="5.3.2 背景知识"></a>5.3.2 背景知识</h4><p> <strong>事务及其ACID属性</strong> </p>
<blockquote>
<p>事务是由一组SQL语句组成的逻辑处理单元。</p>
</blockquote>
<p>事务具有以下4个特性，简称为事务ACID属性。</p>
<table>
<thead>
<tr>
<th>ACID属性</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>原子性（Atomicity）</td>
<td>事务是一个原子操作单元，其对数据的修改，要么全部成功，要么全部失败。</td>
</tr>
<tr>
<td>一致性（Consistent）</td>
<td>在事务开始和完成时，数据都必须保持一致状态。</td>
</tr>
<tr>
<td>隔离性（Isolation）</td>
<td>数据库系统提供一定的隔离机制，保证事务在不受外部<code>并发</code>操作影响的 “独立” 环境下运行。</td>
</tr>
<tr>
<td>持久性（Durable）</td>
<td>事务完成之后，对于数据的修改是永久的。</td>
</tr>
</tbody></table>
<p> <strong>并发事务处理带来的问题</strong> </p>
<table>
<thead>
<tr>
<th>问题</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>丢失更新（Lost Update）</td>
<td>当两个或多个事务选择同一行，最初的事务修改的值，会被后面的事务修改的值<code>覆盖</code>。</td>
</tr>
<tr>
<td>脏读（Dirty Reads）</td>
<td>当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。</td>
</tr>
<tr>
<td>不可重复读（Non-Repeatable Reads）</td>
<td>一个事务在读取某些数据后的某个时间，再次读取以前读过的数据，却发现和以前读出的数据不一致。</td>
</tr>
<tr>
<td>幻读（Phantom Reads）</td>
<td>一个事务按照相同的查询条件重新读取以前查询过的数据，却发现其他事务插入了满足其查询条件的新数据。</td>
</tr>
</tbody></table>
<p> <strong>事务隔离级别</strong> </p>
<p>为了解决上述提到的事务并发问题，数据库提供一定的<code>事务隔离机制</code>来解决这个问题。数据库的事务隔离越严格，并发副作用越小，但付出的代价也就越大，因为事务隔离实质上就是使用事务在一定程度上“串行化” 进行，这显然与“并发” 是矛盾的。</p>
<p>数据库的隔离级别有4个，由低到高依次为Read uncommitted、Read committed、Repeatable read、Serializable，这四个级别可以逐个解决脏写、脏读、不可重复读、幻读这几类问题。</p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>丢失更新</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>Read uncommitted</td>
<td>×</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>Read committed</td>
<td>×</td>
<td>×</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>Repeatable read（默认）</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td>Serializable</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
</tbody></table>
<p>备注 ： √ 代表可能出现 ， × 代表不会出现 。</p>
<p>Mysql 的数据库的默认隔离级别为 <code>Repeatable read </code>， 查看方式：</p>
<div class="hljs"><pre><code class="hljs mysql">show variables like &#39;tx_isolation&#39;;</code></pre></div>

<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210527101843.png" srcset="/img/loading.gif" style="zoom:50%;" />

<h4 id="5-3-3-InnoDB-的行锁模式"><a href="#5-3-3-InnoDB-的行锁模式" class="headerlink" title="5.3.3 InnoDB 的行锁模式"></a>5.3.3 InnoDB 的行锁模式</h4><p>InnoDB 实现了以下两种类型的行锁。</p>
<ul>
<li> <strong>共享锁</strong> （S）：又称为 <code>读锁</code> ，简称S锁，共享锁就是多个事务对于同一数据可以共享一把锁，都能访问到数据，但是只能读不能修改。</li>
<li> <strong>排他锁</strong> （X）：又称为 <code>写锁</code>，简称X锁，排他锁就是不能与其他锁并存，如一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的其他锁，包括共享锁和排他锁，但是获取排他锁的事务是可以对数据就行读取和修改。</li>
</ul>
<ol>
<li><p>对于  <code>UPDATE、DELETE和INSERT</code> 语句，InnoDB会自动给涉及数据集加 <code>排他锁（X)</code>；</p>
</li>
<li><p>对于普通<code>SELECT</code>语句，InnoDB<code>不会加任何锁</code>；</p>
</li>
</ol>
<p>可以通过以下语句显示给记录集加共享锁或排他锁 。</p>
<div class="hljs"><pre><code class="hljs mysql">共享锁（S）：SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE

排他锁（X) ：SELECT * FROM table_name WHERE ... FOR UPDATE</code></pre></div>

<h4 id="5-3-4-案例准备工作"><a href="#5-3-4-案例准备工作" class="headerlink" title="5.3.4 案例准备工作"></a>5.3.4 案例准备工作</h4><div class="hljs"><pre><code class="hljs mysql">create table test_innodb_lock(
	id int(11),
	name varchar(16),
	sex varchar(1)
)engine &#x3D; innodb default charset&#x3D;utf8;

insert into test_innodb_lock values(1,&#39;100&#39;,&#39;1&#39;);
insert into test_innodb_lock values(3,&#39;3&#39;,&#39;1&#39;);
insert into test_innodb_lock values(4,&#39;400&#39;,&#39;0&#39;);
insert into test_innodb_lock values(5,&#39;500&#39;,&#39;1&#39;);
insert into test_innodb_lock values(6,&#39;600&#39;,&#39;0&#39;);
insert into test_innodb_lock values(7,&#39;700&#39;,&#39;0&#39;);
insert into test_innodb_lock values(8,&#39;800&#39;,&#39;1&#39;);
insert into test_innodb_lock values(9,&#39;900&#39;,&#39;1&#39;);
insert into test_innodb_lock values(1,&#39;200&#39;,&#39;0&#39;);

create index idx_test_innodb_lock_id on test_innodb_lock(id);
create index idx_test_innodb_lock_name on test_innodb_lock(name);</code></pre></div>

<h4 id="5-3-5-行锁基本演示"><a href="#5-3-5-行锁基本演示" class="headerlink" title="5.3.5 行锁基本演示"></a>5.3.5 行锁基本演示</h4><table>
<thead>
<tr>
<th>Session-1</th>
<th>Session-2</th>
</tr>
</thead>
<tbody><tr>
<td><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210527102458.png" srcset="/img/loading.gif"> 关闭自动提交功能</td>
<td><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210527102511.png" srcset="/img/loading.gif"> 关闭自动提交功能</td>
</tr>
<tr>
<td><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210527102543.png" srcset="/img/loading.gif"> 可以正常的查询出全部的数据</td>
<td><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210527102543.png" srcset="/img/loading.gif"> 可以正常的查询出全部的数据</td>
</tr>
<tr>
<td><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210527102633.png" srcset="/img/loading.gif">查询id 为3的数据 ；</td>
<td><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210527102633.png" srcset="/img/loading.gif">获取id为3的数据 ；</td>
</tr>
<tr>
<td><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210527102730.png" srcset="/img/loading.gif"> 更新id为3的数据，但是不提交；</td>
<td><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210527102743.png" srcset="/img/loading.gif"> 更新id为3 的数据， 出于等待状态</td>
</tr>
<tr>
<td><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210527102808.png" srcset="/img/loading.gif"> 通过commit， 提交事务</td>
<td><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210527102826.png" srcset="/img/loading.gif"> 解除阻塞，更新正常进行</td>
</tr>
<tr>
<td>以上， 操作的都是同一行的数据，接下来，演示不同行的数据 ：</td>
<td></td>
</tr>
<tr>
<td><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210527103003.png" srcset="/img/loading.gif"> 更新id为3数据，正常的获取到行锁 ， 执行更新 ；</td>
<td><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210527103019.png" srcset="/img/loading.gif"> 由于与Session-1 操作不是同一行，获取当前行锁，执行更新；</td>
</tr>
</tbody></table>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210527103450.png" srcset="/img/loading.gif"></p>
<h4 id="5-3-6-无索引行锁升级为表锁"><a href="#5-3-6-无索引行锁升级为表锁" class="headerlink" title="5.3.6 无索引行锁升级为表锁"></a>5.3.6 无索引行锁升级为表锁</h4><p>如果不通过索引条件检索数据，那么InnoDB将对表中的所有记录加锁，实际效果跟表锁一样。</p>
<p>查看当前表的索引 ： show index from test_innodb_lock ;</p>
<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210527103555.png" srcset="/img/loading.gif" style="zoom:50%;" />

<table>
<thead>
<tr>
<th>Session-1</th>
<th>Session-2</th>
</tr>
</thead>
<tbody><tr>
<td>关闭事务的自动提交<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210527102458.png" srcset="/img/loading.gif"></td>
<td>关闭事务的自动提交<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210527102458.png" srcset="/img/loading.gif"></td>
</tr>
<tr>
<td>执行更新语句 ：<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210527104129.png" srcset="/img/loading.gif"></td>
<td>执行更新语句， 但处于阻塞状态：<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210527104232.png" srcset="/img/loading.gif"></td>
</tr>
<tr>
<td>提交事务：<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210527103935.png" srcset="/img/loading.gif"></td>
<td>解除阻塞，执行更新成功 ：<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210527104205.png" srcset="/img/loading.gif"></td>
</tr>
<tr>
<td></td>
<td>执行提交操作 ：</td>
</tr>
</tbody></table>
<p>由于 执行更新时 ， name字段本来为varchar类型， 我们是作为数组类型使用，存在类型转换，<code>索引失效</code>，最终行锁变为表锁 ；</p>
<p>![](../../Library/Application Support/typora-user-images/image-20210527104123018.png)</p>
<h4 id="5-3-7-间隙锁危害"><a href="#5-3-7-间隙锁危害" class="headerlink" title="5.3.7 间隙锁危害"></a>5.3.7 间隙锁危害</h4><p>当我们用范围条件，而不是使用相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据进行加锁； 对于键值在条件范围内但并不存在的记录，叫做 <code>&quot;间隙（GAP）&quot;</code> ， InnoDB也会对这个 “间隙” 加锁，这种锁机制就是所谓的 <code>间隙锁（Next-Key锁）</code> 。</p>
<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210527104551.png" srcset="/img/loading.gif" style="zoom:50%;" />

<p>示例 ：</p>
<table>
<thead>
<tr>
<th>Session-1</th>
<th>Session-2</th>
</tr>
</thead>
<tbody><tr>
<td>关闭事务自动提交 <img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210527102458.png" srcset="/img/loading.gif"></td>
<td>关闭事务自动提交<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210527102458.png" srcset="/img/loading.gif"></td>
</tr>
<tr>
<td>根据id范围更新数据<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210527104629.png" srcset="/img/loading.gif"></td>
<td></td>
</tr>
<tr>
<td></td>
<td>插入id为2的记录， 出于阻塞状态<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210527104640.png" srcset="/img/loading.gif"></td>
</tr>
<tr>
<td>提交事务 ；<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210527104657.png" srcset="/img/loading.gif"></td>
<td></td>
</tr>
<tr>
<td></td>
<td>解除阻塞 ， 执行插入操作 ：<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210527104715.png" srcset="/img/loading.gif"></td>
</tr>
<tr>
<td></td>
<td>提交事务 ：</td>
</tr>
</tbody></table>
<h4 id="5-3-8-InnoDB-行锁争用情况"><a href="#5-3-8-InnoDB-行锁争用情况" class="headerlink" title="5.3.8 InnoDB 行锁争用情况"></a>5.3.8 InnoDB 行锁争用情况</h4><div class="hljs"><pre><code class="hljs mysql">show  status like &#39;innodb_row_lock%&#39;;</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210527104756.png" srcset="/img/loading.gif"></p>
<div class="hljs"><pre><code class="hljs markdown">Innodb<span class="hljs-emphasis">_row_</span>lock<span class="hljs-emphasis">_current_</span>waits: 当前正在等待锁定的数量

Innodb<span class="hljs-emphasis">_row_</span>lock<span class="hljs-emphasis">_time: 从系统启动到现在锁定总时间长度</span>
<span class="hljs-emphasis"></span>
<span class="hljs-emphasis">Innodb_</span>row<span class="hljs-emphasis">_lock_</span>time<span class="hljs-emphasis">_avg:每次等待所花平均时长</span>
<span class="hljs-emphasis"></span>
<span class="hljs-emphasis">Innodb_</span>row<span class="hljs-emphasis">_lock_</span>time<span class="hljs-emphasis">_max:从系统启动到现在等待最长的一次所花的时间</span>
<span class="hljs-emphasis"></span>
<span class="hljs-emphasis">Innodb_</span>row<span class="hljs-emphasis">_lock_</span>waits: 系统启动后到现在总共等待的次数


当等待的次数很高，而且每次等待的时长也不小的时候，我们就需要分析系统中为什么会有如此多的等待，然后根据分析结果着手制定优化计划。</code></pre></div>

<h4 id="5-3-9-总结"><a href="#5-3-9-总结" class="headerlink" title="5.3.9 总结"></a>5.3.9 总结</h4><p>InnoDB存储引擎由于实现了行级锁定，虽然在锁定机制的实现方面带来了性能损耗可能比表锁会更高一些，但是在整体并发处理能力方面要远远由于MyISAM的表锁的。当系统并发量较高的时候，InnoDB的整体性能和MyISAM相比就会有比较明显的优势。</p>
<p>但是，InnoDB的行级锁同样也有其脆弱的一面，当我们使用不当的时候，可能会让InnoDB的整体性能表现不仅不能比MyISAM高，甚至可能会更差。</p>
<p>优化建议：</p>
<ul>
<li>尽可能让所有数据检索都能通过 <code>索引</code> 来完成，避免无索引行锁升级为表锁。</li>
<li>合理设计索引，尽量缩小锁的范围</li>
<li>尽可能减少索引条件，及索引范围，<code>避免间隙锁</code></li>
<li>尽量控制事务大小，减少锁定资源量和时间长度</li>
<li>尽可使用低级别事务隔离（但是需要业务层面满足需求）</li>
</ul>
<h2 id="6-常用SQL技巧"><a href="#6-常用SQL技巧" class="headerlink" title="6. 常用SQL技巧"></a>6. 常用SQL技巧</h2><h3 id="6-1-SQL执行顺序"><a href="#6-1-SQL执行顺序" class="headerlink" title="6.1 SQL执行顺序"></a>6.1 SQL执行顺序</h3><p>编写顺序</p>
<div class="hljs"><pre><code class="hljs mysql">SELECT DISTINCT
	&lt;select list&gt;
FROM
	&lt;left_table&gt; &lt;join_type&gt;
JOIN
	&lt;right_table&gt; ON &lt;join_condition&gt;
WHERE
	&lt;where_condition&gt;
GROUP BY
	&lt;group_by_list&gt;
HAVING
	&lt;having_condition&gt;
ORDER BY
	&lt;order_by_condition&gt;
LIMIT
	&lt;limit_params&gt;</code></pre></div>

<p>执行顺序</p>
<div class="hljs"><pre><code class="hljs mysql">FROM	&lt;left_table&gt;

ON 		&lt;join_condition&gt;

&lt;join_type&gt;		JOIN	&lt;right_table&gt;

WHERE		&lt;where_condition&gt;

GROUP BY 	&lt;group_by_list&gt;

HAVING		&lt;having_condition&gt;

SELECT DISTINCT		&lt;select list&gt;

ORDER BY	&lt;order_by_condition&gt;

LIMIT		&lt;limit_params&gt;</code></pre></div>

<h3 id="6-2-正则表达式使用"><a href="#6-2-正则表达式使用" class="headerlink" title="6.2 正则表达式使用"></a>6.2 正则表达式使用</h3><p>正则表达式（Regular Expression）是指一个用来描述或者匹配一系列符合某个句法规则的字符串的单个字符串。</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>^</td>
<td>在字符串开始处进行匹配</td>
</tr>
<tr>
<td>$</td>
<td>在字符串末尾处进行匹配</td>
</tr>
<tr>
<td>.</td>
<td>匹配任意单个字符, 包括换行符</td>
</tr>
<tr>
<td>[…]</td>
<td>匹配出括号内的任意字符</td>
</tr>
<tr>
<td>[^…]</td>
<td>匹配不出括号内的任意字符</td>
</tr>
<tr>
<td>a*</td>
<td>匹配零个或者多个a(包括空串)</td>
</tr>
<tr>
<td>a+</td>
<td>匹配一个或者多个a(不包括空串)</td>
</tr>
<tr>
<td>a?</td>
<td>匹配零个或者一个a</td>
</tr>
<tr>
<td>a1|a2</td>
<td>匹配a1或a2</td>
</tr>
<tr>
<td>a(m)</td>
<td>匹配m个a</td>
</tr>
<tr>
<td>a(m,)</td>
<td>至少匹配m个a</td>
</tr>
<tr>
<td>a(m,n)</td>
<td>匹配m个a 到 n个a</td>
</tr>
<tr>
<td>a(,n)</td>
<td>匹配0到n个a</td>
</tr>
<tr>
<td>(…)</td>
<td>将模式元素组成单一元素</td>
</tr>
</tbody></table>
<div class="hljs"><pre><code class="hljs mysql">select * from emp where name regexp &#39;^T&#39;;

select * from emp where name regexp &#39;2$&#39;;

select * from emp where name regexp &#39;[uvw]&#39;;</code></pre></div>

<h3 id="6-3-MySQL-常用函数"><a href="#6-3-MySQL-常用函数" class="headerlink" title="6.3 MySQL 常用函数"></a>6.3 MySQL 常用函数</h3><p>数字函数</p>
<table>
<thead>
<tr>
<th>函数名称</th>
<th>作 用</th>
</tr>
</thead>
<tbody><tr>
<td>ABS</td>
<td>求绝对值</td>
</tr>
<tr>
<td>SQRT</td>
<td>求二次方根</td>
</tr>
<tr>
<td>MOD</td>
<td>求余数</td>
</tr>
<tr>
<td>CEIL 和 CEILING</td>
<td>两个函数功能相同，都是返回不小于参数的最小整数，即向上取整</td>
</tr>
<tr>
<td>FLOOR</td>
<td>向下取整，返回值转化为一个BIGINT</td>
</tr>
<tr>
<td>RAND</td>
<td>生成一个0~1之间的随机数，传入整数参数是，用来产生重复序列</td>
</tr>
<tr>
<td>ROUND</td>
<td>对所传参数进行四舍五入</td>
</tr>
<tr>
<td>SIGN</td>
<td>返回参数的符号</td>
</tr>
<tr>
<td>POW 和 POWER</td>
<td>两个函数的功能相同，都是所传参数的次方的结果值</td>
</tr>
<tr>
<td>SIN</td>
<td>求正弦值</td>
</tr>
<tr>
<td>ASIN</td>
<td>求反正弦值，与函数 SIN 互为反函数</td>
</tr>
<tr>
<td>COS</td>
<td>求余弦值</td>
</tr>
<tr>
<td>ACOS</td>
<td>求反余弦值，与函数 COS 互为反函数</td>
</tr>
<tr>
<td>TAN</td>
<td>求正切值</td>
</tr>
<tr>
<td>ATAN</td>
<td>求反正切值，与函数 TAN 互为反函数</td>
</tr>
<tr>
<td>COT</td>
<td>求余切值</td>
</tr>
</tbody></table>
<p>字符串函数</p>
<table>
<thead>
<tr>
<th>函数名称</th>
<th>作 用</th>
</tr>
</thead>
<tbody><tr>
<td>LENGTH</td>
<td>计算字符串长度函数，返回字符串的字节长度</td>
</tr>
<tr>
<td>CONCAT</td>
<td>合并字符串函数，返回结果为连接参数产生的字符串，参数可以使一个或多个</td>
</tr>
<tr>
<td>INSERT</td>
<td>替换字符串函数</td>
</tr>
<tr>
<td>LOWER</td>
<td>将字符串中的字母转换为小写</td>
</tr>
<tr>
<td>UPPER</td>
<td>将字符串中的字母转换为大写</td>
</tr>
<tr>
<td>LEFT</td>
<td>从左侧字截取符串，返回字符串左边的若干个字符</td>
</tr>
<tr>
<td>RIGHT</td>
<td>从右侧字截取符串，返回字符串右边的若干个字符</td>
</tr>
<tr>
<td>TRIM</td>
<td>删除字符串左右两侧的空格</td>
</tr>
<tr>
<td>REPLACE</td>
<td>字符串替换函数，返回替换后的新字符串</td>
</tr>
<tr>
<td>SUBSTRING</td>
<td>截取字符串，返回从指定位置开始的指定长度的字符换</td>
</tr>
<tr>
<td>REVERSE</td>
<td>字符串反转（逆序）函数，返回与原始字符串顺序相反的字符串</td>
</tr>
</tbody></table>
<p>日期函数</p>
<table>
<thead>
<tr>
<th>函数名称</th>
<th>作 用</th>
</tr>
</thead>
<tbody><tr>
<td>CURDATE 和 CURRENT_DATE</td>
<td>两个函数作用相同，返回当前系统的日期值</td>
</tr>
<tr>
<td>CURTIME 和 CURRENT_TIME</td>
<td>两个函数作用相同，返回当前系统的时间值</td>
</tr>
<tr>
<td>NOW 和 SYSDATE</td>
<td>两个函数作用相同，返回当前系统的日期和时间值</td>
</tr>
<tr>
<td>MONTH</td>
<td>获取指定日期中的月份</td>
</tr>
<tr>
<td>MONTHNAME</td>
<td>获取指定日期中的月份英文名称</td>
</tr>
<tr>
<td>DAYNAME</td>
<td>获取指定曰期对应的星期几的英文名称</td>
</tr>
<tr>
<td>DAYOFWEEK</td>
<td>获取指定日期对应的一周的索引位置值</td>
</tr>
<tr>
<td>WEEK</td>
<td>获取指定日期是一年中的第几周，返回值的范围是否为 0〜52 或 1〜53</td>
</tr>
<tr>
<td>DAYOFYEAR</td>
<td>获取指定曰期是一年中的第几天，返回值范围是1~366</td>
</tr>
<tr>
<td>DAYOFMONTH</td>
<td>获取指定日期是一个月中是第几天，返回值范围是1~31</td>
</tr>
<tr>
<td>YEAR</td>
<td>获取年份，返回值范围是 1970〜2069</td>
</tr>
<tr>
<td>TIME_TO_SEC</td>
<td>将时间参数转换为秒数</td>
</tr>
<tr>
<td>SEC_TO_TIME</td>
<td>将秒数转换为时间，与TIME_TO_SEC 互为反函数</td>
</tr>
<tr>
<td>DATE_ADD 和 ADDDATE</td>
<td>两个函数功能相同，都是向日期添加指定的时间间隔</td>
</tr>
<tr>
<td>DATE_SUB 和 SUBDATE</td>
<td>两个函数功能相同，都是向日期减去指定的时间间隔</td>
</tr>
<tr>
<td>ADDTIME</td>
<td>时间加法运算，在原始时间上添加指定的时间</td>
</tr>
<tr>
<td>SUBTIME</td>
<td>时间减法运算，在原始时间上减去指定的时间</td>
</tr>
<tr>
<td>DATEDIFF</td>
<td>获取两个日期之间间隔，返回参数 1 减去参数 2 的值</td>
</tr>
<tr>
<td>DATE_FORMAT</td>
<td>格式化指定的日期，根据参数返回指定格式的值</td>
</tr>
<tr>
<td>WEEKDAY</td>
<td>获取指定日期在一周内的对应的工作日索引</td>
</tr>
</tbody></table>
<p>聚合函数</p>
<table>
<thead>
<tr>
<th>函数名称</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>MAX</td>
<td>查询指定列的最大值</td>
</tr>
<tr>
<td>MIN</td>
<td>查询指定列的最小值</td>
</tr>
<tr>
<td>COUNT</td>
<td>统计查询结果的行数</td>
</tr>
<tr>
<td>SUM</td>
<td>求和，返回指定列的总和</td>
</tr>
<tr>
<td>AVG</td>
<td>求平均值，返回指定列数据的平均值</td>
</tr>
</tbody></table>
<h1 id="Mysql高级-day04"><a href="#Mysql高级-day04" class="headerlink" title="Mysql高级-day04"></a>Mysql高级-day04</h1><h2 id="1-MySql中常用工具"><a href="#1-MySql中常用工具" class="headerlink" title="1. MySql中常用工具"></a>1. MySql中常用工具</h2><h3 id="1-1-mysql"><a href="#1-1-mysql" class="headerlink" title="1.1 mysql"></a>1.1 mysql</h3><p>该mysql不是指mysql服务，而是指mysql的客户端工具。</p>
<p>语法 ：</p>
<div class="hljs"><pre><code class="hljs mysql">mysql [options] [database]</code></pre></div>

<h4 id="1-1-1-连接选项"><a href="#1-1-1-连接选项" class="headerlink" title="1.1.1 连接选项"></a>1.1.1 连接选项</h4><div class="hljs"><pre><code class="hljs mysql">参数 ： 
	-u, --user&#x3D;name			指定用户名
	-p, --password[&#x3D;name]	指定密码
	-h, --host&#x3D;name			指定服务器IP或域名
	-P, --port&#x3D;#			指定连接端口

示例 ：
	mysql -h 127.0.0.1 -P 3306 -u root -p
	
	mysql -h127.0.0.1 -P3306 -uroot -p2143</code></pre></div>

<h4 id="1-1-2-执行选项"><a href="#1-1-2-执行选项" class="headerlink" title="1.1.2 执行选项"></a>1.1.2 执行选项</h4><div class="hljs"><pre><code class="hljs mysql">-e, --execute&#x3D;name		执行SQL语句并退出(shell脚本应用)</code></pre></div>

<p>此选项可以在Mysql客户端执行SQL语句，而不用连接到MySQL数据库再执行，对于一些批处理脚本，这种方式尤其方便。</p>
<div class="hljs"><pre><code class="hljs mysql">示例：
	mysql -uroot -p2143 db01 -e &quot;select * from tb_book&quot;;</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210527111246.png" srcset="/img/loading.gif"></p>
<h3 id="1-2-mysqladmin"><a href="#1-2-mysqladmin" class="headerlink" title="1.2 mysqladmin"></a>1.2 mysqladmin</h3><p>mysqladmin 是一个执行管理操作的客户端程序。可以用它来<code>检查服务器的配置和当前状态、创建并删除数据库等</code>。</p>
<p>可以通过 ： mysqladmin –help 指令查看帮助文档</p>
<div class="hljs"><pre><code class="hljs mysql">示例 ：
	mysqladmin -uroot -p2143 create &#39;test01&#39;;  
	mysqladmin -uroot -p2143 drop &#39;test01&#39;;
	mysqladmin -uroot -p2143 version;</code></pre></div>

<h3 id="1-3-mysqlbinlog"><a href="#1-3-mysqlbinlog" class="headerlink" title="1.3 mysqlbinlog"></a>1.3 mysqlbinlog</h3><p>由于服务器生成的二进制日志文件以二进制格式保存，所以如果想要检查这些文本的文本格式，就会使用到mysqlbinlog 日志管理工具。</p>
<p>语法 ：</p>
<div class="hljs"><pre><code class="hljs mysql">mysqlbinlog [options]  log-files1 log-files2 ...

选项：
	
	-d, --database&#x3D;name : 指定数据库名称，只列出指定的数据库相关操作。
	
	-o, --offset&#x3D;# : 忽略掉日志中的前n行命令。
	
	-r,--result-file&#x3D;name : 将输出的文本格式日志输出到指定文件。
	
	-s, --short-form : 显示简单格式， 省略掉一些信息。
	
	--start-datatime&#x3D;date1  --stop-datetime&#x3D;date2 : 指定日期间隔内的所有日志。
	
	--start-position&#x3D;pos1 --stop-position&#x3D;pos2 : 指定位置间隔内的所有日志。</code></pre></div>

<h3 id="1-4-mysqldump"><a href="#1-4-mysqldump" class="headerlink" title="1.4 mysqldump"></a>1.4 mysqldump</h3><p>mysqldump 客户端工具用来备份数据库或在不同数据库之间进行数据迁移。备份内容包含创建表，及插入表的SQL语句。</p>
<p>语法 ：</p>
<div class="hljs"><pre><code class="hljs mysql">mysqldump [options] db_name [tables]

mysqldump [options] --database&#x2F;-B db1 [db2 db3...]

mysqldump [options] --all-databases&#x2F;-A</code></pre></div>

<h4 id="1-4-1-连接选项"><a href="#1-4-1-连接选项" class="headerlink" title="1.4.1 连接选项"></a>1.4.1 连接选项</h4><div class="hljs"><pre><code class="hljs mysql">参数 ： 
	-u, --user&#x3D;name			指定用户名
	-p, --password[&#x3D;name]	指定密码
	-h, --host&#x3D;name			指定服务器IP或域名
	-P, --port&#x3D;#			指定连接端口</code></pre></div>

<h4 id="1-4-2-输出内容选项"><a href="#1-4-2-输出内容选项" class="headerlink" title="1.4.2 输出内容选项"></a>1.4.2 输出内容选项</h4><div class="hljs"><pre><code class="hljs mysql">参数：
	--add-drop-database		在每个数据库创建语句前加上 Drop database 语句
	--add-drop-table		在每个表创建语句前加上 Drop table 语句 , 默认开启 ; 不开启 (--skip-add-drop-table)
	
	-n, --no-create-db		不包含数据库的创建语句
	-t, --no-create-info	不包含数据表的创建语句
	-d --no-data			不包含数据
	
	 -T, --tab&#x3D;name			自动生成两个文件：一个.sql文件，创建表结构的语句；
	 						一个.txt文件，数据文件，相当于select into outfile  
示例 ： 
	mysqldump -uroot -p2143 db01 tb_book --add-drop-database --add-drop-table &gt; a
	
	mysqldump -uroot -p2143 -T &#x2F;tmp test city</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210527112101.png" srcset="/img/loading.gif"></p>
<h3 id="1-5-mysqlimport-source"><a href="#1-5-mysqlimport-source" class="headerlink" title="1.5 mysqlimport/source"></a>1.5 mysqlimport/source</h3><p>mysqlimport 是客户端数据导入工具，用来导入mysqldump 加 -T 参数后导出的文本文件。</p>
<p>语法：</p>
<div class="hljs"><pre><code class="hljs mysql">mysqlimport [options]  db_name  textfile1  [textfile2...]</code></pre></div>

<p>示例：</p>
<div class="hljs"><pre><code class="hljs mysql">mysqlimport -uroot -p2143 test &#x2F;tmp&#x2F;city.txt</code></pre></div>

<p>如果需要导入sql文件,可以使用mysql中的source 指令 :</p>
<div class="hljs"><pre><code class="hljs mysql">source &#x2F;root&#x2F;tb_book.sql</code></pre></div>

<h3 id="1-6-mysqlshow"><a href="#1-6-mysqlshow" class="headerlink" title="1.6 mysqlshow"></a>1.6 mysqlshow</h3><p>mysqlshow 客户端对象查找工具，用来很快地查找存在哪些数据库、数据库中的表、表中的列或者索引。</p>
<p>语法：</p>
<div class="hljs"><pre><code class="hljs mysql">mysqlshow [options] [db_name [table_name [col_name]]]</code></pre></div>

<p>参数：</p>
<div class="hljs"><pre><code class="hljs mysql">--count		显示数据库及表的统计信息（数据库，表 均可以不指定）

-i			显示指定数据库或者指定表的状态信息</code></pre></div>

<p>示例：</p>
<div class="hljs"><pre><code class="hljs mysql">#查询每个数据库的表的数量及表中记录的数量
mysqlshow -uroot -p2143 --count

#查询test库中每个表中的字段书，及行数
mysqlshow -uroot -p2143 test --count

#查询test库中book表的详细情况
mysqlshow -uroot -p2143 test book --count</code></pre></div>

<h2 id="2-Mysql-日志"><a href="#2-Mysql-日志" class="headerlink" title="2. Mysql 日志"></a>2. Mysql 日志</h2><p>在任何一种数据库中，都会有各种各样的日志，记录着数据库工作的方方面面，以帮助数据库管理员追踪数据库曾经发生过的各种事件。</p>
<p>MySQL 也不例外，在 MySQL 中，有 4 种不同的日志，分别是:</p>
<ul>
<li><p>错误日志、</p>
</li>
<li><p>二进制日志（BINLOG 日志）、</p>
</li>
<li><p>查询日志、</p>
</li>
<li><p>慢查询日志</p>
<p>这些日志记录着数据库在不同方面的踪迹。</p>
</li>
</ul>
<h3 id="2-1-错误日志"><a href="#2-1-错误日志" class="headerlink" title="2.1 错误日志"></a>2.1 错误日志</h3><p>错误日志是 MySQL 中最重要的日志之一，它记录了当 mysqld 启动和停止时，以及服务器在运行过程中发生任何严重错误时的相关信息。<code>当数据库出现任何故障导致无法正常使用时，可以首先查看此日志</code>。</p>
<p>该日志是默认开启的 ， 默认存放目录为 mysql 的数据目录（var/lib/mysql）, 默认的日志文件名为 hostname.err（hostname是主机名）。</p>
<p>查看日志位置指令 ：</p>
<div class="hljs"><pre><code class="hljs mysql">show variables like &#39;log_error%&#39;;</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210527112429.png" srcset="/img/loading.gif"></p>
<p>查看日志内容 ：</p>
<div class="hljs"><pre><code class="hljs mysql">tail -f ...</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210527112517.png" srcset="/img/loading.gif"></p>
<h3 id="2-2-二进制日志"><a href="#2-2-二进制日志" class="headerlink" title="2.2 二进制日志"></a>2.2 二进制日志</h3><h4 id="2-2-1概述"><a href="#2-2-1概述" class="headerlink" title="2.2.1概述"></a>2.2.1概述</h4><p>二进制日志（BINLOG）记录了<code>所有的 DDL（数据定义语言）语句和 DML（数据操纵语言）语句，但是不包括数据查询语句</code>。此日志对于灾难时的数据恢复起着极其重要的作用，MySQL的<code>主从复制， 就是通过该binlog实现的</code>。</p>
<p>二进制日志，默认情况下是没有开启的，需要到MySQL的配置文件中开启，并配置MySQL日志的格式。</p>
<p>配置文件位置 : /usr/my.cnf</p>
<p>日志存放位置 : 配置时，给定了文件名但是没有指定路径，日志默认写入Mysql的数据目录。</p>
<p><a target="_blank" rel="noopener" href="https://www.google.com/search?q=mac+mysql+%E6%95%B0%E6%8D%AE%E7%9B%AE%E5%BD%95&sxsrf=ALeKk00FFxUBH8Aqk_19RZT3Z63G_wT5WQ:1622086469431&ei=RROvYJPeGdHWz7sPtdeSoAk&oq=mac+mysql+%E6%95%B0%E6%8D%AE%E7%9B%AE%E5%BD%95&gs_lcp=Cgdnd3Mtd2l6EAMyAggAOgYIABAHEB5Q6hxYhCJg7yNoAHAAeACAAeABiAHOB5IBBTAuNS4xmAEAoAEBqgEHZ3dzLXdpesABAQ&sclient=gws-wiz&ved=0ahUKEwjTlLj-9ujwAhVR63MBHbWrBJQQ4dUDCA8&uact=5">mac mysql数据目录</a></p>
<p>Linux mysql 数据目录：/var/lib/mysql</p>
<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210527113543.png" srcset="/img/loading.gif" style="zoom:50%;" />

<div class="hljs"><pre><code class="hljs mysql">#配置开启binlog日志， 日志的文件前缀为 mysqlbin -----&gt; 生成的文件名如 : mysqlbin.000001,mysqlbin.000002
log_bin&#x3D;mysqlbin

#配置二进制日志的格式
binlog_format&#x3D;STATEMENT</code></pre></div>

<h4 id="2-2-2-日志格式"><a href="#2-2-2-日志格式" class="headerlink" title="2.2.2 日志格式"></a>2.2.2 日志格式</h4><p> <strong>STATEMENT</strong> </p>
<p>该日志格式在日志文件中记录的都是<code>SQL语句（statement）</code>， <strong>每一条对数据进行修改的SQL</strong> 都会记录在日志文件中，通过Mysql提供的mysqlbinlog工具，可以清晰的查看到每条语句的文本。主从复制的时候，从库（slave）会将日志解析为原文本，并在从库重新执行一次。</p>
<p> <strong>ROW</strong> </p>
<p>该日志格式在日志文件中记录的是 <strong>每一行的数据变更，而不是记录SQL语句</strong> 。比如，执行SQL语句 ： update tb_book set status=’1’ , 如果是STATEMENT 日志格式，在日志中会记录一行SQL文件； 如果是ROW，由于是对全表进行更新，也就是每一行记录都会发生变更，ROW 格式的日志中会记录每一行的数据变更。</p>
<p> <strong>MIXED</strong> </p>
<p>这是目前MySQL默认的日志格式，即混合了STATEMENT 和 ROW两种格式。默认情况下采用STATEMENT，但是在一些特殊情况下采用ROW来进行记录。MIXED 格式能尽量利用两种模式的优点，而避开他们的缺点。</p>
<h5 id="2-2-3-日志读取"><a href="#2-2-3-日志读取" class="headerlink" title="2.2.3 日志读取"></a>2.2.3 日志读取</h5><p>由于日志以二进制方式存储，不能直接读取，需要用mysqlbinlog工具来查看，语法如下 ：</p>
<div class="hljs"><pre><code class="hljs mysql">mysqlbinlog log-file；</code></pre></div>

<p><strong>查看STATEMENT格式日志</strong></p>
<p>执行插入语句 ：</p>
<div class="hljs"><pre><code class="hljs mysql">insert into tb_book values(null,&#39;Lucene&#39;,&#39;2088-05-01&#39;,&#39;0&#39;);</code></pre></div>

<p>查看日志文件 ：</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/04/23/redis/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">redis笔记</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/04/11/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%983/">
                        <span class="hidden-mobile">高频面试题2</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments">
                
                

              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":200})
    NProgress.start()
    document.addEventListener('DOMContentLoaded', function() {
      window.NProgress && window.NProgress.inc();
    })
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.staticfile.org/jquery/3.5.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.staticfile.org/tocbot/4.12.0/tocbot.min.js" ></script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>





  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      var inputArea = document.querySelector("#local-search-input");
      inputArea.onclick = function () {
        searchFunc(path, 'local-search-input', 'local-search-result');
        this.onclick = null
      }
    })()
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>



<!-- hexo injector body_end start -->
  <script src="/js/custom.js"></script>
<!-- hexo injector body_end end --></body>
</html>
