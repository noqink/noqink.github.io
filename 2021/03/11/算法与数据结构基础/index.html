

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/imgfavicon.jpg">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  <title>数据结构与算法基础回顾笔记 - Blog</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.1.2/styles/ocean.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.5","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"copy_btn":true,"image_zoom":{"enable":true},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.2.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Main</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax=true
         style="background: url('https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/imgdefault.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="数据结构与算法基础回顾笔记">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-03-11 11:11" pubdate>
        2021年3月11日 上午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      38.2k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      544
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">数据结构与算法基础回顾笔记</h1>
            
            <div class="markdown-body">
              <blockquote>
<p>跟左神重学！</p>
</blockquote>
<h1 id="认识复杂度、对数器、二分法与异或运算"><a href="#认识复杂度、对数器、二分法与异或运算" class="headerlink" title="认识复杂度、对数器、二分法与异或运算"></a>认识复杂度、对数器、二分法与异或运算</h1><h2 id="认识复杂度"><a href="#认识复杂度" class="headerlink" title="认识复杂度"></a>认识复杂度</h2><blockquote>
<p>评估算法优劣的核心指标是什么？</p>
</blockquote>
<ul>
<li><p>时间复杂度（流程决定）</p>
</li>
<li><p>额外空间复杂度（流程决定）</p>
</li>
<li><p>常数项时间（实现细节决定）</p>
</li>
</ul>
<h3 id="1、什么是时间复杂度？时间复杂度怎么估算？"><a href="#1、什么是时间复杂度？时间复杂度怎么估算？" class="headerlink" title="1、什么是时间复杂度？时间复杂度怎么估算？"></a>1、什么是时间复杂度？时间复杂度怎么估算？</h3><ul>
<li>常数时间的操作</li>
<li>确定算法流程的总操作数量与样本数量之间的表达式关系</li>
<li>只看表达式最高阶项的部分</li>
</ul>
<h3 id="2、何为常数时间的操作？"><a href="#2、何为常数时间的操作？" class="headerlink" title="2、何为常数时间的操作？"></a>2、何为常数时间的操作？</h3><blockquote>
<p>如果一个操作的执行时间不以具体样本量为转移，每次执行时间都是固定时间。称这样的操作为常数时间的操作。如取Array[0]与取Array[1000000]花费时间一致， 不以数据量转移。</p>
</blockquote>
<p><strong>常见的常数时间的操作</strong></p>
<ul>
<li>常见的算术运算（+、-、*、/、% 等）</li>
<li>常见的位运算（&gt;&gt;(带符号右移)、&gt;&gt;&gt;(不带符号右移)、&lt;&lt;、|、&amp;、^等）</li>
<li>赋值、比较、自增、自减操作等</li>
<li>数组寻址操作</li>
</ul>
<p>总之，执行时间固定的操作都是常数时间的操作。<br>反之，执行时间不固定的操作，都不是常数时间的操作。</p>
<p><strong>如何确定算法流程的总操作数量与样本数量之间的表达式关系？</strong></p>
<p>​    1，想象该算法流程所处理的数据状况，要按照 <strong><em>最差</em></strong>情况来。</p>
<p>​    2，把整个流程彻底拆分为一个个 <strong><em>基本动作</em></strong>，保证每个动作都是 <strong><em>常数时间</em></strong>的操作。</p>
<p>​    3，如果数据量为N，看看基本动作的数量和N是什么关系。</p>
<h3 id="3、如何确定算法流程的时间复杂度？"><a href="#3、如何确定算法流程的时间复杂度？" class="headerlink" title="3、如何确定算法流程的时间复杂度？"></a>3、如何确定算法流程的时间复杂度？</h3><blockquote>
<p>当完成了表达式的建立，只要把最高阶项留下即可。低阶项都去掉，高阶项的系数也去掉。<br>记为：<strong>O(忽略掉系数的高阶项)</strong></p>
</blockquote>
<p>通过三个具体的例子，来实践一把时间复杂度的估算</p>
<h4 id="a、选择排序"><a href="#a、选择排序" class="headerlink" title="a、选择排序"></a>a、选择排序</h4><p>过程：<br>arr[0～N-1]范围上，找到最小值所在的位置，然后把最小值交换到0位置。<br>arr[1～N-1]范围上，找到最小值所在的位置，然后把最小值交换到1位置。<br>arr[2～N-1]范围上，找到最小值所在的位置，然后把最小值交换到2位置。<br>…<br>arr[N-1～N-1]范围上，找到最小值位置，然后把最小值交换到N-1位置。</p>
<p>估算：<br>很明显，如果arr长度为N，每一步常数操作的数量，如等差数列一般<br>所以，总的常数操作数量 = a*(N^2) + b*N + c (a、b、c都是常数)</p>
<p>所以选择排序的时间复杂度为 **O(N^2)**。</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">selectionSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length &lt; <span class="hljs-number">2</span>) &#123;
      <span class="hljs-keyword">return</span>;
   &#125;
   <span class="hljs-comment">// 0～n-1</span>
   <span class="hljs-comment">// 1～n-1</span>
   <span class="hljs-comment">// 2～n-1</span>
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length - <span class="hljs-number">1</span>; i++) &#123; <span class="hljs-comment">// i ~ N-1</span>
      <span class="hljs-comment">// 最小值在哪个位置上  i～n-1</span>
      <span class="hljs-keyword">int</span> minIndex = i;
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; arr.length; j++) &#123; <span class="hljs-comment">// i ~ N-1 上找最小值的下标 </span>
         minIndex = arr[j] &lt; arr[minIndex] ? j : minIndex;
      &#125;
      swap(arr, i, minIndex);
   &#125;
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;
   <span class="hljs-keyword">int</span> tmp = arr[i];
   arr[i] = arr[j];
   arr[j] = tmp;
&#125;</code></pre></div>

<h4 id="b、冒泡排序"><a href="#b、冒泡排序" class="headerlink" title="b、冒泡排序"></a>b、冒泡排序</h4><p>过程：<br>在arr[0～N-1]范围上：<br>arr[0]和arr[1]，谁大谁来到1位置；arr[1]和arr[2]，谁大谁来到2位置…arr[N-2]和arr[N-1]，谁大谁来到N-1位置</p>
<p>在arr[0～N-2]范围上，重复上面的过程，但最后一步是arr[N-3]和arr[N-2]，谁大谁来到N-2位置<br>在arr[0～N-3]范围上，重复上面的过程，但最后一步是arr[N-4]和arr[N-3]，谁大谁来到N-3位置<br>…<br>最后在arr[0～1]范围上，重复上面的过程，但最后一步是arr[0]和arr[1]，谁大谁来到1位置</p>
<p>估算：<br>很明显，如果arr长度为N，每一步常数操作的数量，依然如等差数列一般<br>所以，总的常数操作数量 = a*(N^2) + b*N + c (a、b、c都是常数)</p>
<p>所以冒泡排序的时间复杂度为O(N^2)。</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bubbleSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span></span>&#123;
        <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length &lt; <span class="hljs-number">2</span>)&#123;
            <span class="hljs-keyword">return</span>;
        &#125;

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = arr.length - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--)&#123;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++)&#123;
                <span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>])&#123;
                    swap(arr, j, j+<span class="hljs-number">1</span>);
                &#125;
            &#125;
        &#125;
    &#125;
    <span class="hljs-comment">// 交换arr的i和j位置上的值</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;
        arr[i] = arr[i] ^ arr[j];
        arr[j] = arr[i] ^ arr[j];
        arr[i] = arr[i] ^ arr[j];
    &#125;</code></pre></div>

<h4 id="c、插入排序"><a href="#c、插入排序" class="headerlink" title="c、插入排序"></a>c、插入排序</h4><p>过程：<br>想让arr[0<del>0]上有序，这个范围只有一个数，当然是有序的。<br>想让arr[0</del>1]上有序，所以从arr[1]开始往前看，如果arr[1]&lt;arr[0]，就交换。否则什么也不做。<br>想让arr[0<del>i]上有序，所以从arr[i]开始往前看，arr[i]这个数不停向左移动，一直移动到左边的数字不再比自己大，停止移动。<br>最后一步，想让arr[0</del>N-1]上有序， arr[N-1]这个数不停向左移动，一直移动到左边的数字不再比自己大，停止移动。</p>
<p>估算时发现这个算法流程的复杂程度，会因为数据状况的不同而不同。</p>
<div class="hljs"><pre><code class="hljs mathematica">
如果某个算法流程的复杂程度会根据数据状况的不同而不同，那么你必须要按照最差情况来估计。

很明显，在最差情况下，如果<span class="hljs-variable">arr</span>长度为<span class="hljs-built_in">N</span>，插入排序的每一步常数操作的数量，还是如等差数列一般

所以，总的常数操作数量 <span class="hljs-operator">=</span> <span class="hljs-variable">a</span><span class="hljs-operator">*</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-operator">^</span><span class="hljs-number">2</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">+</span> <span class="hljs-variable">b</span><span class="hljs-operator">*</span><span class="hljs-built_in">N</span> <span class="hljs-operator">+</span> <span class="hljs-variable">c</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">a</span>、<span class="hljs-variable">b</span>、<span class="hljs-variable">c</span>都是常数<span class="hljs-punctuation">)</span>

所以插入排序排序的时间复杂度为<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-operator">^</span><span class="hljs-number">2</span><span class="hljs-punctuation">)</span>。

</code></pre></div>

<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertionSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length &lt; <span class="hljs-number">2</span>) &#123;
      <span class="hljs-keyword">return</span>;
   &#125;
   <span class="hljs-comment">// 0~0 有序的</span>
   <span class="hljs-comment">// 0~i 想有序</span>
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; arr.length; i++) &#123; <span class="hljs-comment">// 0 ~ i 做到有序</span>
      
      <span class="hljs-comment">// arr[i]往前看，一直交换到合适的位置停止</span>
      <span class="hljs-comment">// ...(&lt;=)  ?       &lt;- i</span>
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[j] &gt; arr[j + <span class="hljs-number">1</span>]; j--) &#123;
         swap(arr, j, j + <span class="hljs-number">1</span>);
      &#125;
   &#125;
&#125;

<span class="hljs-comment">// i和j是一个位置的话，会出错</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;
   arr[i] = arr[i] ^ arr[j];
   arr[j] = arr[i] ^ arr[j];
   arr[i] = arr[i] ^ arr[j];
&#125;</code></pre></div>

<blockquote>
<p>注意</p>
</blockquote>
<ul>
<li><p>算法的过程，和具体的语言是无关的。</p>
</li>
<li><p>想分析一个算法流程的时间复杂度的前提，是对该流程非常熟悉</p>
</li>
<li><p>一定要确保在拆分算法流程时，拆分出来的所有行为都是常数时间的操作。这意味着你写算法时，对自己的用过的每一个系统api，都非常的熟悉。否则会影响你对时间复杂度的估算。</p>
<hr>
<div class="hljs"><pre><code class="hljs mathematica">排名从好到差：
<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-number">1</span><span class="hljs-punctuation">)</span>   
<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-variable">logN</span><span class="hljs-punctuation">)</span>   
<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-punctuation">)</span>   
<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-operator">*</span><span class="hljs-variable">logN</span><span class="hljs-punctuation">)</span>   
<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-operator">^</span><span class="hljs-number">2</span><span class="hljs-punctuation">)</span>   <span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-operator">^</span><span class="hljs-number">3</span><span class="hljs-punctuation">)</span>   …   <span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-operator">^</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span>
<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-number">2</span><span class="hljs-operator">^</span><span class="hljs-built_in">N</span><span class="hljs-punctuation">)</span>   <span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-number">3</span><span class="hljs-operator">^</span><span class="hljs-built_in">N</span><span class="hljs-punctuation">)</span>   …   <span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">K</span><span class="hljs-operator">^</span><span class="hljs-built_in">N</span><span class="hljs-punctuation">)</span>
<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-operator">!</span><span class="hljs-punctuation">)</span></code></pre></div>



</li>
</ul>
<h3 id="4、时间复杂度的意义"><a href="#4、时间复杂度的意义" class="headerlink" title="4、时间复杂度的意义"></a>4、时间复杂度的意义</h3><p>抹掉了好多东西，只剩下了一个 <strong><em>最高阶项</em></strong>啊…</p>
<p>那这个东西有什么意义呢？</p>
<p>时间复杂度的意义在于：</p>
<p>当我们要处理的样本量很大很大时，我们会发现*<strong>低阶项是什么不是最重要的 **<em>；每一项的系数是什么，不是最重要的。</em></strong>真正重要的就是最高阶项是什么***。</p>
<p>这就是时间复杂度的意义，它是衡量算法流程的复杂程度的一种指标，该指标只与 <strong><em>数据量</em></strong>有关，与 <strong><em>过程之外的优化</em></strong>无关。</p>
<h3 id="5、额外空间复杂度"><a href="#5、额外空间复杂度" class="headerlink" title="5、额外空间复杂度"></a>5、额外空间复杂度</h3><p>你要实现一个算法流程，在实现算法流程的过程中，你需要开辟一些空间来支持你的算法流程。</p>
<p>作为 <strong><em>输入参数</em></strong>的空间，不算额外空间。<br>作为 <strong><em>输出结果</em></strong>的空间，也不算额外空间。</p>
<p>因为这些都是必要的、和现实目标有关的。所以都不算。<br>但除此之外，你的流程如果还需要开辟空间才能让你的流程继续下去。这部分空间就是额外空间。<br>如果你的流程只需要开辟有限几个变量，额外空间复杂度就是O(1)。</p>
<h3 id="6、算法流程的常数项"><a href="#6、算法流程的常数项" class="headerlink" title="6、算法流程的常数项"></a>6、算法流程的常数项</h3><p>我们会发现，时间复杂度这个指标，是忽略低阶项和所有常数系数的。<br>难道同样时间复杂度的流程，在实际运行时候就一样的好吗？<br>当然不是。</p>
<p>时间复杂度只是一个很重要的指标而已。如果两个时间复杂度一样的算法，你还要去在时间上拼优劣，就进入到拼常数时间的阶段，简称 <strong><em>拼常数项</em></strong>。</p>
<blockquote>
<p>算法流程的常数项的比拼方式</p>
</blockquote>
<p> <strong><em>放弃理论分析，生成随机数据直接测</em></strong>。</p>
<p>为什么不去理论分析？<br>不是不能纯分析，而是没必要。因为不同常数时间的操作，虽然都是固定时间，但还是有快慢之分的。</p>
<p>比如，位运算的常数时间原小于算术运算的常数时间，这两个运算的常数时间又远小于数组寻址的时间。<br>所以如果纯理论分析，往往会需要非常多的分析过程。都已经到了具体细节的程度，莫不如交给实验数据好了。</p>
<h3 id="7、面试、比赛、刷题中，一个问题的最优解是什么意思？"><a href="#7、面试、比赛、刷题中，一个问题的最优解是什么意思？" class="headerlink" title="7、面试、比赛、刷题中，一个问题的最优解是什么意思？"></a>7、面试、比赛、刷题中，一个问题的最优解是什么意思？</h3><p>一般情况下，认为解决一个问题的算法流程，在 <strong><em>时间复杂度</em></strong>的指标上，一定要尽可能的 <strong><em>低</em></strong>，先满足了时间复杂度最低这个指标之后，使用最少的 <strong><em>空间</em></strong>的算法流程，叫这个问题的最优解。</p>
<p>一般说起最优解都是 <strong><em>忽略掉常数项</em></strong>这个因素的，因为这个因素只决定了实现层次的优化和考虑，而和怎么解决整个问题的思想无关。</p>
<h2 id="对数器"><a href="#对数器" class="headerlink" title="对数器"></a>对数器</h2><h3 id="1、什么是对数器"><a href="#1、什么是对数器" class="headerlink" title="1、什么是对数器"></a>1、什么是对数器</h3><blockquote>
<p>认识对数器</p>
</blockquote>
<p>1，你想要测的方法a<br>2，实现复杂度不好但是容易实现的方法b<br>3，实现一个随机样本产生器<br>4，把方法a和方法b跑相同的随机样本，看看得到的结果是否一样<br>5，如果有一个随机样本使得比对结果不一致，打印样本进行人工干预，改对方法a和方法b<br>6，当样本数量很多时比对测试依然正确，可以确定方法a已经正确。</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] generateRandomArray(<span class="hljs-keyword">int</span> maxSize, <span class="hljs-keyword">int</span> maxValue) &#123;
   <span class="hljs-comment">// Math.random() -&gt;  [0,1) 所有的小数，等概率返回一个</span>
   <span class="hljs-comment">// Math.random() * N -&gt; [0,N) 所有小数，等概率返回一个</span>
   <span class="hljs-comment">// (int)(Math.random() * N) -&gt; [0,N-1] 所有的整数，等概率返回一个</span>
   <span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[(<span class="hljs-keyword">int</span>) ((maxSize + <span class="hljs-number">1</span>) * Math.random())]; <span class="hljs-comment">// 长度随机 </span>
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;
      <span class="hljs-comment">// [-?,+?]</span>
      arr[i] = (<span class="hljs-keyword">int</span>) ((maxValue + <span class="hljs-number">1</span>) * Math.random()) 
            - (<span class="hljs-keyword">int</span>) (maxValue * Math.random());
   &#125;
   <span class="hljs-keyword">return</span> arr;
&#125;
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">comparator</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;
		Arrays.sort(arr);
	&#125;
<span class="hljs-comment">// for copy</span>
	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] copyArray(<span class="hljs-keyword">int</span>[] arr) &#123;
		<span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span>) &#123;
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
		&#125;
		<span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[arr.length];
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;
			res[i] = arr[i];
		&#125;
		<span class="hljs-keyword">return</span> res;
	&#125;

	<span class="hljs-comment">// for compare</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEqual</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr1, <span class="hljs-keyword">int</span>[] arr2)</span> </span>&#123;
		<span class="hljs-keyword">if</span> ((arr1 == <span class="hljs-keyword">null</span> &amp;&amp; arr2 != <span class="hljs-keyword">null</span>) || (arr1 != <span class="hljs-keyword">null</span> &amp;&amp; arr2 == <span class="hljs-keyword">null</span>)) &#123;
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
		&#125;
		<span class="hljs-keyword">if</span> (arr1 == <span class="hljs-keyword">null</span> &amp;&amp; arr2 == <span class="hljs-keyword">null</span>) &#123;
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
		&#125;
		<span class="hljs-keyword">if</span> (arr1.length != arr2.length) &#123;
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
		&#125;
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr1.length; i++) &#123;
			<span class="hljs-keyword">if</span> (arr1[i] != arr2[i]) &#123;
				<span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
			&#125;
		&#125;
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
	&#125;</code></pre></div>

<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// for test</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
   <span class="hljs-keyword">int</span> testTime = <span class="hljs-number">500000</span>;
   <span class="hljs-keyword">int</span> maxSize = <span class="hljs-number">100</span>; <span class="hljs-comment">// 随机数组的长度0～100</span>
   <span class="hljs-keyword">int</span> maxValue = <span class="hljs-number">100</span>;<span class="hljs-comment">// 值：-100～100</span>
   <span class="hljs-keyword">boolean</span> succeed = <span class="hljs-keyword">true</span>;
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; testTime; i++) &#123;
      <span class="hljs-keyword">int</span>[] arr1 = generateRandomArray(maxSize, maxValue);
      <span class="hljs-keyword">int</span>[] arr2 = copyArray(arr1);
      insertionSort(arr1);
      comparator(arr2);
      <span class="hljs-keyword">if</span> (!isEqual(arr1, arr2)) &#123;
         <span class="hljs-comment">// 打印arr1</span>
         <span class="hljs-comment">// 打印arr2</span>
         succeed = <span class="hljs-keyword">false</span>;
         <span class="hljs-keyword">break</span>;
      &#125;
   &#125;
   System.out.println(succeed ? <span class="hljs-string">&quot;Nice!&quot;</span> : <span class="hljs-string">&quot;Fucking fucked!&quot;</span>);

   <span class="hljs-keyword">int</span>[] arr = generateRandomArray(maxSize, maxValue);
   printArray(arr);
   insertionSort(arr);
   printArray(arr);
&#125;</code></pre></div>

<h2 id="认识二分法"><a href="#认识二分法" class="headerlink" title="认识二分法"></a>认识二分法</h2><blockquote>
<p> 经常见到的类型是在一个有序数组上，开展二分搜索，但有序真的是所有问题求解时使用二分的必要条件吗？<br>不！<br>只要能正确构建左右两侧的淘汰逻辑，你就可以二分。</p>
</blockquote>
<h3 id="1、在一个有序数组中，找某个数是否存在"><a href="#1、在一个有序数组中，找某个数是否存在" class="headerlink" title="1、在一个有序数组中，找某个数是否存在"></a>1、在一个有序数组中，找某个数是否存在</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">exist</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] sortedArr, <span class="hljs-keyword">int</span> num)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (sortedArr == <span class="hljs-keyword">null</span> || sortedArr.length == <span class="hljs-number">0</span>) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
   &#125;
   <span class="hljs-keyword">int</span> L = <span class="hljs-number">0</span>;
   <span class="hljs-keyword">int</span> R = sortedArr.length - <span class="hljs-number">1</span>;
   <span class="hljs-keyword">int</span> mid = <span class="hljs-number">0</span>;
   <span class="hljs-comment">// L..R</span>
   <span class="hljs-keyword">while</span> (L &lt; R) &#123;
      <span class="hljs-comment">// 防L R 因数值过大 相加后溢出</span>
      mid = L + ((R - L) &gt;&gt; <span class="hljs-number">1</span>); <span class="hljs-comment">// mid = (L + R) / 2</span>
      <span class="hljs-keyword">if</span> (sortedArr[mid] == num) &#123;
         <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sortedArr[mid] &gt; num) &#123;
         R = mid - <span class="hljs-number">1</span>;
      &#125; <span class="hljs-keyword">else</span> &#123;
         L = mid + <span class="hljs-number">1</span>;
      &#125;
   &#125;
   <span class="hljs-keyword">return</span> sortedArr[L] == num;
&#125;</code></pre></div>

<h3 id="2、在一个有序数组中，找-gt-某个数最左侧的位置"><a href="#2、在一个有序数组中，找-gt-某个数最左侧的位置" class="headerlink" title="2、在一个有序数组中，找&gt;=某个数最左侧的位置"></a>2、在一个有序数组中，找&gt;=某个数最左侧的位置</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// 在arr上，找满足&gt;=value的最左位置</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">nearestIndex</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> value)</span></span>&#123;
    <span class="hljs-keyword">int</span> L = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> R = arr.length - <span class="hljs-number">1</span>;
    <span class="hljs-keyword">int</span> index = -<span class="hljs-number">1</span>; <span class="hljs-comment">// 记录最左的对号</span>
    <span class="hljs-keyword">while</span> (L &lt;= R)&#123;
        <span class="hljs-keyword">int</span> mid = L + ((R - L) &gt;&gt; <span class="hljs-number">1</span>);
        <span class="hljs-keyword">if</span> (arr[mid] &gt;= value) &#123;
            index = mid;
            R = mid - <span class="hljs-number">1</span>;
        &#125; <span class="hljs-keyword">else</span> &#123;
            L = mid + <span class="hljs-number">1</span>;
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> index;
&#125;</code></pre></div>

<h3 id="3、-在一个有序数组中，找-lt-某个数最右侧的位置"><a href="#3、-在一个有序数组中，找-lt-某个数最右侧的位置" class="headerlink" title="3、 在一个有序数组中，找&lt;=某个数最右侧的位置"></a>3、 在一个有序数组中，找&lt;=某个数最右侧的位置</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// 在arr上，找满足&lt;=value的最右位置</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">nearestIndex</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> value)</span> </span>&#123;
    <span class="hljs-keyword">int</span> L = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> R = arr.length - <span class="hljs-number">1</span>;
    <span class="hljs-keyword">int</span> index = -<span class="hljs-number">1</span>; <span class="hljs-comment">// 记录最右的对号</span>
    <span class="hljs-keyword">while</span> (L &lt;= R) &#123;
        <span class="hljs-keyword">int</span> mid = L + ((R - L) &gt;&gt; <span class="hljs-number">1</span>);
        <span class="hljs-keyword">if</span> (arr[mid] &lt;= value) &#123;
            index = mid;
            L = mid + <span class="hljs-number">1</span>;
        &#125; <span class="hljs-keyword">else</span> &#123;
            R = mid - <span class="hljs-number">1</span>;
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> index;
&#125;</code></pre></div>

<h3 id="4、-局部最小值问题"><a href="#4、-局部最小值问题" class="headerlink" title="4、 局部最小值问题"></a>4、 局部最小值问题</h3><blockquote>
<ol>
<li>arr[0]&lt;arr[1]</li>
<li>Arr[len-1]&lt;Arr[len-2]</li>
<li>arr[i-1]&lt;arr[i]&lt;arr[i+1]</li>
</ol>
</blockquote>
<p>arr无序, 任意两个相邻数不相等, 只需返回一个局部最小位置:</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getLessIndex</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length == <span class="hljs-number">0</span>) &#123;
      <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">// no exist</span>
   &#125;
   <span class="hljs-keyword">if</span> (arr.length == <span class="hljs-number">1</span> || arr[<span class="hljs-number">0</span>] &lt; arr[<span class="hljs-number">1</span>]) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
   &#125;
   <span class="hljs-keyword">if</span> (arr[arr.length - <span class="hljs-number">1</span>] &lt; arr[arr.length - <span class="hljs-number">2</span>]) &#123;
      <span class="hljs-keyword">return</span> arr.length - <span class="hljs-number">1</span>;
   &#125;
   <span class="hljs-keyword">int</span> left = <span class="hljs-number">1</span>;
   <span class="hljs-keyword">int</span> right = arr.length - <span class="hljs-number">2</span>;
   <span class="hljs-keyword">int</span> mid = <span class="hljs-number">0</span>;
   <span class="hljs-keyword">while</span> (left &lt; right) &#123;
      mid = (left + right) / <span class="hljs-number">2</span>;
      <span class="hljs-keyword">if</span> (arr[mid] &gt; arr[mid - <span class="hljs-number">1</span>]) &#123;
         right = mid - <span class="hljs-number">1</span>;
      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[mid] &gt; arr[mid + <span class="hljs-number">1</span>]) &#123;
         left = mid + <span class="hljs-number">1</span>;
      &#125; <span class="hljs-keyword">else</span> &#123;
         <span class="hljs-keyword">return</span> mid;
      &#125;
   &#125;
   <span class="hljs-keyword">return</span> left;
&#125;</code></pre></div>

<h2 id="认识异或运算"><a href="#认识异或运算" class="headerlink" title="认识异或运算"></a>认识异或运算</h2><h3 id="1、如何记住"><a href="#1、如何记住" class="headerlink" title="1、如何记住"></a>1、如何记住</h3><p>异或运算：相同为0，不同为1<br>同或运算：相同以1，不同为0</p>
<blockquote>
<p>能长时间记住的概率接近0%</p>
<p>所以，异或运算就记成无进位相加！ </p>
</blockquote>
<h3 id="2、异或运算的性质"><a href="#2、异或运算的性质" class="headerlink" title="2、异或运算的性质"></a>2、异或运算的性质</h3><p>0^N == N      N^N == 0<br>异或运算满足交换律和结合率</p>
<p>上面的两个性质用无进位相加来理解就非常的容易</p>
<h3 id="3、如何不用额外变量交换两个数"><a href="#3、如何不用额外变量交换两个数" class="headerlink" title="3、如何不用额外变量交换两个数"></a>3、如何不用额外变量交换两个数</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;
    arr[i] = arr[i] ^ arr[j];
    arr[j] = arr[i] ^ arr[j];
    arr[i] = arr[i] ^ arr[j];
&#125;</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201125212731.png" srcset="/img/loading.gif" alt="结构"></p>
<blockquote>
<p>注意:     i和j是一个位置的话，会出错，指向的内存要求是不一样的，各自独立的。</p>
</blockquote>
<h3 id="4、一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这种数"><a href="#4、一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这种数" class="headerlink" title="4、一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这种数"></a>4、一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这种数</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// arr中，只有一种数，出现奇数次</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printOddTimesNum1</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;
   <span class="hljs-keyword">int</span> eor = <span class="hljs-number">0</span>;
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;
      eor ^= arr[i];
   &#125;
   System.out.println(eor);
&#125;</code></pre></div>

<h3 id="5、怎么把一个int类型的数，提取出最右侧的1来"><a href="#5、怎么把一个int类型的数，提取出最右侧的1来" class="headerlink" title="5、怎么把一个int类型的数，提取出最右侧的1来"></a>5、怎么把一个int类型的数，提取出最右侧的1来</h3><p>N &amp; ((~N)+1)</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img9SF_F0USXR87N%TE$HW3L80.png" srcset="/img/loading.gif" alt="1"></p>
<h3 id="6、一个数组中有两种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这两种数"><a href="#6、一个数组中有两种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这两种数" class="headerlink" title="6、一个数组中有两种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这两种数"></a>6、一个数组中有两种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这两种数</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// arr中，有两种数，出现奇数次</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printOddTimesNum2</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;
   <span class="hljs-keyword">int</span> eor = <span class="hljs-number">0</span>;
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;
      eor ^= arr[i];
   &#125;
   <span class="hljs-comment">// eor = a ^ b</span>
   <span class="hljs-comment">// eor != 0</span>
   <span class="hljs-comment">// eor必然有一个位置上是1</span>
   <span class="hljs-keyword">int</span> rightOne = eor &amp; (~eor + <span class="hljs-number">1</span>); <span class="hljs-comment">// 提取出最右的1</span>
   <span class="hljs-keyword">int</span> onlyOne = <span class="hljs-number">0</span>; <span class="hljs-comment">// eor&#x27;</span>
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; arr.length;i++) &#123;
      <span class="hljs-keyword">if</span> ((arr[i] &amp; rightOne) != <span class="hljs-number">0</span>) &#123;
         onlyOne ^= arr[i];
      &#125;
   &#125;
   System.out.println(onlyOne + <span class="hljs-string">&quot; &quot;</span> + (eor ^ onlyOne));
&#125;</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201125220723.png" srcset="/img/loading.gif" alt="图解"></p>
<h1 id="链表结构、栈、队列、递归行为、哈希表"><a href="#链表结构、栈、队列、递归行为、哈希表" class="headerlink" title="链表结构、栈、队列、递归行为、哈希表"></a>链表结构、栈、队列、递归行为、哈希表</h1><h2 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h2><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> value;
    <span class="hljs-keyword">public</span> Node next;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.value = data;
    &#125;
&#125;</code></pre></div>

<h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DoubleNode</span> </span>&#123;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> value;
    <span class="hljs-keyword">public</span> DoubleNode last;
    <span class="hljs-keyword">public</span> DoubleNode next;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DoubleNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.value = data;
    &#125;
&#125;</code></pre></div>

<h2 id="单向链表和双向链表最简单的练习"><a href="#单向链表和双向链表最简单的练习" class="headerlink" title="单向链表和双向链表最简单的练习"></a>单向链表和双向链表最简单的练习</h2><blockquote>
<p> 链表相关的问题几乎都是coding问题</p>
</blockquote>
<ul>
<li><p>单链表和双链表如何反转</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">reverseLinkedList</span><span class="hljs-params">(Node head)</span> </span>&#123;
   Node pre = <span class="hljs-keyword">null</span>;
   Node next = <span class="hljs-keyword">null</span>;
   <span class="hljs-keyword">while</span> (head != <span class="hljs-keyword">null</span>) &#123;
      next = head.next; <span class="hljs-comment">// 记录head下一个</span>
      head.next = pre; <span class="hljs-comment">// 让head指向pre</span>
      pre = head; <span class="hljs-comment">// 记录初始head</span>
      head = next;<span class="hljs-comment">// head跳到下一个</span>
   &#125;
   <span class="hljs-keyword">return</span> pre;
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> DoubleNode <span class="hljs-title">reverseDoubleList</span><span class="hljs-params">(DoubleNode head)</span></span>&#123;
    DoubleNode pre = <span class="hljs-keyword">null</span>;
    DoubleNode next = <span class="hljs-keyword">null</span>;
    <span class="hljs-keyword">while</span> (head != <span class="hljs-keyword">null</span>)&#123;
        next = head.next;
        head.next = pre;
        head.last = next;
        pre = head;
        head = next;
    &#125;
    <span class="hljs-keyword">return</span> pre;
&#125;</code></pre></div>
</li>
<li><p>把给定值都删除</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">removeValue</span><span class="hljs-params">(Node head, <span class="hljs-keyword">int</span> num)</span></span>&#123;
    <span class="hljs-comment">// 先找到值不是value的结点，作为头结点</span>
    <span class="hljs-keyword">while</span> (head != <span class="hljs-keyword">null</span>)&#123;
        <span class="hljs-keyword">if</span> (head.value != num)&#123;
            <span class="hljs-keyword">break</span>;
        &#125;
        head = head.next;
    &#125;

    <span class="hljs-comment">// 找到后, 删除后面的</span>
    Node pre = head; <span class="hljs-comment">// 记录上一个不等于num的位置</span>
    Node cur = head; <span class="hljs-comment">// cur作为条件, 每次跳一次, 遍历链表</span>
    <span class="hljs-keyword">while</span> (cur != <span class="hljs-keyword">null</span>)&#123;
        <span class="hljs-keyword">if</span> (cur.value == num)&#123;
            pre.next = cur.next;
        &#125;<span class="hljs-keyword">else</span> &#123;
            pre = cur;
        &#125;
        cur = cur.next;
    &#125;
    <span class="hljs-keyword">return</span> head;
&#125;</code></pre></div>

</li>
</ul>
<p>这里就是熟悉结构。链表还有哪些常见面试题，后续有专门系统学习。</p>
<h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h2><blockquote>
<p>逻辑概念<br>栈：数据先进后出，犹如弹匣<br>队列：数据先进先出，好似排队</p>
</blockquote>
<h2 id="栈和队列的实际实现"><a href="#栈和队列的实际实现" class="headerlink" title="栈和队列的实际实现"></a>栈和队列的实际实现</h2><ul>
<li><p>双向链表实现</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;
    <span class="hljs-keyword">public</span> T value;
    <span class="hljs-keyword">public</span> Node&lt;T&gt; last;
    <span class="hljs-keyword">public</span> Node&lt;T&gt; next;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(T data)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.value = data;
    &#125;
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DoubleEndsQueue</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;

    <span class="hljs-keyword">public</span> Node&lt;T&gt; head;
    <span class="hljs-keyword">public</span> Node&lt;T&gt; tail;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addFromHead</span><span class="hljs-params">(T value)</span> </span>&#123;
        Node&lt;T&gt; cur = <span class="hljs-keyword">new</span> Node&lt;&gt;(value);
        <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>)&#123;
            head = cur;
            tail = cur;
        &#125;<span class="hljs-keyword">else</span> &#123;
            <span class="hljs-comment">// 改变结点</span>
            cur.next =  head;
            head.last = cur;
            <span class="hljs-comment">// 变更新的头结点</span>
            head = cur;
        &#125;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addFromBottom</span><span class="hljs-params">(T value)</span> </span>&#123;
        Node&lt;T&gt; cur = <span class="hljs-keyword">new</span> Node&lt;&gt;(value);
        <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>)&#123;
            head = cur;
            tail = cur;
        &#125;<span class="hljs-keyword">else</span> &#123;
            <span class="hljs-comment">// 改变结点</span>
            cur.last = tail;
            tail.next = cur;
            tail = cur;
        &#125;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">popFromHead</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>)&#123;
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
        &#125;
        Node&lt;T&gt; cur = head;
        <span class="hljs-keyword">if</span> (head == tail)&#123;
            head = <span class="hljs-keyword">null</span>;
            tail = <span class="hljs-keyword">null</span>;
        &#125;<span class="hljs-keyword">else</span> &#123;
            head = head.next;
            cur.next = <span class="hljs-keyword">null</span>;
            head.last = <span class="hljs-keyword">null</span>;
        &#125;
        <span class="hljs-keyword">return</span> cur.value;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">popFromBottom</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>)&#123;
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
        &#125;
        Node&lt;T&gt; cur = tail;
        <span class="hljs-keyword">if</span> (head == tail)&#123;
            head = <span class="hljs-keyword">null</span>;
            tail = <span class="hljs-keyword">null</span>;
        &#125;<span class="hljs-keyword">else</span> &#123;
            tail = tail.last;
            tail.next = <span class="hljs-keyword">null</span>;
            cur.last = <span class="hljs-keyword">null</span>;
        &#125;
        <span class="hljs-keyword">return</span> cur.value;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> head == <span class="hljs-keyword">null</span>;
    &#125;
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyStack</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;
    <span class="hljs-keyword">private</span> DoubleEndsQueue&lt;T&gt; queue;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyStack</span><span class="hljs-params">()</span> </span>&#123;
        queue = <span class="hljs-keyword">new</span> DoubleEndsQueue&lt;&gt;();
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(T value)</span></span>&#123;
        queue.addFromHead(value);
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>&#123;
        <span class="hljs-keyword">return</span> queue.popFromHead();
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span></span>&#123;
        <span class="hljs-keyword">return</span> queue.isEmpty();
    &#125;
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyQueue</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;
    <span class="hljs-keyword">private</span> DoubleEndsQueue&lt;T&gt; queue;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyQueue</span><span class="hljs-params">()</span> </span>&#123;
        queue = <span class="hljs-keyword">new</span> DoubleEndsQueue&lt;&gt;();
    &#125;

    <span class="hljs-comment">// 出push</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(T value)</span></span>&#123;
        queue.addFromHead(value);
    &#125;

    <span class="hljs-comment">// 进poll</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">poll</span><span class="hljs-params">()</span></span>&#123;
        <span class="hljs-keyword">return</span> queue.popFromBottom();
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span></span>&#123;
        <span class="hljs-keyword">return</span> queue.isEmpty();
    &#125;
&#125;</code></pre></div>
</li>
<li><p>数组实现</p>
<blockquote>
<p>数组实现栈</p>
</blockquote>
</li>
</ul>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayStack</span> </span>&#123;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span>[] a;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size;<span class="hljs-comment">//栈数组的大小</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> top;<span class="hljs-comment">//栈顶</span>

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayStack</span><span class="hljs-params">(<span class="hljs-keyword">int</span> maxSize)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.size = maxSize;
        <span class="hljs-keyword">this</span>.a = <span class="hljs-keyword">new</span> <span class="hljs-keyword">long</span>[size];
        <span class="hljs-keyword">this</span>.top = -<span class="hljs-number">1</span>;<span class="hljs-comment">//表示空栈</span>
    &#125;

    <span class="hljs-comment">//入栈</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">long</span> value)</span></span>&#123;
        <span class="hljs-keyword">if</span>(isFull())&#123;
            System.out.println(<span class="hljs-string">&quot;栈已经满！&quot;</span>);
            <span class="hljs-keyword">return</span>;
        &#125;
        a[++top] = value;
    &#125;

    <span class="hljs-comment">//返回栈顶内容，但是不删除</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">peek</span><span class="hljs-params">()</span></span>&#123;
        <span class="hljs-keyword">if</span>(isEmpty())&#123;
            System.out.println(<span class="hljs-string">&quot;栈中没有数据！&quot;</span>);
        &#125;
        System.out.println(a[top]);
    &#125;

    <span class="hljs-comment">//弹出栈顶内容，删除</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>&#123;
        <span class="hljs-keyword">if</span>(isEmpty())&#123;
            System.out.println(<span class="hljs-string">&quot;栈中没有数据！&quot;</span>);
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        &#125;
        <span class="hljs-keyword">return</span> a[top--];
    &#125;

    <span class="hljs-comment">//size栈的大小</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span></span>&#123;
        <span class="hljs-keyword">return</span> top + <span class="hljs-number">1</span>;
    &#125;

    <span class="hljs-comment">//是否为空</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> (top == -<span class="hljs-number">1</span>);
    &#125;

    <span class="hljs-comment">//是否满了</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isFull</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> (top == size - <span class="hljs-number">1</span>);
    &#125;

    <span class="hljs-comment">//显示</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span></span>&#123;
        System.out.print(<span class="hljs-string">&quot;[&quot;</span>);
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = top; i &gt;=<span class="hljs-number">0</span> ; i--) &#123;
            System.out.print(a[i]);
            <span class="hljs-keyword">if</span>(i!=<span class="hljs-number">0</span>)&#123;
                System.out.print(<span class="hljs-string">&quot;,&quot;</span>);
            &#125;
        &#125;
        System.out.println(<span class="hljs-string">&quot;]&quot;</span>);
    &#125;
&#125;</code></pre></div>

<blockquote>
<p>数组实现队列</p>
</blockquote>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyQueue</span> </span>&#123;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] arr;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> pushi;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> polli;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> limit;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyQueue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> limit)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[limit];
        <span class="hljs-keyword">this</span>.pushi = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">this</span>.polli = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">this</span>.size = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">this</span>.limit = limit;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (size == limit)&#123;
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;栈满了，不能再加了&quot;</span>);
        &#125;
        size++;
        arr[pushi] = value;
        pushi = nextIndex(pushi);
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">poll</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">if</span> (size == <span class="hljs-number">0</span>)&#123;
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;栈空了，不能再拿了&quot;</span>);
        &#125;
        size--;
        <span class="hljs-keyword">int</span> ans = arr[polli];
        polli = nextIndex(polli);
        <span class="hljs-keyword">return</span> ans;
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> size == <span class="hljs-number">0</span>;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">nextIndex</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>&#123;
        <span class="hljs-keyword">return</span> i &lt; limit - <span class="hljs-number">1</span> ? i + <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;
    &#125;
&#125;</code></pre></div>

<h2 id="栈和队列的常见面试题"><a href="#栈和队列的常见面试题" class="headerlink" title="栈和队列的常见面试题"></a>栈和队列的常见面试题</h2><h3 id="1、实现一个特殊的栈，在基本功能的基础上，再实现返回栈中最小元素的功能"><a href="#1、实现一个特殊的栈，在基本功能的基础上，再实现返回栈中最小元素的功能" class="headerlink" title="1、实现一个特殊的栈，在基本功能的基础上，再实现返回栈中最小元素的功能"></a>1、实现一个特殊的栈，在基本功能的基础上，再实现返回栈中最小元素的功能</h3><blockquote>
<p>1）pop、push、getMin操作的时间复杂度都是 O(1)。 </p>
<p>2）设计的栈类型可以使用现成的栈结构。</p>
</blockquote>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201128160516.png" srcset="/img/loading.gif" alt="实现"></p>
<p> <strong>当前数和最小栈栈顶做比较, 谁小加谁</strong>,  弹出一起弹出 —–&gt; MyStack2</p>
<p> <strong>当前数和最小栈栈顶做比较, 只有小于最小栈栈顶才压入</strong>,弹出如果Data Peek = Min Peek, 一起弹出 —–&gt; MyStack1</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 想要压入的数比最小栈大 不压入, 小于等于压入</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyStack1</span> </span>&#123;
    <span class="hljs-keyword">private</span> Stack&lt;Integer&gt; stackData;
    <span class="hljs-keyword">private</span> Stack&lt;Integer&gt; stackMin;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyStack1</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">this</span>.stackData = <span class="hljs-keyword">new</span> Stack&lt;Integer&gt;();
        <span class="hljs-keyword">this</span>.stackMin = <span class="hljs-keyword">new</span> Stack&lt;Integer&gt;();
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> newNum)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.stackMin.isEmpty()) &#123;
            <span class="hljs-keyword">this</span>.stackMin.push(newNum);
        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (newNum &lt;= <span class="hljs-keyword">this</span>.getmin()) &#123;
            <span class="hljs-keyword">this</span>.stackMin.push(newNum);
        &#125;
        <span class="hljs-keyword">this</span>.stackData.push(newNum);
    &#125;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 弹出如果Data栈弹出的数等于最小栈栈顶则弹出</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.stackData.isEmpty()) &#123;
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;Your stack is empty.&quot;</span>);
        &#125;
        <span class="hljs-keyword">int</span> value = <span class="hljs-keyword">this</span>.stackData.pop();
        <span class="hljs-keyword">if</span> (value == <span class="hljs-keyword">this</span>.getmin()) &#123;
            <span class="hljs-keyword">this</span>.stackMin.pop();
        &#125;
        <span class="hljs-keyword">return</span> value;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getmin</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.stackMin.isEmpty()) &#123;
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;Your stack is empty.&quot;</span>);
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.stackMin.peek();
    &#125;
&#125;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 想要压入的数比最小栈大 重复压入最小栈栈顶</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyStack2</span> </span>&#123;
    <span class="hljs-keyword">private</span> Stack&lt;Integer&gt; stackData;
    <span class="hljs-keyword">private</span> Stack&lt;Integer&gt; stackMin;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyStack2</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">this</span>.stackData = <span class="hljs-keyword">new</span> Stack&lt;Integer&gt;();
        <span class="hljs-keyword">this</span>.stackMin = <span class="hljs-keyword">new</span> Stack&lt;Integer&gt;();
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> newNum)</span></span>&#123;
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.stackMin.isEmpty())&#123;
            <span class="hljs-comment">// 如果最小栈没有元素 直接压入</span>
            <span class="hljs-keyword">this</span>.stackMin.push(newNum);
        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (newNum &lt; <span class="hljs-keyword">this</span>.getMin())&#123;
            <span class="hljs-comment">// 如果最小栈栈顶小于newNum</span>
            <span class="hljs-keyword">this</span>.stackMin.push(newNum);
        &#125;<span class="hljs-keyword">else</span> &#123;
            <span class="hljs-comment">// 如果最小栈栈顶大于newNum, 重复压入栈顶元素</span>
            <span class="hljs-keyword">int</span> minNum = <span class="hljs-keyword">this</span>.getMin();
            <span class="hljs-keyword">this</span>.stackMin.push(minNum);
        &#125;
        <span class="hljs-keyword">this</span>.stackData.push(newNum);
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.stackData.isEmpty()) &#123;
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;Your stack is empty.&quot;</span>);
        &#125;
        <span class="hljs-keyword">this</span>.stackMin.pop();
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.stackData.pop();
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMin</span><span class="hljs-params">()</span></span>&#123;
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.stackMin.isEmpty())&#123;
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;Your stack is empty.&quot;</span>);
        &#125;

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.stackMin.peek();
    &#125;
&#125;</code></pre></div>

<h3 id="2、栈与队列互相实现"><a href="#2、栈与队列互相实现" class="headerlink" title="2、栈与队列互相实现"></a>2、栈与队列互相实现</h3><blockquote>
<p>1）如何用栈结构实现队列结构</p>
</blockquote>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TwoStacksQueue</span> </span>&#123;
        <span class="hljs-keyword">public</span> Stack&lt;Integer&gt; stackPush;
        <span class="hljs-keyword">public</span> Stack&lt;Integer&gt; stackPop;

        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TwoStacksQueue</span><span class="hljs-params">()</span> </span>&#123;
            stackPush = <span class="hljs-keyword">new</span> Stack&lt;Integer&gt;();
            stackPop = <span class="hljs-keyword">new</span> Stack&lt;Integer&gt;();
        &#125;

        <span class="hljs-comment">// push栈向pop栈倒入数据</span>
        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pushToPop</span><span class="hljs-params">()</span> </span>&#123;
            <span class="hljs-keyword">if</span> (stackPop.empty())&#123;
                <span class="hljs-keyword">while</span> (!stackPush.empty())&#123;
                    stackPop.push(stackPush.pop());
                &#125;
            &#125;
        &#125;

        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pushInt)</span></span>&#123;
            stackPush.push(pushInt);
<span class="hljs-comment">//            pushToPop();</span>
        &#125;

        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">poll</span><span class="hljs-params">()</span></span>&#123;
            <span class="hljs-keyword">if</span> (stackPop.empty() &amp;&amp; stackPush.empty()) &#123;
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;Queue is empty!&quot;</span>);
            &#125;
            pushToPop();
            <span class="hljs-keyword">return</span> stackPop.pop();
        &#125;

        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">peek</span><span class="hljs-params">()</span> </span>&#123;
            <span class="hljs-keyword">if</span> (stackPop.empty() &amp;&amp; stackPush.empty()) &#123;
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;Queue is empty!&quot;</span>);
            &#125;
            pushToPop();
            <span class="hljs-keyword">return</span> stackPop.peek();
        &#125;
    &#125;</code></pre></div>

<blockquote>
<p>2）如何用队列结构实现栈结构</p>
</blockquote>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TwoQueueStack</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;
    <span class="hljs-keyword">public</span> Queue&lt;T&gt; queue;
    <span class="hljs-keyword">public</span> Queue&lt;T&gt; help;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TwoQueueStack</span><span class="hljs-params">()</span> </span>&#123;
        queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();
        help = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(T value)</span></span>&#123; queue.offer(value);&#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">poll</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">while</span> (queue.size() &gt; <span class="hljs-number">1</span>)&#123;
            help.offer(queue.poll());
        &#125;
        T ans = queue.poll();
        Queue&lt;T&gt; temp = queue;
        queue = help;
        help = temp;
        <span class="hljs-keyword">return</span> ans;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">peek</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">while</span> (queue.size() &gt; <span class="hljs-number">1</span>)&#123;
            help.offer(queue.poll());
        &#125;
        T ans = queue.peek();
        Queue&lt;T&gt; temp = queue;
        queue = help;
        help = temp;
        queue.offer(ans);
        <span class="hljs-keyword">return</span> ans;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> queue.isEmpty();
    &#125;
&#125;</code></pre></div>

<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><blockquote>
<p>怎么从思想上理解递归</p>
</blockquote>
<p>求数组arr[L..R]中的最大值，怎么用递归方法实现。</p>
<p>1）将[L..R]范围分成左右两半。左：[L..Mid]  右[Mid+1..R]<br>2）左部分求最大值，右部分求最大值<br>3） [L..R]范围上的最大值，是max{左部分最大值，右部分最大值}</p>
<p>注意：2）是个递归过程，当范围上只有一个数，就可以不用再递归了</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// 求arr中的最大值</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMax</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;
    <span class="hljs-keyword">return</span> process(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>);
&#125;

<span class="hljs-comment">// arr[L..R]范围上求最大值  L ... R   N</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">process</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R)</span> </span>&#123;
    <span class="hljs-keyword">if</span> (L == R) &#123; <span class="hljs-comment">// arr[L..R]范围上只有一个数，直接返回，base case</span>
        <span class="hljs-keyword">return</span> arr[L];
    &#125;
    <span class="hljs-keyword">int</span> mid = L + ((R - L) &gt;&gt; <span class="hljs-number">1</span>); <span class="hljs-comment">// 中点    1</span>
    <span class="hljs-keyword">int</span> leftMax = process(arr, L, mid);
    <span class="hljs-keyword">int</span> rightMax = process(arr, mid + <span class="hljs-number">1</span>, R);
    <span class="hljs-keyword">return</span> Math.max(leftMax, rightMax);
&#125;</code></pre></div>



<h3 id="递归的脑图和实际实现"><a href="#递归的脑图和实际实现" class="headerlink" title="递归的脑图和实际实现"></a>递归的脑图和实际实现</h3><p>对于新手来说，把调用的过程画出结构图是必须的，这有利于分析递归</p>
<p>递归并不是玄学，递归底层是利用系统栈来实现的</p>
<p>任何递归函数都一定可以改成非递归</p>
<h3 id="Master公式"><a href="#Master公式" class="headerlink" title="Master公式"></a>Master公式</h3><blockquote>
<p>形如T(N) = a * T(N/b) + O(N^d)(其中的a、b、d都是常数)的递归函数，可以直接通过Master公式来确定时间复杂度, a次子问题规模(总问题是子问题的b倍规模)</p>
</blockquote>
<p>以b为底, logb(a)</p>
<p>如果 log(b,a) &lt; d，复杂度为O(N^d)<br>如果 log(b,a) &gt; d，复杂度为O(N^log(b,a))<br>如果 log(b,a) == d，复杂度为O(N^d  * logN)</p>
<p>上述算法中, 把数组分成两份, 每份1/2, 其他时间复杂度为O(1)</p>
<p>T(N) = 2 * T(N/2) + O(N^0) 即O(N), 与从左往右遍历一遍是一样的</p>
<p>如果左边2/3, 右边也2/3, 也是两份, 其他再打印一次, 时间复杂度为O(n)</p>
<p>T(N) = 2 * T(N/(3/2)) + O(N^1)</p>
<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>1)哈希表在使用层面上可以理解为一种集合结构<br>2)如果只有key，没有伴随数据value，可以使用 <strong><em>HashSet</em></strong>结构<br>3)如果既有key，又有伴随数据value，可以使用 <strong><em>HashMap</em></strong>结构<br>4) <strong><em>有无伴随数据，是HashMap和HashSet唯一的区别，实际结构是一回事</em></strong><br>5)使用哈希表增(put)、删(remove)、改(put)和查(get)的操作，可以认为时间复杂度为 O(1)，但是 <strong><em>常数时间</em></strong>比较大<br>6)放入哈希表的东西，如果是基础类型， <strong><em>内部按值传递</em></strong>，内存占用是这个东西的大小 </p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">int</span> a = <span class="hljs-number">100000</span>;
<span class="hljs-keyword">int</span> b = <span class="hljs-number">100000</span>;
<span class="hljs-comment">// 不关心内存区域, 只关心对应的值</span>
System.out.println(a == b);
Integer c = <span class="hljs-number">100000</span>;
Integer d = <span class="hljs-number">100000</span>;
<span class="hljs-comment">// 关心内存区域</span>
System.out.println(c.equals(d));
Integer e = <span class="hljs-number">127</span>;  <span class="hljs-comment">//  - 128  ~  127 true, 按值传递</span>
Integer f = <span class="hljs-number">127</span>;
System.out.println(e == f);

<span class="hljs-comment">// 但是在哈希表中, 基础类型, 内部都按值传递</span></code></pre></div>



<p>7)放入哈希表的东西，如果不是基础类型， <strong><em>内部按引用传递</em></strong>，内存占用是8字节</p>
<div class="hljs"><pre><code class="hljs java">HashMap&lt;Node, String&gt; map2 = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
Node node1 = <span class="hljs-keyword">new</span> Node(<span class="hljs-number">1</span>);
Node node2 = node1;
map2.put(node1, <span class="hljs-string">&quot;我是node1&quot;</span>);
map2.put(node2, <span class="hljs-string">&quot;我是node1&quot;</span>);
System.out.println(map2.size());
<span class="hljs-comment">// 结果为 1</span></code></pre></div>

<div class="hljs"><pre><code class="hljs java">HashMap&lt;Node, String&gt; map2 = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
Node node1 = <span class="hljs-keyword">new</span> Node(<span class="hljs-number">1</span>);
Node node2 = <span class="hljs-keyword">new</span> Node(<span class="hljs-number">2</span>);
map2.put(node1, <span class="hljs-string">&quot;我是node1&quot;</span>);
map2.put(node2, <span class="hljs-string">&quot;我是node1&quot;</span>);
System.out.println(map2.size());
<span class="hljs-comment">// 结果为 2</span></code></pre></div>



<div class="hljs"><pre><code class="hljs processing">即如果<span class="hljs-keyword">HashMap</span>&lt;<span class="hljs-keyword">String</span>, <span class="hljs-keyword">String</span>&gt; <span class="hljs-built_in">map</span> = <span class="hljs-keyword">new</span> <span class="hljs-keyword">HashMap</span>&lt;&gt;();
<span class="hljs-built_in">key</span>和value都传<span class="hljs-number">100</span>位数据, 最终数据占用为 <span class="hljs-number">4</span> * <span class="hljs-number">100</span> * <span class="hljs-number">2</span>
但如果<span class="hljs-keyword">HashMap</span>&lt;Node, Node&gt; map2 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">HashMap</span>&lt;&gt;();
<span class="hljs-built_in">key</span>和value都传<span class="hljs-number">20</span>g数据, <span class="hljs-built_in">map</span>中只存内存地址<span class="hljs-number">8</span>字节, <span class="hljs-number">4</span> * <span class="hljs-number">8</span> * <span class="hljs-number">2</span>字节大小完成操作</code></pre></div>



<h2 id="有序表-TreeMap-O-logN"><a href="#有序表-TreeMap-O-logN" class="headerlink" title="有序表(TreeMap) O(logN)"></a>有序表(TreeMap) O(logN)</h2><p>1)有序表在使用层面上可以理解为一种集合结构<br>2)如果只有key，没有伴随数据value，可以使用TreeSet结构<br>3)如果既有key，又有伴随数据value，可以使用TreeMap结构<br>4)有无伴随数据，是TreeSet和TreeMap唯一的区别，底层的实际结构是一回事<br>5) <strong><em>有序表把key按照顺序组织起来，而哈希表完全不组织</em></strong></p>
<div class="hljs"><pre><code class="hljs java">System.out.println(treeMap.firstKey());
System.out.println(treeMap.lastKey());

<span class="hljs-comment">// &lt;= 4</span>
System.out.println(treeMap.floorKey(<span class="hljs-number">4</span>));
<span class="hljs-comment">// &gt;= 4</span>
System.out.println(treeMap.ceilingKey(<span class="hljs-number">4</span>));</code></pre></div>

<ol start="6">
<li><strong><em>红黑树</em></strong>、 <strong><em>AVL树</em></strong>、 <strong><em>size-balance-tree</em></strong>和 <strong><em>跳表</em></strong>等都属于 <strong><em>有序表</em></strong>结构，只是底层具体实现不同</li>
<li>放入如果是基础类型，内部按值传递，内存占用就是这个东西的大小</li>
<li>放入如果不是基础类型，内部按引用传递，内存占用是8字节</li>
<li>不管是什么底层具体实现，只要是有序表，都有以下固定的基本功能和固定的时间复杂度 </li>
</ol>
<blockquote>
<p>Api</p>
</blockquote>
<p>1)void put(K key, V value)<br>将一个(key，value)记录加入到表中，或者将key的记录 更新成value。<br>2)V get(K key)<br>根据给定的key，查询value并返回。<br>3)void remove(K key)<br>移除key的记录。<br>4)boolean containsKey(K key)<br>询问是否有关于key的记录。</p>
<p>5)K firstKey()<br>返回所有键值的排序结果中，最小的那个。6)K lastKey()<br>返回所有键值的排序结果中，最大的那个。7)K floorKey(K key)<br>返回&lt;= key 离key最近的那个<br>8)K ceilingKey(K key）<br>返回&gt;= key 离key最近的那个</p>
<blockquote>
<p>哈希表在使用时，增删改查时间复杂度都是O(1)<br>有序表在使用时，比哈希表功能多，时间复杂度都是O(logN)</p>
</blockquote>
<h1 id="归并排序与随机快排"><a href="#归并排序与随机快排" class="headerlink" title="归并排序与随机快排"></a>归并排序与随机快排</h1><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><blockquote>
<p>1）整体是递归，左边排好序+右边排好序+merge让整体有序</p>
</blockquote>
<p>例子: [3, 1, 2, 4]</p>
<p>主函数: f(0, 3) </p>
<p>运行后process(0,1) 再 process(2, 3) 再merge</p>
<p>而运行process(0,1) 需要process(0,0)再process(1,1)再merge</p>
<p>运行process(2, 3)需要process(2, 2)再process(3, 3)再merge</p>
<h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// 递归方法实现</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mergeSort1</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span></span>&#123;
    <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length &lt; <span class="hljs-number">2</span>) &#123;
        <span class="hljs-keyword">return</span>;
    &#125;

    process(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>);
&#125;
<span class="hljs-comment">// 让arr L - R范围变成有序</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R)</span></span>&#123;
    <span class="hljs-keyword">if</span> (L == R)&#123; <span class="hljs-comment">// base case</span>
        <span class="hljs-keyword">return</span>;
    &#125;
    <span class="hljs-keyword">int</span> mid = L + (( R - L ) &gt;&gt; <span class="hljs-number">2</span>);
    process(arr, L, mid);
    process(arr, mid + <span class="hljs-number">1</span>, R);
    merge(arr, L, mid, R);
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span>  <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> M, <span class="hljs-keyword">int</span> R)</span></span>&#123;
    <span class="hljs-keyword">int</span>[] help = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[R - L + <span class="hljs-number">1</span>];
    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; <span class="hljs-comment">// help数组的指针</span>
    <span class="hljs-keyword">int</span> p1 = L; <span class="hljs-comment">// 左部分指针</span>
    <span class="hljs-keyword">int</span> p2 = M + <span class="hljs-number">1</span>; <span class="hljs-comment">// 又部分指针</span>

    <span class="hljs-keyword">while</span> (p1 &lt;= M &amp;&amp; p2 &lt;= R)&#123;
        help[i++] = arr[p1] &lt;= arr[p2] ? arr[p1++] : arr[p2++];
    &#125;
    <span class="hljs-comment">// 要么p1越界, 要么p2越界</span>
    <span class="hljs-keyword">while</span> (p1 &lt;= M)&#123;
        help[i++] = arr[p1++];
    &#125;
    <span class="hljs-keyword">while</span> (p2 &lt;= R)&#123;
        help[i++] = arr[p2++];
    &#125;

    <span class="hljs-comment">// 把help的值赋值回去</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; help.length ; j++) &#123;
        arr[L + i] = help[i];
    &#125;
&#125;</code></pre></div>

<h3 id="非递归实现"><a href="#非递归实现" class="headerlink" title="非递归实现"></a>非递归实现</h3><p>例子[2, 3, 1, 4, 5, 6]</p>
<p>初始k = 1, 每个最小原子单元, 即每个数自我有序,</p>
<p>K &lt;&lt; 2, 每两个一组进行merge, 变成[2, 3, 1, 4, 5, 6]</p>
<p>K &lt;&lt; 2, 每四个一组进行merge, 不够则凑一组[1, 2, 3, 4, 5, 6]</p>
<p>直到k &gt;= N</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// 非递归方法实现</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mergeSort2</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length &lt; <span class="hljs-number">2</span>) &#123;
      <span class="hljs-keyword">return</span>;
   &#125;
   <span class="hljs-keyword">int</span> N = arr.length;
   <span class="hljs-keyword">int</span> mergeSize = <span class="hljs-number">1</span>;<span class="hljs-comment">// 一组是两倍的mergeSize, 当前有序的左组长度</span>
   <span class="hljs-keyword">while</span> (mergeSize &lt; N) &#123;
      <span class="hljs-keyword">int</span> L = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">while</span> (L &lt; N) &#123;
         <span class="hljs-comment">// L...M 左组(mergeSize大小)</span>
         <span class="hljs-comment">// 求中间</span>
         <span class="hljs-keyword">int</span> M = L + mergeSize - <span class="hljs-number">1</span>;
         <span class="hljs-keyword">if</span> (M &gt;= N) &#123;
            <span class="hljs-keyword">break</span>;
         &#125;
         <span class="hljs-comment">// L...M   M+1...R</span>
         <span class="hljs-comment">// 右组可能凑不齐mergeSize个</span>
         <span class="hljs-comment">// 求右边</span>
         <span class="hljs-keyword">int</span> R = Math.min(M + mergeSize, N - <span class="hljs-number">1</span>);
         merge(arr, L, M, R);
         <span class="hljs-comment">// 算下一次左边</span>
         L = R + <span class="hljs-number">1</span>;
      &#125;
      
      <span class="hljs-comment">// 防止溢出</span>
      <span class="hljs-keyword">if</span> (mergeSize &gt; N / <span class="hljs-number">2</span>) &#123;
         <span class="hljs-keyword">break</span>;
      &#125;
      mergeSize &lt;&lt;= <span class="hljs-number">1</span>;
   &#125;
&#125;</code></pre></div>

<h3 id="利用master公式来求解时间复杂度"><a href="#利用master公式来求解时间复杂度" class="headerlink" title="利用master公式来求解时间复杂度"></a>利用master公式来求解时间复杂度</h3><div class="hljs"><pre><code class="hljs mathematica"><span class="hljs-variable">T</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span><span class="hljs-operator">*</span><span class="hljs-variable">T</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-operator">/</span><span class="hljs-number">2</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">+</span> <span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-operator">^</span><span class="hljs-number">1</span><span class="hljs-punctuation">)</span>

根据<span class="hljs-variable">master</span>可知时间复杂度为<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-operator">*</span><span class="hljs-variable">logN</span><span class="hljs-punctuation">)</span>
<span class="hljs-punctuation">(</span>非递归分析<span class="hljs-operator">:</span>每次<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span> <span class="hljs-number">2</span><span class="hljs-operator">,</span> <span class="hljs-number">4</span><span class="hljs-operator">,</span> <span class="hljs-number">8</span><span class="hljs-operator">,</span> <span class="hljs-number">16</span> <span class="hljs-operator">....</span> <span class="hljs-built_in">N</span> <span class="hljs-operator">,</span> <span class="hljs-built_in">Log</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-punctuation">)</span>次<span class="hljs-operator">,</span> 所以<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-operator">*</span><span class="hljs-variable">logN</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">)</span>
<span class="hljs-variable">merge</span>过程需要辅助数组，所以额外空间复杂度为<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-punctuation">)</span>

归并排序的实质是把比较行为变成了有序信息并传递，比<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-operator">^</span><span class="hljs-number">2</span><span class="hljs-punctuation">)</span>的排序快

<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-operator">^</span><span class="hljs-number">2</span><span class="hljs-punctuation">)</span>在无限浪费比较行为<span class="hljs-operator">,</span> 例如选择排序<span class="hljs-operator">,</span> 每次都与后面比较大小</code></pre></div>



<h3 id="用常见面试题再深入理解一下归并排序的精髓"><a href="#用常见面试题再深入理解一下归并排序的精髓" class="headerlink" title="用常见面试题再深入理解一下归并排序的精髓"></a>用常见面试题再深入理解一下归并排序的精髓</h3><blockquote>
<p> 在一个数组中，一个数左边比它小的数的总和，叫数的小和，所有数的小和累加起来，叫数组小和。求数组小和。</p>
</blockquote>
<p>例子： [1,3,4,2,5]<br>1左边比1小的数：没有<br>3左边比3小的数：1<br>4左边比4小的数：1、3<br>2左边比2小的数：1<br>5左边比5小的数：1、3、4、 2<br>所以数组的小和为1+1+3+1+1+3+4+2=16 </p>
<p>每次merge时, 两个指针对应的数比较大小, 如果小, 则计算另外一个指针包括当前位置以后的有多少个比对方大的数字.</p>
<div class="hljs"><pre><code class="hljs css">例子:
<span class="hljs-selector-attr">[1,3,4,2,5]</span> 分为<span class="hljs-selector-attr">[1,3]</span>和<span class="hljs-selector-attr">[4,2,5]</span>
<span class="hljs-selector-attr">[1]</span> <span class="hljs-selector-attr">[3]</span><span class="hljs-selector-tag">merge</span>时, 1比3小, 1个1
<span class="hljs-selector-attr">[4,2,5]</span>分为<span class="hljs-selector-attr">[4]</span>,<span class="hljs-selector-attr">[2, 5]</span>
<span class="hljs-selector-attr">[4]</span><span class="hljs-selector-tag">merge</span>, <span class="hljs-selector-tag">return</span> 0
<span class="hljs-selector-attr">[2, 5]</span><span class="hljs-selector-tag">merge</span>时候, 2比5小, 1个2
<span class="hljs-selector-attr">[4]</span>与<span class="hljs-selector-attr">[2,5]</span><span class="hljs-selector-tag">merge</span>时候, 左指针初始4, 右指针初始2, 4 &gt; 2, <span class="hljs-selector-tag">help</span>数组放入2, 右指针右移
4 &lt; 5, 1个4,<span class="hljs-selector-tag">help</span>数组放入4,越界,放入5
<span class="hljs-selector-attr">[1,3]</span>和<span class="hljs-selector-attr">[2,4,5]</span><span class="hljs-selector-tag">merge</span>, 1&lt;2, 3个1, 3&lt;4, 2个3
结束4个1, 1个2, 2个3, 1个4,</code></pre></div>

<blockquote>
<p>其实就是在左指针与右指针对比时, 加上右指针开始个大于左指针数(利用右边有序)的左指针当前数</p>
<p>result += arr[p1] &lt; arr[p2] ? arr[p1] * (R - p2 + 1) : 0;</p>
<p>也可以解决降序对的问题</p>
<p>只要纠结右边有多少个数比左边大这类的问题，都可以用归并</p>
</blockquote>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">smallNum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[])</span></span>&#123;
    <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length &lt; <span class="hljs-number">2</span>)&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    &#125;

    <span class="hljs-keyword">return</span> process(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>);
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">process</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R)</span></span>&#123;
    <span class="hljs-keyword">if</span> (L == R)&#123;
        <span class="hljs-comment">// 只有一个数, 右组都没有</span>
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    &#125;

    <span class="hljs-keyword">int</span> mid = L + ((R - L) &gt;&gt; <span class="hljs-number">2</span>);
    <span class="hljs-keyword">return</span> process(arr, L, mid) + process(arr, mid + <span class="hljs-number">1</span>, R) + merge(arr, L, mid, R);
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> mid, <span class="hljs-keyword">int</span> R)</span></span>&#123;
    <span class="hljs-keyword">int</span> help[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[R - L + <span class="hljs-number">1</span>];
    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> p1 = L;
    <span class="hljs-keyword">int</span> p2 = mid + <span class="hljs-number">1</span>;
    <span class="hljs-keyword">int</span> result = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">while</span> (p1 &lt;= mid &amp;&amp; p2 &lt;= R)&#123;
        result += arr[p1] &lt; arr[p2] ? arr[p1] * (R - p2 + <span class="hljs-number">1</span>) : <span class="hljs-number">0</span>;
        help[i++] = arr[p1] &lt; arr[p2] ? arr[p1++] : arr[p2++];
    &#125;
    <span class="hljs-keyword">while</span> (p1 &lt;= mid)&#123;
        help[i++] = arr[p1++];
    &#125;
    <span class="hljs-keyword">while</span> (p2 &lt;= R)&#123;
        help[i++] = arr[p2++];
    &#125;
    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; help.length; i++) &#123;
        arr[L + i] = help[i];
    &#125;
    <span class="hljs-keyword">return</span> result;
&#125;</code></pre></div>

<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="Partition过程"><a href="#Partition过程" class="headerlink" title="Partition过程"></a>Partition过程</h3><blockquote>
<p>给定一个数组arr，和一个整数num。请把小于等于num的数放在数组的左边，大于num的数放在数组的右边。<br>要求额外空间复杂度O(1)，时间复杂度O(N) </p>
</blockquote>
<p>设置一个 <strong><em>小于等于区</em></strong>, 设初始位置 -1, </p>
<ol>
<li><p>[i]&lt;=num,当前数和小于等于区下一个位置交换, 小于等于区右扩, i++</p>
</li>
<li><p>[i]&gt;num, i++</p>
</li>
</ol>
<p>例子: [5, 3, 7, 2] num = 3</p>
<p>一开始小于等于区位置 -1, i=0, i[0]=5 &gt; 3, i++, 跳到3, 3&lt;=num, 与小于等于区下一个数即i[0]交换</p>
<p>变成[3, 5, 7, 2]小于等于区右扩, 初始位置为0, 逐步下去</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// 以arr[R]做划分值</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (L &gt; R) &#123;
      <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
   &#125;
   <span class="hljs-keyword">if</span> (L == R) &#123;
      <span class="hljs-keyword">return</span> L;
   &#125;
   <span class="hljs-keyword">int</span> lessEqual = L - <span class="hljs-number">1</span>;
   <span class="hljs-keyword">int</span> index = L;
   <span class="hljs-keyword">while</span> (index &lt; R) &#123;
      <span class="hljs-keyword">if</span> (arr[index] &lt;= arr[R]) &#123;
         swap(arr, index, ++lessEqual);
      &#125;
      index++;
   &#125;
   swap(arr, ++lessEqual, R);
   <span class="hljs-keyword">return</span> lessEqual;
&#125;</code></pre></div>

<h3 id="荷兰国旗问题"><a href="#荷兰国旗问题" class="headerlink" title="荷兰国旗问题"></a>荷兰国旗问题</h3><blockquote>
<p>给定一个数组arr，和一个整数num。请把小于num的数放在数组的左边，等于num的数放在中间，大于num的数放在数组的右边。</p>
<p>要求额外空间复杂度O(1)，时间复杂度O(N)  </p>
</blockquote>
<p>设置一个 <strong><em>小于区</em></strong>,设初始位置 -1 ;  设置一个 <strong><em>大于区</em></strong>,设初始位置 length -1</p>
<ol>
<li><p>[i] == num, i++</p>
</li>
<li><p>[i] &lt; num, [i] 与小于区下一个交换, 小于区右扩, i++</p>
</li>
<li><p>[i] &gt; num, [i] 与大于区左一个交换, 大于区左扩, i <strong><em>停在原地</em></strong></p>
</li>
</ol>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201129162221.png" srcset="/img/loading.gif" alt="流程图"></p>
<p>i与大于区边界撞上的时候停</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// arr[L...R] 玩荷兰国旗问题的划分，以arr[R]做划分值</span>
<span class="hljs-comment">//  &lt;arr[R]  ==arr[R]  &gt; arr[R]</span>
<span class="hljs-comment">// 返回等于区域范围</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] netherlandsFlag(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R) &#123;
   <span class="hljs-keyword">if</span> (L &gt; R) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123; -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span> &#125;;
   &#125;
   <span class="hljs-keyword">if</span> (L == R) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123; L, R &#125;;
   &#125;
   <span class="hljs-keyword">int</span> less = L - <span class="hljs-number">1</span>; <span class="hljs-comment">// &lt; 区 右边界</span>
   <span class="hljs-keyword">int</span> more = R;     <span class="hljs-comment">// &gt; 区 左边界</span>
   <span class="hljs-keyword">int</span> index = L;
   <span class="hljs-keyword">while</span> (index &lt; more) &#123;
      <span class="hljs-keyword">if</span> (arr[index] == arr[R]) &#123;
         index++;
      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[index] &lt; arr[R]) &#123;
         swap(arr, index++, ++less);
      &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// &gt;</span>
         swap(arr, index, --more);
      &#125;
   &#125;
   <span class="hljs-comment">// L...Less 小于区 less+1...more-1 等于区 more...R-1 大于区  R没动过</span>
   <span class="hljs-comment">// 交换后</span>
   <span class="hljs-comment">// L...Less 小于区 less+1.....more 等于区 more+1...R 大于区</span>
   swap(arr, more, R);
   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123; less + <span class="hljs-number">1</span>, more &#125;;
&#125;</code></pre></div>

<h2 id="快速排序1-0"><a href="#快速排序1-0" class="headerlink" title="快速排序1.0"></a>快速排序1.0</h2><p>在arr[L..R]范围上，进行快速排序的过程：<br>1）用arr[R]对该范围做partition，&lt;= arr[R]的数在左部分并且保证arr[R]最后来到左部分小于区的最后一个位置，记为M； &lt;= arr[R]的数在右部分（arr[M+1..R]）,此时X就已经排好序了<br>2）对arr[L..M-1]进行快速排序(递归)<br>3）对arr[M+1..R]进行快速排序(递归)<br>因为每一次partition都会搞定一个数的位置且不会再变动，所以排序能完成</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quickSort1</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length &lt; <span class="hljs-number">2</span>) &#123;
      <span class="hljs-keyword">return</span>;
   &#125;
   process1(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>);
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process1</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (L &gt;= R) &#123;
      <span class="hljs-keyword">return</span>;
   &#125;
   <span class="hljs-comment">// L..R partition arr[R]  [   &lt;=arr[R]   arr[R]    &gt;arr[R]  ]</span>
   <span class="hljs-keyword">int</span> M = partition(arr, L, R);
   process1(arr, L, M - <span class="hljs-number">1</span>);
   process1(arr, M + <span class="hljs-number">1</span>, R);
&#125;</code></pre></div>



<h2 id="快速排序2-0"><a href="#快速排序2-0" class="headerlink" title="快速排序2.0"></a>快速排序2.0</h2><p>在arr[L..R]范围上，进行快速排序的过程：<br>1）用arr[R]对该范围做partition，&lt; arr[R]的数在左部分，== arr[R]的数中间，&gt;arr[R]的数在右部分。假设== arr[R]的数所在范围是[a,b]<br>2）对arr[L..a-1]进行快速排序(递归)<br>3）对arr[b+1..R]进行快速排序(递归)<br>因为每一次partition都会搞定一批数的位置且不会再变动，所以排序能完成</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quickSort2</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length &lt; <span class="hljs-number">2</span>) &#123;
      <span class="hljs-keyword">return</span>;
   &#125;
   process2(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>);
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process2</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (L &gt;= R) &#123;
      <span class="hljs-keyword">return</span>;
   &#125;
   <span class="hljs-keyword">int</span>[] equalArea = netherlandsFlag(arr, L, R);
   process2(arr, L, equalArea[<span class="hljs-number">0</span>] - <span class="hljs-number">1</span>);
   process2(arr, equalArea[<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>, R);
&#125;</code></pre></div>

<h2 id="快速排序1-0和2-0的时间复杂度分析"><a href="#快速排序1-0和2-0的时间复杂度分析" class="headerlink" title="快速排序1.0和2.0的时间复杂度分析"></a>快速排序1.0和2.0的时间复杂度分析</h2><blockquote>
<p>数组已经有序的时候就是复杂度最高的时候<br>时间复杂度O(N^2)</p>
</blockquote>
<h2 id="快速排序3-0-随机快排-荷兰国旗技巧优化"><a href="#快速排序3-0-随机快排-荷兰国旗技巧优化" class="headerlink" title="快速排序3.0(随机快排+荷兰国旗技巧优化)"></a>快速排序3.0(随机快排+荷兰国旗技巧优化)</h2><p>在arr[L..R]范围上，进行快速排序的过程：<br>1）在这个范围上，随机选一个数记为num，<br>1）用num对该范围做partition，&lt; num的数在左部分，== num的数中间，&gt;num的数在右部分。假设== num的数所在范围是[a,b]<br>2）对arr[L..a-1]进行快速排序(递归)<br>3）对arr[b+1..R]进行快速排序(递归)<br>因为每一次partition都会搞定一批数的位置且不会再变动，所以排序能完成</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quickSort3</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length &lt; <span class="hljs-number">2</span>) &#123;
      <span class="hljs-keyword">return</span>;
   &#125;
   process3(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>);
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process3</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (L &gt;= R) &#123;
      <span class="hljs-keyword">return</span>;
   &#125;
   <span class="hljs-comment">// 1、2拿arr[R]做划分值</span>
   <span class="hljs-comment">// 3 随机选一个i, 人为放到arr[R], 再以arr[R]做划分值</span>
   swap(arr, L + (<span class="hljs-keyword">int</span>) (Math.random() * (R - L + <span class="hljs-number">1</span>)), R);
   <span class="hljs-keyword">int</span>[] equalArea = netherlandsFlag(arr, L, R);
   process3(arr, L, equalArea[<span class="hljs-number">0</span>] - <span class="hljs-number">1</span>);
   process3(arr, equalArea[<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>, R);
&#125;</code></pre></div>

<div class="hljs"><pre><code class="hljs apache"><span class="hljs-attribute">1</span>）通过分析知道，划分值越靠近中间，性能越好；越靠近两边，性能越差
<span class="hljs-attribute">2</span>）随机选一个数进行划分的目的就是让好情况和差情况都变成概率事件
<span class="hljs-attribute">3</span>）把每一种情况都列出来，会有每种情况下的时间复杂度，但概率都是<span class="hljs-number">1</span>/N
<span class="hljs-attribute">4</span>）那么所有情况都考虑，时间复杂度就是这种概率模型下的长期期望！</code></pre></div>


<p> *<strong>时间复杂度O(N<em>logN)，额外空间复杂度O(logN)都是这么来的。</em></strong></p>
<h1 id="比较器与堆"><a href="#比较器与堆" class="headerlink" title="比较器与堆"></a>比较器与堆</h1><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><h3 id="堆的实现"><a href="#堆的实现" class="headerlink" title="堆的实现"></a>堆的实现</h3><p>堆结构</p>
<p>1）堆结构就是用数组实现的完全二叉树结构</p>
<blockquote>
<p>完全二叉树是什么</p>
</blockquote>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201201131244.png" srcset="/img/loading.gif" alt="完全二叉树"></p>
<blockquote>
<p>结点从左至右变满, 一个结点也是, 两个结点, 第二个结点在左边也是</p>
</blockquote>
<p>堆可以从数组arr[0]开始, 也可以从arr[1]开始, 为什么会出现从arr[1]开始的情况？</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201201131532.png" srcset="/img/loading.gif" alt="arr[1]开始的堆"></p>
<p><strong>如图所示, 如果堆从arr[1]开始增加, 子结点以及父节点的运算都可以用位运算, 位运算就是快！</strong></p>
<p>2）完全二叉树中如果每棵子树的最大值都在顶部就是大根堆</p>
<blockquote>
<p>头结点为头的树, 最大值为头结点</p>
</blockquote>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201201131811.png" srcset="/img/loading.gif" alt="大根堆"></p>
<p>3）完全二叉树中如果每棵子树的最小值都在顶部就是小根堆</p>
<blockquote>
<p>头结点为头的树, 最小值为头结点</p>
</blockquote>
<p>4）堆结构的heapInsert与heapify操作</p>
<blockquote>
<p>heapInsert: 数放入数组后, 与父节点比较, 如果数更大, 交换, 直到换到根结点</p>
</blockquote>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span></span>&#123;
    <span class="hljs-keyword">if</span> (heapSize &gt; limit)&#123;
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;heap is full!&quot;</span>);
    &#125;
    heap[heapSize] = value;
    heapInsert(heap, heapSize++);
&#125;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 把默认最后加进来的数往上提</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@param</span> arr</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@param</span> index</span>
<span class="hljs-comment"> * arr[index] &gt; arr[(index - 1) / 2]已经包含两个条件</span>
<span class="hljs-comment"> * 1)arr[index] 不比arr[index父]大, 停</span>
<span class="hljs-comment"> * 2)index = 0, 停</span>
<span class="hljs-comment"> */</span>
<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">heapInsert</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> index)</span></span>&#123;
    <span class="hljs-keyword">while</span> (arr[index] &gt; arr[(index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>])&#123;
        swap(arr, index, (index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>);
        index = (index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;
    &#125;
&#125;</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201201133318.png" srcset="/img/loading.gif" alt="heapInsert"></p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 删除堆的最大值并返回, 重组堆</span>
<span class="hljs-comment"> * 用最后的值去顶替arr[0]</span>
<span class="hljs-comment"> * 再往下交换, 找到左孩子与右孩子之间更大的数, 如果更小, 则交换</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span>
<span class="hljs-comment"> */</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>&#123;
    <span class="hljs-keyword">int</span> ans = heap[<span class="hljs-number">0</span>];
    <span class="hljs-comment">// -- heapSize, 之后的数据进入无效区</span>
    swap(heap, <span class="hljs-number">0</span>, -- heapSize);
    heapify(heap, <span class="hljs-number">0</span>, heapSize);
    <span class="hljs-keyword">return</span> ans;
&#125;

<span class="hljs-comment">// 从index的位置往下看, 不断的下沉</span>
<span class="hljs-comment">// 1) 孩子都不比我大 停; 2) 已经没孩子了, 停</span>
<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">heapify</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> heapSize)</span></span>&#123;
    <span class="hljs-keyword">int</span> left = index * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;
    <span class="hljs-comment">// 左孩子不越界就肯定有孩子</span>
    <span class="hljs-keyword">while</span> (left &lt; heapSize)&#123;
        <span class="hljs-comment">// 再判断有没有右孩子</span>
        <span class="hljs-comment">// 右孩子更大的条件是: 有右孩子 &amp;&amp; 右孩子大于左孩子</span>
        <span class="hljs-keyword">int</span> largest = left + <span class="hljs-number">1</span> &lt; heapSize &amp;&amp; arr[left + <span class="hljs-number">1</span>] &gt; arr[left] ? left + <span class="hljs-number">1</span> : left;
        largest = arr[largest] &gt; arr[index] ? largest : index;
        <span class="hljs-comment">// 如果index更大, 则不用下坠</span>
        <span class="hljs-keyword">if</span> (largest == index)&#123;
            <span class="hljs-keyword">break</span>;
        &#125;
        swap(arr, index, largest);
        index = largest;
        left = index * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;
    &#125;
&#125;</code></pre></div>

<p>5）堆结构的增大和减少<br>6）优先级队列结构，就是堆结构(小根堆)</p>
<div class="hljs"><pre><code class="hljs java">PriorityQueue&lt;Integer&gt; heap = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;(<span class="hljs-keyword">new</span> MyComp());</code></pre></div>

<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><blockquote>
<p>先把数组数据变为大根堆结构, 再每次arr[0]与堆最后一个结点互换, 必定会把Max丢到最后, 再heapify</p>
</blockquote>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// 堆排序额外空间复杂度O(1)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">heapSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length &lt; <span class="hljs-number">2</span>) &#123;
            <span class="hljs-keyword">return</span>;
        &#125;
        <span class="hljs-comment">// O(N*logN)</span>
<span class="hljs-comment">//    for (int i = 0; i &lt; arr.length; i++) &#123; // O(N)</span>
<span class="hljs-comment">//       heapInsert(arr, i); // O(logN)</span>
<span class="hljs-comment">//    &#125;</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = arr.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;
            heapify(arr, i, arr.length);
        &#125;
        <span class="hljs-keyword">int</span> heapSize = arr.length;
        swap(arr, <span class="hljs-number">0</span>, --heapSize);
        <span class="hljs-comment">// O(N*logN)</span>
        <span class="hljs-keyword">while</span> (heapSize &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// O(N)</span>
            heapify(arr, <span class="hljs-number">0</span>, heapSize); <span class="hljs-comment">// O(logN)</span>
            swap(arr, <span class="hljs-number">0</span>, --heapSize); <span class="hljs-comment">// O(1)</span>
        &#125;
    &#125;

    <span class="hljs-comment">// arr[index]刚来的数，往上</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">heapInsert</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> index)</span> </span>&#123;
        <span class="hljs-keyword">while</span> (arr[index] &gt; arr[(index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>]) &#123;
            swap(arr, index, (index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>);
            index = (index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;
        &#125;
    &#125;

    <span class="hljs-comment">// arr[index]位置的数，能否往下移动</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">heapify</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> heapSize)</span> </span>&#123;
        <span class="hljs-keyword">int</span> left = index * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>; <span class="hljs-comment">// 左孩子的下标</span>
        <span class="hljs-keyword">while</span> (left &lt; heapSize) &#123; <span class="hljs-comment">// 下方还有孩子的时候</span>
            <span class="hljs-comment">// 两个孩子中，谁的值大，把下标给largest</span>
            <span class="hljs-comment">// 1）只有左孩子，left -&gt; largest</span>
            <span class="hljs-comment">// 2) 同时有左孩子和右孩子，右孩子的值&lt;= 左孩子的值，left -&gt; largest</span>
            <span class="hljs-comment">// 3) 同时有左孩子和右孩子并且右孩子的值&gt; 左孩子的值， right -&gt; largest</span>
            <span class="hljs-keyword">int</span> largest = left + <span class="hljs-number">1</span> &lt; heapSize &amp;&amp; arr[left + <span class="hljs-number">1</span>] &gt; arr[left] ? left + <span class="hljs-number">1</span> : left;
            <span class="hljs-comment">// 父和较大的孩子之间，谁的值大，把下标给largest</span>
            largest = arr[largest] &gt; arr[index] ? largest : index;
            <span class="hljs-keyword">if</span> (largest == index) &#123;
                <span class="hljs-keyword">break</span>;
            &#125;
            swap(arr, largest, index);
            index = largest;
            left = index * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;
        &#125;
    &#125;</code></pre></div>

<div class="hljs"><pre><code class="hljs mathematica"><span class="hljs-number">1</span>，先让整个数组都变成大根堆结构，建立堆的过程<span class="hljs-operator">:</span> 
    <span class="hljs-number">1</span><span class="hljs-punctuation">)</span>从上到下的方法，时间复杂度为<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-operator">*</span><span class="hljs-variable">logN</span><span class="hljs-punctuation">)</span> 
    <span class="hljs-number">2</span><span class="hljs-punctuation">)</span>从下到上的方法，时间复杂度为<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-punctuation">)</span> 
<span class="hljs-number">2</span>，把堆的最大值和堆末尾的值交换，然后减少堆的大小之后，再去调整堆，一直周而复始，时间复杂度为<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-operator">*</span><span class="hljs-variable">logN</span><span class="hljs-punctuation">)</span> 
<span class="hljs-number">3</span>，堆的大小减小成<span class="hljs-number">0</span>之后，排序完成</code></pre></div>



<blockquote>
<p>堆排序优化</p>
</blockquote>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// O(N*logN)</span>
<span class="hljs-comment">// 给定数据的数组,一个一个插入都可以</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123; <span class="hljs-comment">// O(N)</span>
   heapInsert(arr, i); <span class="hljs-comment">// O(logN)</span>
&#125;
      
<span class="hljs-comment">// O(N)</span>
<span class="hljs-comment">// 一定要给定数据数组, 一个一个插入无法使用</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = arr.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;
   heapify(arr, i, arr.length);
&#125;</code></pre></div>

<p>一个O(N*logN), 一个O(N)</p>
<p>怎么证明?</p>
<p>对于从数组最后开始heapify来说, 一颗N结点的树, 最后一层结点应该为N/2, 往上依次为N/4, N/8</p>
<p>最后一层只有”看”的操作, 倒数第二层有”看”和至多一次”换”的操作, 倒数第三层有”看”和至多两次”换”的操作</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201201135242.png" srcset="/img/loading.gif" alt="堆排序优化"></p>
<h2 id="堆问题"><a href="#堆问题" class="headerlink" title="堆问题"></a>堆问题</h2><blockquote>
<p>已知一个几乎有序的数组。几乎有序是指，如果把数组排好顺序的话，每个元素移动的距离一定不超过k，并且k相对于数组长度来说是比较小的。<br>请选择一个合适的排序策略，对这个数组进行排序。</p>
</blockquote>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201207140824.png" srcset="/img/loading.gif" alt="流程"></p>
<p>把前k+1个数放入小根堆, 例如0,1,2,3,4,5位置数放入小根堆, 0～5的数才可能来到0位置, 每排好一次序, 把最小值弹出放到0位置, 再把6位置放入小根堆, 再弹最小值…</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sortedArrDistanceLessK</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> k)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span>) &#123;
      <span class="hljs-keyword">return</span>;
   &#125;
   <span class="hljs-comment">// 默认小根堆</span>
   PriorityQueue&lt;Integer&gt; heap = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;();
   <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;
   <span class="hljs-comment">// 0...K-1</span>
   <span class="hljs-keyword">for</span> (; index &lt;= Math.min(arr.length - <span class="hljs-number">1</span>, k - <span class="hljs-number">1</span>); index++) &#123;
      heap.add(arr[index]);
   &#125;
   <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;
   <span class="hljs-comment">// 先加后弹</span>
   <span class="hljs-keyword">for</span> (; index &lt; arr.length; i++, index++) &#123;
      heap.add(arr[index]);
      arr[i] = heap.poll();
   &#125;
   <span class="hljs-comment">// 没有数可以加了 只弹</span>
   <span class="hljs-keyword">while</span> (!heap.isEmpty()) &#123;
      arr[i++] = heap.poll();
   &#125;
&#125;</code></pre></div>

<p>O(N*logK), 前提是k小于数组长度, 每次加减logk, N次则乘</p>
<h2 id="比较器"><a href="#比较器" class="headerlink" title="比较器"></a>比较器</h2><blockquote>
<p>目前都是基于 <strong>比较</strong> 的排序, 只要告诉两个样本如何比较大小就足够</p>
</blockquote>
<p>1)比较器的实质就是 **重载比较运算符 **</p>
<p>2)比较器可以很好的应用在 <strong>特殊标准的排序</strong>上 </p>
<p>3)比较器可以很好的应用在 <strong>根据特殊标准排序的结构</strong>上</p>
<p>4)写代码变得异常容易，还用于 <strong>范型编程</strong></p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;
   <span class="hljs-keyword">public</span> String name;
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> id;
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> age;

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> id, <span class="hljs-keyword">int</span> age)</span> </span>&#123;
      <span class="hljs-keyword">this</span>.name = name;
      <span class="hljs-keyword">this</span>.id = id;
      <span class="hljs-keyword">this</span>.age = age;
   &#125;
&#125;</code></pre></div>

<blockquote>
<p>comp(T o1, T o2) 返回负数o1放前, 正数o2放前</p>
</blockquote>
<div class="hljs"><pre><code class="hljs java">Student student1 = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-number">2</span>, <span class="hljs-number">20</span>);
Student student2 = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-number">3</span>, <span class="hljs-number">21</span>);
Student student3 = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">22</span>);

Student[] students = <span class="hljs-keyword">new</span> Student[] &#123; student1, student2, student3 &#125;;</code></pre></div>



<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IdAscendingComparator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparator</span>&lt;<span class="hljs-title">Student</span>&gt; </span>&#123;

   <span class="hljs-comment">// 返回负数的时候，第一个参数排在前面</span>
   <span class="hljs-comment">// 返回正数的时候，第二个参数排在前面</span>
   <span class="hljs-comment">// 返回0的时候，谁在前面无所谓</span>
   <span class="hljs-meta">@Override</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Student o1, Student o2)</span> </span>&#123;
      <span class="hljs-keyword">return</span> o1.id - o2.id;
   &#125;
&#125;
Arrays.sort(students, <span class="hljs-keyword">new</span> IdAscendingComparator());
<span class="hljs-comment">// id升序</span></code></pre></div>



<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// 先按照id排序，id小的，放前面；</span>
<span class="hljs-comment">// id一样，age大的，前面；</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IdInAgeDe</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparator</span>&lt;<span class="hljs-title">Student</span>&gt; </span>&#123;

   <span class="hljs-meta">@Override</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Student o1, Student o2)</span> </span>&#123;
      <span class="hljs-keyword">return</span> o1.id != o2.id ? o1.id - o2.id  : (  o2.age - o1.age  );
   &#125;
<span class="hljs-comment">// 更复杂的比较器</span>
&#125;</code></pre></div>



<h3 id="应用在根据特殊标准排序的结构上"><a href="#应用在根据特殊标准排序的结构上" class="headerlink" title="应用在根据特殊标准排序的结构上"></a>应用在根据特殊标准排序的结构上</h3><div class="hljs"><pre><code class="hljs java">PriorityQueue&lt;Student&gt; minHeapBasedId
        = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;(<span class="hljs-keyword">new</span> AgeAscendingComparator());
minHeapBasedId.add(student1);
minHeapBasedId.add(student2);
minHeapBasedId.add(student3);
<span class="hljs-keyword">while</span> (!minHeapBasedId.isEmpty()) &#123;
    Student student = minHeapBasedId.poll();
    System.out.println(<span class="hljs-string">&quot;Name : &quot;</span> + student.name + <span class="hljs-string">&quot;, Id : &quot;</span> + student.id + <span class="hljs-string">&quot;, Age : &quot;</span> + student.age);
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AgeAscendingComparator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparator</span>&lt;<span class="hljs-title">Student</span>&gt; </span>&#123;
        <span class="hljs-meta">@Override</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Student o1, Student o2)</span> </span>&#123;
            <span class="hljs-keyword">return</span> o1.age - o2.age;
        &#125;
&#125;</code></pre></div>

<p>结果:</p>
<div class="hljs"><pre><code class="hljs asciidoc">
===========================
Name : A, Id : 2, Age : 20
Name : B, Id : 3, Age : 21
Name : C, Id : 1, Age : 22
===========================</code></pre></div>



<h2 id="语言提供的堆结构-vs-手写的堆结构"><a href="#语言提供的堆结构-vs-手写的堆结构" class="headerlink" title="语言提供的堆结构 vs 手写的堆结构"></a>语言提供的堆结构 vs 手写的堆结构</h2><p>取决于，你有没有动态改信息的需求！</p>
<p>语言提供的堆结构，如果你动态改数据，不保证依然有序</p>
<p>手写堆结构，因为增加了对象的位置表，所以能够满足动态改信息的需求</p>
<blockquote>
<p>例子</p>
</blockquote>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> classNo;
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> age;
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> id;

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(<span class="hljs-keyword">int</span> c, <span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> i)</span> </span>&#123;
      classNo = c;
      age = a;
      id = i;
   &#125;
&#125;</code></pre></div>

<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StudentComparator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparator</span>&lt;<span class="hljs-title">Student</span>&gt; </span>&#123;
   <span class="hljs-meta">@Override</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Student o1, Student o2)</span> </span>&#123;
      <span class="hljs-keyword">return</span> o1.age - o2.age;
   &#125;
&#125;</code></pre></div>

<div class="hljs"><pre><code class="hljs java">PriorityQueue&lt;Student&gt; heap = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;(<span class="hljs-keyword">new</span> StudentComparator());
heap.add(s1);
heap.add(s2);
heap.add(s3);
heap.add(s4);
heap.add(s5);
heap.add(s6);
<span class="hljs-keyword">while</span> (!heap.isEmpty()) &#123;
   Student cur = heap.poll();
   System.out.println(cur.classNo + <span class="hljs-string">&quot;,&quot;</span> + cur.age + <span class="hljs-string">&quot;,&quot;</span> + cur.id);
&#125;

System.out.println(<span class="hljs-string">&quot;===============&quot;</span>);</code></pre></div>

<div class="hljs"><pre><code class="hljs asciidoc">
6,10,33333
1,14,66666
3,20,44444
2,50,11111
1,60,22222
7,72,55555
===============</code></pre></div>

<div class="hljs"><pre><code class="hljs java">s1 = <span class="hljs-keyword">new</span> Student(<span class="hljs-number">2</span>, <span class="hljs-number">50</span>, <span class="hljs-number">11111</span>);
s2 = <span class="hljs-keyword">new</span> Student(<span class="hljs-number">1</span>, <span class="hljs-number">60</span>, <span class="hljs-number">22222</span>);
s3 = <span class="hljs-keyword">new</span> Student(<span class="hljs-number">6</span>, <span class="hljs-number">10</span>, <span class="hljs-number">33333</span>);
s4 = <span class="hljs-keyword">new</span> Student(<span class="hljs-number">3</span>, <span class="hljs-number">20</span>, <span class="hljs-number">44444</span>);
s5 = <span class="hljs-keyword">new</span> Student(<span class="hljs-number">7</span>, <span class="hljs-number">72</span>, <span class="hljs-number">55555</span>);
s6 = <span class="hljs-keyword">new</span> Student(<span class="hljs-number">1</span>, <span class="hljs-number">14</span>, <span class="hljs-number">66666</span>);

heap = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;(<span class="hljs-keyword">new</span> StudentComparator());

heap.add(s1);
heap.add(s2);
heap.add(s3);
heap.add(s4);
heap.add(s5);
heap.add(s6);
<span class="hljs-comment">// 加进去后 动态改已经加入堆里面的东西</span>
s2.age = <span class="hljs-number">6</span>;
s4.age = <span class="hljs-number">12</span>;
s5.age = <span class="hljs-number">10</span>;
s6.age = <span class="hljs-number">84</span>;

<span class="hljs-keyword">while</span> (!heap.isEmpty()) &#123;
    Student cur = heap.poll();
    System.out.println(cur.classNo + <span class="hljs-string">&quot;,&quot;</span> + cur.age + <span class="hljs-string">&quot;,&quot;</span> + cur.id);
&#125;</code></pre></div>

<div class="hljs"><pre><code class="hljs asciidoc">6,10,33333
3,12,44444
1,6,22222
7,10,55555
2,50,11111
1,84,66666
===============</code></pre></div>

<blockquote>
<p>自己设计某一个值会发生变化的堆</p>
</blockquote>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// 堆</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyHeap</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;
    <span class="hljs-comment">// 没有 T[], 动态数组实现</span>
    <span class="hljs-keyword">private</span> ArrayList&lt;T&gt; heap;
    <span class="hljs-comment">// 记录在堆上的位置</span>
    <span class="hljs-keyword">private</span> HashMap&lt;T, Integer&gt; indexMap;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> heapSize;
    <span class="hljs-keyword">private</span> Comparator&lt;? <span class="hljs-keyword">super</span> T&gt; comparator;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyHeap</span><span class="hljs-params">(Comparator&lt;? <span class="hljs-keyword">super</span> T&gt; com)</span> </span>&#123;
        heap = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
        indexMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
        heapSize = <span class="hljs-number">0</span>;
        comparator = com;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> heapSize == <span class="hljs-number">0</span>;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> heapSize;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">contains</span><span class="hljs-params">(T key)</span> </span>&#123;
        <span class="hljs-keyword">return</span> indexMap.containsKey(key);
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(T value)</span> </span>&#123;
        heap.add(value);
        indexMap.put(value, heapSize);
        heapInsert(heapSize++);
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;
        T ans = heap.get(<span class="hljs-number">0</span>);
        <span class="hljs-keyword">int</span> end = heapSize - <span class="hljs-number">1</span>;
        swap(<span class="hljs-number">0</span>, end);
        heap.remove(end);
        indexMap.remove(ans);
        heapify(<span class="hljs-number">0</span>, --heapSize);
        <span class="hljs-keyword">return</span> ans;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">resign</span><span class="hljs-params">(T value)</span> </span>&#123;
        <span class="hljs-keyword">int</span> valueIndex = indexMap.get(value);
        <span class="hljs-comment">// 只会中一个逻辑</span>
        heapInsert(valueIndex);
        heapify(valueIndex, heapSize);
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">heapInsert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;
        <span class="hljs-keyword">while</span> (comparator.compare(heap.get(index), heap.get((index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>)) &lt; <span class="hljs-number">0</span>) &#123;
            swap(index, (index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>);
            index = (index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;
        &#125;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">heapify</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> heapSize)</span> </span>&#123;
        <span class="hljs-keyword">int</span> left = index * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;
        <span class="hljs-keyword">while</span> (left &lt; heapSize) &#123;
            <span class="hljs-keyword">int</span> largest = left + <span class="hljs-number">1</span> &lt; heapSize &amp;&amp; (comparator.compare(heap.get(left + <span class="hljs-number">1</span>), heap.get(left)) &lt; <span class="hljs-number">0</span>)
                    ? left + <span class="hljs-number">1</span>
                    : left;
            largest = comparator.compare(heap.get(largest), heap.get(index)) &lt; <span class="hljs-number">0</span> ? largest : index;
            <span class="hljs-keyword">if</span> (largest == index) &#123;
                <span class="hljs-keyword">break</span>;
            &#125;
            swap(largest, index);
            index = largest;
            left = index * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;
        &#125;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;
        T o1 = heap.get(i);
        T o2 = heap.get(j);
        heap.set(i, o2);
        heap.set(j, o1);
        indexMap.put(o1, j);
        indexMap.put(o2, i);
    &#125;

&#125;</code></pre></div>



<h1 id="trie、桶排序、排序总结"><a href="#trie、桶排序、排序总结" class="headerlink" title="trie、桶排序、排序总结"></a>trie、桶排序、排序总结</h1><h2 id="前缀树"><a href="#前缀树" class="headerlink" title="前缀树"></a>前缀树</h2><p>1）单个字符串中，字符从前到后的加到一棵多叉树上<br>2）字符放在路上，节点上有专属的数据项（常见的是pass和end值）<br>3）所有样本都这样添加，如果没有路就新建，如有路就复用<br>4）沿途节点的pass值增加1，每个字符串结束时来到的节点end值增加1</p>
<p>可以完成前缀相关的查询</p>
<blockquote>
<p>例子</p>
</blockquote>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201207154038.png" srcset="/img/loading.gif" alt="test1"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201207154211.png" srcset="/img/loading.gif" alt="test2"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201207154255.png" srcset="/img/loading.gif" alt="test3"></p>
<p>所有字符串字符数量为 <strong>N</strong>, </p>
<p>新建树代价为 <strong>O(N)</strong>, </p>
<p>可以找”ab”插入多少次(找ab顺下去b的e值)  <strong>O(N)</strong>, </p>
<p>或者以”a”为前缀的有多少个字符串(找a的p值)  <strong>O(N)</strong></p>
<blockquote>
<p>代码(方式一) <strong>固定数组实现</strong></p>
</blockquote>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node1</span> </span>&#123;
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> pass;
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> end;
   <span class="hljs-keyword">public</span> Node1[] nexts;

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node1</span><span class="hljs-params">()</span> </span>&#123;
      pass = <span class="hljs-number">0</span>;
      end = <span class="hljs-number">0</span>;
      <span class="hljs-comment">// 如何标记存在与否</span>
      <span class="hljs-comment">// nexts[0] -&gt; a</span>
      <span class="hljs-comment">// nexts[1] -&gt; b</span>
      <span class="hljs-comment">// ..     -&gt; ..</span>
      <span class="hljs-comment">// nexts[25]-&gt; z</span>
      <span class="hljs-comment">// nexts[i]== null, i方向的路不存在</span>
      <span class="hljs-comment">// nexts[i]!= null, i方向的路存在</span>
      nexts = <span class="hljs-keyword">new</span> Node1[<span class="hljs-number">26</span>];<span class="hljs-comment">// a — z</span>
   &#125;
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Trie1</span> </span>&#123;
   <span class="hljs-keyword">private</span> Node1 root;

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Trie1</span><span class="hljs-params">()</span> </span>&#123;
      root = <span class="hljs-keyword">new</span> Node1();
   &#125;

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(String word)</span> </span>&#123;
      <span class="hljs-keyword">if</span> (word == <span class="hljs-keyword">null</span>) &#123;
         <span class="hljs-keyword">return</span>;
      &#125;
      <span class="hljs-keyword">char</span>[] chs = word.toCharArray();
      Node1 node = root;
      node.pass++;
      <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;<span class="hljs-comment">// 路</span>
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; chs.length; i++) &#123; <span class="hljs-comment">// 从左往右遍历字符</span>
         index = chs[i] - <span class="hljs-string">&#x27;a&#x27;</span>; <span class="hljs-comment">// 由字符，对应成走向哪条路</span>
         <span class="hljs-keyword">if</span> (node.nexts[index] == <span class="hljs-keyword">null</span>) &#123;
            node.nexts[index] = <span class="hljs-keyword">new</span> Node1();
         &#125;
         node = node.nexts[index];
         node.pass++;
      &#125;
      node.end++;
   &#125;
   <span class="hljs-comment">// 沿途p--, 最后e--</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delete</span><span class="hljs-params">(String word)</span> </span>&#123;
      <span class="hljs-keyword">if</span> (search(word) != <span class="hljs-number">0</span>) &#123;
         <span class="hljs-keyword">char</span>[] chs = word.toCharArray();
         Node1 node = root;
         node.pass--;
         <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;
         <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; chs.length; i++) &#123;
            index = chs[i] - <span class="hljs-string">&#x27;a&#x27;</span>;
            <span class="hljs-comment">// 只要有p变成0，以后肯定都不会经过了</span>
            <span class="hljs-keyword">if</span> (--node.nexts[index].pass == <span class="hljs-number">0</span>) &#123;
               node.nexts[index] = <span class="hljs-keyword">null</span>;
               <span class="hljs-comment">// 直接让jvm释放</span>
               <span class="hljs-comment">// c++需要遍历后续手动释放</span>
               <span class="hljs-keyword">return</span>;
            &#125;
            node = node.nexts[index];
         &#125;
         node.end--;
      &#125;
   &#125;

   <span class="hljs-comment">// word这个单词之前加入过几次</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(String word)</span> </span>&#123;
      <span class="hljs-keyword">if</span> (word == <span class="hljs-keyword">null</span>) &#123;
         <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
      &#125;
      <span class="hljs-keyword">char</span>[] chs = word.toCharArray();
      Node1 node = root;
      <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; chs.length; i++) &#123;
         index = chs[i] - <span class="hljs-string">&#x27;a&#x27;</span>;
         <span class="hljs-keyword">if</span> (node.nexts[index] == <span class="hljs-keyword">null</span>) &#123;
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
         &#125;
         node = node.nexts[index];
      &#125;
      <span class="hljs-keyword">return</span> node.end;
   &#125;

   <span class="hljs-comment">// 所有加入的字符串中，有几个是以pre这个字符串作为前缀的</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">prefixNumber</span><span class="hljs-params">(String pre)</span> </span>&#123;
      <span class="hljs-keyword">if</span> (pre == <span class="hljs-keyword">null</span>) &#123;
         <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
      &#125;
      <span class="hljs-keyword">char</span>[] chs = pre.toCharArray();
      Node1 node = root;
      <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; chs.length; i++) &#123;
         index = chs[i] - <span class="hljs-string">&#x27;a&#x27;</span>;
         <span class="hljs-keyword">if</span> (node.nexts[index] == <span class="hljs-keyword">null</span>) &#123;
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
         &#125;
         node = node.nexts[index];
      &#125;
      <span class="hljs-keyword">return</span> node.pass;
   &#125;
&#125;</code></pre></div>



<blockquote>
<p>代码(方式二)  <strong>哈希表实现</strong>:字符种类变多!</p>
</blockquote>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node2</span> </span>&#123;
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> pass;
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> end;
   <span class="hljs-comment">// ASCII码值, 下一个结点</span>
   <span class="hljs-keyword">public</span> HashMap&lt;Integer, Node2&gt; nexts;

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node2</span><span class="hljs-params">()</span> </span>&#123;
      pass = <span class="hljs-number">0</span>;
      end = <span class="hljs-number">0</span>;
      nexts = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
   &#125;
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Trie2</span> </span>&#123;
   <span class="hljs-keyword">private</span> Node2 root;

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Trie2</span><span class="hljs-params">()</span> </span>&#123;
      root = <span class="hljs-keyword">new</span> Node2();
   &#125;

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(String word)</span> </span>&#123;
      <span class="hljs-keyword">if</span> (word == <span class="hljs-keyword">null</span>) &#123;
         <span class="hljs-keyword">return</span>;
      &#125;
      <span class="hljs-keyword">char</span>[] chs = word.toCharArray();
      Node2 node = root;
      node.pass++;
      <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; chs.length; i++) &#123;
         index = (<span class="hljs-keyword">int</span>) chs[i];
         <span class="hljs-keyword">if</span> (!node.nexts.containsKey(index)) &#123;
            node.nexts.put(index, <span class="hljs-keyword">new</span> Node2());
         &#125;
         node = node.nexts.get(index);
         node.pass++;
      &#125;
      node.end++;
   &#125;

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delete</span><span class="hljs-params">(String word)</span> </span>&#123;
      <span class="hljs-keyword">if</span> (search(word) != <span class="hljs-number">0</span>) &#123;
         <span class="hljs-keyword">char</span>[] chs = word.toCharArray();
         Node2 node = root;
         node.pass--;
         <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;
         <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; chs.length; i++) &#123;
            index = (<span class="hljs-keyword">int</span>) chs[i];
            <span class="hljs-keyword">if</span> (--node.nexts.get(index).pass == <span class="hljs-number">0</span>) &#123;
               node.nexts.remove(index);
               <span class="hljs-keyword">return</span>;
            &#125;
            node = node.nexts.get(index);
         &#125;
         node.end--;
      &#125;
   &#125;

   <span class="hljs-comment">// word这个单词之前加入过几次</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(String word)</span> </span>&#123;
      <span class="hljs-keyword">if</span> (word == <span class="hljs-keyword">null</span>) &#123;
         <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
      &#125;
      <span class="hljs-keyword">char</span>[] chs = word.toCharArray();
      Node2 node = root;
      <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; chs.length; i++) &#123;
         index = (<span class="hljs-keyword">int</span>) chs[i];
         <span class="hljs-keyword">if</span> (!node.nexts.containsKey(index)) &#123;
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
         &#125;
         node = node.nexts.get(index);
      &#125;
      <span class="hljs-keyword">return</span> node.end;
   &#125;

   <span class="hljs-comment">// 所有加入的字符串中，有几个是以pre这个字符串作为前缀的</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">prefixNumber</span><span class="hljs-params">(String pre)</span> </span>&#123;
      <span class="hljs-keyword">if</span> (pre == <span class="hljs-keyword">null</span>) &#123;
         <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
      &#125;
      <span class="hljs-keyword">char</span>[] chs = pre.toCharArray();
      Node2 node = root;
      <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; chs.length; i++) &#123;
         index = (<span class="hljs-keyword">int</span>) chs[i];
         <span class="hljs-keyword">if</span> (!node.nexts.containsKey(index)) &#123;
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
         &#125;
         node = node.nexts.get(index);
      &#125;
      <span class="hljs-keyword">return</span> node.pass;
   &#125;
&#125;</code></pre></div>



<h2 id="不基于比较的排序"><a href="#不基于比较的排序" class="headerlink" title="不基于比较的排序"></a>不基于比较的排序</h2><p>桶排序思想下的排序：**计数排序 &amp; 基数排序 **</p>
<p>1)桶排序思想下的排序都是 <strong>不基于比较的排序</strong></p>
<ol start="2">
<li><strong>时间复杂度为O(N)，额外空间负载度O(M)</strong>:无法确定</li>
</ol>
<p>3)应用范围有限， <strong>需要样本的数据状况</strong> 满足桶的划分,  <strong>强相关</strong></p>
<blockquote>
<p>区别</p>
</blockquote>
<p>1）一般来讲，计数排序要求，样本是 <strong>整数</strong>，且 <strong>范围比较窄</strong></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201207164502.png" srcset="/img/loading.gif" alt="计数排序"></p>
<p>例子:[]里数据为年龄, 年龄不会超过200, 准备一个[0-200]的桶, 记录arr的数, 有就加一, 再遍历桶</p>
<p>2）一般来讲，基数排序要求，样本是 <strong>10进制的正整数</strong></p>
<p>例子:</p>
<p>[100,17,29,13,5,27]</p>
<p>找到最大值100, 补齐位数变成[100,017,029,013,005,027]</p>
<p>准备一个桶 0,1,2,3,4,5,6,7,8,9, 每一个桶 <strong>队列</strong>, 先进先出</p>
<p>[100,017,029,013,005,027]根据个位数入桶, 再倒出来, 由于队列, 先进先出</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201207165238.png" srcset="/img/loading.gif" alt="第一次排序后"></p>
<p>再根据十位数字入桶, 再倒出来, 由于队列, 先进先出</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201207165457.png" srcset="/img/loading.gif" alt="第二次后"></p>
<p>再根据百位数字入桶, 再倒出来, 由于队列, 先进先出</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201207165615.png" srcset="/img/loading.gif" alt="第三次排序后"></p>
<p> <strong>一旦要求稍有升级，改写代价增加是显而易见的！</strong></p>
<h3 id="计数排序代码"><a href="#计数排序代码" class="headerlink" title="计数排序代码"></a>计数排序代码</h3><div class="hljs"><pre><code class="hljs JAVA"><span class="hljs-comment">// only for 0~200 value</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">countSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length &lt; <span class="hljs-number">2</span>) &#123;
      <span class="hljs-keyword">return</span>;
   &#125;
   <span class="hljs-keyword">int</span> max = Integer.MIN_VALUE;
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;
      max = Math.max(max, arr[i]);
   &#125;
   <span class="hljs-keyword">int</span>[] bucket = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[max + <span class="hljs-number">1</span>];
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;
      bucket[arr[i]]++;
   &#125;
   <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; bucket.length; j++) &#123;
      <span class="hljs-keyword">while</span> (bucket[j]-- &gt; <span class="hljs-number">0</span>) &#123;
         arr[i++] = j;
      &#125;
   &#125;
&#125;</code></pre></div>

<h3 id="基数排序代码-O-N-log10为底max"><a href="#基数排序代码-O-N-log10为底max" class="headerlink" title="基数排序代码 O(N*log10为底max)"></a>基数排序代码 O(N*log10为底max)</h3><div class="hljs"><pre><code class="hljs Java"><span class="hljs-comment">// only for no-negative value</span>
<span class="hljs-comment">// 非负</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">radixSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length &lt; <span class="hljs-number">2</span>) &#123;
      <span class="hljs-keyword">return</span>;
   &#125;
   radixSort(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>, maxbits(arr));
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxbits</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;
   <span class="hljs-keyword">int</span> max = Integer.MIN_VALUE;
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;
      max = Math.max(max, arr[i]);
   &#125;
   <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;
   <span class="hljs-keyword">while</span> (max != <span class="hljs-number">0</span>) &#123;
      res++;
      max /= <span class="hljs-number">10</span>;
   &#125;
   <span class="hljs-keyword">return</span> res;
&#125;

<span class="hljs-comment">// arr[l..r]排序  ,  digit(最大值位数)</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">radixSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R, <span class="hljs-keyword">int</span> digit)</span> </span>&#123;
   <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> radix = <span class="hljs-number">10</span>; <span class="hljs-comment">// 以十为基底</span>
   <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;
   <span class="hljs-comment">// 有多少个数准备多少个辅助空间</span>
   <span class="hljs-keyword">int</span>[] help = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[R - L + <span class="hljs-number">1</span>];
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> d = <span class="hljs-number">1</span>; d &lt;= digit; d++) &#123; <span class="hljs-comment">// 有多少位就进出几次</span>
      <span class="hljs-comment">// 10个空间</span>
       <span class="hljs-comment">// count[0] 当前位(d位)是0的数字有多少个</span>
      <span class="hljs-comment">// count[1] 当前位(d位)是(0和1)的数字有多少个</span>
      <span class="hljs-comment">// count[2] 当前位(d位)是(0、1和2)的数字有多少个</span>
      <span class="hljs-comment">// count[i] 当前位(d位)是(0~i)的数字有多少个</span>
      <span class="hljs-keyword">int</span>[] count = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[radix]; <span class="hljs-comment">// count[0..9]</span>
      <span class="hljs-keyword">for</span> (i = L; i &lt;= R; i++) &#123;
         <span class="hljs-comment">// 取出Digit位数上的数 </span>
         <span class="hljs-comment">// 103 1 3</span>
         <span class="hljs-comment">// 202 1 2</span>
         j = getDigit(arr[i], d);
         count[j]++;
      &#125;
      <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; radix; i++) &#123;
         <span class="hljs-comment">// count自己变成count&#x27;</span>
         count[i] = count[i] + count[i - <span class="hljs-number">1</span>];
      &#125;
      <span class="hljs-keyword">for</span> (i = R; i &gt;= L; i--) &#123;
         j = getDigit(arr[i], d);
         help[count[j] - <span class="hljs-number">1</span>] = arr[i];
         count[j]--;
      &#125;
      <span class="hljs-keyword">for</span> (i = L, j = <span class="hljs-number">0</span>; i &lt;= R; i++, j++) &#123;
         arr[i] = help[j];
      &#125;
   &#125;
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getDigit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> d)</span> </span>&#123;
   <span class="hljs-keyword">return</span> ((x / ((<span class="hljs-keyword">int</span>) Math.pow(<span class="hljs-number">10</span>, d - <span class="hljs-number">1</span>))) % <span class="hljs-number">10</span>);
&#125;</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201207172931.png" srcset="/img/loading.gif" alt="基数排序解析"></p>
<p>准备count数组为10长度，下标0 - 9</p>
<p>先对比个位数大小，分别放入对应count数组，count转化为count’词频数组，代表小于等于索引i的数有多少个</p>
<p>再从 <strong>右往左遍历</strong>数组（正常来说从左往右时302应该在队列末尾最后出队），开辟最大个数（小于等于9的数字有五个）的help数组，从右往左遍历时候302个位下标为2，小于等于2的有四个，所以可能放在第0 - 第3个数字，但因为从右往左遍历，302应该在2号桶最后倒出来， 所以302放help[3]，count’的词频减1，41应该在1号桶最后倒出来，个位数小于等于1有两个，所以放help[1]，202放剩下的2最后，小于等于2变成三个，所以help[2]….</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201207173538.png" srcset="/img/loading.gif" alt="只用数组模拟入桶出桶行为"></p>
<h1 id="排序算法的稳定性及总结"><a href="#排序算法的稳定性及总结" class="headerlink" title="排序算法的稳定性及总结"></a>排序算法的稳定性及总结</h1><h2 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h2><p>稳定性是指同样大小的样本再 <strong>排序之后不会改变相对次序</strong></p>
<ul>
<li>第一个1还在第一个, 第二个2还在第二个</li>
</ul>
<p>对 <strong>基础类型</strong> 来说，稳定性毫无意义</p>
<ul>
<li>不用区分是第几个1</li>
</ul>
<p>对 <strong>非基础类型</strong> (引用)来说，稳定性有重要意义</p>
<ul>
<li>班级号、年龄的学生类，第一回按照所有学生年龄从小到大排序，基于此再按照班级号从小到大排序</li>
<li>如果 <strong>具有稳定性</strong> : [一班年纪小, 一班年纪大, 二班年纪小, 三班年纪大…]</li>
<li>即可选择 价格最低和好评最高 -&gt; 物美价廉</li>
</ul>
<p>有些排序算法可以实现成稳定的，而有些排序算法无论如何都实现不成稳定的</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​             时间复杂度 额外空间复杂度   稳定性<br>选择排序    O(N^2)          O(1)            无<br>冒泡排序    O(N^2)          O(1)            有<br>插入排序    O(N^2)          O(1)            有<br>归并排序    O(NlogN)         O(N)           有<br>随机快排    O(NlogN)         O(logN)        无<br>堆排序      O(NlogN)        O(1)           无<br>= = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =<br>计数排序    O(N)      O(M)    有<br>基数排序    O(N)      O(N)    有</p>
<ul>
<li><p><strong>选择排序</strong> 问题</p>
<p>[5,5,5,5,1,5,5,5,5] 直接第一个5位置放到1位置交换，5位置被破坏</p>
</li>
<li><p><strong>冒泡排序</strong> </p>
<p>相等时候不交换，稳定性就不会被破坏</p>
</li>
<li><p><strong>插入排序</strong> </p>
<p>面对相等时，不替换，稳定性也不会被破坏</p>
</li>
<li><p><strong>归并排序</strong></p>
<p>面对相等时，先拷贝左边的，稳定性也不会被破坏</p>
<p>但如果解决逆序对等问题先拷贝右边则会出现问题</p>
</li>
<li><p><strong>随机快排</strong></p>
<p>Partition过程无法做稳定</p>
<p>小于等于区下一个数交换，交换的会是等于区的数字，数字的位置就会被破坏</p>
</li>
<li><p><strong>堆排序</strong></p>
<p>变成大根堆的时候, 3，3，3，3遇到4后有很多个3的位置会改变</p>
</li>
</ul>
<blockquote>
<p>总结</p>
</blockquote>
<div class="hljs"><pre><code class="hljs mathematica"><span class="hljs-number">1</span>）不基于比较的排序，对样本数据有严格要求，不易改写
<span class="hljs-number">2</span>）基于比较的排序，只要规定好两个样本怎么比大小就可以直接复用
<span class="hljs-number">3</span>）基于比较的排序，时间复杂度的极限是<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-operator">*</span><span class="hljs-variable">logN</span><span class="hljs-punctuation">)</span>
<span class="hljs-number">4</span>）时间复杂度<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-operator">*</span><span class="hljs-variable">logN</span><span class="hljs-punctuation">)</span>、额外空间复杂度低于<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-punctuation">)</span>、且稳定的基于比较的排序是不存在的。
<span class="hljs-number">5</span>）为了绝对的速度选快排（常数时间最少）、为了省空间选堆排、为了稳定性选归并</code></pre></div>



<h2 id="常见的坑"><a href="#常见的坑" class="headerlink" title="常见的坑"></a>常见的坑</h2><ul>
<li>归并排序的额外空间复杂度可以变成O(1)，“ <strong>归并排序 内部缓存法</strong> ”，但是将变得 <strong>不再稳定</strong>。</li>
<li>“ <strong>原地归并排序</strong> “ 是垃圾贴，会让时间复杂度变成O(N^2) </li>
<li>快速排序稳定性改进，“01 stable sort”，但是会对 <strong>样本数据要求更多</strong>。</li>
</ul>
<ul>
<li><p>在整型数组中，请把奇数放在数组左边，偶数放在数组右边，要求所有奇数之间原始的相对次序不变，所有偶数之间原始相对次序不变。</p>
<p>要求：时间复杂度做到O(N)，额外空间复杂度做到O(1)</p>
<p>**这是一个 0,1标准的Partition **(原始小于等于和大于分界，此问题奇数偶数分界), 而Partition过程无法做到稳定性</p>
</li>
</ul>
<p>系统函数：先反射，判定是引用传递还是值传递，引用归并，值传递快排</p>
<h1 id="链表问题"><a href="#链表问题" class="headerlink" title="链表问题"></a>链表问题</h1><blockquote>
<p> 面试时链表解题的 <strong>方法论</strong></p>
</blockquote>
<p>1)对于笔试，不用太在乎空间复杂度，一切为了时间复杂度</p>
<p>2)对于面试，时间复杂度依然放在第一位，但是一定要找到空间最省的方法</p>
<h2 id="链表面试题常用数据结构和技巧"><a href="#链表面试题常用数据结构和技巧" class="headerlink" title="链表面试题常用数据结构和技巧"></a>链表面试题常用数据结构和技巧</h2><p>1）使用容器(哈希表、数组等)</p>
<p>2）快慢指针 </p>
<h2 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h2><p>1）输入链表头节点，奇数长度返回中点，偶数长度返回上中点</p>
<p>1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt;5 找到3, 1 -&gt; 2 -&gt; 3 -&gt; 4  找到2</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">midOrUpMidNode</span><span class="hljs-params">(Node head)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span> || head.next == <span class="hljs-keyword">null</span> || head.next.next == <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">return</span> head;
   &#125;
   <span class="hljs-comment">// 链表 &gt;= 三个结点</span>
   Node slow = head.next;
   Node fast = head.next.next;
   <span class="hljs-keyword">while</span> (fast.next != <span class="hljs-keyword">null</span> &amp;&amp; fast.next.next != <span class="hljs-keyword">null</span>) &#123;
      slow = slow.next;
      fast = fast.next.next;
   &#125;
   <span class="hljs-keyword">return</span> slow;
&#125;</code></pre></div>

<p>2）输入链表头节点，奇数长度返回中点，偶数长度返回下中点</p>
<p>1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt;5 找到3,  1 -&gt; 2 -&gt; 3 -&gt; 4  找到3</p>
<p>3）输入链表头节点，奇数长度返回中点前一个，偶数长度返回上中点前一个</p>
<p>4）输入链表头节点，奇数长度返回中点前一个，偶数长度返回下中点前一个</p>
<h2 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h2><h3 id="给定一个单链表的头节点head，请判断该链表是否为回文结构。"><a href="#给定一个单链表的头节点head，请判断该链表是否为回文结构。" class="headerlink" title="给定一个单链表的头节点head，请判断该链表是否为回文结构。"></a>给定一个单链表的头节点head，请判断该链表是否为回文结构。</h3><p>1）栈方法特别简单（笔试用）</p>
<ul>
<li><p><strong>栈实现</strong></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201208150841.png" srcset="/img/loading.gif" alt="栈"></p>
<p>把链表value全放栈中，再弹出一个一个对比。</p>
<p>Code:</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// need n extra space</span>
<span class="hljs-comment">// stack</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPalindrome1</span><span class="hljs-params">(Node head)</span> </span>&#123;
   Stack&lt;Node&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;Node&gt;();
   Node cur = head;
   <span class="hljs-keyword">while</span> (cur != <span class="hljs-keyword">null</span>) &#123;
      stack.push(cur);
      cur = cur.next;
   &#125;
   <span class="hljs-keyword">while</span> (head != <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">if</span> (head.value != stack.pop().value) &#123;
         <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
      &#125;
      head = head.next;
   &#125;
   <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
&#125;</code></pre></div>
</li>
<li><p><strong>栈实现2</strong></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201208151246.png" srcset="/img/loading.gif" alt="快慢指针定位"></p>
<p>快慢指针定位到中点的位置, 奇数唯一中点偶数上中点, 把右半部分加到栈中, 弹出与head一一对比</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// need n/2 extra space</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPalindrome2</span><span class="hljs-params">(Node head)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span> || head.next == <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
   &#125;
   Node right = head.next;
   Node cur = head;
   <span class="hljs-keyword">while</span> (cur.next != <span class="hljs-keyword">null</span> &amp;&amp; cur.next.next != <span class="hljs-keyword">null</span>) &#123;
      right = right.next;
      cur = cur.next.next;
   &#125;
   Stack&lt;Node&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;Node&gt;();
   <span class="hljs-keyword">while</span> (right != <span class="hljs-keyword">null</span>) &#123;
      stack.push(right);
      right = right.next;
   &#125;
   <span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;
      <span class="hljs-keyword">if</span> (head.value != stack.pop().value) &#123;
         <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
      &#125;
      head = head.next;
   &#125;
   <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
&#125;</code></pre></div>



</li>
</ul>
<p>2）改原链表的方法就需要注意边界了（面试用）</p>
<p>​ <img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201208151959.png" srcset="/img/loading.gif" alt="原链表"></p>
<p>变化为-&gt;</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201208152030.png" srcset="/img/loading.gif" alt="变化后"></p>
<p>再L与R对比, 直到比到S, 最后再变回链表位置即可。</p>
<p>这样的 <strong>额外空间复杂度为 O(1);</strong></p>
<p>code:</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// need O(1) extra space</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPalindrome3</span><span class="hljs-params">(Node head)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span> || head.next == <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
   &#125;
   Node n1 = head; <span class="hljs-comment">// slow</span>
   Node n2 = head; <span class="hljs-comment">// fast</span>
   <span class="hljs-keyword">while</span> (n2.next != <span class="hljs-keyword">null</span> &amp;&amp; n2.next.next != <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// find mid node</span>
      n1 = n1.next; <span class="hljs-comment">// n1 -&gt; mid</span>
      n2 = n2.next.next; <span class="hljs-comment">// n2 -&gt; end</span>
   &#125;
   n2 = n1.next; <span class="hljs-comment">// n2 -&gt; right part first node</span>
   n1.next = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// mid.next -&gt; null</span>
   Node n3 = <span class="hljs-keyword">null</span>;
   <span class="hljs-keyword">while</span> (n2 != <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// right part convert</span>
      n3 = n2.next; <span class="hljs-comment">// n3 -&gt; save next node</span>
      n2.next = n1; <span class="hljs-comment">// next of right node convert</span>
      n1 = n2; <span class="hljs-comment">// n1 move</span>
      n2 = n3; <span class="hljs-comment">// n2 move</span>
   &#125;
   n3 = n1; <span class="hljs-comment">// n3 -&gt; save last node</span>
   n2 = head;<span class="hljs-comment">// n2 -&gt; left first node</span>
   <span class="hljs-keyword">boolean</span> res = <span class="hljs-keyword">true</span>;
   <span class="hljs-keyword">while</span> (n1 != <span class="hljs-keyword">null</span> &amp;&amp; n2 != <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// check palindrome</span>
      <span class="hljs-keyword">if</span> (n1.value != n2.value) &#123;
         res = <span class="hljs-keyword">false</span>;
         <span class="hljs-keyword">break</span>;
      &#125;
      n1 = n1.next; <span class="hljs-comment">// left to mid</span>
      n2 = n2.next; <span class="hljs-comment">// right to mid</span>
   &#125;
   n1 = n3.next;
   n3.next = <span class="hljs-keyword">null</span>;
   <span class="hljs-keyword">while</span> (n1 != <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// recover list</span>
      n2 = n1.next;
      n1.next = n3;
      n3 = n1;
      n1 = n2;
   &#125;
   <span class="hljs-keyword">return</span> res;
&#125;</code></pre></div>



<h3 id="将单向链表按某值划分成左边小、中间相等、右边大的形式"><a href="#将单向链表按某值划分成左边小、中间相等、右边大的形式" class="headerlink" title="将单向链表按某值划分成左边小、中间相等、右边大的形式"></a>将单向链表按某值划分成左边小、中间相等、右边大的形式</h3><p>1）把链表放入数组里，在数组上做partition（笔试用）( <strong>不稳定</strong> )</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">listPartition1</span><span class="hljs-params">(Node head, <span class="hljs-keyword">int</span> pivot)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">return</span> head;
   &#125;
   Node cur = head;
   <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;
   <span class="hljs-keyword">while</span> (cur != <span class="hljs-keyword">null</span>) &#123;
      i++;
      cur = cur.next;
   &#125;
   Node[] nodeArr = <span class="hljs-keyword">new</span> Node[i];
   i = <span class="hljs-number">0</span>;
   cur = head;
   <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i != nodeArr.length; i++) &#123;
      nodeArr[i] = cur;
      cur = cur.next;
   &#125;
   arrPartition(nodeArr, pivot);
   <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i != nodeArr.length; i++) &#123;
      nodeArr[i - <span class="hljs-number">1</span>].next = nodeArr[i];
   &#125;
   nodeArr[i - <span class="hljs-number">1</span>].next = <span class="hljs-keyword">null</span>;
   <span class="hljs-keyword">return</span> nodeArr[<span class="hljs-number">0</span>];
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">arrPartition</span><span class="hljs-params">(Node[] nodeArr, <span class="hljs-keyword">int</span> pivot)</span> </span>&#123;
   <span class="hljs-keyword">int</span> small = -<span class="hljs-number">1</span>;
   <span class="hljs-keyword">int</span> big = nodeArr.length;
   <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;
   <span class="hljs-keyword">while</span> (index != big) &#123;
      <span class="hljs-keyword">if</span> (nodeArr[index].value &lt; pivot) &#123;
         swap(nodeArr, ++small, index++);
      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nodeArr[index].value == pivot) &#123;
         index++;
      &#125; <span class="hljs-keyword">else</span> &#123;
         swap(nodeArr, --big, index);
      &#125;
   &#125;
&#125;</code></pre></div>



<p>2）分成小、中、大三部分，再把各个部分之间串起来（面试用）</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201208161643.png" srcset="/img/loading.gif" alt="六个变量"></p>
<p>设置六个变量，分别为小于区头尾结点，大于区头尾结点，等于区头尾结点。</p>
<p>依次遍历，例如遍历4结点，bH、bT = 4，4结点断开。2也是，发至sH和sT=2，3发至eH和eT=3。</p>
<p>来到5时，要发到大于区，5串到4下面，bH=4，让bT指向5但5变成bT。</p>
<p>来到6时，bT指向6并让bT找到6的位置。</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201208162538.png" srcset="/img/loading.gif" alt="流程"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201208162652.png" srcset="/img/loading.gif" alt="流程2"></p>
<p>每一步O(1),整体O(N); 且是 <strong>稳定的</strong></p>
<p>code:</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">listPartition2</span><span class="hljs-params">(Node head, <span class="hljs-keyword">int</span> pivot)</span> </span>&#123;
   Node sH = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// small head</span>
   Node sT = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// small tail</span>
   Node eH = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// equal head</span>
   Node eT = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// equal tail</span>
   Node mH = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// big head</span>
   Node mT = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// big tail</span>
   Node next = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// save next node</span>
   <span class="hljs-comment">// every node distributed to three lists</span>
   <span class="hljs-keyword">while</span> (head != <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-comment">// 记录head.next 后面结点next是要销毁的</span>
      next = head.next;
      head.next = <span class="hljs-keyword">null</span>;
      <span class="hljs-keyword">if</span> (head.value &lt; pivot) &#123;
         <span class="hljs-keyword">if</span> (sH == <span class="hljs-keyword">null</span>) &#123;
            sH = head;
            sT = head;
         &#125; <span class="hljs-keyword">else</span> &#123;
            sT.next = head;
            sT = head;
         &#125;
      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (head.value == pivot) &#123;
         <span class="hljs-keyword">if</span> (eH == <span class="hljs-keyword">null</span>) &#123;
            eH = head;
            eT = head;
         &#125; <span class="hljs-keyword">else</span> &#123;
            eT.next = head;
            eT = head;
         &#125;
      &#125; <span class="hljs-keyword">else</span> &#123;
         <span class="hljs-keyword">if</span> (mH == <span class="hljs-keyword">null</span>) &#123;
            mH = head;
            mT = head;
         &#125; <span class="hljs-keyword">else</span> &#123;
            mT.next = head;
            mT = head;
         &#125;
      &#125;
      head = next;
   &#125;
   <span class="hljs-comment">// small and equal reconnect</span>
   <span class="hljs-keyword">if</span> (sT != <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// 如果有小于区域</span>
      sT.next = eH;
      eT = eT == <span class="hljs-keyword">null</span> ? sT : eT; <span class="hljs-comment">// 下一步，谁去连大于区域的头，谁就变成eT</span>
   &#125;
   <span class="hljs-comment">// 上面的if，不管跑了没有，et</span>
   <span class="hljs-comment">// all reconnect</span>
   <span class="hljs-keyword">if</span> (eT != <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// 如果小于区域和等于区域，不是都没有</span>
      eT.next = mH;
   &#125;
   <span class="hljs-keyword">return</span> sH != <span class="hljs-keyword">null</span> ? sH : (eH != <span class="hljs-keyword">null</span> ? eH : mH);
&#125;</code></pre></div>



<h3 id="一种特殊的单链表节点类-random"><a href="#一种特殊的单链表节点类-random" class="headerlink" title="一种特殊的单链表节点类 random"></a>一种特殊的单链表节点类 random</h3><blockquote>
<p> 一种特殊的单链表节点类描述如下</p>
</blockquote>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123; 
<span class="hljs-keyword">int</span> value; 
Node next; 
Node rand; 
Node(<span class="hljs-keyword">int</span> val) &#123; value = val; &#125; 
&#125;</code></pre></div>

<p>rand指针是单链表节点结构中新增的指针，rand可能指向链表中的任意一个节点，也可能指向null。<br>给定一个由Node节点类型组成的无环单链表的头节点 head，请实现一个函数完成这个链表的复制，并返回复制的新链表的头节点。<br> <strong>【要求】</strong><br> **时间复杂度O(N)，额外空间复杂度O(1) **</p>
<ul>
<li><p>哈希表</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">copyListWithRand1</span><span class="hljs-params">(Node head)</span> </span>&#123;
   HashMap&lt;Node, Node&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;Node, Node&gt;();
   Node cur = head;
   <span class="hljs-keyword">while</span> (cur != <span class="hljs-keyword">null</span>) &#123;
      map.put(cur, <span class="hljs-keyword">new</span> Node(cur.value));
      cur = cur.next;
   &#125;
   cur = head;
   <span class="hljs-keyword">while</span> (cur != <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-comment">// cur 老          (key)</span>
      <span class="hljs-comment">// map.get(cur) 新 (value)</span>
      map.get(cur).next = map.get(cur.next);
      map.get(cur).rand = map.get(cur.rand);
      cur = cur.next;
   &#125;
   <span class="hljs-keyword">return</span> map.get(head);
&#125;</code></pre></div>



</li>
</ul>
<ul>
<li><p>不用哈希表</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201208175756.png" srcset="/img/loading.gif" alt="克隆, 放置后面"></p>
<p>一次拿出一对:</p>
<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201208175936.png" srcset="/img/loading.gif" alt="如何克隆？" style="zoom:50%;" />



</li>
</ul>
<p>  我们通过1找到1的random 3，又因为3’就在3后面，所以可以直接3.next找到并与1’连接</p>
<p>  最后分离</p>
<p>  code:</p>
  <div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">copyListWithRand2</span><span class="hljs-params">(Node head)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
   &#125;
   Node cur = head;
   Node next = <span class="hljs-keyword">null</span>;
   <span class="hljs-comment">// copy node and link to every node</span>
   <span class="hljs-comment">// 1 -&gt; 2</span>
   <span class="hljs-comment">// 1 -&gt; 1&#x27; -&gt; 2</span>
   <span class="hljs-keyword">while</span> (cur != <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-comment">// cur 老</span>
      <span class="hljs-comment">// next表示 老 的下一个</span>
      next = cur.next;
      cur.next = <span class="hljs-keyword">new</span> Node(cur.value);
      cur.next.next = next;
      cur = next;
   &#125;
   cur = head;
   Node curCopy = <span class="hljs-keyword">null</span>;
   <span class="hljs-comment">// set copy node rand</span>
   <span class="hljs-comment">// 1 -&gt; 1&#x27; -&gt; 2 -&gt; 2&#x27;</span>
   <span class="hljs-keyword">while</span> (cur != <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-comment">// cur 老</span>
      <span class="hljs-comment">// cur.next  新 copy</span>
      next = cur.next.next;
      curCopy = cur.next;
      <span class="hljs-comment">// 老的rand的下一个(插入进来的)</span>
      curCopy.rand = cur.rand != <span class="hljs-keyword">null</span> ? cur.rand.next : <span class="hljs-keyword">null</span>;
      cur = next;
   &#125;
   Node res = head.next;
   cur = head;
   <span class="hljs-comment">// split</span>
   <span class="hljs-keyword">while</span> (cur != <span class="hljs-keyword">null</span>) &#123;
      next = cur.next.next;
      curCopy = cur.next;
      cur.next = next;
      curCopy.next = next != <span class="hljs-keyword">null</span> ? next.next : <span class="hljs-keyword">null</span>;
      cur = next;
   &#125;
   <span class="hljs-keyword">return</span> res;
&#125;</code></pre></div>

<p>  不能边设置边断链： <strong>如果后面指向前面，前面已经和自己的 ‘ 断连了，.next已经没有用</strong></p>
<h3 id="与约瑟夫环问题相同的噩梦（相交）"><a href="#与约瑟夫环问题相同的噩梦（相交）" class="headerlink" title="与约瑟夫环问题相同的噩梦（相交）"></a>与约瑟夫环问题相同的噩梦（相交）</h3><p>给定两个可能有环也可能无环的单链表，头节点head1和head2。请实现一个函数，如果两个链表相交，请返回相交的 第一个节点。如果不相交，返回null </p>
<p>相交就是地址共用相同部分！</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201208182234.png" srcset="/img/loading.gif" alt="相交"></p>
<p>【要求】<br> <strong>如果两个链表长度之和为N，时间复杂度请达到O(N)，额外空间复杂度 请达到O(1)。</strong></p>
<blockquote>
<p>先设计 Node f(head) 返回 <strong>入环第一个结点</strong></p>
</blockquote>
<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201208182419.png" srcset="/img/loading.gif" alt="入环结点" style="zoom:50%;" />

<p>如果整个是环，就是head</p>
<p> <strong>一个链表只有一个next指针，进了环，是不能出来的。</strong></p>
<p>可以用set<Node> 先查有没有在set里，查到第一个在的就是入环结点，没有环一定走到空上。</p>
<ul>
<li><p>不用set:</p>
<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201208183357.png" srcset="/img/loading.gif" alt="流程" style="zoom:50%;" />

<p>一开始slow和fast指针从head开始出发，slow走一步，fast走两步；</p>
<p>一直这样走下去，slow和fast一定会在同一个地方，当到达同一个地方时： <strong>证明一定有环</strong></p>
<p>slow不变位置，fast回到开头，fast变成一次走一步，slow也继续一次走一步，</p>
<p>当slow和fast再次相交时，这个点就是 <strong>第一个入环点</strong>。</p>
<p>code：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// 找到链表第一个入环节点，如果无环，返回null</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">getLoopNode</span><span class="hljs-params">(Node head)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span> || head.next == <span class="hljs-keyword">null</span> || head.next.next == <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
   &#125;
   <span class="hljs-comment">// n1 慢  n2 快</span>
   Node n1 = head.next; <span class="hljs-comment">// n1 -&gt; slow</span>
   Node n2 = head.next.next; <span class="hljs-comment">// n2 -&gt; fast</span>
   <span class="hljs-keyword">while</span> (n1 != n2) &#123;
      <span class="hljs-keyword">if</span> (n2.next == <span class="hljs-keyword">null</span> || n2.next.next == <span class="hljs-keyword">null</span>) &#123;
         <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
      &#125;
      n2 = n2.next.next;
      n1 = n1.next;
   &#125;
   n2 = head; <span class="hljs-comment">// n2 -&gt; walk again from head</span>
   <span class="hljs-keyword">while</span> (n1 != n2) &#123;
      n1 = n1.next;
      n2 = n2.next;
   &#125;
   <span class="hljs-keyword">return</span> n1;
&#125;</code></pre></div>



</li>
</ul>
<blockquote>
<p>问题解决</p>
</blockquote>
<ol>
<li>如果 <strong>两个无环链表相交</strong>，相交后为全部相交部分。</li>
</ol>
<ul>
<li><p>用set</p>
<p>把一个链表全部注册进去，对第二个链表逐步遍历直到找到第一个相交。</p>
</li>
<li><p>不用set</p>
<p>假设第一个链表100个，第二个链表80个，两个都找到其最后一个结点（即下一个结点为null的结点），分别为end1和end2。</p>
<ul>
<li>判断 end1 是否等于 end2 ，如果不等于， 不相交。</li>
<li>如果 end1 等于 end2， 链表1走（100-80）= 20步，从这里开始链表二也开始走，两个链表肯定会走到第一个相遇的地方。</li>
</ul>
<p>Code:</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// 如果两个链表都无环，返回第一个相交节点，如果不想交，返回null</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">noLoop</span><span class="hljs-params">(Node head1, Node head2)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (head1 == <span class="hljs-keyword">null</span> || head2 == <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
   &#125;
   Node cur1 = head1;
   Node cur2 = head2;
   <span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>;
   <span class="hljs-keyword">while</span> (cur1.next != <span class="hljs-keyword">null</span>) &#123;
      n++;
      cur1 = cur1.next;
   &#125;
   <span class="hljs-keyword">while</span> (cur2.next != <span class="hljs-keyword">null</span>) &#123;
      n--;
      cur2 = cur2.next;
   &#125;
   <span class="hljs-comment">// n = cur1.len - cur2.len</span>
   <span class="hljs-keyword">if</span> (cur1 != cur2) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
   &#125;
   <span class="hljs-comment">// n  :  链表1长度减去链表2长度的值</span>
   cur1 = n &gt; <span class="hljs-number">0</span> ? head1 : head2; <span class="hljs-comment">// 谁长，谁的头变成cur1</span>
   cur2 = cur1 == head1 ? head2 : head1; <span class="hljs-comment">// 谁短，谁的头变成cur2</span>
   n = Math.abs(n);
   <span class="hljs-comment">// 长链表先走</span>
   <span class="hljs-keyword">while</span> (n != <span class="hljs-number">0</span>) &#123;
      n--;
      cur1 = cur1.next;
   &#125;
   <span class="hljs-comment">// 一起走 走到相交点</span>
   <span class="hljs-keyword">while</span> (cur1 != cur2) &#123;
      cur1 = cur1.next;
      cur2 = cur2.next;
   &#125;
   <span class="hljs-keyword">return</span> cur1;
&#125;</code></pre></div>



</li>
</ul>
<ol start="2">
<li>如果 <strong>两个有环链表相交</strong>，一定是 <strong>共用这个环的</strong></li>
</ol>
<p>​ <img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201208190644.png" srcset="/img/loading.gif" alt="三种情况"></p>
<ul>
<li>没有相交部分<ul>
<li>让loop1往下走，如果在 <strong>遇见自己之前一直没碰到loop2</strong>。</li>
</ul>
</li>
<li>入环结点相同<ul>
<li>loop1和loop2不等于空且相同</li>
<li>不用再看环，把入环点作为尾结点，就变成了两个无环单链表相交问题</li>
</ul>
</li>
<li>入环结点不同<ul>
<li> 让loop1往下走，如果在 <strong>遇见自己之前一直碰到了loop2</strong>。</li>
</ul>
</li>
</ul>
<ol start="3">
<li>如果 <strong>一个有环一个无环</strong>， <strong>不可能相交</strong>。</li>
</ol>
<p>​ 因为是单链表。</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// 两个有环链表，返回第一个相交节点，如果不想交返回null</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">bothLoop</span><span class="hljs-params">(Node head1, Node loop1, Node head2, Node loop2)</span> </span>&#123;
   Node cur1 = <span class="hljs-keyword">null</span>;
   Node cur2 = <span class="hljs-keyword">null</span>;
   <span class="hljs-keyword">if</span> (loop1 == loop2) &#123;
      <span class="hljs-comment">// 解决无环问题，只不过end变为loop</span>
      cur1 = head1;
      cur2 = head2;
      <span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">while</span> (cur1 != loop1) &#123;
         n++;
         cur1 = cur1.next;
      &#125;
      <span class="hljs-keyword">while</span> (cur2 != loop2) &#123;
         n--;
         cur2 = cur2.next;
      &#125;
      cur1 = n &gt; <span class="hljs-number">0</span> ? head1 : head2;
      cur2 = cur1 == head1 ? head2 : head1;
      n = Math.abs(n);
      <span class="hljs-keyword">while</span> (n != <span class="hljs-number">0</span>) &#123;
         n--;
         cur1 = cur1.next;
      &#125;
      <span class="hljs-keyword">while</span> (cur1 != cur2) &#123;
         cur1 = cur1.next;
         cur2 = cur2.next;
      &#125;
      <span class="hljs-keyword">return</span> cur1;
   &#125; <span class="hljs-keyword">else</span> &#123;
      cur1 = loop1.next;
      <span class="hljs-keyword">while</span> (cur1 != loop1) &#123;
         <span class="hljs-keyword">if</span> (cur1 == loop2) &#123;
            <span class="hljs-keyword">return</span> loop1;
         &#125;
         cur1 = cur1.next;
      &#125;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
   &#125;
&#125;</code></pre></div>

<p>最后总结：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">getIntersectNode</span><span class="hljs-params">(Node head1, Node head2)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (head1 == <span class="hljs-keyword">null</span> || head2 == <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
   &#125;
   Node loop1 = getLoopNode(head1);
   Node loop2 = getLoopNode(head2);
   <span class="hljs-keyword">if</span> (loop1 == <span class="hljs-keyword">null</span> &amp;&amp; loop2 == <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">return</span> noLoop(head1, head2);
   &#125;
   <span class="hljs-keyword">if</span> (loop1 != <span class="hljs-keyword">null</span> &amp;&amp; loop2 != <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">return</span> bothLoop(head1, loop1, head2, loop2);
   &#125;
   <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
&#125;</code></pre></div>



<h3 id="能不能不给单链表的头节点，只给想要删除的节点，就能做到在链表上把这个点删掉？"><a href="#能不能不给单链表的头节点，只给想要删除的节点，就能做到在链表上把这个点删掉？" class="headerlink" title="能不能不给单链表的头节点，只给想要删除的节点，就能做到在链表上把这个点删掉？"></a>能不能不给单链表的头节点，只给想要删除的节点，就能做到在链表上把这个点删掉？</h3><p>把下一个值赋给当前结点，当前结点跳到下下个。</p>
<p>1）但 <strong>实际上没有删除 “自己”，只是替代了内容！</strong></p>
<p>2）如果不再是简单的结点问题，而是服务器问题， <strong>拷贝</strong>会变成一件很困难的事情！</p>
<p>3） <strong>绝对无法删除链表最后一个结点的！</strong>没有办法改前一个结点的走向。NULL是一个特定系统区域，去调析构函数是没有用的！</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201208192831.png" srcset="/img/loading.gif" alt="test代码"></p>
<blockquote>
<p>为什么不行？</p>
</blockquote>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201208192918.png" srcset="/img/loading.gif" alt="原因"></p>
<p>c = null;只是让c没有指向Node(3), 但Node(2)还是指向Node(3)了！</p>
<h1 id="二叉树的基本算法"><a href="#二叉树的基本算法" class="headerlink" title="二叉树的基本算法"></a>二叉树的基本算法</h1><blockquote>
<p>结构描述：</p>
</blockquote>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;
  V value;
  Node left;
  Node right;
&#125;</code></pre></div>

<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> value;
   <span class="hljs-keyword">public</span> Node left;
   <span class="hljs-keyword">public</span> Node right;

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v)</span> </span>&#123;
      value = v;
   &#125;
&#125;</code></pre></div>



<h2 id="二叉树的先序、中序、后序遍历"><a href="#二叉树的先序、中序、后序遍历" class="headerlink" title="二叉树的先序、中序、后序遍历"></a>二叉树的先序、中序、后序遍历</h2><p>​ <img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201209164047.png" srcset="/img/loading.gif" alt="如图"></p>
<ul>
<li><p>先序：任何子树的处理顺序都是，先头节点、再左子树、然后右子树</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// 先序打印所有结点</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pre</span><span class="hljs-params">(Node head)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">return</span>;
   &#125;
   System.out.println(head.value);
   pre(head.left);
   pre(head.right);
&#125;</code></pre></div>

<p>​ </p>
</li>
<li><p>中序：任何子树的处理顺序都是，先左子树、再头节点、然后右子树</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">in</span><span class="hljs-params">(Node head)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">return</span>;
   &#125;
   in(head.left);
   System.out.println(head.value);
   in(head.right);
&#125;</code></pre></div>



</li>
</ul>
<ul>
<li><p>后序：任何子树的处理顺序都是，先左子树、再右子树、然后头节点</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pos</span><span class="hljs-params">(Node head)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">return</span>;
   &#125;
   pos(head.left);
   pos(head.right);
   System.out.println(head.value);
&#125;</code></pre></div>



</li>
</ul>
<h3 id="递归的本质是-递归序"><a href="#递归的本质是-递归序" class="headerlink" title="递归的本质是  递归序"></a>递归的本质是  <strong>递归序</strong></h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201209170646.png" srcset="/img/loading.gif" alt="流程"></p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(Node head)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">return</span>;
   &#125;
   <span class="hljs-comment">// 先序</span>
   f(head.left);
   <span class="hljs-comment">// 中序</span>
   f(head.right);
   <span class="hljs-comment">// 后序</span>
&#125;</code></pre></div>

<p>对于这样的代码，一定会 <strong>访问(返回)</strong> 三次：</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201209170852.png" srcset="/img/loading.gif" alt="每一个结点都会到达三次"></p>
<p>先序就是每一次第一次到达了就打印：</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201209171028.png" srcset="/img/loading.gif" alt="第一次到达打印就是先序"></p>
<p>先序，中序，后序只是 <strong>递归序的结果</strong>。</p>
<p>所以在树上做动态规划的前提就是 <strong>每一个结点都会到此，走左边再回来，走右边再回来。</strong></p>
<p>让一个东西来到 <strong>此地三次！</strong></p>
<ul>
<li>理解递归序</li>
<li>先序、中序、后序都可以在递归序的基础上加工出来</li>
<li>第一次到达一个节点就打印就是先序、第二次打印即中序、第三次即后序</li>
</ul>
<h3 id="非递归方式实现二叉树的先序、中序、后序遍历"><a href="#非递归方式实现二叉树的先序、中序、后序遍历" class="headerlink" title="非递归方式实现二叉树的先序、中序、后序遍历"></a>非递归方式实现二叉树的先序、中序、后序遍历</h3><ul>
<li><p>任何递归函数都可以改成非递归</p>
</li>
<li><p>非递归实现先序遍历</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// 先序遍历</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pre</span><span class="hljs-params">(Node head)</span> </span>&#123;
   System.out.print(<span class="hljs-string">&quot;pre-order: &quot;</span>);
   <span class="hljs-keyword">if</span> (head != <span class="hljs-keyword">null</span>) &#123;
      Stack&lt;Node&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;Node&gt;();
      stack.add(head);
      <span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;
         head = stack.pop();
         System.out.print(head.value + <span class="hljs-string">&quot; &quot;</span>);
         <span class="hljs-keyword">if</span> (head.right != <span class="hljs-keyword">null</span>) &#123;
            stack.push(head.right);
         &#125;
         <span class="hljs-keyword">if</span> (head.left != <span class="hljs-keyword">null</span>) &#123;
            stack.push(head.left);
         &#125;
      &#125;
   &#125;
   System.out.println();
&#125;</code></pre></div>

<ul>
<li><p>先放头结点，弹出就打印</p>
</li>
<li><p>弹出打印后，如果有右孩子，先压入右孩子</p>
</li>
<li><p>如果有左孩子，再压入右孩子</p>
</li>
<li><p>例如对上面的树，先压入1，弹出1，压入3、2，弹出2，压入5、4，弹出4，弹出5，弹出3，压入7、6，弹出6、7</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>非递归实现后序遍历</p>
<ul>
<li><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201209172717.png" srcset="/img/loading.gif" alt="流程与先序相反"></p>
</li>
<li><p> 如果上述，先压左再压入右， 头左右就会变成头右左，正好是后序的相反。</p>
</li>
</ul>
<p>Code:</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pos1</span><span class="hljs-params">(Node head)</span> </span>&#123;
   System.out.print(<span class="hljs-string">&quot;pos-order: &quot;</span>);
   <span class="hljs-keyword">if</span> (head != <span class="hljs-keyword">null</span>) &#123;
      Stack&lt;Node&gt; s1 = <span class="hljs-keyword">new</span> Stack&lt;Node&gt;();
      Stack&lt;Node&gt; s2 = <span class="hljs-keyword">new</span> Stack&lt;Node&gt;();
      s1.push(head);
      <span class="hljs-keyword">while</span> (!s1.isEmpty()) &#123;
         head = s1.pop();
         <span class="hljs-comment">// 转移到s2里面，先序这里是直接打印</span>
         s2.push(head);
         <span class="hljs-comment">// 先压左</span>
         <span class="hljs-keyword">if</span> (head.left != <span class="hljs-keyword">null</span>) &#123;
            s1.push(head.left);
         &#125;
         <span class="hljs-keyword">if</span> (head.right != <span class="hljs-keyword">null</span>) &#123;
            s1.push(head.right);
         &#125;
      &#125;
      <span class="hljs-keyword">while</span> (!s2.isEmpty()) &#123;
         System.out.print(s2.pop().value + <span class="hljs-string">&quot; &quot;</span>);
      &#125;
   &#125;
   System.out.println();
&#125;</code></pre></div>
</li>
<li><p>非递归实现后序遍历（方法二）</p>
<ul>
<li><p>死亡代码</p>
</li>
<li><p>左边到最底下，弹出一个往上管右边，右边再找左边最底下，直到把左边处理完再处理右边再处理自己。</p>
</li>
</ul>
</li>
</ul>
  <div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pos2</span><span class="hljs-params">(Node h)</span> </span>&#123;
   System.out.print(<span class="hljs-string">&quot;pos-order: &quot;</span>);
   <span class="hljs-keyword">if</span> (h != <span class="hljs-keyword">null</span>) &#123;
      Stack&lt;Node&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;Node&gt;();
      stack.push(h);
      Node c = <span class="hljs-keyword">null</span>;
      <span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;
         c = stack.peek();
         <span class="hljs-comment">// 左树没处理先处理左树</span>
         <span class="hljs-keyword">if</span> (c.left != <span class="hljs-keyword">null</span> &amp;&amp; h != c.left &amp;&amp; h != c.right) &#123;
            stack.push(c.left);
         <span class="hljs-comment">// 右树没处理先处理右树</span>
         &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c.right != <span class="hljs-keyword">null</span> &amp;&amp; h != c.right) &#123;
            stack.push(c.right);
         <span class="hljs-comment">// 该处理自己了</span>
         &#125; <span class="hljs-keyword">else</span> &#123;
            System.out.print(stack.pop().value + <span class="hljs-string">&quot; &quot;</span>);
            <span class="hljs-comment">// h跟踪上次打印的结点</span>
            h = c;
         &#125;
      &#125;
   &#125;
   System.out.println();
&#125;</code></pre></div>



<ul>
<li><p>非递归实现中序遍历</p>
<ul>
<li><p>整条左边界依次入栈</p>
</li>
<li><p>第一条逻辑无法再命中，就弹出结点并打印，然后来到弹出结点的右树上继续执行条件一</p>
</li>
<li><p>如上面的树，左边界全入栈，栈顶 - &gt; 栈底以此为 4,2,1，不能再命中了，弹出4，来到4的右孩子且为Null，弹出2，来到2的右孩子且为5，压入5，弹出5，来到5的右孩子且为Null，弹出1，来到1的右孩子3，3、6依此入栈，弹出6，来到6的右孩子且为Null，弹出3，来到3的右孩子且为7，弹出7。</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// 左头无限分解</span>
<span class="hljs-comment">// 左边左头分解，右边也左头分解</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">in</span><span class="hljs-params">(Node head)</span> </span>&#123;
    System.out.print(<span class="hljs-string">&quot;in-order: &quot;</span>);
    <span class="hljs-keyword">if</span> (head != <span class="hljs-keyword">null</span>) &#123;
      Stack&lt;Node&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;Node&gt;();
      <span class="hljs-keyword">while</span> (!stack.isEmpty() || head != <span class="hljs-keyword">null</span>) &#123;
        <span class="hljs-comment">// 把左边全压入</span>
        <span class="hljs-keyword">if</span> (head != <span class="hljs-keyword">null</span>) &#123;
          stack.push(head);
          head = head.left;
        &#125; <span class="hljs-keyword">else</span> &#123;
          head = stack.pop();
          System.out.print(head.value + <span class="hljs-string">&quot; &quot;</span>);
          head = head.right;
        &#125;
      &#125;
    &#125;
    System.out.println();
  &#125;</code></pre></div>



</li>
</ul>
</li>
</ul>
<h2 id="实现二叉树的按层遍历"><a href="#实现二叉树的按层遍历" class="headerlink" title="实现二叉树的按层遍历"></a>实现二叉树的按层遍历</h2><ul>
<li><p>其实就是 <strong>宽度优先遍历</strong> ，用 <strong>队列</strong></p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">level</span><span class="hljs-params">(Node head)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">return</span>;
   &#125;
   Queue&lt;Node&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();
   queue.add(head);
   <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;
      Node cur = queue.poll();
      System.out.println(cur.value);
      <span class="hljs-keyword">if</span> (cur.left != <span class="hljs-keyword">null</span>) &#123;
         queue.add(cur.left);
      &#125;
      <span class="hljs-keyword">if</span> (cur.right != <span class="hljs-keyword">null</span>) &#123;
         queue.add(cur.right);
      &#125;
   &#125;
&#125;</code></pre></div>

<ul>
<li><p>先把头结点加入</p>
</li>
<li><p>开始循环，弹出打印，先加左再加右</p>
</li>
<li><p>1弹出，2、3进，2弹出，4、5进，3弹出，6、7进…..</p>
</li>
</ul>
</li>
</ul>
<h3 id="二叉树最大宽度"><a href="#二叉树最大宽度" class="headerlink" title="二叉树最大宽度"></a>二叉树最大宽度</h3><ul>
<li><p>可以通过设置 <strong>flag变量</strong> 的方式，来发现某一层的 <strong>结束</strong>（看题目）</p>
<p>如：找到二叉树最宽的一层，建议一个发现机制就行，发现结束就意味着开始。</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// 寻找到二叉树最大宽度</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxWidthUseMap</span><span class="hljs-params">(Node head)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
   &#125;
   Queue&lt;Node&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();
   queue.add(head);
   <span class="hljs-comment">// key在哪一层</span>
   HashMap&lt;Node, Integer&gt; levelMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
   levelMap.put(head, <span class="hljs-number">1</span>);
   <span class="hljs-comment">// 当前正在统计哪一层的宽度</span>
   <span class="hljs-keyword">int</span> curLevel = <span class="hljs-number">1</span>;
   <span class="hljs-comment">// 当前正在统计层的宽度是多少</span>
   <span class="hljs-keyword">int</span> curLevelNodes = <span class="hljs-number">0</span>; <span class="hljs-comment">// 一律规定出来的时候加，初始为0</span>
   <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;
   <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;
      Node cur = queue.poll();
      <span class="hljs-comment">// 当前层级别</span>
      <span class="hljs-keyword">int</span> curNodeLevel = levelMap.get(cur);
      <span class="hljs-keyword">if</span> (cur.left != <span class="hljs-keyword">null</span>) &#123;
         levelMap.put(cur.left, curNodeLevel + <span class="hljs-number">1</span>);
         queue.add(cur.left);
      &#125;
      <span class="hljs-keyword">if</span> (cur.right != <span class="hljs-keyword">null</span>) &#123;
         levelMap.put(cur.right, curNodeLevel + <span class="hljs-number">1</span>);
         queue.add(cur.right);
      &#125;
      <span class="hljs-keyword">if</span> (curNodeLevel == curLevel) &#123;
         curLevelNodes++;
      &#125; <span class="hljs-keyword">else</span> &#123;
         max = Math.max(max, curLevelNodes);
         curLevel++;
         curLevelNodes = <span class="hljs-number">1</span>;
      &#125;
   &#125;
   <span class="hljs-comment">// 最后一层没有出发max机制</span>
   max = Math.max(max, curLevelNodes);
   <span class="hljs-keyword">return</span> max;
&#125;</code></pre></div>

<p>用map记录结点位置（每一个新层到来结算上一层的老层）</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201210083532.png" srcset="/img/loading.gif" alt="流程"></p>
</li>
</ul>
<ul>
<li><p>不用map寻找最大宽度机制：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxWidthNoMap</span><span class="hljs-params">(Node head)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
   &#125;
   Queue&lt;Node&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();
   queue.add(head);
   <span class="hljs-comment">// 当前层最右结点是谁</span>
   Node curEnd = head;
   <span class="hljs-comment">// 如果有下一层，下一层最右结点是谁</span>
   Node nextEnd = <span class="hljs-keyword">null</span>;
   <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;
   <span class="hljs-keyword">int</span> curLevelNodes = <span class="hljs-number">0</span>; <span class="hljs-comment">// 当前层结点数</span>
   <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;
      Node cur = queue.poll();
      <span class="hljs-keyword">if</span> (cur.left != <span class="hljs-keyword">null</span>) &#123;
         queue.add(cur.left);
         nextEnd = cur.left;
      &#125;
      <span class="hljs-keyword">if</span> (cur.right != <span class="hljs-keyword">null</span>) &#123;
         queue.add(cur.right);
         nextEnd = cur.right;
      &#125;
      curLevelNodes++;
      <span class="hljs-comment">// 当前层结点是否为当前层最右结点</span>
      <span class="hljs-keyword">if</span> (cur == curEnd) &#123;
         max = Math.max(max, curLevelNodes);
         curLevelNodes = <span class="hljs-number">0</span>;
         curEnd = nextEnd;
      &#125;
   &#125;</code></pre></div>



</li>
</ul>
<h2 id="二叉树的序列化和反序列化"><a href="#二叉树的序列化和反序列化" class="headerlink" title="二叉树的序列化和反序列化"></a>二叉树的序列化和反序列化</h2><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201210085559.png" srcset="/img/loading.gif" alt="序列化"></p>
<h3 id="先序序列化"><a href="#先序序列化" class="headerlink" title="先序序列化"></a>先序序列化</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Queue&lt;String&gt; <span class="hljs-title">preSerial</span><span class="hljs-params">(Node head)</span> </span>&#123;
   Queue&lt;String&gt; ans = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();
   pres(head, ans);
   <span class="hljs-keyword">return</span> ans;
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pres</span><span class="hljs-params">(Node head, Queue&lt;String&gt; ans)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;
      ans.add(<span class="hljs-keyword">null</span>);
   &#125; <span class="hljs-keyword">else</span> &#123;
      ans.add(String.valueOf(head.value));
      pres(head.left, ans);
      pres(head.right, ans);
   &#125;
&#125;</code></pre></div>



<h3 id="已知序列化好的队列，还原树"><a href="#已知序列化好的队列，还原树" class="headerlink" title="已知序列化好的队列，还原树"></a>已知序列化好的队列，还原树</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">buildByPreQueue</span><span class="hljs-params">(Queue&lt;String&gt; prelist)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (prelist == <span class="hljs-keyword">null</span> || prelist.size() == <span class="hljs-number">0</span>) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
   &#125;
   <span class="hljs-keyword">return</span> preb(prelist);
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">preb</span><span class="hljs-params">(Queue&lt;String&gt; prelist)</span> </span>&#123;
   String value = prelist.poll();
   <span class="hljs-keyword">if</span> (value == <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
   &#125;
   Node head = <span class="hljs-keyword">new</span> Node(Integer.valueOf(value));
   head.left = preb(prelist);
   head.right = preb(prelist);
   <span class="hljs-keyword">return</span> head;
&#125;</code></pre></div>

<blockquote>
<p>中序、后序只需要改一下顺序就可以了</p>
</blockquote>
<h3 id="按层序列化"><a href="#按层序列化" class="headerlink" title="按层序列化"></a>按层序列化</h3><p>整体上就是 <strong>宽度优先遍历</strong></p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Queue&lt;String&gt; <span class="hljs-title">levelSerial</span><span class="hljs-params">(Node head)</span> </span>&#123;
   <span class="hljs-comment">// 序列化结果</span>
   Queue&lt;String&gt; ans = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();
   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;
      ans.add(<span class="hljs-keyword">null</span>);
   &#125; <span class="hljs-keyword">else</span> &#123;
      ans.add(String.valueOf(head.value));
      Queue&lt;Node&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;Node&gt;();
      queue.add(head);
      <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;
         head = queue.poll();
         <span class="hljs-keyword">if</span> (head.left != <span class="hljs-keyword">null</span>) &#123;
            <span class="hljs-comment">// 即序列化 也加队列</span>
            ans.add(String.valueOf(head.left.value));
            queue.add(head.left);
         &#125; <span class="hljs-keyword">else</span> &#123;
            <span class="hljs-comment">// 只序列化</span>
            ans.add(<span class="hljs-keyword">null</span>);
         &#125;
         <span class="hljs-keyword">if</span> (head.right != <span class="hljs-keyword">null</span>) &#123;
            ans.add(String.valueOf(head.right.value));
            queue.add(head.right);
         &#125; <span class="hljs-keyword">else</span> &#123;
            ans.add(<span class="hljs-keyword">null</span>);
         &#125;
      &#125;
   &#125;
   <span class="hljs-keyword">return</span> ans;
&#125;</code></pre></div>

<p>其实就是多了一个ans队列，把空补齐。层序遍历的时候只有一个queue，queue里面放的一定不为null，再弹出判断。序列化只是ans可以放null，自己另外准备的queue不放null进行层序遍历而已。</p>
<h3 id="按层反序列化"><a href="#按层反序列化" class="headerlink" title="按层反序列化"></a>按层反序列化</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">buildByLevelQueue</span><span class="hljs-params">(Queue&lt;String&gt; levelList)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (levelList == <span class="hljs-keyword">null</span> || levelList.size() == <span class="hljs-number">0</span>) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
   &#125;
   Node head = generateNode(levelList.poll());
   Queue&lt;Node&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;Node&gt;();
   <span class="hljs-keyword">if</span> (head != <span class="hljs-keyword">null</span>) &#123;
      queue.add(head);
   &#125;
   Node node = <span class="hljs-keyword">null</span>;
   <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;
      node = queue.poll();
      node.left = generateNode(levelList.poll());
      node.right = generateNode(levelList.poll());
      <span class="hljs-keyword">if</span> (node.left != <span class="hljs-keyword">null</span>) &#123;
         queue.add(node.left);
      &#125;
      <span class="hljs-keyword">if</span> (node.right != <span class="hljs-keyword">null</span>) &#123;
         queue.add(node.right);
      &#125;
   &#125;
   <span class="hljs-keyword">return</span> head;
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">generateNode</span><span class="hljs-params">(String val)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (val == <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
   &#125;
   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Node(Integer.valueOf(val));
&#125;</code></pre></div>



<h2 id="设计一种打印树的方式"><a href="#设计一种打印树的方式" class="headerlink" title="设计一种打印树的方式"></a>设计一种打印树的方式</h2><blockquote>
<p>如何设计一个打印整棵树的打印函数?</p>
</blockquote>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201211094340.png" srcset="/img/loading.gif" alt="打印出来的效果"></p>
<p>Code:</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printTree</span><span class="hljs-params">(Node head)</span> </span>&#123;
   System.out.println(<span class="hljs-string">&quot;Binary Tree:&quot;</span>);
   printInOrder(head, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;H&quot;</span>, <span class="hljs-number">17</span>);
   System.out.println();
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printInOrder</span><span class="hljs-params">(Node head, <span class="hljs-keyword">int</span> height, String to, <span class="hljs-keyword">int</span> len)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">return</span>;
   &#125;
   printInOrder(head.right, height + <span class="hljs-number">1</span>, <span class="hljs-string">&quot;v&quot;</span>, len);
   String val = to + head.value + to;
   <span class="hljs-keyword">int</span> lenM = val.length();
   <span class="hljs-keyword">int</span> lenL = (len - lenM) / <span class="hljs-number">2</span>;
   <span class="hljs-keyword">int</span> lenR = len - lenM - lenL;
   val = getSpace(lenL) + val + getSpace(lenR);
   System.out.println(getSpace(height * len) + val);
   printInOrder(head.left, height + <span class="hljs-number">1</span>, <span class="hljs-string">&quot;^&quot;</span>, len);
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getSpace</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;
   String space = <span class="hljs-string">&quot; &quot;</span>;
   StringBuffer buf = <span class="hljs-keyword">new</span> StringBuffer(<span class="hljs-string">&quot;&quot;</span>);
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; num; i++) &#123;
      buf.append(space);
   &#125;
   <span class="hljs-keyword">return</span> buf.toString();
&#125;</code></pre></div>

<p>思路：</p>
<p>要打印上面的树，实际上就是按照 <strong>右头左</strong> 的顺序打印。</p>
<p> <strong>printInOrder</strong> 函数就是先打印右边，再头，再左边。</p>
<p>对于每个要打印的当前头部：height表示高度，to标识二叉树左右子树分支关系或头结点关系，len表示当前数字占用的距离。中间的打印头过程其实就是对当前头结点“渲染”了一下而已。</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201211095016.png" srcset="/img/loading.gif" alt="例子"></p>
<p>前面的空格数由层数决定，每个数字占17位，前后补气空格</p>
<h2 id="特殊二叉树返回该节点的后继节点"><a href="#特殊二叉树返回该节点的后继节点" class="headerlink" title="特殊二叉树返回该节点的后继节点"></a>特殊二叉树返回该节点的后继节点</h2><p>二叉树结构如下定义：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;
  V value;
  Node left;
  Node right;
  Node parent;
&#125;</code></pre></div>

<blockquote>
<p>后继结点定义</p>
</blockquote>
<p>后继结点是：<strong>中序遍历</strong> 中一个结点的下一个结点。 </p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201211095339.png" srcset="/img/loading.gif" alt="后继结点"></p>
<ul>
<li><p>思路一</p>
<p>因为有parent结点，所以可以一直往上找，找到头结点。再根据头结点 <strong>中序遍历</strong> ，最后根据 <strong>中序遍历</strong> 的结果找后继结点。 <strong>时间复杂度为 O(N)</strong></p>
</li>
</ul>
<ul>
<li><p>思路二</p>
<ul>
<li><p>假设当前结点距离后继结点距离为k，此方法 <strong>时间复杂度为O(K)</strong></p>
</li>
<li><p>对于 <strong>有右子树</strong> 的结点，其 <strong>后继结点就是右子树最左结点</strong> 。</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201211095756.png" srcset="/img/loading.gif" alt="有右树的情况"></p>
</li>
<li><p>对于 <strong>没有右子树</strong> 的结点，如果 <strong>我是我的父节点的右孩子</strong>  ，<strong>就一直往上找</strong> ，直到到达的结点为当前结点 <strong>父节点的左孩子</strong>，这个父节点就是后继结点。</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201211100108.png" srcset="/img/loading.gif" alt="后继"></p>
</li>
<li><p>由此可以定义: 如果 <strong>结点a左子树上的最右结点(最后打印的结点)为b</strong> ，则a为b的后继结点。</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201211100308.png" srcset="/img/loading.gif" alt="结论"></p>
</li>
<li><p>整棵树的最右结点的后继结点为空</p>
</li>
</ul>
<p>code:</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">getSuccessorNode</span><span class="hljs-params">(Node node)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (node == <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">return</span> node;
   &#125;
   <span class="hljs-keyword">if</span> (node.right != <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">return</span> getLeftMost(node.right);
   &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 无右子树</span>
      Node parent = node.parent;
      <span class="hljs-keyword">while</span> (parent != <span class="hljs-keyword">null</span> &amp;&amp; parent.left != node) &#123; <span class="hljs-comment">// 当前节点是其父亲节点右孩子</span>
         node = parent;
         parent = node.parent;
      &#125;
      <span class="hljs-keyword">return</span> parent;
   &#125;
&#125;

<span class="hljs-comment">// 找最左边</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">getLeftMost</span><span class="hljs-params">(Node node)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (node == <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">return</span> node;
   &#125;
   <span class="hljs-keyword">while</span> (node.left != <span class="hljs-keyword">null</span>) &#123;
      node = node.left;
   &#125;
   <span class="hljs-keyword">return</span> node;
&#125;</code></pre></div>

</li>
</ul>
<h3 id="前驱结点"><a href="#前驱结点" class="headerlink" title="前驱结点"></a>前驱结点</h3><p>正好相反，先找有无左子树，如果有，找左子树最右结点。</p>
<p>如果没有左子树，如果当前结点为父节点的左孩子，一直往上直到当前结点为父节点的右孩子。</p>
<h2 id="折痕问题"><a href="#折痕问题" class="headerlink" title="折痕问题"></a>折痕问题</h2><p>请把一段纸条竖着放在桌子上，然后从纸条的下边向上方对折1次，压出折痕后展开。此时折痕是凹下去的，即折痕突起的方向指向纸条的背面。 如果从纸条的下边向上方连续对折2次，压出折痕后展开，此时有三条折痕，从上到下依次是下折痕、下折痕和上折痕。 </p>
<p>给定一个输入参数N，代表纸条都从下边向上方连续对折N次。 请从上到下打印所有折痕的方向。<br>例如:N=1时，打印: down N=2时，打印: down down up </p>
<ul>
<li>实际对折，会发现：每次对折都会在当前折痕前面加一个down，后面加一个up。</li>
</ul>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201211101348.png" srcset="/img/loading.gif" alt="图解"></p>
<ul>
<li><p>所以实际上就是中序遍历</p>
<ul>
<li>如果用数组实现，N次折产生2的n次方-1个折痕，浪费空间。</li>
<li>新code:</li>
</ul>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printAllFolds</span><span class="hljs-params">(<span class="hljs-keyword">int</span> N)</span> </span>&#123;
   printProcess(<span class="hljs-number">1</span>, N, <span class="hljs-keyword">true</span>);
&#125;

<span class="hljs-comment">// 递归过程，来到了某一个节点，</span>
<span class="hljs-comment">// i是节点的层数，N一共的层数，down == true  凹    down == false 凸</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printProcess</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> N, <span class="hljs-keyword">boolean</span> down)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (i &gt; N) &#123;
      <span class="hljs-keyword">return</span>;
   &#125;
   printProcess(i + <span class="hljs-number">1</span>, N, <span class="hljs-keyword">true</span>);
   System.out.println(down ? <span class="hljs-string">&quot;凹 &quot;</span> : <span class="hljs-string">&quot;凸 &quot;</span>);
   printProcess(i + <span class="hljs-number">1</span>, N, <span class="hljs-keyword">false</span>);
&#125;</code></pre></div>

<ul>
<li>空间复杂度 O(N) 创建了N个i</li>
</ul>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201211101703.png" srcset="/img/loading.gif" alt="流程"></p>
</li>
</ul>
<h1 id="二叉树的递归套路"><a href="#二叉树的递归套路" class="headerlink" title="二叉树的递归套路"></a>二叉树的递归套路</h1><blockquote>
<p>本质是利用递归遍历二叉树的 <strong>便利性</strong> (会到每个结点 <strong>3次</strong> )</p>
</blockquote>
<p>潜意识：任何结点x为头的树，可以得到 <strong>左右子树信息</strong> ，并利用此信息求解过程。</p>
<p>1）假设以X节点为头，假设可以向X左树和X右树要任何信息</p>
<p>2）在上一步的假设下，讨论以X为头节点的树，得到答案的可能性（最重要）</p>
<p>3）列出所有可能性后，确定到底需要向左树和右树要什么样的信息</p>
<p>3）列出所有可能性后，确定到底需要向左树和右树要什么样的信息</p>
<p>4）把左树信息和右树信息求全集，就是任何一棵子树都需要返回的信息S</p>
<p>5）递归函数都返回S，每一棵子树都这么要求</p>
<p>6）写代码，在代码中考虑如何把左树的信息和右树信息整合出整棵树的信</p>
<h2 id="给定一棵二叉树的头节点head，返回这颗二叉树是不是平衡二叉树"><a href="#给定一棵二叉树的头节点head，返回这颗二叉树是不是平衡二叉树" class="headerlink" title="给定一棵二叉树的头节点head，返回这颗二叉树是不是平衡二叉树"></a>给定一棵二叉树的头节点head，返回这颗二叉树是不是平衡二叉树</h2><p>二叉树中每一颗子树，左数的 <strong>高度差</strong> 与右树的高度差不超过 1。</p>
<ol>
<li>左树平衡 2) 右树平衡 3) 左右树高度差不大于一            <strong>|左高 - 右高| &lt; 2</strong></li>
</ol>
<p>在能确定获取子树信息情况下列出可能性：要的信息： <strong>是否平衡， 高度多少</strong></p>
<p>求解过程就变成如何返回信息的过程：</p>
<p>平衡树info：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// 左树和右树要求一样的</span>
<span class="hljs-comment">// 信息返回的结构体</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Info</span> </span>&#123;
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> isBalaced;
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> height;

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Info</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> b, <span class="hljs-keyword">int</span> h)</span> </span>&#123;
      isBalaced = b;
      height = h;
   &#125;
&#125;</code></pre></div>

<p>code:</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isBalanced2</span><span class="hljs-params">(Node head)</span> </span>&#123;
   <span class="hljs-keyword">return</span> process2(head).isBalaced;
&#125;

<span class="hljs-comment">// 左树和右树要求一样的</span>
<span class="hljs-comment">// 信息返回的结构体</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Info</span> </span>&#123;
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> isBalaced;
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> height;

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Info</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> b, <span class="hljs-keyword">int</span> h)</span> </span>&#123;
      isBalaced = b;
      height = h;
   &#125;
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Info <span class="hljs-title">process2</span><span class="hljs-params">(Node head)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Info(<span class="hljs-keyword">true</span>, <span class="hljs-number">0</span>);
   &#125;
   Info leftInfo = process2(head.left);
   Info rightInfo = process2(head.right);
   <span class="hljs-keyword">int</span> height = Math.max(leftInfo.height, rightInfo.height) + <span class="hljs-number">1</span>;
   <span class="hljs-keyword">boolean</span> isBalanced = <span class="hljs-keyword">true</span>;
   <span class="hljs-keyword">if</span> (!leftInfo.isBalaced || !rightInfo.isBalaced || Math.abs(leftInfo.height - rightInfo.height) &gt; <span class="hljs-number">1</span>) &#123;
      isBalanced = <span class="hljs-keyword">false</span>;
   &#125;
   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Info(isBalanced, height);
&#125;</code></pre></div>



<h2 id="给定一棵二叉树的头节点head，任何两个节点之间都存在距离，返回整棵二叉树的最大距离"><a href="#给定一棵二叉树的头节点head，任何两个节点之间都存在距离，返回整棵二叉树的最大距离" class="headerlink" title="给定一棵二叉树的头节点head，任何两个节点之间都存在距离，返回整棵二叉树的最大距离"></a>给定一棵二叉树的头节点head，任何两个节点之间都存在距离，返回整棵二叉树的最大距离</h2><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201211104832.png" srcset="/img/loading.gif" alt="距离"></p>
<p>最大距离不是最左到最后！</p>
<ul>
<li>与x无关时，不跨过x，要么是左树最大距离，要么是右树最大距离。</li>
</ul>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201211105433.png" srcset="/img/loading.gif" alt="最大距离与x无关"></p>
<ul>
<li><p>与x有关时，最大距离会通过x，x左树上离他最远的点走到右树上离他最远的点，也就是左边高度，加自己一步，加右边高度。</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201211105622.png" srcset="/img/loading.gif" alt="有关"></p>
</li>
</ul>
<blockquote>
<p>所以info就需要包含 <strong>最大距离 和 高度</strong></p>
</blockquote>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Info</span> </span>&#123;
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> maxDistance;
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> height;

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Info</span><span class="hljs-params">(<span class="hljs-keyword">int</span> dis, <span class="hljs-keyword">int</span> h)</span> </span>&#123;
      maxDistance = dis;
      height = h;
   &#125;
&#125;</code></pre></div>

<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Info <span class="hljs-title">process</span><span class="hljs-params">(Node head)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Info(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
   &#125;
   Info leftInfo = process(head.left);
   Info rightInfo = process(head.right);
   <span class="hljs-keyword">int</span> height = Math.max(leftInfo.height, rightInfo.height) + <span class="hljs-number">1</span>;
   <span class="hljs-comment">// 返回的 (左子树和右子树最大距离)和(左子树高加上右子树高)的最大值</span>
   <span class="hljs-comment">// 距离只可能为左子树最大距离或者右子树最大距离或者左子树高度加上右子树高度</span>
   <span class="hljs-keyword">int</span> maxDistance = Math.max(Math.max(leftInfo.maxDistance, rightInfo.maxDistance),
         leftInfo.height + rightInfo.height + <span class="hljs-number">1</span>);
   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Info(maxDistance, height);
&#125;</code></pre></div>



<h2 id="给定一棵二叉树的头节点head，返回这颗二叉树中最大的二叉搜索子树的大小（结点的个数）"><a href="#给定一棵二叉树的头节点head，返回这颗二叉树中最大的二叉搜索子树的大小（结点的个数）" class="headerlink" title="给定一棵二叉树的头节点head，返回这颗二叉树中最大的二叉搜索子树的大小（结点的个数）"></a>给定一棵二叉树的头节点head，返回这颗二叉树中最大的二叉搜索子树的大小（结点的个数）</h2><p>搜索二叉树：整个树上没有重复值，左树值都小于父，右树值都大于父</p>
<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201211112015.png" srcset="/img/loading.gif" alt="搜索二叉" style="zoom:50%;" />

<ul>
<li><p>与x无关，就可能为左边子树或者右边子树</p>
</li>
<li><p>与x有关，三个条件，左树整体是搜索二叉树，右树整体是搜索二叉树，左树最大值小于x，右树最大值大于x</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201211113138.png" srcset="/img/loading.gif" alt="条件"></p>
</li>
</ul>
<ul>
<li>左树信息就变成<ul>
<li>左边最大子搜索树大小</li>
<li>是否为最大子搜索树</li>
<li>左树最大值</li>
</ul>
</li>
<li>右树信息就变成<ul>
<li>右边最大子搜索树大小</li>
<li>是否为最大子搜索树</li>
<li>右树最小值</li>
</ul>
</li>
</ul>
<blockquote>
<p>就要用到合并左右树信息</p>
</blockquote>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// 对于任何子树都返回四个信息</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Info</span> </span>&#123;
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> isBST;
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> maxSubBSTSize;
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> min;
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> max;

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Info</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> is, <span class="hljs-keyword">int</span> size, <span class="hljs-keyword">int</span> mi, <span class="hljs-keyword">int</span> ma)</span> </span>&#123;
      isBST = is;
      maxSubBSTSize = size;
      min = mi;
      max = ma;
   &#125;
&#125;</code></pre></div>

<p>算法code：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Info <span class="hljs-title">process</span><span class="hljs-params">(Node head)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
   &#125;
   Info leftInfo = process(head.left);
   Info rightInfo = process(head.right);
   <span class="hljs-keyword">int</span> min = head.value;
   <span class="hljs-keyword">int</span> max = head.value;
   <span class="hljs-keyword">int</span> maxSubBSTSize = <span class="hljs-number">0</span>;
   <span class="hljs-keyword">if</span> (leftInfo != <span class="hljs-keyword">null</span>) &#123;
      min = Math.min(min, leftInfo.min);
      max = Math.max(max, leftInfo.max);
      maxSubBSTSize = Math.max(maxSubBSTSize, leftInfo.maxSubBSTSize);
   &#125;
   <span class="hljs-keyword">if</span> (rightInfo != <span class="hljs-keyword">null</span>) &#123;
      min = Math.min(min, rightInfo.min);
      max = Math.max(max, rightInfo.max);
      maxSubBSTSize = Math.max(maxSubBSTSize, rightInfo.maxSubBSTSize);
   &#125;
   <span class="hljs-keyword">boolean</span> isBST = <span class="hljs-keyword">false</span>;
   <span class="hljs-comment">// 左树是搜索二叉树</span>
   <span class="hljs-comment">// 右树也是搜索二叉树</span>
   <span class="hljs-comment">// 左边max小于x，右边min大于x</span>
   <span class="hljs-keyword">if</span> ((leftInfo == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">true</span> : (leftInfo.isBST &amp;&amp; leftInfo.max &lt; head.value))
         &amp;&amp; (rightInfo == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">true</span> : (rightInfo.isBST &amp;&amp; rightInfo.min &gt; head.value))) &#123;
      isBST = <span class="hljs-keyword">true</span>;
      maxSubBSTSize = (leftInfo == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : leftInfo.maxSubBSTSize)
            + (rightInfo == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : rightInfo.maxSubBSTSize) + <span class="hljs-number">1</span>;
   &#125;
   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Info(isBST, maxSubBSTSize, min, max);
&#125;</code></pre></div>

<p>代码等价：</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201213132931.png" srcset="/img/loading.gif" alt="code"></p>
<h2 id="派对的最大快乐值"><a href="#派对的最大快乐值" class="headerlink" title="派对的最大快乐值"></a>派对的最大快乐值</h2><p>员工信息的定义如下:</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span> </span>&#123;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> happy; <span class="hljs-comment">// 这名员工可以带来的快乐值</span>
    List&lt;Employee&gt; subordinates; <span class="hljs-comment">// 这名员工有哪些直接下级</span>
&#125;</code></pre></div>

<p>多叉树！</p>
<p>​   公司的每个员工都符合 Employee 类的描述。整个公司的人员结构可以看作是一棵标准的、 没有环的多叉树。树的头节点是公司唯一的老板。除老板之外的每个员工都有唯一的直接上级。 叶节点是没有任何下属的基层员工(subordinates列表为空)，除基层员工外，每个员工都有一个或多个直接下级。</p>
<p>这个公司现在要办party，你可以决定哪些员工来，哪些员工不来，规则：</p>
<ul>
<li>如果某个员工来了，那么这个 员工的所有直接下级都不能来</li>
<li>派对的整体快乐值是所有到场员工快乐值的累加</li>
<li>你的目标是让派对的整体快乐值尽量大</li>
<li>给定一棵多叉树的头节点boss，请返回派对的最大快乐值。</li>
</ul>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201213134214.png" srcset="/img/loading.gif" alt="情况分类"></p>
<ol>
<li><p>如果x来，则x的happy，a不来情况下整棵树的最大值，b不来情况下整棵树的最大值，c不来情况下整棵树的最大值</p>
</li>
<li><p>如果x不来，a、b、c不一定会发，应该求Max(a来情况下整棵树最大值，a不来情况下整棵树最大值)</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201213134923.png" srcset="/img/loading.gif" alt="x不来情况"></p>
</li>
<li><p>比较第一种和第二种情况</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Info</span> </span>&#123;
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> yes; <span class="hljs-comment">// 头结点来情况下整棵树最大值</span>
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> no; <span class="hljs-comment">// 头结点不来情况下整棵树最大值</span>

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Info</span><span class="hljs-params">(<span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> n)</span> </span>&#123;
      yes = y;
      no = n;
   &#125;
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Info <span class="hljs-title">process2</span><span class="hljs-params">(Employee x)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (x.nexts.isEmpty()) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Info(x.happy, <span class="hljs-number">0</span>);
   &#125;
   <span class="hljs-keyword">int</span> yes = x.happy;
   <span class="hljs-keyword">int</span> no = <span class="hljs-number">0</span>;
   <span class="hljs-keyword">for</span> (Employee next : x.nexts) &#123;
     <span class="hljs-comment">// 遍历孩子</span>
      Info nextInfo = process2(next);
     <span class="hljs-comment">// 父亲来的值加上子不来</span>
      yes += nextInfo.no;
     <span class="hljs-comment">// 父亲不来值加上子来或不来最大值</span>
      no += Math.max(nextInfo.yes, nextInfo.no);
   &#125;
   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Info(yes, no);
&#125;</code></pre></div>



</li>
</ol>
<h2 id="给定一棵二叉树的头节点head，返回这颗二叉树是不是满二叉树"><a href="#给定一棵二叉树的头节点head，返回这颗二叉树是不是满二叉树" class="headerlink" title="给定一棵二叉树的头节点head，返回这颗二叉树是不是满二叉树"></a>给定一棵二叉树的头节点head，返回这颗二叉树是不是满二叉树</h2><blockquote>
<p>2^L - 1 = N</p>
</blockquote>
<p>找出一棵树的高度和结点个数，组成info。</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Info</span> </span>&#123;
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> height; <span class="hljs-comment">// L</span>
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> nodes; <span class="hljs-comment">// N</span>

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Info</span><span class="hljs-params">(<span class="hljs-keyword">int</span> h, <span class="hljs-keyword">int</span> n)</span> </span>&#123;
      height = h;
      nodes = n;
   &#125;
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Info <span class="hljs-title">process</span><span class="hljs-params">(Node head)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Info(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
   &#125;
   Info leftInfo = process(head.left);
   Info rightInfo = process(head.right);
   <span class="hljs-keyword">int</span> height = Math.max(leftInfo.height, rightInfo.height) + <span class="hljs-number">1</span>;
   <span class="hljs-keyword">int</span> nodes = leftInfo.nodes + rightInfo.nodes + <span class="hljs-number">1</span>;
   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Info(height, nodes);
&#125;</code></pre></div>

<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isFull2</span><span class="hljs-params">(Node head)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
   &#125;
   Info all = process(head);
   <span class="hljs-keyword">return</span> (<span class="hljs-number">1</span> &lt;&lt; all.height) - <span class="hljs-number">1</span> == all.nodes;
&#125;</code></pre></div>



<h2 id="给定一棵二叉树的头节点head，返回这颗二叉树是不是搜索二叉树"><a href="#给定一棵二叉树的头节点head，返回这颗二叉树是不是搜索二叉树" class="headerlink" title="给定一棵二叉树的头节点head，返回这颗二叉树是不是搜索二叉树"></a>给定一棵二叉树的头节点head，返回这颗二叉树是不是搜索二叉树</h2><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Info</span> </span>&#123;
   <span class="hljs-keyword">boolean</span> isBST;
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> min;
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> max;

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Info</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> is, <span class="hljs-keyword">int</span> mi, <span class="hljs-keyword">int</span> ma)</span> </span>&#123;
      isBST = is;
      min = mi;
      max = ma;
   &#125;
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Info <span class="hljs-title">process</span><span class="hljs-params">(Node head)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
   &#125;
   Info leftInfo = process(head.left);
   Info rightInfo = process(head.right);
   <span class="hljs-keyword">int</span> min = head.value;
   <span class="hljs-keyword">int</span> max = head.value;
   <span class="hljs-keyword">if</span> (leftInfo != <span class="hljs-keyword">null</span>) &#123;
      min = Math.min(min, leftInfo.min);
      max = Math.max(max, leftInfo.max);
   &#125;
   <span class="hljs-keyword">if</span> (rightInfo != <span class="hljs-keyword">null</span>) &#123;
      min = Math.min(min, rightInfo.min);
      max = Math.max(max, rightInfo.max);
   &#125;
   <span class="hljs-keyword">boolean</span> isBST = <span class="hljs-keyword">false</span>;
   <span class="hljs-keyword">if</span> (
      (leftInfo == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">true</span> : (leftInfo.isBST &amp;&amp; leftInfo.max &lt; head.value))
      &amp;&amp;
       (rightInfo == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">true</span> : (rightInfo.isBST &amp;&amp; rightInfo.min &gt; head.value))
             ) &#123;
      isBST = <span class="hljs-keyword">true</span>;
   &#125;
   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Info(isBST, min, max);
&#125;</code></pre></div>



<h2 id="给定一棵二叉树的头节点head，返回这颗二叉树中最大的二叉搜索子树的头节点"><a href="#给定一棵二叉树的头节点head，返回这颗二叉树中最大的二叉搜索子树的头节点" class="headerlink" title="给定一棵二叉树的头节点head，返回这颗二叉树中最大的二叉搜索子树的头节点"></a>给定一棵二叉树的头节点head，返回这颗二叉树中最大的二叉搜索子树的头节点</h2><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Info</span> </span>&#123;
  <span class="hljs-comment">// 最大二叉搜索子树的头结点</span>
   <span class="hljs-keyword">public</span> Node maxSubBSTHead;
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> maxSubBSTSize;
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> min;
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> max;

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Info</span><span class="hljs-params">(Node h, <span class="hljs-keyword">int</span> size, <span class="hljs-keyword">int</span> mi, <span class="hljs-keyword">int</span> ma)</span> </span>&#123;
      maxSubBSTHead = h;
      maxSubBSTSize = size;
      min = mi;
      max = ma;
   &#125;
&#125;</code></pre></div>

<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Info <span class="hljs-title">process</span><span class="hljs-params">(Node head)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
   &#125;
   Info leftInfo = process(head.left);
   Info rightInfo = process(head.right);
   <span class="hljs-keyword">int</span> min = head.value;
   <span class="hljs-keyword">int</span> max = head.value;
   Node maxSubBSTHead = <span class="hljs-keyword">null</span>;
   <span class="hljs-keyword">int</span> maxSubBSTSize = <span class="hljs-number">0</span>;
   <span class="hljs-keyword">if</span> (leftInfo != <span class="hljs-keyword">null</span>) &#123;
      min = Math.min(min, leftInfo.min);
      max = Math.max(max, leftInfo.max);
      maxSubBSTHead = leftInfo.maxSubBSTHead;
      maxSubBSTSize = leftInfo.maxSubBSTSize;
   &#125;
   <span class="hljs-keyword">if</span> (rightInfo != <span class="hljs-keyword">null</span>) &#123;
      min = Math.min(min, rightInfo.min);
      max = Math.max(max, rightInfo.max);
      <span class="hljs-keyword">if</span> (rightInfo.maxSubBSTSize &gt; maxSubBSTSize) &#123;
         maxSubBSTHead = rightInfo.maxSubBSTHead;
         maxSubBSTSize = rightInfo.maxSubBSTSize;
      &#125;
   &#125;
   <span class="hljs-keyword">if</span> ((leftInfo == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">true</span> : (leftInfo.maxSubBSTHead == head.left &amp;&amp; leftInfo.max &lt; head.value))
         &amp;&amp; (rightInfo == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">true</span> : (rightInfo.maxSubBSTHead == head.right &amp;&amp; rightInfo.min &gt; head.value))) &#123;
      maxSubBSTHead = head;
      maxSubBSTSize = (leftInfo == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : leftInfo.maxSubBSTSize)
            + (rightInfo == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : rightInfo.maxSubBSTSize) + <span class="hljs-number">1</span>;
   &#125;
   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Info(maxSubBSTHead, maxSubBSTSize, min, max);
&#125;</code></pre></div>



<h2 id="给定一棵二叉树的头节点head，返回这颗二叉树中是不是完全二叉树"><a href="#给定一棵二叉树的头节点head，返回这颗二叉树中是不是完全二叉树" class="headerlink" title="给定一棵二叉树的头节点head，返回这颗二叉树中是不是完全二叉树"></a>给定一棵二叉树的头节点head，返回这颗二叉树中是不是完全二叉树</h2><p>要么满，要么从左到右依次变慢。</p>
<p>基本解法：宽度优先遍历</p>
<p>Code1:</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isCBT1</span><span class="hljs-params">(Node head)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
   &#125;
   LinkedList&lt;Node&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();
   <span class="hljs-comment">// 是否遇到过左右两个孩子不双全的节点</span>
   <span class="hljs-keyword">boolean</span> leaf = <span class="hljs-keyword">false</span>;
   Node l = <span class="hljs-keyword">null</span>;
   Node r = <span class="hljs-keyword">null</span>;
   queue.add(head);
   <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;
      head = queue.poll();
      l = head.left;
      r = head.right;
      <span class="hljs-keyword">if</span> (
      <span class="hljs-comment">// 如果遇到了不双全的节点之后，又发现当前节点不是叶节点</span>
      (leaf &amp;&amp; !(l == <span class="hljs-keyword">null</span> &amp;&amp; r == <span class="hljs-keyword">null</span>)) || (l == <span class="hljs-keyword">null</span> &amp;&amp; r != <span class="hljs-keyword">null</span>)) &#123;
         <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
      &#125;
      <span class="hljs-keyword">if</span> (l != <span class="hljs-keyword">null</span>) &#123;
         queue.add(l);
      &#125;
      <span class="hljs-keyword">if</span> (r != <span class="hljs-keyword">null</span>) &#123;
         queue.add(r);
      &#125;
      <span class="hljs-keyword">if</span> (l == <span class="hljs-keyword">null</span> || r == <span class="hljs-keyword">null</span>) &#123;
         leaf = <span class="hljs-keyword">true</span>;
      &#125;
   &#125;
   <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
&#125;</code></pre></div>



<ol>
<li><p>任何结点有右无左，肯定不是。</p>
</li>
<li><p>否则继续，遇到第一个左右孩子不双全的结点，后续遇到的左右结点都必须是叶结点。</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201213164434.png" srcset="/img/loading.gif" alt="流程"></p>
<p>条件2找到缺口，以下必须为叶子结点。</p>
</li>
</ol>
<p>Code2:</p>
<p>根据最后一个结点到哪了进行分类：</p>
<ol>
<li><p>满二叉树，无缺口 （左树满，右树满，高度一样）</p>
</li>
<li><p>有缺口，第一种缺口停左树 ，最后左边有（左完全二叉，右树满，左树高 - 右树高 = 1）</p>
</li>
<li><p>有缺口，左树填满，缺口还没到右边 （左树满，右树满，左树高度 - 右树高度 = 1）</p>
</li>
<li><p>有缺口，左树填满，右树最后左边有，（左树满，右树完全二叉， 左树高度 = 右树高度）</p>
</li>
</ol>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Info</span> </span>&#123;
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> isFull;
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> isCBT;
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> height;

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Info</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> full, <span class="hljs-keyword">boolean</span> cbt, <span class="hljs-keyword">int</span> h)</span> </span>&#123;
      isFull = full;
      isCBT = cbt;
      height = h;
   &#125;
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Info <span class="hljs-title">process</span><span class="hljs-params">(Node head)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Info(<span class="hljs-keyword">true</span>, <span class="hljs-keyword">true</span>, <span class="hljs-number">0</span>);
   &#125;
   Info leftInfo = process(head.left);
   Info rightInfo = process(head.right);
   <span class="hljs-keyword">int</span> height = Math.max(leftInfo.height, rightInfo.height) + <span class="hljs-number">1</span>;
   <span class="hljs-keyword">boolean</span> isFull = leftInfo.isFull &amp;&amp; rightInfo.isFull &amp;&amp; leftInfo.height == rightInfo.height;
   <span class="hljs-keyword">boolean</span> isCBT = <span class="hljs-keyword">false</span>;
   <span class="hljs-keyword">if</span> (isFull) &#123;
      isCBT = <span class="hljs-keyword">true</span>;
   &#125; <span class="hljs-keyword">else</span> &#123;
      <span class="hljs-keyword">if</span> (leftInfo.isCBT &amp;&amp; rightInfo.isCBT) &#123;
         <span class="hljs-keyword">if</span> (leftInfo.isCBT &amp;&amp; rightInfo.isFull &amp;&amp; leftInfo.height == rightInfo.height + <span class="hljs-number">1</span>) &#123;
            isCBT = <span class="hljs-keyword">true</span>;
         &#125;
         <span class="hljs-keyword">if</span> (leftInfo.isFull &amp;&amp; rightInfo.isFull &amp;&amp; leftInfo.height == rightInfo.height + <span class="hljs-number">1</span>) &#123;
            isCBT = <span class="hljs-keyword">true</span>;
         &#125;
         <span class="hljs-keyword">if</span> (leftInfo.isFull &amp;&amp; rightInfo.isCBT &amp;&amp; leftInfo.height == rightInfo.height) &#123;
            isCBT = <span class="hljs-keyword">true</span>;
         &#125;
      &#125;
   &#125;
   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Info(isFull, isCBT, height);
&#125;</code></pre></div>



<h2 id="给定一棵二叉树的头节点head，和另外两个节点a和b。返回a和b的最低公共祖先"><a href="#给定一棵二叉树的头节点head，和另外两个节点a和b。返回a和b的最低公共祖先" class="headerlink" title="给定一棵二叉树的头节点head，和另外两个节点a和b。返回a和b的最低公共祖先"></a>给定一棵二叉树的头节点head，和另外两个节点a和b。返回a和b的最低公共祖先</h2><p>不用套路：整棵树遍历过程中 <strong>生成一张表</strong>，记录父节点。</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201213171301.png" srcset="/img/loading.gif" alt="让Y往上找"></p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">lowestAncestor1</span><span class="hljs-params">(Node head, Node o1, Node o2)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
   &#125;
   HashMap&lt;Node, Node&gt; parentMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
   parentMap.put(head, <span class="hljs-keyword">null</span>);
   fillParentMap(head, parentMap);
   HashSet&lt;Node&gt; o1Set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();
   Node cur = o1;
   o1Set.add(cur);
   <span class="hljs-keyword">while</span> (parentMap.get(cur) != <span class="hljs-keyword">null</span>) &#123;
      cur = parentMap.get(cur);
      o1Set.add(cur);
   &#125;
   cur = o2;
   <span class="hljs-keyword">while</span> (!o1Set.contains(cur)) &#123;
      cur = parentMap.get(cur);
   &#125;
   <span class="hljs-keyword">return</span> cur;
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fillParentMap</span><span class="hljs-params">(Node head, HashMap&lt;Node, Node&gt; parentMap)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (head.left != <span class="hljs-keyword">null</span>) &#123;
      parentMap.put(head.left, head);
      fillParentMap(head.left, parentMap);
   &#125;
   <span class="hljs-keyword">if</span> (head.right != <span class="hljs-keyword">null</span>) &#123;
      parentMap.put(head.right, head);
      fillParentMap(head.right, parentMap);
   &#125;
&#125;</code></pre></div>

<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201213171603.png" srcset="/img/loading.gif" alt="流程" style="zoom:50%;" />

<p>记录e以上都有谁，f网上找，第一个找到的就是。</p>
<p>套路：</p>
<ol>
<li><p>01, 02没有在x上</p>
</li>
<li><p>01, 02只有一个在x上</p>
</li>
<li><p>01, 02都在x为头的树上 A:左树右树各一个，B:左树或者右树包含全</p>
</li>
<li><p>01, 02有一个为x</p>
</li>
</ol>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Info</span> </span>&#123;
   <span class="hljs-comment">// o1,o2最初交汇点</span>
   <span class="hljs-keyword">public</span> Node ans;
   <span class="hljs-comment">// 有无发现过o1</span>
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> findO1;
   <span class="hljs-comment">// 有无发现过o2</span>
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> findO2;

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Info</span><span class="hljs-params">(Node a, <span class="hljs-keyword">boolean</span> f1, <span class="hljs-keyword">boolean</span> f2)</span> </span>&#123;
      ans = a;
      findO1 = f1;
      findO2 = f2;
   &#125;
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Info <span class="hljs-title">process</span><span class="hljs-params">(Node head, Node o1, Node o2)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Info(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>);
   &#125;
   Info leftInfo = process(head.left, o1, o2);
   Info rightInfo = process(head.right, o1, o2);

   <span class="hljs-keyword">boolean</span> findO1 = head == o1 || leftInfo.findO1 || rightInfo.findO1;
   <span class="hljs-keyword">boolean</span> findO2 = head == o2 || leftInfo.findO2 || rightInfo.findO2;
  <span class="hljs-comment">// 找交汇点</span>
   Node ans = <span class="hljs-keyword">null</span>;
  <span class="hljs-comment">// 左树提前交汇了</span>
   <span class="hljs-keyword">if</span> (leftInfo.ans != <span class="hljs-keyword">null</span>) &#123;
      ans = leftInfo.ans;
   &#125;
  <span class="hljs-comment">// 右树提前交汇了</span>
   <span class="hljs-keyword">if</span> (rightInfo.ans != <span class="hljs-keyword">null</span>) &#123;
      ans = rightInfo.ans;
   &#125;
  <span class="hljs-comment">// head为交汇点</span>
   <span class="hljs-keyword">if</span> (ans == <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">if</span> (findO1 &amp;&amp; findO2) &#123;
         ans = head;
      &#125;
   &#125;
   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Info(ans, findO1, findO2);
&#125;</code></pre></div>



<h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><p>1）最 <strong>自然智慧</strong> 的算法</p>
<p>2）用一种局部最功利的标准，总是做出 <strong>在当前看来</strong> 是最好的选择</p>
<p>3）难点在于 <strong>证明局部最功利的标准可以得到全局最优解</strong></p>
<p>4）对于贪心算法的学习主要以增加阅历和经验为主</p>
<p> <strong>能得到最优解</strong> 的例子：一个数组中N个数，全是正数，第m个数 * arr[i] 得到分数，求分数最大最小。</p>
<p>​       排序后相乘就行了。</p>
<p> <strong>无法得到最优解</strong> 的例子：</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201214075537.png" srcset="/img/loading.gif" alt="例子"></p>
<p>贪心求解，每次拿最多数量的 1:</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201214075629.png" srcset="/img/loading.gif" alt="错误解"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201214075705.png" srcset="/img/loading.gif" alt="正确解"></p>
<h2 id="经典问题"><a href="#经典问题" class="headerlink" title="经典问题"></a>经典问题</h2><p>给定一个由字符串组成的 <strong>数组strs</strong> ，<br>必须把所有的字符串 <strong>拼接</strong> 起来，<br>返回所有可能的拼接结果中， <strong>字典序最小</strong>的结果</p>
<h3 id="字典序"><a href="#字典序" class="headerlink" title="字典序"></a>字典序</h3><blockquote>
<p>字典序</p>
</blockquote>
<ul>
<li>字符串长度一样认为字符串就是a-z的正数，即abc小于abk</li>
<li>字符串长度不一样时，短的补长，ac与b就是ac与b0，ac小于b</li>
</ul>
<p>java中compareTo方法就是比较字典序</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201214080633.png" srcset="/img/loading.gif" alt="按照字符串本身字典序排序"></p>
<p>再由字典序小的拼接到大的，并不是对的。</p>
<p> <strong>错误例子</strong> :</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201214080809.png" srcset="/img/loading.gif" alt="错误例子"></p>
<p>正确策略：</p>
<p>x拼接上y，对比y拼接上x的字典序</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201214081014.png" srcset="/img/loading.gif" alt="正确策略"></p>
<p> <strong>例如[b, ba] bab &lt; bba 所以ba放前</strong></p>
<h3 id="排序的传递性"><a href="#排序的传递性" class="headerlink" title="排序的传递性"></a>排序的传递性</h3><blockquote>
<p>排序的传递序，定义的排序是否一定会具有传递性？</p>
</blockquote>
<p>不一定！</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201214081443.png" srcset="/img/loading.gif" alt="没有传递性的例子"></p>
<p>这就如同 <strong>石头剪刀布</strong> 一样，甲乙对比，甲在前；….</p>
<p>如何证明刚才的排序是有传递性的？</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201214081633.png" srcset="/img/loading.gif" alt="传递性"></p>
<p>a.b &lt;= b.a a前，排好序后，在数组中，任何一个位置前.后都 &lt;= 后.前</p>
<blockquote>
<p>证明</p>
</blockquote>
<p>假设认为字符为26位进制，拼接这件事就可以变为数学移位并相加的运算。</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201214082243.png" srcset="/img/loading.gif" alt="移位并相加"></p>
<p>先认为字符串进位为函数m(b) 代表的意义为 K^b次方，b为字符串长度</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201214083309.png" srcset="/img/loading.gif" alt="证明"></p>
<p>中间部分共同含有ac，减掉，再共同除以b，再移动减法位置得到：</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201214083535.png" srcset="/img/loading.gif" alt="结果"></p>
<p>所以这个排序策略是有传递性的。</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201214084002.png" srcset="/img/loading.gif" alt="数学归纳法"></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyComparator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparator</span>&lt;<span class="hljs-title">String</span>&gt; </span>&#123;
   <span class="hljs-meta">@Override</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(String a, String b)</span> </span>&#123;
      <span class="hljs-keyword">return</span> (a + b).compareTo(b + a);
   &#125;
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">lowestString2</span><span class="hljs-params">(String[] strs)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (strs == <span class="hljs-keyword">null</span> || strs.length == <span class="hljs-number">0</span>) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;
   &#125;
   Arrays.sort(strs, <span class="hljs-keyword">new</span> MyComparator());
   String res = <span class="hljs-string">&quot;&quot;</span>;
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; strs.length; i++) &#123;
      res += strs[i];
   &#125;
   <span class="hljs-keyword">return</span> res;
&#125;</code></pre></div>



<h2 id="贪心算法求解的标准过程"><a href="#贪心算法求解的标准过程" class="headerlink" title="贪心算法求解的标准过程"></a>贪心算法求解的标准过程</h2><p>1，分析业务</p>
<p>2，根据业务逻辑找到 <strong>不同的贪心策略</strong></p>
<p>3，对于能 <strong>举出反例</strong> 的策略直接跳过，不能举出反例的策略要证明有效性</p>
<p>这往往是特别困难的，要求数学能力很高且不具有统一的技巧性</p>
<h2 id="贪心算法的解题套路"><a href="#贪心算法的解题套路" class="headerlink" title="贪心算法的解题套路"></a>贪心算法的解题套路</h2><p>1，实现一个不依靠贪心策略的解法X，可以用最暴力的尝试</p>
<p>2，脑补出贪心策略A、贪心策略B、贪心策略C…</p>
<p>3，用解法X和对数器，用实验的方式得知哪个贪心策略正确 </p>
<p>4， **不要去纠结贪心策略的证明 **</p>
<h2 id="贪心算法的解题套路实战"><a href="#贪心算法的解题套路实战" class="headerlink" title="贪心算法的解题套路实战"></a>贪心算法的解题套路实战</h2><h3 id="会议室题"><a href="#会议室题" class="headerlink" title="会议室题"></a>会议室题</h3><p>一些项目要占用一个会议室宣讲，会议室不能同时容纳两个项目的宣讲。<br>给你每一个项目 <strong>开始的时间和结束的时间</strong><br>你来安排宣讲的日程，要求会议室进行的宣讲的场次最多。<br>返回最多的宣讲场次。 </p>
<p> <strong>按会议结束时间早来贪，安排一个，把不能安排的打X，安排其他的</strong></p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">bestArrange2</span><span class="hljs-params">(Program[] programs)</span> </span>&#123;
   Arrays.sort(programs, <span class="hljs-keyword">new</span> ProgramComparator());
   <span class="hljs-keyword">int</span> timeLine = <span class="hljs-number">0</span>;
   <span class="hljs-keyword">int</span> result = <span class="hljs-number">0</span>;
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; programs.length; i++) &#123;
      <span class="hljs-keyword">if</span> (timeLine &lt;= programs[i].start) &#123;
         result++;
         timeLine = programs[i].end;
      &#125;
   &#125;
   <span class="hljs-keyword">return</span> result;
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProgramComparator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparator</span>&lt;<span class="hljs-title">Program</span>&gt; </span>&#123;

   <span class="hljs-meta">@Override</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Program o1, Program o2)</span> </span>&#123;
      <span class="hljs-keyword">return</span> o1.end - o2.end;
   &#125;

&#125;</code></pre></div>



<h3 id="点灯问题"><a href="#点灯问题" class="headerlink" title="点灯问题"></a>点灯问题</h3><p>给定一个字符串str，只由‘X’和‘.’两种字符构成。<br> <strong>‘X’表示墙，不能放灯，也不需要点亮</strong><br> <strong>‘.’表示居民点，可以放灯，需要点亮</strong><br>如果灯放在i位置，可以让i-1，i和i+1三个位置被点亮<br>返回如果点亮str中所有需要点亮的位置，至少需要几盏灯</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201214143040.png" srcset="/img/loading.gif" alt="贪心"></p>
<ul>
<li>i位置为x，跳下一个</li>
<li>i位置为点<ul>
<li>如果i+1为x，必须放，跳i+2</li>
<li>如果i+1为点，i+2为x，放一个，跳i+3</li>
<li>如果i+1为点，i+2为点，i+1放一个，跳i+3</li>
</ul>
</li>
</ul>
<p>总是在当前步做 <strong>最优决定</strong>。</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minLight2</span><span class="hljs-params">(String road)</span> </span>&#123;
   <span class="hljs-keyword">char</span>[] str = road.toCharArray();
   <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;
   <span class="hljs-keyword">int</span> light = <span class="hljs-number">0</span>;
   <span class="hljs-keyword">while</span> (index &lt; str.length) &#123;
      <span class="hljs-keyword">if</span> (str[index] == <span class="hljs-string">&#x27;X&#x27;</span>) &#123;
         index++;
      &#125; <span class="hljs-keyword">else</span> &#123;
         light++;
         <span class="hljs-keyword">if</span> (index + <span class="hljs-number">1</span> == str.length) &#123;
            <span class="hljs-keyword">break</span>;
         &#125; <span class="hljs-keyword">else</span> &#123;
            <span class="hljs-keyword">if</span> (str[index + <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;X&#x27;</span>) &#123;
               index = index + <span class="hljs-number">2</span>;
            &#125; <span class="hljs-keyword">else</span> &#123;
               index = index + <span class="hljs-number">3</span>;
            &#125;
         &#125;
      &#125;
   &#125;
   <span class="hljs-keyword">return</span> light;
&#125;</code></pre></div>



<h3 id="金块分割问题"><a href="#金块分割问题" class="headerlink" title="金块分割问题"></a>金块分割问题</h3><p>一块金条切成两半，是需要花费和长度数值一样的铜板的。<br>比如长度为20的金条，不管怎么切，都要花费20个铜板。 一群人想整分整块金条，怎么分最省铜板? </p>
<p>例如,给定数组{10,20,30}，代表一共三个人，整块金条长度为60，金条要分成10，20，30三个部分。</p>
<p>如果先把长度60的金条分成10和50，花费60; 再把长度50的金条分成20和30，花费50;一共花费110铜板。<br>但如果先把长度60的金条分成30和30，花费60;再把长度30金条分成10和20， 花费30;一共花费90铜板。<br>输入一个数组，返回分割的最小代价。 </p>
<blockquote>
<p>哈夫曼树</p>
</blockquote>
<p>堆和排序是贪心最常用手段</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201214145441.png" srcset="/img/loading.gif" alt="堆 哈夫曼树"></p>
<p>合成哈夫曼树就是从小根堆里面取两个合并再加入小根堆再合并….</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lessMoney2</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;
   PriorityQueue&lt;Integer&gt; pQ = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;();
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;
      pQ.add(arr[i]);
   &#125;
   <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;
   <span class="hljs-keyword">int</span> cur = <span class="hljs-number">0</span>;
   <span class="hljs-keyword">while</span> (pQ.size() &gt; <span class="hljs-number">1</span>) &#123;
      cur = pQ.poll() + pQ.poll();
      sum += cur;
      pQ.add(cur);
   &#125;
   <span class="hljs-keyword">return</span> sum;
&#125;</code></pre></div>





<h3 id="项目利益问题"><a href="#项目利益问题" class="headerlink" title="项目利益问题"></a>项目利益问题</h3><p>输入: 正数数组costs、正数数组profits、正数K、正数M<br>costs[i]表示i号项目的 <strong>花费</strong><br>profits[i]表示i号项目在扣除花费之后还能 <strong>挣到的钱(利润)</strong><br>K表示你只能串行的最多做k个项目<br>M表示你初始的资金<br>说明: 每做完一个项目，马上获得的收益，可以支持你去做下一个项目。不能并行的做项目。<br>输出：你最后获得的最大钱数。 </p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201214150806.png" srcset="/img/loading.gif" alt="解法"></p>
<ul>
<li>设置一个小根堆，按照花费排序，称为此时 <strong>被锁住的项目</strong></li>
<li>设置一个大根堆，按照利润排序，称为此事 <strong>被解锁的项目</strong></li>
<li>从小根堆里 <strong>弹出所有能被初始资金满足</strong> 的项目到大根堆，因为按照利润组织，挑选大根堆堆顶做。初始资金变为4。拿初始资金继续寻找小根堆里能满足的放入大根堆，挑选大根堆堆顶，改变资金…. </li>
</ul>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findMaximizedCapital</span><span class="hljs-params">(<span class="hljs-keyword">int</span> K, <span class="hljs-keyword">int</span> W, <span class="hljs-keyword">int</span>[] Profits, <span class="hljs-keyword">int</span>[] Capital)</span> </span>&#123;
   PriorityQueue&lt;Program&gt; minCostQ = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;(<span class="hljs-keyword">new</span> MinCostComparator());
   PriorityQueue&lt;Program&gt; maxProfitQ = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;(<span class="hljs-keyword">new</span> MaxProfitComparator());
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; Profits.length; i++) &#123;
      minCostQ.add(<span class="hljs-keyword">new</span> Program(Profits[i], Capital[i]));
   &#125;
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; K; i++) &#123;
      <span class="hljs-keyword">while</span> (!minCostQ.isEmpty() &amp;&amp; minCostQ.peek().c &lt;= W) &#123;
         maxProfitQ.add(minCostQ.poll());
      &#125;
      <span class="hljs-keyword">if</span> (maxProfitQ.isEmpty()) &#123;
         <span class="hljs-keyword">return</span> W;
      &#125;
      W += maxProfitQ.poll().p;
   &#125;
   <span class="hljs-keyword">return</span> W;
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span> </span>&#123;
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> p;
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> c;

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Program</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> c)</span> </span>&#123;
      <span class="hljs-keyword">this</span>.p = p;
      <span class="hljs-keyword">this</span>.c = c;
   &#125;
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MinCostComparator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparator</span>&lt;<span class="hljs-title">Program</span>&gt; </span>&#123;

   <span class="hljs-meta">@Override</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Program o1, Program o2)</span> </span>&#123;
      <span class="hljs-keyword">return</span> o1.c - o2.c;
   &#125;

&#125;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MaxProfitComparator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparator</span>&lt;<span class="hljs-title">Program</span>&gt; </span>&#123;

   <span class="hljs-meta">@Override</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Program o1, Program o2)</span> </span>&#123;
      <span class="hljs-keyword">return</span> o2.p - o1.p;
   &#125;

&#125;</code></pre></div>



<p> <strong>暴力解贪心真的很折磨</strong> </p>
<h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><h2 id="并查集code"><a href="#并查集code" class="headerlink" title="并查集code"></a>并查集code</h2><ol>
<li>有若干个样本a、b、c、d…类型假设是V</li>
<li>在并查集中一开始认为每个样本都在 <strong>单独的集合</strong> 里用户可以在任何时候调用如下两个方法：<div class="hljs"><pre><code>    **boolean isSameSet(V x, V y)** : 查询样本x和样本y是否属于一个集合
    **void union(V x, V y)** : 把x和y各自所在集合的所有样本合并成一个集合</code></pre></div>
</li>
<li> isSameSet和union方法的代价越低越好, 最好O(1)</li>
</ol>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201214153822.png" srcset="/img/loading.gif" alt="代表点"></p>
<p>结果若干union后，代表点不一样，就不是一个集合</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201214153934.png" srcset="/img/loading.gif" alt="union后"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201214154334.png" srcset="/img/loading.gif" alt="union操作"></p>
<p> <strong>小数量挂大数量，数量相等无所谓</strong> </p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201214154455.png" srcset="/img/loading.gif" alt="union操作完毕"></p>
<p>1）每个节点都有一条往上指的指针<br>2）节点a往上找到的头节点，叫做a所在集合的代表节点<br>3）查询x和y是否属于同一个集合，就是看看找到的代表节点是不是一个<br>4）把x和y各自所在集合的所有点合并成一个集合，只需要小集合的代表点挂在大集合的代表点的下方即可</p>
<p>code:</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">V</span>&gt; </span>&#123;
   V value;

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(V v)</span> </span>&#123;
      value = v;
   &#125;
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnionSet</span>&lt;<span class="hljs-title">V</span>&gt; </span>&#123;
   <span class="hljs-comment">// V -&gt; 结点 一一对应，建好后不会改动，记录对应关系</span>
   <span class="hljs-keyword">public</span> HashMap&lt;V, Node&lt;V&gt;&gt; nodes;
   <span class="hljs-keyword">public</span> HashMap&lt;Node&lt;V&gt;, Node&lt;V&gt;&gt; parents;
   <span class="hljs-comment">// 代表点才会有记录</span>
   <span class="hljs-keyword">public</span> HashMap&lt;Node&lt;V&gt;, Integer&gt; sizeMap;

   <span class="hljs-comment">// 初始化过程</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UnionSet</span><span class="hljs-params">(List&lt;V&gt; values)</span> </span>&#123;
      <span class="hljs-keyword">for</span> (V value : values) &#123;
         Node&lt;V&gt; node = <span class="hljs-keyword">new</span> Node&lt;&gt;(value);
         nodes.put(value, node);
         <span class="hljs-comment">// 一开始每个点都为代表点 指向自己</span>
         parents.put(node, node);
         sizeMap.put(node, <span class="hljs-number">1</span>);
      &#125;
   &#125;

   <span class="hljs-comment">// 从cur开始找，找到不能再往上找的代表点并返回</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> Node&lt;V&gt; <span class="hljs-title">findFather</span><span class="hljs-params">(Node&lt;V&gt; cur)</span> </span>&#123;
      Stack&lt;Node&lt;V&gt;&gt; path = <span class="hljs-keyword">new</span> Stack&lt;&gt;();
      <span class="hljs-keyword">while</span> (cur != parents.get(cur)) &#123;
         path.push(cur);
         cur = parents.get(cur);
      &#125;
      <span class="hljs-comment">// cur头节点</span>
      <span class="hljs-keyword">while</span> (!path.isEmpty()) &#123;
         parents.put(path.pop(), cur);
      &#125;
      <span class="hljs-keyword">return</span> cur;
   &#125;

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSameSet</span><span class="hljs-params">(V a, V b)</span> </span>&#123;
      <span class="hljs-keyword">if</span> (!nodes.containsKey(a) || !nodes.containsKey(b)) &#123;
         <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
      &#125;
      <span class="hljs-keyword">return</span> findFather(nodes.get(a)) == findFather(nodes.get(b));
   &#125;

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">union</span><span class="hljs-params">(V a, V b)</span> </span>&#123;
      <span class="hljs-keyword">if</span> (!nodes.containsKey(a) || !nodes.containsKey(b)) &#123;
         <span class="hljs-keyword">return</span>;
      &#125;
      Node&lt;V&gt; aHead = findFather(nodes.get(a));
      Node&lt;V&gt; bHead = findFather(nodes.get(b));
      <span class="hljs-keyword">if</span> (aHead != bHead) &#123;
         <span class="hljs-keyword">int</span> aSetSize = sizeMap.get(aHead);
         <span class="hljs-keyword">int</span> bSetSize = sizeMap.get(bHead);
         <span class="hljs-keyword">if</span> (aSetSize &gt;= bSetSize) &#123;
            parents.put(bHead, aHead);
            sizeMap.put(aHead, aSetSize + bSetSize);
            sizeMap.remove(bHead);
         &#125; <span class="hljs-keyword">else</span> &#123;
            parents.put(aHead, bHead);
            sizeMap.put(bHead, aSetSize + bSetSize);
            sizeMap.remove(aHead);
         &#125;
      &#125;
   &#125;
&#125;</code></pre></div>



<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201214155250.png" srcset="/img/loading.gif" alt="parent表和size表"></p>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>1）节点往上找代表点的过程，把沿途的链变成扁平的</p>
<p>2）小集合挂在大集合的下面</p>
<p>3）如果方法调用很频繁，那么单次调用的代价为O(1)，两个方法都如此</p>
<p>findFather()方法的优化:</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201214160644.png" srcset="/img/loading.gif" alt="打扁平"></p>
<p>将原来串联起来，改变成father全指向代表点</p>
<p>往上找的过程是该算法的瓶颈，让找的方法变为O(1)即可。</p>
<p>解释了为什么 <strong>小挂大</strong> ，也减少了 <strong>遍历链的高度</strong> </p>
<h2 id="复杂度计算"><a href="#复杂度计算" class="headerlink" title="复杂度计算"></a>复杂度计算</h2><p>N个结点 -&gt; N个集合</p>
<p>find <strong>方法越频繁，代价越低</strong>。</p>
<p>当调用次数到达 O(n)或超过，单次调用的代价为O(1)。</p>
<h2 id="题"><a href="#题" class="headerlink" title="题"></a>题</h2><p>学生类有三个String属性，身份证，b站id，githubid，任何一个属性有一组一样就算一个人。</p>
<p>一大堆实例中有几个独立出来的人。</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201214162132.png" srcset="/img/loading.gif" alt="例子"></p>
<p>所有实例进并查集，准备三张表，记录三个字段拥有者</p>
<p>当表中key相同时，并查集合并这两个实例。</p>
<p>最后看sizeMap的数。</p>
<p> <strong>解决连通性的利器</strong> </p>
<h2 id="并查集的应用"><a href="#并查集的应用" class="headerlink" title="并查集的应用"></a>并查集的应用</h2><p>解决两大块区域的合并问题</p>
<p>常用在图等领域中</p>
<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><blockquote>
<p>不难在算法，难在结构</p>
</blockquote>
<p>1）由点的集合和边的集合构成</p>
<p>2）虽然存在有向图和无向图的概念，但实际上都可以用有向图来表达，无向图可以想象两条有向边</p>
<p>3）边上可能带有权值</p>
<h2 id="图结构的表达"><a href="#图结构的表达" class="headerlink" title="图结构的表达"></a>图结构的表达</h2><p>1）邻接表法</p>
<p>2）邻接矩阵法</p>
<p>3）除此之外还有其他众多的方式</p>
<p>邻接表法：记录能直接到达的点</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201215085231.png" srcset="/img/loading.gif" alt="邻接表法"></p>
<p>邻接矩阵法：abcd列行填格子</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201215085523.png" srcset="/img/loading.gif" alt="邻接矩阵"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201215085839.png" srcset="/img/loading.gif" alt="另外的表达"></p>
<h2 id="图的面试题如何搞定"><a href="#图的面试题如何搞定" class="headerlink" title="图的面试题如何搞定"></a>图的面试题如何搞定</h2><p>图的算法都不算难，只不过coding的代价比较高</p>
<p>1）先用 <strong>自己最熟练的方式</strong> ，实现图结构的表达</p>
<p>2）在自己熟悉的结构上， <strong>实现所有常用的图算法作为模板</strong></p>
<p>3）把面试题 <strong>提供的图结构转化为自己熟悉的图结构</strong> ，再调用模板或改写即可</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// 点结构描述</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;
   <span class="hljs-comment">// 编号</span>
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> value;
   <span class="hljs-comment">// 入度 多少个点直接连向</span>
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> in;
   <span class="hljs-comment">// 出度 多少个点直接出向</span>
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> out;
   <span class="hljs-comment">// 直接邻居</span>
   <span class="hljs-keyword">public</span> ArrayList&lt;Node&gt; nexts;
   <span class="hljs-comment">// 边</span>
   <span class="hljs-keyword">public</span> ArrayList&lt;Edge&gt; edges;

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;
      <span class="hljs-keyword">this</span>.value = value;
      in = <span class="hljs-number">0</span>;
      out = <span class="hljs-number">0</span>;
      nexts = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
      edges = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
   &#125;
&#125;</code></pre></div>

<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// 边描述 无向图只是from to相同</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Edge</span> </span>&#123;
   <span class="hljs-comment">// 权重</span>
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> weight;
   <span class="hljs-keyword">public</span> Node from;
   <span class="hljs-keyword">public</span> Node to;

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Edge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> weight, Node from, Node to)</span> </span>&#123;
      <span class="hljs-keyword">this</span>.weight = weight;
      <span class="hljs-keyword">this</span>.from = from;
      <span class="hljs-keyword">this</span>.to = to;
   &#125;

&#125;</code></pre></div>

<p>图结构就出来了：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Graph</span> </span>&#123;
   <span class="hljs-comment">// Integer表示Node里面的value编号</span>
   <span class="hljs-keyword">public</span> HashMap&lt;Integer, Node&gt; nodes;
   <span class="hljs-keyword">public</span> HashSet&lt;Edge&gt; edges;

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Graph</span><span class="hljs-params">()</span> </span>&#123;
      nodes = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
      edges = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();
   &#125;
&#125;</code></pre></div>



<blockquote>
<p>结构转化为上述第三图中矩阵N*3的图结构</p>
</blockquote>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// matrix 所有的边</span>
<span class="hljs-comment">// N*3 的矩阵</span>
<span class="hljs-comment">// [weight, from节点上面的值，to节点上面的值]</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Graph <span class="hljs-title">createGraph</span><span class="hljs-params">(Integer[][] matrix)</span> </span>&#123;
   Graph graph = <span class="hljs-keyword">new</span> Graph();
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; matrix.length; i++) &#123; <span class="hljs-comment">// matrix[0][0], matrix[0][1]  matrix[0][2]</span>
      Integer from = matrix[i][<span class="hljs-number">0</span>];
      Integer to = matrix[i][<span class="hljs-number">1</span>];
      Integer weight = matrix[i][<span class="hljs-number">2</span>];
      <span class="hljs-keyword">if</span> (!graph.nodes.containsKey(from)) &#123;
         graph.nodes.put(from, <span class="hljs-keyword">new</span> Node(from));
      &#125;
      <span class="hljs-keyword">if</span> (!graph.nodes.containsKey(to)) &#123;
         graph.nodes.put(to, <span class="hljs-keyword">new</span> Node(to));
      &#125;
      Node fromNode = graph.nodes.get(from);
      Node toNode = graph.nodes.get(to);
      Edge newEdge = <span class="hljs-keyword">new</span> Edge(weight, fromNode, toNode);
      fromNode.nexts.add(toNode);
      fromNode.out++;
      toNode.in++;
      fromNode.edges.add(newEdge);
      graph.edges.add(newEdge);
   &#125;
   <span class="hljs-keyword">return</span> graph;
&#125;</code></pre></div>



<h2 id="图的宽度优先-amp-深度优先遍历"><a href="#图的宽度优先-amp-深度优先遍历" class="headerlink" title="图的宽度优先&amp;深度优先遍历"></a>图的宽度优先&amp;深度优先遍历</h2><p>宽度优先遍历 (同一层内部的顺序可以无所谓)<br>1，利用 <strong>队列</strong> 实现<br>2，从源节点开始依次按照宽度进队列，然后弹出<br>3，每弹出一个点，把该节点 <strong>所有没有进过队列的邻接点放入队列</strong><br>4，直到队列变空</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// 从node出发，进行宽度优先遍历</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(Node node)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (node == <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">return</span>;
   &#125;
   Queue&lt;Node&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();
   <span class="hljs-comment">// 图会有环的问题，二叉树没有</span>
   HashSet&lt;Node&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();
   queue.add(node);
   set.add(node);
   <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;
      Node cur = queue.poll();
      <span class="hljs-comment">// 出打印</span>
      System.out.println(cur.value);
      <span class="hljs-keyword">for</span> (Node next : cur.nexts) &#123;
         <span class="hljs-keyword">if</span> (!set.contains(next)) &#123;
            set.add(next);
            queue.add(next);
         &#125;
      &#125;
   &#125;
&#125;</code></pre></div>



<p>深度优先遍历<br>1，利用 <strong>栈</strong> 实现<br>2，从源节点开始把节点按照深度放入栈，然后弹出<br>3，每弹出一个点，把该节点 <strong>下一个没有进过栈的邻接点放入栈</strong><br>4，直到栈变空 </p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(Node node)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (node == <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">return</span>;
   &#125;
   <span class="hljs-comment">// 记录从头结点走到的路径</span>
   Stack&lt;Node&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();
   HashSet&lt;Node&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();
   stack.add(node);
   set.add(node);
   System.out.println(node.value);
   <span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;
      Node cur = stack.pop();
      <span class="hljs-keyword">for</span> (Node next : cur.nexts) &#123;
         <span class="hljs-keyword">if</span> (!set.contains(next)) &#123;
            <span class="hljs-comment">// 一条路走到不能再走直接返回</span>
            stack.push(cur);
            stack.push(next);
            set.add(next);
            <span class="hljs-comment">// 进去的时候打印</span>
            System.out.println(next.value);
            <span class="hljs-keyword">break</span>;
         &#125;
      &#125;
   &#125;
&#125;</code></pre></div>



<h2 id="图的拓扑排序算法-有向无环图"><a href="#图的拓扑排序算法-有向无环图" class="headerlink" title="图的拓扑排序算法(有向无环图)"></a>图的拓扑排序算法(有向无环图)</h2><p>1）在图中找到 <strong>所有入度为0</strong> 的点输出<br>2）把所有入度为0的点在图中 <strong>删掉</strong> ，继续找入度为0的点输出，周而复始<br>3）图的所有点都被删除后，依次输出的顺序就是拓扑排序</p>
<p>要求： <strong>有向图且其中没有环</strong><br>应用： <strong>事件安排</strong> 、 <strong>编译顺序</strong></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201215103658.png" srcset="/img/loading.gif" alt="拓扑"></p>
<p>a、b、c、e、f、t</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201215104648.png" srcset="/img/loading.gif" alt="循环依赖与图关系"></p>
<p>ABC各有各自的config，最终会变成有向无环图，如果有环，就形成了循环依赖。</p>
<p>拓扑排序从最底层包往上编译，最终编译出来。</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// directed graph and no loop</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Node&gt; <span class="hljs-title">sortedTopology</span><span class="hljs-params">(Graph graph)</span> </span>&#123;
   <span class="hljs-comment">// key：某一个node</span>
   <span class="hljs-comment">// value：剩余的入度</span>
   HashMap&lt;Node, Integer&gt; inMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
   <span class="hljs-comment">// 入度为0的点，才能进这个队列</span>
   Queue&lt;Node&gt; zeroInQueue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();
   <span class="hljs-keyword">for</span> (Node node : graph.nodes.values()) &#123;
      inMap.put(node, node.in);
      <span class="hljs-comment">// 有向无环图，一定会有入度为0的点</span>
      <span class="hljs-keyword">if</span> (node.in == <span class="hljs-number">0</span>) &#123;
         zeroInQueue.add(node);
      &#125;
   &#125;
   <span class="hljs-comment">// 拓扑排序的结果，依次加入result</span>
   List&lt;Node&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
   <span class="hljs-keyword">while</span> (!zeroInQueue.isEmpty()) &#123;
      Node cur = zeroInQueue.poll();
      result.add(cur);
      <span class="hljs-keyword">for</span> (Node next : cur.nexts) &#123;
         inMap.put(next, inMap.get(next) - <span class="hljs-number">1</span>);
         <span class="hljs-keyword">if</span> (inMap.get(next) == <span class="hljs-number">0</span>) &#123;
            zeroInQueue.add(next);
         &#125;
      &#125;
   &#125;
   <span class="hljs-keyword">return</span> result;
&#125;</code></pre></div>



<h2 id="最小生成树算法之Kruskal"><a href="#最小生成树算法之Kruskal" class="headerlink" title="最小生成树算法之Kruskal"></a>最小生成树算法之Kruskal</h2><p>1）总是从 <strong>权值最小的边</strong> 开始考虑，依次考察权值依次变大的边<br>2）当前的边要么进入最小生成树的集合，要么丢弃<br>3）如果当前的边进入最小生成树的集合中不会形成环，就要当前边<br>4）如果当前的边进入最小生成树的集合中会形成环，就不要当前边<br>5）考察完所有边之后，最小生成树的集合也得到了</p>
<p>最小权值连通所有的点</p>
<p>流程：</p>
<p>所有的 <strong>边</strong> 根据 <strong>权值由小到大排序</strong> ，对边遍历，如果左右两头没有在同一个集合，union，如果在一个集合，淘汰。</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201215110718.png" srcset="/img/loading.gif" alt="流程"></p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Set&lt;Edge&gt; <span class="hljs-title">kruskalMST</span><span class="hljs-params">(Graph graph)</span> </span>&#123;
   UnionFind unionFind = <span class="hljs-keyword">new</span> UnionFind();
   unionFind.makeSets(graph.nodes.values());
   PriorityQueue&lt;Edge&gt; priorityQueue = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;(<span class="hljs-keyword">new</span> EdgeComparator());
   <span class="hljs-keyword">for</span> (Edge edge : graph.edges) &#123; <span class="hljs-comment">// M 条边</span>
      priorityQueue.add(edge);  <span class="hljs-comment">// O(logM)</span>
   &#125;
   Set&lt;Edge&gt; result = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();
   <span class="hljs-keyword">while</span> (!priorityQueue.isEmpty()) &#123; <span class="hljs-comment">// M 条边</span>
      Edge edge = priorityQueue.poll(); <span class="hljs-comment">// O(logM)</span>
      <span class="hljs-keyword">if</span> (!unionFind.isSameSet(edge.from, edge.to)) &#123; <span class="hljs-comment">// O(1)</span>
         result.add(edge);
         unionFind.union(edge.from, edge.to);
      &#125;
   &#125;
   <span class="hljs-keyword">return</span> result;
&#125;</code></pre></div>

<p>有向图有效，如果是 <strong>无向图，会少一半边</strong> ：</p>
<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201215111956.png" srcset="/img/loading.gif" alt="少一半边" style="zoom:50%;" />

<p>每次只会union一次，下次不会再union</p>
<h2 id="最小生成树算法之Prim"><a href="#最小生成树算法之Prim" class="headerlink" title="最小生成树算法之Prim"></a>最小生成树算法之Prim</h2><p>1）可以从 <strong>任意节点</strong> 出发来寻找最小生成树<br>2）某个点加入到被选取的点中后，解锁这个点出发的所有新的边<br>3）在所有解锁的边中选最小的边，然后看看这个边会不会形成环<br>4）如果会，不要当前边，继续考察剩下解锁的边中最小的边，重复3）<br>5）如果不会，要当前边，将该边的指向点加入到被选取的点中，重复2）<br>6）当所有点都被选取，最小生成树就得到了</p>
<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201215113103.png" srcset="/img/loading.gif" alt="例子" style="zoom:33%;" />

<p>a点被解锁，直接边被解锁，在可以被看到的边里选一个最小的边，看看边两侧有没有新结点，解锁，没有新结点抛弃。c被解锁，已经选过的边不被重复解锁，b被解锁，边被解锁，找到所有解锁的边最小继续解锁…一直到所有点被解锁</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201215113614.png" srcset="/img/loading.gif" alt="结果"></p>
<p>总是一个一个点进，而不是一大片结合，所以一个set即可。</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Set&lt;Edge&gt; <span class="hljs-title">primMST</span><span class="hljs-params">(Graph graph)</span> </span>&#123;
   <span class="hljs-comment">// 解锁的边进入小根堆</span>
   PriorityQueue&lt;Edge&gt; priorityQueue = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;(
         <span class="hljs-keyword">new</span> EdgeComparator());

   HashSet&lt;Node&gt; nodeSet = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();
   <span class="hljs-comment">// 防止边重复</span>
   HashSet&lt;Edge&gt; edgeSet = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();

   Set&lt;Edge&gt; result = <span class="hljs-keyword">new</span> HashSet&lt;&gt;(); <span class="hljs-comment">// 依次挑选的的边在result里</span>
   <span class="hljs-keyword">for</span> (Node node : graph.nodes.values()) &#123; <span class="hljs-comment">// 随便挑了一个点</span>
   <span class="hljs-comment">// for循环防森林</span>


      <span class="hljs-comment">// node 是开始点</span>
      <span class="hljs-keyword">if</span> (!set.contains(node)) &#123;
         set.add(node);
         <span class="hljs-keyword">for</span> (Edge edge : node.edges) &#123; <span class="hljs-comment">// 由一个点，解锁所有相连的边</span>
            <span class="hljs-keyword">if</span> (!edgeSet.contains(edge))&#123;
               edgeSet.add(edge);
               priorityQueue.add(edge);
            &#125;
         &#125;
         <span class="hljs-keyword">while</span> (!priorityQueue.isEmpty()) &#123;
            Edge edge = priorityQueue.poll(); <span class="hljs-comment">// 弹出解锁的边中，最小的边</span>
            Node toNode = edge.to; <span class="hljs-comment">// 可能的一个新的点</span>
            <span class="hljs-keyword">if</span> (!set.contains(toNode)) &#123; <span class="hljs-comment">// 不含有的时候，就是新的点</span>
               set.add(toNode);
               result.add(edge);
               <span class="hljs-keyword">for</span> (Edge nextEdge : toNode.edges) &#123;
                  <span class="hljs-keyword">if</span> (!edgeSet.contains(nextEdge))&#123;
                     edgeSet.add(nextEdge);
                     priorityQueue.add(nextEdge);
                  &#125;
               &#125;
            &#125;
         &#125;
      &#125;


      <span class="hljs-comment">//break;</span>
   &#125;
   <span class="hljs-keyword">return</span> result;
&#125;</code></pre></div>



<h2 id="Dijkstra算法-是一种贪心"><a href="#Dijkstra算法-是一种贪心" class="headerlink" title="Dijkstra算法(是一种贪心)"></a>Dijkstra算法(是一种贪心)</h2><p>1）Dijkstra算法必须指定一个源点<br>2）生成一个源点到各个点的最小距离表，一开始只有一条记录，即原点到自己的最小距离为0，源点到其他所有点的最小距离都为正无穷大</p>
<p>​ <img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201216085732.png" srcset="/img/loading.gif" alt="初始表" style="zoom:50%;" /></p>
<p>3）从距离表中拿出没拿过记录里的最小记录，通过这个点发出的边，更新源点到各个点的最小距离表，不断重复这一步</p>
<p>​ <img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201216085957.png" srcset="/img/loading.gif" alt="更新一次" style="zoom:50%;" /></p>
<p>​ 选B再更新…. 注： <strong>使用完的记录，要锁住</strong></p>
<p>4）源点到所有的点记录如果都被拿过一遍，过程停止，最小距离表得到了</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201216085032.png" srcset="/img/loading.gif" alt="最小距离表"></p>
<p> <strong>权值为正数，如果出现负数，环问题可能没有解</strong></p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> HashMap&lt;Node, Integer&gt; <span class="hljs-title">dijkstra1</span><span class="hljs-params">(Node from)</span> </span>&#123;
   <span class="hljs-comment">// 从from出发到所有点的最小距离</span>
   <span class="hljs-comment">// key : 从head出发到达key</span>
   <span class="hljs-comment">// value : 从head出发到达key的最小距离</span>
   <span class="hljs-comment">// 如果在表中，没有T的记录，含义是从head出发到T这个点的距离为正无穷</span>
   HashMap&lt;Node, Integer&gt; distanceMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
   distanceMap.put(from, <span class="hljs-number">0</span>);

   <span class="hljs-comment">// 已经求过距离的节点，存在selectedNodes中，以后再也不碰</span>
   HashSet&lt;Node&gt; selectedNodes = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();

   <span class="hljs-comment">// 选择最小距离且没有被锁住的点</span>
   Node minNode = getMinDistanceAndUnselectedNode(distanceMap, selectedNodes);
   <span class="hljs-keyword">while</span> (minNode != <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">int</span> distance = distanceMap.get(minNode);
      <span class="hljs-keyword">for</span> (Edge edge : minNode.edges) &#123;
         Node toNode = edge.to;
         <span class="hljs-keyword">if</span> (!distanceMap.containsKey(toNode)) &#123;
            distanceMap.put(toNode, distance + edge.weight);
         &#125; <span class="hljs-keyword">else</span> &#123;
            distanceMap.put(edge.to, Math.min(distanceMap.get(toNode), distance + edge.weight));
         &#125;
      &#125;
      selectedNodes.add(minNode);
      minNode = getMinDistanceAndUnselectedNode(distanceMap, selectedNodes);
   &#125;
   <span class="hljs-keyword">return</span> distanceMap;
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">getMinDistanceAndUnselectedNode</span><span class="hljs-params">(HashMap&lt;Node, Integer&gt; distanceMap, HashSet&lt;Node&gt; touchedNodes)</span> </span>&#123;
   <span class="hljs-comment">// touchedNodes为selectedNodes</span>
   <span class="hljs-comment">// 找到最小且未被锁住的点</span>
   Node minNode = <span class="hljs-keyword">null</span>;
   <span class="hljs-keyword">int</span> minDistance = Integer.MAX_VALUE;
   <span class="hljs-keyword">for</span> (Entry&lt;Node, Integer&gt; entry : distanceMap.entrySet()) &#123;
      Node node = entry.getKey();
      <span class="hljs-keyword">int</span> distance = entry.getValue();
      <span class="hljs-keyword">if</span> (!touchedNodes.contains(node) &amp;&amp; distance &lt; minDistance) &#123;
         minNode = node;
         minDistance = distance;
      &#125;
   &#125;
   <span class="hljs-keyword">return</span> minNode;
&#125;</code></pre></div>



<h3 id="小根堆优化"><a href="#小根堆优化" class="headerlink" title="小根堆优化"></a>小根堆优化</h3><p>上述的算法中，for (Entry&lt;Node, Integer&gt; entry : distanceMap.entrySet())这段代码需要对当前取出的结点的下面所有点进行 <strong>遍历</strong>，可以使用一个小根堆，每次取出的就是最小。</p>
<p>原来是遍历哈希表 O(N) 现在是小根堆 O(logN)</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NodeRecord</span> </span>&#123;
   <span class="hljs-keyword">public</span> Node node;
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> distance;

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NodeRecord</span><span class="hljs-params">(Node node, <span class="hljs-keyword">int</span> distance)</span> </span>&#123;
      <span class="hljs-keyword">this</span>.node = node;
      <span class="hljs-keyword">this</span>.distance = distance;
   &#125;
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NodeHeap</span> </span>&#123;
   <span class="hljs-keyword">private</span> Node[] nodes; <span class="hljs-comment">// 实际的堆结构</span>
   <span class="hljs-comment">// key 某一个node， value 上面数组中的位置  -1表示曾经进来过</span>
   <span class="hljs-keyword">private</span> HashMap&lt;Node, Integer&gt; heapIndexMap;
   <span class="hljs-comment">// key 某一个节点， value 从源节点出发到该节点的目前最小距离</span>
   <span class="hljs-keyword">private</span> HashMap&lt;Node, Integer&gt; distanceMap;
   <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size; <span class="hljs-comment">// 堆上有多少个点</span>

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NodeHeap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> size)</span> </span>&#123;
      nodes = <span class="hljs-keyword">new</span> Node[size];
      heapIndexMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
      distanceMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
      size = <span class="hljs-number">0</span>;
   &#125;

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;
      <span class="hljs-keyword">return</span> size == <span class="hljs-number">0</span>;
   &#125;

   <span class="hljs-comment">// 有一个点叫node，现在发现了一个从源节点出发到达node的距离为distance</span>
   <span class="hljs-comment">// 判断要不要更新，如果需要的话，就更新</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addOrUpdateOrIgnore</span><span class="hljs-params">(Node node, <span class="hljs-keyword">int</span> distance)</span> </span>&#123;
      <span class="hljs-keyword">if</span> (inHeap(node)) &#123;
         distanceMap.put(node, Math.min(distanceMap.get(node), distance));
         insertHeapify(node, heapIndexMap.get(node));
      &#125;
      <span class="hljs-keyword">if</span> (!isEntered(node)) &#123;
         nodes[size] = node;
         heapIndexMap.put(node, size);
         distanceMap.put(node, distance);
         insertHeapify(node, size++);
      &#125;
   &#125;

   <span class="hljs-function"><span class="hljs-keyword">public</span> NodeRecord <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;
      NodeRecord nodeRecord = <span class="hljs-keyword">new</span> NodeRecord(nodes[<span class="hljs-number">0</span>], distanceMap.get(nodes[<span class="hljs-number">0</span>]));
      swap(<span class="hljs-number">0</span>, size - <span class="hljs-number">1</span>);
      heapIndexMap.put(nodes[size - <span class="hljs-number">1</span>], -<span class="hljs-number">1</span>);
      distanceMap.remove(nodes[size - <span class="hljs-number">1</span>]);
      <span class="hljs-comment">// free C++同学还要把原本堆顶节点析构，对java同学不必</span>
      nodes[size - <span class="hljs-number">1</span>] = <span class="hljs-keyword">null</span>;
      heapify(<span class="hljs-number">0</span>, --size);
      <span class="hljs-keyword">return</span> nodeRecord;
   &#125;

   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertHeapify</span><span class="hljs-params">(Node node, <span class="hljs-keyword">int</span> index)</span> </span>&#123;
      <span class="hljs-keyword">while</span> (distanceMap.get(nodes[index]) &lt; distanceMap.get(nodes[(index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>])) &#123;
         swap(index, (index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>);
         index = (index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;
      &#125;
   &#125;

   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">heapify</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> size)</span> </span>&#123;
      <span class="hljs-keyword">int</span> left = index * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;
      <span class="hljs-keyword">while</span> (left &lt; size) &#123;
         <span class="hljs-keyword">int</span> smallest = left + <span class="hljs-number">1</span> &lt; size &amp;&amp; distanceMap.get(nodes[left + <span class="hljs-number">1</span>]) &lt; distanceMap.get(nodes[left])
               ? left + <span class="hljs-number">1</span>
               : left;
         smallest = distanceMap.get(nodes[smallest]) &lt; distanceMap.get(nodes[index]) ? smallest : index;
         <span class="hljs-keyword">if</span> (smallest == index) &#123;
            <span class="hljs-keyword">break</span>;
         &#125;
         swap(smallest, index);
         index = smallest;
         left = index * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;
      &#125;
   &#125;

   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEntered</span><span class="hljs-params">(Node node)</span> </span>&#123;
      <span class="hljs-keyword">return</span> heapIndexMap.containsKey(node);
   &#125;

   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">inHeap</span><span class="hljs-params">(Node node)</span> </span>&#123;
      <span class="hljs-keyword">return</span> isEntered(node) &amp;&amp; heapIndexMap.get(node) != -<span class="hljs-number">1</span>;
   &#125;

   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index1, <span class="hljs-keyword">int</span> index2)</span> </span>&#123;
      heapIndexMap.put(nodes[index1], index2);
      heapIndexMap.put(nodes[index2], index1);
      Node tmp = nodes[index1];
      nodes[index1] = nodes[index2];
      nodes[index2] = tmp;
   &#125;
&#125;

<span class="hljs-comment">// 改进后的dijkstra算法</span>
<span class="hljs-comment">// 从head出发，所有head能到达的节点，生成到达每个节点的最小路径记录并返回</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> HashMap&lt;Node, Integer&gt; <span class="hljs-title">dijkstra2</span><span class="hljs-params">(Node head, <span class="hljs-keyword">int</span> size)</span> </span>&#123;
   NodeHeap nodeHeap = <span class="hljs-keyword">new</span> NodeHeap(size);
   nodeHeap.addOrUpdateOrIgnore(head, <span class="hljs-number">0</span>);
   HashMap&lt;Node, Integer&gt; result = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
   <span class="hljs-keyword">while</span> (!nodeHeap.isEmpty()) &#123;
      NodeRecord record = nodeHeap.pop();
      Node cur = record.node;
      <span class="hljs-keyword">int</span> distance = record.distance;
      <span class="hljs-keyword">for</span> (Edge edge : cur.edges) &#123;
         nodeHeap.addOrUpdateOrIgnore(edge.to, edge.weight + distance);
      &#125;
      result.put(cur, distance);
   &#125;
   <span class="hljs-keyword">return</span> result;
&#125;</code></pre></div>



<h1 id="暴力递归"><a href="#暴力递归" class="headerlink" title="暴力递归"></a>暴力递归</h1><blockquote>
<p> 暴力递归就是尝试 </p>
</blockquote>
<p>1，把问题转化为规模缩小了的同类问题的子问题<br>2，有明确的不需要继续进行递归的条件(base case)<br>3，有当得到了子问题的结果之后的决策过程<br>4， <strong>不记录</strong>每一个子问题的解，记录就是 <strong>动态规划</strong> </p>
<h2 id="熟悉什么叫尝试？"><a href="#熟悉什么叫尝试？" class="headerlink" title="熟悉什么叫尝试？"></a>熟悉什么叫尝试？</h2><ul>
<li><p>打印n层汉诺塔从最左边移动到最右边的全部过程（2^n -1 步）</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201216104132.png" srcset="/img/loading.gif" alt="汉诺塔"></p>
</li>
</ul>
<p>​ 思路：1 - N-1个挪到中间，第N个挪到最右边，1 - N-1挪到最右边</p>
<blockquote>
<p>细化递归过程的代码:</p>
</blockquote>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hanoi1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;
   leftToRight(n);
&#125;

<span class="hljs-comment">// 把 1 - N层圆盘从左移动到右</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">leftToRight</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;
      System.out.println(<span class="hljs-string">&quot;Move 1 from left to right&quot;</span>);
      <span class="hljs-keyword">return</span>;
   &#125;
   leftToMid(n - <span class="hljs-number">1</span>);
   System.out.println(<span class="hljs-string">&quot;Move &quot;</span> + n + <span class="hljs-string">&quot; from left to right&quot;</span>);
   midToRight(n - <span class="hljs-number">1</span>);
&#125;

<span class="hljs-comment">// 腾出空间</span>
<span class="hljs-comment">// 移动最底</span>
<span class="hljs-comment">// 移动其他</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">leftToMid</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;
      System.out.println(<span class="hljs-string">&quot;Move 1 from left to mid&quot;</span>);
      <span class="hljs-keyword">return</span>;
   &#125;
   leftToRight(n - <span class="hljs-number">1</span>);
   System.out.println(<span class="hljs-string">&quot;Move &quot;</span> + n + <span class="hljs-string">&quot; from left to mid&quot;</span>);
   rightToMid(n - <span class="hljs-number">1</span>);
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rightToMid</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;
      System.out.println(<span class="hljs-string">&quot;Move 1 from right to mid&quot;</span>);
      <span class="hljs-keyword">return</span>;
   &#125;
   rightToLeft(n - <span class="hljs-number">1</span>);
   System.out.println(<span class="hljs-string">&quot;Move &quot;</span> + n + <span class="hljs-string">&quot; from right to mid&quot;</span>);
   leftToMid(n - <span class="hljs-number">1</span>);
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">midToRight</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;
      System.out.println(<span class="hljs-string">&quot;Move 1 from mid to right&quot;</span>);
      <span class="hljs-keyword">return</span>;
   &#125;
   midToLeft(n - <span class="hljs-number">1</span>);
   System.out.println(<span class="hljs-string">&quot;Move &quot;</span> + n + <span class="hljs-string">&quot; from mid to right&quot;</span>);
   leftToRight(n - <span class="hljs-number">1</span>);
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">midToLeft</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;
      System.out.println(<span class="hljs-string">&quot;Move 1 from mid to left&quot;</span>);
      <span class="hljs-keyword">return</span>;
   &#125;
   midToRight(n - <span class="hljs-number">1</span>);
   System.out.println(<span class="hljs-string">&quot;Move &quot;</span> + n + <span class="hljs-string">&quot; from mid to left&quot;</span>);
   rightToLeft(n - <span class="hljs-number">1</span>);
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rightToLeft</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;
      System.out.println(<span class="hljs-string">&quot;Move 1 from right to left&quot;</span>);
      <span class="hljs-keyword">return</span>;
   &#125;
   rightToMid(n - <span class="hljs-number">1</span>);
   System.out.println(<span class="hljs-string">&quot;Move &quot;</span> + n + <span class="hljs-string">&quot; from right to left&quot;</span>);
   midToLeft(n - <span class="hljs-number">1</span>);
&#125;</code></pre></div>

<p>为每个移动过程都描述过程。</p>
<blockquote>
<p>如果忽略左中右，直接from to other代替全部</p>
</blockquote>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hanoi2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">0</span>) &#123;
      func(n, <span class="hljs-string">&quot;left&quot;</span>, <span class="hljs-string">&quot;right&quot;</span>, <span class="hljs-string">&quot;mid&quot;</span>);
   &#125;
&#125;

<span class="hljs-comment">// 1~i 圆盘 目标是from -&gt; to， other是另外一个</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span> N, String from, String to, String other)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (N == <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// base</span>
      System.out.println(<span class="hljs-string">&quot;Move 1 from &quot;</span> + from + <span class="hljs-string">&quot; to &quot;</span> + to);
   &#125; <span class="hljs-keyword">else</span> &#123;
      func(N - <span class="hljs-number">1</span>, from, other, to);
      System.out.println(<span class="hljs-string">&quot;Move &quot;</span> + N + <span class="hljs-string">&quot; from &quot;</span> + from + <span class="hljs-string">&quot; to &quot;</span> + to);
      func(N - <span class="hljs-number">1</span>, other, to, from);
   &#125;
&#125;</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201216111446.png" srcset="/img/loading.gif" alt="过程"></p>
<div class="hljs"><pre><code class="hljs livecodeserver">打印过程：
Move <span class="hljs-number">1</span> <span class="hljs-built_in">from</span> left <span class="hljs-built_in">to</span> <span class="hljs-literal">right</span>
Move <span class="hljs-number">2</span> <span class="hljs-built_in">from</span> left <span class="hljs-built_in">to</span> <span class="hljs-keyword">mid</span>
Move <span class="hljs-number">1</span> <span class="hljs-built_in">from</span> <span class="hljs-literal">right</span> <span class="hljs-built_in">to</span> <span class="hljs-keyword">mid</span>
Move <span class="hljs-number">3</span> <span class="hljs-built_in">from</span> left <span class="hljs-built_in">to</span> <span class="hljs-literal">right</span>
Move <span class="hljs-number">1</span> <span class="hljs-built_in">from</span> <span class="hljs-keyword">mid</span> <span class="hljs-built_in">to</span> left
Move <span class="hljs-number">2</span> <span class="hljs-built_in">from</span> <span class="hljs-keyword">mid</span> <span class="hljs-built_in">to</span> <span class="hljs-literal">right</span>
Move <span class="hljs-number">1</span> <span class="hljs-built_in">from</span> left <span class="hljs-built_in">to</span> <span class="hljs-literal">right</span></code></pre></div>


<ul>
<li><p>打印一个字符串的全部子序列</p>
<p> <strong>子串</strong> 必须连续。子序列不需要连续，但相对次序不能乱。</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201217083355.png" srcset="/img/loading.gif" alt="子串"></p>
</li>
</ul>
<p>  <img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201217083652.png" srcset="/img/loading.gif" alt="子序列每个都可以选择要或不要"></p>
  <div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;String&gt; <span class="hljs-title">subs</span><span class="hljs-params">(String s)</span> </span>&#123;
   <span class="hljs-keyword">char</span>[] str = s.toCharArray();
   String path = <span class="hljs-string">&quot;&quot;</span>;
   List&lt;String&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
   process1(str, <span class="hljs-number">0</span>, ans, path);
   <span class="hljs-keyword">return</span> ans;
&#125;

<span class="hljs-comment">// str为原始字符串</span>
<span class="hljs-comment">// index此时来到的位置</span>
<span class="hljs-comment">// 如果index来到终止位置 路径所形成的答案放到ans中</span>
<span class="hljs-comment">// 之前做出的选择，就是path</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process1</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] str, <span class="hljs-keyword">int</span> index, List&lt;String&gt; ans, String path)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (index == str.length) &#123;
      ans.add(path);
      <span class="hljs-keyword">return</span>;
   &#125;
   String no = path;
   process1(str, index + <span class="hljs-number">1</span>, ans, no);
   String yes = path + String.valueOf(str[index]);
   process1(str, index + <span class="hljs-number">1</span>, ans, yes);
&#125;</code></pre></div>



<ul>
<li><p>打印一个字符串的全部子序列，要求不要出现重复字面值的子序列</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process2</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] str, <span class="hljs-keyword">int</span> index, HashSet&lt;String&gt; set, String path)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (index == str.length) &#123;
      set.add(path);
      <span class="hljs-keyword">return</span>;
   &#125;
   String no = path;
   process2(str, index + <span class="hljs-number">1</span>, set, no);
   String yes = path + String.valueOf(str[index]);
   process2(str, index + <span class="hljs-number">1</span>, set, yes);
&#125;</code></pre></div>



</li>
</ul>
<ul>
<li><p>打印一个字符串的全部排列</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201217085722.png" srcset="/img/loading.gif" alt="不用额外空间尝试"></p>
<p>只需要一个数组，让index所到位置后面所有字符都到该位置一次</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ArrayList&lt;String&gt; <span class="hljs-title">permutation</span><span class="hljs-params">(String str)</span> </span>&#123;
   ArrayList&lt;String&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
   <span class="hljs-keyword">if</span> (str == <span class="hljs-keyword">null</span> || str.length() == <span class="hljs-number">0</span>) &#123;
      <span class="hljs-keyword">return</span> res;
   &#125;
   <span class="hljs-keyword">char</span>[] chs = str.toCharArray();
   process(chs, <span class="hljs-number">0</span>, res);
   <span class="hljs-keyword">return</span> res;
&#125;

<span class="hljs-comment">// str[0..i-1]已经做好决定</span>
<span class="hljs-comment">// str[i...]后的都有机会来到i位置</span>
<span class="hljs-comment">// i来到终止位置，全部做好决定，已经排列好</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] str, <span class="hljs-keyword">int</span> i, ArrayList&lt;String&gt; res)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (i == str.length) &#123;
      res.add(String.valueOf(str));
   &#125;
  <span class="hljs-comment">// i没有到终止位置，i往后所有位置来到i位置</span>
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i; j &lt; str.length; j++) &#123;
      swap(str, i, j);
      process(str, i + <span class="hljs-number">1</span>, res);
     <span class="hljs-comment">// 恢复现场</span>
      swap(str, i, j);
   &#125;
&#125;</code></pre></div>



</li>
</ul>
<ul>
<li><p>打印一个字符串的全部排列，要求不要出现重复的排列</p>
<p>直接在上面代码改为set，是暴力递归 ➕ 过滤</p>
<p>但如果使用分支限界方法不一样，在执行过程前杀死支路。</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// 分支限界方法</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ArrayList&lt;String&gt; <span class="hljs-title">permutationNoRepeat</span><span class="hljs-params">(String str)</span> </span>&#123;
   ArrayList&lt;String&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
   <span class="hljs-keyword">if</span> (str == <span class="hljs-keyword">null</span> || str.length() == <span class="hljs-number">0</span>) &#123;
      <span class="hljs-keyword">return</span> res;
   &#125;
   <span class="hljs-keyword">char</span>[] chs = str.toCharArray();
   process2(chs, <span class="hljs-number">0</span>, res);
   <span class="hljs-keyword">return</span> res;
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process2</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] str, <span class="hljs-keyword">int</span> i, ArrayList&lt;String&gt; res)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (i == str.length) &#123;
      res.add(String.valueOf(str));
   &#125;
  
   <span class="hljs-comment">// x位置有没有使用过</span>
   <span class="hljs-keyword">boolean</span>[] visit = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[<span class="hljs-number">26</span>]; <span class="hljs-comment">// visit[0 1 .. 25]</span>
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i; j &lt; str.length; j++) &#123;
      <span class="hljs-keyword">if</span> (!visit[str[j] - <span class="hljs-string">&#x27;a&#x27;</span>]) &#123;
         visit[str[j] - <span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-keyword">true</span>;
         swap(str, i, j);
         process2(str, i + <span class="hljs-number">1</span>, res);
         swap(str, i, j);
      &#125;
   &#125;
&#125;</code></pre></div>

</li>
</ul>
<h2 id="仰望好的尝试？"><a href="#仰望好的尝试？" class="headerlink" title="仰望好的尝试？"></a>仰望好的尝试？</h2><p>给你一个栈，请你 <strong>逆序</strong> 这个栈，<br>不能申请额外的数据结构，<br>只能使用递归函数。 如何实现? </p>
<p>f函数功能: 把栈底元素抽离</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201216114416.png" srcset="/img/loading.gif" alt="流程"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201216114856.png" srcset="/img/loading.gif" alt="reverse流程"></p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reverse</span><span class="hljs-params">(Stack&lt;Integer&gt; stack)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (stack.isEmpty()) &#123;
      <span class="hljs-keyword">return</span>;
   &#125;
   <span class="hljs-keyword">int</span> i = f(stack);
   reverse(stack);
   stack.push(i);
&#125;

<span class="hljs-comment">// 功能： 莫名其妙把栈底元素搞没了 还返回了</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">(Stack&lt;Integer&gt; stack)</span> </span>&#123;
   <span class="hljs-keyword">int</span> result = stack.pop();
   <span class="hljs-keyword">if</span> (stack.isEmpty()) &#123;
      <span class="hljs-keyword">return</span> result;
   &#125; <span class="hljs-keyword">else</span> &#123;
      <span class="hljs-keyword">int</span> last = f(stack);
      stack.push(result);
      <span class="hljs-keyword">return</span> last;
   &#125;
&#125;</code></pre></div>




<h2 id="从左往右的尝试模型1"><a href="#从左往右的尝试模型1" class="headerlink" title="从左往右的尝试模型1"></a>从左往右的尝试模型1</h2><h2 id="从左往右的尝试模型2"><a href="#从左往右的尝试模型2" class="headerlink" title="从左往右的尝试模型2"></a>从左往右的尝试模型2</h2><h2 id="范围上尝试的模型"><a href="#范围上尝试的模型" class="headerlink" title="范围上尝试的模型"></a>范围上尝试的模型</h2><h2 id="人过河问题"><a href="#人过河问题" class="headerlink" title="人过河问题"></a>人过河问题</h2><p>假设河里有鳄鱼，吃人后非常虚弱，虚弱后同时也会被其他鳄鱼吃，考虑人是否应该过河。假设鱼都绝顶聪明。</p>
<p>当鱼 <strong>偶数</strong> 时，可以过河；</p>
<p>鱼为 <strong>奇数</strong> 时，不能过河；</p>
<h2 id="海盗分硬币问题思考"><a href="#海盗分硬币问题思考" class="headerlink" title="海盗分硬币问题思考"></a>海盗分硬币问题思考</h2><p>假设有 100 个硬币， ABCDE五人分并依次提议，当赞成数大于等于一半时，提议成功，否则会被杀死。</p>
<p>思考：</p>
<p>如果只有 <strong>E一个人</strong> ，一百个硬币全部归 E；</p>
<p>如果只有 <strong>DE</strong> 两个人，只要E投反对票，D就会被杀死，所以100硬币全部归E；</p>
<p>如果只有 <strong>CDE三个人</strong>， 只要C被投死，D也一定死，所以D为了存活只能投C，C获得100硬币；</p>
<p>如果只有 <strong>BCDE四个人</strong>， B知道D、E没有硬币，所以给D、E各一个，自己98个，就能拉到票；</p>
<p>当 <strong>ABCDE</strong> 时，A知道C没有，给c一个，知道D、E只有一个，只需要给一个人两个硬币就行，所以自己97个；</p>
<h2 id="欧拉信封问题"><a href="#欧拉信封问题" class="headerlink" title="欧拉信封问题"></a>欧拉信封问题</h2><p>一个村子有N个人，每个人能寄出一封信，也能收到一封信，但不能是自己，问有多少种方法寄收。</p>
<p>当只有 1 个人时，寄收方法为0；</p>
<p>当有 2 个人时，寄收方法为1；</p>
<p>当有 3 个人时，ABC，如果A寄给B，B只能寄给C，一种；A寄给C，C只能寄给B，一种；一共 2 种方法；</p>
<p>当有 5 个人时，ABCDE，假设是B寄给E，如果E寄给B，剩下三个人玩欧拉信封问题，就有f(3)；假设E不寄给B，EB就可以看为一个整体，一条出度，一条入度，变成四个人玩欧拉信封问题，就有f(4)；</p>
<p>B一共能寄给4种，所以 4 * ( f(3) + f(4) )</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201218104738.png" srcset="/img/loading.gif" alt="N = 5"></p>
<p>结果为 f(n) = (n - 1) * ( f(n - 2) + f(n - 1) )</p>
<h2 id="N皇后"><a href="#N皇后" class="headerlink" title="N皇后"></a>N皇后</h2><p>N皇后问题是指在 *<em>N</em>N的棋盘上** 要 <strong>摆N个</strong> 皇后，<br>要求任何两个皇后不同行、不同列， 也不在同一条斜线上<br>给定一个整数n，返回n皇后的摆法有多少种。n=1，返回1<br>n=2或3，2皇后和3皇后问题无论怎么摆都不行，返回0<br>n=8，返回92</p>
<p> <strong>每行放一个，不会存在行上攻击问题</strong> ，</p>
<p> <strong>判断下一行与其它行斜线是否合法</strong>： 如果点分别为(a, b) (c, d) 判断 <strong>|a-c| == |b-d|</strong> </p>
<p>Code1:</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">num1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">1</span>) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
   &#125;
   <span class="hljs-comment">// record[0] ?  record[1]  ?  record[2]</span>
   <span class="hljs-keyword">int</span>[] record = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n]; <span class="hljs-comment">// record[i] -&gt; i行的皇后，放在了第几列</span>
   <span class="hljs-keyword">return</span> process1(<span class="hljs-number">0</span>, record, n);
&#125;

<span class="hljs-comment">// 潜台词：record[0..i-1]的皇后，任何两个皇后一定都不共行、不共列，不共斜线</span>
<span class="hljs-comment">// 目前来到了第i行</span>
<span class="hljs-comment">// record[0..i-1]表示之前的行，放了的皇后位置，index可以描述行数，value为列树</span>
<span class="hljs-comment">// n代表整体一共有多少行</span>
<span class="hljs-comment">// 返回值是，摆完所有的皇后，合理的摆法有多少种</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">process1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span>[] record, <span class="hljs-keyword">int</span> n)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (i == n) &#123; <span class="hljs-comment">// 终止行，行数从0开始算</span>
      <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
   &#125;
   <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;
   <span class="hljs-comment">// j为列</span>
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123; <span class="hljs-comment">// 当前行在i行，尝试i行所有的列  -&gt; j</span>

      <span class="hljs-comment">// 判断当前i行的皇后，放在j列，会不会和之前(0..i-1)的皇后，不共行共列或者共斜线，</span>
      <span class="hljs-comment">// 如果是，认为有效</span>
      <span class="hljs-comment">// 如果不是，认为无效</span>
      <span class="hljs-keyword">if</span> (isValid(record, i, j)) &#123;
         <span class="hljs-comment">// record不用还原，数组可以直接覆盖</span>
         record[i] = j;
         res += process1(i + <span class="hljs-number">1</span>, record, n);
      &#125;
   &#125;
   <span class="hljs-keyword">return</span> res;
&#125;

<span class="hljs-comment">// record[0..i-1]你需要看，record[i...]不需要看</span>
<span class="hljs-comment">// 返回i行皇后，放在了j列，是否有效</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValid</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] record, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; i; k++) &#123; <span class="hljs-comment">// 之前的某个k行的皇后</span>
      <span class="hljs-comment">// (k, record[k])  现在的 (i, j)</span>
      <span class="hljs-keyword">if</span> (j == record[k] || Math.abs(record[k] - j) == Math.abs(i - k)) &#123;
         <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
      &#125;
   &#125;
   <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
&#125;</code></pre></div>



<blockquote>
<p>可以进行 <strong>常数项</strong> 优化</p>
</blockquote>
<p>初始变量:</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201218113922.png" srcset="/img/loading.gif" alt="初始变量"></p>
<p>如果放第一个：</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201218114358.png" srcset="/img/loading.gif" alt="放第一个到0位置"></p>
<p>如果放第一个到4位置：</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201218114723.png" srcset="/img/loading.gif" alt="放4位置"></p>
<p> <strong>把三个limit 或运算，就是下一行能够放的位置</strong> </p>
<p> 如果第一行放4位置，第二行放1位置，限制变成</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201218135309.png" srcset="/img/loading.gif" alt="放第二个到1位置"></p>
<p>左limit对比第一次，就是先在第一个位置放皇后，01010000后，左移一位，变成10100000</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201218135531.png" srcset="/img/loading.gif" alt="放第二个后的右限制"></p>
<p>右limit对比第一次，就是先在第一个位置放皇后，01000100后，右移一位，变成00100010；</p>
<p>下次皇后位置，就为三个limit或起来：</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201218135851.png" srcset="/img/loading.gif" alt="下次可放位置"></p>
<p>Code2:</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// 请不要超过32皇后问题</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">num2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">1</span> || n &gt; <span class="hljs-number">32</span>) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
   &#125;
   <span class="hljs-comment">// n皇后问题，limit后面有多少个1</span>
   <span class="hljs-comment">// 比如8皇后问题，1左移8位 8个0， 减1后 8个1</span>
   <span class="hljs-keyword">int</span> limit = n == <span class="hljs-number">32</span> ? -<span class="hljs-number">1</span> : (<span class="hljs-number">1</span> &lt;&lt; n) - <span class="hljs-number">1</span>;


   <span class="hljs-keyword">return</span> process2(limit, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
&#125;

<span class="hljs-comment">// limit划定问题规模 永远不变</span>

<span class="hljs-comment">// colLim 列的限制，1的位置不能放皇后，0的位置可以</span>
<span class="hljs-comment">// leftDiaLim 左斜线的限制，1的位置不能放皇后，0的位置可以</span>
<span class="hljs-comment">// rightDiaLim 右斜线的限制，1的位置不能放皇后，0的位置可以</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">process2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> limit, </span></span>
<span class="hljs-function"><span class="hljs-params">      <span class="hljs-keyword">int</span> colLim, </span></span>
<span class="hljs-function"><span class="hljs-params">      <span class="hljs-keyword">int</span> leftDiaLim,</span></span>
<span class="hljs-function"><span class="hljs-params">      <span class="hljs-keyword">int</span> rightDiaLim)</span> </span>&#123;

   <span class="hljs-keyword">if</span> (colLim == limit) &#123; <span class="hljs-comment">// base case</span>
      <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
   &#125;

   <span class="hljs-comment">// 所有候选皇后的位置，都在pos上</span>
   <span class="hljs-comment">// colLim | leftDiaLim | rightDiaLim -&gt; 总限制</span>
   <span class="hljs-comment">// ~(colLim | leftDiaLim | rightDiaLim)右边为1可摆，但前面都是1</span>
   <span class="hljs-comment">// limit &amp; 让左侧变为0，也可以让左移超边界的1限制变0，防止干扰</span>
   <span class="hljs-keyword">int</span> pos = limit &amp; (~(colLim | leftDiaLim | rightDiaLim));
   <span class="hljs-keyword">int</span> mostRightOne = <span class="hljs-number">0</span>;
   <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;
   <span class="hljs-comment">// pos为0 表示没有位置放了</span>
   <span class="hljs-keyword">while</span> (pos != <span class="hljs-number">0</span>) &#123;
      <span class="hljs-comment">// 找最右边的1</span>
      mostRightOne = pos &amp; (~pos + <span class="hljs-number">1</span>);
      pos = pos - mostRightOne;
      res += process2(limit, 
            colLim | mostRightOne,
            (leftDiaLim | mostRightOne) &lt;&lt; <span class="hljs-number">1</span>,
            (rightDiaLim | mostRightOne) &gt;&gt;&gt; <span class="hljs-number">1</span>);
   &#125;
   <span class="hljs-keyword">return</span> res;
&#125;</code></pre></div>

<p>![如何找到能放皇后的位置，且代表1] (<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201218140919.png" srcset="/img/loading.gif" alt="image-20201218140916545">)</p>
<h3 id="如果要输出怎么办？"><a href="#如果要输出怎么办？" class="headerlink" title="如果要输出怎么办？"></a>如果要输出怎么办？</h3><p>leetcode原题：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;List&lt;String&gt;&gt; solveNQueens(<span class="hljs-keyword">int</span> n) &#123;
        <span class="hljs-keyword">char</span>[][] chess = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[n][n];
        <span class="hljs-comment">//初始化数组</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)
                chess[i][j] = <span class="hljs-string">&#x27;.&#x27;</span>;
        List&lt;List&lt;String&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
        solve(res, chess, <span class="hljs-number">0</span>);
        <span class="hljs-keyword">return</span> res;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(List&lt;List&lt;String&gt;&gt; res, <span class="hljs-keyword">char</span>[][] chess, <span class="hljs-keyword">int</span> row)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (row == chess.length) &#123;
            System.out.println(chess.length);
            res.add(construct(chess));
            <span class="hljs-keyword">return</span>;
        &#125;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> col = <span class="hljs-number">0</span>; col &lt; chess.length; col++) &#123;
            <span class="hljs-keyword">if</span> (valid(chess, row, col)) &#123;
                chess[row][col] = <span class="hljs-string">&#x27;Q&#x27;</span>;
                solve(res, chess, row + <span class="hljs-number">1</span>);
                chess[row][col] = <span class="hljs-string">&#x27;.&#x27;</span>;
            &#125;
        &#125;
    &#125;

    <span class="hljs-comment">//row表示第几行，col表示第几列</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">valid</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] chess, <span class="hljs-keyword">int</span> row, <span class="hljs-keyword">int</span> col)</span> </span>&#123;
        <span class="hljs-comment">//判断当前列有没有皇后,因为他是一行一行往下走的，</span>
        <span class="hljs-comment">//我们只需要检查走过的行数即可，通俗一点就是判断当前</span>
        <span class="hljs-comment">//坐标位置的上面有没有皇后</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; row; i++) &#123;
            <span class="hljs-keyword">if</span> (chess[i][col] == <span class="hljs-string">&#x27;Q&#x27;</span>) &#123;
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
            &#125;
        &#125;
        <span class="hljs-comment">//判断当前坐标的右上角有没有皇后</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = row - <span class="hljs-number">1</span>, j = col + <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &lt; chess.length; i--, j++) &#123;
            <span class="hljs-keyword">if</span> (chess[i][j] == <span class="hljs-string">&#x27;Q&#x27;</span>) &#123;
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
            &#125;
        &#125;
        <span class="hljs-comment">//判断当前坐标的左上角有没有皇后</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = row - <span class="hljs-number">1</span>, j = col - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span>; i--, j--) &#123;
            <span class="hljs-keyword">if</span> (chess[i][j] == <span class="hljs-string">&#x27;Q&#x27;</span>) &#123;
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    &#125;

    <span class="hljs-comment">//把数组转为list</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List&lt;String&gt; <span class="hljs-title">construct</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] chess)</span> </span>&#123;
        List&lt;String&gt; path = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; chess.length; i++) &#123;
            path.add(<span class="hljs-keyword">new</span> String(chess[i]));
        &#125;
        <span class="hljs-keyword">return</span> path;
    &#125;
&#125;</code></pre></div>



<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201218151905.png" srcset="/img/loading.gif" alt="暴力递归存在的问题"></p>
<p>有很多重复过程</p>
<p>你可以用一个数组，记录数列前几项，类似于 <strong>缓存</strong> 。</p>
<h2 id="暴力到动态规划-题目一"><a href="#暴力到动态规划-题目一" class="headerlink" title="暴力到动态规划(题目一)"></a>暴力到动态规划(题目一)</h2><p>假设有排成一行的N个位置，记为1<del>N，N 一定大于或等于 2<br>开始时机器人在其中的M位置上(M 一定是 1</del>N 中的一个)<br>如果机器人来到1位置，那么下一步只能往右来到2位置；<br>如果机器人来到N位置，那么下一步只能往左来到 N-1 位置；<br>如果机器人来到中间位置，那么下一步可以往左走或者往右走；<br>规定机器人必须走 K 步，最终能来到P位置(P也是1~N中的一个)的方法有多少种<br>给定四个参数 N、M、K、P，返回方法数。</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201219132935.png" srcset="/img/loading.gif" alt="流程"></p>
<blockquote>
<p>暴力代码</p>
</blockquote>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">ways1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> N, <span class="hljs-keyword">int</span> M, <span class="hljs-keyword">int</span> K, <span class="hljs-keyword">int</span> P)</span> </span>&#123;
   <span class="hljs-comment">// 参数无效直接返回0</span>
   <span class="hljs-keyword">if</span> (N &lt; <span class="hljs-number">2</span> || K &lt; <span class="hljs-number">1</span> || M &lt; <span class="hljs-number">1</span> || M &gt; N || P &lt; <span class="hljs-number">1</span> || P &gt; N) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
   &#125;
   <span class="hljs-comment">// 总共N个位置，从M点出发，还剩K步，返回最终能达到P的方法数</span>
   <span class="hljs-keyword">return</span> walk(N, M, K, P);
&#125;

<span class="hljs-comment">// N : 位置为1 ~ N，固定参数</span>
<span class="hljs-comment">// cur : 当前在cur位置，可变参数</span>
<span class="hljs-comment">// rest : 还剩res步没有走，可变参数</span>
<span class="hljs-comment">// P : 最终目标位置是P，固定参数</span>
<span class="hljs-comment">// 该函数的含义：只能在1~N这些位置上移动，当前在cur位置，走完rest步之后，停在P位置的方法数作为返回值返回</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">walk</span><span class="hljs-params">(<span class="hljs-keyword">int</span> N, <span class="hljs-keyword">int</span> cur, <span class="hljs-keyword">int</span> rest, <span class="hljs-keyword">int</span> P)</span> </span>&#123;
   <span class="hljs-comment">// 如果没有剩余步数了，当前的cur位置就是最后的位置</span>
   <span class="hljs-comment">// 如果最后的位置停在P上，那么之前做的移动是有效的</span>
   <span class="hljs-comment">// 如果最后的位置没在P上，那么之前做的移动是无效的</span>
   <span class="hljs-keyword">if</span> (rest == <span class="hljs-number">0</span>) &#123;
      <span class="hljs-keyword">return</span> cur == P ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;
   &#125;
   <span class="hljs-comment">// 如果还有rest步要走，而当前的cur位置在1位置上，那么当前这步只能从1走向2</span>
   <span class="hljs-comment">// 后续的过程就是，来到2位置上，还剩rest-1步要走</span>
   <span class="hljs-keyword">if</span> (cur == <span class="hljs-number">1</span>) &#123;
      <span class="hljs-keyword">return</span> walk(N, <span class="hljs-number">2</span>, rest - <span class="hljs-number">1</span>, P);
   &#125;
   <span class="hljs-comment">// 如果还有rest步要走，而当前的cur位置在N位置上，那么当前这步只能从N走向N-1</span>
   <span class="hljs-comment">// 后续的过程就是，来到N-1位置上，还剩rest-1步要走</span>
   <span class="hljs-keyword">if</span> (cur == N) &#123;
      <span class="hljs-keyword">return</span> walk(N, N - <span class="hljs-number">1</span>, rest - <span class="hljs-number">1</span>, P);
   &#125;
   <span class="hljs-comment">// 如果还有rest步要走，而当前的cur位置在中间位置上，那么当前这步可以走向左，也可以走向右</span>
   <span class="hljs-comment">// 走向左之后，后续的过程就是，来到cur-1位置上，还剩rest-1步要走</span>
   <span class="hljs-comment">// 走向右之后，后续的过程就是，来到cur+1位置上，还剩rest-1步要走</span>
   <span class="hljs-comment">// 走向左、走向右是截然不同的方法，所以总方法数要都算上</span>
   <span class="hljs-keyword">return</span> walk(N, cur + <span class="hljs-number">1</span>, rest - <span class="hljs-number">1</span>, P) + walk(N, cur - <span class="hljs-number">1</span>, rest - <span class="hljs-number">1</span>, P);
&#125;</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201219150216.png" srcset="/img/loading.gif" alt="有重复过程"></p>
<blockquote>
<p>缓存式(记忆化搜索) 动态规划代码</p>
</blockquote>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">waysCache</span><span class="hljs-params">(<span class="hljs-keyword">int</span> N, <span class="hljs-keyword">int</span> M, <span class="hljs-keyword">int</span> K, <span class="hljs-keyword">int</span> P)</span> </span>&#123;

   <span class="hljs-keyword">if</span> (N &lt; <span class="hljs-number">2</span> || K &lt; <span class="hljs-number">1</span> || M &lt; <span class="hljs-number">1</span> || M &gt; N || P &lt; <span class="hljs-number">1</span> || P &gt; N) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
   &#125;
   <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[N + <span class="hljs-number">1</span>][K + <span class="hljs-number">1</span>];
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> row = <span class="hljs-number">0</span>; row &lt;= N; row++)&#123;
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> col = <span class="hljs-number">0</span>; col &lt;= N; col++)&#123;
         dp[row][col] = -<span class="hljs-number">1</span>;
      &#125;
   &#125;
   <span class="hljs-keyword">return</span> walkCache(N, M, K, P, dp);
&#125;


<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">walkCache</span><span class="hljs-params">(<span class="hljs-keyword">int</span> N, <span class="hljs-keyword">int</span> cur, <span class="hljs-keyword">int</span> rest, <span class="hljs-keyword">int</span> P, <span class="hljs-keyword">int</span>[][] dp)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (dp[cur][rest] != -<span class="hljs-number">1</span>)&#123;
      <span class="hljs-keyword">return</span> d[cur][rest];
   &#125;
   
   <span class="hljs-keyword">if</span> (rest == <span class="hljs-number">0</span>) &#123;
      dp[cur][rest] = cur == P ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;
      <span class="hljs-keyword">return</span> dp[cur][rest];
   &#125;
   <span class="hljs-keyword">if</span> (cur == <span class="hljs-number">1</span>) &#123;
      dp[cur][rest] = walkCache(N, <span class="hljs-number">2</span>, rest - <span class="hljs-number">1</span>, P, dp);
      <span class="hljs-keyword">return</span> dp[cur][rest];
   &#125;
   <span class="hljs-keyword">if</span> (cur == N) &#123;
      dp[cur][rest] = walkCache(N, N - <span class="hljs-number">1</span>, rest - <span class="hljs-number">1</span>, P, dp);
      <span class="hljs-keyword">return</span> dp[cur][rest]
   &#125;
   dp[cur][rest] =  walkCache(N, cur + <span class="hljs-number">1</span>, rest - <span class="hljs-number">1</span>, P, dp) + walkCache(N, cur - <span class="hljs-number">1</span>, rest - <span class="hljs-number">1</span>, P, dp);
   <span class="hljs-keyword">return</span> dp[cur][rest];
&#125;</code></pre></div>

<blockquote>
<p>依赖关系猜想</p>
</blockquote>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201219152445.png" srcset="/img/loading.gif" alt="依赖过程"></p>
<p>可见每个普通位置都依赖左上和左下，由下方暴力代码猜想而来：</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201219152543.png" srcset="/img/loading.gif" alt="暴力代码依赖性"></p>
<p>最后直接靠 <strong>依赖</strong> 就能得到结果：</p>
<p>![依赖]（<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201219152752.png" srcset="/img/loading.gif" alt="image-20201219152743937"></p>
<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><blockquote>
<p>暴力递归中有重复运算过程，才建议改为动态规划</p>
</blockquote>
<h2 id="什么暴力递归可以继续优化？"><a href="#什么暴力递归可以继续优化？" class="headerlink" title="什么暴力递归可以继续优化？"></a>什么暴力递归可以继续优化？</h2><p>有重复调用同一个子问题的解，这种递归可以优化<br>如果每一个子问题都是不同的解，无法优化也不用优化</p>
<h2 id="暴力递归和动态规划的关系"><a href="#暴力递归和动态规划的关系" class="headerlink" title="暴力递归和动态规划的关系"></a>暴力递归和动态规划的关系</h2><p>某一个暴力递归，有解的重复调用，就可以把这个暴力递归优化成动态规划</p>
<p>任何动态规划问题，都一定对应着某一个有解的重复调用的暴力递归</p>
<p>但不是所有的暴力递归，都一定对应着动态规划</p>
<h2 id="面试题和动态规划的关系"><a href="#面试题和动态规划的关系" class="headerlink" title="面试题和动态规划的关系"></a>面试题和动态规划的关系</h2><p>解决一个问题，可能有很多尝试方法</p>
<p>可能在很多尝试方法中，又有若干个尝试方法有动态规划的方式</p>
<p>一个问题   可能有   若干种动态规划的解法</p>
<h2 id="如何找到某个问题的动态规划方式？"><a href="#如何找到某个问题的动态规划方式？" class="headerlink" title="如何找到某个问题的动态规划方式？"></a>如何找到某个问题的动态规划方式？</h2><p>1）设计暴力递归：重要原则+4种常见尝试模型！重点！</p>
<p>2）分析有没有重复解：套路解决</p>
<p>3）用记忆化搜索 -&gt; 用严格表结构实现动态规划：套路解决</p>
<p>4）看看能否继续优化：套路解决</p>
<h2 id="面试中设计暴力递归过程的原则"><a href="#面试中设计暴力递归过程的原则" class="headerlink" title="面试中设计暴力递归过程的原则"></a>面试中设计暴力递归过程的原则</h2><p>1）每一个可变参数的类型，一定不要比int类型更加复杂</p>
<p>​   一个int可变参数，dp一维表；</p>
<p>​   两个int可变参数，dp二维表；</p>
<p>​   ……</p>
<p>2）原则1）可以违反，让类型突破到一维线性结构，那必须是单一可变参数（如贴纸拼接问题用到字符串）</p>
<p>3）如果发现原则1）被违反，但不违反原则2），只需要做到记忆化搜索即可（如贴纸拼接问题不写dp）</p>
<p>4）可变参数的个数，能少则少</p>
<h2 id="常见的4种尝试模型"><a href="#常见的4种尝试模型" class="headerlink" title="常见的4种尝试模型"></a>常见的4种尝试模型</h2><p>1）从左往右的尝试模型</p>
<p>2）范围上的尝试模型</p>
<p>3）多样本位置全对应的尝试模型</p>
<p>4）寻找业务限制的尝试模型</p>
<h2 id="暴力递归到动态规划的套路"><a href="#暴力递归到动态规划的套路" class="headerlink" title="暴力递归到动态规划的套路"></a>暴力递归到动态规划的套路</h2><p>1）你已经有了一个不违反原则的暴力递归，而且的确存在解的重复调用<br>2）找到哪些参数的变化会影响返回值，对每一个列出变化范围<br>3）参数间的所有的组合数量，意味着表大小<br>4）记忆化搜索的方法就是傻缓存，非常容易得到<br>5）规定好严格表的大小，分析位置的依赖顺序，然后从基础填写到最终解<br>6）对于有枚举行为的决策过程，进一步优化</p>
<h2 id="知道了面试中设计暴力递归过程的原则，然后呢？"><a href="#知道了面试中设计暴力递归过程的原则，然后呢？" class="headerlink" title="知道了面试中设计暴力递归过程的原则，然后呢？"></a>知道了面试中设计暴力递归过程的原则，然后呢？</h2><p>一定要逼自己找到不违反原则情况下的暴力尝试！</p>
<p>如果你找到的暴力尝试，不符合原则，马上舍弃！找新的！</p>
<p>如果某个题目突破了设计原则，一定极难极难，面试中出现概率低于5%！</p>
<h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201220141419.png" srcset="/img/loading.gif" alt="暴力代码"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201220141827.png" srcset="/img/loading.gif" alt="例子"></p>
<p>选1,2不选3和选3不选1,2最后都会再算一遍f(3, 17)</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201220142425.png" srcset="/img/loading.gif" alt="初始位置"></p>
<p>函数调用(0, bag) 即(0, restMax)</p>
<p>由暴力递归得 rest&lt;0,无效；index == w.len, 为0</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201220143712.png" srcset="/img/loading.gif" alt="更改过程"></p>
<p>code:</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">dpWay</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] w, <span class="hljs-keyword">int</span>[] v, <span class="hljs-keyword">int</span> bag)</span> </span>&#123;
   <span class="hljs-keyword">int</span> N = w.length;
   <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[N + <span class="hljs-number">1</span>][bag + <span class="hljs-number">1</span>];
   <span class="hljs-comment">// dp[N][...] = 0,本来初始化就为0</span>
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> index = N - <span class="hljs-number">1</span>; index &gt;= <span class="hljs-number">0</span>; index--) &#123;
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> rest = <span class="hljs-number">1</span>; rest &lt;= bag; rest++) &#123;
         dp[index][rest] = dp[index + <span class="hljs-number">1</span>][rest];
         <span class="hljs-keyword">if</span> (rest &gt;= w[index]) &#123;
            dp[index][rest] = Math.max(dp[index][rest], v[index] + dp[index + <span class="hljs-number">1</span>][rest - w[index]]);
         &#125;
      &#125;
   &#125;
   <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][bag];
&#125;</code></pre></div>



<h2 id="数字转化字符串问题"><a href="#数字转化字符串问题" class="headerlink" title="数字转化字符串问题"></a>数字转化字符串问题</h2><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201220145024.png" srcset="/img/loading.gif" alt="原code"></p>
<p>搭框架</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201220145312.png" srcset="/img/loading.gif" alt="框架"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201220145223.png" srcset="/img/loading.gif" alt="return"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201220145438.png" srcset="/img/loading.gif" alt="填"></p>
<p>code:</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">dpWays</span><span class="hljs-params">(String s)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (s == <span class="hljs-keyword">null</span> || s.length() == <span class="hljs-number">0</span>) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
   &#125;
   <span class="hljs-keyword">char</span>[] str = s.toCharArray();
   <span class="hljs-keyword">int</span> N = str.length;
   <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[N + <span class="hljs-number">1</span>];
   dp[N] = <span class="hljs-number">1</span>;
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = N - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;
      <span class="hljs-keyword">if</span> (str[i] == <span class="hljs-string">&#x27;0&#x27;</span>) &#123;
         dp[i] = <span class="hljs-number">0</span>;
      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (str[i] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;
         dp[i] = dp[i + <span class="hljs-number">1</span>];
         <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span> &lt; N) &#123;
            dp[i] += dp[i + <span class="hljs-number">2</span>];
         &#125;
      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (str[i] == <span class="hljs-string">&#x27;2&#x27;</span>) &#123;
         dp[i] = dp[i + <span class="hljs-number">1</span>]; 
         <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span> &lt; str.length &amp;&amp; (str[i + <span class="hljs-number">1</span>] &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; str[i + <span class="hljs-number">1</span>] &lt;= <span class="hljs-string">&#x27;6&#x27;</span>)) &#123;
            dp[i] += dp[i + <span class="hljs-number">2</span>];
         &#125;
      &#125; <span class="hljs-keyword">else</span> &#123;
         dp[i] = dp[i + <span class="hljs-number">1</span>];
      &#125;
   &#125;
   <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>];
&#125;</code></pre></div>



<h2 id="AB取卡牌问题"><a href="#AB取卡牌问题" class="headerlink" title="AB取卡牌问题"></a>AB取卡牌问题</h2><p>原code:</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201220150438.png" srcset="/img/loading.gif" alt="image-20201220150436084"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201220151842.png" srcset="/img/loading.gif" alt="由暴力递归得"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201220152133.png" srcset="/img/loading.gif" alt="由暴力递归得到关系图"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201220152246.png" srcset="/img/loading.gif" alt="依赖推出"></p>
<p>code:</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">windp</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length == <span class="hljs-number">0</span>) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
   &#125;
   <span class="hljs-keyword">int</span> N = arr.length;
   <span class="hljs-keyword">int</span>[][] f = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[N][N];
   <span class="hljs-keyword">int</span>[][] s = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[N][N];
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;
      f[i][i] = arr[i];
   &#125;
   <span class="hljs-comment">// 0,0 右下方移动</span>
   <span class="hljs-comment">// 0,1</span>
   <span class="hljs-comment">// 0,2</span>
   <span class="hljs-comment">// 0,N-1</span>
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> col = <span class="hljs-number">1</span>; col &lt; N; col++) &#123;
      <span class="hljs-comment">// 对角线出发位置(0,col)</span>
      <span class="hljs-keyword">int</span> L = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">int</span> R = col;
      <span class="hljs-keyword">while</span> (L &lt; N &amp;&amp; R &lt; N) &#123;
         f[L][R] = Math.max(arr[L] + s[L + <span class="hljs-number">1</span>][R], arr[R] + s[L][R - <span class="hljs-number">1</span>]);
         s[L][R] = Math.min(f[L + <span class="hljs-number">1</span>][R], f[L][R - <span class="hljs-number">1</span>]);
         L++;
         R++;
      &#125;
   &#125;
   <span class="hljs-keyword">return</span> Math.max(f[<span class="hljs-number">0</span>][N - <span class="hljs-number">1</span>], s[<span class="hljs-number">0</span>][N - <span class="hljs-number">1</span>]);
&#125;</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201220153643.png" srcset="/img/loading.gif" alt="动态规划"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201220154023.png" srcset="/img/loading.gif" alt="动态规划时间复杂度"></p>
<blockquote>
<p>对于记忆化搜索：</p>
</blockquote>
<p>如果一个问题依赖的子状态是有限个，不用枚举，时间复杂度和经典动态规划是一致的。</p>
<p>如果有枚举问题，应该改为经典动态规划。</p>
<h2 id="货币数组问题"><a href="#货币数组问题" class="headerlink" title="货币数组问题"></a>货币数组问题</h2><p>一个arr中都是正数，无重复值，arr中对应货币面值，给你一个num，用arr中组成num的方法数。</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201220154742.png" srcset="/img/loading.gif" alt="问题"></p>
<p>递归定义：f(i, rest) 表示arr[i]之后的面值随意使用，搞定rest</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// arr中都是正数且无重复值，返回组成aim的方法数</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">ways</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> aim)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length == <span class="hljs-number">0</span> || aim &lt; <span class="hljs-number">0</span>) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
   &#125;
   <span class="hljs-keyword">return</span> process(arr, <span class="hljs-number">0</span>, aim);
&#125;

<span class="hljs-comment">// 如果自由使用arr[index...]的面值，组成rest这么多钱，返回方法数 （1 , 6）</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">process</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> rest)</span> </span>&#123;
   <span class="hljs-comment">// 下面的if在process中保证了rest不会小于0</span>
  
   <span class="hljs-comment">//if (rest &lt;0)&#123;</span>
   <span class="hljs-comment">//   return 0;</span>
   <span class="hljs-comment">//&#125;</span>
   <span class="hljs-keyword">if</span> (index == arr.length) &#123; <span class="hljs-comment">// 无面值的时候</span>
      <span class="hljs-keyword">return</span> rest == <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;
   &#125;
   <span class="hljs-comment">// 有面值的时候</span>
   <span class="hljs-keyword">int</span> ways = <span class="hljs-number">0</span>;
   <span class="hljs-comment">// arr[index] 当钱面值</span>
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> zhang = <span class="hljs-number">0</span>; zhang * arr[index] &lt;= rest; zhang++) &#123;
      ways += process(arr, index + <span class="hljs-number">1</span>, rest - zhang * arr[index]);
   &#125;
   <span class="hljs-keyword">return</span> ways;
&#125;</code></pre></div>



<blockquote>
<p>记忆划搜索</p>
</blockquote>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201220164211.png" srcset="/img/loading.gif" alt="code"></p>
<blockquote>
<p>经典动态规划</p>
</blockquote>
<p>普通由记忆化搜索改的动态规划：</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201220172428.png" srcset="/img/loading.gif" alt="普通方法"></p>
<p> <strong>有枚举行为</strong> </p>
<p>再次查看依赖关系：</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201220173132.png" srcset="/img/loading.gif" alt="依赖关系"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201220173312.png" srcset="/img/loading.gif" alt="依赖"></p>
<p>星号值依赖b、c…. </p>
<p>问号值依赖a、b、c…..</p>
<p>但求问好值，要先求星号值，优化后就是当前 = 左边 加 下面</p>
<p>优化的dp：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">waysdp</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> aim)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length == <span class="hljs-number">0</span> || aim &lt; <span class="hljs-number">0</span>) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
   &#125;
   <span class="hljs-keyword">int</span> N = arr.length;
   <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[N + <span class="hljs-number">1</span>][aim + <span class="hljs-number">1</span>];
   dp[N][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = N - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123; <span class="hljs-comment">// 大顺序 从下往上</span>
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> rest = <span class="hljs-number">0</span>; rest &lt;= aim; rest++) &#123;
         dp[i][rest] = dp[i + <span class="hljs-number">1</span>][rest];
         <span class="hljs-keyword">if</span> (rest - arr[i] &gt;= <span class="hljs-number">0</span>) &#123;
            <span class="hljs-comment">// 加左 加下</span>
            dp[i][rest] += dp[i][rest - arr[i]];
         &#125;
      &#125;
   &#125;
   <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][aim];
&#125;</code></pre></div>



<p>如果所有钞票都是百位数，建议记忆化搜索，因为dp是细粒度的记录（比如上述rest循环中，rest &lt;= aim 对每个都遍历）。</p>
<h2 id="贴纸字符串问题-题目二"><a href="#贴纸字符串问题-题目二" class="headerlink" title="贴纸字符串问题(题目二)"></a>贴纸字符串问题(题目二)</h2><p>给定一个字符串str，给定一个字符串类型的数组arr。<br>arr里的每一个字符串，代表一张贴纸，你可以把单个字符剪开使用，目的是拼出str来。<br>返回需要至少多少张贴纸可以完成这个任务。<br>例子：str= “babac”，arr = {“ba”,”c”,”abcd”}<br>至少需要两张贴纸”ba”和”abcd”，因为使用这两张贴纸，把每一个字符单独剪开，含有2个a、2个b、1个c。是可以拼出str的。所以返回2。</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201221085330.png" srcset="/img/loading.gif" alt="暴力枚举"></p>
<blockquote>
<p>解题思路一</p>
</blockquote>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201221085853.png" srcset="/img/loading.gif" alt="暴力法"></p>
<p>还需要 <strong>过滤</strong> 判断字符是否全在arr，也要 <strong>过滤</strong> 没有出现在rest中的字符，被arr选中，无限递归。</p>
<p>用二维数组存储贴纸</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201221090644.png" srcset="/img/loading.gif" alt="存储格式"></p>
<p>“baabk”代表第一个贴纸，则arr[0]表示完整字符串，index0表示a出现的次数。</p>
<p>Code1:</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minStickers1</span><span class="hljs-params">(String[] stickers, String target)</span> </span>&#123;
   <span class="hljs-keyword">int</span> n = stickers.length;
   <span class="hljs-keyword">int</span>[][] map = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n][<span class="hljs-number">26</span>];

   <span class="hljs-comment">// 傻缓存</span>
   HashMap&lt;String, Integer&gt; dp = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();

   <span class="hljs-comment">// 生成每张贴纸的词频统计</span>
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;
      <span class="hljs-keyword">char</span>[] str = stickers[i].toCharArray();
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : str) &#123;
         map[i][c - <span class="hljs-string">&#x27;a&#x27;</span>]++;
      &#125;
   &#125;
   dp.put(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-number">0</span>);
   <span class="hljs-keyword">return</span> process1(dp, map, target);
&#125;

<span class="hljs-comment">// dp 傻缓存，如果t已经算过了，直接返回dp中的值</span>
<span class="hljs-comment">// t 剩余的目标</span>
<span class="hljs-comment">// 0..N每一个字符串所含字符的词频统计</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">process1</span><span class="hljs-params">(HashMap&lt;String, Integer&gt; dp, <span class="hljs-keyword">int</span>[][] map, String rest)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (dp.containsKey(rest)) &#123;
      <span class="hljs-keyword">return</span> dp.get(rest);
   &#125;
   <span class="hljs-keyword">int</span> ans = Integer.MAX_VALUE; <span class="hljs-comment">// 使用贴纸数</span>
   <span class="hljs-keyword">int</span> n = map.length; <span class="hljs-comment">// n种贴纸</span>

   <span class="hljs-comment">// rest词频统计</span>
   <span class="hljs-keyword">int</span>[] tmap = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">26</span>];
   <span class="hljs-keyword">char</span>[] target = rest.toCharArray();
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : target) &#123;
      tmap[c - <span class="hljs-string">&#x27;a&#x27;</span>]++;
   &#125;

   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;

      <span class="hljs-comment">// 找到第一个共同字符词频</span>
      <span class="hljs-keyword">if</span> (map[i][target[<span class="hljs-number">0</span>] - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-number">0</span>) &#123;
         <span class="hljs-keyword">continue</span>;
      &#125;

      StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();
      <span class="hljs-comment">// 来到第i个贴纸，j枚举从贴纸里面的变化</span>
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">26</span>; j++) &#123;
         <span class="hljs-comment">// 关于j这个字符，target词频数目大于0</span>
         <span class="hljs-keyword">if</span> (tmap[j] &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// j这个字符是target需要的</span>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; Math.max(<span class="hljs-number">0</span>, tmap[j] - map[i][j]); k++) &#123;
               <span class="hljs-comment">// 剪掉贴纸该字符的词频，还剩余多少，存到StringBuilder里面</span>
               sb.append((<span class="hljs-keyword">char</span>) (<span class="hljs-string">&#x27;a&#x27;</span> + j));
            &#125;
         &#125;
      &#125;
      String s = sb.toString();
      <span class="hljs-keyword">int</span> tmp = process1(dp, map, s);
      <span class="hljs-keyword">if</span> (tmp != -<span class="hljs-number">1</span>) &#123;
         ans = Math.min(ans, <span class="hljs-number">1</span> + tmp);
      &#125;
   &#125;
   dp.put(rest, ans == Integer.MAX_VALUE ? -<span class="hljs-number">1</span> : ans);
   <span class="hljs-keyword">return</span> dp.get(rest);
&#125;</code></pre></div>



<blockquote>
<p>解题思路二</p>
</blockquote>
<p>每次选择不选择全部，先把第一个贴纸用N张，再第二张….类似于货币数组问题</p>
<p> <strong>不推荐</strong> 可变参数多，可变参数少的， <strong>缓存</strong> 命中率高。</p>
<h2 id="两个字符串的最长公共子序列问题（第三种模型）"><a href="#两个字符串的最长公共子序列问题（第三种模型）" class="headerlink" title="两个字符串的最长公共子序列问题（第三种模型）"></a>两个字符串的最长公共子序列问题（第三种模型）</h2><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201221121850.png" srcset="/img/loading.gif" alt="猜想"></p>
<p>我们首先认为 dp[i] [j]为str1[0 ~ i]和str2[0 ~ j]的最长公共子序列</p>
<p>最后求 <strong>右下角</strong></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201221123945.png" srcset="/img/loading.gif" alt="求解过程"></p>
<p>取str1的第一个和后面依次对比</p>
<p>更改测试用例str2为 12dea3f</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201221124306.png" srcset="/img/loading.gif" alt="结果"></p>
<p>因为str1只拿出一个字符，只要出现了a，后面全是 1</p>
<p>再改第一列</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201221124459.png" srcset="/img/loading.gif" alt="第一列"></p>
<blockquote>
<p>第一种情况</p>
</blockquote>
<p>既不以str1[i]结尾也不以str2[j]结尾，与i，j无关</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201221124659.png" srcset="/img/loading.gif" alt="可能1"></p>
<p>就是str[i-1] [j-1], 来自于左上角。</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201221125134.png" srcset="/img/loading.gif" alt="对应"></p>
<p> <strong>dp[i - 1] [j - 1]</strong> </p>
<blockquote>
<p>第二种情况</p>
</blockquote>
<p>以str1[i]结尾但不以str2[j]结尾</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201221125249.png" srcset="/img/loading.gif" alt="例子"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201221125350.png" srcset="/img/loading.gif" alt="结果"></p>
<p> <strong>dp[i] [j - 1]</strong></p>
<blockquote>
<p>第三种情况</p>
</blockquote>
<p>不以str1[i]结尾但以str2[j]结尾</p>
<p> <strong>dp[i - 1] [j ]</strong></p>
<blockquote>
<p>第四种情况</p>
</blockquote>
<p>以str1[i]结尾又以str2[j]结尾</p>
<p>可能条件只有 str1[i] == str2[j]</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201221125724.png" srcset="/img/loading.gif" alt="结果"></p>
<p> <strong>1 + dp[i - 1] [j - 1]</strong></p>
<p>code:</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lcse</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] str1, <span class="hljs-keyword">char</span>[] str2)</span> </span>&#123;
   <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[str1.length][str2.length];

   <span class="hljs-comment">// 第一个字符是否相等</span>
   dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = str1[<span class="hljs-number">0</span>] == str2[<span class="hljs-number">0</span>] ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;

   <span class="hljs-comment">// 做第0列</span>
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; str1.length; i++) &#123;
      dp[i][<span class="hljs-number">0</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], str1[i] == str2[<span class="hljs-number">0</span>] ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>);
   &#125;
   <span class="hljs-comment">// 做第0行</span>
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; str2.length; j++) &#123;
      dp[<span class="hljs-number">0</span>][j] = Math.max(dp[<span class="hljs-number">0</span>][j - <span class="hljs-number">1</span>], str1[<span class="hljs-number">0</span>] == str2[j] ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>);
   &#125;

   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; str1.length; i++) &#123;
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; str2.length; j++) &#123;
         dp[i][j] = Math.max(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]);
         <span class="hljs-comment">// 最后在i也在j</span>
         <span class="hljs-keyword">if</span> (str1[i] == str2[j]) &#123;
            dp[i][j] = Math.max(dp[i][j], dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>);
            <span class="hljs-comment">// 既不在i也不在j</span>
         &#125;<span class="hljs-keyword">else</span> &#123;
            dp[i][j] = Math.max(dp[i][j], dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]);
         &#125;
      &#125;
   &#125;
   <span class="hljs-keyword">return</span> dp[str1.length - <span class="hljs-number">1</span>][str2.length - <span class="hljs-number">1</span>];
&#125;</code></pre></div>



<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201221130629.png" srcset="/img/loading.gif" alt="结果"></p>
<p>可能性2一定比1大，所以else是可以取出的</p>
<h2 id="咖啡刷杯子问题（第四种模型）"><a href="#咖啡刷杯子问题（第四种模型）" class="headerlink" title="咖啡刷杯子问题（第四种模型）"></a>咖啡刷杯子问题（第四种模型）</h2><p>给定一个数组，代表每个人喝完咖啡准备刷杯子的时间<br>只有一台咖啡机，一次只能洗一个杯子，时间耗费a，洗完才能洗下一杯<br>每个咖啡杯也可以自己挥发干净，时间耗费b，咖啡杯可以并行挥发<br>返回让所有咖啡杯变干净的最早完成时间<br>三个参数：int[] arr、int a、int b</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// a 洗咖啡机所需时间</span>
<span class="hljs-comment">// b 自然挥发时间</span>
<span class="hljs-comment">// drinks每一个员工喝完咖啡时间</span>
<span class="hljs-comment">// drinks[0...index - 1] 已经洗完</span>
<span class="hljs-comment">// washLine机器什么时候可用</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">process</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] drinks, <span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> washLine)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (index == drinks.length - <span class="hljs-number">1</span>) &#123;
      <span class="hljs-keyword">return</span> Math.min(
            <span class="hljs-comment">// （咖啡机有空时间点 和 我喝完时间点） 的最大值 + 机器洗完</span>
            Math.max(washLine, drinks[index]) + a,
            <span class="hljs-comment">// 喝完时间点 + 挥发完时间</span>
            drinks[index] + b);
   &#125;

   <span class="hljs-comment">// wash是我当前的咖啡杯，洗完的时间</span>
   <span class="hljs-keyword">int</span> wash = Math.max(washLine, drinks[index]) + a;
   <span class="hljs-comment">// 让index + 1以及后面所有咖啡杯变干净的最早时间</span>
   <span class="hljs-keyword">int</span> next1 = process(drinks, a, b, index + <span class="hljs-number">1</span>, wash);
   <span class="hljs-comment">// 既要自己洗完 也要其他都洗完 才能整体都完</span>
   <span class="hljs-keyword">int</span> p1 = Math.max(wash, next1);


   <span class="hljs-comment">// 去挥发</span>
   <span class="hljs-keyword">int</span> dry = drinks[index] + b;
   <span class="hljs-keyword">int</span> next2 = process(drinks, a, b, index + <span class="hljs-number">1</span>, washLine);
   <span class="hljs-keyword">int</span> p2 = Math.max(dry, next2);


   <span class="hljs-keyword">return</span> Math.min(p1, p2);
&#125;</code></pre></div>

<p>改为动态规划：</p>
<p>int washLine寻求最夸张的值（全洗）</p>
<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201221144225.png" srcset="/img/loading.gif" alt="初始化dp" style="zoom:50%;" />

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201221144423.png" srcset="/img/loading.gif" alt="定数"></p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/03/11/%E2%80%9C%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6%E2%80%9D%E7%9A%84%E5%89%AF%E6%9C%AC%202/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">算法进阶</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/12/25/%E5%89%91%E6%8C%87offer/">
                        <span class="hidden-mobile">剑指offer</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments">
                
                

              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":200})
    NProgress.start()
    document.addEventListener('DOMContentLoaded', function() {
      window.NProgress && window.NProgress.inc();
    })
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.staticfile.org/jquery/3.5.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.staticfile.org/tocbot/4.12.0/tocbot.min.js" ></script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>





  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      var inputArea = document.querySelector("#local-search-input");
      inputArea.onclick = function () {
        searchFunc(path, 'local-search-input', 'local-search-result');
        this.onclick = null
      }
    })()
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>



<!-- hexo injector body_end start -->
  <script src="/js/custom.js"></script>
<!-- hexo injector body_end end --></body>
</html>
