<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>docker</title>
    <link href="/2021/04/25/docker/"/>
    <url>/2021/04/25/docker/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    
    
    <tags>
      
      <tag>运维</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我不会k8s</title>
    <link href="/2021/04/25/k8s/"/>
    <url>/2021/04/25/k8s/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    
    
    <tags>
      
      <tag>运维</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux加shell</title>
    <link href="/2021/04/25/linux%E5%8F%8Ashell/"/>
    <url>/2021/04/25/linux%E5%8F%8Ashell/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>消息队列</title>
    <link href="/2021/04/24/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    <url>/2021/04/24/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    
    
    <tags>
      
      <tag>中间件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>八股之王</title>
    <link href="/2021/04/23/%E5%85%AB%E8%82%A1%E6%96%87%E6%B1%87%E6%80%BB/"/>
    <url>/2021/04/23/%E5%85%AB%E8%82%A1%E6%96%87%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql索引</title>
    <link href="/2021/04/22/mysql/"/>
    <url>/2021/04/22/mysql/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis</title>
    <link href="/2021/04/22/redis/"/>
    <url>/2021/04/22/redis/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="1-NoSQL的引言"><a href="#1-NoSQL的引言" class="headerlink" title="1.  NoSQL的引言"></a>1.  NoSQL的引言</h2><p><strong>NoSQL</strong>(<code> Not Only SQL</code> )，意即<strong>不仅仅是SQL</strong>, 泛指非关系型的数据库。Nosql这个技术门类,早期就有人提出,发展至2009年趋势越发高涨。</p><h2 id="2-为什么是NoSQL"><a href="#2-为什么是NoSQL" class="headerlink" title="2. 为什么是NoSQL"></a>2. 为什么是NoSQL</h2><p>随着互联网网站的兴起，传统的关系数据库在应付动态网站，特别是超大规模和高并发的纯动态网站已经显得力不从心，暴露了很多难以克服的问题。如<code>商城网站中对商品数据频繁查询</code>、<code>对热搜商品的排行统计</code>、<code>订单超时问题</code>、以及微信朋友圈（音频，视频）存储等相关使用传统的关系型数据库实现就显得非常复杂，虽然能实现相应功能但是在性能上却不是那么乐观。nosql这个技术门类的出现，更好的解决了这些问题，它告诉了世界不仅仅是sql。</p><h2 id="3-NoSQL的四大分类"><a href="#3-NoSQL的四大分类" class="headerlink" title="3. NoSQL的四大分类"></a>3. NoSQL的四大分类</h2><h3 id="3-1-键值-Key-Value-存储数据库"><a href="#3-1-键值-Key-Value-存储数据库" class="headerlink" title="3.1 键值(Key-Value)存储数据库"></a>3.1 键值(Key-Value)存储数据库</h3><pre><code class="hljs markdown"><span class="hljs-section"># 1.说明: </span><span class="hljs-bullet">-</span> 这一类数据库主要会使用到一个哈希表，这个表中有一个特定的键和一个指针指向特定的数据。<span class="hljs-section"># 2.特点</span><span class="hljs-bullet">-</span> Key/value模型对于IT系统来说的优势在于简单、易部署。  <span class="hljs-bullet">-</span> 但是如果DBA只对部分值进行查询或更新的时候，Key/value就显得效率低下了。<span class="hljs-section"># 3.相关产品</span><span class="hljs-bullet">-</span> Tokyo Cabinet/Tyrant,<span class="hljs-bullet">-</span> Redis<span class="hljs-bullet">-</span> SSDB<span class="hljs-bullet">-</span> Voldemort <span class="hljs-bullet">-</span> Oracle BDB</code></pre><h3 id="3-2-列存储数据库"><a href="#3-2-列存储数据库" class="headerlink" title="3.2 列存储数据库"></a>3.2 列存储数据库</h3><pre><code class="hljs markdown"><span class="hljs-section"># 1.说明</span><span class="hljs-bullet">-</span> 这部分数据库通常是用来应对分布式存储的海量数据。<span class="hljs-section"># 2.特点</span><span class="hljs-bullet">-</span> 键仍然存在，但是它们的特点是指向了多个列。这些列是由列家族来安排的。<span class="hljs-section"># 3.相关产品</span><span class="hljs-bullet">-</span> Cassandra、HBase、Riak.</code></pre><h3 id="3-3-文档型数据库"><a href="#3-3-文档型数据库" class="headerlink" title="3.3 文档型数据库"></a>3.3 文档型数据库</h3><pre><code class="hljs markdown"><span class="hljs-section"># 1.说明</span><span class="hljs-bullet">-</span> 文档型数据库的灵感是来自于Lotus Notes办公软件的，而且它同第一种键值存储相类似该类型的数据模型是版本化的文档，半结构化的文档以特定的格式存储，比如JSON。文档型数据库可 以看作是键值数据库的升级版，允许之间嵌套键值。而且文档型数据库比键值数据库的查询效率更高<span class="hljs-section"># 2.特点</span><span class="hljs-bullet">-</span> 以文档形式存储<span class="hljs-section"># 3.相关产品</span><span class="hljs-bullet">-</span> MongoDB、CouchDB、 MongoDb(4.x). 国内也有文档型数据库SequoiaDB，已经开源。</code></pre><h3 id="3-4-图形-Graph-数据库"><a href="#3-4-图形-Graph-数据库" class="headerlink" title="3.4 图形(Graph)数据库"></a>3.4 图形(Graph)数据库</h3> <pre><code class="hljs markdown"><span class="hljs-section"># 1.说明</span><span class="hljs-bullet">-</span> 图形结构的数据库同其他行列以及刚性结构的SQL数据库不同，它是使用灵活的图形模型，并且能够扩展到多个服务器上。<span class="hljs-bullet">-</span> NoSQL数据库没有标准的查询语言(SQL)，因此进行数据库查询需要制定数据模型。许多NoSQL数据库都有REST式的数据接口或者查询API。<span class="hljs-section"># 2.特点</span><span class="hljs-section"># 3.相关产品</span><span class="hljs-bullet">-</span> Neo4J、InfoGrid、 Infinite Graph、</code></pre><hr><h2 id="4-NoSQL应用场景"><a href="#4-NoSQL应用场景" class="headerlink" title="4. NoSQL应用场景"></a>4. NoSQL应用场景</h2><ul><li><p>数据模型比较简单</p></li><li><p>需要灵活性更强的IT系统</p></li><li><p>对数据库性能要求较高</p></li><li><p>不需要高度的数据一致性</p></li></ul><h2 id="5-什么是Redis"><a href="#5-什么是Redis" class="headerlink" title="5. 什么是Redis"></a>5. 什么是Redis</h2><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/imgimage-20200623121234046.png" alt="redis"></p><blockquote><p>Redis is an open source (BSD licensed), in-memory data structure store, used as a database, cache and message broker.</p></blockquote><p>Redis 开源  遵循BSD  基于内存数据存储 被用于作为 数据库 缓存  消息中间件</p><ul><li>总结: redis是一个<code>内存型的数据库</code></li></ul><h2 id="6-Redis特点"><a href="#6-Redis特点" class="headerlink" title="6. Redis特点"></a>6. Redis特点</h2><ul><li><p> Redis是一个高性能key/value内存型数据库</p></li><li><p>Redis支持丰富的数据类型 </p></li><li><p>Redis支持持久化 </p></li><li><p>Redis单线程,单进程</p></li></ul><hr><h2 id="7-Redis安装"><a href="#7-Redis安装" class="headerlink" title="7. Redis安装"></a>7. Redis安装</h2><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img1.redis%E5%86%85%E5%AD%98%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%86%E8%8A%82.png"></p><pre><code class="hljs markdown"><span class="hljs-section"># 0.准备环境</span><span class="hljs-bullet">-</span> vmware15.x+<span class="hljs-bullet">-</span> centos7.x+<span class="hljs-section"># 1.下载redis源码包</span><span class="hljs-bullet">-</span> https://redis.io/</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/imgimage-20200623121621195.png"></p><pre><code class="hljs markdown"><span class="hljs-section"># 2.下载完整源码包</span><span class="hljs-bullet">-</span> redis-4.0.10.tar.gz</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/imgimage-20200623123918876.png" alt="tar.gz"></p><pre><code class="hljs markdown"><span class="hljs-section"># 3.将下载redis资料包上传到Linux中</span></code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/imgimage-20200623124327319.png"></p><pre><code class="hljs markdown"><span class="hljs-section"># 4.解压缩文件</span>[root@localhost ~]# tar -zxvf redis-4.0.10.tar.gz[root@localhost ~]# ll</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/imgimage-20200623124522026.png"></p><pre><code class="hljs markdown"><span class="hljs-section"># 5.安装gcc  </span><span class="hljs-bullet">-</span> yum install -y gcc<span class="hljs-section"># 6.进入解压缩目录执行如下命令</span><span class="hljs-bullet">-</span> make MALLOC=libc<span class="hljs-section"># 7.编译完成后执行如下命令</span><span class="hljs-bullet">-</span> make install PREFIX=/usr/redis<span class="hljs-section"># 8.进入/usr/redis目录启动redis服务 </span><span class="hljs-bullet">-</span> ./redis-server</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/imgimage-20200623125420505.png"></p><pre><code class="hljs markdown"><span class="hljs-section"># 9.Redis服务端口默认是 6379</span><span class="hljs-section"># 10.进入bin目录执行客户端连接操作</span><span class="hljs-bullet">-</span> ./redis-cli –p 6379</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/imgimage-20200623125716013.png"></p><pre><code class="hljs markdown"><span class="hljs-section"># 11.连接成功出现上面界面连接成功</span></code></pre><h2 id="8-Redis数据库相关指令"><a href="#8-Redis数据库相关指令" class="headerlink" title="8. Redis数据库相关指令"></a>8. Redis数据库相关指令</h2><h3 id="8-1-数据库操作指令"><a href="#8-1-数据库操作指令" class="headerlink" title="8.1 数据库操作指令"></a>8.1 数据库操作指令</h3><pre><code class="hljs markdown"><span class="hljs-section"># 1.Redis中库说明</span><span class="hljs-bullet">-</span> 使用redis的默认配置器动redis服务后,默认会存在16个库,编号从0-15<span class="hljs-bullet">-</span> 可以使用select 库的编号 来选择一个redis的库<span class="hljs-section"># 2.Redis中操作库的指令</span><span class="hljs-bullet">-</span> 清空当前的库  FLUSHDB<span class="hljs-bullet">-</span> 清空全部的库  FLUSHALL<span class="hljs-section"># 3.redis客户端显示中文</span><span class="hljs-bullet">-</span>./redis-cli  -p 7000 --raw</code></pre><h3 id="8-2-操作key相关指令"><a href="#8-2-操作key相关指令" class="headerlink" title="8.2 操作key相关指令"></a>8.2 操作key相关指令</h3><pre><code class="hljs markdown"><span class="hljs-section"># 1.DEL指令</span><span class="hljs-bullet">-</span> 语法 :  DEL key [key ...] <span class="hljs-bullet">-</span> 作用 :  删除给定的一个或多个key 。不存在的key 会被忽略。<span class="hljs-bullet">-</span> 可用版本： &gt;= 1.0.0<span class="hljs-bullet">-</span> 返回值： 被删除key 的数量。 <span class="hljs-section"># 2.EXISTS指令</span><span class="hljs-bullet">-</span> 语法:  EXISTS key<span class="hljs-bullet">-</span> 作用:  检查给定key 是否存在。<span class="hljs-bullet">-</span> 可用版本： &gt;= 1.0.0<span class="hljs-bullet">-</span> 返回值： 若key 存在，返回1 ，否则返回0。<span class="hljs-section"># 3.EXPIRE</span><span class="hljs-bullet">-</span> 语法:  EXPIRE key seconds<span class="hljs-bullet">-</span> 作用:  为给定key 设置生存时间，当key 过期时(生存时间为0 )，它会被自动删除。<span class="hljs-bullet">-</span> 可用版本： &gt;= 1.0.0<span class="hljs-bullet">-</span> 时间复杂度： O(1)<span class="hljs-bullet">-</span> 返回值：设置成功返回1 。<span class="hljs-section"># 4.KEYS</span><span class="hljs-bullet">-</span> 语法 :  KEYS pattern<span class="hljs-bullet">-</span> 作用 :  查找所有符合给定模式pattern 的key 。<span class="hljs-bullet">-</span> 语法:<span class="hljs-code">KEYS * 匹配数据库中所有key 。</span><span class="hljs-code">KEYS h?llo 匹配hello ，hallo 和hxllo 等。</span><span class="hljs-code">KEYS h*llo 匹配hllo 和heeeeello 等。</span><span class="hljs-code">KEYS h[ae]llo 匹配hello 和hallo ，但不匹配hillo 。特殊符号用 &quot;\&quot; 隔开</span><span class="hljs-code">- 可用版本： &gt;= 1.0.0</span><span class="hljs-code">- 返回值： 符合给定模式的key 列表。</span><span class="hljs-code"></span><span class="hljs-code"># 5.MOVE</span><span class="hljs-code">- 语法 :  MOVE key db</span><span class="hljs-code">- 作用 :  将当前数据库的key 移动到给定的数据库db 当中。</span><span class="hljs-code">- 可用版本： &gt;= 1.0.0</span><span class="hljs-code">- 返回值： 移动成功返回1 ，失败则返回0 。</span><span class="hljs-code"></span><span class="hljs-code"># 6.PEXPIRE</span><span class="hljs-code">- 语法 :  PEXPIRE key milliseconds</span><span class="hljs-code">- 作用 :  这个命令和EXPIRE 命令的作用类似，但是它以毫秒为单位设置key 的生存时间，而不像EXPIRE 命令那样，以秒为单位。</span><span class="hljs-code">- 可用版本： &gt;= 2.6.0</span><span class="hljs-code">- 时间复杂度： O(1)</span><span class="hljs-code">- 返回值：设置成功，返回1  key 不存在或设置失败，返回0</span><span class="hljs-code"></span><span class="hljs-code"># 7.PEXPIREAT</span><span class="hljs-code">- 语法 :  PEXPIREAT key milliseconds-timestamp</span><span class="hljs-code">- 作用 :  这个命令和EXPIREAT 命令类似，但它以毫秒为单位设置key 的过期unix 时间戳，而不是像EXPIREAT那样，以秒为单位。</span><span class="hljs-code">- 可用版本： &gt;= 2.6.0</span><span class="hljs-code">- 返回值：如果生存时间设置成功，返回1 。当key 不存在或没办法设置生存时间时，返回0 。(查看EXPIRE 命令获取更多信息)</span><span class="hljs-code"></span><span class="hljs-code"># 8.TTL</span><span class="hljs-code">- 语法 :   TTL key</span><span class="hljs-code">- 作用 :   以秒为单位，返回给定key 的剩余生存时间(TTL, time to live)。</span><span class="hljs-code">- 可用版本： &gt;= 1.0.0</span><span class="hljs-code">- 返回值：</span><span class="hljs-code">当key 不存在时，返回-2 。</span><span class="hljs-code">当key 存在但没有设置剩余生存时间时，返回-1 。</span><span class="hljs-code">否则，以秒为单位，返回key 的剩余生存时间。</span><span class="hljs-code">- Note : 在Redis 2.8 以前，当key 不存在，或者key 没有设置剩余生存时间时，命令都返回-1 。</span><span class="hljs-code"></span><span class="hljs-code"># 9.PTTL</span><span class="hljs-code">- 语法 :  PTTL key</span><span class="hljs-code">- 作用 :  这个命令类似于TTL 命令，但它以毫秒为单位返回key 的剩余生存时间，而不是像TTL 命令那样，以秒为单位。</span><span class="hljs-code">- 可用版本： &gt;= 2.6.0</span><span class="hljs-code">- 返回值： 当key 不存在时，返回-2 。当key 存在但没有设置剩余生存时间时，返回-1 。</span><span class="hljs-code">- 否则，以毫秒为单位，返回key 的剩余生存时间。</span><span class="hljs-code">- 注意 : 在Redis 2.8 以前，当key 不存在，或者key 没有设置剩余生存时间时，命令都返回-1 。</span><span class="hljs-code"></span><span class="hljs-code"># 10.RANDOMKEY</span><span class="hljs-code">- 语法 :  RANDOMKEY</span><span class="hljs-code">- 作用 :  从当前数据库中随机返回(不删除) 一个key 。</span><span class="hljs-code">- 可用版本： &gt;= 1.0.0</span><span class="hljs-code">- 返回值：当数据库不为空时，返回一个key 。当数据库为空时，返回nil 。</span><span class="hljs-code"></span><span class="hljs-code"># 11.RENAME</span><span class="hljs-code">- 语法 :  RENAME key newkey</span><span class="hljs-code">- 作用 :  将key 改名为newkey 。当key 和newkey 相同，或者key 不存在时，返回一个错误。当newkey 已经存在时，RENAME 命令将覆盖旧值。</span><span class="hljs-code">- 可用版本： &gt;= 1.0.0</span><span class="hljs-code">- 返回值： 改名成功时提示OK ，失败时候返回一个错误。</span><span class="hljs-code"></span><span class="hljs-code"># 12.TYPE</span><span class="hljs-code">- 语法 :  TYPE key</span><span class="hljs-code">- 作用 :  返回key 所储存的值的类型。</span><span class="hljs-code">- 可用版本： &gt;= 1.0.0</span><span class="hljs-code">- 返回值：</span><span class="hljs-code">none (key 不存在)</span><span class="hljs-code">string (字符串)</span><span class="hljs-code">list (列表)</span><span class="hljs-code">set (集合)</span><span class="hljs-code">zset (有序集)</span><span class="hljs-code">hash (哈希表)</span></code></pre><h3 id="8-3-String类型"><a href="#8-3-String类型" class="headerlink" title="8.3 String类型"></a>8.3 String类型</h3><h4 id="1-内存存储模型"><a href="#1-内存存储模型" class="headerlink" title="1. 内存存储模型"></a>1. 内存存储模型</h4><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/imgimage-20200623132011112.png" alt="String"></p><h4 id="2-常用操作命令"><a href="#2-常用操作命令" class="headerlink" title="2. 常用操作命令"></a>2. 常用操作命令</h4><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>set</td><td>设置一个key/value</td></tr><tr><td>get</td><td>根据key获得对应的value</td></tr><tr><td>mset</td><td>一次设置多个key value</td></tr><tr><td>mget</td><td>一次获得多个key的value</td></tr><tr><td>getset</td><td>获得原始key的值，同时设置新值</td></tr><tr><td>strlen</td><td>获得对应key存储value的长度</td></tr><tr><td>append</td><td>为对应key的value追加内容</td></tr><tr><td>getrange 索引0开始</td><td>截取value的内容</td></tr><tr><td>setex</td><td>设置一个key存活的有效期（秒）</td></tr><tr><td>psetex</td><td>设置一个key存活的有效期（毫秒）</td></tr><tr><td>setnx</td><td>存在不做任何操作,不存在添加</td></tr><tr><td>msetnx原子操作(只要有一个存在不做任何操作)</td><td>可以同时设置多个key,只有有一个存在都不保存</td></tr><tr><td>decr</td><td>进行数值类型的-1操作</td></tr><tr><td>decrby</td><td>根据提供的数据进行减法操作</td></tr><tr><td>Incr</td><td>进行数值类型的+1操作</td></tr><tr><td>incrby</td><td>根据提供的数据进行加法操作</td></tr><tr><td>Incrbyfloat</td><td>根据提供的数据加入浮点数</td></tr></tbody></table><h3 id="8-4-List类型"><a href="#8-4-List类型" class="headerlink" title="8.4 List类型"></a>8.4 List类型</h3><p>list 列表 相当于java中list 集合  特点  元素有序  且 可以重复</p><h4 id="1-内存存储模型-1"><a href="#1-内存存储模型-1" class="headerlink" title="1.内存存储模型"></a>1.内存存储模型</h4><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/imgimage-20200623161006014.png" alt="List"></p><h4 id="2-常用操作指令"><a href="#2-常用操作指令" class="headerlink" title="2.常用操作指令"></a>2.常用操作指令</h4><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>lpush</td><td>将某个值加入到一个key列表头部</td></tr><tr><td>lpushx</td><td>同lpush,但是必须要保证这个key存在</td></tr><tr><td>rpush</td><td>将某个值加入到一个key列表末尾</td></tr><tr><td>rpushx</td><td>同rpush,但是必须要保证这个key存在</td></tr><tr><td>lpop</td><td>返回和移除列表左边的第一个元素</td></tr><tr><td>rpop</td><td>返回和移除列表右边的第一个元素</td></tr><tr><td>lrange</td><td>获取某一个下标区间内的元素</td></tr><tr><td>llen</td><td>获取列表元素个数</td></tr><tr><td>lset</td><td>设置某一个指定索引的值(索引必须存在)</td></tr><tr><td>lindex</td><td>获取某一个指定索引位置的元素</td></tr><tr><td>lrem</td><td>删除重复元素</td></tr><tr><td>ltrim</td><td>保留列表中特定区间内的元素</td></tr><tr><td>linsert</td><td>在某一个元素之前，之后插入新元素</td></tr></tbody></table><h3 id="8-5-Set类型"><a href="#8-5-Set类型" class="headerlink" title="8.5 Set类型"></a>8.5 Set类型</h3><p>特点: Set类型 Set集合 元素无序  不可以重复</p><h4 id="1-内存存储模型-2"><a href="#1-内存存储模型-2" class="headerlink" title="1.内存存储模型"></a>1.内存存储模型</h4><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/imgimage-20200623193634316.png" alt="Set"></p><h4 id="2-常用命令"><a href="#2-常用命令" class="headerlink" title="2.常用命令"></a>2.常用命令</h4><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>sadd</td><td>为集合添加元素</td></tr><tr><td>smembers</td><td>显示集合中所有元素 无序</td></tr><tr><td>scard</td><td>返回集合中元素的个数</td></tr><tr><td>spop</td><td>随机返回一个元素 并将元素在集合中删除</td></tr><tr><td>smove</td><td>从一个集合中向另一个集合移动元素  必须是同一种类型</td></tr><tr><td>srem</td><td>从集合中删除一个元素</td></tr><tr><td>sismember</td><td>判断一个集合中是否含有这个元素</td></tr><tr><td>srandmember</td><td>随机返回元素</td></tr><tr><td>sdiff</td><td>去掉第一个集合中其它集合含有的相同元素</td></tr><tr><td>sinter</td><td>求交集</td></tr><tr><td>sunion</td><td>求和集</td></tr></tbody></table><h3 id="8-6-ZSet类型"><a href="#8-6-ZSet类型" class="headerlink" title="8.6 ZSet类型"></a>8.6 ZSet类型</h3><p>特点: 可排序的set集合  排序  不可重复 </p><p>ZSET 官方  可排序SET  sortSet   </p><h4 id="1-内存模型"><a href="#1-内存模型" class="headerlink" title="1.内存模型"></a>1.内存模型</h4><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/imgimage-20200623194903967.png" alt="Zset"></p><h4 id="2-常用命令-1"><a href="#2-常用命令-1" class="headerlink" title="2.常用命令"></a>2.常用命令</h4><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>zadd</td><td>添加一个有序集合元素</td></tr><tr><td>zcard</td><td>返回集合的元素个数</td></tr><tr><td>zrange 升序 zrevrange 降序</td><td>返回一个范围内的元素</td></tr><tr><td>zrangebyscore</td><td>按照分数查找一个范围内的元素</td></tr><tr><td>zrank</td><td>返回排名</td></tr><tr><td>zrevrank</td><td>倒序排名</td></tr><tr><td>zscore</td><td>显示某一个元素的分数</td></tr><tr><td>zrem</td><td>移除某一个元素</td></tr><tr><td>zincrby</td><td>给某个特定元素加分</td></tr></tbody></table><h3 id="8-7-hash类型"><a href="#8-7-hash类型" class="headerlink" title="8.7 hash类型"></a>8.7 hash类型</h3><p>特点: value 是一个map结构 存在key value  key 无序的  </p><h4 id="1-内存模型-1"><a href="#1-内存模型-1" class="headerlink" title="1.内存模型"></a>1.内存模型</h4><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/imgimage-20200623200348408.png" alt="Hash"></p><h4 id="2-常用命令-2"><a href="#2-常用命令-2" class="headerlink" title="2.常用命令"></a>2.常用命令</h4><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>hset</td><td>设置一个key/value对</td></tr><tr><td>hget</td><td>获得一个key对应的value</td></tr><tr><td>hgetall</td><td>获得所有的key/value对</td></tr><tr><td>hdel</td><td>删除某一个key/value对</td></tr><tr><td>hexists</td><td>判断一个key是否存在</td></tr><tr><td>hkeys</td><td>获得所有的key</td></tr><tr><td>hvals</td><td>获得所有的value</td></tr><tr><td>hmset</td><td>设置多个key/value</td></tr><tr><td>hmget</td><td>获得多个key的value</td></tr><tr><td>hsetnx</td><td>设置一个不存在的key的值</td></tr><tr><td>hincrby</td><td>为value进行加法运算</td></tr><tr><td>hincrbyfloat</td><td>为value加入浮点值</td></tr></tbody></table><hr><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img2.%E5%BC%80%E5%90%AFredis%E8%BF%9C%E7%A8%8B%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BF%9E%E6%8E%A5.png"></p><h2 id="9-持久化机制"><a href="#9-持久化机制" class="headerlink" title="9. 持久化机制"></a>9. 持久化机制</h2><p>client  redis[内存] —–&gt;  内存数据- 数据持久化–&gt;磁盘</p><p>Redis官方提供了两种不同的持久化方法来将数据存储到硬盘里面分别是:</p><ul><li>快照(Snapshot)</li><li>AOF (Append Only File) 只追加日志文件</li></ul><h3 id="9-1-快照-Snapshot"><a href="#9-1-快照-Snapshot" class="headerlink" title="9.1 快照(Snapshot)"></a>9.1 快照(Snapshot)</h3><h4 id="1-特点"><a href="#1-特点" class="headerlink" title="1. 特点"></a>1. 特点</h4><p>这种方式可以将<code>某一时刻的所有数据</code>都写入硬盘中,当然这也是 <strong>redis的默认开启持久化方式</strong> ,保存的文件是以.rdb形式结尾的文件因此这种方式也称之为RDB方式。</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/imgimage-20200623204303074.png" alt="RDB"></p><h4 id="2-快照生成方式"><a href="#2-快照生成方式" class="headerlink" title="2.快照生成方式"></a>2.快照生成方式</h4><ul><li>客户端方式: BGSAVE 和 SAVE指令</li><li>服务器配置自动触发</li></ul><pre><code class="hljs markdown"><span class="hljs-section"># 1.客户端方式之BGSAVE</span><span class="hljs-bullet">-</span> a.客户端可以使用BGSAVE命令来创建一个快照,当接收到客户端的BGSAVE命令时,redis会调用fork¹来创建一个子进程,然后子进程负责将快照写入磁盘中,而父进程则继续处理命令请求。<span class="hljs-code"></span><span class="hljs-code">`名词解释: fork当一个进程创建子进程的时候,底层的操作系统会创建该进程的一个副本,在类unix系统中创建子进程的操作会进行优化:在刚开始的时候,父子进程共享相同内存,直到父进程或子进程对内存进行了写之后,对被写入的内存的共享才会结束服务` (保证快照如果主进程没有写操作，会以最大速度持久化；如果主进程操作了写，速度会降低)</span></code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/imgimage-20200623205132460.png" alt="BGSAVE"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210517105713.png"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210517105651.png"></p><pre><code class="hljs markdown"><span class="hljs-section"># 2.客户端方式之SAVE</span><span class="hljs-bullet">-</span> b.客户端还可以使用SAVE命令来创建一个快照,接收到SAVE命令的redis服务器在快照创建完毕之前将不再响应任何其他的命令</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/imgimage-20200623205444101.png" alt="SAVE"></p><ul><li> <strong>注意: SAVE命令并不常用,使用SAVE命令在快照创建完毕之前,redis处于阻塞状态,无法对外服务</strong> </li></ul><pre><code class="hljs markdown"><span class="hljs-section"># 3.服务器配置方式之满足配置自动触发</span><span class="hljs-bullet">-</span> 如果用户在redis.conf中设置了save配置选项,redis会在save选项条件满足之后自动触发一次 BGSAVE命令 ,如果设置多个save配置选项,当任意一个save配置选项条件满足,redis也会触发一次BGSAVE命令</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/imgimage-20200623210021012.png" alt="redis.conf"></p><p>15 分钟内 1key变化，则15分钟做一次BGSAVE…</p><pre><code class="hljs markdown"><span class="hljs-section"># 4.服务器接收客户端shutdown指令</span><span class="hljs-bullet">-</span> 当redis通过shutdown指令接收到关闭服务器的请求时,会执行一个save命令,阻塞所有的客户端,不再执行客户端执行发送的任何命令,并且在save命令执行完毕之后关闭服务器</code></pre><h4 id="3-配置生成快照名称和位置"><a href="#3-配置生成快照名称和位置" class="headerlink" title="3.配置生成快照名称和位置"></a>3.配置生成快照名称和位置</h4><pre><code class="hljs markdown"><span class="hljs-section">#1.修改生成快照名称</span><span class="hljs-bullet">-</span> dbfilename dump.rdb<span class="hljs-section"># 2.修改生成位置</span><span class="hljs-bullet">-</span> dir ./</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/imgimage-20200623210352448.png" alt="RDB-filename"></p><hr><h3 id="9-2-AOF-只追加日志文件"><a href="#9-2-AOF-只追加日志文件" class="headerlink" title="9.2 AOF 只追加日志文件"></a>9.2 AOF 只追加日志文件</h3><h4 id="1-特点-1"><a href="#1-特点-1" class="headerlink" title="1.特点"></a>1.特点</h4><p>这种方式可以将所有客户端执行的<code>写命令记录到日志文件</code>中,AOF持久化会将被执行的写命令写到AOF的文件末尾,以此来记录数据发生的变化,因此只要redis从头到尾执行一次AOF文件所包含的所有写命令,就可以恢复AOF文件的记录的数据集.</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/imgimage-20200623211330798.png" alt="AOF"></p><h4 id="2-开启AOF持久化"><a href="#2-开启AOF持久化" class="headerlink" title="2.开启AOF持久化"></a>2.开启AOF持久化</h4><p>在redis的默认配置中AOF持久化机制是没有开启的，需要在配置中开启</p><pre><code class="hljs markdown"><span class="hljs-section"># 1.开启AOF持久化</span><span class="hljs-bullet">-</span> a.修改 appendonly yes 开启持久化<span class="hljs-bullet">-</span> b.修改 appendfilename &quot;appendonly.aof&quot; 指定生成文件名称</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/imgimage-20200623211508987.png" alt="redis-conf"></p><h4 id="3-日志追加频率"><a href="#3-日志追加频率" class="headerlink" title="3.日志追加频率"></a>3.日志追加频率</h4><pre><code class="hljs markdown"><span class="hljs-section"># 1.always 【谨慎使用】</span><span class="hljs-bullet">-</span> 说明: 每个redis写命令都要同步写入硬盘,严重降低redis速度<span class="hljs-bullet">-</span> 解释: 如果用户使用了always选项,那么每个redis写命令都会被写入硬盘,从而将发生系统崩溃时出现的数据丢失减到最少;遗憾的是,因为这种同步策略需要对硬盘进行大量的写入操作,所以redis处理命令的速度会受到硬盘性能的限制;<span class="hljs-bullet">-</span> 注意: 转盘式硬盘在这种频率下200左右个命令/s ; 固态硬盘(SSD) 几百万个命令/s;<span class="hljs-bullet">-</span> 警告: 使用SSD用户请谨慎使用always选项,这种模式不断写入少量数据的做法有可能会引发严重的写入放大问题,导致将固态硬盘的寿命从原来的几年降低为几个月。<span class="hljs-section"># 2.everysec 【推荐】</span><span class="hljs-bullet">-</span> 说明: 每秒执行一次同步显式的将多个写命令同步到磁盘<span class="hljs-bullet">-</span> 解释： 为了兼顾数据安全和写入性能,用户可以考虑使用everysec选项,让redis每秒一次的频率对AOF文件进行同步;redis每秒同步一次AOF文件时性能和不使用任何持久化特性时的性能相差无几,而通过每秒同步一次AOF文件,redis可以保证,即使系统崩溃,用户最多丢失一秒之内产生的数据。<span class="hljs-section"># 3.no【不推荐】</span><span class="hljs-bullet">-</span> 说明: 由操作系统决定何时同步 <span class="hljs-bullet">-</span> 解释：最后使用no选项,将完全有操作系统决定什么时候同步AOF日志文件,这个选项不会对redis性能带来影响但是系统崩溃时,会丢失不定数量的数据,另外如果用户硬盘处理写入操作不够快的话,当缓冲区被等待写入硬盘数据填满时,redis会处于阻塞状态,并导致redis的处理命令请求的速度变慢。</code></pre><h4 id="4-修改同步频率"><a href="#4-修改同步频率" class="headerlink" title="4.修改同步频率"></a>4.修改同步频率</h4><pre><code class="hljs markdown"><span class="hljs-section"># 1.修改日志同步频率</span><span class="hljs-bullet">-</span> 修改appendfsync everysec|always|no 指定</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/imgimage-20200623211658910.png" alt="redis-conf"></p><hr><h3 id="9-3-AOF文件的重写"><a href="#9-3-AOF文件的重写" class="headerlink" title="9.3 AOF文件的重写"></a>9.3 AOF文件的重写</h3><h4 id="1-AOF带来的问题"><a href="#1-AOF带来的问题" class="headerlink" title="1. AOF带来的问题"></a>1. AOF带来的问题</h4><p>AOF的方式也同时带来了另一个问题。持久化文件会变的越来越大。例如我们调用incr test命令100次，文件中必须保存全部的100条命令，其实有99条都是多余的。因为要恢复数据库的状态其实文件中保存一条set test 100就够了。为了压缩aof的持久化文件Redis提供了<code>AOF重写(ReWriter)机制</code>。</p><h4 id="2-AOF重写"><a href="#2-AOF重写" class="headerlink" title="2. AOF重写"></a>2. AOF重写</h4><p>用来在一定程度上<code>减小AOF文件的体积</code></p><h4 id="3-触发重写方式"><a href="#3-触发重写方式" class="headerlink" title="3. 触发重写方式"></a>3. 触发重写方式</h4><pre><code class="hljs markdown"><span class="hljs-section"># 1.客户端方式触发重写</span><span class="hljs-bullet">-</span> 执行BGREWRITEAOF命令  不会阻塞redis的服务<span class="hljs-section"># 2.服务器配置方式自动触发</span><span class="hljs-bullet">-</span> 配置redis.conf中的auto-aof-rewrite-percentage选项 参加下图↓↓↓<span class="hljs-bullet">-</span> 如果设置auto-aof-rewrite-percentage值为100和auto-aof-rewrite-min-size 64mb,并且启用的AOF持久化时,那么当AOF文件体积大于64M,并且AOF文件的体积比上一次重写之后体积大了至少一倍(100%)时,会自动触发,如果重写过于频繁,用户可以考虑将auto-aof-rewrite-percentage设置为更大</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/imgimage-20200623212547775.png" alt="ReWriter"></p><h4 id="4-重写原理"><a href="#4-重写原理" class="headerlink" title="4. 重写原理"></a>4. 重写原理</h4><p> <strong>注意：重写aof文件的操作，并没有读取旧的aof文件，而是将整个内存中的数据库内容用命令的方式重写了一个新的aof文件,替换原有的文件这点和快照有点类似。</strong> </p><pre><code class="hljs markdown"><span class="hljs-section"># 重写流程</span><span class="hljs-bullet">-</span> 1. redis调用fork ，现在有父子两个进程 子进程根据内存中的数据库快照，往临时文件中写入重建数据库状态的命令<span class="hljs-bullet">-</span> 2. 父进程继续处理client请求，除了把写命令写入到原来的aof文件中(防止重写失败)。同时把收到的写命令缓存起来。这样就能保证如果子进程重写失败的话并不会出问题。<span class="hljs-bullet">-</span> 3. 当子进程把快照内容写入已命令方式写到临时文件中后，子进程发信号通知父进程。然后父进程把缓存的写命令也写入到临时文件。<span class="hljs-bullet">-</span> 4. 现在父进程可以使用临时文件替换老的aof文件，并重命名，后面收到的写命令也开始往新的aof文件中追加。</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/imgimage-20200623214843123.png" alt="流程"></p><hr><h3 id="9-4-持久化总结"><a href="#9-4-持久化总结" class="headerlink" title="9.4 持久化总结"></a>9.4 持久化总结</h3><p>两种持久化方案既<code>可以同时使用(aof),又可以单独使用</code>,在某种情况下也可以都不使用,具体使用那种持久化方案取决于用户的数据和应用决定。</p><p>无论使用AOF还是快照机制持久化,将数据持久化到硬盘都是有必要的,除了持久化外,用户还应该对持久化的文件进行备份(最好备份在多个不同地方)。</p><hr><h2 id="10-java操作Redis"><a href="#10-java操作Redis" class="headerlink" title="10. java操作Redis"></a>10. java操作Redis</h2><h3 id="10-1-环境准备"><a href="#10-1-环境准备" class="headerlink" title="10.1 环境准备"></a>10.1 环境准备</h3><h4 id="1-引入依赖"><a href="#1-引入依赖" class="headerlink" title="1. 引入依赖"></a>1. 引入依赖</h4><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--引入jedis连接依赖--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>redis.clients<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jedis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><h4 id="2-创建jedis对象"><a href="#2-创建jedis对象" class="headerlink" title="2.创建jedis对象"></a>2.创建jedis对象</h4><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;  <span class="hljs-comment">//1.创建jedis对象</span>  Jedis jedis = <span class="hljs-keyword">new</span> Jedis(<span class="hljs-string">&quot;192.168.40.4&quot;</span>, <span class="hljs-number">6379</span>);<span class="hljs-comment">//1.redis服务必须关闭防火墙  2.redis服务必须开启远程连接</span>  jedis.select(<span class="hljs-number">0</span>);<span class="hljs-comment">//选择操作的库默认0号库</span>  <span class="hljs-comment">//2.执行相关操作</span>  <span class="hljs-comment">//....</span>  <span class="hljs-comment">//3.释放资源</span>  jedis.close();&#125;</code></pre><h3 id="10-2-操作key相关API"><a href="#10-2-操作key相关API" class="headerlink" title="10.2 操作key相关API"></a>10.2 操作key相关API</h3><pre><code class="hljs java"><span class="hljs-keyword">private</span> Jedis jedis;    <span class="hljs-meta">@Before</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">this</span>.jedis = <span class="hljs-keyword">new</span> Jedis(<span class="hljs-string">&quot;192.168.202.205&quot;</span>, <span class="hljs-number">7000</span>);    &#125;    <span class="hljs-meta">@After</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">after</span><span class="hljs-params">()</span></span>&#123;        jedis.close();    &#125;    <span class="hljs-comment">//测试key相关</span>    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testKeys</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-comment">//删除一个key</span>        jedis.del(<span class="hljs-string">&quot;name&quot;</span>);        <span class="hljs-comment">//删除多个key</span>        jedis.del(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;age&quot;</span>);        <span class="hljs-comment">//判断一个key是否存在exits</span>        Boolean name = jedis.exists(<span class="hljs-string">&quot;name&quot;</span>);        System.out.println(name);        <span class="hljs-comment">//设置一个key超时时间 expire pexpire</span>        Long age = jedis.expire(<span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-number">100</span>);        System.out.println(age);        <span class="hljs-comment">//获取一个key超时时间 ttl</span>        Long age1 = jedis.ttl(<span class="hljs-string">&quot;newage&quot;</span>);        System.out.println(age1);        <span class="hljs-comment">//随机获取一个key</span>        String s = jedis.randomKey();        <span class="hljs-comment">//修改key名称</span>        jedis.rename(<span class="hljs-string">&quot;age&quot;</span>,<span class="hljs-string">&quot;newage&quot;</span>);        <span class="hljs-comment">//查看可以对应值的类型</span>        String name1 = jedis.type(<span class="hljs-string">&quot;name&quot;</span>);        System.out.println(name1);        String maps = jedis.type(<span class="hljs-string">&quot;maps&quot;</span>);        System.out.println(maps);    &#125;</code></pre><h3 id="10-3操作String相关API"><a href="#10-3操作String相关API" class="headerlink" title="10.3操作String相关API"></a>10.3操作String相关API</h3><pre><code class="hljs java"><span class="hljs-comment">//测试String相关</span>    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testString</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-comment">//set</span>        jedis.set(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;小陈&quot;</span>);        <span class="hljs-comment">//get</span>        String s = jedis.get(<span class="hljs-string">&quot;name&quot;</span>);        System.out.println(s);        <span class="hljs-comment">//mset</span>        jedis.mset(<span class="hljs-string">&quot;content&quot;</span>,<span class="hljs-string">&quot;好人&quot;</span>,<span class="hljs-string">&quot;address&quot;</span>,<span class="hljs-string">&quot;海淀区&quot;</span>);        <span class="hljs-comment">//mget</span>        List&lt;String&gt; mget = jedis.mget(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;content&quot;</span>, <span class="hljs-string">&quot;address&quot;</span>);        mget.forEach(v-&gt; System.out.println(<span class="hljs-string">&quot;v = &quot;</span> + v));        <span class="hljs-comment">//getset</span>        String set = jedis.getSet(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;小明&quot;</span>);        System.out.println(set);        <span class="hljs-comment">//............</span>    &#125;</code></pre><h3 id="10-4操作List相关API"><a href="#10-4操作List相关API" class="headerlink" title="10.4操作List相关API"></a>10.4操作List相关API</h3><pre><code class="hljs java"><span class="hljs-comment">//测试List相关</span>    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testList</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-comment">//lpush</span>        jedis.lpush(<span class="hljs-string">&quot;names1&quot;</span>,<span class="hljs-string">&quot;张三&quot;</span>,<span class="hljs-string">&quot;王五&quot;</span>,<span class="hljs-string">&quot;赵柳&quot;</span>,<span class="hljs-string">&quot;win7&quot;</span>);        <span class="hljs-comment">//rpush</span>        jedis.rpush(<span class="hljs-string">&quot;names1&quot;</span>,<span class="hljs-string">&quot;xiaomingming&quot;</span>);        <span class="hljs-comment">//lrange</span>        List&lt;String&gt; names1 = jedis.lrange(<span class="hljs-string">&quot;names1&quot;</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>);        names1.forEach(name-&gt; System.out.println(<span class="hljs-string">&quot;name = &quot;</span> + name));        <span class="hljs-comment">//lpop rpop</span>        String names11 = jedis.lpop(<span class="hljs-string">&quot;names1&quot;</span>);        System.out.println(names11);        <span class="hljs-comment">//llen</span>        jedis.linsert(<span class="hljs-string">&quot;lists&quot;</span>, BinaryClient.LIST_POSITION.BEFORE,<span class="hljs-string">&quot;xiaohei&quot;</span>,<span class="hljs-string">&quot;xiaobai&quot;</span>);      <span class="hljs-comment">//........</span>    &#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210517120930.png"></p><h3 id="10-5操作Set的相关API"><a href="#10-5操作Set的相关API" class="headerlink" title="10.5操作Set的相关API"></a>10.5操作Set的相关API</h3><pre><code class="hljs java"><span class="hljs-comment">//测试SET相关</span><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSet</span><span class="hljs-params">()</span></span>&#123;  <span class="hljs-comment">//sadd</span>  jedis.sadd(<span class="hljs-string">&quot;names&quot;</span>,<span class="hljs-string">&quot;zhangsan&quot;</span>,<span class="hljs-string">&quot;lisi&quot;</span>);  <span class="hljs-comment">//smembers</span>  jedis.smembers(<span class="hljs-string">&quot;names&quot;</span>);  <span class="hljs-comment">//sismember</span>  jedis.sismember(<span class="hljs-string">&quot;names&quot;</span>,<span class="hljs-string">&quot;xiaochen&quot;</span>);  <span class="hljs-comment">//...</span>&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210517120946.png"></p><h3 id="10-6-操作ZSet相关API"><a href="#10-6-操作ZSet相关API" class="headerlink" title="10.6 操作ZSet相关API"></a>10.6 操作ZSet相关API</h3><pre><code class="hljs java"><span class="hljs-comment">//测试ZSET相关</span><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testZset</span><span class="hljs-params">()</span></span>&#123;  <span class="hljs-comment">//zadd</span>  jedis.zadd(<span class="hljs-string">&quot;names&quot;</span>,<span class="hljs-number">10</span>,<span class="hljs-string">&quot;张三&quot;</span>);  <span class="hljs-comment">//zrange</span>  jedis.zrange(<span class="hljs-string">&quot;names&quot;</span>,<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>);  <span class="hljs-comment">//zcard</span>  jedis.zcard(<span class="hljs-string">&quot;names&quot;</span>);  <span class="hljs-comment">//zrangeByScore</span>  jedis.zrangeByScore(<span class="hljs-string">&quot;names&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;100&quot;</span>,<span class="hljs-number">0</span>,<span class="hljs-number">5</span>);  <span class="hljs-comment">//..</span>&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210517121001.png"></p><h3 id="10-7-操作Hash相关API"><a href="#10-7-操作Hash相关API" class="headerlink" title="10.7 操作Hash相关API"></a>10.7 操作Hash相关API</h3><pre><code class="hljs java"><span class="hljs-comment">//测试HASH相关</span><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testHash</span><span class="hljs-params">()</span></span>&#123;  <span class="hljs-comment">//hset</span>  jedis.hset(<span class="hljs-string">&quot;maps&quot;</span>,<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;zhangsan&quot;</span>);  <span class="hljs-comment">//hget</span>  jedis.hget(<span class="hljs-string">&quot;maps&quot;</span>,<span class="hljs-string">&quot;name&quot;</span>);  <span class="hljs-comment">//hgetall</span>  jedis.hgetAll(<span class="hljs-string">&quot;mps&quot;</span>);  <span class="hljs-comment">//hkeys</span>  jedis.hkeys(<span class="hljs-string">&quot;maps&quot;</span>);  <span class="hljs-comment">//hvals</span>  jedis.hvals(<span class="hljs-string">&quot;maps&quot;</span>);  <span class="hljs-comment">//....</span>&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210517121014.png"></p><hr><h2 id="11-SpringBoot整合Redis"><a href="#11-SpringBoot整合Redis" class="headerlink" title="11.SpringBoot整合Redis"></a>11.SpringBoot整合Redis</h2><p>Spring Boot Data(数据) Redis 中提供了 <strong>RedisTemplate和StringRedisTemplate</strong> ，其中StringRedisTemplate是RedisTemplate的子类，两个方法基本一致，不同之处主要体现在操作的数据类型不同， <strong>RedisTemplate中的两个泛型都是Object，意味着存储的key和value都可以是一个对象，而StringRedisTemplate的两个泛型都是String，意味着StringRedisTemplate的key和value都只能是字符串。</strong> </p><p>RedisTemplate(obj, obj) 自动序列化、反序列化</p><p><code>注意: 使用RedisTemplate默认是将对象序列化到Redis中,所以放入的对象必须实现对象序列化接口</code></p><h3 id="11-1-环境准备"><a href="#11-1-环境准备" class="headerlink" title="11.1 环境准备"></a>11.1 环境准备</h3><h4 id="1-引入依赖-1"><a href="#1-引入依赖-1" class="headerlink" title="1.引入依赖"></a>1.引入依赖</h4><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><h4 id="2-配置application-propertie"><a href="#2-配置application-propertie" class="headerlink" title="2.配置application.propertie"></a>2.配置application.propertie</h4><pre><code class="hljs properties"><span class="hljs-meta">spring.redis.host</span>=<span class="hljs-string">localhost</span><span class="hljs-meta">spring.redis.port</span>=<span class="hljs-string">6379</span><span class="hljs-meta">spring.redis.database</span>=<span class="hljs-string">0</span></code></pre><h3 id="11-2-使用StringRedisTemplate和RedisTemplate"><a href="#11-2-使用StringRedisTemplate和RedisTemplate" class="headerlink" title="11.2 使用StringRedisTemplate和RedisTemplate"></a>11.2 使用StringRedisTemplate和RedisTemplate</h3><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> StringRedisTemplate stringRedisTemplate;  <span class="hljs-comment">//对字符串支持比较友好,不能存储对象</span>    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> RedisTemplate redisTemplate;  <span class="hljs-comment">//存储对象</span>    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testRedisTemplate</span><span class="hljs-params">()</span></span>&#123;        System.out.println(redisTemplate);        <span class="hljs-comment">//设置redistemplate值使用对象序列化策略</span>        redisTemplate.setValueSerializer(<span class="hljs-keyword">new</span> JdkSerializationRedisSerializer());<span class="hljs-comment">//指定值使用对象序列化</span>        <span class="hljs-comment">//redisTemplate.opsForValue().set(&quot;user&quot;,new User(&quot;21&quot;,&quot;小黑&quot;,23,new Date()));</span>        User user = (User) redisTemplate.opsForValue().get(<span class="hljs-string">&quot;user&quot;</span>);        System.out.println(user);<span class="hljs-comment">//      Set keys = redisTemplate.keys(&quot;*&quot;);</span><span class="hljs-comment">//      keys.forEach(key -&gt; System.out.println(key));</span>        <span class="hljs-comment">/*Object name = redisTemplate.opsForValue().get(&quot;name&quot;);</span><span class="hljs-comment">        System.out.println(name);*/</span>        <span class="hljs-comment">//Object xiaohei = redisTemplate.opsForValue().get(&quot;xiaohei&quot;);</span>        <span class="hljs-comment">//System.out.println(xiaohei);</span>        <span class="hljs-comment">/*redisTemplate.opsForValue().set(&quot;name&quot;,&quot;xxxx&quot;);</span><span class="hljs-comment">        Object name = redisTemplate.opsForValue().get(&quot;name&quot;);</span><span class="hljs-comment">        System.out.println(name);*/</span>        <span class="hljs-comment">/*redisTemplate.opsForList().leftPushAll(&quot;lists&quot;,&quot;xxxx&quot;,&quot;1111&quot;);</span><span class="hljs-comment">        List lists = redisTemplate.opsForList().range(&quot;lists&quot;, 0, -1);</span><span class="hljs-comment">        lists.forEach(list-&gt; System.out.println(list));*/</span>    &#125;    <span class="hljs-comment">//key的绑定操作 如果日后对某一个key的操作及其频繁,可以将这个key绑定到对应redistemplate中,日后基于绑定操作都是操作这个key</span>    <span class="hljs-comment">//boundValueOps 用来对String值绑定key</span>    <span class="hljs-comment">//boundListOps 用来对List值绑定key</span>    <span class="hljs-comment">//boundSetOps 用来对Set值绑定key</span>    <span class="hljs-comment">//boundZsetOps 用来对Zset值绑定key</span>    <span class="hljs-comment">//boundHashOps 用来对Hash值绑定key</span>    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testBoundKey</span><span class="hljs-params">()</span></span>&#123;        BoundValueOperations&lt;String, String&gt; nameValueOperations = stringRedisTemplate.boundValueOps(<span class="hljs-string">&quot;name&quot;</span>);        nameValueOperations.set(<span class="hljs-string">&quot;1&quot;</span>);        <span class="hljs-comment">//yuew</span>        nameValueOperations.set(<span class="hljs-string">&quot;2&quot;</span>);        String s = nameValueOperations.get();        System.out.println(s);    &#125;    <span class="hljs-comment">//hash相关操作 opsForHash</span>    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testHash</span><span class="hljs-params">()</span></span>&#123;        stringRedisTemplate.opsForHash().put(<span class="hljs-string">&quot;maps&quot;</span>,<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;小黑&quot;</span>);        Object o = stringRedisTemplate.opsForHash().get(<span class="hljs-string">&quot;maps&quot;</span>, <span class="hljs-string">&quot;name&quot;</span>);        System.out.println(o);    &#125;    <span class="hljs-comment">//zset相关操作 opsForZSet</span>    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testZSet</span><span class="hljs-params">()</span></span>&#123;        stringRedisTemplate.opsForZSet().add(<span class="hljs-string">&quot;zsets&quot;</span>,<span class="hljs-string">&quot;小黑&quot;</span>,<span class="hljs-number">10</span>);        Set&lt;String&gt; zsets = stringRedisTemplate.opsForZSet().range(<span class="hljs-string">&quot;zsets&quot;</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>);        zsets.forEach(value-&gt; System.out.println(value));    &#125;    <span class="hljs-comment">//set相关操作 opsForSet</span>    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSet</span><span class="hljs-params">()</span></span>&#123;        stringRedisTemplate.opsForSet().add(<span class="hljs-string">&quot;sets&quot;</span>,<span class="hljs-string">&quot;xiaosan&quot;</span>,<span class="hljs-string">&quot;xiaosi&quot;</span>,<span class="hljs-string">&quot;xiaowu&quot;</span>);        Set&lt;String&gt; sets = stringRedisTemplate.opsForSet().members(<span class="hljs-string">&quot;sets&quot;</span>);        sets.forEach(value-&gt; System.out.println(value));    &#125;    <span class="hljs-comment">//list相关的操作opsForList</span>    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testList</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-comment">// stringRedisTemplate.opsForList().leftPushAll(&quot;lists&quot;,&quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot;);</span>        List&lt;String&gt; lists = stringRedisTemplate.opsForList().range(<span class="hljs-string">&quot;lists&quot;</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>);        lists.forEach(key -&gt; System.out.println(key));    &#125;    <span class="hljs-comment">//String相关的操作 opsForValue</span>    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testString</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-comment">//stringRedisTemplate.opsForValue().set(&quot;166&quot;,&quot;好同学&quot;);</span>        String s = stringRedisTemplate.opsForValue().get(<span class="hljs-string">&quot;166&quot;</span>);        System.out.println(s);        Long size = stringRedisTemplate.opsForValue().size(<span class="hljs-string">&quot;166&quot;</span>);        System.out.println(size);    &#125;    <span class="hljs-comment">//key相关的操作</span>    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;        Set&lt;String&gt; keys = stringRedisTemplate.keys(<span class="hljs-string">&quot;*&quot;</span>);<span class="hljs-comment">//查看所有key</span>        Boolean name = stringRedisTemplate.hasKey(<span class="hljs-string">&quot;name&quot;</span>);<span class="hljs-comment">//判断某个key是否存在</span>        stringRedisTemplate.delete(<span class="hljs-string">&quot;age&quot;</span>);<span class="hljs-comment">//根据指定key删除</span>        stringRedisTemplate.rename(<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>);<span class="hljs-comment">//修改key的名称</span>        stringRedisTemplate.expire(<span class="hljs-string">&quot;key&quot;</span>,<span class="hljs-number">10</span>, TimeUnit.HOURS);      <span class="hljs-comment">//设置key超时时间 参数1:设置key名 参数2:时间 参数3:时间的单位</span>        stringRedisTemplate.move(<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-number">1</span>);<span class="hljs-comment">//移动key</span>    &#125;</code></pre><hr><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 1.针对于日后处理key value 都是 String 使用 StringRedisTemplate</span><span class="hljs-comment"> * 2.针对于日后处理的key value 存在对象 使用 RedisTemplate</span><span class="hljs-comment"> * 3.针对于同一个key多次操作可以使用boundXXxOps() Value List Set Zset Hash的api 简化书写</span><span class="hljs-comment"> */</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * redis应用场景</span><span class="hljs-comment"> *</span><span class="hljs-comment"> *  1.利用redis 中字符串类型完成 项目中手机验证码存储的实现</span><span class="hljs-comment"> *  2.利用redis 中字符串类型完成 具有失效性业务功能  12306  淘宝  订单还有:40分钟</span><span class="hljs-comment"> *  3.利用redis 分布式集群系统中 Session共享  memcache 内存 数据存储上限 数据类型比较简单  redis 内存  数据上限  数据类型丰富</span><span class="hljs-comment"> *  4.利用redis zset类型 可排序set类型  元素 分数  排行榜之类功能   dangdang 销量排行  sales(zset) [商品id,商品销量] ......</span><span class="hljs-comment"> *  5.利用redis 分布式缓存  实现</span><span class="hljs-comment"> *  6.利用redis 存储认证之后token信息   微信小程序 微信公众号 |用户 openid   ---&gt; 令牌(token) redis 超时</span><span class="hljs-comment"> *  7.利用redis 解决分布式集群系统中分布式锁问题       redis 单进程 单线程   n 20 定义</span><span class="hljs-comment"> *      jvm  1进程开启多个线程 synchronize int n=20</span><span class="hljs-comment"> *      jvm  1进程开启多个线程 synchronize int n=20</span><span class="hljs-comment"> *      .....  LUA脚本</span><span class="hljs-comment"> *</span><span class="hljs-comment"> */</span></code></pre><h3 id="11-3-分布式缓存"><a href="#11-3-分布式缓存" class="headerlink" title="11.3 分布式缓存"></a>11.3 分布式缓存</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210517164528.png"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210517164613.png"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210517164854.png"></p><h3 id="11-4-测试mybatis缓存"><a href="#11-4-测试mybatis缓存" class="headerlink" title="11.4 测试mybatis缓存"></a>11.4 测试mybatis缓存</h3><ul><li>pom.xml</li></ul><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--mybatis--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!--mysql--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.38<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!--druid--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.19<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>User实例、DAO、Mapper、Service、ServiceImp省略，具体就是查询</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210518075614.png"></p><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testFindAll</span><span class="hljs-params">()</span></span>&#123;    userService.findAll().forEach(u-&gt; System.out.println(<span class="hljs-string">&quot;u = &quot;</span> + u));    System.out.println(<span class="hljs-string">&quot;==================================&quot;</span>);    userService.findAll().forEach(u-&gt; System.out.println(<span class="hljs-string">&quot;u = &quot;</span> + u));&#125;</code></pre><p>执行了两次sql</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210518075711.png"></p><p>如果在mapper中开启&lt; cache/ &gt;</p><pre><code class="hljs XML">  <span class="hljs-comment">&lt;!--开启mybatis二级缓存 要求对象实现序列化--&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">cache</span>/&gt;</span><span class="hljs-comment">&lt;!-- 宕机后还是要再次查询一次数据库 --&gt;</span></code></pre><p>结果走缓存</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210518075909.png"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210518080246.png"></p><p>可知本地缓存，宕机、重启等都要查询一次DB</p><p>mybatis默认：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PerpetualCache</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cache</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String id;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;Object, Object&gt; cache = <span class="hljs-keyword">new</span> HashMap();  <span class="hljs-comment">//....</span>&#125;</code></pre><h3 id="11-5-实现RedisCache"><a href="#11-5-实现RedisCache" class="headerlink" title="11.5 实现RedisCache"></a>11.5 实现RedisCache</h3><pre><code class="hljs java"><span class="hljs-comment">//自定义Redis缓存实现</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisCache</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cache</span> </span>&#123;<span class="hljs-comment">// ....</span>&#125;</code></pre><pre><code class="hljs java"><span class="hljs-comment">//当前放入缓存的mapper的namespace</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String id;<span class="hljs-comment">//必须存在构造方法</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RedisCache</span><span class="hljs-params">(String id)</span> </span>&#123;    System.out.println(<span class="hljs-string">&quot;id:=====================&gt; &quot;</span> + id);    <span class="hljs-comment">// id:=====================&gt; com.baizhi.dao.UserDAO</span>  <span class="hljs-comment">// mapper的namespace</span>    <span class="hljs-keyword">this</span>.id = id;&#125;<span class="hljs-comment">//返回cache唯一标识</span><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.id;&#125;</code></pre><p>编写工厂类：</p><pre><code class="hljs java"><span class="hljs-comment">//用来获取springboot创建好的工厂</span><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApplicationContextUtils</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ApplicationContextAware</span> </span>&#123;    <span class="hljs-comment">//保留下来工厂</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ApplicationContext applicationContext;    <span class="hljs-comment">//将创建好工厂以参数形式传递给这个类</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setApplicationContext</span><span class="hljs-params">(ApplicationContext applicationContext)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;        <span class="hljs-keyword">this</span>.applicationContext = applicationContext;    &#125;    <span class="hljs-comment">//提供在工厂中获取对象的方法 //RedisTemplate  redisTemplate</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title">getBean</span><span class="hljs-params">(String beanName)</span></span>&#123;        <span class="hljs-keyword">return</span> applicationContext.getBean(beanName);    &#125;&#125;</code></pre><p>redisCahce添加获取RedisTemplate方法</p><pre><code class="hljs java"><span class="hljs-comment">//封装redisTemplate</span><span class="hljs-function"><span class="hljs-keyword">private</span> RedisTemplate <span class="hljs-title">getRedisTemplate</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-comment">//通过application工具类获取redisTemplate</span>    RedisTemplate redisTemplate = (RedisTemplate) ApplicationContextUtils.getBean(<span class="hljs-string">&quot;redisTemplate&quot;</span>);    redisTemplate.setKeySerializer(<span class="hljs-keyword">new</span> StringRedisSerializer());    redisTemplate.setHashKeySerializer(<span class="hljs-keyword">new</span> StringRedisSerializer());    <span class="hljs-keyword">return</span> redisTemplate;&#125;<span class="hljs-comment">//缓存放入值  redis RedisTemplate   StringRedisTemplate</span><span class="hljs-comment">// RedisCache不是由工厂管理，不能直接注入，需要从工厂启动中去拿</span></code></pre><p>总体：</p><pre><code class="hljs java"><span class="hljs-comment">//自定义Redis缓存实现</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisCache</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cache</span> </span>&#123;    <span class="hljs-comment">//当前放入缓存的mapper的namespace</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String id;    <span class="hljs-comment">//必须存在构造方法</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RedisCache</span><span class="hljs-params">(String id)</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;id:=====================&gt; &quot;</span> + id);        <span class="hljs-keyword">this</span>.id = id;    &#125;    <span class="hljs-comment">//返回cache唯一标识</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.id;    &#125;    <span class="hljs-comment">//缓存放入值  redis RedisTemplate   StringRedisTemplate</span>    <span class="hljs-comment">// RedisCache不是由工厂管理，不能直接注入，需要从工厂启动中去拿</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">putObject</span><span class="hljs-params">(Object key, Object value)</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;key:&quot;</span> + key.toString());        System.out.println(<span class="hljs-string">&quot;value:&quot;</span> + value);        <span class="hljs-comment">//key:-1904699567:2928014428:com.baizhi.dao.UserDAO.findAll:0:2147483647:select id,name,age,bir from t_user:SqlSessionFactoryBean</span>        <span class="hljs-comment">//value:[User(id=1, name=qiushi, age=100, bir=Thu Sep 30 00:00:00 CST 1999), User(id=2, name=xiaoshi, age=99, bir=Thu Sep 30 00:00:00 CST 1999)]</span><span class="hljs-comment">//        //通过application工具类获取redisTemplate</span><span class="hljs-comment">//        RedisTemplate redisTemplate = (RedisTemplate) ApplicationContextUtils.getBean(&quot;redisTemplate&quot;);</span><span class="hljs-comment">//        redisTemplate.setKeySerializer(new StringRedisSerializer());</span><span class="hljs-comment">//        redisTemplate.setHashKeySerializer(new StringRedisSerializer());</span>        <span class="hljs-comment">//使用redishash类型作为缓存存储模型  key   hashkey  value</span>        getRedisTemplate().opsForHash().put(id.toString(),getKeyToMD5(key.toString()),value);        <span class="hljs-keyword">if</span>(id.equals(<span class="hljs-string">&quot;com.baizhi.dao.UserDAO&quot;</span>))&#123;            <span class="hljs-comment">//缓存超时  client  用户   client  员工</span>            getRedisTemplate().expire(id.toString(),<span class="hljs-number">1</span>, TimeUnit.HOURS);        &#125;        <span class="hljs-keyword">if</span>(id.equals(<span class="hljs-string">&quot;com.baizhi.dao.CityDAO&quot;</span>))&#123;            <span class="hljs-comment">//缓存超时  client  用户   client  员工</span>            getRedisTemplate().expire(id.toString(),<span class="hljs-number">30</span>, TimeUnit.MINUTES);        &#125;        <span class="hljs-comment">//.....指定不同业务模块设置不同缓存超时时间</span>    &#125;    <span class="hljs-comment">//获取中获取数据</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getObject</span><span class="hljs-params">(Object key)</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;key:&quot;</span> + key.toString());<span class="hljs-comment">//        //通过application工具类获取redisTemplate</span><span class="hljs-comment">//        RedisTemplate redisTemplate = (RedisTemplate) ApplicationContextUtils.getBean(&quot;redisTemplate&quot;);</span><span class="hljs-comment">//        redisTemplate.setKeySerializer(new StringRedisSerializer());</span><span class="hljs-comment">//        redisTemplate.setHashKeySerializer(new StringRedisSerializer());</span>        <span class="hljs-comment">//根据key 从redis的hash类型中获取数据</span>        <span class="hljs-keyword">return</span> getRedisTemplate().opsForHash().get(id.toString(), getKeyToMD5(key.toString()));    &#125;    <span class="hljs-comment">//注意:这个方法为mybatis保留方法 默认没有实现 后续版本可能会实现</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">removeObject</span><span class="hljs-params">(Object key)</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;根据指定key删除缓存&quot;</span>);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;  <span class="hljs-comment">// 删除默认走clear()</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;清空缓存~~~&quot;</span>);        <span class="hljs-comment">//清空namespace</span>        getRedisTemplate().delete(id.toString());<span class="hljs-comment">//清空缓存</span>    &#125;    <span class="hljs-comment">//用来计算缓存数量</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getSize</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//获取hash中key value数量</span>        <span class="hljs-keyword">return</span> getRedisTemplate().opsForHash().size(id.toString()).intValue();    &#125;    <span class="hljs-comment">//封装redisTemplate</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> RedisTemplate <span class="hljs-title">getRedisTemplate</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-comment">//通过application工具类获取redisTemplate</span>        RedisTemplate redisTemplate = (RedisTemplate) ApplicationContextUtils.getBean(<span class="hljs-string">&quot;redisTemplate&quot;</span>);        redisTemplate.setKeySerializer(<span class="hljs-keyword">new</span> StringRedisSerializer());        redisTemplate.setHashKeySerializer(<span class="hljs-keyword">new</span> StringRedisSerializer());        <span class="hljs-keyword">return</span> redisTemplate;    &#125;    <span class="hljs-comment">//封装一个对key进行md5处理方法</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">getKeyToMD5</span><span class="hljs-params">(String key)</span></span>&#123;        <span class="hljs-keyword">return</span> DigestUtils.md5DigestAsHex(key.getBytes());    &#125;&#125;</code></pre><h3 id="11-6-关联关系"><a href="#11-6-关联关系" class="headerlink" title="11.6 关联关系"></a>11.6 关联关系</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210518085202.png"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210518085334.png"></p><pre><code class="hljs xml">    # EmpDaoMapper中<span class="hljs-comment">&lt;!--关联关系缓存处理--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">cache-ref</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.baizhi.dao.UserDAO&quot;</span>/&gt;</span></code></pre><h3 id="11-7-优化策略"><a href="#11-7-优化策略" class="headerlink" title="11.7 优化策略"></a>11.7 优化策略</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img6.redis%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98(%E4%B8%89).png"></p><pre><code class="hljs java"><span class="hljs-comment">//封装一个对key进行md5处理方法</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">getKeyToMD5</span><span class="hljs-params">(String key)</span></span>&#123;      <span class="hljs-comment">// Spring框架自带的md5加密工具类</span>        <span class="hljs-keyword">return</span> DigestUtils.md5DigestAsHex(key.getBytes());    &#125;</code></pre><p>缓存击穿：大规模的无用数据记录，查询不到；（mybatis给DB查不到的结果也进行缓存，给key存null）</p><p>缓存雪崩：缓存宕机（到达超时时间），大规模请求DB导致DB阻塞、挂起；不同业务设置不同时间</p><pre><code class="hljs java"><span class="hljs-keyword">if</span>(id.equals(<span class="hljs-string">&quot;com.baizhi.dao.UserDAO&quot;</span>))&#123;    <span class="hljs-comment">//缓存超时  client  用户   client  员工</span>    getRedisTemplate().expire(id.toString(),<span class="hljs-number">1</span>, TimeUnit.HOURS);&#125;<span class="hljs-keyword">if</span>(id.equals(<span class="hljs-string">&quot;com.baizhi.dao.CityDAO&quot;</span>))&#123;    <span class="hljs-comment">//缓存超时  client  用户   client  员工</span>    getRedisTemplate().expire(id.toString(),<span class="hljs-number">30</span>, TimeUnit.MINUTES);&#125;<span class="hljs-comment">//.....指定不同业务模块设置不同缓存超时时间</span></code></pre><h2 id="12-Redis-主从复制"><a href="#12-Redis-主从复制" class="headerlink" title="12. Redis 主从复制"></a>12. Redis 主从复制</h2><h3 id="12-1-主从复制"><a href="#12-1-主从复制" class="headerlink" title="12.1 主从复制"></a>12.1 主从复制</h3><p>主从复制架构仅仅用来解决数据的冗余备份,从节点 <code>仅仅用来同步数据</code>，不对外提供服务</p><p> <strong>无法解决: 1.master节点出现故障的自动故障转移</strong> ，即从结点<code>不会在主结点故障的时候顶替服务 </code></p><h3 id="12-2-主从复制架构图"><a href="#12-2-主从复制架构图" class="headerlink" title="12.2 主从复制架构图"></a>12.2 主从复制架构图</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/imgimage-20200627201722700.png"></p><h3 id="12-3-搭建主从复制"><a href="#12-3-搭建主从复制" class="headerlink" title="12.3 搭建主从复制"></a>12.3 搭建主从复制</h3><pre><code class="hljs markdown"><span class="hljs-section"># 1.准备3台机器并修改配置</span><span class="hljs-bullet">-</span> master<span class="hljs-code">port 6379</span><span class="hljs-code">bind 0.0.0.0</span><span class="hljs-code"></span><span class="hljs-code">- slave1</span><span class="hljs-code">port 7000</span><span class="hljs-code">bind 0.0.0.0</span><span class="hljs-code">slaveof masterip masterport</span><span class="hljs-code"></span><span class="hljs-code">- slave2</span><span class="hljs-code">port 7001</span><span class="hljs-code">bind 0.0.0.0</span><span class="hljs-code">slaveof masterip masterport</span></code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/imgimage-20200627202443388.png"></p><p>现版本：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210518104106.png"></p><p>设置完后：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210518104150.png"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210518104234.png"></p><pre><code class="hljs markdown"><span class="hljs-section"># 2.启动3台机器进行测试</span><span class="hljs-bullet">-</span> cd /usr/redis/bin<span class="hljs-bullet">-</span> ./redis-server /root/master/redis.conf<span class="hljs-bullet">-</span> ./redis-server /root/slave1/redis.conf<span class="hljs-bullet">-</span> ./redis-server /root/slave2/redis.conf</code></pre><hr><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210518105037.png"></p><p>表示数据同步成功</p><p>测试：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210518105100.png"></p><p>从结点不能写数据，只读</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210519075143.png"></p><p>master结点宕机，不会有从结点顶上来充当主结点；</p><h2 id="13-Redis哨兵机制"><a href="#13-Redis哨兵机制" class="headerlink" title="13. Redis哨兵机制"></a>13. Redis哨兵机制</h2><h3 id="13-1-哨兵Sentinel机制"><a href="#13-1-哨兵Sentinel机制" class="headerlink" title="13.1 哨兵Sentinel机制"></a>13.1 哨兵Sentinel机制</h3><p>Sentinel（哨兵）是Redis 的高可用性解决方案：由一个或多个Sentinel 实例 组成的Sentinel 系统可以监视任意多个主服务器，以及这些主服务器属下的所有从服务器，<code>并在被监视的主服务器进入下线状态时，自动将下线主服务器属下的某个从服务器升级为新的主服务器</code>。简单的说哨兵就是带有 <strong>自动故障转移功能的主从架构</strong> 。</p><p> <strong>无法解决: 1.单节点并发压力问题   2.单节点内存和磁盘物理上限</strong> ，始终都是一个结点提供服务。</p><h3 id="13-2-哨兵架构原理"><a href="#13-2-哨兵架构原理" class="headerlink" title="13.2 哨兵架构原理"></a>13.2 哨兵架构原理</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/imgimage-20200627204422750.png" alt="哨兵"></p><p>定时发送数据包并回复响应。原master恢复会充当新master的从结点。</p><h3 id="13-3-搭建哨兵架构"><a href="#13-3-搭建哨兵架构" class="headerlink" title="13.3 搭建哨兵架构"></a>13.3 搭建哨兵架构</h3><pre><code class="hljs markdown"><span class="hljs-section"># 1.在主节点上创建哨兵配置</span><span class="hljs-bullet">-</span> 在Master对应redis.conf同目录下新建sentinel.conf文件，名字绝对不能错；<span class="hljs-section"># 2.配置哨兵，在sentinel.conf文件中填入内容：</span><span class="hljs-bullet">-</span> sentinel monitor 被监控数据库名字（自己起名字） ip port 1(哨兵数量，超过半数以上哨兵说明matser宕机，才会产生替代)<span class="hljs-section"># 3.启动哨兵模式进行测试</span><span class="hljs-bullet">-</span> redis-sentinel  /root/sentinel/sentinel.conf<span class="hljs-code">说明:这个后面的数字2,是指当有两个及以上的sentinel服务检测到master宕机，才会去执行主从切换的功能。</span></code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210519081128.png"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210519082044.png"></p><p>Ctrl + c 宕机master：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210519081759.png"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210519081832.png"></p><p>master宕机后：</p><p>哨兵选择了7001作主结点(默认有一个心跳超时)</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210519082222.png"></p><p>上面显示 +switch-master … 7001</p><p>结果：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210519082304.png"></p><p>再次重新启动master：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210519082608.png"></p><p>发现master变成了7001的从结点，尝试用master增加数据：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210519082716.png"></p><h3 id="13-4-通过sprigboot操作哨兵"><a href="#13-4-通过sprigboot操作哨兵" class="headerlink" title="13.4 通过sprigboot操作哨兵"></a>13.4 通过sprigboot操作哨兵</h3><pre><code class="hljs properties"><span class="hljs-comment"># redis sentinel 配置</span><span class="hljs-comment"># master书写是使用哨兵监听的那个名称</span><span class="hljs-meta">spring.redis.sentinel.master</span>=<span class="hljs-string">mymaster</span><span class="hljs-comment"># 连接的不再是一个具体redis主机,书写的是多个哨兵节点</span><span class="hljs-meta">spring.redis.sentinel.nodes</span>=<span class="hljs-string">192.168.202.206:26379</span></code></pre><ul><li><strong>注意:如果连接过程中出现如下错误:RedisConnectionException: DENIED Redis is running in protected mode because protected mode is enabled, no bind address was specified, no authentication password is requested to clients. In this mode connections are only accepted from the loopback interface. If you want to connect from external computers to Redis you may adopt one of the following solutions: 1) Just disable protected mode sending the command ‘CONFIG SET protected-mode no’ from the loopback interface by connecting to Redis from the same host the server is running, however MAKE SURE Redis is not publicly accessible from internet if you do so. Use CONFIG REWRITE to make this change permanent. 2)</strong></li><li><strong>解决方案:在哨兵的配置文件中加入bind 0.0.0.0 开启远程连接权限</strong></li></ul><p><img src="Redis.assets/image-20200629154647970.png" alt="image-20200629154647970"></p><p>Properties:</p><pre><code class="hljs xml"># redis 单节点#spring.redis.host=127.0.1#spring.redis.port=6379#spring.redis.database=0# redis sentinel 配置# master书写是使用哨兵监听的那个名称spring.redis.sentinel.master=mymaster# 连接的不再是一个具体redis主机,书写的是多个哨兵节点spring.redis.sentinel.nodes=127.0.0.1:26379# redis cluster 操作 书写集群中所有节点spring.redis.cluster.nodes=127.0.0.1:7000,127.0.0.1:7001</code></pre><p>测试结果：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210519083938.png"></p><p>继续把主结点宕机</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210519084229.png"></p><p>切换到了6379</p><p>再次测试Spring Boot：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210519084311.png"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210519084338.png"></p><h2 id="14-Redis集群"><a href="#14-Redis集群" class="headerlink" title="14. Redis集群"></a>14. Redis集群</h2><h3 id="14-1-集群"><a href="#14-1-集群" class="headerlink" title="14.1 集群"></a>14.1 集群</h3><p>Redis在3.0后开始支持Cluster(模式)模式,目前redis的集群支持<code>节点的自动发现</code>,支持<code>slave-master选举和容错</code>,支持<code>在线分片(sharding shard )等特性</code>。reshard就是重新分配hash槽。</p><h3 id="14-2-集群架构图"><a href="#14-2-集群架构图" class="headerlink" title="14.2 集群架构图"></a>14.2 集群架构图</h3><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/imgwpsgRnQP8.jpg" style="zoom:50%;" /><h3 id="14-3-集群细节"><a href="#14-3-集群细节" class="headerlink" title="14.3 集群细节"></a>14.3 集群细节</h3><pre><code class="hljs markdown"><span class="hljs-bullet">-</span> 所有的redis节点彼此互联( PING-PONG机制 ),内部使用 二进制协议 优化传输速度和带宽.<span class="hljs-bullet">-</span> 节点的fail是通过集群中 超过半数的节点检测失效时 才生效. (所以最好奇数结点)<span class="hljs-bullet">-</span> 客户端与redis节点直连,不需要中间proxy层（tomcat需要nginx，mysql需要mycat）.客户端不需要连接集群所有节点,连接集群中任何一个可用节点即可<span class="hljs-bullet">-</span> redis-cluster把所有的物理节点映射到[0-16383]slot上,cluster 负责维护node&lt;-&gt;slot&lt;-&gt;value</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/imgimage-20200629165226329.png"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210519084742.png"></p><p>set对name crc16计算和get对name crc16计算一致；</p><p>slot一致，只是存入同一个主结点而已；</p><p>集群可用必须是hash槽分配完整；</p><h3 id="14-4-集群搭建"><a href="#14-4-集群搭建" class="headerlink" title="14.4 集群搭建"></a>14.4 集群搭建</h3><p>判断一个是集群中的节点是否可用,是集群中的所用主节点选举过程,如果半数以上的节点认为当前节点挂掉,那么当前节点就是挂掉了,所以搭建redis集群时建议节点数最好为奇数， <strong>搭建集群至少需要三个主节点,三个从节点,至少需要6个节点</strong> 。</p><pre><code class="hljs markdown"><span class="hljs-section"># 1.准备环境安装ruby以及redis集群依赖</span><span class="hljs-bullet">-</span> yum install -y ruby rubygems<span class="hljs-bullet">-</span> gem install redis-xxx.gem</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/imgimage-20200627193251512.png" alt="依赖"></p><p><img src="Redis.assets/image-20200627193348905.png" alt="image-20200627193348905"></p><pre><code class="hljs markdown"><span class="hljs-section"># 2.在一台机器创建7个目录</span></code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/imgimage-20200627193849867.png"></p><pre><code class="hljs markdown"><span class="hljs-section"># 3.每个目录复制一份配置文件</span>[root@localhost ~]# cp redis-4.0.10/redis.conf 7000/[root@localhost ~]# cp redis-4.0.10/redis.conf 7001/[root@localhost ~]# cp redis-4.0.10/redis.conf 7002/[root@localhost ~]# cp redis-4.0.10/redis.conf 7003/[root@localhost ~]# cp redis-4.0.10/redis.conf 7004/[root@localhost ~]# cp redis-4.0.10/redis.conf 7005/[root@localhost ~]# cp redis-4.0.10/redis.conf 7006/</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/imgimage-20200627194004159.png"></p><pre><code class="hljs markdown"><span class="hljs-section"># 4.修改不同目录配置文件</span><span class="hljs-bullet">-</span> port 6379 .....                 //修改端口<span class="hljs-bullet">-</span> bind  0.0.0.0                    //开启远程连接<span class="hljs-bullet">-</span> cluster-enabled  yes          //开启集群模式<span class="hljs-bullet">-</span> cluster-config-file  nodes-port.conf //集群节点配置文件<span class="hljs-bullet">-</span> cluster-node-timeout  5000         //集群节点超时时间<span class="hljs-bullet">-</span> appendonly  yes                  //开启AOF持久化<span class="hljs-bullet">-</span> dbfilename dump-port.rdb // 不同结点产生不同rdb// 建议开启守护进程<span class="hljs-section"># 5.指定不同目录配置文件启动七个节点</span><span class="hljs-bullet">-</span> [root@localhost bin]# ./redis-server  /root/7000/redis.conf<span class="hljs-bullet">-</span> [root@localhost bin]# ./redis-server  /root/7001/redis.conf<span class="hljs-bullet">-</span> [root@localhost bin]# ./redis-server  /root/7002/redis.conf<span class="hljs-bullet">-</span> [root@localhost bin]# ./redis-server  /root/7003/redis.conf<span class="hljs-bullet">-</span> [root@localhost bin]# ./redis-server  /root/7004/redis.conf<span class="hljs-bullet">-</span> [root@localhost bin]# ./redis-server  /root/7005/redis.conf<span class="hljs-bullet">-</span> [root@localhost bin]# ./redis-server  /root/7006/redis.conf</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/imgimage-20200627194913866.png"></p><pre><code class="hljs markdown"><span class="hljs-section"># 6.查看进程</span><span class="hljs-bullet">-</span> [root@localhost bin]# ps aux|grep redis</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/imgimage-20200627194954143.png"></p><h4 id="1-创建集群"><a href="#1-创建集群" class="headerlink" title="1.创建集群"></a>1.创建集群</h4><pre><code class="hljs markdown"><span class="hljs-section"># 1.复制集群操作脚本到bin目录中</span><span class="hljs-bullet">-</span> [root@localhost bin]# cp /root/redis-4.0.10/src/redis-trib.rb .<span class="hljs-section"># 2.创建集群</span><span class="hljs-bullet">-</span> ./redis-trib.rb create --replicas 1(有几个副本结点) 192.168.202.205:7000 192.168.202.205:7001 192.168.202.205:7002 192.168.202.205:7003 192.168.202.205:7004 192.168.202.205:7005</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/imgimage-20200627195601307.png"></p><pre><code class="hljs markdown"><span class="hljs-section"># 3.集群创建成功出现如下提示</span></code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/imgimage-20200627195647767.png"></p><p>连接变成了 <code>redis-cli -p port -c</code> (-c才代表集群)</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210519100539.png"></p><p>在从结点操作会自动重定向</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210519102621.png"></p><h4 id="2-查看集群状态"><a href="#2-查看集群状态" class="headerlink" title="2.查看集群状态"></a>2.查看集群状态</h4><pre><code class="hljs markdown"><span class="hljs-section"># 1.查看集群状态 check [原始集群中任意节点] [无]</span><span class="hljs-bullet">-</span> ./redis-trib.rb check 192.168.202.205:7000<span class="hljs-section"># 2.集群节点状态说明</span><span class="hljs-bullet">-</span> 主节点 <span class="hljs-code">主节点存在hash slots,且主节点的hash slots 没有交叉</span><span class="hljs-code">主节点不能删除</span><span class="hljs-code">一个主节点可以有多个从节点</span><span class="hljs-code">主节点宕机时多个副本之间自动选举主节点</span><span class="hljs-code"></span><span class="hljs-code">- 从节点</span><span class="hljs-code">从节点没有hash slots</span><span class="hljs-code">从节点可以删除</span><span class="hljs-code">从节点不负责数据的写,只负责数据的同步</span></code></pre><h4 id="3-添加主节点"><a href="#3-添加主节点" class="headerlink" title="3.添加主节点"></a>3.添加主节点</h4><pre><code class="hljs markdown"><span class="hljs-section"># 1.添加主节点 add-node [新加入节点] [原始集群中任意节点]</span><span class="hljs-bullet">-</span> ./redis-trib.rb  add-node 192.168.1.158:7006  192.168.1.158:7005<span class="hljs-bullet">-</span> 注意:<span class="hljs-code">1.该节点必须以集群模式启动</span><span class="hljs-code">2.默认情况下该节点就是以master节点形式添加</span></code></pre><h4 id="4-添加从节点"><a href="#4-添加从节点" class="headerlink" title="4.添加从节点"></a>4.添加从节点</h4><pre><code class="hljs markdown"><span class="hljs-section"># 1.添加从节点 add-node --slave [新加入节点] [集群中任意节点]</span><span class="hljs-bullet">-</span> ./redis-trib.rb  add-node --slave 192.168.1.158:7006 192.168.1.158:7000<span class="hljs-bullet">-</span> 注意:<span class="hljs-code">当添加副本节点时没有指定主节点,redis会随机给副本节点较少的主节点添加当前副本节点</span><span class="hljs-code"></span><span class="hljs-code"># 2.为确定的master节点添加主节点 add-node --slave --master-id master节点id [新加入节点] [集群任意节点]</span><span class="hljs-code">- ./redis-trib.rb  add-node --slave --master-id 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 127.0.0.1:7006  127.0.0.1:7000</span></code></pre><h4 id="5-删除副本节点"><a href="#5-删除副本节点" class="headerlink" title="5.删除副本节点"></a>5.删除副本节点</h4><pre><code class="hljs markdown"><span class="hljs-section"># 1.删除节点 del-node [集群中任意节点] [删除节点id]</span><span class="hljs-bullet">-</span> ./redis-trib.rb  del-node 127.0.0.1:7002 0ca3f102ecf0c888fc7a7ce43a13e9be9f6d3dd1<span class="hljs-bullet">-</span> 注意: 1.被删除的节点必须是从节点或没有被分配hash slots的节点</code></pre><h4 id="6-集群在线分片"><a href="#6-集群在线分片" class="headerlink" title="6.集群在线分片"></a>6.集群在线分片</h4><pre><code class="hljs markdown"><span class="hljs-section"># 1.在线分片 reshard [集群中任意节点] [无]</span><span class="hljs-bullet">-</span> ./redis-trib.rb  reshard  192.168.1.158:7000</code></pre><hr><h2 id="15-Redis实现分布式Session管理"><a href="#15-Redis实现分布式Session管理" class="headerlink" title="15.Redis实现分布式Session管理"></a>15.Redis实现分布式Session管理</h2><h3 id="15-1-管理机制"><a href="#15-1-管理机制" class="headerlink" title="15.1 管理机制"></a>15.1 管理机制</h3><p> <strong>redis的session管理是利用spring提供的session管理解决方案,将一个应用session交给Redis存储,整个应用中所有session的请求都会去redis中获取对应的session数据。</strong> </p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/imgimage-20200628201643358.png"></p><p>nginx解决负载均衡；</p><p>如果在tomcat之间进行session共享：</p><ul><li>应用服务器之间才能共享，必须tomcat和tomcat之间才能完成，应用服务器产品之间具有局限性</li><li>有一个应用服务器session数据变化，需要通过网络形式同步给集群中所有的结点，带宽有影响</li><li>session信息多，状态变化快，每一次变化都需要同步，内网性能要求严格</li></ul><p>之前可以用<code>memoryCache</code>（缓存服务器），但tomcat和memoryCache兼容性不佳，延迟大，并且整个过程是某一个服务器创建的session数据创建到当前服务器中，并到缓存服务器备份。下一次找，没找到，到缓存服务器<code>复制到服务器上</code>，操作的还是tomcat上的session，缓存服务器只起到储存作用。<code>基于应用服务器和memCache之间的整合，只要往应用服务器中部署应用，所有的应用session都是交给memCache处理</code>。</p><p>现在可以用redis实现session共享。<code>基于整个应用之间的整合，Spring的应用，把应用中的session使用redis管理</code>。无需修改服务器配置，解耦服务器。</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img7.Redis%E7%9A%84session%E7%AE%A1%E7%90%86%E5%92%8CMemcached%E7%9A%84session%E7%AE%A1%E7%90%86%E4%B8%8D%E5%90%8C.jpg"></p><h3 id="15-2-开发Session管理"><a href="#15-2-开发Session管理" class="headerlink" title="15.2 开发Session管理"></a>15.2 开发Session管理</h3><h4 id="1-引入依赖-2"><a href="#1-引入依赖-2" class="headerlink" title="1. 引入依赖"></a>1. 引入依赖</h4><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.session<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-session-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><h4 id="2-开发Session管理配置类"><a href="#2-开发Session管理配置类" class="headerlink" title="2. 开发Session管理配置类"></a>2. 开发Session管理配置类</h4><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@EnableRedisHttpSession</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisSessionManager</span> </span>&#123;   &#125;</code></pre><h4 id="3-打包测试即可"><a href="#3-打包测试即可" class="headerlink" title="3.打包测试即可"></a>3.打包测试即可</h4><hr><p>Controller:</p><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><span class="hljs-meta">@RequestMapping(&quot;test&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestController</span> </span>&#123;    <span class="hljs-comment">// redis  session   list    1</span>    <span class="hljs-comment">// jvm  list 地址    list.add   list.size  2</span>    <span class="hljs-comment">//使用redis 的session管理  注意:当session中数据发生变化时必须将session中变化的数据同步到redis中</span>    <span class="hljs-meta">@RequestMapping(&quot;test&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        List&lt;String&gt; list = (List&lt;String&gt;) request.getSession().getAttribute(<span class="hljs-string">&quot;list&quot;</span>);        <span class="hljs-keyword">if</span>(list==<span class="hljs-keyword">null</span>)&#123;            list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        &#125;        list.add(<span class="hljs-string">&quot;xxxx&quot;</span>);        request.getSession().setAttribute(<span class="hljs-string">&quot;list&quot;</span>,list);<span class="hljs-comment">//每次session变化都要同步session</span>        response.getWriter().println(<span class="hljs-string">&quot;size: &quot;</span>+list.size());        response.getWriter().println(<span class="hljs-string">&quot;sessionid: &quot;</span>+request.getSession().getId());    &#125;    <span class="hljs-meta">@RequestMapping(&quot;logout&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">logout</span><span class="hljs-params">(HttpServletRequest request)</span></span>&#123;        <span class="hljs-comment">//退出登录</span>        request.getSession().invalidate();<span class="hljs-comment">//失效</span>    &#125;&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210519110237.png"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210519110306.png"></p><p>如果是集群情况下：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210519110702.png"></p><p>自动解决单结点压力问题</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210519111215.png"></p><p><code>集群情况下这样的代码，size会出现没有增加的情况，为什么？</code></p><p>原来session没有交给redis管理的时候，list是JVM层面的对象，list.add是java虚拟机中的内容+1，但现在变成redis代管理session，list.add改变了JVM层面的对象，但没有改变redis中session的对象。</p><p>没有把JVM中的同步到redis中；</p><h3 id="15-3-war包"><a href="#15-3-war包" class="headerlink" title="15.3 war包"></a>15.3 war包</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210519161015.png"></p><p>设置打包形式为war</p><p>修改主启动类</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210519161049.png"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210519161334.png"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210519161437.png"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210519161616.png"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210519161703.png"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210519161727.png"></p><p>测试结点宕机，不会出现问题</p><p>Tail -f tomcat目录/logs/catalina.out</p><p>可以看tomcat启动日志</p>]]></content>
    
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高频面试题</title>
    <link href="/2021/04/11/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9A%84%E5%89%AF%E6%9C%AC/"/>
    <url>/2021/04/11/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9A%84%E5%89%AF%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li>JUC（java.util.concurrent）<ul><li><strong>进程和线程</strong> <ul><li>进程：后台运行的程序（我们打开的一个软件，就是进程）</li><li>线程：轻量级的进程，并且一个进程包含多个线程（同在一个软件内，同时运行窗口，就是线程）</li></ul></li><li>并发和并行<ul><li>并发：同时访问某个东西，就是并发</li><li>并行：一起做某些事情，就是并行</li></ul></li></ul></li><li>JUC下的三个包<ul><li>java.util.concurrent<ul><li>java.util.concurrent.atomic</li><li>java.util.concurrent.locks</li></ul></li></ul></li></ul><h1 id="谈谈Volatile"><a href="#谈谈Volatile" class="headerlink" title="谈谈Volatile"></a>谈谈Volatile</h1><h2 id="Volatile-理解"><a href="#Volatile-理解" class="headerlink" title="Volatile 理解"></a>Volatile 理解</h2><blockquote><p>volatile是JVM提供的轻量级的同步机制</p></blockquote><ol><li>保证可见性</li><li>不保证原子性</li><li>禁止 <strong>指令重排</strong> （保证有序性）</li></ol><h2 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h2><p>JMM是Java内存模型，也就是Java Memory Model，简称JMM，本身是一种抽象的概念，实际上 <strong>并不存在</strong> ，它描述的是一组 <strong>规则或规范</strong> ，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式</p><p>JMM关于同步的规定：</p><ul><li>线程 <strong>解锁</strong> 前，必须把共享变量的值 <strong>刷新回主内存</strong> </li><li>线程 <strong>加锁</strong> 前，必须读取主内存的最新值，到自己的 <strong>工作内存</strong> </li><li>加锁和解锁是 <strong>同一把锁</strong> </li></ul><p>由于JVM运行程序的实体是线程，而 <strong>每个线程</strong> 创建时 <strong>JVM</strong> 都会为其创建一个 <strong>工作内存</strong> （有些地方称为栈空间），工作内存是每个线程的 <strong>私有数据区域</strong> ，而Java内存模型中规定所有变量都存储在 <strong>主内存</strong> ，主内存是 <strong>共享内存区域</strong> ，所有线程都可以访问，<code>但线程对变量的操作（读取赋值等）必须在工作内存中进行，首先要将变量从主内存拷贝到自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写会主内存</code>，不能直接操作主内存中的变量，各个线程中的工作内存中存储着主内存中的 <strong>变量副本拷贝</strong> ，因此不同的线程间无法访问对方的工作内存，线程间的通信（传值）必须通过主内存来完成，其简要访问过程：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210406170735.png"></p><p>数据传输速率：硬盘 &lt; 内存 &lt; &lt; cache &lt; CPU</p><p>上面提到了两个概念：主内存 和 工作内存</p><ul><li>主内存：就是计算机的内存，也就是经常提到的8G内存，16G内存</li><li>工作内存：但我们实例化 new student，那么 age = 25 也是存储在主内存中<ul><li>当同时有三个线程同时访问 student中的age变量时，那么每个线程都会拷贝一份，到各自的工作内存，从而实现了 <strong>变量的拷贝</strong> </li></ul></li></ul><h3 id="JMM内存模型的可见性"><a href="#JMM内存模型的可见性" class="headerlink" title="JMM内存模型的可见性"></a>JMM内存模型的可见性</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210406171943.png"></p><p>即： <strong>JMM内存模型的可见性</strong> ，指的是当主内存区域中的值被某个线程写入更改后，其它线程会马上知晓更改后的值，并重新得到更改后的值。</p><h3 id="JMM的三大特性"><a href="#JMM的三大特性" class="headerlink" title="JMM的三大特性"></a>JMM的三大特性</h3><p>JMM的三大特性，volatile只保证了两个，即可见性和有序性，不满足原子性，</p><ul><li>可见性</li><li>原子性</li><li>有序性</li></ul><h3 id="JMM可见性code"><a href="#JMM可见性code" class="headerlink" title="JMM可见性code"></a>JMM可见性code</h3><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 假设是主物理内存</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyData</span> </span>&#123;    <span class="hljs-keyword">int</span> number = <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addTo60</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">this</span>.number = <span class="hljs-number">60</span>;    &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 验证volatile的可见性</span><span class="hljs-comment"> * 1. 假设int number = 0， number变量之前没有添加volatile关键字修饰</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Code1_volatile</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args [])</span> </span>&#123;        <span class="hljs-comment">// 资源类</span>        MyData myData = <span class="hljs-keyword">new</span> MyData();        <span class="hljs-comment">// AAA线程 实现了Runnable接口的，lambda表达式</span>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t come in&quot;</span>);            <span class="hljs-comment">// 线程睡眠3秒，假设在进行运算</span>            <span class="hljs-keyword">try</span> &#123;                TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>);            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;            <span class="hljs-comment">// 修改number的值</span>            myData.addTo60();            <span class="hljs-comment">// 输出修改后的值</span>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t update number value:&quot;</span> + myData.number);        &#125;, <span class="hljs-string">&quot;AAA&quot;</span>).start();        <span class="hljs-keyword">while</span>(myData.number == <span class="hljs-number">0</span>) &#123;            <span class="hljs-comment">// main线程就一直在这里等待循环，直到number的值不等于零</span>        &#125;        <span class="hljs-comment">// 按道理这个值是不可能打印出来的，因为主线程运行的时候，number的值为0，所以一直在循环</span>        <span class="hljs-comment">// 如果能输出这句话，说明AAA线程在睡眠3秒后，更新的number的值，重新写入到主内存，并被main线程感知到了</span>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t mission is over&quot;</span>);        <span class="hljs-comment">/**</span><span class="hljs-comment">         * 最后输出结果：</span><span class="hljs-comment">         * AAA  come in</span><span class="hljs-comment">         * AAA  update number value:60</span><span class="hljs-comment">         * 最后线程没有停止，并行没有输出  mission is over 这句话，说明没有用volatile修饰的变量，是没有可见性</span><span class="hljs-comment">         */</span>    &#125;&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210407185933.png"></p><p>main线程没有得知number变成了60；</p><p>如果加上volatile关键字：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210407190056.png"></p><p>volatile 修饰的关键字，是为了增加 主线程和线程之间的可见性，只要有一个线程修改了内存中的值，其它线程也能马上感知。</p><p><a href="https://mp.weixin.qq.com/s/Oa3tcfAFO9IgsbE22C5TEg">拓展区域</a></p><h2 id="Volatile不保证原子性"><a href="#Volatile不保证原子性" class="headerlink" title="Volatile不保证原子性"></a>Volatile不保证原子性</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>通过前面对JMM的介绍，我们知道，各个线程对主内存中共享变量的操作都是各个线程各自拷贝到自己的工作内存进行操作后在写回到主内存中的。</p><p>这就可能存在一个 <strong>线程AAA</strong> 修改了共享变量X的值，但是还未写入主内存时，另外一个 <strong>线程BBB</strong> 又对主内存中同一共享变量X进行操作，但此时 <strong>A线程工作内存中共享变量X对线程B来说是不可见</strong> ，这种工作内存与主内存同步延迟现象就造成了 <strong>可见性问题</strong> 。</p><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>不可分割，完整性，也就是说某个线程正在做某个具体业务时，中间 <strong>不可以被加塞或者被分割</strong> ，需要具体完成，要么 <strong>同时成功，要么同时失败</strong> 。</p><p>数据库也经常提到事务具备原子性 </p><h3 id="原子性代码测试"><a href="#原子性代码测试" class="headerlink" title="原子性代码测试"></a>原子性代码测试</h3><p>首先给MyDate资源类添加方法</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 注意，此时number 前面是加了volatile修饰</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addPlusPlus</span><span class="hljs-params">()</span> </span>&#123;    number ++;&#125;</code></pre><p>为了测试volatile是否保证原子性，我们创建了20个线程，然后每个线程分别循环1000次，来调用number++的方法</p><p>最后通过 Thread.activeCount()，来感知20个线程是否执行完毕，这里判断线程数是否大于2；</p><p> <strong>为什么是2？因为默认是有两个线程的，一个main线程，一个gc线程</strong> </p><pre><code class="hljs java">MyData myData = <span class="hljs-keyword">new</span> MyData();<span class="hljs-comment">// 创建10个线程，线程里面进行1000次循环</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;    <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;        <span class="hljs-comment">// 里面</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">1000</span>; j++) &#123;            myData.addPlusPlus();        &#125;    &#125;, String.valueOf(i)).start();&#125;<span class="hljs-comment">// 需要等待上面20个线程都计算完成后，在用main线程取得最终的结果值</span><span class="hljs-keyword">while</span>(Thread.activeCount() &gt; <span class="hljs-number">2</span>) &#123;    <span class="hljs-comment">// yield表示不执行</span>    Thread.yield();&#125;<span class="hljs-comment">// 查看最终的值</span><span class="hljs-comment">// 假设volatile保证原子性，那么输出的值应该为：  20 * 1000 = 20000</span>System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t finally number value: &quot;</span> + myData.number);</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210407192017.png"></p><h3 id="为什么不能保证原子性"><a href="#为什么不能保证原子性" class="headerlink" title="为什么不能保证原子性"></a>为什么不能保证原子性</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210407193224.png"></p><p>各自线程在写入主内存的时候，出现了数据的丢失，而引起的数值缺失的问题</p><p>下面我们将一个简单的number++操作，转换为字节码文件一探究竟</p><p>.java -&gt; .class -&gt; JVM字节码</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210407193959.png"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210407194057.png"></p><p>我们能够发现 n++这条命令，被拆分成了 <strong>3个指令</strong> </p><ul><li>执行<code>getfield</code> 从主内存拿到原始n</li><li>执行<code>iadd</code> 进行加1操作</li><li>执行<code>putfileld</code> 把累加后的值写回主内存</li></ul><p>假设我们没有加 <code>synchronized</code>那么第一步就可能存在着， <strong>三个线程同时通过getfield命令</strong> ，拿到主存中的 n值，然后三个线程，各自在自己的工作内存中进行加1操作，但他们并发进行 <code>iadd</code> 命令的时候，因为只能一个进行写，所以其它操作会被 <strong>挂起</strong> ，假设1线程，先进行了写操作，在写完后，volatile的可见性，应该需要告诉其它两个线程，主内存的值已经被修改了，但是 <strong>因为太快了</strong> ， <strong>没有来得及获取最新值</strong> ，其它两个线程，陆续执行 <code>iadd</code>命令，进行写入操作，这就造成了其他线程没有接受到主内存n的改变，从而覆盖了原来的值，出现写丢失，这样也就让最终的结果少于20000</p><p> <strong>写覆盖问题</strong> ；</p><h3 id="如何解决？"><a href="#如何解决？" class="headerlink" title="如何解决？"></a>如何解决？</h3><p>因此这也说明，在 <strong>多线程环境</strong> 下 number ++ 在多线程环境下是 <strong>非线程安全</strong> 的，解决的方法有哪些呢？</p><ul><li><p>在方法上加入 synchronized</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addPlusPlus</span><span class="hljs-params">()</span> </span>&#123;        number ++;    &#125;</code></pre><p>引入synchronized关键字后， 保证了该方法 <strong>每次只能够一个线程</strong> 进行访问和操作，最终输出的结果也就为20000</p></li></ul><p>上面的方法引入synchronized，虽然能够保证原子性，但是为了解决number++，而引入 <strong>重量级</strong> 的同步机制，有种  <strong>杀鸡焉用牛刀</strong> </p><ul><li><p>可以使用JUC下面的 <strong>原子包装类</strong> ，即刚刚的int类型的number，可以使用AtomicInteger来代替，最小单位不可分割</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">    *  创建一个原子Integer包装类，默认为0</span><span class="hljs-comment">     */</span>   AtomicInteger atomicInteger = <span class="hljs-keyword">new</span> AtomicInteger();     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addAtomic</span><span class="hljs-params">()</span> </span>&#123;       <span class="hljs-comment">// 相当于 atomicInter ++</span>       atomicInteger.getAndIncrement();   &#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210407195719.png"></p></li></ul><h3 id="字节码表"><a href="#字节码表" class="headerlink" title="字节码表"></a>字节码表</h3><p><a href="https://segmentfault.com/a/1190000008722128">表</a></p><h2 id="Volatile禁止指令重排"><a href="#Volatile禁止指令重排" class="headerlink" title="Volatile禁止指令重排"></a>Volatile禁止指令重排</h2><p>计算机在执行程序时，为了提高性能， <strong>编译器和处理器</strong> 常常会对 <strong>指令重排</strong> ，一般分为以下三种：</p><pre><code class="hljs clean">源代码 -&gt; 编译器优化的重排 -&gt; 指令并行的重排 -&gt; 内存系统的重排 -&gt; 最终执行指令</code></pre><ul><li> <strong>单线程环境</strong> 里面确保最终执行结果和代码顺序的结果一致</li><li>处理器在进行重排序时，必须要考虑指令之间的<code>数据依赖性</code></li><li> <strong>多线程环境</strong> 中线程交替执行，由于编译器优化重排的存在，两个线程中使用的变量能否保证一致性是无法确定的， <strong>结果无法预测</strong> 。</li></ul><h3 id="指令重排-example-1"><a href="#指令重排-example-1" class="headerlink" title="指令重排 - example 1"></a>指令重排 - example 1</h3><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mySort</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-keyword">int</span> x = <span class="hljs-number">11</span>;  <span class="hljs-keyword">int</span> y = <span class="hljs-number">12</span>;  x = x + <span class="hljs-number">5</span>;  y = x * x;&#125;</code></pre><ul><li><p>按照正常 <strong>单线程环境</strong> ，执行顺序是 1 2 3 4 </p></li><li><p>但是在 <strong>多线程环境</strong> 下，可能出现以下的顺序： </p><ul><li>2 1 3 4</li><li>1 3 2 4</li></ul></li></ul><p>上述的过程就可以当做是 <strong>指令的重排</strong> ，即内部执行顺序，和我们的代码顺序不一样</p><p>但是指令重排也是有 <strong>限制</strong> 的，即不会出现下面的顺序</p><ul><li>4 3 2 1</li></ul><p>因为处理器在进行重排时候，必须考虑到指令之间的<code>数据依赖性</code></p><p>因为步骤 4：需要依赖于 y的申明，以及x的申明，故因为存在数据依赖，无法首先执行</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p> <strong>int a,b,x,y = 0</strong> </p><table><thead><tr><th>线程1</th><th>线程2</th></tr></thead><tbody><tr><td>x = a;</td><td>y = b;</td></tr><tr><td>b = 1;</td><td>a = 2;</td></tr><tr><td></td><td></td></tr><tr><td>x = 0; y = 0</td><td></td></tr></tbody></table><p>因为上面的代码，不存在数据的依赖性，因此编译器可能对数据进行重排</p><table><thead><tr><th>线程1</th><th>线程2</th></tr></thead><tbody><tr><td>b = 1;</td><td>a = 2;</td></tr><tr><td>x = a;</td><td>y = b;</td></tr><tr><td></td><td></td></tr><tr><td>x = 2; y = 1</td><td></td></tr></tbody></table><p>这样造成的结果，和最开始的就不一致了，这就是导致重排后，结果和最开始的不一样，因此为了防止这种结果出现， <strong>volatile就规定禁止指令重排</strong> ，为了 <strong>保证数据的一致性</strong> </p><h3 id="指令重排-example-2"><a href="#指令重排-example-2" class="headerlink" title="指令重排 - example 2"></a>指令重排 - example 2</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ResortSeqDemo</span> </span>&#123;    <span class="hljs-keyword">int</span> a= <span class="hljs-number">0</span>;    <span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">false</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method01</span><span class="hljs-params">()</span> </span>&#123;        a = <span class="hljs-number">1</span>;        flag = <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method02</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span>(flag) &#123;            a = a + <span class="hljs-number">5</span>;            System.out.println(<span class="hljs-string">&quot;reValue:&quot;</span> + a);        &#125;    &#125;&#125;</code></pre><p>我们按照正常的顺序，分别调用method01() 和 method02() 那么，最终输出就是 a = 6</p><p>但是如果在多线程环境下，因为方法1 和 方法2，他们之间不能存在数据依赖的问题，因此原先的顺序可能是</p><pre><code class="hljs java">a = <span class="hljs-number">1</span>;flag = <span class="hljs-keyword">true</span>;a = a + <span class="hljs-number">5</span>;System.out.println(<span class="hljs-string">&quot;reValue:&quot;</span> + a);</code></pre><p>但是在经过编译器，指令，或者内存的重排后，可能会出现这样的情况</p><pre><code class="hljs java">flag = <span class="hljs-keyword">true</span>;a = a + <span class="hljs-number">5</span>;System.out.println(<span class="hljs-string">&quot;reValue:&quot;</span> + a);a = <span class="hljs-number">1</span>;</code></pre><p>也就是先执行 flag = true后，另外一个线程马上调用方法2，满足 flag的判断，最终让a + 5，结果为5，这样同样出现了数据不一致的问题</p><p>为什么会出现这个结果：多线程环境中线程交替执行，由于编译器优化重排的存在，两个线程中使用的变量能否保证一致性是无法确定的，结果无法预测。</p><p>这样就需要通过 <strong>volatile来修饰</strong> ，来保证线程安全性</p><h3 id="Volatile针对指令重排做了啥"><a href="#Volatile针对指令重排做了啥" class="headerlink" title="Volatile针对指令重排做了啥"></a>Volatile针对指令重排做了啥</h3><p>Volatile实现 <strong>禁止指令重排优化</strong> ，从而避免了多线程环境下程序出现乱序执行的现象</p><p>首先了解一个概念， <strong>内存屏障</strong> （Memory Barrier）又称 <strong>内存栅栏</strong> ，是一个 <strong>CPU指令</strong> ，它的作用有两个：</p><ul><li><p>保证特定操作的顺序</p></li><li><p>保证某些变量的内存可见性（利用该特性 <strong>实现volatile的内存可见性</strong> ）</p><p>由于编译器和处理器都能执行指令重排的优化，如果在指令间插入一条Memory Barrier则会告诉编译器和CPU，不管什么指令都不能和这条Memory Barrier指令重排序，也就是说 <code>通过插入内存屏障禁止在内存屏障前后的指令执行重排序优化</code>。 内存屏障另外一个作用是 <strong>刷新出各种CPU的缓存数据</strong> ，因此任何CPU上的线程都能读取到这些数据的最新版本。</p></li></ul><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210407202835.png"></p><p>也就是在Volatile的写 和 读的时候，加入屏障，防止出现指令重排的</p><h3 id="线程安全获得保证"><a href="#线程安全获得保证" class="headerlink" title="线程安全获得保证"></a>线程安全获得保证</h3><p>工作内存与主内存同步延迟现象导致的 <strong>可见性问题</strong> </p><ul><li>可通过synchronized或volatile关键字解决，他们都可以使一个线程修改后的变量立即对其它线程可见</li></ul><p>对于 <strong>指令重排导致的可见性问题和有序性问题</strong> </p><ul><li>可以使用volatile关键字解决，因为volatile关键字的另一个作用就是禁止重排序优化</li></ul><h2 id="Volatile的应用"><a href="#Volatile的应用" class="headerlink" title="Volatile的应用"></a>Volatile的应用</h2><h3 id="单例模式DCL代码"><a href="#单例模式DCL代码" class="headerlink" title="单例模式DCL代码"></a>单例模式DCL代码</h3><pre><code class="hljs java"><span class="hljs-comment">// 单例模式DCL代码</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Code2_SingletonDemo</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Code2_SingletonDemo instance = <span class="hljs-keyword">null</span>;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Code2_SingletonDemo</span><span class="hljs-params">()</span></span>&#123;        System.out.println(<span class="hljs-string">&quot;构造方法&quot;</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Code2_SingletonDemo <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>)&#123;            instance = <span class="hljs-keyword">new</span> Code2_SingletonDemo();        &#125;        <span class="hljs-keyword">return</span> instance;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">// 单线程(main 线程操作)</span>        System.out.println(Code2_SingletonDemo.getInstance() == Code2_SingletonDemo.getInstance());        System.out.println(Code2_SingletonDemo.getInstance() == Code2_SingletonDemo.getInstance());        System.out.println(Code2_SingletonDemo.getInstance() == Code2_SingletonDemo.getInstance());    &#125;&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210408185446.png"></p><p>改变后</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    <span class="hljs-comment">// 并发后 情况有所改变</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            Code2_SingletonDemo.getInstance();        &#125;, String.valueOf(i)).start();    &#125;&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210408185546.png"></p><p>从上面的结果我们可以看出，我们通过SingletonDemo.getInstance() 获取到的对象，并不是同一个，而是被下面几个线程都进行了创建，那么在多线程环境下， <strong>单例模式如何保证呢</strong> ？</p><h4 id="解决方法1"><a href="#解决方法1" class="headerlink" title="解决方法1"></a>解决方法1</h4><ul><li><p>引入synchronized关键字</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> SingletonDemo <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span>(instance == <span class="hljs-keyword">null</span>) &#123;            instance = <span class="hljs-keyword">new</span> SingletonDemo();        &#125;        <span class="hljs-keyword">return</span> instance;    &#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210408185857.png"></p></li></ul><p>我们能够发现，通过引入Synchronized关键字，能够 <strong>解决高并发环境下的单例模式问题</strong> </p><p>但是synchronized属于 <strong>重量级</strong> 的同步机制，它只允许一个线程同时访问获取实例的方法，但是为了保证数据一致性，而 <strong>减低了并发性</strong> ，因此采用的比较少</p><h4 id="解决方法2"><a href="#解决方法2" class="headerlink" title="解决方法2"></a>解决方法2</h4><ul><li><p>通过引入 <strong>DCL</strong>  Double Check Lock 双端检锁机制</p><p>就是在进来和出去的时候，进行检测</p></li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingletonDemo <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">if</span>(instance == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-comment">// 同步代码段的时候，进行检测</span>        <span class="hljs-keyword">synchronized</span> (SingletonDemo.class) &#123;            <span class="hljs-keyword">if</span>(instance == <span class="hljs-keyword">null</span>) &#123;                instance = <span class="hljs-keyword">new</span> SingletonDemo();            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> instance;&#125;</code></pre><p>​   </p><p>从输出结果来看，确实能够保证单例模式的正确性，但是上面的方法还是 <strong>存在问题的</strong> </p><p>DCL（双端检锁）机制不一定是线程安全的，原因是有 <strong>指令重排</strong> 的存在，加入volatile可以禁止指令重排</p><p>原因是在某一个线程执行到第一次检测的时候，读取到 instance 不为null，instance的引用对象 <strong>可能没有完成实例化</strong> 。</p><p>因为 instance = new SingletonDemo()；可以分为以下 <strong>三步</strong> 进行完成：</p><ul><li>memory = allocate(); // 1、分配对象内存空间</li><li>instance(memory); // 2、初始化对象</li><li>instance = memory; // 3、设置instance指向刚刚分配的内存地址，此时instance != null</li></ul><p>步骤2、步骤3 <strong>不存在数据依赖关系</strong> ，重排前和重排后对单线程模式下的程序运行没有结果改变，所以这种重排优化是被允许的。</p><ul><li>memory = allocate(); // 1、分配对象内存空间</li><li>instance = memory; // 3、设置instance指向刚刚分配的内存地址，此时instance != null， <strong>但是对象还没有初始化完成</strong> </li><li>instance(memory); // 2、初始化对象</li></ul><p>这样就会造成什么问题呢？</p><p>也就是当我们执行到重排后的步骤2，试图获取instance的时候，会得到null，因为对象的初始化还没有完成，而是在重排后的步骤3才完成，因此执行单例模式的代码时候，就会 <strong>重新</strong> 创建一个instance实例</p><p><code>指令重排只会保证串行语义的执行一致性（单线程），但并不会关系多线程间的语义一致性</code></p><p>所以当一条线程访问instance不为null时， <strong>由于instance实例未必已初始化完成</strong> ，这就造成了 <strong>线程安全</strong> 的问题</p><p>所以需要引入volatile，来保证出现指令重排的问题，从而保证单例模式的线程安全性</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> SingletonDemo instance = <span class="hljs-keyword">null</span>;</code></pre><h4 id="最终代码"><a href="#最终代码" class="headerlink" title="最终代码"></a>最终代码</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonDemo</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> SingletonDemo instance = <span class="hljs-keyword">null</span>;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">SingletonDemo</span> <span class="hljs-params">()</span> </span>&#123;        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 我是构造方法SingletonDemo&quot;</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingletonDemo <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span>(instance == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-comment">// a 双重检查加锁多线程情况下会出现某个线程虽然这里已经为空，但是另外一个线程已经执行到d处</span>            <span class="hljs-keyword">synchronized</span> (SingletonDemo.class) <span class="hljs-comment">//b</span>            &#123;            <span class="hljs-comment">//c不加volitale关键字的话有可能会出现尚未完全初始化就获取到的情况。原因是内存模型允许无序写入</span>                <span class="hljs-keyword">if</span>(instance == <span class="hljs-keyword">null</span>) &#123;                   <span class="hljs-comment">// d 此时才开始初始化</span>                    instance = <span class="hljs-keyword">new</span> SingletonDemo();                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> instance;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;            <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;                SingletonDemo.getInstance();            &#125;, String.valueOf(i)).start();        &#125;    &#125;&#125;</code></pre><h1 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p> 比较并交换；</p><p>CAS的全称是 <strong>Compare-And-Swap</strong> ，它是 <strong>CPU并发原语</strong> </p><p>它的功能是 <strong>判断内存某个位置的值是否为预期值</strong> ，如果是则更改为新的值，这个过程是 <strong>原子的</strong> </p><p>CAS并发原语体现在Java语言中就是 <strong>sun.misc.Unsafe类</strong> 的各个方法。调用UnSafe类中的 <strong>CAS方法</strong> ， <strong>JVM</strong> 会帮我们实现出 <strong>CAS汇编指令</strong> ，这是一种完全依赖于 <strong>硬件</strong> 的功能，通过它实现了原子操作，再次强调，由于CAS是一种系统原语，原语属于操作系统用于范畴，是由若干条指令组成，用于完成某个功能的一个过程，并且原语的执行必须是连续的，在执行过程中不允许被中断，也就是说 <strong>CAS是一条CPU的原子指令</strong> ，不会造成所谓的数据不一致的问题，也就是说 <strong>CAS是线程安全的</strong> 。</p><h2 id="代码使用"><a href="#代码使用" class="headerlink" title="代码使用"></a>代码使用</h2><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    <span class="hljs-comment">// 创建一个原子类</span>    AtomicInteger atomicInteger = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">5</span>);    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 一个是期望值，一个是更新值，但期望值和原来的值相同时，才能够更改</span><span class="hljs-comment">     * 假设三秒前，我拿的是5，也就是expect为5，然后我需要更新成 2019</span><span class="hljs-comment">     */</span>    System.out.println(atomicInteger.compareAndSet(<span class="hljs-number">5</span>, <span class="hljs-number">2019</span>) + <span class="hljs-string">&quot;\t current data: &quot;</span> + atomicInteger.get());    System.out.println(atomicInteger.compareAndSet(<span class="hljs-number">5</span>, <span class="hljs-number">1024</span>) + <span class="hljs-string">&quot;\t current data: &quot;</span> + atomicInteger.get());&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210408195319.png"></p><p>这是因为我们执行第一个的时候，期望值和原本值是满足的，因此修改成功，</p><p>但是第二次后，主内存的值已经修改成了2019， <strong>不满足期望值</strong> ，因此返回了false，本次写入失败。</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210408195413.png"></p><p>这个就类似于 <strong>SVN或者Git的版本号</strong> ，如果没有人更改过，就能够正常提交，否者需要先将代码pull下来，合并代码后，然后提交</p><h2 id="CAS底层原理"><a href="#CAS底层原理" class="headerlink" title="CAS底层原理"></a>CAS底层原理</h2><h3 id="atomicInteger源码"><a href="#atomicInteger源码" class="headerlink" title="atomicInteger源码"></a>atomicInteger源码</h3><p>首先我们先看看 atomicInteger.getAndIncrement()方法的源码</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210408201048.png"></p><p>从这里能够看到，底层又调用了一个unsafe类的getAndAddInt方法</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210408201332.png"></p><h3 id="unsafe类源码"><a href="#unsafe类源码" class="headerlink" title="unsafe类源码"></a>unsafe类源码</h3><p>继续深挖</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210408201458.png"></p><p>进入sun.misc.Unsafe；</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210408201631.png" alt="JDK"></p><p>JDK自带的native方法</p><p>先回到aotomicInteger</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210408201930.png"></p><p>objectFieldOffset得到对象偏移量</p><p>Unsafe是CAS的 <strong>核心类</strong> ，CAS靠的是Unsafe的原子性，由于Java方法无法直接访问底层系统，需要通过本地（Native）方法来访问，Unsafe相当于一个 <strong>后门</strong> ，基于该类可以直接操作特定的内存数据。Unsafe类存在sun.misc包中，其内部方法操作可以像C的指针一样直接操作内存，因为Java中的 <strong>CAS操作的执行依赖于Unsafe类的方法</strong> 。</p><pre><code class="hljs oxygene">注意<span class="hljs-keyword">Unsafe</span>类的所有方法都是native修饰的，也就是说<span class="hljs-keyword">unsafe</span>类中的方法都直接调用操作系统底层资源执行相应的任务</code></pre><p>为什么Atomic修饰的包装类，能够保证原子性，依靠的就是底层的unsafe类</p><h3 id="变量valueOffset"><a href="#变量valueOffset" class="headerlink" title="变量valueOffset"></a>变量valueOffset</h3><p>表示该变量值在 <strong>内存中的偏移地址</strong> ，因为Unsafe就是根据内存偏移地址获取数据的。</p><p>从这里我们能够看到，通过valueOffset，直接通过内存地址，获取到值，然后进行加1的操作</p><h3 id="变量value"><a href="#变量value" class="headerlink" title="变量value"></a>变量value</h3><p>用 <strong>volatile</strong> 修饰</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210408202836.png"></p><p>var5：就是我们从主内存中拷贝到 <strong>工作内存中的值</strong>  (每次都要从主内存拿到 <strong>最新的值</strong> 到自己的本地内存，然后执行compareAndSwapInt()再和主内存的值进行比较。因为线程不可以直接越过高速缓存，直接操作主内存，所以执行上述方法需要比较一次，在执行加1操作)</p><p>那么操作的时候，需要比较 <strong>工作内存中的值</strong> ，和 <strong>主内存中的值</strong> 进行比较</p><p>假设执行 compareAndSwapInt返回false，那么就一直执行 while方法，直到期望的值和真实值一样</p><ul><li>val1：AtomicInteger对象本身</li><li>var2：该对象值的 <strong>引用地址</strong> （内存偏移量）</li><li>var4：需要变动的数量</li><li>var5：用var1和var2找到的内存中的真实值<ul><li>用该对象当前的值与var5比较</li><li>如果相同，更新var5 + var4 并返回true</li><li>如果不同，继续取值（取得 <strong>最新的值</strong> ）然后再比较，直到更新完成</li></ul></li></ul><p>这里没有用synchronized，而用CAS，这样 <strong>提高了并发性</strong> ，也能够 <strong>实现一致性</strong> ，是因为每个线程进来后，进入的do while循环，然后不断的获取内存中的值，判断是否为最新，然后在进行更新操作。</p><p>假设 <strong>线程A和线程B</strong> 同时执行getAndInt操作（分别跑在不同的CPU上）</p><ol><li><p>AtomicInteger里面的value原始值为3，即主内存中AtomicInteger的 value 为3，根据JMM模型，线程A和线程B各自持有一份价值为3的副本，分别存储在各自的工作内存</p></li><li><p>线程A通过getIntVolatile(var1 , var2) 拿到value值3，这是 <strong>线程A被挂起</strong> （该线程失去CPU执行权）</p></li><li><p>线程B也通过getIntVolatile(var1, var2)方法获取到value值也是3，此时刚好线程B <strong>没有被挂起</strong> ，并执行了compareAndSwapInt方法，比较内存的值也是3，成功修改内存值为4，线程B打完收工，一切OK</p></li><li><p>这是线程A恢复，执行CAS方法，比较发现自己手里的数字3和主内存中的数字4 <strong>不一致</strong> ，说明该值已经被其它线程抢先一步修改过了，那么A线程本次修改失败，只能够 <strong>重新读取</strong> 后在来一遍了，也就是在执行do while</p></li><li><p>线程A重新获取value值， <strong>因为变量value被volatile修饰</strong> ，（unsafe.getAndAddInt(this, valueOffset, 1)传入的this是当前atomicInteger对象，修改的是里面的value字段 ）所以其它线程对它的修改，线程A总能够看到，线程A继续执行compareAndSwapInt进行比较替换，直到成功。</p></li></ol><p>Unsafe类 + CAS思想： 也就是 <strong>自旋</strong> ，自我旋转</p><h2 id="底层汇编"><a href="#底层汇编" class="headerlink" title="底层汇编"></a>底层汇编</h2><p>Unsafe类中的compareAndSwapInt是一个 <strong>本地方法</strong> ，该方法的实现位于 <strong>unsafe.cpp</strong> 中</p><ul><li>先想办法拿到变量value在内存中的地址</li><li>通过Atomic::cmpxchg(x, addr, e) 实现比较替换，其中参数X是即将更新的值，参数e是原内存的值</li></ul><h2 id="CAS缺点"><a href="#CAS缺点" class="headerlink" title="CAS缺点"></a>CAS缺点</h2><p>CAS <strong>不加锁</strong> ，保证一次性，但是 <strong>需要多次比较</strong> </p><ul><li>循环时间长，开销大（因为执行的是do while，如果比较不成功一直在循环，最差的情况，就是某个线程一直取到的值和预期值都不一样，这样就会 <strong>无限循环</strong> ）</li><li>只能 <strong>保证一个共享变量的原子操作</strong> <ul><li>当对一个共享变量执行操作时，我们可以通过循环CAS的方式来保证原子操作</li><li>但是对于多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候 <strong>只能用锁</strong> 来保证原子性</li></ul></li><li>引出来ABA问题？</li></ul><h1 id="原子类AtomicInteger的ABA问题"><a href="#原子类AtomicInteger的ABA问题" class="headerlink" title="原子类AtomicInteger的ABA问题"></a>原子类AtomicInteger的ABA问题</h1><h2 id="前提引入"><a href="#前提引入" class="headerlink" title="前提引入"></a>前提引入</h2><p>从AtomicInteger引出下面的问题</p><p>CAS -&gt; Unsafe -&gt; CAS底层思想 -&gt; ABA -&gt; 原子引用更新 -&gt; 如何规避ABA问题</p><h2 id="ABA问题是什么"><a href="#ABA问题是什么" class="headerlink" title="ABA问题是什么"></a>ABA问题是什么</h2><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210408232736.png"></p><p>假设现在有两个线程，分别是T1 和 T2，然后T1执行某个操作的时间为 <strong>10秒</strong> ，T2执行某个时间的操作是 <strong>2秒</strong> ，最开始AB两个线程，分别从主内存中获取A值，但是因为B的执行速度更快，他先把A的值改成B，然后在修改成A，然后执行完毕，T1线程在10秒后，执行完毕，判断内存中的值为A，并且和自己预期的值一样，它就认为没有人更改了主内存中的值，就快乐的修改成B，但是实际上 可能中间经历了 ABCDEFA 这个变换，也就是中间的值经历了 <strong>狸猫换太子</strong> 。</p><p>所以ABA问题就是，在进行获取主内存值的时候，该内存值在我们写入主内存的时候， <strong>已经被修改了N次</strong> ，但是最终又改成原来的值了</p><h2 id="CAS导致ABA问题"><a href="#CAS导致ABA问题" class="headerlink" title="CAS导致ABA问题"></a>CAS导致ABA问题</h2><p>CAS算法实现了一个重要的前提，需要取出内存中某时刻的数据，并在当下时刻比较并替换，那么这个时间差会导致数据的变化。</p><p>比如说一个线程one从内存位置V中取出A，这时候另外一个线程two也从内存中取出A，并且线程two进行了一些操作将值变成了B，然后线程two又将V位置的数据变成A，这时候线程one进行CAS操作发现内存中仍然是A，然后线程one操作成功</p><p><code>尽管线程one的CAS操作成功，但是不代表这个过程就是没有问题的</code></p><p>CAS只管开头和结尾，也就是头和尾是一样，那就修改成功， <strong>中间的这个过程，可能会被人修改过</strong> </p><h2 id="AtomicReference原子引用"><a href="#AtomicReference原子引用" class="headerlink" title="AtomicReference原子引用"></a>AtomicReference原子引用</h2><p> <strong>原子引用</strong> 其实和 <strong>原子包装类</strong> 是差不多的概念，就是将一个java类， <strong>用原子引用类进行包装起来</strong> ，那么这个类就具备了 <strong>原子性</strong> </p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;    String userName;    <span class="hljs-keyword">int</span> age;    ....&#125;</code></pre><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    User z3 = <span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;zhangsan&quot;</span>, <span class="hljs-number">22</span>);    User l4 = <span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;lisi&quot;</span>, <span class="hljs-number">25</span>);    <span class="hljs-comment">// 创建原子引用包装类</span>    AtomicReference&lt;User&gt; atomicReference = <span class="hljs-keyword">new</span> AtomicReference&lt;&gt;();    <span class="hljs-comment">// 现在主物理内存的共享变量，为z3</span>    atomicReference.set(z3);    <span class="hljs-comment">// 比较并交换，如果现在主物理内存的值为z3，那么交换成l4</span>    System.out.println(atomicReference.compareAndSet(z3, l4) + <span class="hljs-string">&quot;\t &quot;</span> + atomicReference.get().toString());    <span class="hljs-comment">// 比较并交换，现在主物理内存的值是l4了，但是预期为z3，因此交换失败</span>    System.out.println(atomicReference.compareAndSet(z3, l4) + <span class="hljs-string">&quot;\t &quot;</span> + atomicReference.get().toString());&#125;</code></pre><h2 id="基于原子引用的ABA问题"><a href="#基于原子引用的ABA问题" class="headerlink" title="基于原子引用的ABA问题"></a>基于原子引用的ABA问题</h2><pre><code class="hljs java"><span class="hljs-comment">// 测试ABA问题</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Code5_ABADemo</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 普通的原子引用包装类</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">static</span> AtomicReference&lt;Integer&gt; atomicReference = <span class="hljs-keyword">new</span> AtomicReference&lt;&gt;(<span class="hljs-number">100</span>);    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            <span class="hljs-comment">// 把100 改成 101 然后在改成100，也就是ABA</span>            atomicReference.compareAndSet(<span class="hljs-number">100</span>, <span class="hljs-number">101</span>);            atomicReference.compareAndSet(<span class="hljs-number">101</span>, <span class="hljs-number">100</span>);        &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-comment">// 睡眠一秒，保证t1线程，完成了ABA操作</span>                TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;            <span class="hljs-comment">// 把100 改成 101 然后在改成100，也就是ABA</span>            System.out.println(atomicReference.compareAndSet(<span class="hljs-number">100</span>, <span class="hljs-number">2019</span>) + <span class="hljs-string">&quot;\t&quot;</span> + atomicReference.get());        &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();    &#125;&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210408235035.png"></p><p>创建两个线程，然后T1线程，执行一次ABA的操作，T2线程在一秒后修改主内存的值</p><h2 id="解决ABA问题"><a href="#解决ABA问题" class="headerlink" title="解决ABA问题"></a>解决ABA问题</h2><p>新增一种机制，也就是 <strong>修改版本号</strong> ，类似于 <strong>时间戳</strong> 的概念</p><p>T1： 100 1         （拿到100改成2019） 2</p><p>T2： 100 1   101 2   100 3</p><p>如果T1修改的时候，版本号为2， <strong>落后于</strong> 现在的版本号3，所以要重新获取最新值，这里就提出了一个使用时间戳版本号，来解决ABA问题的思路</p><h2 id="AtomicStampedReference"><a href="#AtomicStampedReference" class="headerlink" title="AtomicStampedReference"></a>AtomicStampedReference</h2><p> <strong>时间戳原子引用</strong> ，来这里应用于版本号的更新，也就是每次更新的时候，需要比较期望值和当前值，以及 <strong>期望版本号和当前版本号</strong> </p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210409000130.png"></p><pre><code class="hljs java"><span class="hljs-comment">// ABA问题的解决</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Code6_ABASolution</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 普通的原子引用包装类</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">static</span> AtomicReference&lt;Integer&gt; atomicReference = <span class="hljs-keyword">new</span> AtomicReference&lt;&gt;(<span class="hljs-number">100</span>);    <span class="hljs-comment">// 传递两个值，一个是初始值，一个是初始版本号</span>    <span class="hljs-keyword">static</span> AtomicStampedReference&lt;Integer&gt; atomicStampedReference = <span class="hljs-keyword">new</span> AtomicStampedReference&lt;&gt;(<span class="hljs-number">100</span>, <span class="hljs-number">1</span>);    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;============以下是ABA问题的产生==========&quot;</span>);        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            <span class="hljs-comment">// 把100 改成 101 然后在改成100，也就是ABA</span>            atomicReference.compareAndSet(<span class="hljs-number">100</span>, <span class="hljs-number">101</span>);            atomicReference.compareAndSet(<span class="hljs-number">101</span>, <span class="hljs-number">100</span>);        &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-comment">// 睡眠一秒，保证t1线程，完成了ABA操作</span>                TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;            <span class="hljs-comment">// 把100 改成 101 然后在改成100，也就是ABA</span>            System.out.println(atomicReference.compareAndSet(<span class="hljs-number">100</span>, <span class="hljs-number">2019</span>) + <span class="hljs-string">&quot;\t&quot;</span> + atomicReference.get());        &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();        System.out.println(<span class="hljs-string">&quot;============以下是ABA问题的解决==========&quot;</span>);        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            <span class="hljs-comment">// 获取版本号</span>            <span class="hljs-keyword">int</span> stamp = atomicStampedReference.getStamp();            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 第一次版本号&quot;</span> + stamp);            <span class="hljs-comment">// 暂停t3一秒钟</span>            <span class="hljs-keyword">try</span> &#123;                TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;            <span class="hljs-comment">// 传入4个值，期望值，更新值，期望版本号，更新版本号</span>            atomicStampedReference.compareAndSet(<span class="hljs-number">100</span>, <span class="hljs-number">101</span>, atomicStampedReference.getStamp(), atomicStampedReference.getStamp()+<span class="hljs-number">1</span>);            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 第二次版本号&quot;</span> + atomicStampedReference.getStamp());            atomicStampedReference.compareAndSet(<span class="hljs-number">101</span>, <span class="hljs-number">100</span>, atomicStampedReference.getStamp(), atomicStampedReference.getStamp()+<span class="hljs-number">1</span>);            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 第三次版本号&quot;</span> + atomicStampedReference.getStamp());        &#125;, <span class="hljs-string">&quot;t3&quot;</span>).start();        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            <span class="hljs-comment">// 获取版本号</span>            <span class="hljs-keyword">int</span> stamp = atomicStampedReference.getStamp();            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 第一次版本号&quot;</span> + stamp);            <span class="hljs-comment">// 暂停t4 3秒钟，保证t3线程也进行一次ABA问题</span>            <span class="hljs-keyword">try</span> &#123;                TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>);            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;            <span class="hljs-keyword">boolean</span> result = atomicStampedReference.compareAndSet(<span class="hljs-number">100</span>, <span class="hljs-number">2019</span>, stamp, stamp+<span class="hljs-number">1</span>);            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 修改成功否：&quot;</span> + result + <span class="hljs-string">&quot;\t 当前最新实际版本号：&quot;</span> + atomicStampedReference.getStamp());            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 当前实际最新值&quot;</span> + atomicStampedReference.getReference());        &#125;, <span class="hljs-string">&quot;t4&quot;</span>).start();    &#125;&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210409000627.png"></p><p>我们能够发现，线程t3，在进行ABA操作后，版本号变更成了3，而线程t4在进行操作的时候，就出现操作失败了，因为版本号和当初拿到的不一样， <strong>无法修改</strong> 。</p><h2 id="CAS拓展优化"><a href="#CAS拓展优化" class="headerlink" title="CAS拓展优化"></a>CAS拓展优化</h2><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://blog.csdn.net/eluanshi12/article/details/84871879">AtomicLong与LongAdder（CAS机制的优化）</a></p><p><a href="https://mp.weixin.qq.com/s/KFsqsCVgyiiTDXMR-Hu1-Q">大白话聊聊Java并发面试问题之Java 8如何优化CAS性能？</a></p><p><a href="https://blog.csdn.net/wolf_love666/article/details/87693771">https://blog.csdn.net/wolf_love666/article/details/87693771</a></p><h1 id="集合类不安全问题"><a href="#集合类不安全问题" class="headerlink" title="集合类不安全问题"></a>集合类不安全问题</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>当我们执行下面语句的时候，底层进行了什么操作</li></ul><pre><code class="hljs java"><span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();</code></pre><p>底层创建了一个空的数组，伴随着初始值为10</p><ul><li>当执行add方法后，如果超过了10，那么会进行扩容，扩容的大小为原值的一半，也就是5个，使用下列方法扩容</li></ul><pre><code class="hljs java">Arrays.copyOf(elementData, netCapacity);</code></pre><h2 id="ArrayList单线程环境下"><a href="#ArrayList单线程环境下" class="headerlink" title="ArrayList单线程环境下"></a>ArrayList单线程环境下</h2><p>单线程环境的ArrayList是不会有问题的</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayListNotSafeDemo</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        list.add(<span class="hljs-string">&quot;a&quot;</span>);        list.add(<span class="hljs-string">&quot;b&quot;</span>);        list.add(<span class="hljs-string">&quot;c&quot;</span>);        <span class="hljs-keyword">for</span>(String element : list) &#123;            System.out.println(element);        &#125;    &#125;&#125;</code></pre><h2 id="多线程环境"><a href="#多线程环境" class="headerlink" title="多线程环境"></a>多线程环境</h2><p>为什么ArrayList是 <strong>线程不安全</strong> 的？因为在进行写操作的时候，方法上为了保证并发性，是 <strong>没有添加synchronized修饰</strong> ，所以并发写的时候，就会出现问题</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210412170344.png"></p><p>当我们同时启动30个线程去操作List的时候</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayListNotSafeDemo</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">30</span>; i++) &#123;            <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;                list.add(UUID.randomUUID().toString().substring(<span class="hljs-number">0</span>, <span class="hljs-number">8</span>));                System.out.println(list);            &#125;, String.valueOf(i)).start();        &#125;    &#125;&#125;</code></pre><p>这个时候出现了错误，也就是java.util.ConcurrentModificationException</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210412170505.png"></p><p>这个异常是  <strong>并发修改的异常</strong> </p><h2 id="ArrayList解决方案"><a href="#ArrayList解决方案" class="headerlink" title="ArrayList解决方案"></a>ArrayList解决方案</h2><h3 id="方案一：Vector"><a href="#方案一：Vector" class="headerlink" title="方案一：Vector"></a>方案一：Vector</h3><p>第一种方法，就是不用ArrayList这种不安全的List实现类，而 <strong>采用Vector</strong> ，线程安全的</p><p>关于Vector如何实现线程安全的，而是在方法上加了锁，即synchronized</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210412171057.png"></p><p>这样就每次只能够一个线程进行操作，所以不会出现线程不安全的问题，但是因为加锁了，导致 <strong>并发性下降</strong> </p><h3 id="方案二：Collections-synchronized"><a href="#方案二：Collections-synchronized" class="headerlink" title="方案二：Collections.synchronized()"></a>方案二：Collections.synchronized()</h3><pre><code class="hljs java">List&lt;String&gt; list = Collections.synchronizedList(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;());</code></pre><p>采用Collections集合工具类，在ArrayList外面包装一层 同步 机制</p><h3 id="方案三：采用JUC里面的方法"><a href="#方案三：采用JUC里面的方法" class="headerlink" title="方案三：采用JUC里面的方法"></a>方案三：采用JUC里面的方法</h3><p>CopyOnWriteArrayList：写时复制，主要是一种 <strong>读写分离</strong> 的思想</p><p>写时复制，CopyOnWrite容器即写时复制的容器，往一个容器中添加元素的时候，不直接往 <strong>当前容器</strong> Object[]添加，而是先将Object[]进行copy， <strong>复制出一个新的容器</strong> object[] newElements，然后新的容器Object[] newElements里添加原始，添加元素完后，在将原容器的引用 <strong>指向新的容器</strong>  setArray(newElements)；这样做的好处是可以对copyOnWrite容器进行并发的度，而不需要加锁，因为当前容器不需要添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器</p><p>就是写的时候，把ArrayList扩容一个出来，然后把值填写上去，在通知其他的线程，ArrayList的引用指向扩容后的</p><p>查看底层add方法源码</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210412172516.png"></p><p>首先需要加锁</p><pre><code class="hljs java"><span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">this</span>.lock;lock.lock();</code></pre><p>然后在末尾扩容一个单位</p><pre><code class="hljs java">Object[] elements = getArray();<span class="hljs-keyword">int</span> len = elements.length;Object[] newElements = Arrays.copyOf(elements, len + <span class="hljs-number">1</span>);</code></pre><p>然后在把扩容后的空间，填写上需要add的内容</p><pre><code class="hljs java">newElements[len] = e;</code></pre><p>最后把内容set到Array中</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210412172718.png"></p><h2 id="HashSet线程不安全"><a href="#HashSet线程不安全" class="headerlink" title="HashSet线程不安全"></a>HashSet线程不安全</h2><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210412174134.png"></p><p>原因也是没有同步机制</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210412174244.png"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210412174310.png"></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="CopyOnWriteArraySet"><a href="#CopyOnWriteArraySet" class="headerlink" title="CopyOnWriteArraySet"></a>CopyOnWriteArraySet</h4><p>底层还是使用CopyOnWriteArrayList进行实例化</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210412174358.png"></p><h4 id="Collections-synchronizedSet"><a href="#Collections-synchronizedSet" class="headerlink" title="Collections.synchronizedSet"></a>Collections.synchronizedSet</h4><h3 id="HashSet底层结构"><a href="#HashSet底层结构" class="headerlink" title="HashSet底层结构"></a>HashSet底层结构</h3><p>HashSet的底层结构就是HashMap</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210412174705.png"></p><p>但是为什么我调用 HashSet.add()的方法，只需要传递一个元素，而HashMap是需要 <strong>传递key-value键值对</strong> ？</p><p>首先我们查看hashSet的 <strong>add方法</strong> </p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;    <span class="hljs-keyword">return</span> map.put(e, PRESENT)==<span class="hljs-keyword">null</span>;&#125;</code></pre><p>我们能发现但我们调用add的时候，存储一个值进入map中，只是作为 <strong>key</strong> 进行存储，而 <strong>value</strong> 存储的是一个Object类型的常量，也就是说HashSet只关心key，而不关心value</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210412174839.png"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210412174858.png"></p><h2 id="HashMap线程不安全"><a href="#HashMap线程不安全" class="headerlink" title="HashMap线程不安全"></a>HashMap线程不安全</h2><p>同理HashMap在多线程环境下，也是不安全的</p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>1、使用Collections.synchronizedMap(new HashMap&lt;&gt;());</p><p>2、使用 ConcurrentHashMap</p><pre><code class="hljs java">Map&lt;String, String&gt; map = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;&gt;();</code></pre><h1 id="TransferValue是什么"><a href="#TransferValue是什么" class="headerlink" title="TransferValue是什么"></a><strong>TransferValue是什么</strong></h1><h2 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h2><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;    <span class="hljs-keyword">private</span> Integer id;    <span class="hljs-keyword">private</span> String personName;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(String personName)</span> </span>&#123;        <span class="hljs-keyword">this</span>.personName = personName;    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TransferValueDemo</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">changeValue1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;        age = <span class="hljs-number">30</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">changeValue2</span><span class="hljs-params">(Person person)</span> </span>&#123;        person.setPersonName(<span class="hljs-string">&quot;XXXX&quot;</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">changeValue3</span><span class="hljs-params">(String str)</span> </span>&#123;        str = <span class="hljs-string">&quot;XXX&quot;</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        TransferValueDemo test = <span class="hljs-keyword">new</span> TransferValueDemo();        <span class="hljs-comment">// 定义基本数据类型</span>        <span class="hljs-keyword">int</span> age = <span class="hljs-number">20</span>;        test.changeValue1(age);        System.out.println(<span class="hljs-string">&quot;age ----&quot;</span> + age);        <span class="hljs-comment">// 实例化person类</span>        Person person = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;abc&quot;</span>);        test.changeValue2(person);        System.out.println(<span class="hljs-string">&quot;personName-----&quot;</span> + person.getPersonName());        <span class="hljs-comment">// String</span>        String str = <span class="hljs-string">&quot;abc&quot;</span>;        test.changeValue3(str);        System.out.println(<span class="hljs-string">&quot;string-----&quot;</span> + str);    &#125;&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210412175818.png"></p><h2 id="changeValue1的执行过程"><a href="#changeValue1的执行过程" class="headerlink" title="changeValue1的执行过程"></a>changeValue1的执行过程</h2><p>八种基本数据类型，在栈里面分配内存，属于 <strong>值传递</strong> </p><pre><code class="hljs plain">栈管运行，堆管存储</code></pre><p>当们执行 changeValue1的时候，因为int是基本数据类型，所以传递的是int = 20这个值，相当于传递的是一个 <strong>副本</strong> ，main方法里面的age并没有改变，因此输出的结果 age还是20，属于值传递</p><p>打印的age一直都是main方法的，传入函数的age是一个副本；</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210412180107.png"></p><h2 id="changeValue2的执行过程"><a href="#changeValue2的执行过程" class="headerlink" title="changeValue2的执行过程"></a>changeValue2的执行过程</h2><p>因为Person是属于对象， <strong>传递的是内存地址</strong> ，当执行changeValue2的时候，会改变内存中的Person的值，属于 <strong>引用传递</strong> ，两个指针都是指向同一个地址</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210412180148.png"></p><h2 id="changeValue3的执行过程"><a href="#changeValue3的执行过程" class="headerlink" title="changeValue3的执行过程"></a>changeValue3的执行过程</h2><p>String不属于基本数据类型，但是为什么执行完成后，还是abc呢？</p><p>这是因为String的特殊性，当我们执行String str = “abc”的时候，它会把 <code>abc</code> 放入常量池中</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210412180300.png"></p><p>当我们执行changeValue3的时候，会重新 <strong>新建一个xxx</strong> ，并 <strong>没有销毁abc</strong> ，然后指向xxx，然后最后我们输出的是   <strong>main中的引用</strong> ，还是指向的abc，因此最后输出结果还是abc</p><h1 id="Java的锁"><a href="#Java的锁" class="headerlink" title="Java的锁"></a><strong>Java的锁</strong></h1><h2 id="lock和Synchronized的区别"><a href="#lock和Synchronized的区别" class="headerlink" title="lock和Synchronized的区别"></a>lock和Synchronized的区别</h2><ol><li><p>synchronized属于JVM层面，属于java的 <strong>关键字</strong> </p><ul><li><p>monitorenter（底层是通过monitor对象来完成，其实wait/notify等方法也依赖于monitor对象 只能在 <strong>同步块或者方法中</strong> 才能调用 wait/ notify等方法）</p></li><li><p>Lock是 <strong>具体类</strong> （java.util.concurrent.locks.Lock）是api层面的锁<br><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210415100641.png"></p></li><li><p>synchronized底层的monitor有两种退出方式，正常和异常退出，保证不会产生死锁</p></li><li><p>lock是new出来的</p></li></ul></li><li><p>使用方法：</p><ul><li>synchronized： <strong>不需要用户去手动释放锁</strong> ，当synchronized代码执行后，系统会自动让线程释放对锁的占用。</li><li>ReentrantLock：则需要用户去手动释放锁，若没有主动释放锁，就有可能出现死锁的现象，需要lock() 和 unlock() 配置try catch语句来完成</li></ul></li><li><p>等待是否中断</p><ul><li>synchronized：不可中断，除非抛出异常或者正常运行完成。</li><li>ReentrantLock： <strong>可中断</strong> ，可以设置 <strong>超时方法</strong> <ul><li>设置超时方法，trylock(long timeout, TimeUnit unit)</li><li>lockInterrupible() 放代码块中，调用interrupt() 方法可以中断</li></ul></li></ul></li><li><p>加锁是否公平<br>synchronized：非公平锁<br>ReentrantLock：默认非公平锁，构造函数可以传递boolean值，true为公平锁，false为非公平锁</p></li><li><p>锁绑定多个条件Condition<br>synchronized：没有，要么随机，要么全部唤醒<br>ReentrantLock：用来实现分组唤醒需要唤醒的线程，可以 <strong>精确唤醒</strong> ，而不是像synchronized那样，要么随机，要么全部唤醒</p></li></ol><h3 id="锁绑定多个条件Condition"><a href="#锁绑定多个条件Condition" class="headerlink" title="锁绑定多个条件Condition"></a>锁绑定多个条件Condition</h3><p><strong>实现场景</strong></p><p>多线程之间按顺序调用，实现 A-&gt; B -&gt; C 三个线程启动，要求如下：<br>AA打印5次，BB打印10次，CC打印15次<br>紧接着<br>AA打印5次，BB打印10次，CC打印15次<br>…<br>来10轮</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Code17_MoreConditionDemo</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        ShareNewData shareResource = <span class="hljs-keyword">new</span> ShareNewData();        <span class="hljs-keyword">int</span> num = <span class="hljs-number">10</span>;        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; num; i++) &#123;                shareResource.print5();            &#125;        &#125;, <span class="hljs-string">&quot;A&quot;</span>).start();        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; num; i++) &#123;                shareResource.print10();            &#125;        &#125;, <span class="hljs-string">&quot;B&quot;</span>).start();        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; num; i++) &#123;                shareResource.print15();            &#125;        &#125;, <span class="hljs-string">&quot;C&quot;</span>).start();    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShareNewData</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> number = <span class="hljs-number">1</span>;    <span class="hljs-keyword">private</span> Lock lock = <span class="hljs-keyword">new</span> ReentrantLock();    <span class="hljs-comment">// 设置三把钥匙</span>    Condition condition1 = lock.newCondition();    Condition condition2 = lock.newCondition();    Condition condition3 = lock.newCondition();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print5</span><span class="hljs-params">()</span></span>&#123;        lock.lock();        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">// 判断</span>            <span class="hljs-keyword">while</span> (number != <span class="hljs-number">1</span>)&#123;                <span class="hljs-comment">// 等待</span>                condition1.await();            &#125;            <span class="hljs-comment">// 干活</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;                System.out.println(Thread.currentThread() + <span class="hljs-string">&quot;优先级&quot;</span> + number +<span class="hljs-string">&quot; 打印5&quot;</span>);            &#125;            <span class="hljs-comment">// 唤醒</span>            number = <span class="hljs-number">2</span>;            condition2.signal();        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;<span class="hljs-keyword">finally</span> &#123;            lock.unlock();        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print10</span><span class="hljs-params">()</span></span>&#123;        lock.lock();        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">while</span> (number != <span class="hljs-number">2</span>)&#123;                condition2.await();            &#125;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;                System.out.println(Thread.currentThread() + <span class="hljs-string">&quot;优先级&quot;</span> + number +<span class="hljs-string">&quot; 打印10&quot;</span>);            &#125;            number = <span class="hljs-number">3</span>;            condition3.signal();        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;<span class="hljs-keyword">finally</span> &#123;            lock.unlock();        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print15</span><span class="hljs-params">()</span></span>&#123;        lock.lock();        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">while</span> (number != <span class="hljs-number">3</span>)&#123;                condition3.await();            &#125;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">15</span>; i++) &#123;                System.out.println(Thread.currentThread() + <span class="hljs-string">&quot;优先级&quot;</span> + number +<span class="hljs-string">&quot; 打印15&quot;</span>);            &#125;number = <span class="hljs-number">1</span>;            condition1.signal();        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;<span class="hljs-keyword">finally</span> &#123;            lock.unlock();        &#125;    &#125;&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210415102711.png"></p><h2 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><h4 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h4><p>是指多个线程按照 <strong>申请锁的顺序</strong> 来获取锁，类似于排队买饭，先来后到，先来先服务，就是公平的，也就是 <strong>队列</strong> </p><h4 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a>非公平锁</h4><p>是指多个线程获取锁的顺序，并不是按照申请锁的顺序，有可能申请的线程比先申请的线程优先获取锁，在高并发环境下，有可能造成 <strong>优先级翻转</strong> ，或者 <strong>饥饿</strong> 的线程（也就是某个线程一直得不到锁）</p><h3 id="如何创建"><a href="#如何创建" class="headerlink" title="如何创建"></a>如何创建</h3><p>并发包中 <strong>ReentrantLock</strong> 的创建可以指定 <strong>析构函数</strong> 的boolean类型来得到公平锁或者非公平锁，默认是非公平锁</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">* 创建一个可重入锁，true 表示公平锁，false 表示非公平锁。默认非公平锁</span><span class="hljs-comment">*/</span>Lock lock = <span class="hljs-keyword">new</span> ReentrantLock(<span class="hljs-keyword">true</span>);</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210412192606.png"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210412192713.png"></p><h3 id="两者区别"><a href="#两者区别" class="headerlink" title="两者区别"></a>两者区别</h3><p><strong>公平锁</strong>：就是很公平，在并发环境中，每个线程在获取锁时会先查看此锁维护的等待队列，如果为空，或者当前线程是等待队列中的第一个，就占用锁，否者就会加入到等待队列中，以后按照 <strong>FIFO</strong> 的规则从队列中取到自己</p><p><strong>非公平锁：</strong> 非公平锁比较粗鲁，上来就直接尝试占有锁，如果尝试失败，就 <strong>再采用类似公平锁</strong> 那种方式。</p><h3 id="题外"><a href="#题外" class="headerlink" title="题外"></a>题外</h3><p>Java ReenttrantLock通过构造函数指定该锁是否公平，默认是非公平锁，因为非公平锁的优点在于 <strong>吞吐量</strong> 比公平锁大；</p><p><code>对于synchronized而言，也是一种非公平锁</code></p><h2 id="可重入锁-递归锁"><a href="#可重入锁-递归锁" class="headerlink" title="可重入锁(递归锁)"></a>可重入锁(递归锁)</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><p>可重入锁就是 <strong>递归锁</strong> </p><p>指的是同一线程外层函数获得锁之后，内层递归函数仍然能获取到该锁的代码，在同一线程在外层方法获取锁的时候，在进入内层方法会自动获取锁</p><p>也就是说：<code>线程可以进入任何一个它已经拥有的锁所同步的代码块</code></p><p> <strong>ReentrantLock / Synchronized</strong> 就是一个典型的可重入锁</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>可重入锁就是，在一个method1方法中加入一把锁，方法2也加锁了，那么他们拥有的是 <strong>同一把锁</strong> </p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">// 大门锁</span>  method2();<span class="hljs-comment">// 大门锁和小门锁变成一把锁</span>&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">// 小门锁</span>  &#125;</code></pre><p>也就是说我们只需要进入method1后，那么它也能直接进入method2方法，因为他们所拥有的锁，是同一把。</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>可重入锁的最大作用就是 <strong>避免死锁</strong> </p><h3 id="可重入锁验证"><a href="#可重入锁验证" class="headerlink" title="可重入锁验证"></a>可重入锁验证</h3><h4 id="证明Synchronized"><a href="#证明Synchronized" class="headerlink" title="证明Synchronized"></a>证明Synchronized</h4><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 资源类</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Phone</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 发送短信</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendSMS</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t invoked sendSMS()&quot;</span>);        <span class="hljs-comment">// 在同步方法中，调用另外一个同步方法</span>        sendEmail();    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 发邮件</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendEmail</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;        System.out.println(Thread.currentThread().getId() + <span class="hljs-string">&quot;\t invoked sendEmail()&quot;</span>);    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReenterLockDemo</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Phone phone = <span class="hljs-keyword">new</span> Phone();        <span class="hljs-comment">// 两个线程操作资源列</span>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            <span class="hljs-keyword">try</span> &#123;                phone.sendSMS();            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            <span class="hljs-keyword">try</span> &#123;                phone.sendSMS();            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();    &#125;&#125;</code></pre><p>在这里，我们编写了一个资源类phone，拥有两个加了synchronized的同步方法，分别是sendSMS 和 sendEmail，我们在sendSMS方法中，调用sendEmail。最后在主线程同时开启了两个线程进行测试，最后得到的结果为：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210413105219.png"></p><p>这就说明当 t1 线程进入sendSMS的时候，拥有了一把锁，同时t2线程无法进入，直到t1线程拿着锁，执行了sendEmail 方法后，才释放锁，这样t2才能够进入</p><pre><code class="hljs javascript">t1   invoked sendSMS()      t1线程在外层方法获取锁的时候t1   invoked sendEmail()    t1在进入内层方法会自动获取锁t2   invoked sendSMS()      t2线程在外层方法获取锁的时候t2   invoked sendEmail()    t2在进入内层方法会自动获取锁</code></pre><h4 id="证明ReentrantLock"><a href="#证明ReentrantLock" class="headerlink" title="证明ReentrantLock"></a>证明ReentrantLock</h4><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 资源类</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Phone</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;    Lock lock = <span class="hljs-keyword">new</span> ReentrantLock();    <span class="hljs-comment">/**</span><span class="hljs-comment">     * set进去的时候，就加锁，调用set方法的时候，能否访问另外一个加锁的set方法</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getLock</span><span class="hljs-params">()</span> </span>&#123;        lock.lock();        <span class="hljs-keyword">try</span> &#123;            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t get Lock&quot;</span>);            setLock();        &#125; <span class="hljs-keyword">finally</span> &#123;            lock.unlock();        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLock</span><span class="hljs-params">()</span> </span>&#123;        lock.lock();        <span class="hljs-keyword">try</span> &#123;            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t set Lock&quot;</span>);        &#125; <span class="hljs-keyword">finally</span> &#123;            lock.unlock();        &#125;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        getLock();    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReenterLockDemo</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Phone phone = <span class="hljs-keyword">new</span> Phone();        <span class="hljs-comment">/**</span><span class="hljs-comment">         * 因为Phone实现了Runnable接口</span><span class="hljs-comment">         */</span>        Thread t3 = <span class="hljs-keyword">new</span> Thread(phone, <span class="hljs-string">&quot;t3&quot;</span>);        Thread t4 = <span class="hljs-keyword">new</span> Thread(phone, <span class="hljs-string">&quot;t4&quot;</span>);        t3.start();        t4.start();    &#125;&#125;</code></pre><p>我们使用ReentrantLock进行验证，首先资源类实现了Runnable接口，重写Run方法，里面调用get方法，get方法在进入的时候，就加了锁</p><p>然后在方法里面，又调用另外一个加了锁的setLock方法</p><p>最后输出结果我们能发现，结果和加synchronized方法是一致的，都是在 <strong>外层的方法获取锁之后，线程能够直接进入里层</strong> </p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210413105930.png"></p><blockquote><p>如果加两把锁</p></blockquote><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210414075812.png"></p><p>Lock, unlock只要配对就行了；</p><p>最后得到的结果也是一样的，因为里面不管有几把锁，其它他们都是同一把锁，也就是说用同一个钥匙都能够打开</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210414075933.png"></p><blockquote><p>如果缺一个unlock</p></blockquote><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210414080126.png"></p><p>也就是说程序直接卡死，线程不能出来，也就说明我们申请几把锁，最后需要解除几把锁</p><p> <strong>当我们只加一把锁，但是用两把锁来解锁的时候，又会出现什么情况呢？</strong> </p><p>这个时候，运行程序会直接报错</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210414080330.png"></p><h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><p>自旋锁：spinlock，是指尝试获取锁的线程不会立即阻塞，而是采用 <strong>循环</strong> 的方式去尝试 <strong>获取锁</strong> ，这样的好处是 <strong>减少线程上下文切换的消耗</strong> ，缺点是 <strong>循环会消耗CPU</strong> </p><p>原来提到的CAS，底层使用的就是自旋，自旋就是多次尝试，多次访问， <strong>不会阻塞</strong> 的状态就是自旋。</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210414081207.png"></p><h3 id="手写自旋锁"><a href="#手写自旋锁" class="headerlink" title="手写自旋锁"></a>手写自旋锁</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Code10_SpinLockDemo</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpinLockDemo lock = <span class="hljs-keyword">new</span> SpinLockDemo();        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            lock.myLock();            <span class="hljs-comment">// t1等待5s</span>            <span class="hljs-keyword">try</span> &#123;                TimeUnit.SECONDS.sleep(<span class="hljs-number">5</span>);            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;            lock.unLock();        &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();        <span class="hljs-keyword">try</span> &#123;            TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            lock.myLock();            lock.unLock();        &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpinLockDemo</span></span>&#123;    <span class="hljs-comment">// 持有锁的线程，null表示锁未被线程持有</span>    AtomicReference&lt;Thread&gt; atomicReference = <span class="hljs-keyword">new</span> AtomicReference&lt;&gt;();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">myLock</span><span class="hljs-params">()</span></span>&#123;        Thread thread = Thread.currentThread();        System.out.println(thread.getName() + <span class="hljs-string">&quot;: come in!&quot;</span>);        <span class="hljs-keyword">while</span> (!atomicReference.compareAndSet(<span class="hljs-keyword">null</span>, thread))&#123;            <span class="hljs-comment">//当atomicReference为null的时候compareAndSet返回true，反之为false</span>            <span class="hljs-comment">//通过循环不断的自旋判断锁是否被其他线程持有</span>            System.out.println(thread.getName() + <span class="hljs-string">&quot; 自旋....&quot;</span>);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unLock</span><span class="hljs-params">()</span></span>&#123;        Thread thread = Thread.currentThread();        <span class="hljs-comment">// 解锁可以追加判断是否为当前线程 单CAS可以预判断期待值</span>        atomicReference.compareAndSet(thread, <span class="hljs-keyword">null</span>);        System.out.println(thread.getName() + <span class="hljs-string">&quot;: destory!&quot;</span>);    &#125;&#125;</code></pre><p>输出结果：</p><p>一开始：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210414084139.png"></p><p>t1进去占用线程，t2也进去，但循环判断，开始自旋</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210414084243.png"></p><p>然后1秒后，t2线程启动，发现锁被t1占有，所有不断的执行 compareAndSet方法，来进行比较，直到t1释放锁后，也就是5秒后，t2成功获取到锁，然后释放</p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：循环比较获取直到成功为止， <strong>没有</strong> 类似于wait的 <strong>阻塞</strong> </p><p>缺点：当不断自旋的线程越来越多的时候，会因为执行while循环不断的消耗CPU资源</p><h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><h3 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h3><p> <strong>独占锁</strong> ：指该锁一次只能被 <strong>一个线程</strong> 所持有。对ReentrantLock和Synchronized而言都是独占锁</p><p> <strong>共享锁</strong> ：指该锁可以被 <strong>多个线程锁持有</strong> </p><p>对ReentrantReadWriteLock其 <strong>读锁</strong> 是共享，其 <strong>写锁</strong> 是独占</p><p>写的时候只能一个人写，但是读的时候，可以多个人同时读</p><h3 id="为什么会有写锁和读锁"><a href="#为什么会有写锁和读锁" class="headerlink" title="为什么会有写锁和读锁"></a>为什么会有写锁和读锁</h3><p>原来我们使用ReentrantLock创建锁的时候，是独占锁，也就是说一次只能一个线程访问，但是有一个读写分离场景，读的时候想同时进行，因此原来独占锁的并发性就没这么好了，因为 <strong>读锁并不会造成数据不一致</strong> 的问题，因此可以多个人 <strong>共享读</strong> </p><pre><code class="hljs plain">多个线程 同时读一个资源类没有任何问题，所以为了满足并发量，读取共享资源应该可以同时进行，但是如果一个线程想去写共享资源，就不应该再有其它线程可以对该资源进行读或写</code></pre><p>读-读：能共存</p><p>读-写：不能共存</p><p>写-写：不能共存</p><h3 id="手写代码"><a href="#手写代码" class="headerlink" title="手写代码"></a>手写代码</h3><p>实现一个 <strong>读写缓存的操作</strong> ，假设开始 <strong>没有加锁</strong> 的时候，会出现什么情况</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 读写锁</span><span class="hljs-comment"> * 多个线程 同时读一个资源类没有任何问题，所以为了满足并发量，读取共享资源应该可以同时进行</span><span class="hljs-comment"> * 但是，如果一个线程想去写共享资源，就不应该再有其它线程可以对该资源进行读或写</span><span class="hljs-comment"> *</span><span class="hljs-comment"> */</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * 资源类</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCache</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    <span class="hljs-comment">// private Lock lock = null;</span>    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 定义写操作</span><span class="hljs-comment">     * 满足：原子 + 独占</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(String key, Object value)</span> </span>&#123;        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 正在写入：&quot;</span> + key);        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">// 模拟网络拥堵，延迟0.3秒</span>            TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">300</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        map.put(key, value);        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 写入完成&quot;</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">get</span><span class="hljs-params">(String key)</span> </span>&#123;        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 正在读取:&quot;</span>);        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">// 模拟网络拥堵，延迟0.3秒</span>            TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">300</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        Object value = map.get(key);        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 读取完成：&quot;</span> + value);    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Code11_ReadWriteLockDemo</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        MyCache myCache = <span class="hljs-keyword">new</span> MyCache();        <span class="hljs-comment">// 线程操作资源类，5个线程写</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;            <span class="hljs-comment">// lambda表达式内部必须是final</span>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> tempInt = i;            <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;                myCache.put(tempInt + <span class="hljs-string">&quot;&quot;</span>, tempInt +  <span class="hljs-string">&quot;&quot;</span>);            &#125;, String.valueOf(i)).start();        &#125;        <span class="hljs-comment">// 线程操作资源类， 5个线程读</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;            <span class="hljs-comment">// lambda表达式内部必须是final</span>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> tempInt = i;            <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;                myCache.get(tempInt + <span class="hljs-string">&quot;&quot;</span>);            &#125;, String.valueOf(i)).start();        &#125;    &#125;&#125;</code></pre><p>没有加锁的情况下：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210414160436.png"></p><p>在写入的时候，写操作都没完成，其它线程就打断了，这就造成了，还没写完，其它线程又开始读，这样就造成数据不一致</p><h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><p>上面的代码是 <strong>没有加锁</strong> 的，这样就会造成线程在进行写入操作的时候，被其它线程频繁打断，从而不具备原子性，这个时候，我们就需要用到 <strong>读写锁</strong> 来解决了</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 资源类</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyNewCache</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 缓存中的东西，必须保持可见性，因此使用volatile修饰</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 创建一个读写锁</span><span class="hljs-comment">     * 它是一个读写融为一体的锁，在使用的时候，需要转换</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> ReentrantReadWriteLock rwLock = <span class="hljs-keyword">new</span> ReentrantReadWriteLock();    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 定义写操作</span><span class="hljs-comment">     * 满足：原子 + 独占</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(String key, Object value)</span> </span>&#123;        <span class="hljs-comment">// 创建一个写锁</span>        rwLock.writeLock().lock();        <span class="hljs-keyword">try</span> &#123;            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 正在写入：&quot;</span> + key);            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-comment">// 模拟网络拥堵，延迟0.3秒</span>                TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">300</span>);            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;            map.put(key, value);            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 写入完成&quot;</span>);        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">finally</span> &#123;            <span class="hljs-comment">// 写锁 释放</span>            rwLock.writeLock().unlock();        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 获取</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">get</span><span class="hljs-params">(String key)</span> </span>&#123;        <span class="hljs-comment">// 读锁</span>        rwLock.readLock().lock();        <span class="hljs-keyword">try</span> &#123;            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 正在读取:&quot;</span>);            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-comment">// 模拟网络拥堵，延迟0.3秒</span>                TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">300</span>);            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;            Object value = map.get(key);            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 读取完成：&quot;</span> + value);        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">finally</span> &#123;            <span class="hljs-comment">// 读锁释放</span>            rwLock.readLock().unlock();        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 清空缓存</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clean</span><span class="hljs-params">()</span> </span>&#123;        map.clear();    &#125;    &#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210414160844.png"></p><p>从运行结果我们可以看出，写入操作是 <strong>一个一个线程</strong> 进行执行的，并且中间不会被打断，而读操作的时候，是 <strong>同时5个线程进入</strong> ，然后 <strong>并发读</strong> 取操作</p><h1 id="JUC一些包"><a href="#JUC一些包" class="headerlink" title="JUC一些包"></a>JUC一些包</h1><h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><h3 id="概念-4"><a href="#概念-4" class="headerlink" title="概念"></a>概念</h3><p>让一些 <strong>线程阻塞</strong> 直到另一些线程完成一系列操作才被 <strong>唤醒</strong> </p><p>CountDownLatch主要有 <strong>两个方法</strong> ，当一个或多个线程调用await方法时，调用线程就会被阻塞。其它线程调用CountDown方法会将计数器减1（调用CountDown方法的线程不会被阻塞），当计数器的值变成零时，因调用await方法被阻塞的线程会被唤醒，继续执行</p><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>现在有这样一个场景，假设一个自习室里有7个人，其中有一个是班长，班长的主要职责就是在其它6个同学走了后，关灯，锁教室门，然后走人，因此班长是需要最后一个走的，那么有什么方法能够控制班长这个线程是最后一个执行，而其它线程是随机执行的</p><h3 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h3><p>这个时候就用到了CountDownLatch，计数器了。我们一共创建 <strong>6个线程</strong> ，然后 <strong>计数器</strong> 的值也设置成6</p><p>然后每次学生线程执行完，就让计数器的值减1</p><p>最后我们需要通过CountDownLatch的await方法来控制班长主线程的执行，这里 countDownLatch.await()可以想成是一道墙，只有当计数器的值为0的时候，墙才会消失，主线程才能继续往下执行</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;    <span class="hljs-comment">// 计数器</span>    CountDownLatch countDownLatch = <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">6</span>);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">6</span>; i++) &#123;        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 上完自习，离开教室&quot;</span>);            countDownLatch.countDown();        &#125;, String.valueOf(i)).start();    &#125;    countDownLatch.await();    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 班长最后关门&quot;</span>);&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210414164311.png"></p><p>引入CountDownLatch后的执行结果，我们能够控制住main方法的执行，这样能够保证前提任务的执行</p><h3 id="枚举优化拓展"><a href="#枚举优化拓展" class="headerlink" title="枚举优化拓展"></a>枚举优化拓展</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210414165748.png"></p><h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><h3 id="概念-5"><a href="#概念-5" class="headerlink" title="概念"></a>概念</h3><p>和CountDownLatch相反，需要集齐七颗龙珠，召唤神龙。也就是 <strong>做加法</strong> ，开始是0，加到某个值的时候就执行</p><p>CyclicBarrier的字面意思就是可循环（cyclic）使用的屏障（Barrier）。它要求做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活，线程进入屏障通过CyclicBarrier的await方法</p><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>集齐7个龙珠，召唤神龙的Demo，我们需要首先创建CyclicBarrier（ <strong>第二个参数为被阻塞的线程</strong> ）</p><p>然后同时编写七个线程，进行龙珠收集，但一个线程收集到了的时候，我们需要让他执行await方法，等待到7个线程全部执行完毕后，我们就执行原来定义好的方法</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 定义一个循环屏障，参数1：需要累加的值，参数2 需要执行的方法</span><span class="hljs-comment">     */</span>    CyclicBarrier cyclicBarrier = <span class="hljs-keyword">new</span> CyclicBarrier(<span class="hljs-number">7</span>, () -&gt; &#123;        System.out.println(<span class="hljs-string">&quot;召唤神龙&quot;</span>);    &#125;);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">7</span>; i++) &#123;        <span class="hljs-keyword">final</span> Integer tempInt = i;        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 收集到 第&quot;</span> + tempInt + <span class="hljs-string">&quot;颗龙珠&quot;</span>);            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-comment">// 先到的被阻塞，等全部线程完成后，才能执行方法</span>                cyclicBarrier.await();            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125; <span class="hljs-keyword">catch</span> (BrokenBarrierException e) &#123;                e.printStackTrace();            &#125;        &#125;, String.valueOf(i)).start();    &#125;&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210414165944.png"></p><h2 id="Semaphore：信号量"><a href="#Semaphore：信号量" class="headerlink" title="Semaphore：信号量"></a>Semaphore：信号量</h2><h3 id="概念-6"><a href="#概念-6" class="headerlink" title="概念"></a>概念</h3><p>信号量主要用于两个目的</p><ul><li>一个是用于 <strong>共享资源</strong> 的 <strong>互斥</strong> 使用</li><li>另一个用于 <strong>并发线程数</strong> 的控制</li></ul><h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><p>我们模拟一个抢车位的场景，假设一共有 <strong>6个车，3个停车位</strong> </p><p>那么我们首先需要定义信号量为3，也就是3个停车位</p><p>然后我们模拟6辆车同时并发抢占停车位，但第一个车辆抢占到停车位后， <strong>信号量需要减1</strong> </p><p>同时车辆假设需要等待3秒后， <strong>释放信号量</strong> </p><p>最后车辆离开，释放信号量</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 初始化一个信号量为3，默认是false 非公平锁， 模拟3个停车位</span><span class="hljs-comment">     */</span>    Semaphore semaphore = <span class="hljs-keyword">new</span> Semaphore(<span class="hljs-number">3</span>, <span class="hljs-keyword">false</span>);    <span class="hljs-comment">// 模拟6部车</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; i++) &#123;        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-comment">// 代表一辆车，已经占用了该车位</span>                semaphore.acquire(); <span class="hljs-comment">// 抢占</span>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 抢到车位&quot;</span>);                <span class="hljs-comment">// 每个车停3秒</span>                <span class="hljs-keyword">try</span> &#123;                    TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>);                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                &#125;                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 离开车位&quot;</span>);            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125; <span class="hljs-keyword">finally</span> &#123;                <span class="hljs-comment">// 释放停车位</span>                semaphore.release();            &#125;        &#125;, String.valueOf(i)).start();    &#125;&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210414170931.png"></p><h1 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h1><h2 id="概念-7"><a href="#概念-7" class="headerlink" title="概念"></a>概念</h2><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>队列就可以想成是一个数组，从一头进入，一头出去，排队买饭</p><h3 id="阻塞队列-1"><a href="#阻塞队列-1" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><p>BlockingQueue 阻塞队列，排队拥堵，首先它是一个队列，而一个阻塞队列在数据结构中所起的作用大致如下图所示：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210414171141.png"></p><p>线程1往阻塞队列中 <strong>添加元素</strong> ，而线程2从阻塞队列中 <strong>移除元素</strong> </p><ul><li><code>当阻塞队列是空时，从队列中获取元素的操作将会被阻塞</code><ul><li>当蛋糕店的柜子空的时候， <strong>无法</strong> 从柜子里面获取蛋糕</li></ul></li><li><code>当阻塞队列是满时，从队列中添加元素的操作将会被阻塞</code><ul><li>当蛋糕店的柜子满的时候， <strong>无法</strong> 继续向柜子里面添加蛋糕了</li></ul></li></ul><p>也就是说 试图从空的阻塞队列中获取元素的线程将会被阻塞，直到其它线程往空的队列插入新的元素</p><p>同理，试图往已经满的阻塞队列中添加新元素的线程，直到其它线程往满的队列中移除一个或多个元素，或者完全清空队列后，使队列重新变得空闲起来，并后续新增</p><h2 id="为什么要用？"><a href="#为什么要用？" class="headerlink" title="为什么要用？"></a>为什么要用？</h2><p>去海底捞吃饭，大厅满了，需要进候厅等待，但是这些等待的客户能够对商家带来利润，因此我们非常欢迎他们阻塞</p><p>在多线程领域：所谓的阻塞，在某些清空下会 <strong>挂起线程（即阻塞）</strong> ，一旦条件满足，被挂起的线程又会 <strong>自动唤醒</strong> </p><h3 id="为什么需要BlockingQueue"><a href="#为什么需要BlockingQueue" class="headerlink" title="为什么需要BlockingQueue"></a>为什么需要BlockingQueue</h3><p>好处是我们 <strong>不需要关心什么时候</strong> 需要阻塞线程，什么时候需要唤醒线程，因为这一切BlockingQueue都帮你一手包办了</p><p>在concurrent包发布以前，在多线程环境下，我们每个程序员都必须自己取控制这些细节，尤其还要兼顾效率和线程安全，而这会给我们的程序带来不小的复杂度。</p><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>BlockingQueue阻塞队列是属于一个 <strong>接口</strong> ，底下有 <strong>七个实现类</strong> </p><ul><li> <strong>ArrayBlockQueue</strong> ：由数组结构组成的 <strong>有界阻塞队列</strong> (数组该有个初始值)</li><li><strong>LinkedBlockingQueue</strong> ：由链表结构组成的 <strong>有界</strong> （但是默认大小  <strong>Integer.MAX_VALUE</strong> ）的阻塞队列<ul><li>有界，但是界限非常大，相当于无界，可以当成无界</li></ul></li><li>PriorityBlockQueue：支持优先级排序的无界阻塞队列</li><li>DelayQueue：使用优先级队列实现的延迟无界阻塞队列</li><li><strong>SynchronousQueue</strong> ： <strong>不存储元素</strong> 的阻塞队列，也即单个元素的队列<ul><li>生产一个，消费一个，不存储元素，不消费不生产</li></ul></li><li>LinkedTransferQueue：由链表结构组成的无界阻塞队列</li><li>LinkedBlockingDeque：由链表结构组成的 <strong>双向</strong> 阻塞队列</li></ul><p>这里需要掌握的是：ArrayBlockQueue、LinkedBlockingQueue、SynchronousQueue</p><h2 id="BlockingQueue核心方法"><a href="#BlockingQueue核心方法" class="headerlink" title="BlockingQueue核心方法"></a>BlockingQueue核心方法</h2><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210415084245.png"></p><table><thead><tr><th>抛出异常</th><th>当阻塞队列满时：在往队列中add插入元素会抛出 IIIegalStateException：Queue full 当阻塞队列空时：再往队列中remove移除元素，会抛出NoSuchException</th></tr></thead><tbody><tr><td>特殊性</td><td>插入方法，成功true，失败false 移除方法：成功返回出队列元素，队列没有就返回空</td></tr><tr><td>一直阻塞</td><td>当阻塞队列满时，生产者继续往队列里put元素，队列会一直阻塞生产线程直到put数据or响应中断退出， 当阻塞队列空时，消费者线程试图从队列里take元素，队列会一直阻塞消费者线程直到队列可用。</td></tr><tr><td>超时退出</td><td>当阻塞队列满时，队里会阻塞生产者线程一定时间，超过限时后生产者线程会退出</td></tr></tbody></table><h3 id="抛出异常组"><a href="#抛出异常组" class="headerlink" title="抛出异常组"></a>抛出异常组</h3><h4 id="add-异常"><a href="#add-异常" class="headerlink" title="add 异常"></a>add 异常</h4><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210415084733.png"></p><p>执行add方法，向 <strong>已经满的</strong> ArrayBlockingQueue中添加元素时候，会抛出异常</p><h4 id="remove异常"><a href="#remove异常" class="headerlink" title="remove异常"></a>remove异常</h4><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210415084912.png"></p><p>如果我们 <strong>多取出</strong> 元素的时候，也会抛出异常，我们假设只存储了3个值，但是取的时候，取了四次</p><h4 id="element"><a href="#element" class="headerlink" title="element"></a>element</h4><p>element首先检测队列是否为空，再返回队首</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210415085205.png"></p><h3 id="特殊值组"><a href="#特殊值组" class="headerlink" title="特殊值组"></a>特殊值组</h3><h4 id="offer和poll"><a href="#offer和poll" class="headerlink" title="offer和poll"></a>offer和poll</h4><p>我们使用 offer的方法，添加元素时候，如果阻塞队列满了后，会返回false，否者返回true</p><p>同时在取的时候，如果队列已空，那么会返回null</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210415085420.png"></p><h3 id="阻塞队列组"><a href="#阻塞队列组" class="headerlink" title="阻塞队列组"></a>阻塞队列组</h3><p>我们使用 put的方法，添加元素时候，如果阻塞队列满了后，添加消息的线程，会一直 <strong>阻塞</strong> ，直到队列元素减少，会被清空，才会 <strong>唤醒</strong> </p><p>一般在消息中间件，比如 <strong>RabbitMQ</strong> 中会使用到，因为需要保证消息 <strong>百分百不丢失</strong> ，因此只有让它阻塞</p><p>同时使用take取消息的时候，如果内容不存在的时候， <strong>也会被阻塞</strong> </p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210415085722.png"></p><h3 id="不见不散组"><a href="#不见不散组" class="headerlink" title="不见不散组"></a>不见不散组</h3><p>offer( ) ， poll 加时间</p><p>使用offer插入的时候，需要 <strong>指定时间</strong> ，如果2秒还没有插入，那么就放弃插入</p><pre><code class="hljs java">BlockingQueue&lt;String&gt; blockingQueue = <span class="hljs-keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="hljs-number">3</span>);System.out.println(blockingQueue.offer(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-number">2L</span>, TimeUnit.SECONDS));System.out.println(blockingQueue.offer(<span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-number">2L</span>, TimeUnit.SECONDS));System.out.println(blockingQueue.offer(<span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-number">2L</span>, TimeUnit.SECONDS));System.out.println(blockingQueue.offer(<span class="hljs-string">&quot;d&quot;</span>, <span class="hljs-number">2L</span>, TimeUnit.SECONDS));</code></pre><p>同时取的时候也进行判断,如果2秒内取不出来，那么就返回null</p><h2 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h2><p>SynchronousQueue <strong>没有容量</strong> ，与其他BlockingQueue不同，SynchronousQueue是一个不存储的BlockingQueue， <strong>每一个put操作必须等待一个take操作</strong> ，否者不能继续添加元素</p><p>下面我们测试SynchronousQueue添加元素的过程</p><p>首先我们创建了两个线程，一个线程用于生产，一个线程用于消费</p><p>生产的线程分别put了 A、B、C这三个字段</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSynchronousQueue</span><span class="hljs-params">()</span> </span>&#123;    BlockingQueue&lt;String&gt; blockingQueue = <span class="hljs-keyword">new</span> SynchronousQueue&lt;&gt;();    <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;        <span class="hljs-keyword">try</span> &#123;            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t put A &quot;</span>);            blockingQueue.put(<span class="hljs-string">&quot;A&quot;</span>);            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t put B &quot;</span>);            blockingQueue.put(<span class="hljs-string">&quot;B&quot;</span>);            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t put C &quot;</span>);            blockingQueue.put(<span class="hljs-string">&quot;C&quot;</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();    <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">try</span> &#123;                TimeUnit.SECONDS.sleep(<span class="hljs-number">5</span>);            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;            blockingQueue.take();            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t take A &quot;</span>);            <span class="hljs-keyword">try</span> &#123;                TimeUnit.SECONDS.sleep(<span class="hljs-number">5</span>);            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;            blockingQueue.take();            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t take B &quot;</span>);            <span class="hljs-keyword">try</span> &#123;                TimeUnit.SECONDS.sleep(<span class="hljs-number">5</span>);            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;            blockingQueue.take();            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t take C &quot;</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();&#125;</code></pre><p>最后结果输出为：</p><pre><code class="hljs js">t1   put A t2   take A <span class="hljs-number">5</span>秒后...t1   put B t2   take B <span class="hljs-number">5</span>秒后...t1   put C t2   take C</code></pre><p>我们从最后的运行结果可以看出，每次t1线程向队列中添加阻塞队列添加元素后，t1输入线程就会 <strong>等待</strong>  t2消费线程，t2消费后，t2处于 <strong>挂起状态</strong> ，等待t1在存入，从而周而复始，形成 一存一取的状态</p><h2 id="阻塞队列的用处"><a href="#阻塞队列的用处" class="headerlink" title="阻塞队列的用处"></a>阻塞队列的用处</h2><h3 id="生产者消费者模式"><a href="#生产者消费者模式" class="headerlink" title="生产者消费者模式"></a>生产者消费者模式</h3><h5 id="版本区别"><a href="#版本区别" class="headerlink" title="版本区别"></a>版本区别</h5><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210415091117.png"></p><p>一个初始值为0的变量，两个线程对其 <strong>交替操作</strong> ，一个加1，一个减1，来5轮</p><p>关于多线程的操作，我们需要记住下面几句</p><ul><li>线程 操作  <strong>资源类</strong> </li><li>判断 干活 通知</li><li>防止虚假唤醒机制</li></ul><p>我们下面实现一个简单的生产者消费者模式，首先有 <strong>资源类ShareData</strong></p><h5 id="传统模式"><a href="#传统模式" class="headerlink" title="传统模式"></a>传统模式</h5><p>里面有一个number变量，同时提供了increment 和 decrement的方法，分别让number 加1和减1</p><p>但是我们在进行判断的时候，为了防止出现 <strong>虚假唤醒机制</strong> ，不能使用if来进行判断，而应该使用while</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210415095911.png"></p><pre><code class="hljs java"><span class="hljs-comment">// 判断</span><span class="hljs-keyword">while</span>(number != <span class="hljs-number">0</span>) &#123;    <span class="hljs-comment">// 等待不能生产</span>    condition.await();&#125;</code></pre><p>不能使用 if判断</p><pre><code class="hljs java"><span class="hljs-comment">// 判断</span><span class="hljs-keyword">if</span>(number != <span class="hljs-number">0</span>) &#123;    <span class="hljs-comment">// 等待不能生产</span>    condition.await();&#125;</code></pre><p>完整代码</p><p>一个进行生产，一个进行消费</p><pre><code class="hljs java"><span class="hljs-comment">// 生产与消费者 传统模式</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Code16_ProdConsumerTraditionDemo</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">// 高内聚，低耦合    内聚指的是，一个空调，自身带有调节温度高低的方法</span>        ShareData shareData = <span class="hljs-keyword">new</span> ShareData();        <span class="hljs-comment">// t1线程，生产</span>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;                <span class="hljs-keyword">try</span> &#123;                    shareData.increment();                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();        <span class="hljs-comment">// t2线程，消费</span>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;                <span class="hljs-keyword">try</span> &#123;                    shareData.decrement();                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShareData</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> number; <span class="hljs-comment">// 资源类数量</span>    <span class="hljs-keyword">private</span> Lock lock = <span class="hljs-keyword">new</span> ReentrantLock();    <span class="hljs-keyword">private</span> Condition condition = lock.newCondition();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increment</span> <span class="hljs-params">()</span></span>&#123;        <span class="hljs-comment">// 同步代码块，加锁</span>        lock.lock();        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">// 循环判断</span>            <span class="hljs-keyword">while</span> (number != <span class="hljs-number">0</span>)&#123;                <span class="hljs-comment">// 等待不能生产</span>                condition.await();            &#125;            <span class="hljs-comment">// 干活</span>            number ++; <span class="hljs-comment">// 生产</span>            System.out.println(Thread.currentThread() + <span class="hljs-string">&quot;生产&quot;</span> + number);            <span class="hljs-comment">// 通知 唤醒</span>            condition.signalAll();        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;<span class="hljs-keyword">finally</span> &#123;            lock.unlock();        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decrement</span> <span class="hljs-params">()</span></span>&#123;        lock.lock();        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">// 循环判断</span>            <span class="hljs-keyword">while</span> (number == <span class="hljs-number">0</span>)&#123;                condition.await();            &#125;            number --; <span class="hljs-comment">//  消费</span>            System.out.println(Thread.currentThread() + <span class="hljs-string">&quot;消费&quot;</span> + number);            condition.signalAll();        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;<span class="hljs-keyword">finally</span> &#123;            lock.unlock();        &#125;    &#125;&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210415095629.png"></p><h2 id="生成者和消费者3-0"><a href="#生成者和消费者3-0" class="headerlink" title="生成者和消费者3.0"></a>生成者和消费者3.0</h2><p>在concurrent包发布以前，在多线程环境下，我们每个程序员都必须自己去控制这些细节，尤其还要兼顾效率和线程安全，则这会给我们的程序带来不小的时间复杂度</p><p>现在我们使用新版的阻塞队列版生产者和消费者，使用：volatile、CAS、atomicInteger、BlockQueue、线程交互、原子引用</p><h5 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h5><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210415103425.png"></p><p>设置开关，打开可以生产一个消费一个，关闭可以不再生产消费；</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Code18_ProdConsumerBlockingQueueDemo</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">// 传入具体的实现类， ArrayBlockingQueue</span>        MyResource myResource = <span class="hljs-keyword">new</span> MyResource(<span class="hljs-keyword">new</span> ArrayBlockingQueue&lt;String&gt;(<span class="hljs-number">10</span>));        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 生产线程启动&quot;</span>);            System.out.println(<span class="hljs-string">&quot;&quot;</span>);            System.out.println(<span class="hljs-string">&quot;&quot;</span>);            <span class="hljs-keyword">try</span> &#123;                myResource.myProd();                System.out.println(<span class="hljs-string">&quot;&quot;</span>);                System.out.println(<span class="hljs-string">&quot;&quot;</span>);            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;, <span class="hljs-string">&quot;prod&quot;</span>).start();        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 消费线程启动&quot;</span>);            <span class="hljs-keyword">try</span> &#123;                myResource.myConsumer();            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;, <span class="hljs-string">&quot;consumer&quot;</span>).start();        <span class="hljs-comment">// 5秒后，停止生产和消费</span>        <span class="hljs-keyword">try</span> &#123;            TimeUnit.SECONDS.sleep(<span class="hljs-number">5</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        System.out.println(<span class="hljs-string">&quot;&quot;</span>);        System.out.println(<span class="hljs-string">&quot;&quot;</span>);        System.out.println(<span class="hljs-string">&quot;5秒中后，生产和消费线程停止，线程结束&quot;</span>);        myResource.stop();    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyResource</span> </span>&#123;    <span class="hljs-comment">// 默认开启，进行生产消费</span>    <span class="hljs-comment">// 这里用到了volatile是为了保持数据的可见性，也就是当FLAG修改时，要马上通知其它线程进行修改</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> FLAG = <span class="hljs-keyword">true</span>;    <span class="hljs-comment">// 使用原子包装类，而不用number++</span>    <span class="hljs-keyword">private</span> AtomicInteger atomicInteger = <span class="hljs-keyword">new</span> AtomicInteger();    <span class="hljs-comment">// 这里不能为了满足条件，而实例化一个具体的SynchronousBlockingQueue</span>    BlockingQueue&lt;String&gt; blockingQueue = <span class="hljs-keyword">null</span>;    <span class="hljs-comment">// 而应该采用依赖注入里面的，构造注入方法传入</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyResource</span><span class="hljs-params">(BlockingQueue&lt;String&gt; blockingQueue)</span></span>&#123;        <span class="hljs-keyword">this</span>.blockingQueue = blockingQueue;        <span class="hljs-comment">// 查询出传入的class是什么</span>        System.out.println(blockingQueue.getClass().getName());    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 生产</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">myProd</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;        String data = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">boolean</span> retValue;        <span class="hljs-comment">// 多线程环境的判断，一定要使用while进行，防止出现虚假唤醒</span>        <span class="hljs-comment">// 当FLAG为true的时候，开始生产</span>        <span class="hljs-keyword">while</span>(FLAG) &#123;            data = atomicInteger.incrementAndGet() + <span class="hljs-string">&quot;&quot;</span>;            <span class="hljs-comment">// 2秒存入1个data</span>            retValue = blockingQueue.offer(data, <span class="hljs-number">2L</span>, TimeUnit.SECONDS);            <span class="hljs-keyword">if</span>(retValue) &#123;                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 插入队列:&quot;</span> + data  + <span class="hljs-string">&quot;成功&quot;</span> );            &#125; <span class="hljs-keyword">else</span> &#123;                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 插入队列:&quot;</span> + data  + <span class="hljs-string">&quot;失败&quot;</span> );            &#125;            <span class="hljs-keyword">try</span> &#123;                TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 停止生产，表示FLAG=false，生产介绍&quot;</span>);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 消费</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">myConsumer</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;        String retValue;        <span class="hljs-comment">// 多线程环境的判断，一定要使用while进行，防止出现虚假唤醒</span>        <span class="hljs-comment">// 当FLAG为true的时候，开始生产</span>        <span class="hljs-keyword">while</span>(FLAG) &#123;            <span class="hljs-comment">// 2秒取出1个data</span>            retValue = blockingQueue.poll(<span class="hljs-number">2L</span>, TimeUnit.SECONDS);            <span class="hljs-keyword">if</span>(retValue != <span class="hljs-keyword">null</span> &amp;&amp; retValue != <span class="hljs-string">&quot;&quot;</span>) &#123;                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 消费队列:&quot;</span> + retValue  + <span class="hljs-string">&quot;成功&quot;</span> );            &#125; <span class="hljs-keyword">else</span> &#123;                FLAG = <span class="hljs-keyword">false</span>;                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 消费失败，队列中已为空，退出&quot;</span> );                <span class="hljs-comment">// 退出消费队列</span>                <span class="hljs-keyword">return</span>;            &#125;        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 停止生产的判断</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">this</span>.FLAG = <span class="hljs-keyword">false</span>;    &#125;&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210415105340.png"></p><h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><h2 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h2><p>获取多线程的方法，我们都知道有三种，还有一种是实现Callable接口</p><ul><li>实现Runnable接口</li><li>实现Callable接口</li><li>实例化Thread类</li><li>使用线程池获取</li></ul><h2 id="Callable接口"><a href="#Callable接口" class="headerlink" title="Callable接口"></a>Callable接口</h2><p>Callable接口，是一种让线程执行完成后，能够返回结果的</p><p>在说到Callable接口的时候，我们不得不提到 <strong>Runnable接口</strong> </p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 实现Runnable接口</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;    &#125;&#125;</code></pre><p>我们知道，实现Runnable接口的时候，需要 <strong>重写run方法</strong> ，也就是线程在启动的时候，会 <strong>自动调用</strong> 的方法</p><p>同理，我们实现Callable接口，也需要 <strong>实现call方法</strong> ，但是这个时候我们还需要 <strong>有返回值</strong> ，这个Callable接口的应用场景一般就在于批处理业务，比如转账的时候，需要给一会返回结果的状态码回来，代表本次操作成功还是失败</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Callable有返回值</span><span class="hljs-comment"> * 批量处理的时候，需要带返回值的接口（例如支付失败的时候，需要返回错误状态）</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Callable</span>&lt;<span class="hljs-title">Integer</span>&gt; </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        System.out.println(<span class="hljs-string">&quot;come in Callable&quot;</span>);        <span class="hljs-keyword">return</span> <span class="hljs-number">1024</span>;    &#125;&#125;</code></pre><p>最后我们需要做的就是通过Thread线程， 将MyThread2实现Callable接口的类包装起来</p><p>这里需要用到的是 <strong>FutureTask类</strong> ，他 <strong>实现了Runnable接口</strong> ，并且还需要传递一个实现Callable接口的类作为 <strong>构造函数</strong> </p><pre><code class="hljs java"><span class="hljs-comment">// FutureTask：实现了Runnable接口，构造函数又需要传入 Callable接口</span><span class="hljs-comment">// 这里通过了FutureTask接触了Callable接口</span>FutureTask&lt;Integer&gt; futureTask = <span class="hljs-keyword">new</span> FutureTask&lt;&gt;(<span class="hljs-keyword">new</span> MyThread2());</code></pre><p>然后在用Thread进行实例化，传入实现Runnabnle接口的FutureTask的类</p><pre><code class="hljs java">Thread t1 = <span class="hljs-keyword">new</span> Thread(futureTask, <span class="hljs-string">&quot;aaa&quot;</span>);t1.start();</code></pre><p>最后通过 futureTask.get() 获取到返回值</p><pre><code class="hljs java"><span class="hljs-comment">// 输出FutureTask的返回值</span>System.out.println(<span class="hljs-string">&quot;result FutureTask &quot;</span> + futureTask.get());</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210415110635.png"></p><p>这就相当于原来我们的方式是main方法一条龙，后面在引入Callable后，对于执行比较久的线程，可以 <strong>单独新开一个线程</strong> 进行执行，最后在进行 <strong>汇总输出</strong> </p><p>最后需要注意的是 要求获得Callable线程的计算结果，如果没有计算完成就要去强求，会 <strong>导致阻塞</strong> ，直到计算完成</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210415112328.png"></p><p>也就是说 futureTask.get() 需要 <strong>放在最后执行</strong> ，这样 <strong>不会导致主线程阻塞</strong> </p><p>也可以使用下面算法，使用类似于自旋锁的方式来进行判断是否运行完毕</p><pre><code class="hljs java"><span class="hljs-comment">// 判断futureTask是否计算完成</span><span class="hljs-keyword">while</span>(!futureTask.isDone()) &#123;&#125;</code></pre><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>多个线程执行 一个FutureTask的时候，只会 <strong>计算一次</strong> </p><pre><code class="hljs java">FutureTask futureTask = <span class="hljs-keyword">new</span> FutureTask(<span class="hljs-keyword">new</span> CallableThread());Thread t1 = <span class="hljs-keyword">new</span> Thread(futureTask, <span class="hljs-string">&quot;aaa&quot;</span>);Thread t2 = <span class="hljs-keyword">new</span> Thread(futureTask, <span class="hljs-string">&quot;bbb&quot;</span>);t1.start();t2.start();</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210415112613.png"></p><p>如果我们要两个线程同时计算任务的话，那么需要这样写，需要 <strong>定义两个futureTask</strong> </p><pre><code class="hljs java">FutureTask futureTask = <span class="hljs-keyword">new</span> FutureTask(<span class="hljs-keyword">new</span> CallableThread());FutureTask futureTaskOther = <span class="hljs-keyword">new</span> FutureTask(<span class="hljs-keyword">new</span> CallableThread());Thread t1 = <span class="hljs-keyword">new</span> Thread(futureTask, <span class="hljs-string">&quot;aaa&quot;</span>);Thread t2 = <span class="hljs-keyword">new</span> Thread(futureTaskOther, <span class="hljs-string">&quot;bbb&quot;</span>);t1.start();t2.start();</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210415112745.png"></p><h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><h3 id="为什么用线程池"><a href="#为什么用线程池" class="headerlink" title="为什么用线程池"></a>为什么用线程池</h3><p>线程池做的主要工作就是 <strong>控制运行的线程的数量</strong> ，处理过程中，将任务放入到队列中，然后线程创建后，启动这些任务，如果线程数量超过了最大数量的线程排队等候，等其它线程执行完毕，再从队列中取出任务来执行。</p><p>它的主要特点为： <strong>线程复用</strong> 、 <strong>控制最大并发数</strong> 、 <strong>管理线程</strong> </p><pre><code class="hljs java">Runtime.getRuntime().availableProcessors();<span class="hljs-comment">// 查找线程数</span></code></pre><h3 id="线程池的好处"><a href="#线程池的好处" class="headerlink" title="线程池的好处"></a>线程池的好处</h3><p>多核处理的好处是： <strong>省略的上下文的切换开销</strong> </p><p>原来我们实例化对象的时候，是使用 new关键字进行创建，到了Spring后，我们学了IOC依赖注入，发现Spring帮我们将对象已经加载到了Spring容器中，只需要通过@Autowrite注解，就能够自动注入，从而使用</p><p>因此使用多线程有下列的好处</p><ul><li> <strong>降低资源消耗</strong> 。通过重复利用已创建的线程，降低线程创建和销毁造成的消耗</li><li> <strong>提高响应速度</strong> 。当任务到达时，任务可以不需要等到线程创建就立即执行</li><li> <strong>提高线程的可管理性</strong> 。线程是稀缺资源，如果无线创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控</li></ul><h3 id="架构说明"><a href="#架构说明" class="headerlink" title="架构说明"></a>架构说明</h3><p>Java中线程池是通过Executor框架实现的，该框架中用到了 <strong>Executor</strong> ， <strong>Executors（代表工具类）</strong> ， <strong>ExecutorService</strong> ， <strong>ThreadPoolExecutor</strong> 这几个类。</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210416100920.png"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210416100937.png"></p><h3 id="创建线程池"><a href="#创建线程池" class="headerlink" title="创建线程池"></a>创建线程池</h3><ul><li>Executors.newFixedThreadPool(int i) ： 创建一个 <strong>固定</strong> 拥有 i 个线程的线程池<ul><li>执行长期的任务，性能好很多</li><li>创建一个 <strong>定长线程池</strong> ，可控制线程数最大并发数，超出的线程会在队列中等待</li></ul></li><li>Executors.newSingleThreadExecutor：创建一个 <strong>只有1个线程</strong> 的 单线程池<ul><li>一个任务一个任务执行的场景</li><li>创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序执行</li></ul></li><li>Executors.newCacheThreadPool(); 创建一个 <strong>可扩容</strong> 的线程池<ul><li>执行很多短期异步的小程序或者负载教轻的服务器</li><li>创建一个可缓存线程池，如果线程长度超过处理需要，可灵活回收空闲线程，如无可回收，则新建新线程</li></ul></li><li>Executors.newScheduledThreadPool(int corePoolSize)：线程池支持 <strong>定时以及周期性执行</strong> 任务，创建一个corePoolSize为传入参数，最大线程数为整形的最大数的线程池</li></ul><p>具体使用，首先我们需要使用 <strong>Executors工具类，进行创建线程池</strong> ，这里创建了一个拥有5个线程的线程池</p><pre><code class="hljs java"><span class="hljs-comment">// 一池5个处理线程（用池化技术，一定要记得关闭）</span>ExecutorService threadPool = Executors.newFixedThreadPool(<span class="hljs-number">5</span>);<span class="hljs-comment">// 创建一个只有一个线程的线程池</span>ExecutorService threadPool = Executors.newSingleThreadExecutor();<span class="hljs-comment">// 创建一个拥有N个线程的线程池，根据调度创建合适的线程</span>ExecutorService threadPool = Executors.newCacheThreadPool();</code></pre><p>然后我们执行下面的的应用场景</p><pre><code class="hljs js">模拟<span class="hljs-number">10</span>个用户来办理业务，每个用户就是一个来自外部请求线程</code></pre><p>我们需要使用 threadPool.execute执行业务，execute需要传入一个实现了 <strong>Runnable接口</strong> 的线程</p><pre><code class="hljs java">threadPool.execute(() -&gt; &#123;  System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 给用户办理业务&quot;</span>);&#125;);</code></pre><p>然后我们使用完毕后关闭线程池</p><pre><code class="hljs java">threadPool.shutdown();</code></pre><p>完整代码为：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">create</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// Array  Arrays(辅助工具类)</span>    <span class="hljs-comment">// Collection Collections(辅助工具类)</span>    <span class="hljs-comment">// Executor Executors(辅助工具类)</span>    <span class="hljs-comment">// 一池5个处理线程（用池化技术，一定要记得关闭）</span>    ExecutorService threadPool = Executors.newFixedThreadPool(<span class="hljs-number">5</span>);    <span class="hljs-comment">// 模拟10个用户来办理业务，每个用户就是一个来自外部请求线程</span>    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-comment">// 循环十次，模拟业务办理，让5个线程处理这10个请求</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> tempInt = i;            threadPool.execute(() -&gt; &#123;                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 给用户:&quot;</span> + tempInt + <span class="hljs-string">&quot; 办理业务&quot;</span>);            &#125;);        &#125;    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;        e.printStackTrace();    &#125; <span class="hljs-keyword">finally</span> &#123;        threadPool.shutdown();    &#125;&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210416102056.png"></p><h3 id="创建周期性执行任务的线程池"><a href="#创建周期性执行任务的线程池" class="headerlink" title="创建周期性执行任务的线程池"></a>创建周期性执行任务的线程池</h3><p>Executors.newScheduledThreadPool(int corePoolSize)：</p><p><strong>线程池支持定时以及周期性执行任务，创建一个corePoolSize为传入参数，最大线程数为整形的最大数的线程池</strong></p><p>底层使用 ScheduledThreadPoolExecutor 来实现, ScheduledThreadPoolExecutor 为ThreadPoolExecutor子类</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ScheduledExecutorService <span class="hljs-title">newScheduledThreadPool</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize)</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);&#125;</code></pre><p>点进查看</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ScheduledThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize)</span> </span>&#123;    <span class="hljs-keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="hljs-number">0</span>, NANOSECONDS,          <span class="hljs-keyword">new</span> DelayedWorkQueue());&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ScheduledThreadPoolExecutor</span></span><span class="hljs-class">        <span class="hljs-keyword">extends</span> <span class="hljs-title">ThreadPoolExecutor</span></span><span class="hljs-class">        <span class="hljs-keyword">implements</span> <span class="hljs-title">ScheduledExecutorService</span> </span>&#123;  ....&#125;</code></pre><h4 id="执行方法"><a href="#执行方法" class="headerlink" title="执行方法"></a>执行方法</h4><pre><code class="hljs java"> <span class="hljs-comment">/**</span><span class="hljs-comment">  * <span class="hljs-doctag">@throws</span> RejectedExecutionException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><span class="hljs-comment">  * <span class="hljs-doctag">@throws</span> NullPointerException       &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><span class="hljs-comment">  * command：执行的任务 Callable或Runnable接口实现类</span><span class="hljs-comment">* delay：延时执行任务的时间</span><span class="hljs-comment">* unit：延迟时间单位</span><span class="hljs-comment">  */</span> <span class="hljs-keyword">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable command,                                    <span class="hljs-keyword">long</span> delay,                                    TimeUnit unit) <span class="hljs-comment">/**</span><span class="hljs-comment">  * <span class="hljs-doctag">@throws</span> RejectedExecutionException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><span class="hljs-comment">  * <span class="hljs-doctag">@throws</span> NullPointerException       &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><span class="hljs-comment">  * <span class="hljs-doctag">@throws</span> IllegalArgumentException   &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><span class="hljs-comment">  * command：执行的任务 Callable或Runnable接口实现类</span><span class="hljs-comment">* initialDelay 第一次执行任务延迟时间</span><span class="hljs-comment">* period 连续执行任务之间的周期，从上一个任务开始执行时计算延迟多少开始执行下一个任务，但是还会等上一个任务结束之后。</span><span class="hljs-comment">* unit：延迟时间单位</span><span class="hljs-comment">  */</span> <span class="hljs-keyword">public</span> ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,                                               <span class="hljs-keyword">long</span> initialDelay,                                               <span class="hljs-keyword">long</span> period,                                               TimeUnit unit) <span class="hljs-comment">/**</span><span class="hljs-comment">  * <span class="hljs-doctag">@throws</span> RejectedExecutionException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><span class="hljs-comment">  * <span class="hljs-doctag">@throws</span> NullPointerException       &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><span class="hljs-comment">  * <span class="hljs-doctag">@throws</span> IllegalArgumentException   &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><span class="hljs-comment">  * command：执行的任务 Callable或Runnable接口实现类</span><span class="hljs-comment">* initialDelay 第一次执行任务延迟时间</span><span class="hljs-comment">* delay：连续执行任务之间的周期，从上一个任务全部执行完成时计算延迟多少开始执行下一个任务</span><span class="hljs-comment">* unit：延迟时间单位</span><span class="hljs-comment">  */</span> <span class="hljs-keyword">public</span> ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command,                                                  <span class="hljs-keyword">long</span> initialDelay,                                                  <span class="hljs-keyword">long</span> delay,                                                  TimeUnit unit)</code></pre><h2 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h2><p>我们通过查看源码，点击了Executors.newSingleThreadExecutor 和 Executors.newFixedThreadPool能够发现底层都是使用了 <strong>ThreadPoolExecutor</strong> </p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210416103013.png"></p><p>我们可以看到线程池的内部，还使用到了 <strong>LinkedBlockingQueue</strong>  链表阻塞队列</p><p>同时在查看Executors.newCacheThreadPool 看到底层用的是  <strong>SynchronousBlockingQueue</strong> 阻塞队列</p><p>最后查看一下，完整的三个创建线程的方法</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210416103304.png"></p><h2 id="线程池的重要参数"><a href="#线程池的重要参数" class="headerlink" title="线程池的重要参数"></a>线程池的重要参数</h2><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210416103728.png"></p><p>线程池在创建的时候，一共有 <strong>7大参数</strong> </p><ul><li><p>corePoolSize： <strong>核心线程数</strong> ，线程池中的常驻核心线程数</p><ul><li>在创建线程池后，当有请求任务来之后，就会安排池中的线程去执行请求任务，近似理解为今日当值线程</li><li>当线程池中的线程数目达到corePoolSize后，就会把到达的 <strong>队列放到缓存队列</strong> 中</li></ul></li><li><p>maximumPoolSize：线程池能够容纳同时执行的 <strong>最大线程数</strong> ，此值必须大于等于1、</p><ul><li>相当有扩容后的线程数，这个线程池能容纳的最多线程数</li></ul></li><li><p>keepAliveTime：多余的空闲线程存活时间</p><ul><li>当线程池数量超过corePoolSize时，当空闲时间达到keepAliveTime值时，多余的空闲线程会被 <strong>销毁</strong> ，直到只剩下corePoolSize个线程为止</li><li>默认情况下，只有当线程池中的线程数大于corePoolSize时，keepAliveTime才会起作用</li></ul></li><li><p>unit：keepAliveTime的单位</p></li><li><p>workQueue： <strong>任务队列，被提交的但未被执行的任务</strong> （类似于银行里面的候客区）</p><ul><li>LinkedBlockingQueue：链表阻塞队列</li><li>SynchronousBlockingQueue：同步阻塞队列</li></ul></li><li><p>threadFactory：表示生成线程池中工作线程的 <strong>线程工厂</strong> ，用于创建线程池 一般用默认即可</p></li><li><p>handler：拒绝策略，表示当 <strong>队列满了并且工作线程大于线程池的最大线程数</strong> （maximumPoolSize3）时，如何来拒绝请求执行的Runnable的策略</p><p>当营业窗口最大值和阻塞队列中都满了时候，就需要设置拒绝策略</p></li></ul><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210416105326.png"></p><h2 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h2><p>以下所有拒绝策略都实现了 <strong>RejectedExecutionHandler</strong> 接口</p><ul><li>AbortPolicy：默认，直接抛出RejectedExcutionException异常，阻止系统正常运行</li><li>DiscardPolicy：直接 <strong>丢弃</strong> 任务，不予任何处理也不抛出异常，如果运行任务丢失，这是一种好方案</li><li>CallerRunsPolicy：该策略既不会抛弃任务，也不会抛出异常，而是将某些任务 <strong>回退</strong> 到调用者</li><li>DiscardOldestPolicy： <strong>抛弃</strong> 队列中 <strong>等待最久</strong> 的任务，然后把当前任务加入队列中尝试再次提交当前任务</li></ul><p>ThreadPoolExecutor中源代码：</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> RejectedExecutionHandler defaultHandler =    <span class="hljs-keyword">new</span> AbortPolicy();</code></pre><h2 id="线程池底层工作原理"><a href="#线程池底层工作原理" class="headerlink" title="线程池底层工作原理"></a>线程池底层工作原理</h2><h3 id="线程池运行架构图"><a href="#线程池运行架构图" class="headerlink" title="线程池运行架构图"></a>线程池运行架构图</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210416110149.png"></p><p>文字说明</p><ol><li>在创建了线程池后，等待提交过来的 <strong>任务请求</strong> </li><li>当调用execute()方法添加一个请求任务时，线程池会做出如下判断<ol><li>如果正在运行的线程池数量小于corePoolSize，那么马上创建线程运行这个任务</li><li>如果正在运行的线程数量大于或等于corePoolSize，那么将这个任务 <strong>放入队列</strong> </li><li>如果这时候 <strong>队列满了</strong> ，并且正在运行的线程数量还 <strong>小于maximumPoolSize</strong> ，那么还是创建非核心线程like运行这个任务；</li><li>如果队列满了并且正在运行的线程数量 <strong>大于或等于maximumPoolSize</strong> ，那么线程池会启动 <strong>饱和拒绝策略</strong> 来执行</li></ol></li><li>当一个线程完成任务时，它会从队列中取下一个任务来执行</li><li>当一个线程无事可做操作一定的时间 <strong>(keepAliveTime)</strong> 时，线程池会判断：<ol><li>如果当前运行的线程数大于corePoolSize，那么这个线程就 <strong>被停掉</strong> </li><li>所以线程池的所有任务完成后，它会最终 <strong>收缩到corePoolSize的大小</strong> </li></ol></li></ol><p>以顾客去银行办理业务为例，谈谈线程池的底层工作原理</p><ol><li>最开始假设来了两个顾客，因为corePoolSize为2，因此这两个顾客直接能够去窗口办理</li><li>后面又来了三个顾客，因为corePool已经被顾客占用了，因此只有去候客区，也就是阻塞队列中等待</li><li>后面的人又陆陆续续来了，候客区可能不够用了，因此需要申请增加处理请求的窗口，这里的窗口指的是线程池中的线程数，以此来解决线程不够用的问题</li><li>假设受理窗口已经达到最大数，并且请求数还是不断递增，此时候客区和线程池都已经满了，为了防止大量请求冲垮线程池，已经需要开启拒绝策略</li><li>临时增加的线程会因为超过了最大存活时间，就会销毁，最后从最大数削减到核心数</li></ol><h2 id="为什么不用默认创建的线程池？"><a href="#为什么不用默认创建的线程池？" class="headerlink" title="为什么不用默认创建的线程池？"></a>为什么不用默认创建的线程池？</h2><p>线程池创建的方法有： <strong>固定数的</strong> ， <strong>单一的</strong> ， <strong>可变的</strong> ，那么在实际开发中，应该使用哪个？</p><p>我们一个都不用，在生产环境中是使用自己 <strong>自定义的</strong> </p><p>为什么不用 Executors 中JDK提供的？</p><p>根据 <strong>阿里巴巴手册</strong> ：并发控制这章</p><ul><li>线程资源必须通过线程池提供， <strong>不允许在应用中自行显式创建线程</strong> <ul><li>使用线程池的好处是 <strong>减少</strong> 在创建和销毁线程上所消耗的时间以及系统资源的 <strong>开销</strong> ，解决资源不足的问题，如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题</li></ul></li><li>线程池 <strong>不允许使用Executors去创建</strong> ，而是通过  <strong>ThreadPoolExecutor</strong>  的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险<ul><li>Executors返回的线程池对象弊端如下：<ul><li>FixedThreadPool和SingleThreadPool：<ul><li>运行的请求队列长度为：Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 <strong>OOM</strong> </li></ul></li><li>CacheThreadPool和ScheduledThreadPool<ul><li>运行的请求队列长度为：Integer.MAX_VALUE，可能会堆积大量的请求，从而导致OOM</li></ul></li></ul></li></ul></li></ul><h2 id="手写线程池"><a href="#手写线程池" class="headerlink" title="手写线程池"></a>手写线程池</h2><h3 id="采用默认拒绝策略"><a href="#采用默认拒绝策略" class="headerlink" title="采用默认拒绝策略"></a>采用默认拒绝策略</h3><p>从上面我们知道，因为默认的Executors创建的线程池，底层都是使用LinkBlockingQueue作为阻塞队列的，而LinkBlockingQueue虽然是有界的，但是它的界限是 Integer.MAX_VALUE 大概有20多亿，可以相当是无界的了，因此我们要使用ThreadPoolExecutor自己 <strong>手动创建线程池，然后指定阻塞队列的大小</strong> </p><p>下面我们创建了一个 核心线程数为2，最大线程数为5，并且阻塞队列数为3的线程池</p><pre><code class="hljs java"><span class="hljs-comment">// 手写线程池</span><span class="hljs-keyword">final</span> Integer corePoolSize = <span class="hljs-number">2</span>;<span class="hljs-keyword">final</span> Integer maximumPoolSize = <span class="hljs-number">5</span>;<span class="hljs-keyword">final</span> Long keepAliveTime = <span class="hljs-number">1L</span>;ExecutorService threadPool = <span class="hljs-keyword">new</span> ThreadPoolExecutor(        corePoolSize,        maximumPoolSize,        keepAliveTime,        TimeUnit.SECONDS,        <span class="hljs-keyword">new</span> LinkedBlockingDeque&lt;Runnable&gt;(<span class="hljs-number">3</span>),        Executors.defaultThreadFactory(),        <span class="hljs-keyword">new</span> ThreadPoolExecutor.AbortPolicy());</code></pre><p>然后使用for循环，模拟15个用户来进行请求</p><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;    <span class="hljs-comment">// 循环十次，模拟业务办理，让5个线程处理这15个请求</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">15</span>; i++) &#123;        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> tempInt = i;        threadPool.execute(() -&gt; &#123;            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 给用户:&quot;</span> + tempInt + <span class="hljs-string">&quot; 办理业务&quot;</span>);        &#125;);    &#125;&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;    e.printStackTrace();&#125; <span class="hljs-keyword">finally</span> &#123;    threadPool.shutdown();&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210416141103.png"></p><p>这是因为触发了拒绝策略，而我们设置的拒绝策略是默认的AbortPolicy，也就是抛异常的</p><p>触发条件是， <strong>请求的线程</strong> 大于 <strong>阻塞队列大小 + 最大线程数 = 8</strong>  的时候，也就是说第9个线程来获取线程池中的线程时，就会抛出异常从而报错退出。</p><h3 id="采用CallerRunsPolicy拒绝策略"><a href="#采用CallerRunsPolicy拒绝策略" class="headerlink" title="采用CallerRunsPolicy拒绝策略"></a>采用CallerRunsPolicy拒绝策略</h3><p>当我们更好其它的拒绝策略时，采用CallerRunsPolicy拒绝策略，也称为 <strong>回退策略</strong> ，就是把任务丢回原来的请求开启线程着，我们看运行结果</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210416141242.png"></p><p>我们发现，输出的结果里面出现了main线程，因为线程池出发了拒绝策略，把任务回退到main线程，然后main线程对任务进行处理</p><h3 id="采用-DiscardPolicy-拒绝策略"><a href="#采用-DiscardPolicy-拒绝策略" class="headerlink" title="采用 DiscardPolicy 拒绝策略"></a>采用 DiscardPolicy 拒绝策略</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210416141344.png"></p><p>采用DiscardPolicy拒绝策略会，线程池会自动把后面的任务都直接丢弃，也不报异常，当任务无关紧要的时候，可以采用这个方式</p><h3 id="采用DiscardOldestPolicy拒绝策略"><a href="#采用DiscardOldestPolicy拒绝策略" class="headerlink" title="采用DiscardOldestPolicy拒绝策略"></a>采用DiscardOldestPolicy拒绝策略</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210416141411.png"></p><p>这个策略和刚刚差不多，会把 <strong>最久</strong> 的队列中的任务替换掉</p><h2 id="线程池的合理参数"><a href="#线程池的合理参数" class="headerlink" title="线程池的合理参数"></a>线程池的合理参数</h2><p>生产环境中如何配置 corePoolSize 和 maximumPoolSize</p><p>这个是根据具体业务来配置的，分为CPU密集型和IO密集型</p><ul><li> <strong>CPU密集型</strong> </li></ul><p>CPU密集的意思是该任务需要大量的运算，而没有阻塞，CPU一直全速运行</p><p>CPU密集任务只有在真正的多核CPU上才可能得到加速（通过多线程）</p><p>而在单核CPU上，无论你开几个模拟的多线程该任务都不可能得到加速，因为CPU总的运算能力就那些</p><p>CPU密集型任务配置尽可能少的线程数量：</p><p>一般公式： <strong>CPU核数 + 1个线程数</strong> </p><ul><li> <strong>IO密集型</strong> </li></ul><p>由于IO密集型任务线程并不是一直在执行任务，则可能多的线程，如 CPU核数 * 2</p><p>IO密集型，即该任务需要大量的IO操作，即大量的阻塞</p><p>在单线程上运行IO密集型的任务会导致浪费大量的CPU运算能力花费在等待上</p><p>所以IO密集型任务中使用多线程可以大大的加速程序的运行，即使在单核CPU上，这种加速主要就是利用了被浪费掉的阻塞时间。</p><p>IO密集时，大部分线程都被阻塞，故需要多配置线程数：</p><p>参考公式： <strong>CPU核数 / (1 - 阻塞系数) 阻塞系数在0.8 ~ 0.9左右</strong> </p><p>例如：8核CPU：8/ (1 - 0.9) = 80个线程数</p><h1 id="死锁编码及定位分析"><a href="#死锁编码及定位分析" class="headerlink" title="死锁编码及定位分析"></a>死锁编码及定位分析</h1><h2 id="概念-8"><a href="#概念-8" class="headerlink" title="概念"></a>概念</h2><p>死锁是指两个或多个以上的进程在执行过程中，因争夺资源而造成一种 <strong>互相等待</strong> 的现象，若无外力干涉那他们都将无法推进下去。如果资源充足，进程的资源请求都能够得到满足，死锁出现的可能性就很低，否则就会因争夺有限的资源而陷入死锁。</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210416142259.png"></p><h2 id="死锁产生的四个必要条件"><a href="#死锁产生的四个必要条件" class="headerlink" title="死锁产生的四个必要条件"></a>死锁产生的四个必要条件</h2><ul><li><strong>互斥</strong> <ul><li>解决方法：把互斥的共享资源封装成可同时访问</li></ul></li><li><strong>占有且等待</strong> <ul><li>解决方法：进程请求资源时，要求它不占有任何其它资源，也就是它必须一次性申请到所有的资源，这种方式会导致资源效率低。</li></ul></li><li><strong>非抢占式</strong> <ul><li>解决方法：如果进程不能立即分配资源，要求它不占有任何其他资源，也就是只能够同时获得所有需要资源时，才执行分配操作</li></ul></li><li><strong>循环等待</strong> <ul><li>解决方法：对资源进行排序，要求进程按顺序请求资源。</li></ul></li></ul><h2 id="死锁代码"><a href="#死锁代码" class="headerlink" title="死锁代码"></a>死锁代码</h2><p>我们创建了一个资源类，然后让两个线程分别持有自己的锁，同时在尝试获取别人的，就会出现死锁现象</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Code21_DeadLockDemo</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        String lockA = <span class="hljs-string">&quot;lockA&quot;</span>;        String lockB = <span class="hljs-string">&quot;lockB&quot;</span>;        <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> HoldLockThread(lockA, lockB), <span class="hljs-string">&quot;t1&quot;</span>).start();        <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> HoldLockThread(lockB, lockA), <span class="hljs-string">&quot;t2&quot;</span>).start();    &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 资源类</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HoldLockThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;    <span class="hljs-keyword">private</span> String lockA;    <span class="hljs-keyword">private</span> String lockB;    <span class="hljs-comment">// 持有自己的锁，还想得到别人的锁</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HoldLockThread</span><span class="hljs-params">(String lockA, String lockB)</span> </span>&#123;        <span class="hljs-keyword">this</span>.lockA = lockA;        <span class="hljs-keyword">this</span>.lockB = lockB;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">synchronized</span> (lockA) &#123;            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 自己持有&quot;</span> + lockA + <span class="hljs-string">&quot;\t 尝试获取：&quot;</span> + lockB);            <span class="hljs-keyword">try</span> &#123;                TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;            <span class="hljs-keyword">synchronized</span> (lockB) &#123;                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 自己持有&quot;</span> + lockB + <span class="hljs-string">&quot;\t 尝试获取：&quot;</span> + lockA);            &#125;        &#125;    &#125;&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210416142630.png"></p><h2 id="如何排查死锁"><a href="#如何排查死锁" class="headerlink" title="如何排查死锁"></a>如何排查死锁</h2><p>当我们出现死锁的时候，首先需要使用jps命令查看运行的程序</p><ul><li><p>jps - l</p><p>我们能看到DeadLockDemo这个类，一直在运行</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210416142816.png"></p></li></ul><p>在使用jstack查看堆栈信息</p><ul><li><p>jstack  xxxx   # 后面参数是 jps输出的该类的pid</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210416142928.png"></p></li></ul><p>最终结果：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210416142958.png"></p><p>定位</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210416143945.png"></p><h1 id="JVM体系结构"><a href="#JVM体系结构" class="headerlink" title="JVM体系结构"></a>JVM体系结构</h1><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210416144354.png"></p><p>java gc 主要回收的是 <strong>方法区</strong>  和 <strong>堆</strong> 中的内容</p><p>灰色线程私有，几乎不存在垃圾回收</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210416144526.png"></p><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><ul><li>类加载器是什么</li><li>双亲委派机制</li><li>Java类加载的沙箱安全机制</li></ul><h2 id="常见的垃圾回收算法"><a href="#常见的垃圾回收算法" class="headerlink" title="常见的垃圾回收算法"></a>常见的垃圾回收算法</h2><ul><li><p>引用计数</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210416144610.png"></p></li></ul><p>在双端循环，互相引用的时候，容易报错，目前很少使用这种方式了</p><ul><li><p>复制</p><p>复制算法在年轻代的时候，进行使用，复制时候有交换</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210416144654.png"></p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95/JUC/12_JVM/JVM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/images/image-20200318184820787.png"></p></li></ul><p>优点：没有产生内存碎片</p><ul><li><p>标记清除</p><p>先标记，后清除，缺点是会产生内存碎片，用于老年代多一些</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210416144748.png"></p></li><li><p>标记整理</p><p>标记清除整理</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210416144820.png"></p><p>但是需要付出代价，因为移动对象需要成本</p></li></ul><h1 id="JVM面试汇总"><a href="#JVM面试汇总" class="headerlink" title="JVM面试汇总"></a>JVM面试汇总</h1><h2 id="JVM垃圾回收的时候如何确定垃圾？是否知道什么是GC-Roots"><a href="#JVM垃圾回收的时候如何确定垃圾？是否知道什么是GC-Roots" class="headerlink" title="JVM垃圾回收的时候如何确定垃圾？是否知道什么是GC Roots"></a>JVM垃圾回收的时候如何确定垃圾？是否知道什么是GC Roots</h2><h3 id="什么是垃圾"><a href="#什么是垃圾" class="headerlink" title="什么是垃圾"></a>什么是垃圾</h3><p>简单来说就是 <strong>内存中已经不再被使用的空间就是垃圾</strong> </p><h3 id="如何判断一个对象是否可以被回收"><a href="#如何判断一个对象是否可以被回收" class="headerlink" title="如何判断一个对象是否可以被回收"></a>如何判断一个对象是否可以被回收</h3><h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><p>Java中，引用和对象是有关联的。如果要操作对象则必须用引用进行。</p><p>因此，很显然一个简单的办法就是通过引用计数来判断一个对象是否可以回收。简单说，给对象中添加一个引用计数器</p><p>每当有一个地方引用它，计数器值加1</p><p>每当有一个引用失效，计数器值减1</p><p>任何时刻计数器值为零的对象就是不可能再被使用的，那么这个对象就是可回收对象。</p><p>那么为什么主流的Java虚拟机里面都没有选用这个方法呢？其中最主要的原因是它很难解决对象之间相互循环引用的问题。 <strong>循环互相引用问题</strong> </p><p>该算法存在但目前无人用了，解决不了 <strong>循环引用</strong> 的问题，了解即可。</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210416150640.png"></p><h4 id="枚举根节点做可达性分析"><a href="#枚举根节点做可达性分析" class="headerlink" title="枚举根节点做可达性分析"></a>枚举根节点做可达性分析</h4><p>为了解决 <strong>循环引用</strong> 的问题</p><p>根搜索路径算法</p><p>为了解决引用计数法的循环引用个问题，Java使用了可达性分析的方法：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210416150837.png"></p><p>所谓 <strong>GC Roots</strong> 或者说 <strong>Tracing Roots</strong> 的“根集合” 就是一组必须活跃的引用(上图对象C没有被GC可达)</p><p>基本思路就是 <strong>通过一系列名为 GC Roots的对象作为起始点</strong> ，从这个被称为GC Roots的对象开始向下搜索，如果一个对象到GC Roots没有任何引用链相连，则说明此对象不可用。也即给定一个集合的引用作为根出发，通过引用关系 <strong>遍历对象图</strong> ，能被遍历到的（可到达的）对象就被判定为 <strong>存活</strong> ，没有被遍历到的对象就被判定为 <strong>死亡</strong> </p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210416151128.png"></p><p>必须从GC Roots对象开始，这个类似于linux的 / 也就是根目录</p><p>蓝色部分是从GC Roots出发，能够循环可达</p><p>而白色部分，从GC Roots出发，无法到达</p><h4 id="一句话理解GC-Roots"><a href="#一句话理解GC-Roots" class="headerlink" title="一句话理解GC Roots"></a>一句话理解GC Roots</h4><p>假设我们现在有三个实体，分别是 人，狗，毛衣</p><p>然后他们之间的关系是：人 牵着 狗，狗穿着毛衣，他们之间是强连接的关系</p><p>有一天人消失了，只剩下狗狗 和 毛衣，这个时候，把人想象成 GC Roots，因为 人 和 狗之间失去了绳子连接，</p><p>那么狗可能被回收，也就是被警察抓起来，被送到流浪狗寄养所</p><p>假设狗和人有强连接的时候，狗狗就不会被当成是流浪狗</p><h4 id="那些对象可以当做GC-Roots"><a href="#那些对象可以当做GC-Roots" class="headerlink" title="那些对象可以当做GC Roots"></a>那些对象可以当做GC Roots</h4><ul><li>虚拟机栈（栈帧中的局部变量区，也叫做局部变量表）中的引用对象</li><li>方法区中的类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中的JNI（Native方法）的引用对象</li></ul><h4 id="代码说明"><a href="#代码说明" class="headerlink" title="代码说明"></a>代码说明</h4><pre><code class="hljs java">jpublic <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GCRootDemo</span> </span>&#123;    <span class="hljs-comment">// 方法区中的类静态属性引用的对象</span>    <span class="hljs-comment">// private static GCRootDemo2 t2;</span>    <span class="hljs-comment">// 方法区中的常量引用，GC Roots 也会以这个为起点，进行遍历</span>    <span class="hljs-comment">// private static final GCRootDemo3 t3 = new GCRootDemo3(8);</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m1</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 第一种，虚拟机栈中的引用对象</span>        GCRootDemo t1 = <span class="hljs-keyword">new</span> GCRootDemo();        System.gc();        System.out.println(<span class="hljs-string">&quot;第一次GC完成&quot;</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        m1();    &#125;&#125;</code></pre><h2 id="JVM参数调优"><a href="#JVM参数调优" class="headerlink" title="JVM参数调优"></a>JVM参数调优</h2><h3 id="前言-2"><a href="#前言-2" class="headerlink" title="前言"></a>前言</h3><p>你说你做过JVM调优和参数配置，请问如何盘点查看 <strong>JVM系统默认值</strong> </p><p>使用jps和jinfo进行查看</p><pre><code class="hljs diff"><span class="hljs-deletion">-Xms：初始堆空间</span><span class="hljs-deletion">-Xmx：堆最大值</span><span class="hljs-deletion">-Xss：栈空间</span></code></pre><p>-Xms 和 -Xmx最好调整一致，防止JVM频繁进行收集和回收</p><h3 id="JVM参数类型"><a href="#JVM参数类型" class="headerlink" title="JVM参数类型"></a>JVM参数类型</h3><ul><li>标配参数（从JDK1.0 - Java12都在，很稳定）<ul><li>-version</li><li>-help</li><li>java -showversion</li></ul></li><li>X参数（了解）<ul><li>-Xint：解释执行</li><li>-Xcomp：第一次使用就编译成本地代码</li><li>-Xmixed：混合模式</li></ul></li><li><strong>XX参数</strong> （重点）<ul><li>Boolean类型<ul><li>公式：-XX:+ 或者-某个属性 + 表示开启，-表示关闭</li><li>Case：-XX:-PrintGCDetails：表示关闭了GC详情输出</li></ul></li><li>key-value类型<ul><li>公式：-XX:属性key=属性value</li><li>不满意初始值，可以通过下列命令调整</li><li>case：如何：-XX:MetaspaceSize=21807104：查看Java元空间的值</li></ul></li></ul></li></ul><h3 id="查看运行的Java程序，JVM参数是否开启，具体值为多少？"><a href="#查看运行的Java程序，JVM参数是否开启，具体值为多少？" class="headerlink" title="查看运行的Java程序，JVM参数是否开启，具体值为多少？"></a>查看运行的Java程序，JVM参数是否开启，具体值为多少？</h3><h4 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h4><p>首先我们运行一个HelloGC的java程序</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Code22_HelloGC</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        System.out.println(<span class="hljs-string">&quot;hello GC&quot;</span>);        Thread.sleep(Integer.MAX_VALUE);    &#125;&#125;</code></pre><p>然后使用下列命令查看它的默认参数</p><pre><code class="hljs shell">jps：查看java的后台进程jinfo：查看正在运行的java程序</code></pre><p>具体使用：</p><pre><code class="hljs shell">jps -l得到进程号</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210419090019.png"></p><p>查看到HelloGC的进程号为：95447</p><p>我们使用jinfo -flag 然后查看是否开启PrintGCDetails这个参数</p><pre><code class="hljs js">qiukedeMacBook-Pro-<span class="hljs-number">2</span>:meeting qiuke$ jps -l<span class="hljs-number">95634</span> sun.tools.jps.Jps<span class="hljs-number">95447</span> Code22_HelloGC<span class="hljs-number">95446</span> org.jetbrains.jps.cmdline.Launcher<span class="hljs-number">11256</span> qiukedeMacBook-Pro-<span class="hljs-number">2</span>:meeting qiuke$ jinfo -flag PrintGCDetails <span class="hljs-number">95447</span>-XX:-PrintGCDetails</code></pre><p>上面提到了，-号表示关闭，即没有开启PrintGCDetails这个参数</p><p>下面我们需要在启动HelloGC的时候， <strong>增加</strong>  PrintGCDetails这个参数，需要在运行程序的时候配置JVM参数</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210419090223.png"></p><p>再次如上操作：</p><pre><code class="hljs js">qiukedeMacBook-Pro-<span class="hljs-number">2</span>:meeting qiuke$ jps -l<span class="hljs-number">96100</span> sun.tools.jps.Jps<span class="hljs-number">11256</span> <span class="hljs-number">96045</span> Code22_HelloGC<span class="hljs-number">96044</span> org.jetbrains.jps.cmdline.LauncherqiukedeMacBook-Pro-<span class="hljs-number">2</span>:meeting qiuke$ jinfo -flag PrintGCDetails <span class="hljs-number">96045</span>-XX:+PrintGCDetails</code></pre><p>我们看到原来的-号变成了+号，说明我们通过 VM Options配置的JVM参数已经生效了</p><p>使用下列命令，会把jvm的 <strong>全部默认参数输出</strong> </p><pre><code class="hljs shell">jinfo -flags ***</code></pre><h4 id="KV设置类型"><a href="#KV设置类型" class="headerlink" title="KV设置类型"></a>KV设置类型</h4><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210419092534.png"></p><pre><code class="hljs js">qiukedeMacBook-Pro-<span class="hljs-number">2</span>:meeting qiuke$ jps -l<span class="hljs-number">11256</span> <span class="hljs-number">99069</span> sun.tools.jps.Jps<span class="hljs-number">98911</span> Code22_HelloGC<span class="hljs-number">98910</span> org.jetbrains.jps.cmdline.LauncherqiukedeMacBook-Pro-<span class="hljs-number">2</span>:meeting qiuke$ jinfo -flag MetaspaceSize <span class="hljs-number">98911</span>-XX:MetaspaceSize=<span class="hljs-number">21807104</span></code></pre><h3 id="题外话（坑题）"><a href="#题外话（坑题）" class="headerlink" title="题外话（坑题）"></a>题外话（坑题）</h3><p>两个经典参数：-Xms 和 -Xmx，这两个参数 如何解释</p><p>这两个参数，还是属于XX参数，因为取了别名</p><ul><li>-Xms 等价于 -XX:InitialHeapSize ：初始化堆内存（默认只会用最大物理内存的64分1）</li><li>-Xmx 等价于 -XX:MaxHeapSize ：最大堆内存（默认只会用最大物理内存的4分1）</li></ul><h3 id="查看JVM默认参数"><a href="#查看JVM默认参数" class="headerlink" title="查看JVM默认参数"></a>查看JVM默认参数</h3><ul><li><p>-XX:+PrintFlagsInitial</p><ul><li><p>主要是查看初始默认值</p></li><li><p>公式</p><ul><li><p>java -XX:+PrintFlagsInitial -version</p></li><li><p>java -XX:+PrintFlagsInitial（重要参数）</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210419094429.png"></p></li></ul></li></ul></li><li><p>-XX:+PrintFlagsFinal：表示修改以后，最终的值</p><p>会将JVM的各个结果都进行打印</p><p>如果有 := 表示 <strong>修改过的</strong> ， = 表示没有修改过的</p></li></ul><h3 id="修改变更JVM参数"><a href="#修改变更JVM参数" class="headerlink" title="修改变更JVM参数"></a>修改变更JVM参数</h3><p>PrintFlagsFinal举例，运行java命令的同时打印出参数</p><pre><code class="hljs js">java -XX:+PrintFlagsFinal -XX:MetaspaceSize=512m HelloWorld</code></pre><p>打印命令行参数</p><p>-XX:+PrintCommandLineFlags</p><h3 id="工作中常用的JVM基本配置参数"><a href="#工作中常用的JVM基本配置参数" class="headerlink" title="工作中常用的JVM基本配置参数"></a>工作中常用的JVM基本配置参数</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210419094934.png"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210419100741.png"></p><h4 id="Xms-Xmx"><a href="#Xms-Xmx" class="headerlink" title="Xms Xmx"></a>Xms Xmx</h4><p>查看JVM的初始化堆内存 -Xms 和最大堆内存 Xmx</p><p>-XX:InitialHeapSize 和 -XX:MaxHeapSize</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">checkJVM</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-comment">// 返回Java虚拟机中内存的总量</span>    <span class="hljs-keyword">long</span> totalMemory = Runtime.getRuntime().totalMemory();    <span class="hljs-comment">// 返回Java虚拟机中试图使用的最大内存量</span>    <span class="hljs-keyword">long</span> maxMemory = Runtime.getRuntime().maxMemory();    System.out.println(<span class="hljs-string">&quot;TOTAL_MEMORY(-Xms) = &quot;</span> + totalMemory + <span class="hljs-string">&quot;(字节)、&quot;</span> + (totalMemory / (<span class="hljs-keyword">double</span>)<span class="hljs-number">1024</span> / <span class="hljs-number">1024</span>) + <span class="hljs-string">&quot;MB&quot;</span>);    System.out.println(<span class="hljs-string">&quot;MAX_MEMORY(-Xmx) = &quot;</span> + maxMemory + <span class="hljs-string">&quot;(字节)、&quot;</span> + (maxMemory / (<span class="hljs-keyword">double</span>)<span class="hljs-number">1024</span> / <span class="hljs-number">1024</span>) + <span class="hljs-string">&quot;MB&quot;</span>);&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210419101152.png"></p><p>-Xms 初始堆内存为：物理内存的1/64 -Xmx 最大堆内存为：系统物理内存的 1/4</p><h4 id="Xss"><a href="#Xss" class="headerlink" title="Xss"></a>Xss</h4><p>设置单个线程栈的大小，一般默认为512k~1024K</p><p>等价于-XX:ThreadStackSize</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210419102115.png"></p><p>0 128都能运行</p><blockquote><p>-XX:ThreadStackSize=size</p><p>Sets the thread stack size (in bytes). Append the letter k or K to indicate kilobytes, m or M to indicate megabytes, g or G to indicate gigabytes. The default value depends on virtual memory.</p><p>The following examples show how to set the thread stack size to 1024 KB in different units:</p><p>1 -XX:ThreadStackSize=1m<br>2 -XX:ThreadStackSize=1024k<br>3 -XX:ThreadStackSize=1048576</p><p>This option is equivalent to -Xss.</p><p><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/windows/java.html#BGBCIEFC">官方文档</a></p></blockquote><h4 id="xmn"><a href="#xmn" class="headerlink" title="xmn"></a>xmn</h4><p>-Xmn：设置年轻代大小</p><p>-XX:MetaspaceSize 设置 <strong>元空间</strong> 大小</p><p>元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制</p><h4 id="典型设置案例"><a href="#典型设置案例" class="headerlink" title="典型设置案例"></a>典型设置案例</h4><p>-Xms128m -Xmx4096m -Xss1024k -XX:MetaspaceSize=512m -XX:+PrintCommandLineFlags -XX:+PrintGCDetails-XX:+UseSerialGC</p><h4 id="PrintGCDetails"><a href="#PrintGCDetails" class="headerlink" title="PrintGCDetails"></a>PrintGCDetails</h4><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210419104448.png"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210419104518.png"></p><h4 id="GC查看"><a href="#GC查看" class="headerlink" title="GC查看"></a>GC查看</h4><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210419104643.png"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210419104643.png"></p><h4 id="XX-SurvivorRatio"><a href="#XX-SurvivorRatio" class="headerlink" title="-XX:SurvivorRatio"></a>-XX:SurvivorRatio</h4><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210419105325.png"></p><p>调节新生代中 eden 和 S0、S1的空间比例，默认为 -XX:SuriviorRatio=8，Eden:S0:S1 =  <strong>8:1:1</strong> </p><p>假如设置成 -XX:SurvivorRatio=4，则为 Eden:S0:S1 = 4:1:1</p><p>SurvivorRatio值就是设置eden区的比例占多少，S0和S1相同。</p><ul><li>eden、SurvivorFrom复制到SurvivorTo，年龄 + 1</li></ul><p>首先，当Eden区满的时候会触发第一次GC，把还活着的对象拷贝到SurvivorFrom去，当Eden区再次触发GC的时候会扫描Eden区合From区域，对这两个区域进行垃圾回收，经过这次回收后还存活的对象，则直接复制到To区域（如果对象的年龄已经到达老年的标准，则赋值到老年代区），通知把这些对象的年龄 + 1</p><ul><li>清空eden、SurvivorFrom</li></ul><p>然后，清空eden，SurvivorFrom中的对象，也即复制之后有交换，谁空谁是to</p><ul><li>SurvivorTo和SurvivorFrom互换</li></ul><p>最后，SurvivorTo和SurvivorFrom互换，原SurvivorTo成为下一次GC时的SurvivorFrom区，部分对象会在From和To区域中复制来复制去，如此 <strong>交换15次</strong> （由JVM参数 <strong>MaxTenuringThreshold</strong> 决定，这个参数默认为15），最终如果还是存活，就存入老年代</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210419105920.png"></p><h4 id="XX-NewRatio（了解）"><a href="#XX-NewRatio（了解）" class="headerlink" title="-XX:NewRatio（了解）"></a>-XX:NewRatio（了解）</h4><p>配置年轻代new 和老年代old 在堆结构的占比</p><p>默认： -XX:NewRatio=2 新生代占1，老年代2，年轻代占整个堆的1/3</p><p>-XX:NewRatio=4：新生代占1，老年代占4，年轻代占整个堆的1/5，NewRadio值就是设置老年代的占比，剩下的1个新生代</p><p>新生代特别小，会造成频繁的进行GC收集</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210419110844.png"></p><h4 id="XX-MaxTenuringThreshold"><a href="#XX-MaxTenuringThreshold" class="headerlink" title="-XX:MaxTenuringThreshold"></a>-XX:MaxTenuringThreshold</h4><p>设置垃圾最大年龄，SurvivorTo和SurvivorFrom互换，原SurvivorTo成为下一次GC时的SurvivorFrom区，部分对象会在From和To区域中复制来复制去，如此交换15次（由JVM参数MaxTenuringThreshold决定，这个参数默认为15），最终如果还是存活，就存入老年代</p><p>这里就是调整这个次数的，默认是15，并且设置的值 在 0~15之间</p><p>查看默认进入老年代年龄：jinfo -flag MaxTenuringThreshold 17344</p><p>-XX:MaxTenuringThreshold=0：设置垃圾最大年龄。如果设置为0的话，则年轻对象不经过Survivor区，直接进入老年代。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大的值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概念</p><h2 id="Java中的引用"><a href="#Java中的引用" class="headerlink" title="Java中的引用"></a>Java中的引用</h2><h3 id="前言-3"><a href="#前言-3" class="headerlink" title="前言"></a>前言</h3><p>在原来的时候，我们谈到一个类的实例化</p><pre><code class="hljs haxe">Person p = <span class="hljs-keyword">new</span> <span class="hljs-type">Person</span>()</code></pre><p>在等号的左边，就是一个对象的引用，存储在 **栈中 **</p><p>而等号右边，就是实例化的对象，存储在 <strong>堆中</strong> </p><p>其实这样的一个引用关系，就被称为强引用</p><h3 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210421080219.png"></p><h3 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h3><p>当内存不足的时候，JVM开始垃圾回收， <strong>对于强引用的对象，就算是出现了OOM也不会对该对象进行回收</strong> ，打死也不回收！</p><p>强引用是我们最常见的普通对象引用，只要还有 <strong>一个强引用指向一个对象，就能表明对象还“活着”</strong> ，垃圾收集器不会碰这种对象。在Java中最常见的就是强引用，把一个对象赋给一个引用变量，这个引用变量就是一个强引用。当一个对象被强引用变量引用时，它处于 <strong>可达状态</strong> ，它是不可能被垃圾回收机制回收的，即使该对象以后永远都不会被用到，JVM也不会回收，因此 <strong>强引用是造成Java内存泄漏的主要原因之一</strong> 。</p><p>对于一个普通的对象，如果没有其它的引用关系，只要超过了引用的作用域或者显示地将相应（强）引用赋值为null，一般可以认为就是可以被垃圾收集的了（当然具体回收时机还是要看垃圾回收策略）</p><p>强引用小例子：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">StrongReferenceDemo</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// 这样定义的默认就是强应用</span>    Object obj1 = <span class="hljs-keyword">new</span> Object();    <span class="hljs-comment">// 使用第二个引用，指向刚刚创建的Object对象</span>    Object obj2 = obj1;    <span class="hljs-comment">// 置空</span>    obj1 = <span class="hljs-keyword">null</span>;    <span class="hljs-comment">// 垃圾回收</span>    System.gc();    System.out.println(obj1);    System.out.println(obj2);&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210421080832.png"></p><p>输出结果我们能够发现，即使 obj1 被设置成了null，然后调用gc进行回收，但是也没有回收实例出来的对象，obj2还是能够指向该地址，也就是说垃圾回收器，并 <strong>没有将该对象进行垃圾回收</strong> </p><h3 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h3><p>软引用是一种相对弱化了一些的引用，需要用Java.lang.ref.SoftReference类来实现，可以让对象豁免一些垃圾收集，对于只有软引用的对象来讲：</p><ul><li>当系统内存充足时，它不会被回收</li><li>当系统 <strong>内存不足时，它会被回收</strong> </li></ul><p>软引用通常在对内存敏感的程序中，比如 <strong>高速缓存就用到了软引用</strong> ，内存够用 的时候就保留，不够用就回收</p><p>具体使用</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 内存够用的时候</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">softRefMemoryEnough</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// 创建一个强应用</span>    Object o1 = <span class="hljs-keyword">new</span> Object();    <span class="hljs-comment">// 创建一个软引用</span>    SoftReference&lt;Object&gt; softReference = <span class="hljs-keyword">new</span> SoftReference&lt;&gt;(o1);    System.out.println(o1);    System.out.println(softReference.get());    o1 = <span class="hljs-keyword">null</span>;    <span class="hljs-comment">// 手动GC</span>    System.gc();    System.out.println(o1);    System.out.println(softReference.get());&#125;</code></pre><p>得到结果：</p><p>我们写了两个方法，一个是内存够用的时候，一个是内存不够用的时候</p><p>我们首先查看内存够用的时候，首先输出的是 o1 和 软引用的 softReference，我们都能够看到值</p><p>然后我们把o1设置为null，执行手动GC后，我们发现 <strong>softReference的值还存在</strong> ，说明内存充足的时候，软引用的对象不会被回收</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210421081338.png"></p><p>更改代码，手动OOM：</p><p>使用了JVM启动参数配置，给初始化堆内存为5M，创建了一个30M的大对象；</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * JVM配置，故意产生大对象并配置小的内存，让它的内存不够用了导致OOM，看软引用的回收情况</span><span class="hljs-comment"> * -Xms5m -Xmx5m -XX:+PrintGCDetails</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">softRefMemoryNoEnough</span><span class="hljs-params">()</span> </span>&#123;    System.out.println(<span class="hljs-string">&quot;========================&quot;</span>);    <span class="hljs-comment">// 创建一个强应用</span>    Object o1 = <span class="hljs-keyword">new</span> Object();    <span class="hljs-comment">// 创建一个软引用</span>    SoftReference&lt;Object&gt; softReference = <span class="hljs-keyword">new</span> SoftReference&lt;&gt;(o1);    System.out.println(o1);    System.out.println(softReference.get());    o1 = <span class="hljs-keyword">null</span>;    <span class="hljs-comment">// 模拟OOM自动GC</span>    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-comment">// 创建30M的大对象</span>        <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">30</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>];    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;        e.printStackTrace();    &#125; <span class="hljs-keyword">finally</span> &#123;        System.out.println(o1);        System.out.println(softReference.get());    &#125;&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210421081449.png"></p><p>这就必然会触发垃圾回收机制，这也是中间出现的垃圾回收过程，最后看结果我们发现，o1 和 softReference都被回收了，因此说明， <strong>软引用</strong> 在 <strong>内存不足</strong> 的时候， <strong>会自动回收</strong> </p><h3 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h3><p>不管内存是否够，只要有GC操作就会进行回收</p><p>弱引用需要用 <code>java.lang.ref.WeakReference</code> 类来实现，它比软引用生存期更短</p><p>对于只有弱引用的对象来说，只要垃圾回收机制一运行，不管JVM的内存空间是否足够， <strong>都会回收</strong> 该对象占用的空间。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">weakReferenceDemo</span><span class="hljs-params">()</span> </span>&#123;    Object o1 = <span class="hljs-keyword">new</span> Object();    WeakReference&lt;Object&gt; weakReference = <span class="hljs-keyword">new</span> WeakReference&lt;&gt;(o1);    System.out.println(o1);    System.out.println(weakReference.get());    o1 = <span class="hljs-keyword">null</span>;    System.gc();    System.out.println(o1);    System.out.println(weakReference.get());&#125;</code></pre><p>我们并没有制造出OOM内存溢出，而只是调用了一下GC操作，垃圾回收就把它给收集了</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210421081830.png"></p><h3 id="软引用和弱引用的使用场景"><a href="#软引用和弱引用的使用场景" class="headerlink" title="软引用和弱引用的使用场景"></a>软引用和弱引用的使用场景</h3><p>场景：假如有一个应用需要读取大量的本地图片</p><ul><li>如果每次读取图片都从硬盘读取则会严重 <strong>影响性能</strong> </li><li>如果一次性全部加载到内存中，又可能造成 <strong>内存溢出</strong> </li></ul><p>此时使用软引用可以解决这个问题</p><p>设计思路：使用HashMap来保存 <strong>图片的路径</strong> 和相应 <strong>图片对象关联的软引用</strong> 之间的映射关系，在内存不足时，JVM会自动回收这些缓存图片对象所占的空间，从而有效地避免了OOM的问题</p><pre><code class="hljs java">Map&lt;String, SoftReference&lt;String&gt;&gt; imageCache = <span class="hljs-keyword">new</span> HashMap&lt;String, SoftReference&lt;Bitmap&gt;&gt;();</code></pre><h3 id="WeakHashMap是什么？"><a href="#WeakHashMap是什么？" class="headerlink" title="WeakHashMap是什么？"></a>WeakHashMap是什么？</h3><p>比如一些常常和底层打交道的， <strong>mybatis</strong> 等，底层都应用到了 <strong>WeakHashMap</strong> </p><p>WeakHashMap和HashMap类似，只不过它的 <strong>Key是使用了弱引用的</strong> ，也就是说，当执行GC的时候，HashMap中的key会进行回收，下面我们使用例子来测试一下</p><p>我们使用了两个方法，一个是普通的HashMap方法</p><p>测试：</p><p>我们输入一个Key-Value键值对，然后让它的key置空，然后在查看结果</p><p>第二个是使用了WeakHashMap，完整代码如下</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">myHashMap</span><span class="hljs-params">()</span> </span>&#123;        Map&lt;Integer, String&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        Integer key = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">1</span>);        String value = <span class="hljs-string">&quot;HashMap&quot;</span>;        map.put(key, value);        System.out.println(map);        key = <span class="hljs-keyword">null</span>;        System.gc();        System.out.println(map);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">myWeakHashMap</span><span class="hljs-params">()</span> </span>&#123;        Map&lt;Integer, String&gt; map = <span class="hljs-keyword">new</span> WeakHashMap&lt;&gt;();        Integer key = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">1</span>);        String value = <span class="hljs-string">&quot;WeakHashMap&quot;</span>;        map.put(key, value);        System.out.println(map);        key = <span class="hljs-keyword">null</span>;        System.gc();        System.out.println(map);    &#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210421083335.png"></p><p>从这里我们看到，对于普通的HashMap来说，key置空并不会影响，HashMap的键值对，因为这个属于强引用，不会被垃圾回收。</p><p>但是WeakHashMap，在进行GC操作后， <strong>弱引用的就会被回收</strong> </p><h3 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h3><h4 id="概念-9"><a href="#概念-9" class="headerlink" title="概念"></a>概念</h4><p>虚引用又称为 <strong>幽灵引用</strong> ，需要<code>java.lang.ref.PhantomReference</code> 类来实现</p><p>顾名思义，就是形同虚设，与其他几种引用都不同， <strong>虚引用并不会决定对象的生命周期</strong> 。</p><p>如果一个对象持有虚引用，那么 <strong>它就和没有任何引用一样</strong> ，在 <strong>任何时候都可能被垃圾回收器回收</strong> ，它 <strong>不能单独使用</strong> 也不能通过它访问对象，虚引用 <strong>必须和引用队列ReferenceQueue联合使用</strong> 。</p><p>虚引用的主要作用是 <strong><em>跟踪对象被垃圾回收的状态</em></strong> ，仅仅是提供一种确保对象被finalize以后，做某些事情的机制。</p><p>PhantomReference的get方法总是返回null，因此 <strong>无法访问对象的引用对象</strong> 。其意义在于说明一个对象已经进入finalization阶段，可以被gc回收，用来实现比finalization机制更灵活的回收操作</p><p>换句话说，设置虚引用关联的唯一目的，就是 <strong><em>在这个对象被收集器回收的时候，收到一个系统通知或者后续添加进一步的处理，Java技术允许使用finalize()方法在垃圾收集器将对象从内存中清除出去之前，做必要的清理工作</em></strong> </p><p>这个就相当于Spring AOP里面的 <strong>后置通知</strong> </p><h4 id="场景-1"><a href="#场景-1" class="headerlink" title="场景"></a>场景</h4><p>一般用于在回收时候做通知相关操作</p><h3 id="引用队列-ReferenceQueue"><a href="#引用队列-ReferenceQueue" class="headerlink" title="引用队列 ReferenceQueue"></a>引用队列 ReferenceQueue</h3><p>软引用，弱引用，虚引用在回收之前，需要在 <strong>引用队列保存一下</strong> </p><p>我们在初始化的弱引用或者虚引用的时候，可以传入一个引用队列</p><p>那么在进行GC回收的时候， <strong>弱引用和虚引用的对象都会被回收</strong> ，但是在回收之前，它会被送至引用队列中</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">referenceQueueDemo</span><span class="hljs-params">()</span> </span>&#123;        Object o1 = <span class="hljs-keyword">new</span> Object();        <span class="hljs-comment">// 创建引用队列</span>        ReferenceQueue&lt;Object&gt; referenceQueue = <span class="hljs-keyword">new</span> ReferenceQueue&lt;&gt;();        <span class="hljs-comment">// 创建一个弱引用</span>        WeakReference&lt;Object&gt; weakReference = <span class="hljs-keyword">new</span> WeakReference&lt;&gt;(o1, referenceQueue);        <span class="hljs-comment">// 创建一个虚引用</span><span class="hljs-comment">//        PhantomReference&lt;Object&gt; reference = new PhantomReference&lt;&gt;(o1, referenceQueue);</span>        System.out.println(o1);        System.out.println(weakReference.get());        <span class="hljs-comment">// 取队列中的内容</span>        System.out.println(referenceQueue.poll());        o1 = <span class="hljs-keyword">null</span>;        System.gc();        System.out.println(<span class="hljs-string">&quot;执行GC操作&quot;</span>);        <span class="hljs-keyword">try</span> &#123;            TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        System.out.println(o1);        System.out.println(weakReference.get());        <span class="hljs-comment">// 取队列中的内容</span>        System.out.println(referenceQueue.poll());    &#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210421085733.png"></p><p>从这里我们能看到，在进行垃圾回收后，我们弱引用对象，也被设置成null，但是在队列中还能够导出该引用的实例，这就说明在回收之前，该弱引用的实例 <strong>被放置引用队列中</strong> 了，我们可以通过引用队列进行一些后置操作</p><p>如果把上列代码换成虚引用：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210421090517.png"></p><h3 id="GCRoots和四大引用小总结"><a href="#GCRoots和四大引用小总结" class="headerlink" title="GCRoots和四大引用小总结"></a>GCRoots和四大引用小总结</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210421090816.png"></p><h2 id="Java内存溢出OOM"><a href="#Java内存溢出OOM" class="headerlink" title="Java内存溢出OOM"></a>Java内存溢出OOM</h2><h3 id="经典错误"><a href="#经典错误" class="headerlink" title="经典错误"></a>经典错误</h3><p>JVM中常见的两个错误</p><p>StackoverFlowError ：栈溢出</p><p>OutofMemoryError: java heap space：堆溢出</p><p>除此之外，还有以下的错误</p><ul><li>java.lang.StackOverflowError</li><li>java.lang.OutOfMemoryError：java heap space</li><li>java.lang.OutOfMemoryError：GC overhead limit exceeeded</li><li>java.lang.OutOfMemoryError：Direct buffer memory</li><li>java.lang.OutOfMemoryError：unable to create new native thread</li><li>java.lang.OutOfMemoryError：Metaspace</li></ul><h3 id="架构-1"><a href="#架构-1" class="headerlink" title="架构"></a>架构</h3><p>OutOfMemoryError和StackOverflowError是属于Error，不是Exception</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210421091320.png"></p><h3 id="StackoverFlowError"><a href="#StackoverFlowError" class="headerlink" title="StackoverFlowError"></a>StackoverFlowError</h3><p>堆栈溢出，栈管方法，我们有最简单的一个递归调用，就会造成堆栈溢出，也就是深度的方法调用</p><p>栈一般是512K，不断的深度调用，直到栈被撑破</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 栈一般是512K，不断的深度调用，直到栈被撑破</span><span class="hljs-comment"> * Exception in thread &quot;main&quot; java.lang.StackOverflowError</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stackOverflowError</span><span class="hljs-params">()</span> </span>&#123;    stackOverflowError();&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210421091659.png"></p><h3 id="OutOfMemoryError"><a href="#OutOfMemoryError" class="headerlink" title="OutOfMemoryError"></a>OutOfMemoryError</h3><h4 id="java-heap-space"><a href="#java-heap-space" class="headerlink" title="java heap space"></a>java heap space</h4><p>创建了很多对象，导致堆空间不够存储</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">heapSpaceDemo</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// 堆空间的大小 -Xms10m -Xmx10m</span>    <span class="hljs-comment">// 创建一个 80M的字节数组</span>    <span class="hljs-keyword">byte</span> [] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">80</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>];&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210421094730.png"></p><h4 id="GC-overhead-limit-exceeded"><a href="#GC-overhead-limit-exceeded" class="headerlink" title="GC overhead limit exceeded"></a>GC overhead limit exceeded</h4><p>GC回收时间过长时会抛出OutOfMemoryError，过长的定义是，超过了98%的时间用来做GC，并且回收了不到2%的堆内存</p><p>连续多次GC都只回收了不到2%的极端情况下，才会抛出。假设不抛出GC overhead limit 错误会造成什么情况呢？</p><p>那就是GC清理的这点内存很快会再次被填满，迫使GC再次执行，这样就形成了恶性循环，CPU的使用率一直都是100%，而GC却没有任何成果。</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210421095832.png"></p><p>代码演示：</p><p>为了更快的达到效果，我们首先需要设置JVM启动参数</p><pre><code class="hljs java">-Xms10m -Xmx10m -XX:+PrintGCDetails -XX:MaxDirectMemorySize=5m</code></pre><p>这个异常出现的步骤就是，我们不断的向list中插入String对象，直到启动GC回收</p><pre><code class="hljs java"><span class="hljs-comment">// -Xms10m -Xmx10m -XX:+PrintGCDetails -XX:MaxDirectMemorySize=5m</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">GClimit</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;    List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;            list.add(String.valueOf(++i).intern());        &#125;    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;        System.out.println(<span class="hljs-string">&quot;***************i:&quot;</span> + i);        e.printStackTrace();        <span class="hljs-keyword">throw</span> e;    &#125; <span class="hljs-keyword">finally</span> &#123;    &#125;&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210421100931.png"></p><p>我们能够看到 多次Full GC，并没有清理出空间，在多次执行GC操作后，就抛出异常 GC overhead limit</p><h4 id="Direct-buffer-memory"><a href="#Direct-buffer-memory" class="headerlink" title="Direct buffer memory"></a>Direct buffer memory</h4><p>Netty + NIO：这是由于 <strong>NIO引起的</strong> </p><p>写NIO程序的时候经常会使用 <strong>ByteBuffer</strong> 来读取或写入数据，这是一种基于通道(Channel) 与 缓冲区(Buffer)的I/O方式，它可以使用Native 函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。</p><p> <strong>ByteBuffer.allocate(capability)</strong> ：第一种方式是分配JVM堆内存，属于GC管辖范围，由于需要拷贝所以速度相对较慢</p><p> <strong>ByteBuffer.allocteDirect(capability)</strong> ：第二种方式是分配OS本地内存，不属于GC管辖范围，由于不需要内存的拷贝，所以速度相对较快</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210421102643.png"></p><p>但如果不断分配本地内存，堆内存很少使用，那么JVM就不需要执行GC，DirectByteBuffer对象就不会被回收，这时候怼内存充足，但本地内存可能已经使用光了，再次尝试分配本地内存就会出现OutOfMemoryError，那么程序就奔溃了。</p><p>一句话说： <strong>本地内存不足，但是堆内存充足的时候</strong> ，就会出现这个问题</p><p>我们使用 -XX:MaxDirectMemorySize=5m 配置能使用的堆外物理内存为5M</p><pre><code class="hljs java">-Xms10m -Xmx10m -XX:+PrintGCDetails -XX:MaxDirectMemorySize=5m</code></pre><p>然后我们申请一个6M的空间</p><pre><code class="hljs java"><span class="hljs-comment">// 只设置了5M的物理内存使用，但是却分配 6M的空间</span>ByteBuffer bb = ByteBuffer.allocateDirect(<span class="hljs-number">6</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>);</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210421101944.png"></p><h4 id="unable-to-create-new-native-thread"><a href="#unable-to-create-new-native-thread" class="headerlink" title="unable to create new native thread"></a>unable to create new native thread</h4><p>不能够创建更多的新的线程了，也就是说 <strong>创建线程的上限达到了</strong> </p><p>在高并发场景的时候，会应用到</p><p>高并发请求服务器时，经常会出现如下异常<code>java.lang.OutOfMemoryError:unable to create new native thread</code>，准确说该native thread异常与对应的平台有关</p><p>导致原因：</p><ul><li>应用 <strong>创建了太多线程</strong> ，一个应用进程创建多个线程，超过系统承载极限</li><li> <strong>服务器并不允许你的应用程序创建这么多线程</strong> ，linux系统默认运行单个进程可以创建的线程为 <strong>1024个</strong> ，如果应用创建超过这个数量，就会报 <code>java.lang.OutOfMemoryError:unable to create new native thread</code></li></ul><p>解决方法：</p><ol><li>想办法 <strong>降低你应用程序创建线程的数量</strong> ，分析应用是否真的需要创建这么多线程，如果不是，改代码将线程数降到最低</li><li>对于有的应用，确实需要创建很多线程，远超过linux系统默认1024个线程限制，可以通过 <strong>修改linux服务器配置</strong> ，扩大linux默认限制</li></ol><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unableCreateNewThreadDemo</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; ; i++) &#123;        System.out.println(<span class="hljs-string">&quot;************** i = &quot;</span> + i);        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            <span class="hljs-keyword">try</span> &#123;                TimeUnit.SECONDS.sleep(Integer.MAX_VALUE);            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;, String.valueOf(i)).start();    &#125;&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210421102303.png"></p><p>如何查看线程数</p><pre><code class="hljs java">ulimit -u</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210421104732.png"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210421104805.png"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210421104849.png"></p><h4 id="Metaspace"><a href="#Metaspace" class="headerlink" title="Metaspace"></a>Metaspace</h4><p>元空间内存不足，Matespace元空间应用的是本地内存</p><p><code>-XX:MetaspaceSize</code> 的处理化大小为20M</p><h5 id="元空间是什么"><a href="#元空间是什么" class="headerlink" title="元空间是什么"></a>元空间是什么</h5><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210421105112.png"></p><p>元空间就是我们的 <strong>方法区</strong> ，存放的是 <strong>类模板，类信息，常量池</strong> 等</p><p>Metaspace是方法区HotSpot中的实现，它与持久代最大的区别在于：Metaspace并不在虚拟内存中，而是使用本地内存，也即在java8中，class metadata（the virtual machines internal presentation of Java class），被存储在叫做Matespace的native memory</p><p>永久代（java8后被元空间Metaspace取代了）存放了以下信息：</p><ul><li>虚拟机加载的类信息</li><li>常量池</li><li>静态变量</li><li>即时编译后的代码</li></ul><p>模拟Metaspace空间溢出，我们不断生成类 往元空间里灌输，类占据的空间总会超过Metaspace指定的空间大小</p><h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><p>在模拟异常生成时候，因为初始化的元空间为20M，因此我们使用JVM参数调整元空间的大小，为了更好的效果</p><pre><code class="hljs java">-XX:MetaspaceSize=8m -XX:MaxMetaspaceSize=8m</code></pre><pre><code class="hljs java"><span class="hljs-comment">// 静态类</span><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OOMTest</span> </span>&#123;&#125;<span class="hljs-comment">// -XX:MetaspaceSize=8m -XX:MaxMetaspaceSize=8m</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">metaspaceOutOfMemoryDemo</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-comment">// 模拟计数多少次以后发生异常</span>    <span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;            i++;            <span class="hljs-comment">// 使用Spring的动态字节码技术</span>            Enhancer enhancer = <span class="hljs-keyword">new</span> Enhancer();            enhancer.setSuperclass(OOMTest.class);            enhancer.setUseCache(<span class="hljs-keyword">false</span>);            enhancer.setCallback(<span class="hljs-keyword">new</span> MethodInterceptor() &#123;                <span class="hljs-meta">@Override</span>                <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">intercept</span><span class="hljs-params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;                    <span class="hljs-keyword">return</span> methodProxy.invokeSuper(o, args);                &#125;            &#125;);        &#125;    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;        System.out.println(<span class="hljs-string">&quot;发生异常的次数:&quot;</span> + i);        e.printStackTrace();    &#125; <span class="hljs-keyword">finally</span> &#123;    &#125;&#125;</code></pre><p>会出现以下错误：</p><pre><code class="hljs java">发生异常的次数: <span class="hljs-number">201</span>java.lang.OutOfMemoryError:Metaspace</code></pre><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><h3 id="GC垃圾回收算法和垃圾收集器关系"><a href="#GC垃圾回收算法和垃圾收集器关系" class="headerlink" title="GC垃圾回收算法和垃圾收集器关系"></a>GC垃圾回收算法和垃圾收集器关系</h3><blockquote><p>天上飞的理念，要有落地的实现（垃圾收集器就是GC垃圾回收算法的实现）</p><p>GC算法是内存回收的方法论，垃圾收集器就是算法的落地实现</p></blockquote><p>GC算法主要有以下几种</p><ul><li>引用计数（几乎不用，无法解决循环引用的问题）</li><li>复制拷贝（用于新生代）</li><li>标记清除（用于老年代）</li><li>标记整理（用于老年代）</li></ul><p>因为目前为止还没有完美的收集器出现，更没有万能的收集器，只是针对具体应用最合适的收集器，进行分代收集（那个代用什么收集器）</p><h3 id="四种主要的垃圾收集器"><a href="#四种主要的垃圾收集器" class="headerlink" title="四种主要的垃圾收集器"></a>四种主要的垃圾收集器</h3><ul><li>Serial：串行回收 <code>-XX:+UseSeriallGC</code></li><li>Parallel：并行回收 <code>-XX:+UseParallelGC</code></li><li>CMS：并发标记清除</li><li>G1</li><li>ZGC：（java 11 出现的）</li></ul><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210421110535.png"></p><h4 id="Serial"><a href="#Serial" class="headerlink" title="Serial"></a>Serial</h4><p>串行垃圾回收器，它为 <strong>单线程环境</strong> 设计且值使用一个线程进行垃圾收集，会 <strong>暂停所有的用户线程</strong> ，只有当垃圾回收完成时，才会重新唤醒主线程继续执行。所以 <strong>不适合</strong> 服务器环境</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210422094624.png"></p><h4 id="Parallel"><a href="#Parallel" class="headerlink" title="Parallel"></a>Parallel</h4><p>并行垃圾收集器，多个垃圾收集线程并行工作，此时 <strong>用户线程也是阻塞</strong> 的，适用于科学计算 / 大数据处理等弱交互场景，也就是说 <strong>Serial 和 Parallel其实是类似的，不过是多了几个线程进行垃圾收集，但是主线程都会被暂停</strong> ，但是并行垃圾收集器处理时间，肯定比串行的垃圾收集器要更短</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210422094811.png"></p><h4 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h4><p>并发标记清除，用户线程和垃圾收集线程 <strong>同时执行</strong> （不一定是并行，可能是交替执行），不需要停顿用户线程，互联网公司都在使用，适用于响应时间有要求的场景。并发是可以有交互的，也就是说可以一边进行收集，一边执行应用程序。</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210422095000.png"></p><h4 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h4><p>G1垃圾回收器将堆内存分割成不同区域，然后 <strong>并发</strong> 的进行垃圾回收</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210422095045.png"></p><h3 id="垃圾收集器总结"><a href="#垃圾收集器总结" class="headerlink" title="垃圾收集器总结"></a>垃圾收集器总结</h3><p>注意：并行垃圾回收在单核CPU下可能会更慢</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210422095236.png"></p><h3 id="查看默认垃圾收集器"><a href="#查看默认垃圾收集器" class="headerlink" title="查看默认垃圾收集器"></a>查看默认垃圾收集器</h3><p>使用下面JVM命令，查看配置的初始参数</p><pre><code class="hljs java">-XX:+PrintCommandLineFlags</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210422100102.png"></p><p>或者：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210422100248.png"></p><p>然后运行一个程序后，能够看到它的一些初始配置信息</p><pre><code class="hljs java">-XX:InitialHeapSize=<span class="hljs-number">266376000</span> -XX:MaxHeapSize=<span class="hljs-number">4262016000</span> -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:-UseLargePagesIndividualAllocation -XX:+UseParallelGC</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210422100110.png"></p><p>移动到最后一句，就能看到 <code>-XX:+UseParallelGC</code> 说明使用的是并行垃圾回收</p><pre><code class="hljs java">-XX:+UseParallelGC</code></pre><h3 id="默认垃圾收集器有哪些"><a href="#默认垃圾收集器有哪些" class="headerlink" title="默认垃圾收集器有哪些"></a>默认垃圾收集器有哪些</h3><p>Java中一共有7大垃圾收集器</p><ul><li>UseSerialGC：串行垃圾收集器</li><li>UseParallelGC：并行垃圾收集器</li><li>UseConcMarkSweepGC：（CMS）并发标记清除</li><li>UseParNewGC：年轻代的并行垃圾回收器</li><li>UseParallelOldGC：老年代的并行垃圾回收器</li><li>UseG1GC：G1垃圾收集器</li><li>UserSerialOldGC：串行老年代垃圾收集器（已经被移除）</li></ul><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210422100753.png"></p><p>如何修改：</p><p>我们先设置参数</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210422101215.png"></p><p>再运行查看：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210422101444.png"></p><h3 id="各垃圾收集器的使用范围"><a href="#各垃圾收集器的使用范围" class="headerlink" title="各垃圾收集器的使用范围"></a>各垃圾收集器的使用范围</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210422101637.png"></p><p> <strong>新生代</strong> 使用的：</p><ul><li>Serial Copying： UserSerialGC，串行垃圾回收器</li><li>Parallel Scavenge：UserParallelGC，并行垃圾收集器</li><li>ParNew：UserParNewGC，新生代并行垃圾收集器</li></ul><p> <strong>老年区</strong> 使用的：</p><ul><li>Serial Old：UseSerialOldGC，老年代串行垃圾收集器</li><li>Parallel Compacting（Parallel Old）：UseParallelOldGC，老年代并行垃圾收集器</li><li> <strong>CMS</strong> ：UseConcMarkSwepp，并行标记清除垃圾收集器</li></ul><p> <strong>各区都能使用</strong> 的：</p><p> <strong>G1</strong> ：UseG1GC，G1垃圾收集器</p><p>垃圾收集器就来具体实现这些GC算法并实现内存回收，不同厂商，不同版本的虚拟机实现差别很大，HotSpot中包含的收集器如下图所示：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210422102139.png"></p><h3 id="部分参数说明"><a href="#部分参数说明" class="headerlink" title="部分参数说明"></a>部分参数说明</h3><ul><li>DefNew：Default New Generation</li><li>Tenured：Old</li><li>ParNew：Parallel New Generation</li><li>PSYoungGen：Parallel Scavenge</li><li>ParOldGen：Parallel Old Generation</li></ul><h3 id="Java中的Server和Client模式"><a href="#Java中的Server和Client模式" class="headerlink" title="Java中的Server和Client模式"></a>Java中的Server和Client模式</h3><p>使用范围：一般使用Server模式，Client模式基本不会使用</p><p>操作系统</p><ul><li>32位的Window操作系统，不论硬件如何都默认使用Client的JVM模式</li><li>32位的其它操作系统，2G内存同时有2个cpu以上用Server模式，低于该配置还是Client模式</li><li>64位只有Server模式</li></ul><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210422102723.png"></p><h3 id="新生代下的垃圾收集器"><a href="#新生代下的垃圾收集器" class="headerlink" title="新生代下的垃圾收集器"></a>新生代下的垃圾收集器</h3><h4 id="串行GC-Serial"><a href="#串行GC-Serial" class="headerlink" title="串行GC(Serial)"></a>串行GC(Serial)</h4><p>串行GC（Serial）（Serial Copying）</p><p>是一个 <strong>单线程的收集器</strong> ，在进行垃圾收集时候，必须暂停其他所有的工作线程直到它收集结束。</p><p>由上面的图会自动激活serial old</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210422103104.png"></p><p>串行收集器是 <strong>最古老，最稳定以及效率高</strong> 的收集器，只使用一个线程去回收但其在垃圾收集过程中可能会产生较长的停顿( <strong>top-The-World 状态</strong> )。 虽然在收集垃圾过程中需要暂停所有其它的工作线程，但是它简单高效，对于限定单个CPU环境来说，没有线程交互的开销可以 <strong>获得最高的单线程垃圾收集效率</strong> ，因此Serial垃圾收集器依然是Java虚拟机运行在 <strong>client模式下默认的新生代垃圾收集器</strong> </p><p>对应JVM参数是：-XX:+UseSerialGC</p><p>开启后会使用： <strong>Serial(Young区用) + Serial Old(Old区用) 的收集器组合</strong> </p><p>表示：新生代、老年代都会使用串行回收收集器，新生代使用复制算法，老年代使用标记-整理算法</p><pre><code class="hljs java">-Xms10m -Xmx10m -XX:+PrintGCDetails -XX:+PrintCommandLineFlags -XX:+UseSerialGC</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210422104815.png"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210422105455.png"></p><h4 id="并行GC-ParNew"><a href="#并行GC-ParNew" class="headerlink" title="并行GC(ParNew)"></a>并行GC(ParNew)</h4><p>并行收集器，使用 <strong>多线程</strong> 进行垃圾回收，在垃圾收集，会 <strong>Stop-the-World暂停</strong> 其他所有的工作线程直到它收集结束</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210422103943.png"></p><p>ParNew收集器其实就是Serial收集器新生代的 <strong>并行多线程版本</strong> ，最常见的应用场景时配合老年代的CMS GC工作，其余的行为和Serial收集器完全一样，ParNew垃圾收集器在垃圾收集过程中同样也要暂停所有其他的工作线程。它是很多Java虚拟机运行在Server模式下新生代的默认垃圾收集器。</p><p>常见对应JVM参数：-XX:+UseParNewGC 启动ParNew收集器， <strong>只影响新生代的收集</strong> ，不影响老年代</p><p>开启上述参数后，会使用： <strong>ParNew（Young区用） + Serial Old</strong> 的收集器组合，新生代使用复制算法，老年代采用标记-整理算法</p><pre><code class="hljs java">-Xms10m -Xmx10m -XX:+PrintGCDetails -XX:+PrintCommandLineFlags -XX:+UseParNewGC</code></pre><p>但是会出现警告，即 ParNew 和 Serial Old 这样搭配，Java8已经 <strong>不再被推荐</strong> </p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210422105142.png"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210422105402.png"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210422105423.png"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210422105559.png"></p><p>备注： -XX:ParallelGCThreads 限制线程数量，默认开启和CPU数目相同的线程数</p><h4 id="并行回收GC（Parallel）-（Parallel-Scavenge）"><a href="#并行回收GC（Parallel）-（Parallel-Scavenge）" class="headerlink" title="并行回收GC（Parallel）/ （Parallel Scavenge）"></a>并行回收GC（Parallel）/ （Parallel Scavenge）</h4><p>因为Serial 和 ParNew都不推荐使用了，因此现在新生代默认使用的是Parallel Scavenge，也就是 <strong>新生代和老年代都是使用并行</strong> </p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210422110254.png"></p><p>Parallel Scavenge收集器类似ParNew也是一个新生代垃圾收集器，使用 <strong>复制算法</strong> ，也是一个并行的多线程的垃圾收集器，俗称吞吐量优先收集器。一句话： <strong>串行收集器在新生代和老年代的并行化</strong> </p><p>它关注的重点是：</p><p> <strong>可控制的吞吐量</strong> （Thoughput = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间) ），也即比如程序运行100分钟，垃圾收集时间1分钟，吞吐量就是99%。高吞吐量意味着高效利用CPU时间，它多用于在后台运算而不需要太多交互的任务。</p><p> <strong>自适应调节策略</strong> 也是ParallelScavenge收集器与ParNew收集器的一个重要区别。（自适应调节策略：虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供 <strong>最合适的停顿时间</strong> ( -XX:MaxGCPauseMills)）或最大的吞吐量。</p><p>常用JVM参数： <strong>-XX:+UseParallelGC 或 -XX:+UseParallelOldGC</strong> （可互相激活）使用Parallel Scanvenge收集器</p><p>开启该参数后：新生代使用复制算法，老年代使用标记-整理算法</p><pre><code class="hljs java">-Xms10m -Xmx10m -XX:+PrintGCDetails -XX:+PrintCommandLineFlags -XX:+UseParallelGC</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210422111001.png"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210422111021.png"></p><h3 id="老年代下的垃圾收集器"><a href="#老年代下的垃圾收集器" class="headerlink" title="老年代下的垃圾收集器"></a>老年代下的垃圾收集器</h3><h4 id="串行GC（Serial-Old）-Serial-MSC"><a href="#串行GC（Serial-Old）-Serial-MSC" class="headerlink" title="串行GC（Serial Old） / (Serial MSC)"></a>串行GC（Serial Old） / (Serial MSC)</h4><p>Serial Old是Serial垃圾收集器 <strong>老年代版本</strong> ，它同样是一个单线程的收集器，使用标记-整理算法，这个收集器也主要是运行在Client默认的Java虚拟机中默认的老年代垃圾收集器</p><p>在Server模式下，主要有两个用途（了解，版本已经到8及以后）</p><ul><li>在JDK1.5之前版本中与新生代的Parallel Scavenge收集器 <strong>搭配</strong> 使用（Parallel Scavenge + Serial Old）</li><li>作为老年代版中使用CMS收集器的 <strong>后备垃圾收集方案</strong> 。</li></ul><p>配置方法：</p><pre><code class="hljs java">-Xms10m -Xmx10m -XX:+PrintGCDetails -XX:+PrintCommandLineFlags -XX:+UseSerialOldlGC</code></pre><p>该垃圾收集器，目前已经 <strong>不推荐使用</strong> 了</p><h4 id="并行GC（Parallel-Old）-（Parallel-MSC）"><a href="#并行GC（Parallel-Old）-（Parallel-MSC）" class="headerlink" title="并行GC（Parallel Old）/ （Parallel MSC）"></a>并行GC（Parallel Old）/ （Parallel MSC）</h4><p>Parallel Old收集器是Parallel Scavenge的老年代版本，使用多线程的标记-整理算法，Parallel Old收集器在JDK1.6才开始提供。</p><p>在JDK1.6之前，新生代使用ParallelScavenge收集器只能搭配老年代的Serial Old收集器，只能保证新生代的吞吐量优先，无法保证整体的吞吐量。在JDK1.6以前(Parallel Scavenge + Serial Old)</p><p>Parallel Old正是 <strong>为了在老年代同样提供吞吐量优先的垃圾收集器</strong> ，如果系统对吞吐量要求比较高，JDK1.8后可以考虑新生代Parallel Scavenge和老年代Parallel Old 收集器的搭配策略。在JDK1.8及后（Parallel Scavenge + Parallel Old）</p><p>JVM常用参数：</p><pre><code class="hljs java">-XX +UseParallelOldGC：使用Parallel Old收集器，设置该参数后，新生代Parallel+老年代 Parallel Old</code></pre><p>或者使用老年代并行收集器：</p><pre><code class="hljs java">-Xms10m -Xmx10m -XX:+PrintGCDetails -XX:+PrintCommandLineFlags -XX:+UseParallelOldlGC</code></pre><h4 id="并发标记清除GC（CMS）"><a href="#并发标记清除GC（CMS）" class="headerlink" title="并发标记清除GC（CMS）"></a>并发标记清除GC（CMS）</h4><p>CMS收集器（Concurrent Mark Sweep： <strong>并发标记清除</strong> (节约内存空间 容易留下内存碎片) ）是一种以 <strong>最短回收停顿时间为目标</strong> 的收集器</p><p>适合应用在互联网或者B/S系统的服务器上，这类应用尤其重视服务器的响应速度，希望系统停顿时间最短。</p><p>CMS非常适合堆内存大，CPU核数多的服务器端应用，也是G1出现之前大型应用的首选收集器。</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210422111728.png"></p><p>四个步骤，1、3停顿，2、4交替执行</p><p>Concurrent Mark Sweep：并发标记清除，并发收集 <strong>低停顿</strong> ，并发指的是与用户线程一起执行</p><p>开启该收集器的JVM参数： -XX:+UseConcMarkSweepGC 开启该参数后，会自动将 -XX:+UseParNewGC打开，开启该参数后，使用ParNew(young 区用）+ CMS（Old 区用） + Serial Old 的收集器组合，Serial Old将作为CMS出错的后备收集器</p><pre><code class="hljs java">-Xms10m -Xmx10m -XX:+PrintGCDetails -XX:+UseConcMarkSweepGC</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210422112140.png"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210422112204.png"></p><h4 id="CMS-四个步骤"><a href="#CMS-四个步骤" class="headerlink" title="CMS 四个步骤"></a>CMS 四个步骤</h4><ul><li>初始标记（CMS initial mark）<ul><li>只是标记一个GC Roots 能直接关联的对象，速度很快，仍然 <strong>需要暂停</strong> 所有的工作线程</li></ul></li><li>并发标记（CMS concurrent mark）和用户线程一起<ul><li>进行GC Roots跟踪过程，和用户线程一起工作， <strong>不需要暂停</strong> 工作线程。主要标记过程，标记全部对象</li></ul></li><li>重新标记（CMS remark）<ul><li>为了修正在并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，仍然需要 <strong>暂停</strong> 所有的工作线程，由于并发标记时，用户线程依然运行，因此在正式清理前，再做修正</li></ul></li><li>并发清除（CMS concurrent sweep）和用户线程一起<ul><li>清除GC Roots不可达对象，和用户线程一起工作， <strong>不需要暂停</strong> 工作线程。基于标记结果，直接清理对象，由于耗时最长的并发标记和并发清除过程中，垃圾收集线程可以和用户现在一起并发工作，所以总体上来看CMS收集器的内存回收和用户线程是一起并发地执行。</li></ul></li></ul><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210422112630.png"></p><p> <strong>优点</strong> ：并发收集低停顿</p><p> <strong>缺点</strong> ：并发执行，对 <em>CPU资源压力大</em>，采用的标记清除算法会  <strong><em>导致大量碎片</em></strong> </p><p>由于并发进行，CMS在收集与应用线程会同时 <strong>增加对堆内存的占用</strong> ，也就是说，CMS <strong>必须在老年代堆内存用尽之前完成垃圾回收</strong> ，否则CMS回收失败时，将 <strong>触发担保机制</strong> ，串行老年代收集器将会以 <strong>STW方式进行一次GC</strong> ，从而造成较大的停顿时间</p><p> <strong><em>标记清除算法无法整理空间碎片</em></strong> ，老年代空间会随着应用时长被逐步耗尽，最后将 <strong><em>不得不通过担保机制对堆内存进行压缩</em></strong> ，CMS也提供了参数 -XX:CMSFullGCSBeForeCompaction（默认0，即每次都进行内存整理）来指定多少次CMS收集之后，进行一次压缩的Full GC</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210422113429.png"></p><h3 id="为什么新生代采用复制算法，老年代采用标整算法"><a href="#为什么新生代采用复制算法，老年代采用标整算法" class="headerlink" title="为什么新生代采用复制算法，老年代采用标整算法"></a>为什么新生代采用复制算法，老年代采用标整算法</h3><h4 id="新生代使用复制算法"><a href="#新生代使用复制算法" class="headerlink" title="新生代使用复制算法"></a>新生代使用复制算法</h4><p>因为新生代对象的生存时间比较短，80%的都要回收的对象，采用标记-清除算法则内存碎片化比较严重，采用复制算法可以灵活高效，且便与整理空间</p><h4 id="老年代采用标记整理"><a href="#老年代采用标记整理" class="headerlink" title="老年代采用标记整理"></a>老年代采用标记整理</h4><p>标记整理算法主要是为了解决标记清除算法存在内存碎片的问题，又解决了复制算法两个Survivor区的问题，因为老年代的空间比较大，不可能采用复制算法，特别占用内存空间</p><h3 id="垃圾收集器如何选择"><a href="#垃圾收集器如何选择" class="headerlink" title="垃圾收集器如何选择"></a>垃圾收集器如何选择</h3><ul><li>单CPU或者小内存，单机程序<ul><li>-XX:+UseSerialGC</li></ul></li><li>多CPU，需要最大的吞吐量，如后台计算型应用(大数据)<ul><li>-XX:+UseParallelGC（这两个相互激活）</li><li>-XX:+UseParallelOldGC</li></ul></li><li>多CPU，追求低停顿时间，需要快速响应如互联网应用<ul><li>-XX:+UseConcMarkSweepGC</li><li>-XX:+ParNewGC</li></ul></li></ul><table><thead><tr><th>参数</th><th>新生代垃圾收集器</th><th>新生代算法</th><th>老年代垃圾收集器</th><th>老年代算法</th></tr></thead><tbody><tr><td>-XX:+UseSerialGC</td><td>SerialGC</td><td>复制</td><td>SerialOldGC</td><td>标记整理</td></tr><tr><td>-XX:+UseParNewGC</td><td>ParNew</td><td>复制</td><td>SerialOldGC</td><td>标记整理</td></tr><tr><td>-XX:+UseParallelGC</td><td>Parallel [Scavenge]</td><td>复制</td><td>Parallel Old</td><td>标记整理</td></tr><tr><td>-XX:+UseConcMarkSweepGC</td><td>ParNew</td><td>复制</td><td>CMS + Serial Old的收集器组合，Serial Old作为CMS出错的后备收集器</td><td>标记清除</td></tr><tr><td>-XX:+UseG1GC</td><td>G1整体上采用标记整理算法</td><td>局部复制</td><td></td><td></td></tr></tbody></table><h3 id="G1垃圾收集器"><a href="#G1垃圾收集器" class="headerlink" title="G1垃圾收集器"></a>G1垃圾收集器</h3><h4 id="开启G1垃圾收集器"><a href="#开启G1垃圾收集器" class="headerlink" title="开启G1垃圾收集器"></a>开启G1垃圾收集器</h4><pre><code class="hljs java">-XX:+UseG1GC</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210423082401.png"></p><p>heap区只有 garbage - first ，然后就是metaspace</p><h4 id="以前收集器的特点"><a href="#以前收集器的特点" class="headerlink" title="以前收集器的特点"></a>以前收集器的特点</h4><ul><li>年轻代和老年代是各自独立且连续的内存块</li><li>年轻代收集使用单eden + S0 + S1 进行复制算法</li><li>老年代收集必须扫描珍整个老年代区域</li><li>都是以尽可能少而快速地执行GC为设计原则</li></ul><h4 id="G1是什么"><a href="#G1是什么" class="headerlink" title="G1是什么"></a>G1是什么</h4><p>G1： <strong>Garbage-First 收集器</strong> ，是一款面向 <strong>服务端应用</strong> 的收集器，应用在多处理器和大容量内存环境中，在实现高吞吐量的同时，尽可能满足垃圾收集暂停时间的要求。另外，它还具有一下特征：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210423082915.png"></p><ul><li>像CMS收集器一样，能与应用程序 <strong>并发</strong> 执行</li><li>整理空闲空间更快</li><li> <strong>需要更多的时间来预测GC停顿时间</strong> </li><li>不希望牺牲大量的 <strong>吞吐量</strong> 性能</li><li>不需要更大的Java  <strong>Heap</strong> </li></ul><p>G1收集器设计目标是取代CMS收集器，它同CMS相比，在以下方面表现的 <strong>更出色</strong> </p><ul><li>G1是一个有整理内存过程的垃圾收集器， <strong>不会产生很多内存碎片</strong> 。</li><li>G1的Stop The World（STW） <strong>更可控</strong> ，G1在停顿时间上添加了 <strong>预测机制</strong> ，用户可以指定期望停顿时间。</li></ul><p> <strong>CMS垃圾收集器</strong> 虽然减少了暂停应用程序的运行时间，但是它还存在着内存碎片问题。于是，为了去除内存碎片问题，同时又保留CMS垃圾收集器低暂停时间的优点，JAVA7发布了一个新的垃圾收集器-G1垃圾收集器</p><p>G1是在2012年才在JDK1.7中可用，Oracle官方计划在JDK9中将G1变成默认的垃圾收集器以替代CMS，它是一款面向服务端应用的收集器，主要应用在多CPU和大内存服务器环境下，极大减少垃圾收集的停顿时间，全面提升服务器的性能，逐步替换Java8以前的CMS收集器</p><p>主要改变是：Eden，Survivor和Tenured等内存区域不再是连续了，而是变成一个个大小一样的 <strong>region</strong> ，每个region从1M到32M不等。一个region有可能属于Eden，Survivor或者Tenured内存区域。</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>G1能充分利用多CPU，多核环境硬件优势，尽量 <strong>缩短STW</strong> </li><li>G1整体上采用标记-整理算法，局部是通过复制算法， <strong>不会产生内存碎片</strong> </li><li> <strong>宏观上</strong> 看G1之中 <strong>不再区分年轻代和老年代</strong> 。把内存划分成多个独立的子区域（Region），可以近似理解为一个围棋的棋盘</li><li>G1收集器里面将整个内存区域都混合在一起了，但其本身依然在 <strong>小范围内要进行年轻代和老年代的区分</strong> ，保留了新生代和老年代，但他们不再是物理隔离的，而是通过一部分Region的集合且不需要Region是连续的，也就是说依然会采取不同的GC方式来处理不同的区域</li><li>G1虽然也是分代收集器，但整个内存分区不存在物理上的年轻代和老年代的区别，也不需要完全独立的Survivor（to space）堆做复制准备，G1只有逻辑上的分代概念，或者说 <strong>每个分区都可能随G1的运行在不同代之间前后切换</strong> 。</li></ul><h4 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h4><p>Region区域化垃圾收集器，化整为零， <strong>打破了原来新生区和老年区的壁垒</strong> ，避免了全内存扫描，只需要按照区域来进行扫描即可。</p><p>区域化内存划片Region，整体遍为了一些列不连续的内存区域，避免了全内存区的GC操作。</p><p>核心思想是将整个堆内存区域分成大小相同的子区域（Region），在JVM启动时会自动设置子区域大小</p><p>在堆的使用上，G1并不要求对象的存储一定是物理上连续的，只要 <strong>逻辑上连续</strong> 即可，每个分区也不会固定地为某个代服务，可以按需在年轻代和老年代之间切换。启动时可以通过参数<code>-XX:G1HeapRegionSize=n</code> 可指定分区大小（1MB~32MB，且必须是2的幂），默认将整堆划分为2048个分区。</p><p>大小范围在1MB~32MB，最多能设置2048个区域，也即能够支持的最大内存为：32MB*2048 = 64G内存</p><h4 id="Region区域化垃圾收集器"><a href="#Region区域化垃圾收集器" class="headerlink" title="Region区域化垃圾收集器"></a>Region区域化垃圾收集器</h4><p>G1将新生代、老年代的物理空间划分取消了</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210423084628.png"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210423084658.png"></p><p>G1算法将堆划分为若干个区域（Reign），它仍然属于分代收集器。</p><p>这些Region的一部分包含 <strong>新生代</strong> ，新生代的垃圾收集依然采用暂停所有应用线程的方式，将存活对象拷贝到老年代或者Survivor空间</p><p>这些Region的一部分包含 <strong>老年代</strong> ，G1收集器通过将对象从一个区域复制到另外一个区域，完成了清理工作。这就意味着，在正常的处理过程中，G1完成了堆的压缩（至少是部分堆的压缩），这样也就不会有CMS内存碎片的问题存在了。</p><p>在G1中，还有一种特殊的区域，叫做 <strong>Humongous（巨大的）区域</strong> ，如果一个对象占用了空间超过了分区容量50%以上，G1收集器就认为这是一个 <strong>巨型对象</strong> ，这些巨型对象默认直接分配在老年代，但是如果他是一个短期存在的巨型对象，就会对垃圾收集器造成负面影响，为了解决这个问题，G1划分了一个 <strong>Humongous区</strong> ，它用来专门存放巨型对象。如果一个H区装不下一个巨型对象，那么G1会寻找连续的H区来存储，为了能找到连续的H区，有时候不得不启动Full GC。</p><h4 id="回收步骤"><a href="#回收步骤" class="headerlink" title="回收步骤"></a>回收步骤</h4><p>针对Eden区进行收集，Eden区耗尽后会被触发，主要是小区域收集 + 形成连续的内存块，避免内碎片</p><ul><li>Eden区的数据移动到Survivor区，加入出现Survivor区空间不够，Eden区数据会晋升到Old区</li><li>Survivor区的数据移动到新的Survivor区，部分数据晋升到Old区</li><li>最后Eden区收拾干净了，GC结束，用户的应用程序继续执行</li></ul><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210423085314.png"></p><p>回收完成后</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210423085339.png"></p><p>小区域收集 + 形成连续的内存块，最后在收集完成后，就会形成连续的内存空间，这样就解决了内存碎片的问题</p><h4 id="四步过程"><a href="#四步过程" class="headerlink" title="四步过程"></a>四步过程</h4><ul><li>初始标记：只标记GC Roots能直接关联到的对象</li><li>并发标记：进行GC Roots Tracing（链路扫描）的过程</li><li>最终标记：修正并发标记期间，因为程序运行导致标记发生变化的那一部分对象</li><li>筛选回收：根据时间来进行价值最大化回收</li></ul><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210423085542.png"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210423085637.png"></p><h4 id="参数配置"><a href="#参数配置" class="headerlink" title="参数配置"></a>参数配置</h4><p>开发人员仅仅需要申明以下参数即可</p><p>三步归纳：<code>-XX:+UseG1GC -Xmx32G -XX:MaxGCPauseMillis=100</code></p><p> <strong>开始G1+设置最大内存+设置最大停顿时间</strong> </p><p>-XX:MaxGCPauseMillis=n： <strong>最大GC停顿时间</strong> 单位 <strong>毫秒</strong> ，这是个软目标，JVM尽可能停顿小于这个时间</p><ul><li>-XX:+UseG1GC</li><li>-XX:G1HeapRegionSize=n：设置的G1区域的大小。值是2的幂，范围是1MB到32MB。目标是根据最小的Java堆大小划分出约2048个区域。</li><li>-XX:MaxGCPauseMillis=n：最大GC停顿时间，这是个软目标，JVM将尽可能（但不保证）停顿小于这个时间。</li><li>-XX:InitiatingHeapOccupancyPercent=n：堆占用了多少的时候就触发GC，默认为45。</li><li>-XX:ConcGCThreads=n：并发GC使用的线程数。</li><li>-XX:G1ReservePercent=n：设置作为空闲空间的预留内存百分比，以降低目标空间溢出的风险，默认值是10%。</li></ul><h4 id="G1和CMS比较"><a href="#G1和CMS比较" class="headerlink" title="G1和CMS比较"></a>G1和CMS比较</h4><ul><li>G1不会产生内碎片</li><li>是可以精准控制停顿。该收集器是把整个堆（新生代、老年代）划分成多个固定大小的区域，每次根据允许停顿的时间去收集垃圾最多的区域。</li></ul><h4 id="SpringBoot结合JVMGC"><a href="#SpringBoot结合JVMGC" class="headerlink" title="SpringBoot结合JVMGC"></a>SpringBoot结合JVMGC</h4><p>启动微服务时候，就可以带上JVM和GC的参数</p><ul><li>IDEA开发完微服务工程</li><li>maven进行clean package</li><li>要求微服务启动的时候，同时配置我们的JVM/GC的调优参数<ul><li>我们就可以根据具体的业务配置我们启动的JVM参数</li></ul></li><li>公式：<code>java -server jvm的各种参数 -jar 第1步上面的jar/war包名</code>。</li></ul><p>例如：</p><pre><code class="hljs java">java -Xms1024m -Xmx1024 -XX:UseG1GC -jar   xxx.jar</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210423090654.png"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210423090628.png"></p><h1 id="Linux相关命令"><a href="#Linux相关命令" class="headerlink" title="Linux相关命令"></a>Linux相关命令</h1><h2 id="Linux诊断原因"><a href="#Linux诊断原因" class="headerlink" title="Linux诊断原因"></a>Linux诊断原因</h2><h3 id="命令集合"><a href="#命令集合" class="headerlink" title="命令集合"></a>命令集合</h3><h4 id="整机：top，查看整机系统新能"><a href="#整机：top，查看整机系统新能" class="headerlink" title="整机：top，查看整机系统新能"></a>整机：top，查看整机系统新能</h4><blockquote><p>load average表示系统负载，即任务队列的平均长度。 三个数值分别为 1分钟、5分钟、15分钟前到现在的平均值。</p><p>load average: 如果这个数除以逻辑CPU的数量，结果高于5的时候就表明系统在超负荷运转了。</p><p><a href="https://yjclsx.blog.csdn.net/article/details/81508455">Linux中top命令参数详解</a></p></blockquote><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210423095131.png"></p><p>q退出，uptime精简版</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210423095451.png"></p><p>使用top命令的话，重点关注的是  <strong>%CPU、%MEM 、load average</strong>  三个指标</p><ul><li>load average三个指标：分别代表1、5、15分钟的负载情况</li></ul><p>在这个命令下，按1的话，可以看到每个CPU的占用情况</p><p>uptime：系统性能命令的精简版</p><h4 id="CPU：vmstat"><a href="#CPU：vmstat" class="headerlink" title="CPU：vmstat"></a>CPU：vmstat</h4><ul><li><p>查看CPU（包含但是不限于）</p></li><li><p>查看额外</p><ul><li><p>查看所有CPU核信息：mpstat -P ALL 2</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210423101245.png"></p></li><li><p>每个进程使用CPU的用量分解信息：pidstat -u 1 -p 进程编号</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210423101443.png"></p></li></ul></li></ul><p>命令格式：<code>vmstat -n 2 3</code> 每 <strong>两秒</strong> 采样一次，共计 <strong>采样三次</strong> </p><p>一般vmstat工具的使用是通过两个数字参数来完成的，第一个参数是残阳的时间间隔数（单位秒），第二个参数是采样的次数</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210423095949.png"></p><p><strong>procs</strong></p><p> r：运行和等待的CPU时间片的进程数，原则上1核的CPU的运行队列不要超过2，整个系统的运行队列不超过总核数的2倍，否则代表系统压力过大</p><p> b：等待资源的进程数，比如正在等待磁盘I/O、网络I/O等</p><p><strong>cpu</strong></p><p> us：用户进程消耗CPU时间百分比，us值高，用户进程消耗CPU时间多，如果长期大于50%，优化程序</p><p> sy：内核进程消耗的CPU时间百分比</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210423100524.png"></p><p> us + sy 参考值为80%，如果us + sy 大于80%，说明可能存在CPU不足，从上面的图片可以看出，us + sy还没有超过百分80，因此说明CPU消耗不是很高</p><p> id：处于空闲的CPU百分比</p><p> wa：系统等待IO的CPU时间百分比</p><p> st：来自于一个虚拟机偷取的CPU时间比</p><h4 id="内存：free"><a href="#内存：free" class="headerlink" title="内存：free"></a>内存：free</h4><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210423101611.png"></p><ul><li>应用程序可用内存数：free -m</li><li>应用程序可用内存/系统物理内存 &gt; 70% 内存充足</li><li>应用程序可用内存/系统物理内存 &lt; 20% 内存不足，需要增加内存</li><li>20% &lt; 应用程序可用内存/系统物理内存 &lt; 70%，表示内存基本够用</li></ul><p>free -h：以人类能看懂的方式查看物理内存</p><p>free -m：以MB为单位，查看物理内存</p><p>free -g：以GB为单位，查看物理内存(会取整)</p><p>查看额外</p><pre><code class="hljs java">pidstat -p 进程号 -r 采样间隔秒数</code></pre><h4 id="硬盘：df"><a href="#硬盘：df" class="headerlink" title="硬盘：df"></a>硬盘：df</h4><p>格式：<code>df -h /</code> (-h：human，表示以人类能看到的方式换算)</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210423102033.png"></p><h4 id="磁盘IO：iostat"><a href="#磁盘IO：iostat" class="headerlink" title="磁盘IO：iostat"></a>磁盘IO：iostat</h4><p>系统慢有两种原因引起的，一个是CPU高，一个是大量IO操作</p><p>格式：<code>iostat -xdk 2 3</code></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210423102221.png"></p><p>磁盘块设备分布</p><p>rkB /s：每秒读取数据量kB；</p><p>wkB/s：每秒写入数据量kB；</p><p>svctm I/O：请求的平均服务时间，单位毫秒</p><p>await I/O：请求的平均等待时间，单位毫秒，值越小，性能越好</p><p> <strong>util：一秒钟有百分几的时间用于I/O操作。接近100%时，表示磁盘带宽跑满，需要优化程序或者增加磁盘</strong> ；</p><p>rkB/s，wkB/s根据系统应用不同会有不同的值，但有规律遵循：长期、超大数据读写，肯定不正常，需要优化程序读取。</p><p>svctm的值与await的值很接近，表示几乎没有I/O等待，磁盘性能好，如果await的值远高于svctm的值，则表示I/O队列等待太长，需要优化程序或更换更快磁盘</p><h4 id="网络IO：ifstat"><a href="#网络IO：ifstat" class="headerlink" title="网络IO：ifstat"></a>网络IO：ifstat</h4><ul><li>默认本地没有，下载ifstat</li></ul><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210423102358.png"></p><h2 id="CPU占用过高的定位分析思路"><a href="#CPU占用过高的定位分析思路" class="headerlink" title="CPU占用过高的定位分析思路"></a>CPU占用过高的定位分析思路</h2><p>记一次印象深刻的故障？</p><p>结合Linux 和 JDK命令一起分析，步骤如下</p><ul><li><p>使用top命令找出CPU占比最高的</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210423103045.png"></p><p>我们先写一个死循环</p><p>然后用top查看</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210423103137.png"></p></li><li><p>ps -ef 或者 jps 进一步定位，得知是一个怎么样的后台程序出的问题</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210423103251.png"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210423103310.png"></p><p>30296 TestCpu</p></li><li><p>定位到具体线程或者代码</p><ul><li><p>ps -mp 进程 -o THREAD，tid，time</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210423103453.png"></p><p>root     98.7  19    - -         -      - 30307 00:04:51</p><p>30307是线程id</p></li><li><p>参数解释</p><ul><li>-m：显示所有的线程</li><li>-p：pid进程使用CPU的时间</li><li>-o：该参数后是用户自定义格式</li></ul></li></ul></li><li><p>将需要的线程ID转换为16进制格式（英文小写格式）</p><ul><li><p>printf “%x\n” 有问题的线程ID</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210423103714.png"></p></li></ul></li><li><p>jstack 进程ID | grep tid（16进制线程ID小写英文） -A60</p><p>精准定位到错误的地方</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210423104317.png"></p></li></ul><h2 id="JDK-自带工具排查"><a href="#JDK-自带工具排查" class="headerlink" title="JDK 自带工具排查"></a>JDK 自带工具排查</h2><p><a href="https://blog.csdn.net/u011863024/article/details/106651068">jdk</a></p><h1 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h1><h2 id="常用词含义"><a href="#常用词含义" class="headerlink" title="常用词含义"></a>常用词含义</h2><ul><li>watch：会持续收到该项目的 <strong>动态</strong> </li><li>fork： <strong>复制</strong> 某个仓库到自己的Github仓库中</li><li>star：可以理解为点赞</li><li>clone：将项目下载至本地</li><li>follow：关注你感兴趣的作者，会收到他们的动态</li></ul><h2 id="in关键字限制搜索范围"><a href="#in关键字限制搜索范围" class="headerlink" title="in关键字限制搜索范围"></a>in关键字限制搜索范围</h2><ul><li>公式：<code>XXX关键字 in:name 或 description 或 readme</code></li><li>xxx in:name 项目名称含有XXX的</li><li>xxx in:description 项目描述含有XXX的</li><li>xxx in:readme 项目的readme文件中包含XXX的</li><li>组合使用<ul><li>xxx in:name,readme 项目的名称和readme中包含xxx的</li></ul></li></ul><h2 id="stars或fork数量关键字查找"><a href="#stars或fork数量关键字查找" class="headerlink" title="stars或fork数量关键字查找"></a>stars或fork数量关键字查找</h2><ul><li>公式：<ul><li><code>xxx关键字 stars 通配符</code> :&gt; 或者 :&gt;=</li><li>区间范围数字： <code>stars:数字1..数字2</code></li></ul></li><li>案例<ul><li>查找stars数大于等于5000的Springboot项目：springboot stars:&gt;=5000</li><li>查找forks数在1000~2000之间的springboot项目：springboot forks:1000..5000</li></ul></li><li>组合使用<ul><li>查找star大于1000，fork数在500到1000：<code>springboot stars:&gt;1000 forks:500..1000</code></li></ul></li></ul><h2 id="awesome加强搜索"><a href="#awesome加强搜索" class="headerlink" title="awesome加强搜索"></a>awesome加强搜索</h2><ul><li>公式：<code>awesome 关键字</code>：awesome系列，一般用来收集学习、工具、书籍类相关的项目</li><li>搜索优秀的redis相关的项目，包括框架，教程等 awesome redis</li></ul><h2 id="高亮显示某行代码"><a href="#高亮显示某行代码" class="headerlink" title="高亮显示某行代码"></a>高亮显示某行代码</h2><ul><li>一行：地址后面紧跟 #L10<ul><li><code>https://github.com/moxi624/mogu_blog_v2/blob/master/mogu_admin/pom.xml#L13</code></li></ul></li><li>多行：地址后面紧跟 #Lx - #Ln<ul><li><code>https://github.com/moxi624/mogu_blog_v2/blob/master/mogu_admin/pom.xml#L13-L30</code></li></ul></li></ul><h2 id="项目内搜索"><a href="#项目内搜索" class="headerlink" title="项目内搜索"></a>项目内搜索</h2><ul><li>使用英文字母 <code>t</code> ,开启项目内搜索</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法进阶</title>
    <link href="/2021/01/11/%E2%80%9C%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6%E2%80%9D%E7%9A%84%E5%89%AF%E6%9C%AC%202/"/>
    <url>/2021/01/11/%E2%80%9C%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6%E2%80%9D%E7%9A%84%E5%89%AF%E6%9C%AC%202/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="单调栈和滑动窗口"><a href="#单调栈和滑动窗口" class="headerlink" title="单调栈和滑动窗口"></a>单调栈和滑动窗口</h1><h2 id="滑动窗口是什么？"><a href="#滑动窗口是什么？" class="headerlink" title="滑动窗口是什么？"></a>滑动窗口是什么？</h2><p>滑动窗口是一种想象出来的 <strong>数据结构</strong> ：</p><p>滑动窗口有 <strong>左边界L和右边界R</strong> </p><p>在数组或者字符串或者一个序列上，记为S，窗口就是S[L..R]这一部分</p><p>L往右滑意味着一个样本出了窗口，R往右滑意味着一个样本进了窗口</p><p>L和R都只能往右滑</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210119143320.png" alt="滑动窗口"></p><p>注意：任何时候 L &lt;= R，且必须往右动不回退</p><h2 id="滑动窗口能做什么？"><a href="#滑动窗口能做什么？" class="headerlink" title="滑动窗口能做什么？"></a>滑动窗口能做什么？</h2><p>滑动窗口、首尾指针等技巧，说白了是一种求解问题的流程设计。</p><h2 id="滑动内最大值和最小值的更新结构"><a href="#滑动内最大值和最小值的更新结构" class="headerlink" title="滑动内最大值和最小值的更新结构"></a>滑动内最大值和最小值的更新结构</h2><p>窗口不管L还是R滑动之后，都会让窗口呈现新状况，</p><p>如何能够更快的得到窗口当前状况下的最大值和最小值？</p><p>最好平均下来复杂度能做到O(1)</p><p>利用 <strong>单调双端队列！</strong> </p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210119144456.png" alt="双端队列"></p><p>1⃣️ R右移加数：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210119144535.png" alt="Max"></p><p>双端队列 <strong>从大到小</strong> ，如果新的数能落就落，落不下就弹出直至能落下（相等也要弹出）</p><p>2⃣️ L右移减数：</p><p>如果当时情况为：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210119144839.png" alt="当时情况"></p><p>L右移时：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210119145056.png" alt="移动"></p><p>L右移，发现0位置不在，从双端队列 <strong>队首</strong> 开时寻找，没有0，不动；</p><p>L如果再次右移，发现1位置不在，从双端队列 <strong>队首</strong> 开时寻找，1为过期下标，1位置5从头部弹出；</p><p> <strong>双端队列头部</strong> 的数就是此时 <strong>窗口状况</strong> 的 <strong>最大值</strong> </p><p>双端队列的含义：</p><p>已经形成的窗口状况，不让R右移，只让L右移，哪些数会依次成为 <strong>最大值的优先级</strong>；</p><p>复杂度分析：</p><p>一个数最多：入一次，出一次。遍历一次O(N)， <strong>平均</strong> 下来单次代价O(1)</p><h2 id="题一-滑动窗口最大值"><a href="#题一-滑动窗口最大值" class="headerlink" title="题一 滑动窗口最大值"></a>题一 滑动窗口最大值</h2><p>假设一个固定大小为W的窗口，依次划过arr，<br>返回每一次滑出状况的最大值<br>例如，arr = [4,3,5,4,3,3,6,7], W = 3<br>返回：[5,5,5,4,6,7]</p><p class="note note-primary">对应lc239和剑指 59-1</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] getMaxWindow(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> w) &#123;   <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || w &lt; <span class="hljs-number">1</span> || arr.length &lt; w) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;   &#125;   <span class="hljs-comment">// LinkedList双端队列</span>   <span class="hljs-comment">// 其中放的是位置，arr[位置]</span>   LinkedList&lt;Integer&gt; qmax = <span class="hljs-keyword">new</span> LinkedList&lt;Integer&gt;();   <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[arr.length - w + <span class="hljs-number">1</span>];   <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;   <span class="hljs-comment">// [L...R] i 表示 R 进窗口；</span>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123; <span class="hljs-comment">// 当前让 i -&gt; [i] 进窗口 ， i 就是 r</span>      <span class="hljs-comment">// R位置值放到双端队列比他大的数字后面，或者空后</span>      <span class="hljs-keyword">while</span> (!qmax.isEmpty() &amp;&amp; arr[qmax.peekLast()] &lt;= arr[i]) &#123;         qmax.pollLast();      &#125;      qmax.addLast(i);      <span class="hljs-comment">// 数进来了</span>      <span class="hljs-comment">// 如果窗口没有形成w的长度 不会弹出数字</span>      <span class="hljs-comment">// 形成了w的长度 弹出也是弹i - w的位置的数</span>      <span class="hljs-keyword">if</span> (qmax.peekFirst() == i - w) &#123;         qmax.pollFirst();      &#125;      <span class="hljs-comment">// 窗口每一次形成w的长度，收集一次答案</span>      <span class="hljs-keyword">if</span> (i &gt;= w - <span class="hljs-number">1</span>) &#123;         res[index++] = arr[qmax.peekFirst()];      &#125;   &#125;   <span class="hljs-keyword">return</span> res;&#125;</code></pre><h2 id="题二-达标子数组"><a href="#题二-达标子数组" class="headerlink" title="题二 达标子数组"></a>题二 达标子数组</h2><p>给定一个整型数组arr，和一个整数num<br>某个arr中的子数组sub，如果想达标，必须满足：<br>sub中最大值 – sub中最小值 &lt;= num，<br>返回arr中达标子数组的数量</p><p class="note note-primary">对应lc1438</p><p>如果 <strong>子数组arr[L…R]达标</strong> ，内部任何 <strong>子数组</strong> 都达标</p><p>如果 <strong>子数组arr[L…R]不达标</strong> ，L往左或者R往右扩出来的范围也不会达标， 最大值只可能更大，最小值只可能最小</p><p>每一次成长到不达标位置，L右移再求到不达标位置</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210119155530.png" alt="流程"></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getNum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> num)</span> </span>&#123;   <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length == <span class="hljs-number">0</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;   &#125;   LinkedList&lt;Integer&gt; qmin = <span class="hljs-keyword">new</span> LinkedList&lt;Integer&gt;();   LinkedList&lt;Integer&gt; qmax = <span class="hljs-keyword">new</span> LinkedList&lt;Integer&gt;();   <span class="hljs-keyword">int</span> L = <span class="hljs-number">0</span>;   <span class="hljs-keyword">int</span> R = <span class="hljs-number">0</span>;   <span class="hljs-comment">// [L...R) -&gt; [0, 0)一个数没有 [0, 1) -&gt; [0, 0] R表示不达标的第一个位置</span>   <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;   <span class="hljs-keyword">while</span> (L &lt; arr.length) &#123; <span class="hljs-comment">// L是开头位置，尝试每一个开头</span>      <span class="hljs-comment">// 如果此时窗口的开头是L,下面的while工作:R向右扩到违规为止</span>      <span class="hljs-keyword">while</span> (R &lt; arr.length) &#123; <span class="hljs-comment">// R是最后一个达标位置的再下一个</span>         <span class="hljs-keyword">while</span> (!qmin.isEmpty() &amp;&amp; arr[qmin.peekLast()] &gt;= arr[R]) &#123;            qmin.pollLast();         &#125;         qmin.addLast(R);         <span class="hljs-comment">// R -&gt; arr[R],</span>         <span class="hljs-keyword">while</span> (!qmax.isEmpty() &amp;&amp; arr[qmax.peekLast()] &lt;= arr[R]) &#123;            qmax.pollLast();         &#125;         qmax.addLast(R);         <span class="hljs-keyword">if</span> (arr[qmax.getFirst()] - arr[qmin.getFirst()] &gt; num) &#123;            <span class="hljs-keyword">break</span>;         &#125;         R++;      &#125;      <span class="hljs-comment">// R是最后一个达标位置的再下一个，第一个违规的位置</span>      res += R - L;      <span class="hljs-keyword">if</span> (qmin.peekFirst() == L) &#123;         qmin.pollFirst();      &#125;      <span class="hljs-keyword">if</span> (qmax.peekFirst() == L) &#123;         qmax.pollFirst();      &#125;      L++;   &#125;   <span class="hljs-keyword">return</span> res;&#125;</code></pre><p>方法论：</p><p>优化题的方向：</p><ol><li><p>数据状况方向，上题本身就是一个窗口，达标内部就达标，不达标再扩充也不达标，建立了单调性</p></li><li><p>问题本身求的是什么 方向</p></li></ol><h2 id="单调栈是什么？"><a href="#单调栈是什么？" class="headerlink" title="单调栈是什么？"></a>单调栈是什么？</h2><p>一种特别设计的栈结构，为了解决如下的问题：</p><p>给定一个可能含有重复值的数组arr，i位置的数一定存在如下两个信息<br>1）arr[i]的左侧离i最近并且小于(或者大于)arr[i]的数在哪？<br>2）arr[i]的右侧离i最近并且小于(或者大于)arr[i]的数在哪？<br>如果想得到arr中所有位置的 <strong>两个信息</strong> ，怎么能让得到信息的过程尽量快。</p><p>那么到底怎么设计呢？</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210119162030.png" alt="单调栈"></p><p>求每一个数左边和右边比它本身小的表，O(n)</p><blockquote><p>先假设数组中 <strong>没有重复值</strong> </p></blockquote><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210119162432.png" alt="结构"></p><p>轮到 2位置的2想进去时，从栈中开始 <strong>弹出</strong> 生成 <strong>记录</strong> ；</p><p>1位置的4弹出，谁让它弹出，谁就是右边比他小的最近的（2位置的2）；</p><p>1位置的4栈下面压的数（0位置的3）就是左边比他小的最近的；</p><p>接着0位置3弹出生成 <strong>记录</strong> ，</p><p>2位置的2是右边比他小的，下面没有压数据，左边无；</p><p>栈空了，2压入；</p><p>遍历完后，单独处理栈还剩下的东西；</p><p>6位置1被迫弹出，右边无数据，左边为5位置的0；</p><p>5位置的0也被迫弹出，右边无数据，没压数，左边也无；</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[][] getNearLessNoRepeat(<span class="hljs-keyword">int</span>[] arr) &#123;   <span class="hljs-keyword">int</span>[][] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[arr.length][<span class="hljs-number">2</span>];   Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;      <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; arr[stack.peek()] &gt; arr[i]) &#123;         <span class="hljs-keyword">int</span> popIndex = stack.pop();         <span class="hljs-keyword">int</span> leftLessIndex = stack.isEmpty() ? -<span class="hljs-number">1</span> : stack.peek();         res[popIndex][<span class="hljs-number">0</span>] = leftLessIndex;         res[popIndex][<span class="hljs-number">1</span>] = i;      &#125;      stack.push(i);   &#125;   <span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;      <span class="hljs-keyword">int</span> popIndex = stack.pop();      <span class="hljs-keyword">int</span> leftLessIndex = stack.isEmpty() ? -<span class="hljs-number">1</span> : stack.peek();      res[popIndex][<span class="hljs-number">0</span>] = leftLessIndex;      res[popIndex][<span class="hljs-number">1</span>] = -<span class="hljs-number">1</span>;   &#125;   <span class="hljs-keyword">return</span> res;&#125;</code></pre><blockquote><p>假设数组中 有重复值情况</p></blockquote><p class="note note-danger">下面流程有误，第一个3、2搞错了</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210119164743.png" alt="情况"></p><p>生成 <strong>list</strong> ，轮到2位置的3：</p><p>1位置的2 右边最近比他小的就是迫使它弹出的2位置的3；</p><p>1位置的2 左边最新比他小的就是下面list的末尾位置的值（0位置的3）；</p><p>相等把2位置的下标扔进list里面：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210119164943.png" alt="压缩"></p><p>直到：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210119165006.png" alt="情况"></p><p>3位置的4右边就是迫使他弹出的数，即为5位置的3；</p><p>3位置的4左边就是压着的list的末尾，即为2位置的3；</p><p>4位置的4右边还是5位置的3；</p><p>4位置的3右边还是压着的list的末尾；</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210119165159.png" alt="遍历结束"></p><p>6位置的1压入，0，2，5位置的3记录，6右边无左边也无，结束；</p><p>相邻原因：</p><p>1）本身在一起 3445</p><p>2）中间的数都比其大 344553</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[][] getNearLess(<span class="hljs-keyword">int</span>[] arr) &#123;   <span class="hljs-keyword">int</span>[][] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[arr.length][<span class="hljs-number">2</span>];   <span class="hljs-comment">// List&lt;Integer&gt; -&gt; 放的是位置，同样值的东西，位置压在一起</span>   Stack&lt;List&lt;Integer&gt;&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123; <span class="hljs-comment">// i -&gt; arr[i] 进栈</span>      <span class="hljs-comment">// 底 -&gt; 顶， 小 -&gt; 大</span>      <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; arr[stack.peek().get(<span class="hljs-number">0</span>)] &gt; arr[i]) &#123;         List&lt;Integer&gt; popIs = stack.pop();         <span class="hljs-comment">// 取位于下面位置的列表中，最晚加入的那个</span>         <span class="hljs-keyword">int</span> leftLessIndex = stack.isEmpty() ? -<span class="hljs-number">1</span> : stack.peek().get(stack.peek().size() - <span class="hljs-number">1</span>);         <span class="hljs-keyword">for</span> (Integer popi : popIs) &#123;            res[popi][<span class="hljs-number">0</span>] = leftLessIndex;            res[popi][<span class="hljs-number">1</span>] = i;         &#125;      &#125;      <span class="hljs-comment">// 相等的、比你小的</span>      <span class="hljs-keyword">if</span> (!stack.isEmpty() &amp;&amp; arr[stack.peek().get(<span class="hljs-number">0</span>)] == arr[i]) &#123;         stack.peek().add(Integer.valueOf(i));      &#125; <span class="hljs-keyword">else</span> &#123;         ArrayList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();         list.add(i);         stack.push(list);      &#125;   &#125;   <span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;      List&lt;Integer&gt; popIs = stack.pop();      <span class="hljs-comment">// 取位于下面位置的列表中，最晚加入的那个</span>      <span class="hljs-keyword">int</span> leftLessIndex = stack.isEmpty() ? -<span class="hljs-number">1</span> : stack.peek().get(stack.peek().size() - <span class="hljs-number">1</span>);      <span class="hljs-keyword">for</span> (Integer popi : popIs) &#123;         res[popi][<span class="hljs-number">0</span>] = leftLessIndex;         res[popi][<span class="hljs-number">1</span>] = -<span class="hljs-number">1</span>;      &#125;   &#125;   <span class="hljs-keyword">return</span> res;&#125;</code></pre><h2 id="题目三"><a href="#题目三" class="headerlink" title="题目三"></a>题目三</h2><p>给定一个只包含正数的数组arr，arr中任何一个子数组sub，<br>一定都可以算出(sub累加和 )* (sub中的最小值)是什么，<br>那么所有子数组中，这个值最大是多少？</p><p>sub累加和可以用 <strong>前缀和数组</strong> 储存；sum[i]</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210119172219.png" alt="前缀和数组"></p><p>arr[L … R] = arr[0, R] - arr[0, L-1];</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210119172558.png" alt="sub最小值"></p><p>找到以3作最小值的最大子数组；</p><p>再找以4作最小值的最大子数组；</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210119172705.png" alt="重复"></p><p>就是用单调栈：</p><p>求当前数左右比其小的数的位置就是范围：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">max2</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;   <span class="hljs-keyword">int</span> size = arr.length;   <span class="hljs-keyword">int</span>[] sums = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[size];   sums[<span class="hljs-number">0</span>] = arr[<span class="hljs-number">0</span>];   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; size; i++) &#123;      sums[i] = sums[i - <span class="hljs-number">1</span>] + arr[i];   &#125;   <span class="hljs-keyword">int</span> max = Integer.MIN_VALUE;   Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;Integer&gt;();   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;      <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; arr[stack.peek()] &gt;= arr[i]) &#123;         <span class="hljs-keyword">int</span> j = stack.pop();         max = Math.max(max, (stack.isEmpty() ? sums[i - <span class="hljs-number">1</span>] : (sums[i - <span class="hljs-number">1</span>] - sums[stack.peek()])) * arr[j]);      &#125;      stack.push(i);   &#125;   <span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;      <span class="hljs-keyword">int</span> j = stack.pop();      max = Math.max(max, (stack.isEmpty() ? sums[size - <span class="hljs-number">1</span>] : (sums[size - <span class="hljs-number">1</span>] - sums[stack.peek()])) * arr[j]);   &#125;   <span class="hljs-keyword">return</span> max;&#125;</code></pre><h2 id="为什么要求题三？"><a href="#为什么要求题三？" class="headerlink" title="为什么要求题三？"></a>为什么要求题三？</h2><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210119173110.png" alt="求面积"></p><p class="note note-primary">对应lc85</p><h2 id="动态规划-马跳象棋"><a href="#动态规划-马跳象棋" class="headerlink" title="动态规划 马跳象棋"></a>动态规划 马跳象棋</h2><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210119181235.png" alt="暴力"></p><blockquote><p>9、10为棋盘的宽高</p></blockquote><p>改dp：</p><p>k == 0时，x = 0，y = 0才为 1，其他都为0</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210119181921.png" alt="0,0,0"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210119182602.png" alt="dp"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210119182639.png" alt="dp"></p><h1 id="类似斐波那契数列"><a href="#类似斐波那契数列" class="headerlink" title="类似斐波那契数列"></a>类似斐波那契数列</h1><h2 id="优化原理"><a href="#优化原理" class="headerlink" title="优化原理"></a>优化原理</h2><ul><li><p>可以优化为 O(Log(N))的解法：快速幂</p><ul><li><p>斐波那契数列的线性求解（O(N)）的方式非常好理解</p></li><li><p>同时利用线性代数，也可以改写出另一种表示</p><p> | F(N) , F(N-1) | = | F(2), F(1) |  *  某个二阶矩阵的N-2次方</p><p>求出这个二阶矩阵，进而最快求出这个二阶矩阵的N-2次方</p></li></ul></li></ul><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210316145619.png" alt="行列式"></p><p>第三项和第二项组成的行列式 等于 第二项和第一项的行列式乘以一个abcd的矩阵</p><p>第四项和第三项组成的行列式 等于 第三项和第二项的行列式乘以一个同样是abcd的矩阵</p><p>后面跟着的二阶矩阵是 <strong>同一个</strong> </p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210318095005.png" alt="关系"></p><p>再根据下一组数据得到a=b=c=1,d=0</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210318095506.png" alt="最终结论"></p><p>F2和F1分别为1，1；所以后面的矩阵算得快慢等于算法算得快慢</p><blockquote><p>先解决一个数字的次方怎么算得快？</p></blockquote><p>例如10^75次方，75拆成2进制形式，75 = 1001011</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210318100134.png" alt="方法"></p><p>结果为res，先取1相乘，取t等于10^1，每次t与自己相乘，75二进制有1，乘到res里面，</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210318100333.png" alt="进入res的数"></p><p>Log2(75)</p><blockquote><p>反思矩阵</p></blockquote><p>res开始为单位矩阵，对角线为1，其他全为0，</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210318100618.png" alt="方法"></p><pre><code class="hljs java"><span class="hljs-comment">// 矩阵乘法</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">f3</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;   <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">1</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;   &#125;   <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span> || n == <span class="hljs-number">2</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;   &#125;   <span class="hljs-comment">// [ 1 ,1 ]</span>   <span class="hljs-comment">// [ 1, 0 ]</span>   <span class="hljs-keyword">int</span>[][] base = &#123;         &#123; <span class="hljs-number">1</span>, <span class="hljs-number">1</span> &#125;,         &#123; <span class="hljs-number">1</span>, <span class="hljs-number">0</span> &#125;         &#125;;   <span class="hljs-comment">// 求矩阵n-2次方</span>   <span class="hljs-keyword">int</span>[][] res = matrixPower(base, n - <span class="hljs-number">2</span>);   <span class="hljs-keyword">return</span> res[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] + res[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>];&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[][] matrixPower(<span class="hljs-keyword">int</span>[][] m, <span class="hljs-keyword">int</span> p) &#123;   <span class="hljs-keyword">int</span>[][] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m.length][m[<span class="hljs-number">0</span>].length];   <span class="hljs-comment">// res初始为单位矩阵</span>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; res.length; i++) &#123;      res[i][i] = <span class="hljs-number">1</span>;   &#125;   <span class="hljs-comment">// res = 矩阵中的1</span>   <span class="hljs-keyword">int</span>[][] tmp = m;<span class="hljs-comment">// 矩阵1次方 t^1</span>   <span class="hljs-comment">// 次方每次右移一位，直到为0</span>   <span class="hljs-keyword">for</span> (; p != <span class="hljs-number">0</span>; p &gt;&gt;= <span class="hljs-number">1</span>) &#123;      <span class="hljs-comment">// 1为 00000000000001</span>      <span class="hljs-keyword">if</span> ((p &amp; <span class="hljs-number">1</span>) != <span class="hljs-number">0</span>) &#123;         res = muliMatrix(res, tmp);      &#125;      <span class="hljs-comment">// t*t</span>      tmp = muliMatrix(tmp, tmp);   &#125;   <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-comment">// 两个矩阵相乘结果返回</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[][] muliMatrix(<span class="hljs-keyword">int</span>[][] m1, <span class="hljs-keyword">int</span>[][] m2) &#123;   <span class="hljs-keyword">int</span>[][] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m1.length][m2[<span class="hljs-number">0</span>].length];   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m1.length; i++) &#123;      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; m2[<span class="hljs-number">0</span>].length; j++) &#123;         <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; m2.length; k++) &#123;            res[i][j] += m1[i][k] * m2[k][j];         &#125;      &#125;   &#125;   <span class="hljs-keyword">return</span> res;&#125;</code></pre><h2 id="推广"><a href="#推广" class="headerlink" title="推广"></a>推广</h2><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210318102323.png" alt="递推式"></p><p>C1,c2,c3…cz只要是常数，都有logn的解</p><p>如果某个递归，除了初始项之外，具有如下的形式</p><ul><li>F(N) = C1 * F(N) + C2 * F(N-1) + … + Ck * F(N-k) ( C1…Ck 和k都是常数)</li><li>并且这个递归的表达式是 <strong>严格的、不随条件转移的</strong> </li><li>那么都存在类似斐波那契数列的优化，时间复杂度都能优化成O(logN)</li></ul><h2 id="奶牛问题"><a href="#奶牛问题" class="headerlink" title="奶牛问题"></a>奶牛问题</h2><p>第一年农场有1只成熟的母牛A，往后的每年：</p><p>1）每一只成熟的母牛都会生一只母牛</p><p>2）每一只新出生的母牛都在出生后的第三年成熟</p><p>3）每一只母牛永远不会死</p><p>返回N年后牛的数量</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210318103032.png" alt="牛"></p><p>f（n-1）为去年牛数量，f（n-3）为三年前新出生的牛</p><p>很明显是一个三阶问题：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210318103243.png" alt="三阶"></p><p>三阶问题求解方式：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210318103309.png" alt="求解"></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">c1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;   <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">1</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;   &#125;   <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span> || n == <span class="hljs-number">2</span> || n == <span class="hljs-number">3</span>) &#123;      <span class="hljs-keyword">return</span> n;   &#125;   <span class="hljs-keyword">return</span> c1(n - <span class="hljs-number">1</span>) + c1(n - <span class="hljs-number">3</span>);&#125;<span class="hljs-comment">// 矩阵方法</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">c3</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;   <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">1</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;   &#125;   <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span> || n == <span class="hljs-number">2</span> || n == <span class="hljs-number">3</span>) &#123;      <span class="hljs-keyword">return</span> n;   &#125;   <span class="hljs-keyword">int</span>[][] base = &#123; &#123; <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span> &#125;, &#123; <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span> &#125;, &#123; <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span> &#125; &#125;;   <span class="hljs-keyword">int</span>[][] res = matrixPower(base, n - <span class="hljs-number">3</span>);   <span class="hljs-keyword">return</span> <span class="hljs-number">3</span> * res[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] + <span class="hljs-number">2</span> * res[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + res[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>];&#125;</code></pre><blockquote><p>如果母牛十年后会死呢？</p></blockquote><p>递推式减去f(n-10)</p><h2 id="迈楼梯问题"><a href="#迈楼梯问题" class="headerlink" title="迈楼梯问题"></a>迈楼梯问题</h2><p>一个人可以一次往上迈1个台阶，也可以迈2个台阶</p><p>返回这个人迈上N级台阶的方法数</p><p>迈一层方法数为1，迈两层方法数为2，迈三层为f(1)+f(2);迈n层为f(n-1)+f(n-2)</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">s1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;   <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">1</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;   &#125;   <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span> || n == <span class="hljs-number">2</span>) &#123;      <span class="hljs-keyword">return</span> n;   &#125;   <span class="hljs-keyword">return</span> s1(n - <span class="hljs-number">1</span>) + s1(n - <span class="hljs-number">2</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">s3</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;   <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">1</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;   &#125;   <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span> || n == <span class="hljs-number">2</span>) &#123;      <span class="hljs-keyword">return</span> n;   &#125;   <span class="hljs-keyword">int</span>[][] base = &#123; &#123; <span class="hljs-number">1</span>, <span class="hljs-number">1</span> &#125;, &#123; <span class="hljs-number">1</span>, <span class="hljs-number">0</span> &#125; &#125;;   <span class="hljs-keyword">int</span>[][] res = matrixPower(base, n - <span class="hljs-number">2</span>);   <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * res[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] + res[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>];&#125;</code></pre><p>其他：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210318104617.png" alt="迈五步"></p><h2 id="01字符串"><a href="#01字符串" class="headerlink" title="01字符串"></a>01字符串</h2><p>给定一个数N，想象只由0和1两种字符，组成的所有长度为N的字符串</p><p>如果某个字符串,任何0字符的左边都有1紧挨着,认为这个字符串达标</p><p>返回有多少达标的字符串</p><p>定义一个递归 f(i): <strong>表示字符串为i长度，规定其i长度外左边必有一个1，求f(i)可以达标数</strong> </p><p>N = 8时候，求f（7）即可</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210318110045.png" alt="解法"></p><p>f（i） = f（i-1） + f（i-2）</p><h2 id="铺瓷砖问题"><a href="#铺瓷砖问题" class="headerlink" title="铺瓷砖问题"></a>铺瓷砖问题</h2><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210318110254.png" alt="填满方法"></p><p>就看左上角瓷砖怎么摆</p><p>定义函数f(n)如果还有n列没有填满，返回方法数</p><p>如果一开始就竖着摆放：f(n-1)种</p><p>如果一开始就横着摆:只能再用一个瓷砖填满 ;</p><p>所以：f(n) = f(n-1) + f(n-2)</p><h1 id="bfprt算法与蓄水池算法"><a href="#bfprt算法与蓄水池算法" class="headerlink" title="bfprt算法与蓄水池算法"></a>bfprt算法与蓄水池算法</h1><h2 id="bfprt"><a href="#bfprt" class="headerlink" title="bfprt"></a>bfprt</h2><h2 id="笔试推荐-改写快排"><a href="#笔试推荐-改写快排" class="headerlink" title="笔试推荐 改写快排"></a>笔试推荐 改写快排</h2><p>注：bfprt笔试不用，已经有更好的替代。</p><p>解答问题：在一个无序数组中，怎么求第 k 小的数？ O(N)拿下</p><p>可以用 <strong>快排</strong> 的思想解决</p><p>随机选一个m，找命中k的一侧，快排两侧都要排</p><p>为什么是O(N)?</p><p>如果m打的非常正，在中间，下一次只需要划分一半，所以 T(n) = T(n/2) + O(n) 用公式求收敛于O(n)</p><p>如果m打的非常不正，在最边上，T(n) = T (n - 1) + O(n) 是O(n^2)的</p><p>因为随机，所以的概率事件，用表达式收敛，还是收敛于O(n)</p><p>笔试code:</p><pre><code class="hljs java"><span class="hljs-comment">// 改写快排，时间复杂度O(N)</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minKth2</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] array, <span class="hljs-keyword">int</span> k)</span> </span>&#123;   <span class="hljs-keyword">int</span>[] arr = copyArray(array);   <span class="hljs-keyword">return</span> process2(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>, k - <span class="hljs-number">1</span>);&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] copyArray(<span class="hljs-keyword">int</span>[] arr) &#123;   <span class="hljs-keyword">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[arr.length];   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i != ans.length; i++) &#123;      ans[i] = arr[i];   &#125;   <span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-comment">// 在arr[L..R]范围上，如果排序的话，找位于index位置的数</span><span class="hljs-comment">// index一定在[L...R]上</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">process2</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R, <span class="hljs-keyword">int</span> index)</span> </span>&#123;   <span class="hljs-keyword">if</span> (L == R) &#123;      <span class="hljs-keyword">return</span> arr[L];   &#125;   <span class="hljs-comment">// 等概率随机选一个值作划分</span>   <span class="hljs-keyword">int</span> pivot = arr[L + (<span class="hljs-keyword">int</span>) (Math.random() * (R - L + <span class="hljs-number">1</span>))];   <span class="hljs-comment">// range[0] range[1]</span>   <span class="hljs-comment">// L...R pivot在范围上的左边界和右边界</span>   <span class="hljs-keyword">int</span>[] range = partition(arr, L, R, pivot);   <span class="hljs-keyword">if</span> (index &gt;= range[<span class="hljs-number">0</span>] &amp;&amp; index &lt;= range[<span class="hljs-number">1</span>]) &#123;      <span class="hljs-keyword">return</span> arr[index];   &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (index &lt; range[<span class="hljs-number">0</span>]) &#123;      <span class="hljs-keyword">return</span> process2(arr, L, range[<span class="hljs-number">0</span>] - <span class="hljs-number">1</span>, index);   &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-keyword">return</span> process2(arr, range[<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>, R, index);   &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] partition(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R, <span class="hljs-keyword">int</span> pivot) &#123;   <span class="hljs-keyword">int</span> less = L - <span class="hljs-number">1</span>;   <span class="hljs-keyword">int</span> more = R + <span class="hljs-number">1</span>;   <span class="hljs-keyword">int</span> cur = L;   <span class="hljs-keyword">while</span> (cur &lt; more) &#123;      <span class="hljs-keyword">if</span> (arr[cur] &lt; pivot) &#123;         swap(arr, ++less, cur++);      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[cur] &gt; pivot) &#123;         swap(arr, cur, --more);      &#125; <span class="hljs-keyword">else</span> &#123;         cur++;      &#125;   &#125;   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123; less + <span class="hljs-number">1</span>, more - <span class="hljs-number">1</span> &#125;;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> i1, <span class="hljs-keyword">int</span> i2)</span> </span>&#123;   <span class="hljs-keyword">int</span> tmp = arr[i1];   arr[i1] = arr[i2];   arr[i2] = tmp;&#125;</code></pre><h2 id="bfprt是什么？"><a href="#bfprt是什么？" class="headerlink" title="bfprt是什么？"></a>bfprt是什么？</h2><p>不用概率计算，严格流程收敛于O(N)；</p><p>bfprt怎么选这个随机数，是很讲究的。</p><p>第一步：每五个数分成一组，0～4，5～9，最后不足五个凑一组</p><p>第二步：每组自己排序</p><p>第三步：每组中位数拿出来 m0，m1，m2….，最后不足就拿上中位数或下中位数，组成m数组</p><p>第四步：递归调用bfprt把m数组传入，找到m数组的中位数，这个数就是“天选”</p><p>就是把随机选择数，变成分组排序后的中位数数组取中位数</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210320144759.png" alt="求m数组过程"></p><p>假设得到的c是中位数数组的中位数，一定有两个中位数大于等于c，如果整个数字个数为N，一共有N/5个中位数，一共有N/10 + (n/10) * 2 即一共  <strong>3/10倍的N</strong>  的数大于等于c</p><p>所以比c小的数有 7/10的N 的数，数不管在左侧还是右侧，问题只是变成至多大于等于还是小于等于m的数字有多少，反向思考至少小于或者大于的m，一定可以甩掉 3/10倍的N 的规模。</p><p>T(N)=O(n) + T(n/5) + T(7n/10) 数学证明为O（N）</p><pre><code class="hljs java"><span class="hljs-comment">// 利用bfprt算法，时间复杂度O(N)</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minKth3</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] array, <span class="hljs-keyword">int</span> k)</span> </span>&#123;   <span class="hljs-keyword">int</span>[] arr = copyArray(array);   <span class="hljs-keyword">return</span> bfprt(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>, k - <span class="hljs-number">1</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">bfprt</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R, <span class="hljs-keyword">int</span> index)</span> </span>&#123;   <span class="hljs-keyword">if</span> (L == R) &#123;      <span class="hljs-keyword">return</span> arr[L];   &#125;   <span class="hljs-keyword">int</span> pivot = medianOfMedians(arr, L, R);   <span class="hljs-keyword">int</span>[] range = partition(arr, L, R, pivot);   <span class="hljs-keyword">if</span> (index &gt;= range[<span class="hljs-number">0</span>] &amp;&amp; index &lt;= range[<span class="hljs-number">1</span>]) &#123;      <span class="hljs-keyword">return</span> arr[index];   &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (index &lt; range[<span class="hljs-number">0</span>]) &#123;      <span class="hljs-keyword">return</span> bfprt(arr, L, range[<span class="hljs-number">0</span>] - <span class="hljs-number">1</span>, index);   &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-keyword">return</span> bfprt(arr, range[<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>, R, index);   &#125;&#125;<span class="hljs-comment">// arr[L...R]五个一组 内部排序 得到中位数数组，求其中位数</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">medianOfMedians</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R)</span> </span>&#123;   <span class="hljs-keyword">int</span> size = R - L + <span class="hljs-number">1</span>;   <span class="hljs-comment">// offset表示要不要补最后一组</span>   <span class="hljs-keyword">int</span> offset = size % <span class="hljs-number">5</span> == <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>;   <span class="hljs-keyword">int</span>[] mArr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[size / <span class="hljs-number">5</span> + offset];   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> team = <span class="hljs-number">0</span>; team &lt; mArr.length; team++) &#123;      <span class="hljs-keyword">int</span> teamFirst = L + team * <span class="hljs-number">5</span>;      mArr[team] = getMedian(arr, teamFirst, Math.min(R, teamFirst + <span class="hljs-number">4</span>));   &#125;  <span class="hljs-comment">// 调用bfprt找到中位数数组的中位数</span>   <span class="hljs-keyword">return</span> bfprt(mArr, <span class="hljs-number">0</span>, mArr.length - <span class="hljs-number">1</span>, mArr.length / <span class="hljs-number">2</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMedian</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R)</span> </span>&#123;   insertionSort(arr, L, R);   <span class="hljs-keyword">return</span> arr[(L + R) / <span class="hljs-number">2</span>];&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertionSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R)</span> </span>&#123;   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = L + <span class="hljs-number">1</span>; i &lt;= R; i++) &#123;      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i - <span class="hljs-number">1</span>; j &gt;= L &amp;&amp; arr[j] &gt; arr[j + <span class="hljs-number">1</span>]; j--) &#123;         swap(arr, j, j + <span class="hljs-number">1</span>);      &#125;   &#125;&#125;</code></pre><h3 id="bfprt应用"><a href="#bfprt应用" class="headerlink" title="bfprt应用"></a>bfprt应用</h3><p>拿一个数组前十小的数，先找第十小的数，再遍历数组</p><h2 id="蓄水池算法"><a href="#蓄水池算法" class="headerlink" title="蓄水池算法"></a>蓄水池算法</h2><p>一个流蓄水池，在不断吐出有编号的球，有一个只能装十个球的袋子，丢的球不能再找回，</p><p>要求到n号球吐出，所有球被接住的概率均等</p><p>流程：</p><p>1～10全接住，往后的每一个球出来的时候，以10/k的概率决定是否要，如果不要则丢；如果要，则等概率丢弃袋子中一个</p><p>例子：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210318111942.png" alt="例子"></p><p>4~10号球时，3号球在袋子里面的概率是1，当11号球到来时，以10/11的概率决定11是否入袋，并且以1/10的概率决定是否抛弃3号球，所以11号球到来后，3号球还在袋子中的概率为 1*(1-10/11乘1/10) 即为10/11</p><p>现在12号球到来，则为 10/11 乘 （1 * （1 - 10/12乘1/10））即为 10/12</p><p>所以等到17号球到来，3号球在袋子中的概率为10/17</p><p>怎么求当17号球到来时，13号球在袋子里的概率：</p><p>13号被选中为 10/13，14被选中且恰好13被踢出去为 10/14 * 1/10 </p><p>所以14到来，13还在的概率为 10/13 * (1 - 1/14) 即为 10/14</p><p>…..</p><p>当17号球到来时，13号球在袋子里为10/17</p><h3 id="蓄水池举例"><a href="#蓄水池举例" class="headerlink" title="蓄水池举例"></a>蓄水池举例</h3><p>如果有一个游戏公司，上10亿个用户，抽取100个当天登录的幸运儿：</p><p>传统方式：当天登录记录，去重，抽取100个；</p><p>蓄水池方式：取一个能装载100个用户的服务器，当当天每个用户登录时，先判断是否为第一次登录，再写一个方法，确定今天第几个登录的用户，概率就是 100/第几个登录，再利用蓄水池算法剔除，最后公布100人</p><h3 id="1～10概率问题"><a href="#1～10概率问题" class="headerlink" title="1～10概率问题"></a>1～10概率问题</h3><p>已知有一个黑盒，能返回1～7等概率，要求加工，使1～10也能等概率：</p><p>1～7如果roll到7，剔除，认为1～3为roll到0，4～6位roll到1；</p><p>用二进制位表示数，黑盒roll四次能保证0～15等概率；剔除10～15，重做。</p><p>roll出0～9就等于roll出1～10</p><h3 id="01概率问题"><a href="#01概率问题" class="headerlink" title="01概率问题"></a>01概率问题</h3><p>假设roll 0的概率为p，roll 1的概率为 1 - p</p><p>怎么roll 0，1等概率？</p><p>roll两次，出00和11淘汰，出01和10分别代表一个</p><h1 id="KMP算法及其扩展"><a href="#KMP算法及其扩展" class="headerlink" title="KMP算法及其扩展"></a>KMP算法及其扩展</h1><blockquote><p>思考</p></blockquote><p>假设字符串str长度为N，字符串match长度为M，M &lt;= N</p><p>想确定str中是否有某个 <strong>子串是等于match的</strong> 。</p><p>时间复杂度 <strong>O(N)</strong> </p><p>int f(str, match) 返回包含的开始位置</p><p> <strong>子串</strong> 一定是要求连续的</p><p>KMP算法思路仍是试每一个位置，只不过有加速。每一个位置有一个 <strong>指标</strong> ，讨论的是之前的字符串中，前缀跟后缀的 <strong>最长匹配长度</strong> 。</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210319141309.png" alt="匹配"></p><p>还需要长度为4、5，不取到整体，求 <strong>相等的最大长度值为指标值</strong> 。</p><p>设立一个 <strong>next数组</strong> ，保存match的信息。</p><p>0位置信息规定为-1，1位置信息规定为0；</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210319142245.png" alt="信息"></p><p>接下来用next数组加速匹配：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210319142745.png" alt="传统"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210319143217.png" alt="KMP"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210319143950.png" alt="例子"></p><blockquote><p>为什么最长前后缀之前不能配出match？</p></blockquote><p>假设可以，会得出match最后不等字符之前的最长相等前后缀长度值与得到的实际值不一致的矛盾。</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210319150718.png" alt="流程"></p><h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>先对while循环进行分析，只需要分析进去while循环多少次</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210320105747.png" alt="while"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210320105701.png" alt="分析"></p><p>我们设立两个参数，第一个参数就是while中的x，最大能达到N；第二个参数为x - y，最大也只能达到n；</p><p>当命中第一条分支时，x上升，x - y不变；</p><p>以此类推，两个量最大只能达到 2N</p><h2 id="next数组生成"><a href="#next数组生成" class="headerlink" title="next数组生成"></a>next数组生成</h2><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210320111351.png" alt="第一步"></p><p>如果相等就直接等于next[i - 1] + 1了</p><p>如果不等于：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210320111604.png" alt="不等"></p><p>上图打错，是 s位置的值加一</p><h2 id="总体算法"><a href="#总体算法" class="headerlink" title="总体算法"></a>总体算法</h2><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getIndexOf</span><span class="hljs-params">(String s, String m)</span> </span>&#123;   <span class="hljs-keyword">if</span> (s == <span class="hljs-keyword">null</span> || m == <span class="hljs-keyword">null</span> || m.length() &lt; <span class="hljs-number">1</span> || s.length() &lt; m.length()) &#123;      <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;   &#125;   <span class="hljs-keyword">char</span>[] str = s.toCharArray();   <span class="hljs-keyword">char</span>[] match = m.toCharArray();   <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;<span class="hljs-comment">// str中比对到的位置</span>   <span class="hljs-keyword">int</span> y = <span class="hljs-number">0</span>;<span class="hljs-comment">// match中比对到的位置</span>   <span class="hljs-keyword">int</span>[] next = getNextArray(match);   <span class="hljs-keyword">while</span> (x &lt; str.length &amp;&amp; y &lt; match.length) &#123;      <span class="hljs-keyword">if</span> (str[x] == match[y]) &#123;         x++;         y++;      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (next[y] == -<span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 或者y == 0</span>         x++;      &#125; <span class="hljs-keyword">else</span> &#123;         y = next[y];      &#125;   &#125;   <span class="hljs-keyword">return</span> y == match.length ? x - y : -<span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] getNextArray(<span class="hljs-keyword">char</span>[] ms) &#123;   <span class="hljs-keyword">if</span> (ms.length == <span class="hljs-number">1</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123; -<span class="hljs-number">1</span> &#125;;   &#125;   <span class="hljs-keyword">int</span>[] next = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[ms.length];   next[<span class="hljs-number">0</span>] = -<span class="hljs-number">1</span>;   next[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;   <span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>;   <span class="hljs-comment">// cn代表，cn位置的字符，是当前和i-1位置比较的字符</span>   <span class="hljs-keyword">int</span> cn = <span class="hljs-number">0</span>;   <span class="hljs-keyword">while</span> (i &lt; next.length) &#123;      <span class="hljs-keyword">if</span> (ms[i - <span class="hljs-number">1</span>] == ms[cn]) &#123;         next[i++] = ++cn;         <span class="hljs-comment">// ++cn的值必定是next[i-1]的值</span>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cn &gt; <span class="hljs-number">0</span>) &#123;         cn = next[cn];      &#125; <span class="hljs-keyword">else</span> &#123;         next[i++] = <span class="hljs-number">0</span>;      &#125;   &#125;   <span class="hljs-keyword">return</span> next;&#125;</code></pre><p>利用分析上面while循环复杂度的方法分析next生成复杂度</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210320113033.png" alt="复杂度"></p><h2 id="indexOf方法"><a href="#indexOf方法" class="headerlink" title="indexOf方法"></a>indexOf方法</h2><p>indexlof方法后台不是kmp，是比kmp拥有给小的常数的算法，时间复杂度也是O(N)</p><h2 id="KMP应用"><a href="#KMP应用" class="headerlink" title="KMP应用"></a>KMP应用</h2><h3 id="旋转词问题"><a href="#旋转词问题" class="headerlink" title="旋转词问题"></a>旋转词问题</h3><p>给定一个str1和str2，判断是否互为旋转词</p><blockquote><p>旋转词定义</p></blockquote><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210320115002.png" alt="旋转词"></p><p>方法：</p><p>给str1增加一倍，查str2是否为子串</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210320115412.png" alt="方法"></p><p>str1增加一倍从任何地方开头，长度为str1的串，一定是str1的旋转词</p><h3 id="二叉树子树问题"><a href="#二叉树子树问题" class="headerlink" title="二叉树子树问题"></a>二叉树子树问题</h3><p>给定两棵二叉树的头节点head1和head2</p><p>想知道head1中是否有某个子树的结构和head2完全一样</p><p>解法：先序序列化二叉树，找是否包含子串</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210320121908.png" alt="要包含null"></p><p>因为先序序列化一个子串只代表一个结构，没有歧义</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> value;   <span class="hljs-keyword">public</span> Node left;   <span class="hljs-keyword">public</span> Node right;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v)</span> </span>&#123;      value = v;   &#125;&#125;<span class="hljs-comment">// 暴力 big做头节点的树，其中是否有某颗子树的结构和small为头的树完全一样</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">containsTree1</span><span class="hljs-params">(Node big, Node small)</span> </span>&#123;   <span class="hljs-keyword">if</span> (small == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;   &#125;   <span class="hljs-keyword">if</span> (big == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;   &#125;   <span class="hljs-keyword">if</span> (isSameValueStructure(big, small)) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;   &#125;   <span class="hljs-keyword">return</span> containsTree1(big.left, small) || containsTree1(big.right, small);&#125;<span class="hljs-comment">// head1为头的树是否在结构上完全和head2一样</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSameValueStructure</span><span class="hljs-params">(Node head1, Node head2)</span> </span>&#123;   <span class="hljs-keyword">if</span> (head1 == <span class="hljs-keyword">null</span> &amp;&amp; head2 != <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;   &#125;   <span class="hljs-keyword">if</span> (head1 != <span class="hljs-keyword">null</span> &amp;&amp; head2 == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;   &#125;   <span class="hljs-keyword">if</span> (head1 == <span class="hljs-keyword">null</span> &amp;&amp; head2 == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;   &#125;   <span class="hljs-keyword">if</span> (head1.value != head2.value) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;   &#125;   <span class="hljs-comment">// 1 2有值</span>   <span class="hljs-comment">// 1左树等于2左树</span>   <span class="hljs-keyword">return</span> isSameValueStructure(head1.left, head2.left) &amp;&amp; isSameValueStructure(head1.right, head2.right);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">containsTree2</span><span class="hljs-params">(Node big, Node small)</span> </span>&#123;   <span class="hljs-keyword">if</span> (small == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;   &#125;   <span class="hljs-keyword">if</span> (big == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;   &#125;   <span class="hljs-comment">// 先序 含空的</span>   ArrayList&lt;String&gt; b = preSerial(big);   ArrayList&lt;String&gt; s = preSerial(small);   String[] str = <span class="hljs-keyword">new</span> String[b.size()];   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; str.length; i++) &#123;      str[i] = b.get(i);   &#125;   String[] match = <span class="hljs-keyword">new</span> String[s.size()];   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; match.length; i++) &#123;      match[i] = s.get(i);   &#125;   <span class="hljs-keyword">return</span> getIndexOf(str, match) != -<span class="hljs-number">1</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ArrayList&lt;String&gt; <span class="hljs-title">preSerial</span><span class="hljs-params">(Node head)</span> </span>&#123;   ArrayList&lt;String&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();   pres(head, ans);   <span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pres</span><span class="hljs-params">(Node head, ArrayList&lt;String&gt; ans)</span> </span>&#123;   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;      ans.add(<span class="hljs-keyword">null</span>);   &#125; <span class="hljs-keyword">else</span> &#123;      ans.add(String.valueOf(head.value));      pres(head.left, ans);      pres(head.right, ans);   &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getIndexOf</span><span class="hljs-params">(String[] str1, String[] str2)</span> </span>&#123;   <span class="hljs-keyword">if</span> (str1 == <span class="hljs-keyword">null</span> || str2 == <span class="hljs-keyword">null</span> || str1.length &lt; <span class="hljs-number">1</span> || str1.length &lt; str2.length) &#123;      <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;   &#125;   <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;   <span class="hljs-keyword">int</span> y = <span class="hljs-number">0</span>;   <span class="hljs-keyword">int</span>[] next = getNextArray(str2);   <span class="hljs-keyword">while</span> (x &lt; str1.length &amp;&amp; y &lt; str2.length) &#123;      <span class="hljs-keyword">if</span> (isEqual(str1[x], str2[y])) &#123;         x++;         y++;      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (next[y] == -<span class="hljs-number">1</span>) &#123;         x++;      &#125; <span class="hljs-keyword">else</span> &#123;         y = next[y];      &#125;   &#125;   <span class="hljs-keyword">return</span> y == str2.length ? x - y : -<span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] getNextArray(String[] ms) &#123;   <span class="hljs-keyword">if</span> (ms.length == <span class="hljs-number">1</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123; -<span class="hljs-number">1</span> &#125;;   &#125;   <span class="hljs-keyword">int</span>[] next = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[ms.length];   next[<span class="hljs-number">0</span>] = -<span class="hljs-number">1</span>;   next[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;   <span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>;   <span class="hljs-keyword">int</span> cn = <span class="hljs-number">0</span>;   <span class="hljs-keyword">while</span> (i &lt; next.length) &#123;      <span class="hljs-keyword">if</span> (isEqual(ms[i - <span class="hljs-number">1</span>], ms[cn])) &#123;         next[i++] = ++cn;      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cn &gt; <span class="hljs-number">0</span>) &#123;         cn = next[cn];      &#125; <span class="hljs-keyword">else</span> &#123;         next[i++] = <span class="hljs-number">0</span>;      &#125;   &#125;   <span class="hljs-keyword">return</span> next;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEqual</span><span class="hljs-params">(String a, String b)</span> </span>&#123;   <span class="hljs-keyword">if</span> (a == <span class="hljs-keyword">null</span> &amp;&amp; b == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;   &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-keyword">if</span> (a == <span class="hljs-keyword">null</span> || b == <span class="hljs-keyword">null</span>) &#123;         <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;      &#125; <span class="hljs-keyword">else</span> &#123;         <span class="hljs-keyword">return</span> a.equals(b);      &#125;   &#125;&#125;</code></pre><p>改成数组形式，防止歧义：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210320122739.png" alt="防止歧义"></p><h1 id="Manacher算法及其扩展"><a href="#Manacher算法及其扩展" class="headerlink" title="Manacher算法及其扩展"></a>Manacher算法及其扩展</h1><p>假设字符串str长度为N，想返回最长回文子串的长度</p><p>时间复杂度O(N)</p><p>如果暴力定位字符左右两边扩的话，可能会遗失 “虚轴”</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210321121046.png" alt="虚轴"></p><p>暴力定位要变成下面样子：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210321121544.png"></p><p>暴力法最差情况就是全都是一种字符，每次都要扩到一个边界</p><p>前一半是一个等差数列，后一半也是，所以是O(N^2)</p><h2 id="算法概念"><a href="#算法概念" class="headerlink" title="算法概念"></a>算法概念</h2><h3 id="0、回文半径、直径、区域"><a href="#0、回文半径、直径、区域" class="headerlink" title="0、回文半径、直径、区域"></a>0、回文半径、直径、区域</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210322112218.png" alt="回文"></p><h3 id="1、回文半径数组-parr"><a href="#1、回文半径数组-parr" class="headerlink" title="1、回文半径数组(parr)"></a>1、回文半径数组(parr)</h3><p>前面每一步求出来的答案求加速</p><h3 id="2、回文最右右边界-int-R"><a href="#2、回文最右右边界-int-R" class="headerlink" title="2、回文最右右边界(int R)"></a>2、回文最右右边界(int R)</h3><h3 id="3、中心-int-c"><a href="#3、中心-int-c" class="headerlink" title="3、中心(int c)"></a>3、中心(int c)</h3><p>R和C是一组概念，一开始可以认为R C 为-1，没有意义</p><p>拿 #1#2#2#1#…..举例子</p><p>扩到第一个#时候，位置为0，回文区域最右侧到0，比-1大，更新；R更新时，谁让他更新的，就是C，此时为0</p><p>扩到第一个1时候，区域为#1#，右边界2位置，R更新为2；1让R更新，C为1；</p><h2 id="算法过程"><a href="#算法过程" class="headerlink" title="算法过程"></a>算法过程</h2><p>假设当前处于i位置</p><ol><li>i在R外</li></ol><ul><li>没有任何优化，暴力过程，比较i-1，i-2……</li></ul><ol start="2"><li>i在R内，压线也算</li></ol><ul><li>一定存在i在C和R位置之间</li><li><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210322114003.png" alt="一定存在i&#39;"></li><li>再细分对称点，对称点一定是已经求得答案了<ul><li>i’自己的回文区域彻底在L..R大范围的内部，答案 <strong>和i’一样</strong> <ul><li><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210322114447.png" alt="内部"></li><li>如上图，为什么不会有更大区域，因为上图i’旁边的b等于i右边的b；s等于左边的s，但b不等于s，所以就是这么宽的区域</li></ul></li><li>i’自己的回文区域彻底在L..R大范围的外部，<strong>完全不用扩，i到R位置就是新区域</strong> <ul><li><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210322115624.png" alt="在外"></li><li>以k为中心的只能扩到右边Y左边，i’能扩到外面，但i不能，i外面和a一定不等，不在回文内部</li></ul></li><li>i’自己的回文区域和L压线，可能更长，<strong>需要从R后面的字符和C相不相等</strong> <ul><li><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210322120612.png" alt="压线"></li></ul></li></ul></li></ul><h2 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="分支限定"><a href="#分支限定" class="headerlink" title="分支限定"></a>分支限定</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210322165919.png" alt="分支"></p><p>假定R分析四个分支：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210322165735.png" alt="分析"></p><p>R最多跑到N，所以manacher一定是O(N)的算法</p><h2 id="总体算法-1"><a href="#总体算法-1" class="headerlink" title="总体算法"></a>总体算法</h2><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">manacher</span><span class="hljs-params">(String s)</span> </span>&#123;   <span class="hljs-keyword">if</span> (s == <span class="hljs-keyword">null</span> || s.length() == <span class="hljs-number">0</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;   &#125;   <span class="hljs-keyword">char</span>[] str = manacherString(s);   <span class="hljs-comment">// 回文半径的大小</span>   <span class="hljs-keyword">int</span>[] pArr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[str.length];   <span class="hljs-keyword">int</span> C = -<span class="hljs-number">1</span>;   <span class="hljs-keyword">int</span> R = -<span class="hljs-number">1</span>;<span class="hljs-comment">// 课上：R代表最右的扩成功的位置。代码中：最右的扩成功位置的，再下一个位置</span>   <span class="hljs-keyword">int</span> max = Integer.MIN_VALUE;   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i != str.length; i++) &#123;      <span class="hljs-comment">// R是第一个违规的位置 i&gt;=R就相当于第一个分支 i在R外 i至少不用验的区域是自己这个字符 为1</span>      <span class="hljs-comment">// pArr[i] 初始表示不用验证的区域</span>      <span class="hljs-comment">// i位置扩出来的答案，i位置扩的区域，至少是多大。</span>      <span class="hljs-comment">// 如果R &gt; i 包括了i&#x27;区域在里面和在外面</span>      pArr[i] = R &gt; i ? Math.min(pArr[<span class="hljs-number">2</span> * C - i], R - i) : <span class="hljs-number">1</span>;      <span class="hljs-keyword">while</span> (i + pArr[i] &lt; str.length &amp;&amp; i - pArr[i] &gt; -<span class="hljs-number">1</span>) &#123;         <span class="hljs-comment">// 向左向右扩充</span>         <span class="hljs-comment">// 情况2情况3直接进while就退出</span>         <span class="hljs-keyword">if</span> (str[i + pArr[i]] == str[i - pArr[i]])            pArr[i]++;         <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">break</span>;         &#125;      &#125;      <span class="hljs-keyword">if</span> (i + pArr[i] &gt; R) &#123;         <span class="hljs-comment">// i位置扩出来的答案 如果刷新了R 就更新并记录中心</span>         R = i + pArr[i];         C = i;      &#125;      max = Math.max(max, pArr[i]);   &#125;   <span class="hljs-comment">// #1#2#1# 半径 4 - 1 （该算法记录半径）</span>   <span class="hljs-comment">// #1#2#1# 直径 7/2</span>   <span class="hljs-keyword">return</span> max - <span class="hljs-number">1</span>;&#125;<span class="hljs-comment">// 前后加 #</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">char</span>[] manacherString(String str) &#123;   <span class="hljs-keyword">char</span>[] charArr = str.toCharArray();   <span class="hljs-keyword">char</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[str.length() * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>];   <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i != res.length; i++) &#123;      res[i] = (i &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span> ? <span class="hljs-string">&#x27;#&#x27;</span> : charArr[index++];   &#125;   <span class="hljs-keyword">return</span> res;&#125;</code></pre><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>给定字符串str，让字符串整体变成回文串，只能在后面添加字符，求添加最短字符数。</p><blockquote><p>思考：实际是求什么</p></blockquote><p> <strong>必须包含最后一个字符的回文串有多长</strong> </p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210322172919.png" alt="解"></p><p>然后把不是的逆序，就是答案</p><p>找到 <strong>最左侧</strong> 哪个字符位置能包含住最后一个字符。</p><p>或者直接得到全部的回文半径数组。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">shortestEnd</span><span class="hljs-params">(String str)</span> </span>&#123;   <span class="hljs-keyword">if</span> (str == <span class="hljs-keyword">null</span> || str.length() == <span class="hljs-number">0</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;   &#125;   <span class="hljs-keyword">char</span>[] charArr = manacherString(str);   <span class="hljs-keyword">int</span>[] pArr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[charArr.length];   <span class="hljs-keyword">int</span> C = -<span class="hljs-number">1</span>;   <span class="hljs-keyword">int</span> R = -<span class="hljs-number">1</span>;   <span class="hljs-keyword">int</span> maxContainsEnd = -<span class="hljs-number">1</span>;   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i != charArr.length; i++) &#123;      pArr[i] = R &gt; i ? Math.min(pArr[<span class="hljs-number">2</span> * C - i], R - i) : <span class="hljs-number">1</span>;      <span class="hljs-keyword">while</span> (i + pArr[i] &lt; charArr.length &amp;&amp; i - pArr[i] &gt; -<span class="hljs-number">1</span>) &#123;         <span class="hljs-keyword">if</span> (charArr[i + pArr[i]] == charArr[i - pArr[i]])            pArr[i]++;         <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">break</span>;         &#125;      &#125;      <span class="hljs-keyword">if</span> (i + pArr[i] &gt; R) &#123;         R = i + pArr[i];         C = i;      &#125;      <span class="hljs-keyword">if</span> (R == charArr.length) &#123;         maxContainsEnd = pArr[i];         <span class="hljs-keyword">break</span>;      &#125;   &#125;   <span class="hljs-keyword">char</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[str.length() - maxContainsEnd + <span class="hljs-number">1</span>];   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; res.length; i++) &#123;      res[res.length - <span class="hljs-number">1</span> - i] = charArr[i * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>];   &#125;   <span class="hljs-keyword">return</span> String.valueOf(res);&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">char</span>[] manacherString(String str) &#123;   <span class="hljs-keyword">char</span>[] charArr = str.toCharArray();   <span class="hljs-keyword">char</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[str.length() * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>];   <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i != res.length; i++) &#123;      res[i] = (i &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span> ? <span class="hljs-string">&#x27;#&#x27;</span> : charArr[index++];   &#125;   <span class="hljs-keyword">return</span> res;&#125;</code></pre><h1 id="Morris遍历及其相关扩展"><a href="#Morris遍历及其相关扩展" class="headerlink" title="Morris遍历及其相关扩展"></a>Morris遍历及其相关扩展</h1><h2 id="算法概念-1"><a href="#算法概念-1" class="headerlink" title="算法概念"></a>算法概念</h2><p>一种遍历二叉树的方式，并且时间复杂度O(N)， <strong>额外空间复杂度O(1)</strong> </p><p>通过利用原树中大量空闲指针的方式，达到节省空间的目的</p><p>之前递归方法拿栈花费空间，跟高度相关，O(h)。非递归自己压栈，也是O(h)</p><h2 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h2><p>假设来到当前节点cur，开始时cur来到 <strong>头节点</strong> 位置</p><ul><li><ol><li>如果cur没有左孩子，cur向右移动(cur = cur.right)</li></ol></li><li><ol start="2"><li>如果cur有左孩子，找到左子树上最右的节点mostRight：</li></ol><ul><li>如果mostRight的右指针指向null，让其指向cur，然后cur向左移动(cur = cur.left)</li><li>如果mostRight的右指针指向cur，让其指向null，然后cur向右移动(cur = cur.right)</li></ul></li><li><ol start="3"><li>cur为空时遍历停止</li></ol></li></ul><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210323082818.png" alt="例子"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210323083705.png" alt="例子"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210323084354.png" alt="例子2"></p><p>任何一个结点有左孩子，一定来两次；</p><p>没有左孩子的点，只来到一次；</p><h2 id="算法代码"><a href="#算法代码" class="headerlink" title="算法代码"></a>算法代码</h2><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">morrisIn</span><span class="hljs-params">(Node head)</span> </span>&#123;   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span>;   &#125;   Node cur = head;   Node mostRight = <span class="hljs-keyword">null</span>;   <span class="hljs-keyword">while</span> (cur != <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-comment">// cur 有没有左树</span>      mostRight = cur.left;      <span class="hljs-keyword">if</span> (mostRight != <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// 有左树情况下</span>         <span class="hljs-comment">// 找到cur左树上真实的最右节点</span>         <span class="hljs-keyword">while</span> (mostRight.right != <span class="hljs-keyword">null</span> &amp;&amp; mostRight.right != cur) &#123;            mostRight = mostRight.right;         &#125;         <span class="hljs-comment">// 找到了mostRight</span>         <span class="hljs-comment">// mostRight指向空</span>         <span class="hljs-keyword">if</span> (mostRight.right == <span class="hljs-keyword">null</span>) &#123;            mostRight.right = cur;            cur = cur.left;            <span class="hljs-keyword">continue</span>;         &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// mostRight指向cur</span>            mostRight.right = <span class="hljs-keyword">null</span>;         &#125;      &#125;      cur = cur.right;   &#125;&#125;</code></pre><h2 id="morris序实现先序中序后序"><a href="#morris序实现先序中序后序" class="headerlink" title="morris序实现先序中序后序"></a>morris序实现先序中序后序</h2><h3 id="先序"><a href="#先序" class="headerlink" title="先序"></a>先序</h3><p>第一次来到就 <strong>打印</strong> </p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">morrisPre</span><span class="hljs-params">(Node head)</span> </span>&#123;   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span>;   &#125;   Node cur = head;   Node mostRight = <span class="hljs-keyword">null</span>;   <span class="hljs-keyword">while</span> (cur != <span class="hljs-keyword">null</span>) &#123;      mostRight = cur.left;      <span class="hljs-keyword">if</span> (mostRight != <span class="hljs-keyword">null</span>) &#123;         <span class="hljs-keyword">while</span> (mostRight.right != <span class="hljs-keyword">null</span> &amp;&amp; mostRight.right != cur) &#123;            mostRight = mostRight.right;         &#125;         <span class="hljs-keyword">if</span> (mostRight.right == <span class="hljs-keyword">null</span>) &#123;            mostRight.right = cur;           <span class="hljs-comment">// 有左树就第一次打印</span>            System.out.print(cur.value + <span class="hljs-string">&quot; &quot;</span>);            cur = cur.left;            <span class="hljs-keyword">continue</span>;         &#125; <span class="hljs-keyword">else</span> &#123;            mostRight.right = <span class="hljs-keyword">null</span>;         &#125;      &#125; <span class="hljs-keyword">else</span>         <span class="hljs-comment">// 没有左树就打印</span>         System.out.print(cur.value + <span class="hljs-string">&quot; &quot;</span>);      &#125;      cur = cur.right;   &#125;   System.out.println();&#125;</code></pre><h3 id="中序"><a href="#中序" class="headerlink" title="中序"></a>中序</h3><p>能回到自己两次的结点（有左树），第二次打印，不能则直接打印；</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">morrisIn</span><span class="hljs-params">(Node head)</span> </span>&#123;   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span>;   &#125;   Node cur = head;   Node mostRight = <span class="hljs-keyword">null</span>;   <span class="hljs-keyword">while</span> (cur != <span class="hljs-keyword">null</span>) &#123;      mostRight = cur.left;      <span class="hljs-keyword">if</span> (mostRight != <span class="hljs-keyword">null</span>) &#123;          <span class="hljs-keyword">while</span> (mostRight.right != <span class="hljs-keyword">null</span> &amp;&amp; mostRight.right != cur) &#123;            mostRight = mostRight.right;         &#125;<span class="hljs-comment">// 能回到自己结点两次的不打印</span>         <span class="hljs-keyword">if</span> (mostRight.right == <span class="hljs-keyword">null</span>) &#123;            mostRight.right = cur;            cur = cur.left;            <span class="hljs-keyword">continue</span>;         &#125; <span class="hljs-keyword">else</span> &#123;            mostRight.right = <span class="hljs-keyword">null</span>;         &#125;      &#125;      System.out.print(cur.value + <span class="hljs-string">&quot; &quot;</span>);      cur = cur.right;   &#125;   System.out.println();&#125;</code></pre><h3 id="后序"><a href="#后序" class="headerlink" title="后序"></a>后序</h3><p>打印时机放到能回到自己两次，且第二次回到自己的时候；</p><p>打左树的右边界，逆序打印，最后打印自己的最右边界；</p><p>用 <strong>反转链表</strong> 打印 <strong>逆序右边界</strong> </p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210323094725.png" alt="图解"></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">morrisPos</span><span class="hljs-params">(Node head)</span> </span>&#123;   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span>;   &#125;   Node cur = head;   Node mostRight = <span class="hljs-keyword">null</span>;   <span class="hljs-keyword">while</span> (cur != <span class="hljs-keyword">null</span>) &#123;      mostRight = cur.left;      <span class="hljs-keyword">if</span> (mostRight != <span class="hljs-keyword">null</span>) &#123;         <span class="hljs-keyword">while</span> (mostRight.right != <span class="hljs-keyword">null</span> &amp;&amp; mostRight.right != cur) &#123;            mostRight = mostRight.right;         &#125;         <span class="hljs-keyword">if</span> (mostRight.right == <span class="hljs-keyword">null</span>) &#123;            mostRight.right = cur;            cur = cur.left;            <span class="hljs-keyword">continue</span>;         &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// 第二次回到自己 打印左树右边界</span>            mostRight.right = <span class="hljs-keyword">null</span>;            printEdge(cur.left);         &#125;      &#125;      cur = cur.right;   &#125;   <span class="hljs-comment">// 最后打印整棵树的右边界</span>   printEdge(head);   System.out.println();&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printEdge</span><span class="hljs-params">(Node head)</span> </span>&#123;   Node tail = reverseEdge(head);   Node cur = tail;   <span class="hljs-keyword">while</span> (cur != <span class="hljs-keyword">null</span>) &#123;      System.out.print(cur.value + <span class="hljs-string">&quot; &quot;</span>);      cur = cur.right;   &#125;   reverseEdge(tail);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">reverseEdge</span><span class="hljs-params">(Node from)</span> </span>&#123;   Node pre = <span class="hljs-keyword">null</span>;   Node next = <span class="hljs-keyword">null</span>;   <span class="hljs-keyword">while</span> (from != <span class="hljs-keyword">null</span>) &#123;      next = from.right;      from.right = pre;      pre = from;      from = next;   &#125;   <span class="hljs-keyword">return</span> pre;&#125;</code></pre><h2 id="isBST"><a href="#isBST" class="headerlink" title="isBST"></a>isBST</h2><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210323095917.png" alt="isBST"></p><p>把打印过程变成 <strong>比较过程</strong> ；</p><h2 id="最小高度"><a href="#最小高度" class="headerlink" title="最小高度"></a>最小高度</h2><p>给定一棵二叉树的头节点head</p><p>求以head为头的树中，最小深度是多少？</p><h3 id="二叉树递归套路"><a href="#二叉树递归套路" class="headerlink" title="二叉树递归套路"></a>二叉树递归套路</h3><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minHeight1</span><span class="hljs-params">(Node head)</span> </span>&#123;   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;   &#125;   <span class="hljs-keyword">return</span> p(head);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">p</span><span class="hljs-params">(Node x)</span> </span>&#123;   <span class="hljs-keyword">if</span> (x.left == <span class="hljs-keyword">null</span> &amp;&amp; x.right == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;   &#125;   <span class="hljs-comment">// 左右子树起码有一个不为空</span>   <span class="hljs-keyword">int</span> leftH = Integer.MAX_VALUE;   <span class="hljs-keyword">if</span> (x.left != <span class="hljs-keyword">null</span>) &#123;      leftH = p(x.left);   &#125;   <span class="hljs-keyword">int</span> rightH = Integer.MAX_VALUE;   <span class="hljs-keyword">if</span> (x.right != <span class="hljs-keyword">null</span>) &#123;      rightH = p(x.right);   &#125;   <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + Math.min(leftH, rightH);&#125;</code></pre><h3 id="morris遍历求解"><a href="#morris遍历求解" class="headerlink" title="morris遍历求解"></a>morris遍历求解</h3><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minHeight2</span><span class="hljs-params">(Node head)</span> </span>&#123;   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;   &#125;   Node cur = head;   Node mostRight = <span class="hljs-keyword">null</span>;   <span class="hljs-keyword">int</span> curLevel = <span class="hljs-number">0</span>;   <span class="hljs-keyword">int</span> minHeight = Integer.MAX_VALUE;   <span class="hljs-keyword">while</span> (cur != <span class="hljs-keyword">null</span>) &#123;      mostRight = cur.left;      <span class="hljs-keyword">if</span> (mostRight != <span class="hljs-keyword">null</span>) &#123;         <span class="hljs-comment">// 左树上右边界点的个数</span>         <span class="hljs-keyword">int</span> leftHeight = <span class="hljs-number">1</span>;         <span class="hljs-keyword">while</span> (mostRight.right != <span class="hljs-keyword">null</span> &amp;&amp; mostRight.right != cur) &#123;            leftHeight++;            mostRight = mostRight.right;         &#125;         <span class="hljs-keyword">if</span> (mostRight.right == <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// 第一次到达</span>            curLevel++;            mostRight.right = cur;            cur = cur.left;            <span class="hljs-keyword">continue</span>;         &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 第二次到达</span>            <span class="hljs-keyword">if</span> (mostRight.left == <span class="hljs-keyword">null</span>) &#123;               <span class="hljs-comment">// 说明是叶节点，要更新curlevel，跳到上面去了</span>               minHeight = Math.min(minHeight, curLevel);            &#125;            curLevel -= leftHeight;            mostRight.right = <span class="hljs-keyword">null</span>;         &#125;      &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 只有一次到达</span>         curLevel++;      &#125;      cur = cur.right;   &#125;   <span class="hljs-keyword">int</span> finalRight = <span class="hljs-number">1</span>;   cur = head;   <span class="hljs-keyword">while</span> (cur.right != <span class="hljs-keyword">null</span>) &#123;      finalRight++;      cur = cur.right;   &#125;   <span class="hljs-comment">// 单独跑整棵树的最右节点</span>   <span class="hljs-keyword">if</span> (cur.left == <span class="hljs-keyword">null</span> &amp;&amp; cur.right == <span class="hljs-keyword">null</span>) &#123;      minHeight = Math.min(minHeight, finalRight);   &#125;   <span class="hljs-keyword">return</span> minHeight;&#125;</code></pre><h1 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h1><blockquote><p>定义</p></blockquote><ol><li><p>一种支持范围整体修改和范围整体查询的数据结构</p></li><li><p>解决的问题范畴：<br>大范围信息可以只由左、右两侧信息加工出，而不必遍历左右两个子范围的具体状况</p></li></ol><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210328164125.png" alt="线段树"></p><p>线段树的指标三个方法的性能达到log(n)的水平</p><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>给定一个数组arr，用户希望你实现如下三个方法<br>1）void add(int L, int R, int V) :  让数组arr[L…R]上每个数都加上V<br>2）void update(int L, int R, int V) :  让数组arr[L…R]上每个数都变成V<br>3）int sum(int L, int R) :让返回arr[L…R]这个范围整体的累加和<br>怎么让这三个方法，时间复杂度都是O(logN)</p><p class="note note-danger">注意！以下所有数组的规则规定下标从 1 开始！</p><h2 id="build流程"><a href="#build流程" class="headerlink" title="build流程"></a>build流程</h2><p>假设有一种“格子”可以存储位置上的信息</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210328165141.png" alt="存取"></p><p>二分存储信息</p><p>满二叉树的情况下需要格子 2*8-1，最下面8，上面8-1</p><p>现在让这棵树一定变成 <strong>满二叉树</strong> ，往上构建</p><p>假设N个数， <strong>4N</strong> 的空间，一定足够。</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210328171024.png" alt="数组替代"></p><p>i位置左孩子2i，右孩子2i+1</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210328172630.png" alt="build"></p><pre><code class="hljs java"><span class="hljs-comment">// 在初始化阶段，先把sum数组，填好</span><span class="hljs-comment">// 在arr[l~r]范围上，去build，1~N，</span><span class="hljs-comment">// rt :  这个范围在sum中的下标</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> rt)</span> </span>&#123;   <span class="hljs-keyword">if</span> (l == r) &#123;      sum[rt] = arr[l];      <span class="hljs-keyword">return</span>;   &#125;   <span class="hljs-keyword">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;   <span class="hljs-comment">// rt * 2 下标从1开始才可以位运算</span>   build(l, mid, rt &lt;&lt; <span class="hljs-number">1</span>);   <span class="hljs-comment">// rt * 2 + 1</span>   build(mid + <span class="hljs-number">1</span>, r, rt &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>);   pushUp(rt);&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pushUp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rt)</span> </span>&#123; sum[rt] = sum[rt &lt;&lt; <span class="hljs-number">1</span>] + sum[rt &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>];&#125;</code></pre><h2 id="懒更新机制"><a href="#懒更新机制" class="headerlink" title="懒更新机制"></a>懒更新机制</h2><p>不把任务彻底下发到底</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210328180943.png" alt="懒加载"></p><p>就会把1～4加入lazy</p><p>5~8没有包含1～6，5～6放入lazy</p><blockquote><p>为什么要设置lazy？</p></blockquote><p>假设一开始设置要让1～256加7</p><p>下个任务设置要1~100 加3</p><p>lazy发现无法覆盖，下发任务至1～128和129～256</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210328193121.png" alt="下发"></p><h2 id="push-down操作"><a href="#push-down操作" class="headerlink" title="push down操作"></a>push down操作</h2><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210328194721.png" alt="流程"></p><p>前面已经见过两部，左边lazy3，右边lazy4，现在新任务为1 - 1000，加5</p><p>直接懒住</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210328194852.png" alt="懒更新"></p><p>当第四个任务 1 - 1000 加1时：</p><p>1～1024已经懒住一个5，会把之前 <strong>懒住的5往下发</strong> ，左边子树懒8，右边懒9</p><p>1-1024 lazy清空 变为0 后再懒1</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210328200909.png" alt="当第四个任务到来时"></p><p>1-4懒不住</p><p>把lazy发下去，1-2的lazy变成7更新sum，3-4的lazy变成9更新sum</p><p>lazy变成0</p><h2 id="update"><a href="#update" class="headerlink" title="update"></a>update</h2><p>update后应该更新lazy为0</p><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SegmentTree</span> </span>&#123;   <span class="hljs-comment">// arr[]为原序列的信息从0开始，但在arr里是从1开始的</span>   <span class="hljs-comment">// sum[]模拟线段树维护区间和</span>   <span class="hljs-comment">// lazy[]为累加懒惰标记</span>   <span class="hljs-comment">// change[]为更新的值</span>   <span class="hljs-comment">// update[]为更新慵懒标记</span>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> MAXN;   <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] arr;   <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] sum;   <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] lazy;   <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] change;   <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span>[] update;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SegmentTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] origin)</span> </span>&#123;      MAXN = origin.length + <span class="hljs-number">1</span>;      arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[MAXN]; <span class="hljs-comment">// arr[0] 不用  从1开始使用</span>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; MAXN; i++) &#123;         arr[i] = origin[i - <span class="hljs-number">1</span>];      &#125;      sum = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[MAXN &lt;&lt; <span class="hljs-number">2</span>]; <span class="hljs-comment">// 用来支持脑补概念中，某一个范围的累加和信息</span>      lazy = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[MAXN &lt;&lt; <span class="hljs-number">2</span>]; <span class="hljs-comment">// 用来支持脑补概念中，某一个范围沒有往下傳遞的纍加任務</span>      change = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[MAXN &lt;&lt; <span class="hljs-number">2</span>]; <span class="hljs-comment">// 用来支持脑补概念中，某一个范围有没有更新操作的任务</span>      update = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[MAXN &lt;&lt; <span class="hljs-number">2</span>]; <span class="hljs-comment">// 用来支持脑补概念中，某一个范围更新任务，更新成了什么</span>   &#125;   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pushUp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rt)</span> </span>&#123;      sum[rt] = sum[rt &lt;&lt; <span class="hljs-number">1</span>] + sum[rt &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>];   &#125;   <span class="hljs-comment">// 懒更新和懒增加的分发策略</span>   <span class="hljs-comment">// ln表示左子树元素结点个数，rn表示右子树结点个数</span>   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pushDown</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rt, <span class="hljs-keyword">int</span> ln, <span class="hljs-keyword">int</span> rn)</span> </span>&#123;      <span class="hljs-keyword">if</span> (update[rt]) &#123;         update[rt &lt;&lt; <span class="hljs-number">1</span>] = <span class="hljs-keyword">true</span>;         update[rt &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>] = <span class="hljs-keyword">true</span>;         change[rt &lt;&lt; <span class="hljs-number">1</span>] = change[rt];         change[rt &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>] = change[rt];         lazy[rt &lt;&lt; <span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;         lazy[rt &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;         sum[rt &lt;&lt; <span class="hljs-number">1</span>] = change[rt] * ln;         sum[rt &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>] = change[rt] * rn;         update[rt] = <span class="hljs-keyword">false</span>;      &#125;      <span class="hljs-keyword">if</span> (lazy[rt] != <span class="hljs-number">0</span>) &#123;         lazy[rt &lt;&lt; <span class="hljs-number">1</span>] += lazy[rt];         sum[rt &lt;&lt; <span class="hljs-number">1</span>] += lazy[rt] * ln;         lazy[rt &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>] += lazy[rt];         sum[rt &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>] += lazy[rt] * rn;         lazy[rt] = <span class="hljs-number">0</span>;      &#125;   &#125;   <span class="hljs-comment">// 在初始化阶段，先把sum数组，填好</span>   <span class="hljs-comment">// 在arr[l~r]范围上，去build，1~N，</span>   <span class="hljs-comment">// rt :  这个范围在sum中的下标</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> rt)</span> </span>&#123;      <span class="hljs-keyword">if</span> (l == r) &#123;         sum[rt] = arr[l];         <span class="hljs-keyword">return</span>;      &#125;      <span class="hljs-keyword">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;      <span class="hljs-comment">// rt * 2 下标从1开始才可以位运算</span>      build(l, mid, rt &lt;&lt; <span class="hljs-number">1</span>);      <span class="hljs-comment">// rt * 2 + 1</span>      build(mid + <span class="hljs-number">1</span>, r, rt &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>);      pushUp(rt);   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R, <span class="hljs-keyword">int</span> C, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> rt)</span> </span>&#123;      <span class="hljs-keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) &#123;         update[rt] = <span class="hljs-keyword">true</span>;         change[rt] = C;         sum[rt] = C * (r - l + <span class="hljs-number">1</span>);         lazy[rt] = <span class="hljs-number">0</span>;         <span class="hljs-keyword">return</span>;      &#125;      <span class="hljs-comment">// 当前任务躲不掉，无法懒更新，要往下发</span>      <span class="hljs-keyword">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;      pushDown(rt, mid - l + <span class="hljs-number">1</span>, r - mid);      <span class="hljs-keyword">if</span> (L &lt;= mid) &#123;         update(L, R, C, l, mid, rt &lt;&lt; <span class="hljs-number">1</span>);      &#125;      <span class="hljs-keyword">if</span> (R &gt; mid) &#123;         update(L, R, C, mid + <span class="hljs-number">1</span>, r, rt &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>);      &#125;      pushUp(rt);   &#125;   <span class="hljs-comment">// L..R -&gt; 任务范围 ,所有的值累加上C  1～1000</span>   <span class="hljs-comment">// l,r -&gt; 表达的范围  1～1024</span>   <span class="hljs-comment">// rt  去哪找l，r范围上的信息</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R, <span class="hljs-keyword">int</span> C,</span></span><span class="hljs-function"><span class="hljs-params">         <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, </span></span><span class="hljs-function"><span class="hljs-params">         <span class="hljs-keyword">int</span> rt)</span> </span>&#123;      <span class="hljs-comment">// 任务的范围彻底覆盖了，当前表达的范围</span>      <span class="hljs-keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) &#123;         sum[rt] += C * (r - l + <span class="hljs-number">1</span>);         lazy[rt] += C;         <span class="hljs-keyword">return</span>;      &#125;      <span class="hljs-comment">// 要把任务往下发</span>      <span class="hljs-comment">// 任务  L, R  没有把本身表达范围 l,r 彻底包住</span>      <span class="hljs-keyword">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;      <span class="hljs-comment">// 下发之前的lazy add任务</span>      pushDown(rt, mid - l + <span class="hljs-number">1</span>, r - mid);      <span class="hljs-comment">// 左孩子是否需要接到任务</span>      <span class="hljs-keyword">if</span> (L &lt;= mid) &#123;         add(L, R, C, l, mid, rt &lt;&lt; <span class="hljs-number">1</span>);      &#125;      <span class="hljs-comment">// 右孩子是否需要接到任务</span>      <span class="hljs-keyword">if</span> (R &gt; mid) &#123;         add(L, R, C, mid + <span class="hljs-number">1</span>, r, rt &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>);      &#125;      <span class="hljs-comment">// 左右孩子做完任务后，我更新我的sum信息</span>      pushUp(rt);   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> rt)</span> </span>&#123;      <span class="hljs-keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) &#123;         <span class="hljs-keyword">return</span> sum[rt];      &#125;      <span class="hljs-keyword">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;      pushDown(rt, mid - l + <span class="hljs-number">1</span>, r - mid);      <span class="hljs-keyword">long</span> ans = <span class="hljs-number">0</span>;      <span class="hljs-keyword">if</span> (L &lt;= mid) &#123;         ans += query(L, R, l, mid, rt &lt;&lt; <span class="hljs-number">1</span>);      &#125;      <span class="hljs-keyword">if</span> (R &gt; mid) &#123;         ans += query(L, R, mid + <span class="hljs-number">1</span>, r, rt &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>);      &#125;      <span class="hljs-keyword">return</span> ans;   &#125;&#125;</code></pre><h2 id="线段树应用"><a href="#线段树应用" class="headerlink" title="线段树应用"></a>线段树应用</h2><p>想象一下标准的俄罗斯方块游戏，X轴是积木最终下落到底的轴线<br>下面是这个游戏的简化版：<br>1）只会下落正方形积木<br>2）[a,b] -&gt; 代表一个边长为b的正方形积木，积木左边缘沿着X = a这条线从上方掉落<br>3）认为整个X轴都可能接住积木，也就是说简化版游戏是没有整体的左右边界的<br>4）没有整体的左右边界，所以简化版游戏不会消除积木，因为不会有哪一层被填满。</p><p>给定一个N*2的二维数组matrix，可以代表N个积木依次掉落，<br>返回每一次掉落之后的最大高度</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210329045829.png" alt="解"></p><p>返回的是“结果数组”，每一步后的结果都要储存</p><p>假设[3,4 ]应该是3到6范围高度增加，不能增加7，下一个如果沿着7的边界，会被挡住</p><p>线段树的信息代表高度的信息</p><p>来了[ L, H]要看[L, L + H - 1]的高度是多少</p><p>只有update和query操作</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SegmentTree</span> </span>&#123;   <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] max;   <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] change;   <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span>[] update;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SegmentTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span> size)</span> </span>&#123;      <span class="hljs-keyword">int</span> N = size + <span class="hljs-number">1</span>;      max = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[N &lt;&lt; <span class="hljs-number">2</span>];      change = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[N &lt;&lt; <span class="hljs-number">2</span>];      update = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[N &lt;&lt; <span class="hljs-number">2</span>];   &#125;   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pushUp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rt)</span> </span>&#123;      max[rt] = Math.max(max[rt &lt;&lt; <span class="hljs-number">1</span>], max[rt &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>]);   &#125;   <span class="hljs-comment">// ln表示左子树元素结点个数，rn表示右子树结点个数</span>   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pushDown</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rt, <span class="hljs-keyword">int</span> ln, <span class="hljs-keyword">int</span> rn)</span> </span>&#123;      <span class="hljs-keyword">if</span> (update[rt]) &#123;         update[rt &lt;&lt; <span class="hljs-number">1</span>] = <span class="hljs-keyword">true</span>;         update[rt &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>] = <span class="hljs-keyword">true</span>;         change[rt &lt;&lt; <span class="hljs-number">1</span>] = change[rt];         change[rt &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>] = change[rt];         max[rt &lt;&lt; <span class="hljs-number">1</span>] = change[rt];         max[rt &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>] = change[rt];         update[rt] = <span class="hljs-keyword">false</span>;      &#125;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R, <span class="hljs-keyword">int</span> C, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> rt)</span> </span>&#123;      <span class="hljs-keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) &#123;         update[rt] = <span class="hljs-keyword">true</span>;         change[rt] = C;         max[rt] = C;         <span class="hljs-keyword">return</span>;      &#125;      <span class="hljs-keyword">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;      pushDown(rt, mid - l + <span class="hljs-number">1</span>, r - mid);      <span class="hljs-keyword">if</span> (L &lt;= mid) &#123;         update(L, R, C, l, mid, rt &lt;&lt; <span class="hljs-number">1</span>);      &#125;      <span class="hljs-keyword">if</span> (R &gt; mid) &#123;         update(L, R, C, mid + <span class="hljs-number">1</span>, r, rt &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>);      &#125;      pushUp(rt);   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> rt)</span> </span>&#123;      <span class="hljs-keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) &#123;         <span class="hljs-keyword">return</span> max[rt];      &#125;      <span class="hljs-keyword">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;      pushDown(rt, mid - l + <span class="hljs-number">1</span>, r - mid);      <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;      <span class="hljs-keyword">int</span> right = <span class="hljs-number">0</span>;      <span class="hljs-keyword">if</span> (L &lt;= mid) &#123;         left = query(L, R, l, mid, rt &lt;&lt; <span class="hljs-number">1</span>);      &#125;      <span class="hljs-keyword">if</span> (R &gt; mid) &#123;         right = query(L, R, mid + <span class="hljs-number">1</span>, r, rt &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>);      &#125;      <span class="hljs-keyword">return</span> Math.max(left, right);   &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> HashMap&lt;Integer, Integer&gt; <span class="hljs-title">index</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] positions)</span> </span>&#123;   TreeSet&lt;Integer&gt; pos = <span class="hljs-keyword">new</span> TreeSet&lt;&gt;();   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] arr : positions) &#123;      pos.add(arr[<span class="hljs-number">0</span>]);      pos.add(arr[<span class="hljs-number">0</span>] + arr[<span class="hljs-number">1</span>] - <span class="hljs-number">1</span>);   &#125;   HashMap&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();   <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;   <span class="hljs-keyword">for</span> (Integer index : pos) &#123;      <span class="hljs-comment">// 编号排序 从1开始</span>      map.put(index, ++count);   &#125;   <span class="hljs-keyword">return</span> map;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">fallingSquares</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] positions)</span> </span>&#123;   <span class="hljs-comment">// 位置离散化 把所有的块左右两个边界都有哪些值</span>   <span class="hljs-comment">// [100, 7] 认为是[100, 106]为边界</span>   HashMap&lt;Integer, Integer&gt; map = index(positions);   <span class="hljs-keyword">int</span> N = map.size();   <span class="hljs-comment">// 不拿x值修改，拿编好号排好序的修改</span>   SegmentTree segmentTree = <span class="hljs-keyword">new</span> SegmentTree(N);   <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;   List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] arr : positions) &#123;      <span class="hljs-keyword">int</span> L = map.get(arr[<span class="hljs-number">0</span>]);      <span class="hljs-keyword">int</span> R = map.get(arr[<span class="hljs-number">0</span>] + arr[<span class="hljs-number">1</span>] - <span class="hljs-number">1</span>);      <span class="hljs-keyword">int</span> height = segmentTree.query(L, R, <span class="hljs-number">1</span>, N, <span class="hljs-number">1</span>) + arr[<span class="hljs-number">1</span>];      max = Math.max(max, height);      res.add(max);      segmentTree.update(L, R, height, <span class="hljs-number">1</span>, N, <span class="hljs-number">1</span>);   &#125;   <span class="hljs-keyword">return</span> res;&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210329084729.png" alt="第一次"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210329084800.png" alt="第二次"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210329084830.png" alt="第三次"></p><h2 id="线段重合问题"><a href="#线段重合问题" class="headerlink" title="线段重合问题"></a>线段重合问题</h2><p>给你一段线段，求重合线段；</p><p>可以用线段树做，和上面的俄罗斯方块类似，左右边界离散化，遇到线段加1；</p><p>更好实现的方法：</p><p> <strong>开始位置排个序</strong> </p><p>线段开始位置越早越先处理，准备一个小根堆，</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210329090901.png" alt="开始"></p><p>把10放进去：堆里面一个数，</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210329091033.png" alt="第二回"></p><p>两个数；</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210329091131.png" alt="第n回合"></p><blockquote><p>小根堆的意义</p></blockquote><p>之前还有哪些线段会对此时的线段产生影响，这些线段的结尾都在这个小根堆里面；</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210329091740.png"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210329093040.png" alt="code"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210329093106.png" alt="code"></p><h2 id="线段重合拓展"><a href="#线段重合拓展" class="headerlink" title="线段重合拓展"></a>线段重合拓展</h2><p>[1, 3, 2, 1]代表一个矩阵，矩形左上角和右下角</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210329093511.png" alt="矩阵"></p><p>给很多个矩阵，N * 4</p><p>求哪个区域盖的矩形最多，返回数量；</p><blockquote><p>怎么遍历一个矩形？</p></blockquote><p>下底最靠下，最先遍历</p><p>遍历时，假设底是无限延伸的，如果固定一个矩形，下一个矩形的上边都小于底，则不可能覆盖</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210329094432.png" alt="无限延伸"></p><p>再根据左边界右边界抽出来认为是一个线段，就变成了线段重合问题；</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210329094710.png" alt="code"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210329095013.png" alt="code2"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210329095116.png" alt="code3"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210329100521.png" alt="code"></p><blockquote><p> 为什么list要用treeset表示？</p></blockquote><p>要转换为线段重合问题，莫不如修改为set排序好</p><p>while循环是优化，如果底边一样，一票求一下</p><h1 id="AC自动机"><a href="#AC自动机" class="headerlink" title="AC自动机"></a>AC自动机</h1><p>解决在一个大字符串中，找到 <strong>多个候选字符串</strong> 的问题</p><h2 id="AC自动机算法核心"><a href="#AC自动机算法核心" class="headerlink" title="AC自动机算法核心"></a>AC自动机算法核心</h2><p>1）把所有匹配串生成一棵前缀树</p><p>2）前缀树节点增加 <strong>fail指针</strong> ，每一个结点都有</p><p>3）fail指针的含义：如果必须以当前字符结尾，当前形成的路径是str，剩下哪一个字符串的前缀和str的后缀，拥有最大的匹配长度。fail指针就指向那个字符串的最后一个字符所对应的节点。</p><p>头结点fail指针人为规定 <strong>指向空</strong> ，第一级孩子人为规定 <strong>指向头</strong> ；</p><p>加fail指针的方式是前缀树建立好后，再做一个fail指针设定过程（宽度优先遍历）</p><p>再接下来的 fail指针，假如来到X结点，设置孩子的指针，假设通过b到达孩子，自己的fail指针指向甲，如果甲通过b有其他的路，则X的孩子指向这里；</p><p>如果甲没有b的路，找甲的fail指针….直到有b的路，如果都没有，指回头</p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210405004906.png" style="zoom:50%;" /><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210405005439.png" style="zoom:50%;" /><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210405005039.png"></p><p>​    </p><blockquote><p>意义</p></blockquote><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210405010227.png"></p><p>Axctft可以串到xct，f可以串到xctf</p><p>Axctf和xctxxc，t串到xctxxc的t</p><p>其实是 <strong>动态规划</strong> ；</p><h2 id="找寻过程"><a href="#找寻过程" class="headerlink" title="找寻过程"></a>找寻过程</h2><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210405012406.png"></p><p>能到达的点描黑</p><p>每到一个点顺着fail指针收集黑</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210405013416.png"></p><p>收集到了的黑改成白色，收集只是fail指针转一圈，不是到达的结点换位置。</p><h2 id="code-1"><a href="#code-1" class="headerlink" title="code"></a>code</h2><pre><code class="hljs java"><span class="hljs-comment">// 前缀树的节点</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;   <span class="hljs-comment">// 如果一个node，end为空，不是结尾</span>   <span class="hljs-comment">// 如果end不为空，表示这个点是某个字符串的结尾，end的值就是这个字符串</span>   <span class="hljs-keyword">public</span> String end;   <span class="hljs-comment">// 只有在上面的end变量不为空的时候，endUse才有意义</span>   <span class="hljs-comment">// 表示，这个字符串之前有没有加入过答案</span>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> endUse;   <span class="hljs-keyword">public</span> Node fail;   <span class="hljs-keyword">public</span> Node[] nexts;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">()</span> </span>&#123;      endUse = <span class="hljs-keyword">false</span>;      end = <span class="hljs-keyword">null</span>;      fail = <span class="hljs-keyword">null</span>;      nexts = <span class="hljs-keyword">new</span> Node[<span class="hljs-number">26</span>];   &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ACAutomation</span> </span>&#123;   <span class="hljs-keyword">private</span> Node root;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ACAutomation</span><span class="hljs-params">()</span> </span>&#123;      root = <span class="hljs-keyword">new</span> Node();   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(String s)</span> </span>&#123;      <span class="hljs-keyword">char</span>[] str = s.toCharArray();      Node cur = root;      <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; str.length; i++) &#123;         index = str[i] - <span class="hljs-string">&#x27;a&#x27;</span>;         <span class="hljs-keyword">if</span> (cur.nexts[index] == <span class="hljs-keyword">null</span>) &#123;            Node next = <span class="hljs-keyword">new</span> Node();            cur.nexts[index] = next;         &#125;         cur = cur.nexts[index];      &#125;      cur.end = s;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">()</span> </span>&#123;      Queue&lt;Node&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();      queue.add(root);      Node cur = <span class="hljs-keyword">null</span>;      Node cfail = <span class="hljs-keyword">null</span>;      <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;         <span class="hljs-comment">// 当前节点弹出，</span>         <span class="hljs-comment">// 当前节点的所有后代加入到队列里去，</span>         <span class="hljs-comment">// 当前节点给它的子去设置fail指针</span>         <span class="hljs-comment">// cur -&gt; 父亲</span>         cur = queue.poll();         <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++) &#123; <span class="hljs-comment">// 所有的路</span>            <span class="hljs-keyword">if</span> (cur.nexts[i] != <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// 找到所有有效的路</span>               cur.nexts[i].fail = root; <span class="hljs-comment">//</span>               cfail = cur.fail;               <span class="hljs-keyword">while</span> (cfail != <span class="hljs-keyword">null</span>) &#123;                  <span class="hljs-keyword">if</span> (cfail.nexts[i] != <span class="hljs-keyword">null</span>) &#123;                     cur.nexts[i].fail = cfail.nexts[i];                     <span class="hljs-keyword">break</span>;                  &#125;                  cfail = cfail.fail;               &#125;               queue.add(cur.nexts[i]);            &#125;         &#125;      &#125;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">containWords</span><span class="hljs-params">(String content)</span> </span>&#123;      <span class="hljs-keyword">char</span>[] str = content.toCharArray();      Node cur = root;      Node follow = <span class="hljs-keyword">null</span>;      <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;      List&lt;String&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; str.length; i++) &#123;         index = str[i] - <span class="hljs-string">&#x27;a&#x27;</span>; <span class="hljs-comment">// 路</span>         <span class="hljs-comment">// 如果当前字符在这条路上没配出来，就随着fail方向走向下条路径</span>         <span class="hljs-comment">// 如果当前结点没有path的路，通过fail指针跳到别的路上</span>         <span class="hljs-keyword">while</span> (cur.nexts[index] == <span class="hljs-keyword">null</span> &amp;&amp; cur != root) &#123;            cur = cur.fail;         &#125;         <span class="hljs-comment">// 1) 现在来到的路径，是可以继续匹配的</span>         <span class="hljs-comment">// 2) 现在来到的节点，就是前缀树的根节点 来到头了</span>         cur = cur.nexts[index] != <span class="hljs-keyword">null</span> ? cur.nexts[index] : root;         follow = cur;         <span class="hljs-keyword">while</span> (follow != root) &#123;            <span class="hljs-keyword">if</span>(follow.endUse) &#123;               <span class="hljs-keyword">break</span>;            &#125;            <span class="hljs-comment">// 不同的需求，在这一段之间修改</span>            <span class="hljs-keyword">if</span> (follow.end != <span class="hljs-keyword">null</span>) &#123;               ans.add(follow.end);               follow.endUse = <span class="hljs-keyword">true</span>;            &#125;            <span class="hljs-comment">// 不同的需求，在这一段之间修改</span>            follow = follow.fail;         &#125;      &#125;      <span class="hljs-keyword">return</span> ans;   &#125;&#125;</code></pre><h1 id="打表"><a href="#打表" class="headerlink" title="打表"></a>打表</h1><p>1）问题如果返回值不太多，可以用hardcode的方式列出，作为程序的一部分</p><p>2）一个大问题解决时底层频繁使用规模不大的小问题的解，如果小问题的返回值满足条件1），可以把小问题的解列成一张表，作为程序的一部分</p><p>3）打表找规律</p><p>打表是做出一张表，独立于程序之外，参数改变一般不会改变表的数据；</p><h2 id="打表规律"><a href="#打表规律" class="headerlink" title="打表规律"></a>打表规律</h2><p>1）某个面试题，输入参数类型简单，并且只有一个实际参数</p><p>2）要求的返回值类型也简单，并且只有一个</p><p>3）用暴力方法，把输入参数对应的返回值，打印出来看看，进而优化code</p><h2 id="题目1"><a href="#题目1" class="headerlink" title="题目1"></a>题目1</h2><p>小虎去买苹果，商店只提供两种类型的塑料袋，每种类型都有任意数量。<br>1）能装下6个苹果的袋子<br>2）能装下8个苹果的袋子<br>小虎可以自由使用两种袋子来装苹果，但是小虎有强迫症，他要求自己使用的袋子数量必须最少，且使用的每个袋子必须装满。<br>给定一个正整数N，返回至少使用多少袋子。如果N无法让使用的每个袋子必须装满，返回-1</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210329181015.png" alt="正常解题思路"></p><p>解题加速：</p><p>8 6最大公倍数为24</p><p>当剩下的大于24个时，又走循环</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210329181403.png" alt="加速"></p><p>剩余31个的问题等于剩余7个</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minBags</span><span class="hljs-params">(<span class="hljs-keyword">int</span> apple)</span> </span>&#123;   <span class="hljs-keyword">if</span> (apple &lt; <span class="hljs-number">0</span>) &#123;      <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;   &#125;   <span class="hljs-keyword">int</span> bag6 = -<span class="hljs-number">1</span>;   <span class="hljs-keyword">int</span> bag8 = apple / <span class="hljs-number">8</span>;   <span class="hljs-keyword">int</span> rest = apple - <span class="hljs-number">8</span> * bag8;   <span class="hljs-keyword">while</span> (bag8 &gt;= <span class="hljs-number">0</span> &amp;&amp; rest &lt; <span class="hljs-number">24</span>) &#123;      <span class="hljs-keyword">int</span> restUse6 = minBagBase6(rest);      <span class="hljs-keyword">if</span> (restUse6 != -<span class="hljs-number">1</span>) &#123;         bag6 = restUse6;         <span class="hljs-keyword">break</span>;      &#125;      rest = apple - <span class="hljs-number">8</span> * (--bag8);   &#125;   <span class="hljs-keyword">return</span> bag6 == -<span class="hljs-number">1</span> ? -<span class="hljs-number">1</span> : bag6 + bag8;&#125;<span class="hljs-comment">// 如果剩余苹果rest可以被装6个苹果的袋子搞定，返回袋子数量</span><span class="hljs-comment">// 不能搞定返回-1</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minBagBase6</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rest)</span> </span>&#123;   <span class="hljs-keyword">return</span> rest % <span class="hljs-number">6</span> == <span class="hljs-number">0</span> ? (rest / <span class="hljs-number">6</span>) : -<span class="hljs-number">1</span>;&#125;</code></pre><h3 id="打表解题"><a href="#打表解题" class="headerlink" title="打表解题"></a>打表解题</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210329181632.png" alt="规律"></p><p>18开始奇数-1，偶数3</p><p>26开始奇数-1，偶数4</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minBagAwesome</span><span class="hljs-params">(<span class="hljs-keyword">int</span> apple)</span> </span>&#123;   <span class="hljs-keyword">if</span> ((apple &amp; <span class="hljs-number">1</span>) != <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 如果是奇数，返回-1</span>      <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;   &#125;   <span class="hljs-keyword">if</span> (apple &lt; <span class="hljs-number">18</span>) &#123;      <span class="hljs-keyword">return</span> apple == <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : (apple == <span class="hljs-number">6</span> || apple == <span class="hljs-number">8</span>) ? <span class="hljs-number">1</span>            : (apple == <span class="hljs-number">12</span> || apple == <span class="hljs-number">14</span> || apple == <span class="hljs-number">16</span>) ? <span class="hljs-number">2</span> : -<span class="hljs-number">1</span>;   &#125;   <span class="hljs-keyword">return</span> (apple - <span class="hljs-number">18</span>) / <span class="hljs-number">8</span> + <span class="hljs-number">3</span>;&#125;</code></pre><h2 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h2><p>给定一个正整数N，表示有N份青草统一堆放在仓库里<br>有一只牛和一只羊，牛先吃，羊后吃，它俩轮流吃草<br>不管是牛还是羊，每一轮能吃的草量必须是：<br>1，4，16，64…(4的某次方)<br>谁最先把草吃完，谁获胜<br>假设牛和羊都绝顶聪明，都想赢，都会做出理性的决定<br>根据唯一的参数N，返回谁会赢</p><pre><code class="hljs java"><span class="hljs-comment">// n份青草放在一堆</span><span class="hljs-comment">// 先手后手都绝顶聪明</span><span class="hljs-comment">// string &quot;先手&quot; &quot;后手&quot;</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">winner1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;   <span class="hljs-comment">// 0  1  2  3 4</span>   <span class="hljs-comment">// 后 先 后 先 先</span>   <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">5</span>) &#123; <span class="hljs-comment">// base case</span>      <span class="hljs-keyword">return</span> (n == <span class="hljs-number">0</span> || n == <span class="hljs-number">2</span>) ? <span class="hljs-string">&quot;后手&quot;</span> : <span class="hljs-string">&quot;先手&quot;</span>;   &#125;   <span class="hljs-comment">// n &gt;= 5 时</span>   <span class="hljs-keyword">int</span> base = <span class="hljs-number">1</span>; <span class="hljs-comment">// 当前先手决定吃的草数</span>   <span class="hljs-comment">// 当前是先手在选</span>   <span class="hljs-keyword">while</span> (base &lt;= n) &#123;      <span class="hljs-comment">// 当前一共n份草，先手吃掉的是base份，n - base 是留给后手的草</span>      <span class="hljs-comment">// 母过程 先手 在子过程里是 后手</span>      <span class="hljs-keyword">if</span> (winner1(n - base).equals(<span class="hljs-string">&quot;后手&quot;</span>)) &#123;         <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;先手&quot;</span>;      &#125;      <span class="hljs-keyword">if</span> (base &gt; n / <span class="hljs-number">4</span>) &#123; <span class="hljs-comment">// 防止base*4之后溢出</span>         <span class="hljs-keyword">break</span>;      &#125;      <span class="hljs-comment">// 第一次用1 下回试试4 下回试试16.....</span>      base *= <span class="hljs-number">4</span>;   &#125;   <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;后手&quot;</span>;&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210329185551.png" alt="分析"></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">winner2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;   <span class="hljs-keyword">if</span> (n % <span class="hljs-number">5</span> == <span class="hljs-number">0</span> || n % <span class="hljs-number">5</span> == <span class="hljs-number">2</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;后手&quot;</span>;   &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;先手&quot;</span>;   &#125;&#125;</code></pre><h2 id="题目三-1"><a href="#题目三-1" class="headerlink" title="题目三"></a>题目三</h2><p>定义一种数：可以表示成若干（数量&gt;1）连续正数和的数<br>比如:<br>5 = 2+3，5就是这样的数<br>12 = 3+4+5，12就是这样的数<br>1不是这样的数，因为要求数量大于1个、连续正数和<br>2 = 1 + 1，2也不是，因为等号右边不是连续正数<br>给定一个参数N，返回是不是可以表示成若干连续正数和的数</p><p>暴力：从1开始加，加到等于一百返回，大于一百从2开始加</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isMSum1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= num; i++) &#123;      <span class="hljs-keyword">int</span> sum = i;      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt;= num; j++) &#123;         <span class="hljs-keyword">if</span> (sum + j &gt; num) &#123;            <span class="hljs-keyword">break</span>;         &#125;         <span class="hljs-keyword">if</span> (sum + j == num) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;         &#125;         sum += j;      &#125;   &#125;   <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;&#125;</code></pre><p>找规律</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210329190329.png" alt="规律"></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isMSum2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;   <span class="hljs-keyword">if</span> (num &lt; <span class="hljs-number">3</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;   &#125;   <span class="hljs-comment">// 是2的次幂</span>   <span class="hljs-comment">// 规律 二进制上只有一个1</span>   <span class="hljs-keyword">return</span> (num &amp; (num - <span class="hljs-number">1</span>)) != <span class="hljs-number">0</span>;&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210329190740.png" alt="判断2的次幂"></p><h1 id="矩阵处理技巧"><a href="#矩阵处理技巧" class="headerlink" title="矩阵处理技巧"></a>矩阵处理技巧</h1><p>核心技巧：找到coding上的宏观调度，不要局限于局部坐标变换</p><h2 id="zigzag打印矩阵"><a href="#zigzag打印矩阵" class="headerlink" title="zigzag打印矩阵"></a>zigzag打印矩阵</h2><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210329192140.png" alt="打印"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210329192611.png" alt="方法"></p><p>A往右走，B往下走，压到一条斜线</p><p>当A不能往右，就往下，B不能往下，就往右</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210329192748.png" alt="结果"></p><p>分别从左下到右上或者右上到左下，依次调换</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printMatrixZigZag</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix)</span> </span>&#123;   <span class="hljs-keyword">int</span> Ar = <span class="hljs-number">0</span>;<span class="hljs-comment">// A的行号</span>   <span class="hljs-keyword">int</span> Ac = <span class="hljs-number">0</span>;<span class="hljs-comment">// A的列号</span>   <span class="hljs-keyword">int</span> Br = <span class="hljs-number">0</span>;<span class="hljs-comment">// B的行号</span>   <span class="hljs-keyword">int</span> Bc = <span class="hljs-number">0</span>;<span class="hljs-comment">// B的列号</span>   <span class="hljs-keyword">int</span> endR = matrix.length - <span class="hljs-number">1</span>;<span class="hljs-comment">// 终止位置行</span>   <span class="hljs-keyword">int</span> endC = matrix[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span>;<span class="hljs-comment">// 终止位置列</span>   <span class="hljs-keyword">boolean</span> fromUp = <span class="hljs-keyword">false</span>;<span class="hljs-comment">// 是不是从右上往左下打印；一开始是从左下往右上</span>   <span class="hljs-keyword">while</span> (Ar != endR + <span class="hljs-number">1</span>) &#123;<span class="hljs-comment">// A还没来到右下角的位置 + 1</span>      <span class="hljs-comment">// 已知斜线两端，方向，即可打印</span>      printLevel(matrix, Ar, Ac, Br, Bc, fromUp);      Ar = Ac == endC ? Ar + <span class="hljs-number">1</span> : Ar;      Ac = Ac == endC ? Ac : Ac + <span class="hljs-number">1</span>;      Bc = Br == endR ? Bc + <span class="hljs-number">1</span> : Bc;      Br = Br == endR ? Br : Br + <span class="hljs-number">1</span>;      fromUp = !fromUp;   &#125;   System.out.println();&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printLevel</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] m, <span class="hljs-keyword">int</span> tR, <span class="hljs-keyword">int</span> tC, <span class="hljs-keyword">int</span> dR, <span class="hljs-keyword">int</span> dC,</span></span><span class="hljs-function"><span class="hljs-params">      <span class="hljs-keyword">boolean</span> f)</span> </span>&#123;   <span class="hljs-keyword">if</span> (f) &#123;      <span class="hljs-keyword">while</span> (tR != dR + <span class="hljs-number">1</span>) &#123;         System.out.print(m[tR++][tC--] + <span class="hljs-string">&quot; &quot;</span>);      &#125;   &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-keyword">while</span> (dR != tR - <span class="hljs-number">1</span>) &#123;         System.out.print(m[dR--][dC++] + <span class="hljs-string">&quot; &quot;</span>);      &#125;   &#125;&#125;</code></pre><h2 id="转圈打印矩阵"><a href="#转圈打印矩阵" class="headerlink" title="转圈打印矩阵"></a>转圈打印矩阵</h2><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210329195422.png" alt="打印"></p><p>第一层结束的位置等于第二层开始的位置</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210329195739.png"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210329200957.png" alt="规定好"></p><p>b++但不碰到d，a++不要碰到c，d–不要碰到b，c–不要碰到a</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">spiralOrderPrint</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix)</span> </span>&#123;   <span class="hljs-keyword">int</span> tR = <span class="hljs-number">0</span>;   <span class="hljs-keyword">int</span> tC = <span class="hljs-number">0</span>;   <span class="hljs-keyword">int</span> dR = matrix.length - <span class="hljs-number">1</span>;   <span class="hljs-keyword">int</span> dC = matrix[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span>;   <span class="hljs-keyword">while</span> (tR &lt;= dR &amp;&amp; tC &lt;= dC) &#123;      printEdge(matrix, tR++, tC++, dR--, dC--);   &#125;&#125;<span class="hljs-comment">// tR, tC 左上角</span><span class="hljs-comment">// dR, dC 右下角</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printEdge</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] m, <span class="hljs-keyword">int</span> tR, <span class="hljs-keyword">int</span> tC, <span class="hljs-keyword">int</span> dR, <span class="hljs-keyword">int</span> dC)</span> </span>&#123;   <span class="hljs-keyword">if</span> (tR == dR) &#123; <span class="hljs-comment">// 只剩一条横线</span>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = tC; i &lt;= dC; i++) &#123;         <span class="hljs-comment">// 打印横线</span>         System.out.print(m[tR][i] + <span class="hljs-string">&quot; &quot;</span>);      &#125;   &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tC == dC) &#123;      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = tR; i &lt;= dR; i++) &#123;         <span class="hljs-comment">// 打印竖线</span>         System.out.print(m[i][tC] + <span class="hljs-string">&quot; &quot;</span>);      &#125;   &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-keyword">int</span> curC = tC;      <span class="hljs-keyword">int</span> curR = tR;      <span class="hljs-keyword">while</span> (curC != dC) &#123;         System.out.print(m[tR][curC] + <span class="hljs-string">&quot; &quot;</span>);         curC++;      &#125;      <span class="hljs-keyword">while</span> (curR != dR) &#123;         System.out.print(m[curR][dC] + <span class="hljs-string">&quot; &quot;</span>);         curR++;      &#125;      <span class="hljs-keyword">while</span> (curC != tC) &#123;         System.out.print(m[dR][curC] + <span class="hljs-string">&quot; &quot;</span>);         curC--;      &#125;      <span class="hljs-keyword">while</span> (curR != tR) &#123;         System.out.print(m[curR][tC] + <span class="hljs-string">&quot; &quot;</span>);         curR--;      &#125;   &#125;&#125;</code></pre><h2 id="原地旋转正方形矩阵"><a href="#原地旋转正方形矩阵" class="headerlink" title="原地旋转正方形矩阵"></a>原地旋转正方形矩阵</h2><p>一样先转外层的框</p><p>分圈结构！</p><p> <img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210329202839.png" alt="分组"></p><p>4*4有3个小组；</p><p>小组数等于边长 - 1</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210329203434.png" alt="四个坐标"></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix)</span> </span>&#123;   <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>;   <span class="hljs-keyword">int</span> b = <span class="hljs-number">0</span>;   <span class="hljs-keyword">int</span> c = matrix.length - <span class="hljs-number">1</span>;   <span class="hljs-keyword">int</span> d = matrix[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span>;   <span class="hljs-keyword">while</span> (a &lt; c) &#123;      rotateEdge(matrix, a++, b++, c--, d--);   &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rotateEdge</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] m, <span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> c, <span class="hljs-keyword">int</span> d)</span> </span>&#123;   <span class="hljs-keyword">int</span> tmp = <span class="hljs-number">0</span>;   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; d - b; i++) &#123;      <span class="hljs-comment">// i组号</span>      tmp = m[a][b + i];      m[a][b + i] = m[c - i][b];      m[c - i][b] = m[c][d - i];      m[c][d - i] = m[a + i][d];      m[a + i][d] = tmp;   &#125;&#125;</code></pre><h1 id="数组累加和问题三连"><a href="#数组累加和问题三连" class="headerlink" title="数组累加和问题三连"></a>数组累加和问题三连</h1><h2 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h2><p>给定一个正整数组成的无序数组arr，给定一个正整数值K<br>找到arr的所有子数组里，哪个子数组的累加和等于K，并且是长度最大的<br>返回其长度</p><p> <strong>范围和累加和有严格单调性</strong> ，也就是说右扩一定增大，左缩一定减小</p><p>子数组、子串都是连续的；子序列才是散开的</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210330173727.png" alt="方法"></p><p>设置窗口，窗口内为windowsum</p><p>ws&lt;sum, R右移</p><p>ws&gt;sum, L右移</p><p>ws == sum, 判断是否更新, R右移</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMaxLength</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> K)</span> </span>&#123;   <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length == <span class="hljs-number">0</span> || K &lt;= <span class="hljs-number">0</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;   &#125;   <span class="hljs-comment">// [L..R]</span>   <span class="hljs-comment">// [0..0]上的范围</span>   <span class="hljs-comment">// 一开始这样设置窗口内应该设置一个数 arr[0]</span>   <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;   <span class="hljs-keyword">int</span> right = <span class="hljs-number">0</span>;   <span class="hljs-comment">// 这里的sum指的是windowsum k表示sum</span>   <span class="hljs-keyword">int</span> sum = arr[<span class="hljs-number">0</span>];   <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>;   <span class="hljs-keyword">while</span> (right &lt; arr.length) &#123;      <span class="hljs-keyword">if</span> (sum == K) &#123;         len = Math.max(len, right - left + <span class="hljs-number">1</span>);         <span class="hljs-comment">// 这里L或者R动都可以 L减，R加</span>         sum -= arr[left++];      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &lt; K) &#123;         right++;         <span class="hljs-keyword">if</span> (right == arr.length) &#123;            <span class="hljs-keyword">break</span>;         &#125;         sum += arr[right];      &#125; <span class="hljs-keyword">else</span> &#123;         sum -= arr[left++];      &#125;   &#125;   <span class="hljs-keyword">return</span> len;&#125;</code></pre><h2 id="题目二-1"><a href="#题目二-1" class="headerlink" title="题目二"></a>题目二</h2><p>给定一个整数组成的无序数组arr，值可能正、可能负、可能0<br>给定一个整数值K<br>找到arr的所有子数组里，哪个子数组的累加和等于K，并且是长度最大的<br>返回其长度</p><p>假设0 - 17位置累加和为 1000；</p><p>0 - 5位置是第一次出现800的情况；</p><p>所以6 - 17累加和为200，同时又是以17结尾，200最长的，因为800是最早出现的</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210330180620.png" alt="解"></p><p>假设sum为当前位置的累加和，map放累加和 <strong>最早</strong> 出现的位置</p><p>来到5的时候，找map里面有没有5 - 10 = - 5的位置；</p><p>没有，所以以5结尾的没有答案</p><p>把新的累加和加到map里面，5最早的累加和出现在0位置，记录 5 0</p><p>下一个数来到6，加上累加和为11， 找11 - 10 = 1最早出现的位置</p><p>说明以6结尾的没有答案，记录 11 1</p><p>来到4，加上累加和为15， 15 - 10 = 5，map有5</p><p>说明来到2位置的时候，1 - 2为当前最长答案2，15放入map。。。。</p><p> <strong>必须躺着一个 0 -1的键值对</strong> ，不然0 - i正好出现的时候找不到答案</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxLength</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> k)</span> </span>&#123;   <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length == <span class="hljs-number">0</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;   &#125;   HashMap&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;Integer, Integer&gt;();   map.put(<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>); <span class="hljs-comment">// important</span>   <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>;   <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;      sum += arr[i];      <span class="hljs-keyword">if</span> (map.containsKey(sum - k)) &#123;         len = Math.max(i - map.get(sum - k), len);      &#125;      <span class="hljs-keyword">if</span> (!map.containsKey(sum)) &#123;         map.put(sum, i);      &#125;   &#125;   <span class="hljs-keyword">return</span> len;&#125;</code></pre><h3 id="题目二拓展"><a href="#题目二拓展" class="headerlink" title="题目二拓展"></a>题目二拓展</h3><p>一个数组中有正负数，返回里面1和2个数相等的最大子数组</p><p>解法：遇到1 和 2之外的数认为是0，遇到1变成1，遇到2变成-1</p><p>求累加和为0的最长子数组</p><h2 id="题目三-2"><a href="#题目三-2" class="headerlink" title="题目三"></a>题目三</h2><p>给定一个整数组成的无序数组arr，值可能正、可能负、可能0<br>给定一个整数值K<br>找到arr的所有子数组里，哪个子数组的累加和&lt;=K，并且是长度最大的<br>返回其长度</p><p>定义一个概念：</p><p>i开头所有的可能性中，哪一个是取得累加和最小的情况</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210330192125.png"></p><p>生成好这两个数组</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210330193310.png" alt="解"></p><p>就维持一个窗口看看有没有往右看的可能性，如果可能性都没有，一定不是想要的答案</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210330193550.png"></p><p>当扩到1时，sum=1，超过k了</p><p>于是去掉 - 10，加入1 发现sum大于k</p><p>所以此时5开头一定得不到一个更长的答案，舍弃</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxLengthAwesome</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> k)</span> </span>&#123;   <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length == <span class="hljs-number">0</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;   &#125;   <span class="hljs-keyword">int</span>[] minSums = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[arr.length];   <span class="hljs-keyword">int</span>[] minSumEnds = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[arr.length];   minSums[arr.length - <span class="hljs-number">1</span>] = arr[arr.length - <span class="hljs-number">1</span>];   minSumEnds[arr.length - <span class="hljs-number">1</span>] = arr.length - <span class="hljs-number">1</span>;   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = arr.length - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;      <span class="hljs-keyword">if</span> (minSums[i + <span class="hljs-number">1</span>] &lt; <span class="hljs-number">0</span>) &#123;         minSums[i] = arr[i] + minSums[i + <span class="hljs-number">1</span>];         minSumEnds[i] = minSumEnds[i + <span class="hljs-number">1</span>];      &#125; <span class="hljs-keyword">else</span> &#123;         minSums[i] = arr[i];         minSumEnds[i] = i;      &#125;   &#125;   <span class="hljs-comment">// (i...)(...)(...) | (end....</span>   <span class="hljs-comment">// end开始算不进去了</span>   <span class="hljs-comment">// sum是i扩到end的窗口累加和</span>   <span class="hljs-keyword">int</span> end = <span class="hljs-number">0</span>;   <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;   <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;   <span class="hljs-comment">// i是窗口的最左的位置，end扩出来的最右有效块儿的最后一个位置的，再下一个位置</span>   <span class="hljs-comment">// end也是下一块儿的开始位置</span>   <span class="hljs-comment">// 窗口：[i~end)</span>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;      <span class="hljs-comment">// while循环结束之后：</span>      <span class="hljs-comment">// 1) 如果以i开头的情况下，累加和&lt;=k的最长子数组是arr[i..end-1]，看看这个子数组长度能不能更新res；</span>      <span class="hljs-comment">// 2) 如果以i开头的情况下，累加和&lt;=k的最长子数组比arr[i..end-1]短，更新还是不更新res都不会影响最终结果；</span>      <span class="hljs-keyword">while</span> (end &lt; arr.length &amp;&amp; sum + minSums[end] &lt;= k) &#123;         sum += minSums[end];         end = minSumEnds[end] + <span class="hljs-number">1</span>;      &#125;      <span class="hljs-comment">// 不管越界还是累加跳出来的都对</span>      <span class="hljs-comment">// [i....](end...x)</span>      <span class="hljs-comment">// [i.... ] x</span>      res = Math.max(res, end - i);      <span class="hljs-keyword">if</span> (end &gt; i) &#123; <span class="hljs-comment">// 窗口内还有数 [i~end) [4,4)</span>         sum -= arr[i];      &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 窗口内已经没有数了，说明从i开头的所有子数组累加和都不可能&lt;=k</span>         end = i + <span class="hljs-number">1</span>;      &#125;   &#125;   <span class="hljs-keyword">return</span> res;&#125;</code></pre><h1 id="哈希函数有关的结构和岛问题"><a href="#哈希函数有关的结构和岛问题" class="headerlink" title="哈希函数有关的结构和岛问题"></a>哈希函数有关的结构和岛问题</h1><h2 id="认识哈希函数"><a href="#认识哈希函数" class="headerlink" title="认识哈希函数"></a>认识哈希函数</h2><p>out  f(in data)</p><p>in为输入类型，out为输出类型</p><ol><li>输入参数data，假设是in类型，特征：可能性无穷大，比如str类型的参数</li><li>输出参数类型out，特征：可能性可以很大，但一定是有穷尽的</li><li>哈希函数没有任何随机的机制，固定的输入一定是固定的输出</li><li>输入无穷多但输出值有限，所以不同输入也可能输出相同（哈希碰撞）</li><li>再相似的不同输入，得到的输出值，会 <strong>几乎均匀的分布在out域</strong> 上<br>重点：第5条！</li></ol><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210330202849.png"></p><p>假设有一个框能框住s区域，s区域不同的框框中的都差不多；</p><p>散列函数</p><p>输入很像并不能决定输出很像，输出一定会是离散；</p><h2 id="哈希函数作用"><a href="#哈希函数作用" class="headerlink" title="哈希函数作用"></a>哈希函数作用</h2><p>可以把数据根据不同值，几乎均匀的分开</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210330203525.png"></p><p>可以用得到的out模上m，得到的也会是均匀输出</p><p>假设有一个四十亿个整数的文件，每一个整数四个字节，文件一行一个整数</p><p>假设只有1G的内存，统计哪一个数出现的次数最多</p><p>key出现数，value次数，都是无符号整数</p><p>如果1g内存都作哈希表，能放多少个数</p><p>一条记录8字节，key4字节，value4字节，还有内部索引空间…..(假设不算)；</p><p>假设都不一样，最差情况 8 * 40 亿个字节，32G，是会爆内存的</p><p>1G内存最多能装多少记录？</p><p>40亿除以32，假设再保守一点，40亿除以40也就是一亿条的时候不会爆；</p><p>读到一个数，用哈希函数的到返回值，让其 <strong>模上40</strong> </p><p>得到0 - 39范围上的数；</p><p>把原数据分别发送到对应的0，1，2….39号小文件里面</p><p>这时候就可以认为</p><p>0…39文件中所含有不同数字的总数， <strong>几乎均等</strong> </p><p>第一次统计0号文件记录，第二次统计…</p><p>直到得到40个top1，取最大的top</p><h2 id="哈希表的实现"><a href="#哈希表的实现" class="headerlink" title="哈希表的实现"></a>哈希表的实现</h2><p>增删查改 O(1)</p><blockquote><p>最传统的HashMap</p></blockquote><p>假设有17个格子的空间，一开始放入一个键值对为 abc 1</p><p>会把abc用哈希函数再与17去模后放入</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210331003811.png" alt="传统"></p><p>左边类似于单链表串下去</p><p>假设有一个新串的哈希值碰撞了，abc底下再串一个，而不是覆盖</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210331004125.png" alt="哈希碰撞"></p><p>查询的时候，用哈希函数找到对应格子用单链表遍历到abc</p><p>增删改查都类似；</p><p>因为是类似均匀分配，如果有一条链超过x，其他差不多也超过x；</p><p>后面会进行 <strong>扩容</strong> ：</p><p> <strong>暴力扩容</strong> ：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210331004551.png" alt="扩容"></p><p>就是暴力用原数据模新模来放进去，放完之后如果是上图数据大小的话，之后样本长度差不多为之前一半</p><p>log2为底的N基上为扩容的次数</p><p>暴力扩容总代价为(1 + 2 + 4 + 8….+ N/2)；所以扩容总代价O(N)</p><p>如果算上平均 均摊 就是应该为O(1)，后续有 <strong>改进</strong> </p><p>比如JVM可以 <strong>离线扩容</strong> ，不占用用户在线时间</p><p>或者桶 <strong>不按照单链表</strong> 串，而使用 <strong>有序表</strong>  ，不用链表长度为6再扩容，有序表查为logk，可以放很多</p><p>所以 <strong>哈希表再使用时，增删查改时间复杂度都为O(1)</strong> </p><h2 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h2><p>1）利用哈希函数的性质</p><p>2）每一条数据提取特征</p><p>3）加入描黑库</p><p>类似于没有删除的 <strong>黑名单系统</strong> </p><p>100亿的url构成的 <strong>黑名单</strong> （爬虫问题）</p><p>每一个爬虫爬到url，就塞入表；</p><p>假设100亿url64字节的，6400亿字节差不多640G <strong>内存</strong> ；</p><p>首先有一个类似于 <strong>位图</strong> 的东西，bit数组，每一个位置占用一个bit表示01</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210331012220.png" alt="code"></p><p>最终得到就是：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210331012257.png" alt="右移"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210331012459.png" alt="右移"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210331012701.png" alt="设置"></p><p>假设申请的是整形数组，最大数字为21亿多一些，能表示21亿多一些 * 32位的位图</p><p>long能表示21亿多一些 * 64位的位图，因为数组长度Integer.MAX_VALUE</p><p>如果还不够，就可以用矩阵表示</p><p>找行找列</p><p>m长度的位图，m/8个字节数可以使用；</p><p> <strong>布隆过滤器</strong> 先设置一个m长度的位图，利用哈希函数算出哈希值，模上m决定一个位置描黑</p><p>url用另外一个独立的哈希函数算出out2，模上m得到新的位置再描黑；</p><p>若一共有k个哈希函数，能描黑k的位置，有可能k的位置中有重复的；</p><p>这个时候就说url <strong>加入过黑名单</strong> </p><p>查询算k个哈希值模m算k的位置，只有k的位置都黑才算在黑名单中</p><p> <strong>一定存在失误率</strong> ，只给1000个bit位图，100亿url搞完几乎全黑，全黑后报谁都是黑名单；</p><p> <strong>布隆过滤器</strong> 失误类型 <strong>不可能为是黑名单的url误报为非黑名单</strong> ，一定是非黑名单误报为黑名单。</p><h3 id="布隆过滤器重要的三个公式"><a href="#布隆过滤器重要的三个公式" class="headerlink" title="布隆过滤器重要的三个公式"></a>布隆过滤器重要的三个公式</h3><p>1，假设数据量为n，预期的失误率为p（布隆过滤器大小和每个样本的大小无关）<br>2，根据n和p，算出Bloom Filter一共需要多少个bit位，向上取整，记为m<br>3，根据m和n，算出Bloom Filter需要多少个哈希函数，向上取整，记为k<br>4，根据修正公式，算出真实的失误率p_true</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210331014315.png" alt="公式"></p><p>如果设计一个黑名单系统，提前规定 <strong>失误率</strong> </p><p>m空间有理论和实际，用理论算k，k12.7时，k实际为13</p><p>此时就会存在真实失误率，都带入实际值，得到真实失误率， <strong>一般都更低</strong> 。</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210331015050.png" alt="关系"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210331015107.png" alt="关系"></p><p>k个哈希函数怎么得到呢？</p><p>找两个哈希函数就行，f和g；</p><p>f函数的返回值 加上 1 * g的返回值 第一个哈希函数</p><p>f函数的返回值 加上 2 * g的返回值….第二个哈希函数</p><h2 id="一致性哈希"><a href="#一致性哈希" class="headerlink" title="一致性哈希"></a>一致性哈希</h2><p>分布式 <strong>存储结构</strong> 最常见的结构</p><p>1）哈希域变成环的设计</p><p>2）虚拟节点技术</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210331185719.png" alt="传统"></p><p>经典结构为：算hashcode存放到不同的数据端实现分布式；</p><p>如果对key作大量的索引，比如查询 ，要从不同服务器作merge(MapReduce)</p><p>要实现 <strong>负载均衡</strong> 高中低频key也应该均匀分布，都要有一些；</p><p>能作hash的key应该足够多；</p><blockquote><p>传统负载均衡底层数据服务器问题</p></blockquote><p>增加机器和减少机器会特别麻烦；</p><p>要重新做hash，全量迁移</p><h3 id="hash成环"><a href="#hash成环" class="headerlink" title="hash成环"></a>hash成环</h3><blockquote><p>一致性哈希解决问题</p></blockquote><p>既可以做到负载均衡，也可以解决迁移问题</p><p>把哈希函数的返回值想象成一个环；</p><p>假设有三台机器，一定有ip、hostname、mac地址不同，取出能区分的东西；</p><p>一致性哈希里面没有模这个问题，都是hash值；</p><p>假设用hostname作哈希，得到m1，m2，m3；不一定很均分</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210331191429.png"></p><p>假设要存储abc，计算出hash，顺时针找到的第一台机器，就是它的归属</p><p>假设三台机器code足够均匀，就可以负载均衡；</p><p>假设m1要下线，把m1的数据给m2，数据迁移就完成</p><p>假设要加mk，找到属于的一段，迁移就行</p><blockquote><p>怎么找？</p></blockquote><p>m1,m2,m3算出来有hashcode</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210331192104.png" alt="下发"></p><p>找刚刚大于等于abc的hashcode的机器即可（可以用二分）</p><blockquote><p>还存在问题</p></blockquote><ol><li><p>刚开始机器少，散列后可能不均匀</p></li><li><p>减机器的时候也可能造成负载不均匀</p></li></ol><h3 id="虚拟节点技术"><a href="#虚拟节点技术" class="headerlink" title="虚拟节点技术"></a>虚拟节点技术</h3><p>例如给m1,m2,m3分别分配1000个字符串，是能够找到字符串归属于哪一台机器的，</p><p>用每台数据储存服务器的字符串去抢环</p><p>虚拟节点抢到的数据归属于本身机器</p><p>增加机器的时候，一样分配一千个字符串去抢环，然后归属</p><p> <strong>字符串数量没到万亿级别，几乎不会出现碰撞</strong> </p><p>也能实现 <strong>负载管理</strong> ，如果一个机器性能更强，相对给予更多的字符串，抢更多的点</p><h1 id="并行算法"><a href="#并行算法" class="headerlink" title="并行算法"></a>并行算法</h1><h2 id="岛问题"><a href="#岛问题" class="headerlink" title="岛问题"></a>岛问题</h2><blockquote><p> 岛问题只是一种启发性的说明</p></blockquote><p>一个只有0和1两种数字的二维矩阵中，<br>上下左右能练成一片的1，算一个岛<br>返回矩阵中，一共有几个岛(上下左右相连)</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">countIslands1</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] m)</span> </span>&#123;   <span class="hljs-keyword">if</span> (m == <span class="hljs-keyword">null</span> || m[<span class="hljs-number">0</span>] == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;   &#125;   <span class="hljs-keyword">int</span> N = m.length;   <span class="hljs-keyword">int</span> M = m[<span class="hljs-number">0</span>].length;   <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; M; j++) &#123;         <span class="hljs-keyword">if</span> (m[i][j] == <span class="hljs-number">1</span>) &#123;            res++;            infect(m, i, j, N, M);         &#125;      &#125;   &#125;   <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-comment">// 感染函数 来到i，j 把上下左右所到之路感染为2</span><span class="hljs-comment">// N行 M列</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">infect</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] m, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j, <span class="hljs-keyword">int</span> N, <span class="hljs-keyword">int</span> M)</span> </span>&#123;   <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || i &gt;= N || j &lt; <span class="hljs-number">0</span> || j &gt;= M || m[i][j] != <span class="hljs-number">1</span>) &#123;      <span class="hljs-keyword">return</span>;   &#125;   <span class="hljs-comment">// i j不越界也是1</span>   m[i][j] = <span class="hljs-number">2</span>;   infect(m, i + <span class="hljs-number">1</span>, j, N, M);   infect(m, i - <span class="hljs-number">1</span>, j, N, M);   infect(m, i, j + <span class="hljs-number">1</span>, N, M);   infect(m, i, j - <span class="hljs-number">1</span>, N, M);&#125;</code></pre><blockquote><p>问题</p></blockquote><p>O(N * M)</p><p>矩阵如果很大，单cpu运行很乏力；</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210331202150.png" alt="分两个cpu"></p><p>分两个cpu处理，建立分割记录</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210331202700.png"></p><p>只关心左右两边都是1的情况</p><p>遇到则判断是否一个集合，是的话下一个，不是的话union</p><p>可以分为很多个部分，分配cpu</p><h1 id="资源限制技巧汇总"><a href="#资源限制技巧汇总" class="headerlink" title="资源限制技巧汇总"></a>资源限制技巧汇总</h1><p>1）布隆过滤器用于集合的建立与查询，并可以节省大量空间（已讲）<br>2）一致性哈希解决数据服务器的负载管理问题（已讲）<br>3）利用并查集结构做岛问题的并行计算（已讲）<br>4）哈希函数可以把数据按照种类均匀分流<br>5）位图解决某一范围上数字的出现情况，并可以节省大量空间<br>6）利用分段统计思想、并进一步节省大量空间<br>7）利用堆、外排序来做多个处理单元的结果合并</p><h2 id="题目一-1"><a href="#题目一-1" class="headerlink" title="题目一"></a>题目一</h2><p>32位无符号整数的范围是0~4,294,967,295，<br>现在有一个正好包含40亿个无符号整数的文件，<br>可以使用最多1GB的内存，怎么找到出现次数最多的数？</p><p> <strong>上面哈希章节</strong> </p><h2 id="题目二-2"><a href="#题目二-2" class="headerlink" title="题目二"></a>题目二</h2><p>32位无符号整数的范围是0~4,294,967,295，<br>现在有一个正好包含40亿个无符号整数的文件，<br>所以在整个范围中必然存在没出现过的数。<br>可以使用最多1GB的内存，怎么找到所有未出现过的数？</p><p>用哈希表 42亿 * 4字节 差不多16G</p><p>用 <strong>位图</strong> ，0 - 2^ 32 -1 用2^ 32个bit表示一个数出现过没有</p><p>哈希表是4个字节表示是否出现，位图一个bit表示一个数是否出现，16G/32差不多500多M</p><p>【进阶】<br>内存限制为 10MB，但是只用找到一个没出现过的数即可</p><p>内存限制为 3kb，但是只用找到一个没出现过的数即可</p><p> <strong>3kb转化为int数组</strong> ，比如找到3k / 4 = 3 * 256 ，找离这个数最近的2的次方，即为 2^ 9；</p><p>所以吧数组定成512长度的话，一定不会爆空间；</p><p>int[512]:  0~2^32 - 1数字，2^32能均分512，均分一份是2^32 / 512 = 8388608</p><p>第0份统计8388608出现了多少个数；</p><p>遍历所有数组，中了范围在counts[i]++</p><p>必在某一个范围内词频统计不够8388608，则在这个范围上必缺数字，</p><p>找到L…R，继续重复拿3kb分，直到3kb能单独做到统计数组；</p><p>内存限制为 3个变量，但是只用找到一个没出现过的数即可</p><p> <strong>二分</strong> </p><p>遍历左侧，判断哪边数字小于一半，继续二分小于一半的区域….</p><h2 id="题目三-3"><a href="#题目三-3" class="headerlink" title="题目三"></a>题目三</h2><p>有一个包含100亿个URL的大文件，假设每个URL占用64B，<br>请找出其中所有重复的URL<br>【补充】<br>某搜索公司一天的用户搜索词汇是海量的(百亿数据量)，<br>请设计一种求出每天热门Top100词汇的可行办法</p><p>补充和重复是一样的问题</p><p>用 <strong>哈希</strong> 发配到不同机器上，如果一个机器种类过多，继续哈希；</p><p> <strong>不怕重复的多，怕种类多</strong> </p><p>top100就是哈希分机器，哈希分文件，统计文件top100</p><p>总体都是mapper和reducer</p><p> <strong>外排</strong> ，各个文件top1 pk弹出，再pk新顶部和其他的….</p><p>也可以用 <strong>二维堆</strong> 找出来</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210401172823.png" alt="二维堆"></p><p>每个大根堆的结点还是一个大根堆</p><h2 id="题目四"><a href="#题目四" class="headerlink" title="题目四"></a>题目四</h2><p>32位无符号整数的范围是0~4294967295，<br>现在有40亿个无符号整数，<br>可以使用最多1GB的内存，<br>找出所有出现了两次的数。</p><p>用两个bit表示一个数字出现的频率；00表示初始状态，出现多一次变成01，再多10…出现更多次都是11</p><p>16G/32 * 2 = 1G左右</p><h2 id="题目五"><a href="#题目五" class="headerlink" title="题目五"></a>题目五</h2><p>32位无符号整数的范围是0~4294967295，现在有40亿个无符号整数<br>可以使用最多10MB的内存，怎么找到这40亿个整数的中位数？</p><p>用题目二的方式用3kb开整型数组，int[512]，每一份8388608，求第二十亿小的数；</p><p>遍历统计，定位到第二十亿位数的空间</p><h2 id="题目六"><a href="#题目六" class="headerlink" title="题目六"></a>题目六</h2><p>32位无符号整数的范围是0~4294967295，<br>有一个10G大小的文件，每一行都装着这种类型的数字，<br>整个文件是无序的，给你5G的内存空间，<br>请你输出一个10G大小的文件，就是原文件所有数字排序的结果</p><p> <strong>小根堆</strong> 记录目前为止最大的两个数，并记录出现次数，哈希表记录在小根堆出现的位置；</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210401181749.png" alt="例子"></p><p>能统计全局最大前两个及次数，下一次重复行为，大于等于第二大的数不再统计；</p><blockquote><p>10G文件，5G内存</p></blockquote><p>估算map和小根堆能堆放的记录，去怼文件排序就行</p><h1 id="有序表的原理、应用、扩展"><a href="#有序表的原理、应用、扩展" class="headerlink" title="有序表的原理、应用、扩展"></a>有序表的原理、应用、扩展</h1><p class="note note-primary">代码传github</p><h2 id="搜索二叉树"><a href="#搜索二叉树" class="headerlink" title="搜索二叉树"></a>搜索二叉树</h2><p>搜索二叉树一定要说明以什么标准来排序</p><p>经典的搜索二叉树，树上 <strong>没有重复</strong> 的用来排序的key值</p><p>(没有重复因为 <strong>平衡性调整问题</strong> ，无法控制一律放在哪边的问题)</p><p>如果有重复节点的需求，可以在一个节点 <strong>内部增加数据项</strong> </p><h3 id="搜索二叉树查询key"><a href="#搜索二叉树查询key" class="headerlink" title="搜索二叉树查询key"></a>搜索二叉树查询key</h3><p>1）如果当前节点的value==key，返回true<br>2）如果当前节点的value&lt;key，当前节点向左移动<br>3）如果当前节点的value&gt;key，当前节点向右移动<br>4）如果当前节点变成null，返回false</p><h3 id="搜索二叉树插入新的key"><a href="#搜索二叉树插入新的key" class="headerlink" title="搜索二叉树插入新的key"></a>搜索二叉树插入新的key</h3><p>和查询过程一样，但当前节点滑到空的时候，就插入在这里</p><h3 id="搜索二叉树删除key"><a href="#搜索二叉树删除key" class="headerlink" title="搜索二叉树删除key"></a>搜索二叉树删除key</h3><p>0）先找到key所在的节点<br>1）如果该节点没有左孩子、没有右孩子，直接删除即可<br>2）如果该节点有左孩子、没有右孩子，直接用左孩子顶替该节点<br>3）如果该节点没有左孩子、有右孩子，直接用右孩子顶替该节点<br>4）如果该节点有左孩子、有右孩子，用该节点 <strong>后继节点</strong> 顶替该节点</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210401193315.png" alt="右树最左"></p><p>6有右孩子扔给8即可</p><p>删除要判断后继结点的父节点是否为待删除节点；</p><h3 id="裸搜索二叉树问题"><a href="#裸搜索二叉树问题" class="headerlink" title="裸搜索二叉树问题"></a>裸搜索二叉树问题</h3><p> <strong>输入状况决定性能</strong> </p><p>输入状况很好，左右均分，logN</p><p>输入状况不好，全左全右，N</p><p>1）基础的搜索二叉树，添加、删除时候 <strong>不照顾平衡性</strong> </p><p>2）数据状况很差时，性能就很差</p><p>给搜索二叉树引入两个动作：<strong>左旋、右旋</strong> ，log(N)</p><p>对 X 进行右旋， X倒向右方</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210401200133.png" alt="对a右旋"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210401200409.png" alt="左旋"></p><p>有序表特殊功能</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210401201836.png"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210401201936.png"></p><p>TreeMap底层平衡搜索二叉树</p><p>hashMap增删改查O(1)</p><p>TreeMap O(logN)</p><h2 id="AVL树、SB树、红黑树的共性"><a href="#AVL树、SB树、红黑树的共性" class="headerlink" title="AVL树、SB树、红黑树的共性"></a>AVL树、SB树、红黑树的共性</h2><p>1）都是搜索二叉树</p><p>2）插入、删除、查询（一切查询）搜索二叉树怎么做，这些结构都这么做</p><p>3）使用调整的基本动作都只有左旋、右旋</p><p>4）插入、删除时，从最底层被影响到的节点开始，对往上路径的节点做平衡性检查</p><p>5）因为只对一条向上路径的每个节点做O(1)的检查和调整，所以可以做到O(logN)</p><p>性能指标完全一样，有差别的是常数时间、跳表、实现</p><h2 id="AVL树、SB树、红黑树的不同"><a href="#AVL树、SB树、红黑树的不同" class="headerlink" title="AVL树、SB树、红黑树的不同"></a>AVL树、SB树、红黑树的不同</h2><p>1）平衡性的约束不同</p><p>AVL树最严格（ <strong>左树高 - 右树高 的绝对值 &lt; 2</strong> ）、</p><p>SB树稍宽松（任何一个 <strong>叔结点</strong> 所拥有的结点数不少于它的任何一个 <strong>侄子结点</strong> ）、</p><p>这样左树跟右树数量关系 维持到 <strong>至多多一倍 + 1</strong> </p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210401202616.png"></p><p>红黑树最宽松</p><blockquote><p>红黑树特性</p></blockquote><ol><li>每一个结点红 或者 黑</li><li>头结点黑 叶节点黑</li><li>红结点的子结点为黑（两红不相邻）</li><li>从任何一个结点到每一个子的所有路径上黑结点一样多</li></ol><p>最长的链一定是黑红交替，最短的一定是全黑，所以也不会超过一半</p><p>2）插入、删除和搜索二叉树一样，但是额外，做各自的平衡性调整。各自的平衡性调整所使用的动作都是 <strong>左旋或者右旋</strong> </p><p>三种树都是从 <strong>受影响的结点</strong> 开始检查，只不过到具体一个结点的 <strong>检查的动作不一样</strong> 。</p><h2 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h2><p>1）最严格的平衡性，任何节点左树高度和右树高度差不超过1</p><p>2） <strong>受影响的结点</strong> 开始（删除、插入），往上沿途检查每个节点时，都去检查四种违规情况：LL、RR、LR、RL</p><p>​        如果删除时，用了后继结点替代，则从 <strong>后继结点原位置</strong> 开始网上检查。</p><p>3）不同情况虽然看起来复杂，但是核心点是：<br>LL（做一次右旋）、RR（做一次左旋）<br>LR和RL（利用旋转让底层那个上到顶部）</p><p>| 左树高度 - 右树高度 | &lt; 2 不违规；</p><p>| 左树高度 - 右树高度 | &gt; 1；</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210401225201.png" alt="LL型"></p><p>LL型，左树的左树导致不平</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210401225412.png" alt="LR型"></p><p>LR型，左树的右树不平….</p><p>RR..RL</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210401225814.png">假设左边为7右边为6，只可能左树的左子树为6或者右子树为6，不可能都为6，都为6之前就已经违规了</p><blockquote><p>如何旋转</p></blockquote><ul><li>LL型x右旋即可,RR型x左旋即可，一次动作</li></ul><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210401230223.png" alt="右旋"></p><ul><li><p>LR型</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210401230440.png"></p><p>让底下的 <strong>孙结点</strong> 上到顶部</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210401230704.png" alt="先让左边c代替a"></p><p>再让x右旋</p><p>所插的点一路插到最顶</p><p>转两次，每个节点都是O(1)的代价，一路往上每个节点都查找，O(log(N))的复杂度</p></li></ul><h2 id="SB树（size-balance-tree）"><a href="#SB树（size-balance-tree）" class="headerlink" title="SB树（size-balance-tree）"></a>SB树（size-balance-tree）</h2><p>AVL维护 <strong>高度</strong> ，sb树维护 <strong>节点数</strong> ，不算重复的key，只算种类</p><p>1）让每一个叔叔节点为头的数，节点个数都不少于其任何一个侄子节点<br>2）也是从底层被影响节点开始向上做路径每个节点检查<br>3）与AVL树非常像，也是四种违规类型：LL、RR、LR、RL<br>4）与AVL树非常像，核心点是：<br>LL（做一次右旋）、RR（做一次左旋）<br>LR和RL（利用旋转让底层那个上到顶部）<br>5）与AVL树不同的是，每轮经过调整后，谁的孩子发生变化了，谁就再查</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210402000039.png" alt="sb RL型"></p><p>查到x时，发现左孩子没有右孩子的左孩子多，RL；</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210402000133.png" alt="RR"></p><p>没有右孩子的右孩子多，RR；</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210402000251.png"></p><blockquote><p>平衡调整</p></blockquote><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210402001131.png" alt="LL"></p><p>进行一波右旋后，要找到子孩子改变的结点（x和b）进行递归调用m（x）调整平衡性</p><p>m(x)函数的意义是在x上进行检查孩子和孩子的孩子违规情况</p><p>是一个递归套递归的过程</p><p>因为 <strong>换了孩子后，孩子pk的对象改变了</strong> ，要重复执行m(x)和m(b)防止孩子出现问题；</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210402002011.png" alt="RR"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210402192028.png" alt="LR"></p><h3 id="SB树在使用时候的改进"><a href="#SB树在使用时候的改进" class="headerlink" title="SB树在使用时候的改进"></a>SB树在使用时候的改进</h3><p>1）删除时候 <strong>可以不用检查</strong> </p><p>2）就把平衡性的调整放在 <strong>插入</strong> 的时候</p><p>3）因为这种只要变就递归的特性，别的树没有</p><p>4）可以在节点上封装别的数据项，来增加功能</p><h2 id="跳表（skiplist）"><a href="#跳表（skiplist）" class="headerlink" title="跳表（skiplist）"></a>跳表（skiplist）</h2><p>实现机制和二叉树没关系</p><p>1）结构上根本和 <strong>搜索二叉树无关</strong> </p><p>2）利用随机概率分布来使得高层索引可以无视数据规律，做到整体性能优良</p><p>3） <strong>思想</strong> 是所有有序表中最 <strong>先进</strong> 的</p><p>4）结构简单就是 <strong>多级单链表</strong> </p><p>最初的node，最顶部天然存在，全局最小值为null</p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210403192343.png" alt="node" style="zoom:25%;" /><p>假设要加（3，abc），会生成一个node，并且本身有一条指针，然后掷骰子决定</p><p>掷出0，加一条指针，直到掷1；</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210403192548.png" alt="掷骰子"></p><p>自己结点不会再拓展了，只会拓展初始的</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210403192833.png" alt="拓展"></p><p>然后依次从第一层（最高层）找到小于等于3的key，没有，则指向(3, abc)</p><p>从第二层找…第三层…</p><p>直到</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210403193053.png"></p><p>有高层一定有底层，不会断层</p><p>假设再加一个5，假设5只有2层，左侧三层，不需要扩；</p><p>从最高层开始找，遍历最高层单链表，找到小于等于5最晚的结点3，但是5没有三层，3此时不指向5</p><p>直接往下跳，3第二层指针指向5；</p><p>往下走，3第三层指向5；</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210403193403.png"></p><p>假设一个结点2，只有一层，</p><p>最高层开始，小于等于2最晚的key在大结点上，无法跳到3，</p><p>2没有三层结点，往下跳，往下跳，在最后一层</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210403193510.png"></p><blockquote><p>查询过程</p></blockquote><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210403193900.png" alt="查询"></p><p>找都是从最高层开始找；</p><blockquote><p>好在哪？</p></blockquote><p>假设加入了N个记录，第一层一定是N个，拥有第二个期望是 N/2，第三层 N/4……</p><p>从最高层开始找…..</p><p> <strong>由高层到底层建立了索引关系</strong> </p><p>可以收敛到 logN</p><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><ol><li>每一个结点非红即黑</li><li>头结点黑 叶节点黑</li><li>红结点的子结点为黑（两红不相邻）</li><li>从任何一个结点到每一个叶节点的所有路径上黑结点一样多</li><li>最长链黑红黑红黑红黑…最短链黑黑黑黑</li></ol><p>1）平衡性规定非常诡异<br>2）平衡性调整最为复杂（插入5种，删除8种）<br>3）优点在于每次插入删除扰动较好，但是在今天看来这个优势也极其微弱了<br>原因：贪图插入频繁 扰动小的话，底层硬盘组织的 B+树、2-3-4树可能更好，还是那句话，到底图什么<br>4）除此之外，红黑树并不比AVL树、SB树、跳表更加优秀</p><p>红黑树在纯插入和纯查询这两者之间达到了一种平衡</p><p>redis为什么用跳表？</p><p>可能有序列化要求，skiplist好序列化</p><h2 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h2><h3 id="数组区间问题"><a href="#数组区间问题" class="headerlink" title="数组区间问题"></a>数组区间问题</h3><p>二维数组，每一行都有序，想找到一个左闭右闭的区间。</p><p>使每一个数组总有一个数字命中在区间里面；</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210404202146.png"></p><blockquote><p>流程</p></blockquote><p>第一回把数组中第0个数放到有序表里面</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210404202449.png"></p><p>找到了有序表中的一个区间，最小值和最大构成 [1, 5]</p><p>有序表中弹出最小的，来自于谁，把谁的下一个数字扔进来，拍完后[3, 5]</p><p>比原来更窄，记上新答案；</p><p>再弹出，把来源下一个数字9加入，[4, 9]</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210404202708.png"></p><h3 id="改写有序表（子数组累加和区间问题）"><a href="#改写有序表（子数组累加和区间问题）" class="headerlink" title="改写有序表（子数组累加和区间问题）"></a>改写有序表（子数组累加和区间问题）</h3><p>给定一个数组arr，和两个整数a和b（a&lt;=b）<br>求arr中有多少个子数组，累加和在[a,b]这个范围上<br>返回达标的子数组数量</p><p>假设 0 - i整体累加和是100，如果 0 -j的累加和是 80， j + 1 - i的累加和是20</p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210404233611.png" style="zoom:50%;" /><p>如果子数组必须以i位置数结尾的情况下，多少子数组最后累加和可以 10 - 30？</p><p>等于求 0 - i - 1 多少前缀和范围在 70 - 90 范围上</p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210404233846.png" style="zoom:50%;" /><p>问题就转化为了求前缀和</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210404234149.png"></p><p>就变成找到一种结构，存储前缀和</p><p>这种结构可以add() 允许重复值，给一个上界和下界求范围上多少个</p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210404234741.png" style="zoom:50%;" /><p>求[L, R]可以先求小于R + 1；再求小于 L，减一下即可；</p><blockquote><p>怎么让有序表允许增加重复</p></blockquote><p>增加一个字段 all，计算到达次数。</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210404235507.png"></p><p>往左滑 ans不获得任何数据</p><p>往右滑 ans获得头结点减去右的信息</p><p>找到6 不用滑了 如果6有左树加上左树的量</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SBTNode</span> </span>&#123;   <span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> key;   <span class="hljs-keyword">public</span> SBTNode l;   <span class="hljs-keyword">public</span> SBTNode r;   <span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> size; <span class="hljs-comment">// 不同key的size</span>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> all; <span class="hljs-comment">// 总的size</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SBTNode</span><span class="hljs-params">(<span class="hljs-keyword">long</span> k)</span> </span>&#123;      key = k;      size = <span class="hljs-number">1</span>;      all = <span class="hljs-number">1</span>;   &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SizeBalancedTreeSet</span> </span>&#123;   <span class="hljs-keyword">private</span> SBTNode root;   <span class="hljs-keyword">private</span> HashSet&lt;Long&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();   <span class="hljs-function"><span class="hljs-keyword">private</span> SBTNode <span class="hljs-title">rightRotate</span><span class="hljs-params">(SBTNode cur)</span> </span>&#123;      <span class="hljs-keyword">long</span> same = cur.all - (cur.l != <span class="hljs-keyword">null</span> ? cur.l.all : <span class="hljs-number">0</span>) - (cur.r != <span class="hljs-keyword">null</span> ? cur.r.all : <span class="hljs-number">0</span>);      SBTNode leftNode = cur.l;      cur.l = leftNode.r;      leftNode.r = cur;      leftNode.size = cur.size;      cur.size = (cur.l != <span class="hljs-keyword">null</span> ? cur.l.size : <span class="hljs-number">0</span>) + (cur.r != <span class="hljs-keyword">null</span> ? cur.r.size : <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>;      <span class="hljs-comment">// all modify</span>      leftNode.all = cur.all;      cur.all = (cur.l != <span class="hljs-keyword">null</span> ? cur.l.all : <span class="hljs-number">0</span>) + (cur.r != <span class="hljs-keyword">null</span> ? cur.r.all : <span class="hljs-number">0</span>) + same;      <span class="hljs-keyword">return</span> leftNode;   &#125;   <span class="hljs-function"><span class="hljs-keyword">private</span> SBTNode <span class="hljs-title">leftRotate</span><span class="hljs-params">(SBTNode cur)</span> </span>&#123;      <span class="hljs-keyword">long</span> same = cur.all - (cur.l != <span class="hljs-keyword">null</span> ? cur.l.all : <span class="hljs-number">0</span>) - (cur.r != <span class="hljs-keyword">null</span> ? cur.r.all : <span class="hljs-number">0</span>);      SBTNode rightNode = cur.r;      cur.r = rightNode.l;      rightNode.l = cur;      rightNode.size = cur.size;      cur.size = (cur.l != <span class="hljs-keyword">null</span> ? cur.l.size : <span class="hljs-number">0</span>) + (cur.r != <span class="hljs-keyword">null</span> ? cur.r.size : <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>;      <span class="hljs-comment">// all modify</span>      rightNode.all = cur.all;      cur.all = (cur.l != <span class="hljs-keyword">null</span> ? cur.l.all : <span class="hljs-number">0</span>) + (cur.r != <span class="hljs-keyword">null</span> ? cur.r.all : <span class="hljs-number">0</span>) + same;      <span class="hljs-keyword">return</span> rightNode;   &#125;   <span class="hljs-function"><span class="hljs-keyword">private</span> SBTNode <span class="hljs-title">matain</span><span class="hljs-params">(SBTNode cur)</span> </span>&#123;      <span class="hljs-keyword">if</span> (cur == <span class="hljs-keyword">null</span>) &#123;         <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;      &#125;      <span class="hljs-keyword">if</span> (cur.l != <span class="hljs-keyword">null</span> &amp;&amp; cur.l.l != <span class="hljs-keyword">null</span> &amp;&amp; cur.r != <span class="hljs-keyword">null</span> &amp;&amp; cur.l.l.size &gt; cur.r.size) &#123;         cur = rightRotate(cur);         cur.r = matain(cur.r);         cur = matain(cur);      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cur.l != <span class="hljs-keyword">null</span> &amp;&amp; cur.l.r != <span class="hljs-keyword">null</span> &amp;&amp; cur.r != <span class="hljs-keyword">null</span> &amp;&amp; cur.l.r.size &gt; cur.r.size) &#123;         cur.l = leftRotate(cur.l);         cur = rightRotate(cur);         cur.l = matain(cur.l);         cur.r = matain(cur.r);         cur = matain(cur);      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cur.r != <span class="hljs-keyword">null</span> &amp;&amp; cur.r.r != <span class="hljs-keyword">null</span> &amp;&amp; cur.l != <span class="hljs-keyword">null</span> &amp;&amp; cur.r.r.size &gt; cur.l.size) &#123;         cur = leftRotate(cur);         cur.l = matain(cur.l);         cur = matain(cur);      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cur.r != <span class="hljs-keyword">null</span> &amp;&amp; cur.r.l != <span class="hljs-keyword">null</span> &amp;&amp; cur.l != <span class="hljs-keyword">null</span> &amp;&amp; cur.r.l.size &gt; cur.l.size) &#123;         cur.r = rightRotate(cur.r);         cur = leftRotate(cur);         cur.l = matain(cur.l);         cur.r = matain(cur.r);         cur = matain(cur);      &#125;      <span class="hljs-keyword">return</span> cur;   &#125;   <span class="hljs-function"><span class="hljs-keyword">private</span> SBTNode <span class="hljs-title">add</span><span class="hljs-params">(SBTNode cur, <span class="hljs-keyword">long</span> key, <span class="hljs-keyword">boolean</span> contains)</span> </span>&#123;      <span class="hljs-keyword">if</span> (cur == <span class="hljs-keyword">null</span>) &#123;         <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SBTNode(key);      &#125; <span class="hljs-keyword">else</span> &#123;         cur.all++;         <span class="hljs-keyword">if</span> (key == cur.key) &#123;            <span class="hljs-keyword">return</span> cur;         &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 还在左滑或者右滑</span>            <span class="hljs-keyword">if</span> (!contains) &#123;               cur.size++;            &#125;            <span class="hljs-keyword">if</span> (key &lt; cur.key) &#123;               cur.l = add(cur.l, key, contains);            &#125; <span class="hljs-keyword">else</span> &#123;               cur.r = add(cur.r, key, contains);            &#125;            <span class="hljs-keyword">return</span> matain(cur);         &#125;      &#125;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">long</span> sum)</span> </span>&#123;      <span class="hljs-keyword">boolean</span> contains = set.contains(sum);      root = add(root, sum, contains);      set.add(sum);   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">lessKeySize</span><span class="hljs-params">(<span class="hljs-keyword">long</span> key)</span> </span>&#123;      SBTNode cur = root;      <span class="hljs-keyword">long</span> ans = <span class="hljs-number">0</span>;      <span class="hljs-keyword">while</span> (cur != <span class="hljs-keyword">null</span>) &#123;         <span class="hljs-keyword">if</span> (key == cur.key) &#123;            <span class="hljs-keyword">return</span> ans + (cur.l != <span class="hljs-keyword">null</span> ? cur.l.all : <span class="hljs-number">0</span>);         &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key &lt; cur.key) &#123;            cur = cur.l;         &#125; <span class="hljs-keyword">else</span> &#123;            ans += cur.all - (cur.r != <span class="hljs-keyword">null</span> ? cur.r.all : <span class="hljs-number">0</span>);            cur = cur.r;         &#125;      &#125;      <span class="hljs-keyword">return</span> ans;   &#125;   <span class="hljs-comment">// &gt; 7 8...</span>   <span class="hljs-comment">// &lt;8 ...&lt;=7</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">moreKeySize</span><span class="hljs-params">(<span class="hljs-keyword">long</span> key)</span> </span>&#123;      <span class="hljs-keyword">return</span> root != <span class="hljs-keyword">null</span> ? (root.all - lessKeySize(key + <span class="hljs-number">1</span>)) : <span class="hljs-number">0</span>;   &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">countRangeSum2</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> lower, <span class="hljs-keyword">int</span> upper)</span> </span>&#123;   SizeBalancedTreeSet treeSet = <span class="hljs-keyword">new</span> SizeBalancedTreeSet();   <span class="hljs-keyword">long</span> sum = <span class="hljs-number">0</span>;   <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;   treeSet.add(<span class="hljs-number">0</span>);<span class="hljs-comment">// 一个数都没有 已经有一个前缀和0</span>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;      sum += nums[i];      <span class="hljs-comment">// sum i结尾的时候[lower, upper]</span>      <span class="hljs-comment">// 先求之前有多少在[sum - upper, sum - lower]</span>      <span class="hljs-comment">// 查 ? &lt; sum - lower + 1 a</span>      <span class="hljs-comment">// 查 ? &lt; sum - upper b</span>      <span class="hljs-comment">// a - b</span>      <span class="hljs-keyword">long</span> a = treeSet.lessKeySize(sum - lower + <span class="hljs-number">1</span>);      <span class="hljs-keyword">long</span> b = treeSet.lessKeySize(sum - upper);      ans += a - b;      treeSet.add(sum);   &#125;   <span class="hljs-keyword">return</span> ans;&#125;</code></pre><h3 id="滑动窗口中位数"><a href="#滑动窗口中位数" class="headerlink" title="滑动窗口中位数"></a>滑动窗口中位数</h3><p>有一个滑动窗口（讲过的）：</p><p>1）L是滑动窗口最左位置、R是滑动窗口最右位置，一开始LR都在数组左侧<br>2）任何一步都可能R往右动，表示某个数进了窗口<br>3）任何一步都可能L往右动，表示某个数出了窗口</p><p>想知道每一个窗口状态的中位数(严格的中位数)</p><p>增加重复数字，允许删掉一次，得到第小K的函数就行</p><p>从头部开始滑，左孩子如果都小K，看自己，再看右边….</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SBTNode</span>&lt;<span class="hljs-title">K</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">K</span>&gt;&gt; </span>&#123;   <span class="hljs-keyword">public</span> K key;   <span class="hljs-keyword">public</span> SBTNode&lt;K&gt; l;   <span class="hljs-keyword">public</span> SBTNode&lt;K&gt; r;   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> size;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SBTNode</span><span class="hljs-params">(K k)</span> </span>&#123;      key = k;      size = <span class="hljs-number">1</span>;   &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SizeBalancedTreeMap</span>&lt;<span class="hljs-title">K</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">K</span>&gt;&gt; </span>&#123;   <span class="hljs-keyword">private</span> SBTNode&lt;K&gt; root;   <span class="hljs-function"><span class="hljs-keyword">private</span> SBTNode&lt;K&gt; <span class="hljs-title">rightRotate</span><span class="hljs-params">(SBTNode&lt;K&gt; cur)</span> </span>&#123;      SBTNode&lt;K&gt; leftNode = cur.l;      cur.l = leftNode.r;      leftNode.r = cur;      leftNode.size = cur.size;      cur.size = (cur.l != <span class="hljs-keyword">null</span> ? cur.l.size : <span class="hljs-number">0</span>) + (cur.r != <span class="hljs-keyword">null</span> ? cur.r.size : <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>;      <span class="hljs-keyword">return</span> leftNode;   &#125;   <span class="hljs-function"><span class="hljs-keyword">private</span> SBTNode&lt;K&gt; <span class="hljs-title">leftRotate</span><span class="hljs-params">(SBTNode&lt;K&gt; cur)</span> </span>&#123;      SBTNode&lt;K&gt; rightNode = cur.r;      cur.r = rightNode.l;      rightNode.l = cur;      rightNode.size = cur.size;      cur.size = (cur.l != <span class="hljs-keyword">null</span> ? cur.l.size : <span class="hljs-number">0</span>) + (cur.r != <span class="hljs-keyword">null</span> ? cur.r.size : <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>;      <span class="hljs-keyword">return</span> rightNode;   &#125;   <span class="hljs-function"><span class="hljs-keyword">private</span> SBTNode&lt;K&gt; <span class="hljs-title">matain</span><span class="hljs-params">(SBTNode&lt;K&gt; cur)</span> </span>&#123;      <span class="hljs-keyword">if</span> (cur == <span class="hljs-keyword">null</span>) &#123;         <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;      &#125;      <span class="hljs-keyword">if</span> (cur.l != <span class="hljs-keyword">null</span> &amp;&amp; cur.l.l != <span class="hljs-keyword">null</span> &amp;&amp; cur.r != <span class="hljs-keyword">null</span> &amp;&amp; cur.l.l.size &gt; cur.r.size) &#123;         cur = rightRotate(cur);         cur.r = matain(cur.r);         cur = matain(cur);      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cur.l != <span class="hljs-keyword">null</span> &amp;&amp; cur.l.r != <span class="hljs-keyword">null</span> &amp;&amp; cur.r != <span class="hljs-keyword">null</span> &amp;&amp; cur.l.r.size &gt; cur.r.size) &#123;         cur.l = leftRotate(cur.l);         cur = rightRotate(cur);         cur.l = matain(cur.l);         cur.r = matain(cur.r);         cur = matain(cur);      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cur.r != <span class="hljs-keyword">null</span> &amp;&amp; cur.r.r != <span class="hljs-keyword">null</span> &amp;&amp; cur.l != <span class="hljs-keyword">null</span> &amp;&amp; cur.r.r.size &gt; cur.l.size) &#123;         cur = leftRotate(cur);         cur.l = matain(cur.l);         cur = matain(cur);      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cur.r != <span class="hljs-keyword">null</span> &amp;&amp; cur.r.l != <span class="hljs-keyword">null</span> &amp;&amp; cur.l != <span class="hljs-keyword">null</span> &amp;&amp; cur.r.l.size &gt; cur.l.size) &#123;         cur.r = rightRotate(cur.r);         cur = leftRotate(cur);         cur.l = matain(cur.l);         cur.r = matain(cur.r);         cur = matain(cur);      &#125;      <span class="hljs-keyword">return</span> cur;   &#125;   <span class="hljs-function"><span class="hljs-keyword">private</span> SBTNode&lt;K&gt; <span class="hljs-title">findLastIndex</span><span class="hljs-params">(K key)</span> </span>&#123;      SBTNode&lt;K&gt; pre = root;      SBTNode&lt;K&gt; cur = root;      <span class="hljs-keyword">while</span> (cur != <span class="hljs-keyword">null</span>) &#123;         pre = cur;         <span class="hljs-keyword">if</span> (key.compareTo(cur.key) == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">break</span>;         &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key.compareTo(cur.key) &lt; <span class="hljs-number">0</span>) &#123;            cur = cur.l;         &#125; <span class="hljs-keyword">else</span> &#123;            cur = cur.r;         &#125;      &#125;      <span class="hljs-keyword">return</span> pre;   &#125;   <span class="hljs-function"><span class="hljs-keyword">private</span> SBTNode&lt;K&gt; <span class="hljs-title">add</span><span class="hljs-params">(SBTNode&lt;K&gt; cur, K key)</span> </span>&#123;      <span class="hljs-keyword">if</span> (cur == <span class="hljs-keyword">null</span>) &#123;         <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SBTNode&lt;K&gt;(key);      &#125; <span class="hljs-keyword">else</span> &#123;         cur.size++;         <span class="hljs-keyword">if</span> (key.compareTo(cur.key) &lt; <span class="hljs-number">0</span>) &#123;            cur.l = add(cur.l, key);         &#125; <span class="hljs-keyword">else</span> &#123;            cur.r = add(cur.r, key);         &#125;         <span class="hljs-keyword">return</span> matain(cur);      &#125;   &#125;   <span class="hljs-function"><span class="hljs-keyword">private</span> SBTNode&lt;K&gt; <span class="hljs-title">delete</span><span class="hljs-params">(SBTNode&lt;K&gt; cur, K key)</span> </span>&#123;      cur.size--;      <span class="hljs-keyword">if</span> (key.compareTo(cur.key) &gt; <span class="hljs-number">0</span>) &#123;         cur.r = delete(cur.r, key);      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key.compareTo(cur.key) &lt; <span class="hljs-number">0</span>) &#123;         cur.l = delete(cur.l, key);      &#125; <span class="hljs-keyword">else</span> &#123;         <span class="hljs-keyword">if</span> (cur.l == <span class="hljs-keyword">null</span> &amp;&amp; cur.r == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-comment">// free cur memory -&gt; C++</span>            cur = <span class="hljs-keyword">null</span>;         &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cur.l == <span class="hljs-keyword">null</span> &amp;&amp; cur.r != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-comment">// free cur memory -&gt; C++</span>            cur = cur.r;         &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cur.l != <span class="hljs-keyword">null</span> &amp;&amp; cur.r == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-comment">// free cur memory -&gt; C++</span>            cur = cur.l;         &#125; <span class="hljs-keyword">else</span> &#123;            SBTNode&lt;K&gt; pre = <span class="hljs-keyword">null</span>;            SBTNode&lt;K&gt; des = cur.r;            des.size--;            <span class="hljs-keyword">while</span> (des.l != <span class="hljs-keyword">null</span>) &#123;               pre = des;               des = des.l;               des.size--;            &#125;            <span class="hljs-keyword">if</span> (pre != <span class="hljs-keyword">null</span>) &#123;               pre.l = des.r;               des.r = cur.r;            &#125;            des.l = cur.l;            des.size = des.l.size + (des.r == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : des.r.size) + <span class="hljs-number">1</span>;            <span class="hljs-comment">// free cur memory -&gt; C++</span>            cur = des;         &#125;      &#125;      <span class="hljs-keyword">return</span> cur;   &#125;   <span class="hljs-function"><span class="hljs-keyword">private</span> SBTNode&lt;K&gt; <span class="hljs-title">getIndex</span><span class="hljs-params">(SBTNode&lt;K&gt; cur, <span class="hljs-keyword">int</span> kth)</span> </span>&#123;      <span class="hljs-keyword">if</span> (kth == (cur.l != <span class="hljs-keyword">null</span> ? cur.l.size : <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>) &#123;         <span class="hljs-keyword">return</span> cur;      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (kth &lt;= (cur.l != <span class="hljs-keyword">null</span> ? cur.l.size : <span class="hljs-number">0</span>)) &#123;         <span class="hljs-keyword">return</span> getIndex(cur.l, kth);      &#125; <span class="hljs-keyword">else</span> &#123;         <span class="hljs-keyword">return</span> getIndex(cur.r, kth - (cur.l != <span class="hljs-keyword">null</span> ? cur.l.size : <span class="hljs-number">0</span>) - <span class="hljs-number">1</span>);      &#125;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> root == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : root.size;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">containsKey</span><span class="hljs-params">(K key)</span> </span>&#123;      <span class="hljs-keyword">if</span> (key == <span class="hljs-keyword">null</span>) &#123;         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;invalid parameter.&quot;</span>);      &#125;      SBTNode&lt;K&gt; lastNode = findLastIndex(key);      <span class="hljs-keyword">return</span> lastNode != <span class="hljs-keyword">null</span> &amp;&amp; key.compareTo(lastNode.key) == <span class="hljs-number">0</span> ? <span class="hljs-keyword">true</span> : <span class="hljs-keyword">false</span>;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(K key)</span> </span>&#123;      <span class="hljs-keyword">if</span> (key == <span class="hljs-keyword">null</span>) &#123;         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;invalid parameter.&quot;</span>);      &#125;      SBTNode&lt;K&gt; lastNode = findLastIndex(key);      <span class="hljs-keyword">if</span> (lastNode == <span class="hljs-keyword">null</span> || key.compareTo(lastNode.key) != <span class="hljs-number">0</span>) &#123;         root = add(root, key);      &#125;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(K key)</span> </span>&#123;      <span class="hljs-keyword">if</span> (key == <span class="hljs-keyword">null</span>) &#123;         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;invalid parameter.&quot;</span>);      &#125;      <span class="hljs-keyword">if</span> (containsKey(key)) &#123;         root = delete(root, key);      &#125;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> K <span class="hljs-title">getIndexKey</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;      <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt;= <span class="hljs-keyword">this</span>.size()) &#123;         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;invalid parameter.&quot;</span>);      &#125;      <span class="hljs-keyword">return</span> getIndex(root, index + <span class="hljs-number">1</span>).key;   &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">Node</span>&gt; </span>&#123;   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> index;   <span class="hljs-comment">// 先根据value排序，再排序index</span>   <span class="hljs-comment">// 5第一次出现 再5第二次出现前面</span>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> value;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> v)</span> </span>&#123;      index = i;      value = v;   &#125;   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(Node o)</span> </span>&#123;      <span class="hljs-keyword">return</span> value != o.value ? Integer.valueOf(value).compareTo(o.value)            : Integer.valueOf(index).compareTo(o.index);   &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">double</span>[] medianSlidingWindow(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k) &#123;   SizeBalancedTreeMap&lt;Node&gt; map = <span class="hljs-keyword">new</span> SizeBalancedTreeMap&lt;&gt;();   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k - <span class="hljs-number">1</span>; i++) &#123;      map.add(<span class="hljs-keyword">new</span> Node(i, nums[i]));   &#125;   <span class="hljs-keyword">double</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-keyword">double</span>[nums.length - k + <span class="hljs-number">1</span>];   <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = k - <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;      map.add(<span class="hljs-keyword">new</span> Node(i, nums[i]));      <span class="hljs-keyword">if</span> (map.size() % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;         Node upmid = map.getIndexKey(map.size() / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>);         Node downmid = map.getIndexKey(map.size() / <span class="hljs-number">2</span>);         ans[index++] = ((<span class="hljs-keyword">double</span>) upmid.value + (<span class="hljs-keyword">double</span>) downmid.value) / <span class="hljs-number">2</span>;      &#125; <span class="hljs-keyword">else</span> &#123;         Node mid = map.getIndexKey(map.size() / <span class="hljs-number">2</span>);         ans[index++] = (<span class="hljs-keyword">double</span>) mid.value;      &#125;      map.remove(<span class="hljs-keyword">new</span> Node(i - k + <span class="hljs-number">1</span>, nums[i - k + <span class="hljs-number">1</span>]));   &#125;   <span class="hljs-keyword">return</span> ans;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指offer</title>
    <link href="/2020/12/25/%E5%89%91%E6%8C%87offer/"/>
    <url>/2020/12/25/%E5%89%91%E6%8C%87offer/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>开始更新了！</p><h1 id="数组和字符串"><a href="#数组和字符串" class="headerlink" title="数组和字符串"></a>数组和字符串</h1><h2 id="04-二维数组中的查找"><a href="#04-二维数组中的查找" class="headerlink" title="04. 二维数组中的查找"></a>04. 二维数组中的查找</h2><p>在一个 n * m 的二维数组中，每一行都按照 <strong>从左到右递增</strong> 的顺序排序，每一列都按照 <strong>从上到下递增</strong> 的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><blockquote><p>示例</p></blockquote><p>[<br>  [1,   4,  7, 11, 15],<br>  [2,   5,  8, 12, 19],<br>  [3,   6,  9, 16, 22],<br>  [10, 13, 14, 17, 24],<br>  [18, 21, 23, 26, 30]<br>]</p><p>给定 target = <code>5</code>，返回 <code>true</code>。</p><p>给定 target = <code>20</code>，返回 <code>false</code>。</p><h3 id="错误的贪心策略"><a href="#错误的贪心策略" class="headerlink" title="错误的贪心策略"></a>错误的贪心策略</h3><p class="note note-danger"> 错误策略 </p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201230105314.png" alt="错误"></p><p>我们找 <strong>对角线</strong>，当上一个对角线值小于target并且下一个对角线值大于target的时候，我们从上一个开始往右和往下找，即可以盲目遍历，也可以在新位置进行新的找对角线。</p><p>代码很 <strong>复杂</strong>， 判断的条件多。</p><p>能解决很多的例子：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201230105549.png" alt="例子"></p><p>但为什么是错误的？</p><p>我们仔细看上面一张图，是否出现遗漏区域：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201230105641.png" alt="遗漏区域"></p><p>框所示，为遗漏区域，所以当矩阵为：</p><p>[[1,3,5,7,9],</p><p>[2,4,6,8,10],</p><p>[11,13,15,17,19],</p><p>[12,14,16,18,20],</p><p>[21,22,23,24,25]]</p><p>我们是找不到11的，因为我们定的位置在 4 - 13，开始找4右边和4下面，这两个位置都没有11，11在第一列中。</p><h3 id="正确的贪心策略"><a href="#正确的贪心策略" class="headerlink" title="正确的贪心策略"></a>正确的贪心策略</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201230110103.png" alt="正确策略"></p><p>我们利用左下角位置，上面都小，右边都大的策略，</p><p>如果发现当前cur 小于 target 往右找；cur 大于 target 往上找，直到出边界或者找到为止。</p><p>Code:</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">findNumberIn2DArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix, <span class="hljs-keyword">int</span> target)</span> </span>&#123;      <span class="hljs-keyword">int</span> n = matrix.length; <span class="hljs-comment">// 行数</span>      <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>)&#123;          <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;      &#125;      <span class="hljs-keyword">int</span> m = matrix[<span class="hljs-number">0</span>].length; <span class="hljs-comment">// 列</span>      <span class="hljs-keyword">if</span> (m == <span class="hljs-number">0</span>)&#123;          <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;      &#125;      <span class="hljs-keyword">int</span> row = n - <span class="hljs-number">1</span>; <span class="hljs-comment">// 行数</span>      <span class="hljs-keyword">int</span> col = <span class="hljs-number">0</span>; <span class="hljs-comment">// 列数</span>      <span class="hljs-keyword">while</span> ( row &gt;= <span class="hljs-number">0</span> &amp;&amp; col &lt; m)&#123;          <span class="hljs-keyword">if</span> (matrix[row][col] == target)&#123;              <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;          &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (matrix[row][col] &gt; target)&#123;              row --;          &#125; <span class="hljs-keyword">else</span> &#123;              col ++;          &#125;      &#125;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;  &#125;</code></pre><h2 id="05-替换空格"><a href="#05-替换空格" class="headerlink" title="05. 替换空格"></a>05. 替换空格</h2><p> <a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/">05. 替换空格</a></p><p>请实现一个函数，把字符串 <code>s</code> 中的每个空格替换成”%20”。</p><blockquote><p>示例</p></blockquote><pre><code class="hljs perl">输入：<span class="hljs-keyword">s</span> = <span class="hljs-string">&quot;We are happy.&quot;</span>输出：<span class="hljs-string">&quot;We%20are%20happy.&quot;</span></code></pre><p class="note note-primary"> 三种方式实现，思考String Builder底层 </p><h3 id="java自带api"><a href="#java自带api" class="headerlink" title="java自带api"></a>java自带api</h3><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">replaceSpace</span><span class="hljs-params">(String s)</span> </span>&#123;    <span class="hljs-keyword">return</span> s.replace(<span class="hljs-string">&quot; &quot;</span>, <span class="hljs-string">&quot;%20&quot;</span>);&#125;</code></pre><p>一行代码解决问题</p><h3 id="String-Builder追加"><a href="#String-Builder追加" class="headerlink" title="String Builder追加"></a>String Builder追加</h3><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">replaceSpace1</span><span class="hljs-params">(String s)</span> </span>&#123;    <span class="hljs-keyword">char</span>[] chars = s.toCharArray();    StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; chars.length; i ++)&#123;        <span class="hljs-keyword">if</span> (chars[i] != <span class="hljs-string">&#x27; &#x27;</span>)&#123;            sb.append(chars[i]);        &#125;<span class="hljs-keyword">else</span> &#123;            sb.append(<span class="hljs-string">&quot;%20&quot;</span>);        &#125;       &#125;    <span class="hljs-keyword">return</span> sb.toString();&#125;</code></pre><h3 id="静态char数组"><a href="#静态char数组" class="headerlink" title="静态char数组"></a>静态char数组</h3><p> <strong>StringBuilder</strong> ，本质上是一个 <strong>char</strong> 类型的 <strong>动态数组</strong>：</p><p>当初始化 StringBuilder 的时候，会初始化一个固定长度的 char 类型的数组<br>当往 StringBuilder 中 append 数据的时候，其实就是往 char 类型的数组最后追加数据</p><p>但是 <strong>扩容</strong> 这个过程是有损性能的，我们可以直接设置一个 三倍长度的静态char[]数组</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">replaceSpace</span><span class="hljs-params">(String s)</span> </span>&#123;        <span class="hljs-keyword">char</span>[] chars = s.toCharArray();        <span class="hljs-keyword">int</span> n = chars.length;        <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;        <span class="hljs-keyword">char</span>[] append = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">3</span> * n];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; chars.length; i ++)&#123;            <span class="hljs-keyword">if</span> (chars[i] == <span class="hljs-string">&#x27; &#x27;</span>)&#123;                append[j++] = <span class="hljs-string">&#x27;%&#x27;</span>;                append[j++] = <span class="hljs-string">&#x27;2&#x27;</span>;                append[j++] = <span class="hljs-string">&#x27;0&#x27;</span>;            &#125;<span class="hljs-keyword">else</span> &#123;                append[j++] = chars[i];            &#125;                 &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(append, <span class="hljs-number">0</span>, j);    &#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201230142311.png" alt="图解"></p><h2 id="剑指-Offer-45-把数组排成最小的数"><a href="#剑指-Offer-45-把数组排成最小的数" class="headerlink" title="剑指 Offer 45. 把数组排成最小的数"></a>剑指 Offer 45. 把数组排成最小的数</h2><p><a href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/">剑指 Offer 45. 把数组排成最小的数</a></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210104082536.png" alt="question"></p><p>思路，参考：</p><p>重写 <strong>比较器</strong> <a href="https://blog.qiukework.top/2020/11/25/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/#%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95">贪心字典序问题</a></p><p>即 x,y比较拼接后大小,需要比较 xy和yx</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">minNumber</span> <span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">if</span> (nums == <span class="hljs-keyword">null</span> || nums.length == <span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;        &#125;        String[] strs = <span class="hljs-keyword">new</span> String[nums.length];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i ++)&#123;            strs[i] = <span class="hljs-string">&quot;&quot;</span> + nums[i];        &#125;                    Arrays.sort(strs, <span class="hljs-keyword">new</span> MyComparator1());        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; strs.length;i++ )&#123;            sb.append(strs[i]);        &#125;        <span class="hljs-keyword">return</span> sb.toString();    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyComparator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparator</span>&lt;<span class="hljs-title">String</span>&gt; </span>&#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(String a, String b)</span> </span>&#123;            <span class="hljs-keyword">return</span> (a + b).compareTo(b + a);        &#125;    &#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>剑指offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode</title>
    <link href="/2020/12/25/leetcode/"/>
    <url>/2020/12/25/leetcode/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="188-买卖股票-IV"><a href="#188-买卖股票-IV" class="headerlink" title="188. 买卖股票 IV"></a>188. 买卖股票 IV</h2><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/">188. 买卖股票的最佳时机 IV</a></p><p class="note note-primary">买卖股票有六种题型，后续更新</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201228180405.png" alt="question"></p><p>状态图：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201229091140.png" alt="状态图"></p><p>由题意分析，不难得出：</p><ul><li><p>如果状态是是 <strong>买入</strong> :</p><ul><li>那么可以 <strong>保持不动</strong></li><li>或者马上 <strong>卖掉</strong></li></ul></li><li><p>如果状态是 <strong>卖出</strong>:</p><ul><li>可以 <strong>保持不动</strong> (等待更好的股价出现，暂时不买)</li><li>或者 <strong>立马再买一股</strong></li><li>同时将count数+1，表示交易过一次了</li></ul></li></ul><h3 id="暴力递归思考问题"><a href="#暴力递归思考问题" class="headerlink" title="暴力递归思考问题"></a>暴力递归思考问题</h3><p>我们可以用 <strong>三个变量</strong> 来表示买卖k次的交易状态</p><ul><li>index，用来表示 <strong>当前是哪一天</strong></li><li>status，用来表示 <strong>当前是买入、还是卖出</strong> </li><li>count，用来表示 <strong>交易了几次</strong></li></ul><p>暴力法中我们尝试所有的解决策略：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201229091330.png" alt="递归树"></p><pre><code class="hljs java">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;    <span class="hljs-comment">// 暴力</span>    <span class="hljs-keyword">if</span>(prices.length== <span class="hljs-number">0</span> || prices == <span class="hljs-keyword">null</span>)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, k, prices);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> status, <span class="hljs-keyword">int</span> count, <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span>[] prices)</span></span>&#123;    <span class="hljs-keyword">if</span> (count == k || index == prices.length) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-comment">// 保持不变</span>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>, b = <span class="hljs-number">0</span>, c = <span class="hljs-number">0</span>;    a = dfs(index + <span class="hljs-number">1</span>, status, count, k, prices);    <span class="hljs-keyword">if</span> (status == <span class="hljs-number">1</span>)&#123;        <span class="hljs-comment">// 卖出</span>        b = dfs(index + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, count + <span class="hljs-number">1</span>, k, prices) + prices[index];    &#125;<span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">// 买入</span>        c = dfs(index + <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, count, k, prices) - prices[index];    &#125;    <span class="hljs-keyword">return</span> Math.max(Math.max(a, b), c);&#125;</code></pre><h3 id="动态规划-1"><a href="#动态规划-1" class="headerlink" title="动态规划"></a>动态规划</h3><blockquote><p>三个参数三维表，但有一维为01，转为两个二维表</p></blockquote><p>我们再次回顾一下状态转化：</p><p>每次到达i位置时：</p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201229091455.png" alt="i位置" style="zoom:50%;" /><p>如果三维表最后一位 0表示卖出，1表示买入：</p><pre><code class="hljs js">第一次买入：从初始状态转换而来，或者第一次买入后保持不动#dp[i][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = max(dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>],dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]-prices[i])第一次卖出：从第一次买入转换而来，或者第一次卖出后保持不动#dp[i][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = max(dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>],dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]+prices[i])第二次买入：从第一次卖出转换而来，或者第二次买入后保持不动dp[i][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = max(dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>],dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]-prices[i])第二次卖出：从第二次买入转换而来，或者第二次卖出后保持不动dp[i][<span class="hljs-number">2</span>][<span class="hljs-number">0</span>] = max(dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">2</span>][<span class="hljs-number">0</span>],dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]+prices[i])第三次买入：dp[i][<span class="hljs-number">2</span>][<span class="hljs-number">1</span>] = max(dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">2</span>][<span class="hljs-number">1</span>],dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">2</span>][<span class="hljs-number">0</span>]-prices[i])第三次卖出：   dp[i][<span class="hljs-number">3</span>][<span class="hljs-number">0</span>] = max(dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">3</span>][<span class="hljs-number">0</span>],dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">2</span>][<span class="hljs-number">1</span>]+prices[i])</code></pre><p>扩展至j次交易的话：</p><pre><code class="hljs js">第k次买入： 从第k-<span class="hljs-number">1</span>次卖出转换而来，或者第k次买入后保持不动dp[i][j-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = max(dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>],dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]-prices[i])第k次卖出： 从第k次买入后转换而来，或者是第k次卖出后保持不动dp[i][j][<span class="hljs-number">0</span>] = max(dp[i-<span class="hljs-number">1</span>][j][<span class="hljs-number">0</span>],dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]+prices[i])第k+<span class="hljs-number">1</span>次买入：dp[i][j][<span class="hljs-number">1</span>] = max(dp[i-<span class="hljs-number">1</span>][j][<span class="hljs-number">1</span>],dp[i-<span class="hljs-number">1</span>][j][<span class="hljs-number">0</span>]-prices[i])</code></pre><p>因此我们设置 <strong>两张表</strong>：</p><p>buy和sell，都为二维表，这样就可以忽略三维表第三位：</p><p>我们的规则如下：</p><p> buy[i] [j]表示到达索引i时候，达成j次交易买入获得最大收益<br> sell[i] [j]表示到达索引i时候，达成j次交易卖出获得最大收益<br> buy[i] [j] = Math.max( buy[i - 1] [j], sell[i - 1] [j] - price[i])<br> sell[i] [j] = Math.max( sell[i - 1] [j], buy[i - 1] [j - 1] + price[i])</p><pre><code class="hljs java">    <span class="hljs-comment">// 动态规划</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;    <span class="hljs-keyword">if</span>(prices.length== <span class="hljs-number">0</span> || prices == <span class="hljs-keyword">null</span>)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">int</span> n = prices.length;    k = Math.min(n/<span class="hljs-number">2</span>, k);    <span class="hljs-comment">// 动态规划的意义</span>    <span class="hljs-comment">// buy[i][j]表示到达索引i时候，达成j次交易买入获得最大收益</span>    <span class="hljs-comment">// sell[i][j]表示到达索引i时候，达成j次交易卖出获得最大收益</span>    <span class="hljs-comment">// buy[i][j] = Math.max( buy[i - 1][j], sell[i - 1][j] - price[i])</span>    <span class="hljs-comment">// sell[i][j] = Math.max( sell[i - 1][j], buy[i - 1][j - 1] + price[i])</span>    <span class="hljs-keyword">int</span>[][] buy = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n][k + <span class="hljs-number">1</span>];    <span class="hljs-keyword">int</span>[][] sell = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n][k + <span class="hljs-number">1</span>];    buy[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = -prices[<span class="hljs-number">0</span>];    sell[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 注意：buy[0][i] 和 sell[0][i] 是没有意义的</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= k; ++i) &#123;        buy[<span class="hljs-number">0</span>][i] = sell[<span class="hljs-number">0</span>][i] = Integer.MIN_VALUE / <span class="hljs-number">2</span>;    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)&#123;        buy[i][<span class="hljs-number">0</span>] = Math.max( buy[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], sell[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] - prices[i]);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j&lt;= k; j++)&#123;            buy[i][j] = Math.max( buy[i - <span class="hljs-number">1</span>][j], sell[i - <span class="hljs-number">1</span>][j] - prices[i]);            sell[i][j] = Math.max( sell[i - <span class="hljs-number">1</span>][j], buy[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + prices[i]);        &#125;    &#125;    <span class="hljs-keyword">return</span> Arrays.stream(sell[n - <span class="hljs-number">1</span>]).max().getAsInt();&#125;</code></pre><h3 id="动态规划优化"><a href="#动态规划优化" class="headerlink" title="动态规划优化"></a>动态规划优化</h3><blockquote><p>空间优化</p></blockquote><p>上述中：</p><ul><li>外层的循环是n，即遍历数组</li><li>内层的循环是k，遍历k次交易</li></ul><p>不难看出上述二维表中的i并没有被实际用到</p><p>又或者说：状态转移方程中，<strong>buy[i] [j] 和 sell[i] [j] 都从 buy[i−1] [..] 以及 sell[i−1] [..] 转移而来</strong></p><pre><code class="hljs java">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;    <span class="hljs-comment">// 动态规划空间优化</span>    <span class="hljs-keyword">if</span>(prices.length== <span class="hljs-number">0</span> || prices == <span class="hljs-keyword">null</span>)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">int</span> n = prices.length;    k = Math.min(n/<span class="hljs-number">2</span>, k);    <span class="hljs-keyword">int</span>[] buy = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[k + <span class="hljs-number">1</span>];    <span class="hljs-keyword">int</span>[] sell = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[k + <span class="hljs-number">1</span>];    buy[<span class="hljs-number">0</span>] = -prices[<span class="hljs-number">0</span>];    sell[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 注意：buy[0][i] 和 sell[0][i] 是没有意义的</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= k; ++i) &#123;        buy[i] = sell[i] = Integer.MIN_VALUE / <span class="hljs-number">2</span>;    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)&#123;        buy[<span class="hljs-number">0</span>] = Math.max( buy[<span class="hljs-number">0</span>], sell[<span class="hljs-number">0</span>] - prices[i]);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j&lt;= k; j++)&#123;            buy[j] = Math.max( buy[j], sell[j] - prices[i]);            sell[j] = Math.max( sell[j], buy[j - <span class="hljs-number">1</span>] + prices[i]);        &#125;    &#125;    <span class="hljs-keyword">return</span> Arrays.stream(sell).max().getAsInt();&#125;</code></pre><p class="note note-danger">buy[0][i] 和 sell[0][i] 是没有意义的,必须值为负最小</p><h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><h2 id="330-按要求补齐数组"><a href="#330-按要求补齐数组" class="headerlink" title="330. 按要求补齐数组"></a>330. 按要求补齐数组</h2><p><a href="https://leetcode-cn.com/problems/patching-array/">330. 按要求补齐数组</a></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201229084726.png" alt="question"></p><h3 id="贪心策略"><a href="#贪心策略" class="headerlink" title="贪心策略"></a>贪心策略</h3><p>每次找到未被 <strong>数组nums</strong> 覆盖的 <strong>最小的整数x</strong>，在数组中 <strong>补充x</strong>，然后寻找下一个 <strong>未被覆盖的最小的整数</strong> ，重复上述步骤直到区间 [1,n] 中的所有数字都被覆盖。</p><p class="note note-primary">贪心原理及证明</p><p>对于正整数 x，如果区间 <strong>[1,x-1]</strong> 内的所有数字都已经被覆盖，且 x 在数组中，则区间 <strong>[1,2x-1]</strong> 内的所有数字也都被覆盖。证明如下。</p><p>对于任意  1≤y&lt;x，y 已经被覆盖，x 在数组中，因此 y+x 也被覆盖，区间 [x+1,2x-1]（即区间 [1,x-1] 内的每个数字加上 x 之后得到的区间）内的所有数字也被覆盖，由此可得区间 [1,2x-1] 内的所有数字都被覆盖。</p><p>直接看证明可能有点 <strong>晦涩难懂</strong> ，我们看一下 <strong>例子</strong> ：</p><p>对于数组[1, 5, 10] 要求加x个数字能够覆盖20，即[1, 20]。</p><p>1⃣️ 我们设 <strong>初始能够覆盖的边界</strong> 为boundary = 1，即当前我们还没开始遍历数组，我们的 <strong>初始覆盖范围为[1, 1)</strong></p><p>2⃣️ 现在我们开始遍历数组，从第一位开始，遍历到 1，当前数组自身第一个数就能够覆盖的范围为 [1, 1]，1&lt;= boundary，所以我们加上boundary，覆盖范围变成 <strong>[1, 1 + boundary)</strong> ，即[1, 2)，注意右边为 <strong>开区间</strong> ，你可以把boundary想象成 <strong>闭区间且初始没有覆盖为0</strong> ；</p><p>3⃣️ 我们再遍历下一位，来到5，此时我们发现 <strong>[1, 2) 无法遍历到 5</strong>，于是我们加入 <strong>最小的整数x</strong> ，寻找新覆盖范围，能否覆盖到5，我们加入的数正根据上述的 <strong>贪心原理及证明</strong> 规则中加入， 边界[1, 2)我们加入2，所以新的覆盖范围为[1, 4)，加入数加一，我们再次来到5，发现还是无法遍历到5，我们再加入最小整数x，新的覆盖范围为[1, 8)，加入数加一。</p><p>4⃣️ 我们又一次来到5，发现可以覆盖到5了，但数组中的5改怎么办呢？</p><p>即因为数组中5存在，所以我们需要扩大我们的覆盖范围，实际上就是覆盖范围加上5，变为 <strong>[1, 8 + 5)</strong> ，证明上述已经证明，下一次来到10，发现可以覆盖10，又因为数组中有10，所以我们再次更新覆盖范围 <strong>[1, 8 + 5 + 10)</strong> ，最后覆盖范围能够越过20.</p><h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><pre><code class="hljs java">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minPatches</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> n)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = nums.length;    <span class="hljs-comment">// 从1开始验证覆盖范围， 此时可覆盖的范围是[1,1)</span>    <span class="hljs-comment">// boundary表示连续覆盖范围的右边界</span>    <span class="hljs-keyword">long</span> boundary = <span class="hljs-number">1</span>;     <span class="hljs-comment">// count 表示 添加了几个数字</span>    <span class="hljs-comment">// i表示目前遍历到的nums中的index</span>    <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;     <span class="hljs-comment">// 若目前还没连续覆盖到n，则继续循环</span>    <span class="hljs-keyword">while</span> (boundary &lt;= n)&#123;        <span class="hljs-comment">// 原本覆盖范围为[1,add)，如果当前加入nums[i]到[i,boundary)中</span>        <span class="hljs-comment">// 那么此时可构成的连续覆盖范围就是[1,boundary + nums[i])</span>        <span class="hljs-keyword">if</span> ( (index &lt; len ) &amp;&amp; ( nums[index] &lt;= boundary ))&#123;            boundary += nums[index];            index++;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// 否则，那么目前由数组中原本的数字没法继续扩大为下一级别的连续范围，</span>            <span class="hljs-comment">// 则向数组中加入此时的右边界add，可覆盖[1,2boundary)范围  </span>            boundary = boundary &lt;&lt; <span class="hljs-number">1</span>;            count++;        &#125;    &#125;    <span class="hljs-keyword">return</span> count;&#125;</code></pre><p class="note note-danger">boundary应该小于等于n，该程序中边界为开区间 </p><h2 id="435-无重叠区间"><a href="#435-无重叠区间" class="headerlink" title="435. 无重叠区间"></a>435. 无重叠区间</h2><p><a href="https://leetcode-cn.com/problems/non-overlapping-intervals/">435. 无重叠区间</a></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210104083302.png" alt="question"></p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210104084026.png" alt="绿色为不相交" style="zoom:50%;" /><p>绿色区间就为不相交，我们需要先算出不相交的个数。</p><p>解题思路：</p><p>按照尾端排序（nlogn），排好序后对区间遍历，如果下一个start大于当前end，加一，求出不相交个数</p><p>总个数 - 不相交个数 就为需要 <strong>移除</strong> 的结果。</p><p>注意：初始一定会有一个区间不相交，初始count为1。</p><p>Code:</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">eraseOverlapIntervals</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] intervals)</span> </span>&#123;        <span class="hljs-keyword">return</span> intervals.length - findMaxIntervals(intervals);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findMaxIntervals</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] intervals)</span></span>&#123;        <span class="hljs-keyword">if</span> (intervals.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-comment">// 按 end 升序排序</span>        Arrays.sort(intervals, <span class="hljs-keyword">new</span> Comparator&lt;<span class="hljs-keyword">int</span>[]&gt;() &#123;            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span>[] b)</span> </span>&#123;                <span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>] - b[<span class="hljs-number">1</span>];            &#125;        &#125;);                <span class="hljs-comment">// 找不相交的最大区间数目</span>        <span class="hljs-comment">// 一开始定在第一个 ，如果下一个的左区间大于等于第一个的右区间</span>        <span class="hljs-comment">// 就不会相交</span>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> end = intervals[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] interval : intervals)&#123;            <span class="hljs-keyword">int</span> start = interval[<span class="hljs-number">0</span>];            <span class="hljs-keyword">if</span> (start &gt;= end)&#123;                count ++;                end = interval[<span class="hljs-number">1</span>];            &#125;        &#125;        <span class="hljs-keyword">return</span> count;    &#125;</code></pre><p class="note note-primary">下题为上题同一个模板的延展题</p><h2 id="452-用最少数量的箭引爆气球"><a href="#452-用最少数量的箭引爆气球" class="headerlink" title="452. 用最少数量的箭引爆气球"></a>452. 用最少数量的箭引爆气球</h2><p><a href="https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/">452. 用最少数量的箭引爆气球</a></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210104085016.png" alt="question"></p><p>同一个模板套入：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findMinArrowShots</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] points)</span> </span>&#123;        <span class="hljs-keyword">return</span> findMaxIntervals(points);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findMaxIntervals</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] intervals)</span></span>&#123;        <span class="hljs-keyword">if</span> (intervals.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-comment">// 按 end 升序排序</span>        Arrays.sort(intervals, (p1, p2) -&gt; p1[<span class="hljs-number">1</span>] &lt; p2[<span class="hljs-number">1</span>] ? -<span class="hljs-number">1</span> : <span class="hljs-number">1</span>);        <span class="hljs-comment">// 找不相交的最大区间数目</span>        <span class="hljs-comment">// 一开始定在第一个 ，如果下一个的左区间大于等于第一个的右区间</span>        <span class="hljs-comment">// 就不会相交</span>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> end = intervals[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] interval : intervals)&#123;            <span class="hljs-keyword">int</span> start = interval[<span class="hljs-number">0</span>];            <span class="hljs-keyword">if</span> (start &gt; end)&#123;                count ++;                end = interval[<span class="hljs-number">1</span>];            &#125;        &#125;        <span class="hljs-keyword">return</span> count;    &#125;</code></pre><p class="note note-danger">比较器必须写全</p><p>或者：</p><p>最近新增了Test Case， <code>[[-2147483646,-2147483645],[2147483646,2147483647]]</code> 就过不了了，这是因为差值过大而产生溢出。sort的时候不要用<code>a-b</code>来比较，要用<code>Integer.compare(a, b)</code>!!!</p><h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><h2 id="1046-最后一块石头的重量"><a href="#1046-最后一块石头的重量" class="headerlink" title="1046. 最后一块石头的重量"></a>1046. 最后一块石头的重量</h2><p><a href="https://leetcode-cn.com/problems/last-stone-weight/">1046. 最后一块石头的重量</a></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201230114619.png" alt="question"></p><p>方法很简单，只需要创建一个大根堆，每次取出两个数a，b，第一次取出的a一定大于等于b</p><p>如果a &gt; b，把 a - b放进去，如果 a = b，什么都不做</p><p class="note note-info"> 可以尝试自己手写堆结构实现 </p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lastStoneWeight</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] stones)</span> </span>&#123;        PriorityQueue&lt;Integer&gt; pq = <span class="hljs-keyword">new</span> PriorityQueue&lt;Integer&gt;((a, b) -&gt; b - a);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> stone : stones) &#123;            pq.offer(stone);        &#125;        <span class="hljs-keyword">while</span> (pq.size() &gt; <span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">int</span> a = pq.poll();            <span class="hljs-keyword">int</span> b = pq.poll();            <span class="hljs-keyword">if</span> (a &gt; b) &#123;                pq.offer(a - b);            &#125;        &#125;        <span class="hljs-keyword">return</span> pq.isEmpty() ? <span class="hljs-number">0</span> : pq.poll();    &#125;&#125;</code></pre><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="316-去除重复字母"><a href="#316-去除重复字母" class="headerlink" title="316. 去除重复字母"></a>316. 去除重复字母</h2><p><a href="https://leetcode-cn.com/problems/remove-duplicate-letters/">316. 去除重复字母</a></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210104080806.png" alt="question"></p><h3 id="栈解决思路"><a href="#栈解决思路" class="headerlink" title="栈解决思路"></a>栈解决思路</h3><p>例子：bcabc，预期结果为abc</p><p>我们准备一个数组，记录每个字符 <strong>最后一次</strong> 出现的位置，准备一个 <strong>栈</strong>， 准备一个数组 <strong>记录栈中是否存在该字符</strong> </p><p>每次都放入栈，放入前对栈遍历，记录当前来到字符为cur，如果栈中peek大于cur并且peek值 <strong>后续还会出现</strong> </p><p>那就弹出。</p><p>1⃣️ 来到b，加入栈，栈为b。</p><p>2⃣️ 来到c，b小于c，加入栈，栈为bc。</p><p>3⃣️ 来到a，c大于a，后续还有c，弹出，栈为b，继续到b，b大于a，后续还有b，弹出，把a压入栈，栈为a。</p><p>4⃣️ 来到b、c，压入栈，全部弹出逆序。</p><p>Code:</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">removeDuplicateLetters</span><span class="hljs-params">(String s)</span></span>&#123;        <span class="hljs-keyword">int</span> len = s.length();        <span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">2</span>)&#123;            <span class="hljs-keyword">return</span> s;        &#125;        <span class="hljs-comment">// abca</span>        <span class="hljs-keyword">char</span>[] chars = s.toCharArray();        <span class="hljs-keyword">int</span>[] place = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">26</span>]; <span class="hljs-comment">// 记录chars中字符出现的最后一次位置</span>        <span class="hljs-keyword">boolean</span>[] visited = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[<span class="hljs-number">26</span>]; <span class="hljs-comment">// 记录chars中字符是否保存在栈中</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)&#123;            <span class="hljs-comment">// place[ a - a] = 0;</span>            place[chars[i] - <span class="hljs-string">&#x27;a&#x27;</span>] = i;            <span class="hljs-comment">// ....</span>            <span class="hljs-comment">// place [ a - a] = 4</span>        &#125;        Stack stack = <span class="hljs-keyword">new</span> Stack();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)&#123;            <span class="hljs-keyword">char</span> currentChar = chars[i];            <span class="hljs-keyword">if</span> (visited[currentChar - <span class="hljs-string">&#x27;a&#x27;</span>])&#123;                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-comment">// 弹出条件:</span>            <span class="hljs-comment">// 1.栈不为空</span>            <span class="hljs-comment">// 2.栈顶元素字典序 大于 当前元素</span>            <span class="hljs-comment">// 3.栈顶元素 在后序会再次出现</span>            <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; (<span class="hljs-keyword">char</span>)stack.peek() &gt; currentChar &amp;&amp; place[(<span class="hljs-keyword">char</span>)stack.peek()  - <span class="hljs-string">&#x27;a&#x27;</span>] &gt; i)&#123;                visited[(<span class="hljs-keyword">char</span>)stack.pop() - <span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-keyword">false</span>;            &#125;            stack.push(currentChar);            visited[currentChar - <span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-keyword">true</span>;        &#125;        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();        <span class="hljs-keyword">int</span> size = stack.size();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;            sb.append(stack.pop());        &#125;        <span class="hljs-keyword">return</span> sb.reverse().toString();    &#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nowcoder Community Code Review</title>
    <link href="/2020/12/14/Nowcoder%20Community%20Code%20Review/"/>
    <url>/2020/12/14/Nowcoder%20Community%20Code%20Review/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><iframe frameborder="no" border="0" marginwidth="0" position="fixed"  marginheight="0" left=0 width=330 height=86 src="//music.163.com/outchain/player?type=2&id=347572&auto=1&height=66"></iframe><h1 id="系统分析"><a href="#系统分析" class="headerlink" title="系统分析"></a>系统分析</h1><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201216143154.png" alt="需求列表"></p><h2 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h2><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201216150139.png" alt="数据库表设计1"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201216150203.png" alt="数据库表设计2"></p><h2 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h2><ul><li><p>技术栈架构</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201216151114.png" alt="技术栈"></p></li><li><p>部署架构</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201219154749.png" alt="部署架构图"></p></li></ul><h2 id="项目结构一览"><a href="#项目结构一览" class="headerlink" title="项目结构一览"></a>项目结构一览</h2><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201219160159.png" alt="结构"></p><p>此结构有瑕疵，application配置文件应区分 <strong>dev or produce</strong></p><h2 id="项目开发前框架基础配置"><a href="#项目开发前框架基础配置" class="headerlink" title="项目开发前框架基础配置"></a>项目开发前框架基础配置</h2><blockquote><p>Mybatis</p></blockquote><pre><code class="hljs xml"># MybatisPropertiesmybatis.mapper-locations=classpath:mapper/*.xmlmybatis.type-aliases-package=com.nowcoder.community.entitymybatis.configuration.useGeneratedKeys=true#驼峰命名与数据库下划线命名转换mybatis.configuration.mapUnderscoreToCamelCase=true</code></pre><blockquote><p>Spring</p></blockquote><pre><code class="hljs yaml"><span class="hljs-comment"># ServerProperties</span><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span>  <span class="hljs-attr">servlet:</span>    <span class="hljs-attr">context-path:</span> <span class="hljs-string">/community</span><span class="hljs-comment"># ThymeleafProperties</span><span class="hljs-attr">spring:</span>  <span class="hljs-attr">thymeleaf:</span>    <span class="hljs-attr">cache:</span> <span class="hljs-literal">false</span>  <span class="hljs-comment"># DataSourceProperties</span>  <span class="hljs-attr">datasource:</span>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/community?characterEncoding=utf-8&amp;useSSL=false&amp;serverTimezone=Hongkong</span>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span>    <span class="hljs-attr">password:</span> <span class="hljs-string">password</span>    <span class="hljs-attr">type:</span> <span class="hljs-string">com.zaxxer.hikari.HikariDataSource</span>    <span class="hljs-attr">hikari:</span>      <span class="hljs-attr">maximum-pool-size:</span> <span class="hljs-number">15</span>      <span class="hljs-attr">minimum-idle:</span> <span class="hljs-number">5</span>      <span class="hljs-attr">idle-timeout:</span> <span class="hljs-number">30000</span></code></pre><p>默认使用 <strong>hikari连接池</strong></p><blockquote><p>maven</p></blockquote><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.junit.vintage<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit-vintage-engine<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.12<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-comment">&lt;!--&lt;scope&gt;test&lt;/scope&gt;--&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-devtools<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></code></pre><h1 id="首页展示模块"><a href="#首页展示模块" class="headerlink" title="首页展示模块"></a>首页展示模块</h1><h2 id="开发社区首页"><a href="#开发社区首页" class="headerlink" title="开发社区首页"></a>开发社区首页</h2><h3 id="开发流程概括"><a href="#开发流程概括" class="headerlink" title="开发流程概括"></a>开发流程概括</h3><ul><li><p>流程请求执行过程</p><ul><li><p>1次请求的执行过程</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201219155543.png" alt="请求过程"></p></li></ul></li><li><p>分步实现</p><ul><li>开发首页，显示前十个帖子</li><li>开发 <strong>分页</strong> 组件(手动实现)，分页显示所有帖子</li></ul></li></ul><p>基础配置已在系统分析给出，不再多概述。</p><blockquote><p>编写分页前，只显示十条数据</p></blockquote><ol><li><p>编写 <strong>实体类</strong></p><p>为什么要同时编写 User相关的，因为页面需要Username，headerUrl等信息，所以查询一并返回。</p><pre><code class="hljs java"><span class="hljs-meta">@Data</span><span class="hljs-meta">@AllArgsConstructor</span><span class="hljs-meta">@NoArgsConstructor</span><span class="hljs-comment">// 使用了lombok</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DiscussPost</span> </span>&#123;      <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> userId;    <span class="hljs-keyword">private</span> String title;    <span class="hljs-keyword">private</span> String content;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> type;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> status;    <span class="hljs-keyword">private</span> Date createTime;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> commentCount;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> score;&#125;<span class="hljs-meta">@Data</span><span class="hljs-meta">@AllArgsConstructor</span><span class="hljs-meta">@NoArgsConstructor</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;    <span class="hljs-keyword">private</span> String username;    <span class="hljs-keyword">private</span> String password;    <span class="hljs-keyword">private</span> String salt;    <span class="hljs-keyword">private</span> String email;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> type;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> status;    <span class="hljs-keyword">private</span> String activationCode;    <span class="hljs-keyword">private</span> String headerUrl;    <span class="hljs-keyword">private</span> Date createTime;&#125;</code></pre></li><li><p>描述接口Mapper</p><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">DiscussPostMapper</span> </span>&#123;    <span class="hljs-comment">// userId为&quot;我发布的帖子&quot;功能调用</span>    <span class="hljs-comment">// offset,limit为分页功能调用</span>    <span class="hljs-function">List&lt;DiscussPost&gt; <span class="hljs-title">selectDiscussPosts</span><span class="hljs-params">(<span class="hljs-keyword">int</span> userId, <span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">int</span> limit, <span class="hljs-keyword">int</span> orderMode)</span></span>;<span class="hljs-comment">// @Param注解用于给参数取别名</span>    <span class="hljs-comment">// 动态sql在&lt;if&gt;中使用,单一参数,一定要取别名,否则报错</span>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">selectDiscussPostRows</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;userId&quot;)</span> <span class="hljs-keyword">int</span> userId)</span></span>;&#125;<span class="hljs-meta">@Mapper</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserMapper</span> </span>&#123;    <span class="hljs-function">User <span class="hljs-title">selectById</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span></span>;&#125;</code></pre></li><li><p>写接口对应的Mapper文件</p><p>xml文件开头过于冗余，已忽略，请查略源代码文件</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- discussPost-mapper --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">sql</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectFields&quot;</span>&gt;</span>    id, user_id, title, content, type, status, create_time, comment_count, score<span class="hljs-tag">&lt;/<span class="hljs-name">sql</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectDiscussPosts&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;DiscussPost&quot;</span>&gt;</span>        select        <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">&quot;selectFields&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span>        from discuss_post        where status != 2        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;userId!=0&quot;</span>&gt;</span>            and user_id = #&#123;userId&#125;        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>        limit #&#123;offset&#125;,#&#123;limit&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectDiscussPostRows&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;int&quot;</span>&gt;</span>        select count(id)        from discuss_post        where status != 2        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;userId!=0&quot;</span>&gt;</span>            and user_id = #&#123;userId&#125;        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><span class="hljs-comment">&lt;!-- user-mapper --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">sql</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectFields&quot;</span>&gt;</span>        id, username, password, salt, email, type, status, activation_code, header_url, create_time<span class="hljs-tag">&lt;/<span class="hljs-name">sql</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectById&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;User&quot;</span>&gt;</span>        select <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">&quot;selectFields&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span>        from user        where id = #&#123;id&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre></li><li><p>写Service</p><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DiscussPostService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> DiscussPostMapper discussPostMapper;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;DiscussPost&gt; <span class="hljs-title">findDiscussPosts</span><span class="hljs-params">(<span class="hljs-keyword">int</span> userId, <span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">int</span> limit)</span> </span>&#123;        <span class="hljs-keyword">return</span> discussPostMapper.selectDiscussPosts(userId, offset, limit);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findDiscussPostRows</span><span class="hljs-params">(<span class="hljs-keyword">int</span> userId)</span> </span>&#123;        <span class="hljs-keyword">return</span> discussPostMapper.selectDiscussPostRows(userId);    &#125;&#125;<span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> UserMapper userMapper;    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">findUserById</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;        <span class="hljs-keyword">return</span> userMapper.selectById(id);    &#125;&#125;</code></pre></li><li><p>编写HomeController</p><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HomeController</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> DiscussPostService discussPostService;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> UserService userService;    <span class="hljs-meta">@RequestMapping(path = &quot;/index&quot;, method = RequestMethod.GET)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getIndexPage</span><span class="hljs-params">(Model model)</span> </span>&#123;        List&lt;DiscussPost&gt; list = discussPostService.findDiscussPosts(<span class="hljs-number">0</span>, page.getOffset(), page.getLimit());        List&lt;Map&lt;String, Object&gt;&gt; discussPosts = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">if</span> (list != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">for</span> (DiscussPost post : list) &#123;                Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();                map.put(<span class="hljs-string">&quot;post&quot;</span>, post);                User user = userService.findUserById(post.getUserId());                map.put(<span class="hljs-string">&quot;user&quot;</span>, user);                discussPosts.add(map);            &#125;        &#125;        model.addAttribute(<span class="hljs-string">&quot;discussPosts&quot;</span>, discussPosts);        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;/index&quot;</span>;    &#125;&#125;</code></pre></li><li><p>对index页进行 <strong>模版引擎修改</strong> </p><p>详细修改请查看源代码</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201219164449.png" alt="index修改"></p></li><li><p>总体流程归纳：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201219164943.png" alt="流程归纳"></p></li></ol><blockquote><p>编写分页</p></blockquote><ol><li><p>封装分页对象</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 封装分页相关信息</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Page</span> </span>&#123;    <span class="hljs-comment">// 当前页码(默认为1)</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> current = <span class="hljs-number">1</span>;    <span class="hljs-comment">// 显示上限(默认为10)</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> limit = <span class="hljs-number">10</span>;    <span class="hljs-comment">// 数据总数,用于计算总的页数</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> rows;    <span class="hljs-comment">// 查询路径,用于复用分页链接</span>    <span class="hljs-keyword">private</span> String path;&#125;</code></pre><p>分页里面的set和get方法有 <strong>技巧</strong>，有许多判断和默认值，不使用lombok，详细代码请看源码。</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201219165225.png" alt="分页对象信息"></p></li><li><p>修改HomeController</p><p>修改后的controller：</p><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(path = &quot;/index&quot;, method = RequestMethod.GET)</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getIndexPage</span><span class="hljs-params">(Model model, Page page)</span> </span>&#123;    <span class="hljs-comment">// 方法调用前,SpringMVC会自动实例化Model和Page,并将Page注入Model.</span>    <span class="hljs-comment">// 所以,在thymeleaf中可以直接访问Page对象中的数据.</span>    page.setRows(discussPostService.findDiscussPostRows(<span class="hljs-number">0</span>));    page.setPath(<span class="hljs-string">&quot;/index&quot;</span>);    List&lt;DiscussPost&gt; list = discussPostService.findDiscussPosts(<span class="hljs-number">0</span>, page.getOffset(), page.getLimit());    List&lt;Map&lt;String, Object&gt;&gt; discussPosts = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">if</span> (list != <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">for</span> (DiscussPost post : list) &#123;            Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();            map.put(<span class="hljs-string">&quot;post&quot;</span>, post);            User user = userService.findUserById(post.getUserId());            map.put(<span class="hljs-string">&quot;user&quot;</span>, user);            discussPosts.add(map);        &#125;    &#125;    model.addAttribute(<span class="hljs-string">&quot;discussPosts&quot;</span>, discussPosts);    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;/index&quot;</span>;&#125;</code></pre></li><li><p>修改模版引擎分页系统(可复用)</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201219165634.png" alt="模版引擎处理"></p></li><li><p>分页总体流程归纳</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201219170954.png" alt="流程图"></p></li></ol><h2 id="日志分级输出"><a href="#日志分级输出" class="headerlink" title="日志分级输出"></a>日志分级输出</h2><p>详细请参考resources目录下的logback-spring.xml文件</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201219171414.png" alt="日志"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201219171501.png" alt="日志分级"></p><h2 id="发送邮件功能-非aliyun实现"><a href="#发送邮件功能-非aliyun实现" class="headerlink" title="发送邮件功能 (非aliyun实现)"></a>发送邮件功能 (非aliyun实现)</h2><ul><li>邮件设置<ul><li>启用客户端SMTP服务</li></ul></li><li>Spring Email<ul><li>导入jar包</li><li>邮箱参数配置</li><li>使用 <strong>JavaMailSender</strong> 发送邮件</li></ul></li><li>模版引擎<ul><li>使用 <strong>Thymeleaf</strong> 发送 <strong>HTML</strong> 邮件</li></ul></li></ul><h3 id="开发流程概括-1"><a href="#开发流程概括-1" class="headerlink" title="开发流程概括"></a>开发流程概括</h3><ol><li><p>确保邮箱服务开启</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201219172636.png" alt="邮箱服务"></p></li><li><p>Maven导入</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-mail<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.6.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></li><li><p>配置文件</p><pre><code class="hljs yaml"><span class="hljs-comment">#MailProperties</span><span class="hljs-attr">mail:</span>  <span class="hljs-attr">host:</span> <span class="hljs-string">smtp.163.com</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">465</span>  <span class="hljs-attr">username:</span> <span class="hljs-string">username</span>  <span class="hljs-attr">password:</span> <span class="hljs-string">pwd</span>  <span class="hljs-attr">protocol:</span> <span class="hljs-string">smtps</span>  <span class="hljs-attr">properties:</span>    <span class="hljs-attr">smtp:</span>      <span class="hljs-attr">ssl:</span>        <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span></code></pre></li><li><p>编写MailClient的工具类</p><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MailClient</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger logger = LoggerFactory.getLogger(MailClient.class);    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> JavaMailSender mailSender;    <span class="hljs-meta">@Value(&quot;$&#123;spring.mail.username&#125;&quot;)</span>    <span class="hljs-keyword">private</span> String mailFrom;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendMail</span><span class="hljs-params">(String mailTo, String title, String content)</span></span>&#123;        <span class="hljs-keyword">try</span> &#123;            MimeMessage mimeMessage = mailSender.createMimeMessage();            MimeMessageHelper helper = <span class="hljs-keyword">new</span> MimeMessageHelper(mimeMessage);            helper.setFrom(mailFrom);            helper.setTo(mailTo);            helper.setSubject(title);            helper.setText(content,<span class="hljs-keyword">true</span>);            mailSender.send(helper.getMimeMessage());        &#125; <span class="hljs-keyword">catch</span> (MessagingException e) &#123;            logger.error(<span class="hljs-string">&quot;邮件发送失败：&quot;</span>+e.getMessage());        &#125;    &#125;&#125;</code></pre></li><li><p>测试 (省略，请查看test包下的MailTest)</p></li></ol><h2 id="开放注册功能"><a href="#开放注册功能" class="headerlink" title="开放注册功能"></a>开放注册功能</h2><ul><li>访问注册页面<ul><li>点击顶部区域内的链接，打开注册页面</li></ul></li><li>提交注册数据<ul><li>通过表单提交数据</li><li>服务端验证账号是否已存在、邮箱是否已注册。</li><li>服务端发送激活邮件。</li></ul></li><li>激活注册账号<ul><li>点击邮件中的链接，访问服务端的激活服务。</li></ul></li></ul><h3 id="开发流程概括-2"><a href="#开发流程概括-2" class="headerlink" title="开发流程概括"></a>开发流程概括</h3><ol><li><p>跳转注册页面</p><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginController</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CommunityConstant</span> </span>&#123;      <span class="hljs-meta">@RequestMapping(path = &quot;/register&quot;,method = RequestMethod.GET)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getRegisterPage</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;site/register&quot;</span>;    &#125;&#125;</code></pre></li><li><p>修改主页模版引擎</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;nav-item ml-3 btn-group-vertical&quot;</span> <span class="hljs-attr">th:if</span>=<span class="hljs-string">&quot;$&#123;loginUser==null&#125;&quot;</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;nav-link&quot;</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">&quot;@&#123;/register&#125;&quot;</span>&gt;</span>注册<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></code></pre></li><li><p>配置激活邮箱发送时附带的激活链接和Commonslang包</p><pre><code class="hljs yaml"><span class="hljs-comment"># community</span><span class="hljs-attr">community:</span>  <span class="hljs-attr">path:</span>    <span class="hljs-attr">domain:</span> <span class="hljs-string">http://localhost:8080</span>    <span class="hljs-attr">upload:</span> <span class="hljs-string">/Users/qiuke/Desktop/nowcoder_source/work/picture</span></code></pre><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--    空值比较    --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.commons<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-lang3<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></li><li><p>编写MD5、UUID工具类</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CommunityUtil</span> </span>&#123;    <span class="hljs-comment">// 生成随机字符串</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">generateUUID</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> UUID.randomUUID().toString().replaceAll(<span class="hljs-string">&quot;-&quot;</span>,<span class="hljs-string">&quot;&quot;</span>);    &#125;    <span class="hljs-comment">// md5加密 key为pwd+salt</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">md5</span><span class="hljs-params">(String key)</span></span>&#123;        <span class="hljs-keyword">if</span> (StringUtils.isBlank(key))&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-keyword">return</span> DigestUtils.md5DigestAsHex(key.getBytes());    &#125;&#125;</code></pre></li><li><p>编写UserService</p><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><span class="hljs-keyword">private</span> MailClient mailClient;<span class="hljs-meta">@Autowired</span><span class="hljs-keyword">private</span> TemplateEngine templateEngine;<span class="hljs-meta">@Value(&quot;$&#123;community.path.domain&#125;&quot;)</span><span class="hljs-keyword">private</span> String domain;<span class="hljs-meta">@Value(&quot;$&#123;server.servlet.context-path&#125;&quot;)</span><span class="hljs-keyword">private</span> String contextPath;<span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String, Object&gt; <span class="hljs-title">register</span><span class="hljs-params">(User user)</span></span>&#123;        Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        <span class="hljs-comment">// 空值处理</span>        <span class="hljs-keyword">if</span> (user == <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;User参数不能为空&quot;</span>);        &#125;        <span class="hljs-keyword">if</span> (StringUtils.isBlank(user.getUsername()))&#123;            map.put(<span class="hljs-string">&quot;usernameMsg&quot;</span>,<span class="hljs-string">&quot;账号不能为空&quot;</span>);            <span class="hljs-keyword">return</span> map;        &#125;        <span class="hljs-keyword">if</span> (StringUtils.isBlank(user.getPassword()))&#123;            map.put(<span class="hljs-string">&quot;passwordMsg&quot;</span>,<span class="hljs-string">&quot;密码不能为空&quot;</span>);            <span class="hljs-keyword">return</span> map;        &#125;        <span class="hljs-keyword">if</span> (StringUtils.isBlank(user.getEmail()))&#123;            map.put(<span class="hljs-string">&quot;emailMsg&quot;</span>,<span class="hljs-string">&quot;邮箱不能为空&quot;</span>);            <span class="hljs-keyword">return</span> map;        &#125;        User u = userMapper.selectByName(user.getUsername());        <span class="hljs-keyword">if</span> (u != <span class="hljs-keyword">null</span>)&#123;            map.put(<span class="hljs-string">&quot;usernameMsg&quot;</span>,<span class="hljs-string">&quot;该账号已存在&quot;</span>);            <span class="hljs-keyword">return</span> map;        &#125;        u = userMapper.selectByEmail(user.getEmail());        <span class="hljs-keyword">if</span> (u != <span class="hljs-keyword">null</span>)&#123;            map.put(<span class="hljs-string">&quot;emailMsg&quot;</span>,<span class="hljs-string">&quot;该邮箱已存在&quot;</span>);            <span class="hljs-keyword">return</span> map;        &#125;        <span class="hljs-comment">// 注册用户</span>        user.setSalt(CommunityUtil.generateUUID().substring(<span class="hljs-number">0</span>,<span class="hljs-number">6</span>));        user.setPassword(CommunityUtil.md5(user.getPassword()+user.getSalt()));        user.setType(<span class="hljs-number">0</span>); <span class="hljs-comment">// 普通用户</span>        user.setStatus(<span class="hljs-number">0</span>); <span class="hljs-comment">// 未激活</span>        user.setActivationCode(CommunityUtil.generateUUID()); <span class="hljs-comment">// 邮箱激活码</span>        user.setHeaderUrl(String.format(<span class="hljs-string">&quot;http://images.nowcoder.com/head/%dt.png&quot;</span>, <span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">1000</span>))); <span class="hljs-comment">// 牛客网的随机头像</span>        user.setCreateTime(<span class="hljs-keyword">new</span> Date());        userMapper.insertUser(user);        <span class="hljs-comment">// 激活邮件</span>        Context context = <span class="hljs-keyword">new</span> Context();        context.setVariable(<span class="hljs-string">&quot;email&quot;</span>, user.getEmail());        <span class="hljs-comment">// 请求格式为：http://localhost:8080/community/activation/id/code</span>        <span class="hljs-comment">// 设置了mybatis.configuration.useGeneratedKeys=true,user主键id会自动赋值自增</span>        String url = domain + contextPath + <span class="hljs-string">&quot;/activation/&quot;</span>  + user.getId() + <span class="hljs-string">&quot;/&quot;</span> + user.getActivationCode();        context.setVariable(<span class="hljs-string">&quot;url&quot;</span>, url);        <span class="hljs-comment">// /mail/activation为HTML格式的邮件所在路径</span>        String process = templateEngine.process(<span class="hljs-string">&quot;/mail/activation&quot;</span>, context);        mailClient.sendMail(user.getEmail(), <span class="hljs-string">&quot;激活邮件&quot;</span>, process);        <span class="hljs-keyword">return</span> map;&#125;</code></pre></li><li><p>修改模版引擎</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201219175018.png" alt="模版引擎"></p></li><li><p>写LoginController</p><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(path = &quot;/register&quot;,method = RequestMethod.POST)</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">register</span><span class="hljs-params">(Model model, User user)</span></span>&#123;    Map&lt;String, Object&gt; map = userService.register(user);    <span class="hljs-keyword">if</span> (map == <span class="hljs-keyword">null</span> || map.isEmpty())&#123;        model.addAttribute(<span class="hljs-string">&quot;msg&quot;</span>, <span class="hljs-string">&quot;注册成功,我们已经向您的邮箱发送了一封激活邮件,请尽快激活！&quot;</span>);        <span class="hljs-comment">// 点击跳转回首页</span>        model.addAttribute(<span class="hljs-string">&quot;target&quot;</span>,<span class="hljs-string">&quot;/index&quot;</span>);        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;site/operate-result&quot;</span>;    &#125; <span class="hljs-keyword">else</span> &#123;        model.addAttribute(<span class="hljs-string">&quot;usernameMsg&quot;</span>, map.get(<span class="hljs-string">&quot;usernameMsg&quot;</span>));        model.addAttribute(<span class="hljs-string">&quot;passwordMsg&quot;</span>, map.get(<span class="hljs-string">&quot;passwordMsg&quot;</span>));        model.addAttribute(<span class="hljs-string">&quot;emailMsg&quot;</span>, map.get(<span class="hljs-string">&quot;emailMsg&quot;</span>));        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;site/register&quot;</span>;    &#125;&#125;</code></pre></li><li><p>修改operate-result模版引擎</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201219175509.png" alt="模版引擎"></p></li><li><p>修改register模版引擎(省略，请查看源代码)</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201219175654.png" alt="模版引擎"></p></li><li><p>编写常量接口</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CommunityConstant</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 激活成功</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">int</span> ACTIVATION_SUCCESS = <span class="hljs-number">1</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 激活失败</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">int</span> ACTIVATION_FAILURE = -<span class="hljs-number">1</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 重复激活</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">int</span> ACTIVATION_REPEAT = <span class="hljs-number">0</span>;&#125;</code></pre></li><li><p>编写activation 激活函数</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">activation</span><span class="hljs-params">(<span class="hljs-keyword">int</span> userId, String code)</span></span>&#123;    User user = userMapper.selectById(userId);    <span class="hljs-keyword">if</span> (user.getStatus() == <span class="hljs-number">1</span>)&#123;        <span class="hljs-keyword">return</span> ACTIVATION_REPEAT;    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (user.getActivationCode().equals(code))&#123;        userMapper.updateStatus(userId,<span class="hljs-number">1</span>);        clearCache(userId);        <span class="hljs-keyword">return</span> ACTIVATION_SUCCESS;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">return</span> ACTIVATION_FAILURE;    &#125;&#125;</code></pre></li><li><p>编写LoginController</p><pre><code class="hljs java"><span class="hljs-comment">// http://localhost:8080/community/activation/id/code</span><span class="hljs-meta">@RequestMapping(path = &quot;/activation/&#123;userId&#125;/&#123;code&#125;&quot;, method = RequestMethod.GET)</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">activation</span><span class="hljs-params">(Model model, <span class="hljs-meta">@PathVariable(&quot;userId&quot;)</span> <span class="hljs-keyword">int</span> userId, <span class="hljs-meta">@PathVariable(&quot;code&quot;)</span> String code)</span></span>&#123;    <span class="hljs-keyword">int</span> activation_code = userService.activation(userId, code);    <span class="hljs-keyword">if</span> (activation_code == ACTIVATION_SUCCESS)&#123;        model.addAttribute(<span class="hljs-string">&quot;msg&quot;</span>, <span class="hljs-string">&quot;激活成功,您的账号已经可以正常使用了！&quot;</span>);        <span class="hljs-comment">// 点击跳转回首页</span>        model.addAttribute(<span class="hljs-string">&quot;target&quot;</span>,<span class="hljs-string">&quot;/login&quot;</span>);    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (activation_code == ACTIVATION_REPEAT)&#123;        model.addAttribute(<span class="hljs-string">&quot;msg&quot;</span>, <span class="hljs-string">&quot;激活无效,您的账号已经激活过了！&quot;</span>);        <span class="hljs-comment">// 点击跳转回首页</span>        model.addAttribute(<span class="hljs-string">&quot;target&quot;</span>,<span class="hljs-string">&quot;/index&quot;</span>);    &#125;<span class="hljs-keyword">else</span> &#123;        model.addAttribute(<span class="hljs-string">&quot;msg&quot;</span>, <span class="hljs-string">&quot;激活失败,您提供的激活码不正确&quot;</span>);        <span class="hljs-comment">// 点击跳转回首页</span>        model.addAttribute(<span class="hljs-string">&quot;target&quot;</span>,<span class="hljs-string">&quot;/index&quot;</span>);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;site/operate-result&quot;</span>;&#125;    <span class="hljs-meta">@RequestMapping(path = &quot;/login&quot;,method = RequestMethod.GET)</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getLoginPage</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;site/login&quot;</span>;&#125;</code></pre></li><li><p>修改index可以点击注册</p></li></ol><h3 id="流程概括图"><a href="#流程概括图" class="headerlink" title="流程概括图"></a>流程概括图</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201219181942.png" alt="注册流程"></p><h2 id="生成验证码功能"><a href="#生成验证码功能" class="headerlink" title="生成验证码功能"></a>生成验证码功能</h2><blockquote><p>先存session后，后续redis更改项目时，存入redis</p></blockquote><ul><li><p>Kaptcha</p><ul><li>导入jar包</li><li>编写Kaptcha配置类</li><li>生成随机字符、生成图片</li></ul></li><li><p>kaptcha手册 <a href="https//code.google.com/archive/p/kaptcha">手册</a></p></li></ul><h3 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h3><ol><li><p>Maven导入</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--    验证码工具    --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.penggle<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>kaptcha<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></li><li><p>编写Kaptcha配置类</p><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">KaptchaConfig</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Producer <span class="hljs-title">kaptchaProducer</span><span class="hljs-params">()</span></span>&#123;        Properties properties = <span class="hljs-keyword">new</span> Properties();        properties.setProperty(<span class="hljs-string">&quot;kaptcha.image.width&quot;</span>, <span class="hljs-string">&quot;100&quot;</span>);        properties.setProperty(<span class="hljs-string">&quot;kaptcha.image.height&quot;</span>, <span class="hljs-string">&quot;40&quot;</span>);        properties.setProperty(<span class="hljs-string">&quot;kaptcha.textproducer.font.size&quot;</span>, <span class="hljs-string">&quot;32&quot;</span>);        properties.setProperty(<span class="hljs-string">&quot;kaptcha.textproducer.font.color&quot;</span>, <span class="hljs-string">&quot;0,0,0&quot;</span>);        properties.setProperty(<span class="hljs-string">&quot;kaptcha.textproducer.char.string&quot;</span>, <span class="hljs-string">&quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span>);        properties.setProperty(<span class="hljs-string">&quot;kaptcha.textproducer.char.length&quot;</span>, <span class="hljs-string">&quot;4&quot;</span>);        properties.setProperty(<span class="hljs-string">&quot;kaptcha.textproducer.noise.impl&quot;</span>, <span class="hljs-string">&quot;com.google.code.kaptcha.impl.NoNoise&quot;</span>);        <span class="hljs-comment">// 建议另建properties</span>        DefaultKaptcha kaptcha = <span class="hljs-keyword">new</span> DefaultKaptcha();        Config config = <span class="hljs-keyword">new</span> Config(properties);        kaptcha.setConfig(config);        <span class="hljs-keyword">return</span> kaptcha;    &#125;&#125;</code></pre></li><li><p>编写LoginController</p><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(path = &quot;/kaptcha&quot;,method = RequestMethod.GET)</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getKaptcha</span><span class="hljs-params">(HttpServletResponse response, HttpSession session)</span></span>&#123;    <span class="hljs-comment">// 生成验证码</span>    String text = kaptchProducer.createText();    BufferedImage image = kaptchProducer.createImage(text);    <span class="hljs-comment">// 验证码文字存入session</span>    session.setAttribute(<span class="hljs-string">&quot;kaptcha&quot;</span>,text);    <span class="hljs-comment">// 将图片输出给浏览器</span>    response.setContentType(<span class="hljs-string">&quot;image/png&quot;</span>);    <span class="hljs-keyword">try</span> &#123;        OutputStream os = response.getOutputStream();        ImageIO.write(image, <span class="hljs-string">&quot;png&quot;</span>, os);    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;        logger.error(<span class="hljs-string">&quot;验证码响应失败：&quot;</span> + e.getMessage());    &#125;&#125;</code></pre></li><li><p>修改login页面模版引擎路径</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201219183214.png" alt="模版引擎"></p><pre><code class="hljs js">&lt;script&gt;   <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">refresh_kaptcha</span>(<span class="hljs-params"></span>) </span>&#123;      <span class="hljs-keyword">var</span> path = CONTEXT_PATH + <span class="hljs-string">&quot;/kaptcha?p=&quot;</span> + <span class="hljs-built_in">Math</span>.random();      $(<span class="hljs-string">&quot;#kaptcha&quot;</span>).attr(<span class="hljs-string">&quot;src&quot;</span>, path);   &#125;&lt;/script&gt;</code></pre></li></ol><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201219183831.png" alt="流程图"></p><h3 id="登录开发流程"><a href="#登录开发流程" class="headerlink" title="登录开发流程"></a>登录开发流程</h3><ol><li><p>生成loginTicket实体类并编写Mapper</p><pre><code class="hljs java"><span class="hljs-meta">@Data</span><span class="hljs-meta">@AllArgsConstructor</span><span class="hljs-meta">@NoArgsConstructor</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginTicket</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> userId;    <span class="hljs-keyword">private</span> String ticket;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> status;    <span class="hljs-keyword">private</span> Date expired;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">LoginTicketMapper</span> </span>&#123;    <span class="hljs-meta">@Insert(&#123;</span><span class="hljs-meta">            &quot;insert into login_ticket(user_id,ticket,status,expired) &quot;,</span><span class="hljs-meta">            &quot;values(#&#123;userId&#125;,#&#123;ticket&#125;,#&#123;status&#125;,#&#123;expired&#125;)&quot;</span><span class="hljs-meta">    &#125;)</span>    <span class="hljs-meta">@Options(useGeneratedKeys = true,keyProperty = &quot;id&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">insertLoginTicket</span><span class="hljs-params">(LoginTicket loginTicket)</span></span>;    <span class="hljs-meta">@Select(&#123;</span><span class="hljs-meta">            &quot;select id,user_id,ticket,status,expired &quot;,</span><span class="hljs-meta">            &quot;from login_ticket &quot;,</span><span class="hljs-meta">            &quot;where ticket = #&#123;ticket&#125;&quot;</span><span class="hljs-meta">    &#125;)</span>    <span class="hljs-function">LoginTicket <span class="hljs-title">selectByTicket</span><span class="hljs-params">(String ticket)</span></span>;    <span class="hljs-meta">@Update(&#123;</span><span class="hljs-meta">            &quot;update login_ticket set status = #&#123;status&#125; &quot;,</span><span class="hljs-meta">            &quot;where ticket = #&#123;ticket&#125;&quot;</span><span class="hljs-meta">    &#125;)</span>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">updateStatus</span><span class="hljs-params">(String ticket, <span class="hljs-keyword">int</span> status)</span></span>;&#125;</code></pre></li><li><p>编写UserService的login方法，一个实现跳转，一个实现登录业务</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String, Object&gt; <span class="hljs-title">login</span><span class="hljs-params">(String username, String password, <span class="hljs-keyword">int</span> expiredSeconds)</span></span>&#123;     Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        <span class="hljs-comment">// 空值处理</span>     <span class="hljs-keyword">if</span> (StringUtils.isBlank(username))&#123;         map.put(<span class="hljs-string">&quot;usernameMsg&quot;</span>,<span class="hljs-string">&quot;账号不能为空！&quot;</span>);         <span class="hljs-keyword">return</span> map;     &#125;     <span class="hljs-keyword">if</span> (StringUtils.isBlank(password))&#123;         map.put(<span class="hljs-string">&quot;passwordMsg&quot;</span>,<span class="hljs-string">&quot;密码不能为空！&quot;</span>);         <span class="hljs-keyword">return</span> map;     &#125;        <span class="hljs-comment">// 查询 激活处理</span>     User user = userMapper.selectByName(username);     <span class="hljs-keyword">if</span> (user == <span class="hljs-keyword">null</span>)&#123;         map.put(<span class="hljs-string">&quot;usernameMsg&quot;</span>,<span class="hljs-string">&quot;账号不存在！&quot;</span>);         <span class="hljs-keyword">return</span> map;     &#125;     <span class="hljs-keyword">if</span> (user.getStatus() == <span class="hljs-number">0</span>)&#123;         map.put(<span class="hljs-string">&quot;usernameMsg&quot;</span>,<span class="hljs-string">&quot;账号未激活！&quot;</span>);         <span class="hljs-keyword">return</span> map;     &#125;        <span class="hljs-comment">// 验证密码</span>     password = CommunityUtil.md5(password + user.getSalt());     <span class="hljs-keyword">if</span> (!user.getPassword().equals(password))&#123;         map.put(<span class="hljs-string">&quot;passwordMsg&quot;</span>,<span class="hljs-string">&quot;密码不正确！&quot;</span>);         <span class="hljs-keyword">return</span> map;     &#125;        <span class="hljs-comment">// 登陆成功 生成登陆凭证</span>     LoginTicket loginTicket = <span class="hljs-keyword">new</span> LoginTicket();     loginTicket.setUserId(user.getId());     loginTicket.setTicket(CommunityUtil.generateUUID());     loginTicket.setStatus(<span class="hljs-number">0</span>);     loginTicket.setExpired(<span class="hljs-keyword">new</span> Date(System.currentTimeMillis() + <span class="hljs-number">1000</span> * expiredSeconds));     loginTicketMapper.insertLoginTicket(loginTicket);      <span class="hljs-comment">// 浏览器只需要记录key</span>      <span class="hljs-comment">// TODO redis</span>     map.put(<span class="hljs-string">&quot;ticket&quot;</span>, loginTicket.getTicket());        <span class="hljs-keyword">return</span> map; &#125;</code></pre></li><li><p>编写LoginController</p><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(path = &quot;/login&quot;,method = RequestMethod.GET)</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getLoginPage</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;site/login&quot;</span>;&#125;<span class="hljs-meta">@RequestMapping(path = &quot;/login&quot;,method = RequestMethod.POST)</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">login</span><span class="hljs-params">(String username, String password, String code, Boolean rememberme,</span></span><span class="hljs-function"><span class="hljs-params">                    Model model, HttpServletResponse response, <span class="hljs-meta">@CookieValue(&quot;kaptchaOwner&quot;)</span>String kaptchaOwner)</span></span>&#123;    <span class="hljs-comment">// 最先判断验证码</span>    String kaptcha = (String) session.getAttribute(<span class="hljs-string">&quot;kaptcha&quot;</span>);      <span class="hljs-keyword">if</span> (StringUtils.isBlank(kaptcha)            || StringUtils.isBlank(code)            || !kaptcha.equalsIgnoreCase(code))&#123;        model.addAttribute(<span class="hljs-string">&quot;codeMsg&quot;</span>, <span class="hljs-string">&quot;验证码不正确&quot;</span>);        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;site/login&quot;</span>;    &#125;    <span class="hljs-comment">// 前端一直拿不到rememberme为false,便加入这行代码自动false,但能拿到true</span>    <span class="hljs-keyword">if</span> (rememberme == <span class="hljs-keyword">null</span>)&#123;        rememberme = <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-comment">// 检查账号密码</span>    <span class="hljs-keyword">int</span> expiredSeconds = rememberme ? REMEMBER_EXPIRED_SECONDS : DEFAULT_EXPIRED_SECONDS;    Map&lt;String, Object&gt; map = userService.login(username, password, expiredSeconds);    <span class="hljs-keyword">if</span> (map.containsKey(<span class="hljs-string">&quot;ticket&quot;</span>))&#123;        Cookie cookie =  <span class="hljs-keyword">new</span> Cookie(<span class="hljs-string">&quot;ticket&quot;</span>, map.get(<span class="hljs-string">&quot;ticket&quot;</span>).toString());        <span class="hljs-comment">// application.yaml中有</span>        cookie.setPath(contextPath);        cookie.setMaxAge(expiredSeconds);        response.addCookie(cookie);        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;redirect:/index&quot;</span>;    &#125;<span class="hljs-keyword">else</span> &#123;        model.addAttribute(<span class="hljs-string">&quot;usernameMsg&quot;</span>, map.get(<span class="hljs-string">&quot;usernameMsg&quot;</span>));        model.addAttribute(<span class="hljs-string">&quot;passwordMsg&quot;</span>, map.get(<span class="hljs-string">&quot;passwordMsg&quot;</span>));        model.addAttribute(<span class="hljs-string">&quot;emailMsg&quot;</span>, map.get(<span class="hljs-string">&quot;emailMsg&quot;</span>));        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;site/login&quot;</span>;    &#125;&#125;</code></pre></li></ol><p>​     期间对应的工具类常量接口数值为：</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 默认状态登录凭证的超时时间</span><span class="hljs-comment"> */</span><span class="hljs-keyword">int</span> DEFAULT_EXPIRED_SECONDS = <span class="hljs-number">3600</span> * <span class="hljs-number">12</span>;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 记住状态登录凭证的超时时间</span><span class="hljs-comment"> */</span><span class="hljs-keyword">int</span> REMEMBER_EXPIRED_SECONDS = <span class="hljs-number">3600</span> * <span class="hljs-number">24</span> * <span class="hljs-number">14</span>;</code></pre><ol start="4"><li><p>修改模版引擎</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201221151740.png" alt="模版引擎"></p><p>代码修改请见源码。</p></li><li><p>编写UserService logout功能</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">logout</span><span class="hljs-params">(String ticket)</span></span>&#123;    loginTicketMapper.updateStatus(ticket,<span class="hljs-number">1</span>);&#125;</code></pre></li><li><p>编写的LoginController logout请求</p><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(path = &quot;/logout&quot;,method = RequestMethod.GET)</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">logout</span><span class="hljs-params">(<span class="hljs-meta">@CookieValue(&quot;ticket&quot;)</span> String ticket)</span></span>&#123;    userService.logout(ticket);    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;redirect:/login&quot;</span>;&#125;</code></pre></li><li><p>修改模版引擎导航栏请求</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201221152201.png" alt="模版引擎"></p></li></ol><blockquote><p>业务流程图</p></blockquote><p>   <img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201221154233.png" alt="登录流程"></p><p>   <img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201221154357.png" alt="退出功能"></p><h2 id="显示登录信息"><a href="#显示登录信息" class="headerlink" title="显示登录信息"></a>显示登录信息</h2><ul><li><p>拦截器</p><ul><li>在请求开始时查询登录用户</li><li>在本次请求中持有用户数据</li><li>在模版视图上显示用户数据</li><li>在请求结束时清理用户数据</li></ul></li></ul><ol><li><p>原理图</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201221155649.png" alt="原理图"></p></li><li><p>编写HostHolder持有用户信息</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 容器作用,持有用户信息,用于代替session对象,线程隔离</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HostHolder</span> </span>&#123;    <span class="hljs-keyword">private</span> ThreadLocal&lt;User&gt; users = <span class="hljs-keyword">new</span> ThreadLocal&lt;&gt;();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUsers</span><span class="hljs-params">(User user)</span></span>&#123;        users.set(user);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">getUsers</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> users.get();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span></span>&#123;        users.remove();    &#125;&#125;</code></pre></li><li><p>编写登录拦截器(实现CookieUtil)</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CookieUtil</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getValue</span><span class="hljs-params">(HttpServletRequest request, String name)</span></span>&#123;        <span class="hljs-keyword">if</span> (request == <span class="hljs-keyword">null</span> || name == <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;参数为空！&quot;</span>);        &#125;        Cookie[] cookies = request.getCookies();        <span class="hljs-keyword">if</span> (cookies != <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">for</span> (Cookie cookie : cookies) &#123;                <span class="hljs-keyword">if</span> (cookie.getName().equals(name))&#123;                    <span class="hljs-keyword">return</span> cookie.getValue();                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginTicketInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HandlerInterceptor</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    UserService userService;    <span class="hljs-meta">@Autowired</span>    HostHolder hostHolder;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">// 从cookie中获取ticket</span>        String ticket = CookieUtil.getValue(request, <span class="hljs-string">&quot;ticket&quot;</span>);        <span class="hljs-keyword">if</span> (ticket != <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-comment">// 查询</span>            LoginTicket loginTicket = userService.findLoginTicket(ticket);            <span class="hljs-comment">// 检测有效</span>            <span class="hljs-keyword">if</span> (loginTicket != <span class="hljs-keyword">null</span> &amp;&amp; loginTicket.getStatus() == <span class="hljs-number">0</span> &amp;&amp; loginTicket.getExpired().after(<span class="hljs-keyword">new</span> Date()))&#123;                <span class="hljs-comment">// 根据凭证找到用户</span>                User user = userService.findUserById(loginTicket.getUserId());                <span class="hljs-comment">// 在本次请求中持有用户</span>                hostHolder.setUsers(user);                <span class="hljs-comment">// 构建用户认证结果 存入SecurityContext 以便与security进行授权(越过了security认证 用了自己的认证 需要自己授权)</span>            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        User user = hostHolder.getUsers();        <span class="hljs-keyword">if</span> (user != <span class="hljs-keyword">null</span> &amp;&amp; modelAndView != <span class="hljs-keyword">null</span>)&#123;            modelAndView.addObject(<span class="hljs-string">&quot;loginUser&quot;</span>,user);        &#125;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterCompletion</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        hostHolder.clear();        SecurityContextHolder.clearContext();    &#125;&#125;</code></pre><p>modelAndView.addObject(“loginUser”,user) </p><p>这样user就会被模版引擎拿到</p></li><li><p>注入到WebMvcConfig</p><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebMvcConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> LoginTicketInterceptor loginTicketInterceptor;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> </span>&#123;        registry.addInterceptor(loginTicketInterceptor)                .excludePathPatterns(<span class="hljs-string">&quot;/**/*.css&quot;</span>, <span class="hljs-string">&quot;/**/*.js&quot;</span>, <span class="hljs-string">&quot;/**/*.png&quot;</span>, <span class="hljs-string">&quot;/**/*.jpg&quot;</span>, <span class="hljs-string">&quot;/**/*.jpeg&quot;</span>);    &#125;&#125;</code></pre></li><li><p>更改模版引擎</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201221160610.png" alt="模版引擎"></p></li></ol><h2 id="账号设置"><a href="#账号设置" class="headerlink" title="账号设置"></a>账号设置</h2><h3 id="上传文件-头像"><a href="#上传文件-头像" class="headerlink" title="上传文件(头像)"></a>上传文件(头像)</h3><blockquote><p>七牛云上传在后续，先实现本地存储</p></blockquote><ul><li>请求POST</li><li>表单：enctype = “multipart/form-data”</li><li>Spring MVC : 通过MultipartFile处理上传文件<ul><li>访问账号设置页面</li><li>上传头像</li><li>获取头像</li></ul></li></ul><h3 id="上传文件开发流程"><a href="#上传文件开发流程" class="headerlink" title="上传文件开发流程"></a>上传文件开发流程</h3><ol><li><p>设置跳转请求并配置模版引擎</p><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(path = &quot;/setting&quot;, method = RequestMethod.GET)</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getSettingPage</span><span class="hljs-params">(Model model)</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;site/setting&quot;</span>;&#125;</code></pre></li><li><p>yaml文件设置访问路径</p><pre><code class="hljs yaml"><span class="hljs-comment"># community</span><span class="hljs-attr">community:</span>  <span class="hljs-attr">path:</span>    <span class="hljs-attr">domain:</span> <span class="hljs-string">http://localhost:8080</span>    <span class="hljs-attr">upload:</span> <span class="hljs-string">路径</span></code></pre></li><li><p>编写UserService更新头像并编写mapper(省略)</p><pre><code class="hljs java">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">updateHeadUrl</span><span class="hljs-params">(<span class="hljs-keyword">int</span> userId, String headerUrl)</span></span>&#123;<span class="hljs-comment">//        return userMapper.updateHeader(userId, headerUrl);</span>        <span class="hljs-keyword">int</span> rows = userMapper.updateHeader(userId, headerUrl);        <span class="hljs-keyword">return</span> rows;    &#125;</code></pre></li><li><p>编写UserController中upload方法</p><pre><code class="hljs java"><span class="hljs-meta">@Value(&quot;$&#123;community.path.upload&#125;&quot;)</span><span class="hljs-keyword">private</span> String uploadPath;<span class="hljs-meta">@RequestMapping(path = &quot;/upload&quot;, method = RequestMethod.POST)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">uploadHeader</span><span class="hljs-params">(MultipartFile headerImage, Model model)</span> </span>&#123;        <span class="hljs-keyword">if</span> (headerImage == <span class="hljs-keyword">null</span>) &#123;            model.addAttribute(<span class="hljs-string">&quot;error&quot;</span>, <span class="hljs-string">&quot;文件还未上传！&quot;</span>);            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;site/setting&quot;</span>;        &#125;        <span class="hljs-comment">// 获取后缀</span>        String fileName = headerImage.getOriginalFilename();        String suffix = fileName.substring(fileName.lastIndexOf(<span class="hljs-string">&quot;.&quot;</span>));        <span class="hljs-keyword">if</span> (StringUtils.isBlank(suffix)) &#123;            model.addAttribute(<span class="hljs-string">&quot;error&quot;</span>, <span class="hljs-string">&quot;文件格式不正确！&quot;</span>);            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;site/setting&quot;</span>;        &#125;        <span class="hljs-comment">// 生成随机文件名</span>        fileName = CommunityUtil.generateUUID() + suffix;        <span class="hljs-comment">// 确定文件存放路径</span>        File dest = <span class="hljs-keyword">new</span> File(uploadPath + <span class="hljs-string">&quot;/&quot;</span> + fileName);        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">// 存文件</span>            headerImage.transferTo(dest);        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            logger.error(<span class="hljs-string">&quot;上传文件失败：&quot;</span> + e.getMessage());            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;上传文件失败，服务器发生异常&quot;</span>, e);        &#125;        <span class="hljs-comment">// 更新当前用户头像路径</span>        <span class="hljs-comment">// web访问路径</span>        <span class="hljs-comment">// http:localhost:8080/community/user/header/xxx.png</span>        User user = hostHolder.getUsers();        String headerUrl = domain + contextPath + <span class="hljs-string">&quot;/user&quot;</span> + <span class="hljs-string">&quot;/header/&quot;</span> + fileName;        <span class="hljs-keyword">int</span> rows = userService.updateHeadUrl(user.getId(), headerUrl);        <span class="hljs-keyword">if</span> (rows&gt;<span class="hljs-number">0</span>)&#123;            model.addAttribute(<span class="hljs-string">&quot;success&quot;</span>,<span class="hljs-string">&quot;成功&quot;</span>);        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;site/setting&quot;</span>;<span class="hljs-comment">//        return &quot;redirect:/index&quot;;</span>    &#125;</code></pre></li><li><p>编写UserController中展示头像方法</p><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(path = &quot;/header/&#123;fileName&#125;&quot;, method = RequestMethod.GET)</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getHeader</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;fileName&quot;)</span> String fileName, HttpServletResponse response)</span> </span>&#123;    <span class="hljs-comment">// 获取服务器存放路径</span>    String filePath = uploadPath + <span class="hljs-string">&quot;/&quot;</span> + fileName;    <span class="hljs-comment">// 文件后缀名</span>    String suffix = fileName.substring(fileName.lastIndexOf(<span class="hljs-string">&quot;.&quot;</span>));    <span class="hljs-comment">// 响应类型</span>    response.setContentType(<span class="hljs-string">&quot;image/&quot;</span> + suffix);    <span class="hljs-keyword">try</span> (            FileInputStream fis = <span class="hljs-keyword">new</span> FileInputStream(filePath);            ServletOutputStream os = response.getOutputStream()    ) &#123;        <span class="hljs-keyword">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];        <span class="hljs-keyword">int</span> length = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> ((length = fis.read(buffer)) != -<span class="hljs-number">1</span>) &#123;            os.write(buffer, <span class="hljs-number">0</span>, length);        &#125;    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;        logger.error(<span class="hljs-string">&quot;读取头像失败&quot;</span> + e.getMessage());    &#125;&#125;</code></pre></li><li><p>修改模版引擎</p></li></ol><h3 id="更改密码"><a href="#更改密码" class="headerlink" title="更改密码"></a>更改密码</h3><ol><li><p>编写UserService中updatePassword方法</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String, Object&gt; <span class="hljs-title">updatePassword</span><span class="hljs-params">(String oldPassword, String newPassword, String newPasswordConfim)</span></span>&#123;    Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    <span class="hljs-keyword">if</span>(StringUtils.isBlank(oldPassword))&#123;        map.put(<span class="hljs-string">&quot;oldPasswordMsg&quot;</span>,<span class="hljs-string">&quot;旧密码不能为空！&quot;</span>);        <span class="hljs-keyword">return</span> map;    &#125;    <span class="hljs-keyword">if</span>(StringUtils.isBlank(newPassword))&#123;        map.put(<span class="hljs-string">&quot;newPasswordMsg&quot;</span>,<span class="hljs-string">&quot;新密码不能为空！&quot;</span>);        <span class="hljs-keyword">return</span> map;    &#125;    <span class="hljs-keyword">if</span>(StringUtils.isBlank(newPasswordConfim))&#123;        map.put(<span class="hljs-string">&quot;newPasswordConfimMsg&quot;</span>,<span class="hljs-string">&quot;确认密码不能为空！&quot;</span>);        <span class="hljs-keyword">return</span> map;    &#125;    <span class="hljs-keyword">if</span>(oldPassword.equals(newPassword))&#123;        map.put(<span class="hljs-string">&quot;newPasswordMsg&quot;</span>,<span class="hljs-string">&quot;新密码不能和原密码相同！&quot;</span>);        <span class="hljs-keyword">return</span> map;    &#125;    <span class="hljs-keyword">if</span>(!newPassword.equals(newPasswordConfim))&#123;        map.put(<span class="hljs-string">&quot;newPasswordConfimMsg&quot;</span>,<span class="hljs-string">&quot;确认密码与新密码不同！&quot;</span>);        <span class="hljs-keyword">return</span> map;    &#125;    User user = hostHolder.getUsers();    oldPassword=CommunityUtil.md5(oldPassword+user.getSalt());    <span class="hljs-keyword">if</span>(!oldPassword.equals(user.getPassword()))&#123;        map.put(<span class="hljs-string">&quot;oldPasswordMsg&quot;</span>,<span class="hljs-string">&quot;密码错误！&quot;</span>);        <span class="hljs-keyword">return</span> map;    &#125;    userMapper.updatePassword(user.getId(),CommunityUtil.md5(newPassword+user.getSalt()));    <span class="hljs-keyword">return</span> map;&#125;</code></pre></li><li><p>编写Mapper</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;updatePassword&quot;</span>&gt;</span>    update user set password = #&#123;password&#125; where id = #&#123;id&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span></code></pre></li><li><p>编写UserControlle请求</p><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(path = &quot;/updatePassword&quot;, method = RequestMethod.POST)</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">updatePasswordByOld</span><span class="hljs-params">(String oldPassword, String newPassword, String newPasswordConfim,</span></span><span class="hljs-function"><span class="hljs-params">                                  Model model, <span class="hljs-meta">@CookieValue(&quot;ticket&quot;)</span> String ticket)</span> </span>&#123;    Map&lt;String, Object&gt; map = userService.updatePassword(oldPassword, newPassword, newPasswordConfim);    <span class="hljs-keyword">if</span> (map == <span class="hljs-keyword">null</span> || map.isEmpty()) &#123;        userService.logout(ticket);        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;redirect:/login&quot;</span>;    &#125;    model.addAttribute(<span class="hljs-string">&quot;oldPasswordMsg&quot;</span>, map.get(<span class="hljs-string">&quot;oldPasswordMsg&quot;</span>));    model.addAttribute(<span class="hljs-string">&quot;newPasswordMsg&quot;</span>, map.get(<span class="hljs-string">&quot;newPasswordMsg&quot;</span>));    model.addAttribute(<span class="hljs-string">&quot;newPasswordConfimMsg&quot;</span>, map.get(<span class="hljs-string">&quot;newPasswordConfimMsg&quot;</span>));    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;site/setting&quot;</span>;&#125;</code></pre></li><li><p>修改模版引擎</p></li></ol><h3 id="业务流程图"><a href="#业务流程图" class="headerlink" title="业务流程图"></a>业务流程图</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201221163918.png" alt="业务流程图"></p><h2 id="注解实现检查登录状态"><a href="#注解实现检查登录状态" class="headerlink" title="注解实现检查登录状态"></a>注解实现检查登录状态</h2><ul><li><p>使用拦截器</p><ul><li>在方法前标注自定义注解</li><li>拦截所有请求，只处理带有该注解的方法</li></ul></li><li><p>自定义注解</p><ul><li><p>常用元注解</p><p>@Target、@Retention、@Document、@Inherited</p></li><li><p>如何读取注解</p><p>Method.getDeclaredAnnotations()</p><p>Method.getAnnotation(Class<T> annotationClass)</p></li></ul></li></ul><h3 id="开发流程-1"><a href="#开发流程-1" class="headerlink" title="开发流程"></a>开发流程</h3><ol><li><p>实现注解</p><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.METHOD)</span><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> LoginRequired &#123;    &#125;</code></pre><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201221165052.png" alt="包位置" style="zoom:50%;" /></li><li><p>给想要拦截的Controller加上注解</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201221165130.png" alt="加注解"></p></li><li><p>编写拦截注解的拦截器</p><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-meta">@Deprecated</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginRequiredInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HandlerInterceptor</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    HostHolder hostHolder;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">// 判定拦截对象handler是否为method</span>        <span class="hljs-keyword">if</span> (handler <span class="hljs-keyword">instanceof</span> HandlerMethod)&#123;            HandlerMethod handlerMethod = (HandlerMethod) handler;            Method method = handlerMethod.getMethod();            LoginRequired loginRequired = method.getAnnotation(LoginRequired.class);            <span class="hljs-keyword">if</span> (loginRequired != <span class="hljs-keyword">null</span> &amp;&amp; hostHolder.getUsers() == <span class="hljs-keyword">null</span>)&#123;                response.sendRedirect(request.getContextPath() + <span class="hljs-string">&quot;/login&quot;</span>);                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;&#125;</code></pre></li><li><p>给WebMvcConfig添加拦截器</p><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebMvcConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> LoginTicketInterceptor loginTicketInterceptor;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> LoginRequiredInterceptor loginRequiredInterceptor;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> </span>&#123;        registry.addInterceptor(loginTicketInterceptor)                .excludePathPatterns(<span class="hljs-string">&quot;/**/*.css&quot;</span>, <span class="hljs-string">&quot;/**/*.js&quot;</span>, <span class="hljs-string">&quot;/**/*.png&quot;</span>, <span class="hljs-string">&quot;/**/*.jpg&quot;</span>, <span class="hljs-string">&quot;/**/*.jpeg&quot;</span>);        <span class="hljs-comment">//registry.addInterceptor(loginRequiredInterceptor)</span>        <span class="hljs-comment">//        .excludePathPatterns(&quot;/**/*.css&quot;, &quot;/**/*.js&quot;, &quot;/**/*.png&quot;, &quot;/**/*.jpg&quot;, &quot;/**/*.jpeg&quot;);</span>&#125;</code></pre></li></ol><h1 id="帖子模块"><a href="#帖子模块" class="headerlink" title="帖子模块"></a>帖子模块</h1><h2 id="前缀树过滤敏感词"><a href="#前缀树过滤敏感词" class="headerlink" title="前缀树过滤敏感词"></a>前缀树过滤敏感词</h2><ul><li>前缀树<ul><li>Trie、字典树、查找树</li><li>查找效率高、消耗内存大</li><li>字符串检索、词频统计、字符串排序</li></ul></li><li>敏感词过滤<ul><li>定义前缀树</li><li>根据敏感词，初始化前缀树</li><li>编写过滤敏感词的方法</li></ul></li></ul><ol><li><p>编写前缀树算法</p><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SensitiveFilter</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger logger = LoggerFactory.getLogger(SensitiveFilter.class);    <span class="hljs-comment">// 替换符</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String REPLACEMENT = <span class="hljs-string">&quot;*&quot;</span>;    <span class="hljs-comment">// 根节点</span>    <span class="hljs-keyword">private</span> TrieNode root = <span class="hljs-keyword">new</span> TrieNode();    <span class="hljs-comment">// 前缀树过滤</span>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TrieNode</span></span>&#123;        <span class="hljs-comment">// 敏感词结束结尾</span>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> isKeywordEnd = <span class="hljs-keyword">false</span>;        <span class="hljs-comment">// 子节点(key是下级字符,value是下级节点)</span>        <span class="hljs-keyword">private</span> Map&lt;Character, TrieNode&gt; subNode = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isKeywordEnd</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> isKeywordEnd;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setKeywordEnd</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> keywordEnd)</span> </span>&#123;            isKeywordEnd = keywordEnd;        &#125;        <span class="hljs-comment">// 添加子节点</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addSubNode</span><span class="hljs-params">(Character c, TrieNode node)</span></span>&#123;            subNode.put(c, node);        &#125;        <span class="hljs-comment">// 获取子节点</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> TrieNode <span class="hljs-title">getSubNode</span><span class="hljs-params">(Character c)</span></span>&#123;            <span class="hljs-keyword">return</span> subNode.get(c);        &#125;    &#125;    <span class="hljs-comment">// 初始化</span>    <span class="hljs-meta">@PostConstruct</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">try</span>(                InputStream is = <span class="hljs-keyword">this</span>.getClass().getClassLoader().getResourceAsStream(<span class="hljs-string">&quot;sensitive-words.txt&quot;</span>);                BufferedReader reader = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(is));        ) &#123;            String sensitiveWord;            <span class="hljs-keyword">while</span> ((sensitiveWord = reader.readLine()) != <span class="hljs-keyword">null</span>)&#123;                <span class="hljs-comment">// 添加到前缀树</span>                <span class="hljs-keyword">this</span>.addSensitiveWord(sensitiveWord);            &#125;        &#125; <span class="hljs-keyword">catch</span> (IOException e)&#123;            logger.error(<span class="hljs-string">&quot;加载敏感词文件失败&quot;</span> + e.getMessage());        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addSensitiveWord</span><span class="hljs-params">(String sensitiveWord)</span> </span>&#123;        TrieNode tempNode = root;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; sensitiveWord.length(); i++) &#123;            <span class="hljs-keyword">char</span> c = sensitiveWord.charAt(i);            TrieNode subNode = tempNode.getSubNode(c);            <span class="hljs-keyword">if</span> (subNode == <span class="hljs-keyword">null</span>)&#123;                <span class="hljs-comment">// 初始化</span>                subNode = <span class="hljs-keyword">new</span> TrieNode();                tempNode.addSubNode(c, subNode);            &#125;            <span class="hljs-comment">// 改变指针</span>            tempNode = subNode;            <span class="hljs-comment">// 设置敏感词结尾标记</span>            <span class="hljs-keyword">if</span> (i == sensitiveWord.length() - <span class="hljs-number">1</span>)&#123;                tempNode.setKeywordEnd(<span class="hljs-keyword">true</span>);            &#125;        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 过滤敏感词</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> text 待过滤文本</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 过滤后的文本</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">Filter</span><span class="hljs-params">(String text)</span></span>&#123;        <span class="hljs-keyword">if</span> (StringUtils.isBlank(text))&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-comment">// 指针1 指向树的根</span>        TrieNode tempNode = root;        <span class="hljs-comment">// 指针2 指向字符串首位</span>        <span class="hljs-keyword">int</span> begin = <span class="hljs-number">0</span>;        <span class="hljs-comment">// 指针3</span>        <span class="hljs-keyword">int</span> position = <span class="hljs-number">0</span>;        <span class="hljs-comment">// 结果</span>        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();        <span class="hljs-keyword">while</span> (position &lt; text.length())&#123;            <span class="hljs-keyword">char</span> c = text.charAt(position);            <span class="hljs-comment">// 跳过符号</span>            <span class="hljs-keyword">if</span> (isSymbol(c))&#123;                <span class="hljs-comment">// 若指针1处于根节点,将此符号计入结果,不用过滤,指针2向下走一步</span>                <span class="hljs-keyword">if</span> (tempNode == root)&#123;                    sb.append(c);                    begin++;                &#125;                <span class="hljs-comment">// 无论符号在开头、结尾,指针3都向下走一步</span>                position++;                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-comment">// 检查下级节点</span>            tempNode = tempNode.getSubNode(c);            <span class="hljs-keyword">if</span> (tempNode == <span class="hljs-keyword">null</span>)&#123;                <span class="hljs-comment">// 以为begin开头的字符串不是敏感词</span>                sb.append(text.charAt(begin));                position = ++ begin;                tempNode = root;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tempNode.isKeywordEnd)&#123;                <span class="hljs-comment">// 发现敏感词,将begin到position字符串替换掉</span>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; position - begin + <span class="hljs-number">1</span>; i++) &#123;                    sb.append(REPLACEMENT);                &#125;                begin = ++ position;                tempNode = root;            &#125; <span class="hljs-keyword">else</span> &#123;                position ++;            &#125;        &#125;        <span class="hljs-comment">// 最后一批字符计入结果</span>        sb.append(text.substring(begin));        <span class="hljs-keyword">return</span> sb.toString();    &#125;    <span class="hljs-comment">// 判断是否为符号</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSymbol</span><span class="hljs-params">(Character c)</span></span>&#123;        <span class="hljs-comment">// c &lt; 0x2E80 || c &gt; 0x9FFF 之间为东亚文字范围</span>        <span class="hljs-keyword">return</span> !CharUtils.isAsciiAlphanumeric(c) &amp;&amp; (c &lt; <span class="hljs-number">0x2E80</span> || c &gt; <span class="hljs-number">0x9FFF</span>);    &#125;&#125;</code></pre></li><li><p>编写sensitive-words.txt，设置要过滤的词</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201221165956.png" alt="过滤词"></p></li></ol><h2 id="发布帖子"><a href="#发布帖子" class="headerlink" title="发布帖子"></a>发布帖子</h2><ul><li>采用AJAX请求，实现发布帖子的功能  <ul><li>使用jQuery发送AJAX</li></ul></li></ul><h3 id="开发流程-2"><a href="#开发流程-2" class="headerlink" title="开发流程"></a>开发流程</h3><ol><li><p>导入fastJson</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>fastjson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.73<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></li><li><p>编写工具类，增加Json转换方法</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CommunityUtil</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getJSONString</span><span class="hljs-params">(<span class="hljs-keyword">int</span> code, String msg, Map&lt;String, Object&gt; map)</span></span>&#123;        JSONObject json = <span class="hljs-keyword">new</span> JSONObject();        json.put(<span class="hljs-string">&quot;code&quot;</span>, code);        json.put(<span class="hljs-string">&quot;msg&quot;</span>, msg);        <span class="hljs-keyword">if</span> (map != <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">for</span> (String key :map.keySet())&#123;                json.put(key, map.get(key));            &#125;        &#125;        <span class="hljs-keyword">return</span> json.toJSONString();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getJSONString</span><span class="hljs-params">(<span class="hljs-keyword">int</span> code, String msg)</span></span>&#123;        <span class="hljs-keyword">return</span> getJSONString(code, msg, <span class="hljs-keyword">null</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getJSONString</span><span class="hljs-params">(<span class="hljs-keyword">int</span> code)</span></span>&#123;        <span class="hljs-keyword">return</span> getJSONString(code, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);    &#125;&#125;</code></pre></li><li><p>discussPost-mapper增加insert</p><pre><code class="hljs java">&lt;insert id=<span class="hljs-string">&quot;insertDiscussPost&quot;</span> parameterType=<span class="hljs-string">&quot;DiscussPost&quot;</span> keyProperty=<span class="hljs-string">&quot;id&quot;</span>&gt;    <span class="hljs-function">insert into <span class="hljs-title">discuss_post</span><span class="hljs-params">(&lt;include refid=<span class="hljs-string">&quot;insertFields&quot;</span>&gt;&lt;/include&gt;)</span></span><span class="hljs-function">    <span class="hljs-title">values</span> <span class="hljs-params">(#&#123;userId&#125;,#&#123;title&#125;,#&#123;content&#125;,#&#123;type&#125;,#&#123;status&#125;,#&#123;createTime&#125;,#&#123;commentCount&#125;,#&#123;score&#125;)</span></span><span class="hljs-function">&lt;/insert&gt;</span></code></pre></li><li><p>DiscussPostService添加add方法</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">addDiscussPost</span><span class="hljs-params">(DiscussPost discussPost)</span></span>&#123;    <span class="hljs-keyword">if</span> (discussPost == <span class="hljs-keyword">null</span>)&#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;参数不能为空&quot;</span>);    &#125;    <span class="hljs-comment">// 转义html标记</span>    discussPost.setTitle(HtmlUtils.htmlEscape(discussPost.getTitle()));    discussPost.setContent(HtmlUtils.htmlEscape(discussPost.getContent()));    <span class="hljs-comment">// 敏感词过滤</span>    discussPost.setTitle(sensitiveFilter.Filter(discussPost.getTitle()));    discussPost.setContent(sensitiveFilter.Filter(discussPost.getContent()));    <span class="hljs-keyword">return</span> discussPostMapper.insertDiscussPost(discussPost);&#125;</code></pre></li><li><p>便携DiscussPostController</p><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(path = &quot;/add&quot;, method = RequestMethod.POST)</span><span class="hljs-meta">@ResponseBody</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">addDiscussPost</span><span class="hljs-params">(String title, String content)</span></span>&#123;    User user = hostHolder.getUsers();    <span class="hljs-keyword">if</span> (user == <span class="hljs-keyword">null</span>)&#123;        <span class="hljs-comment">// 未登陆</span>        <span class="hljs-keyword">return</span> CommunityUtil.getJSONString(<span class="hljs-number">403</span>, <span class="hljs-string">&quot;用户未登录！&quot;</span>);    &#125;    DiscussPost discussPost = <span class="hljs-keyword">new</span> DiscussPost();    discussPost.setUserId(user.getId());    discussPost.setTitle(title);    discussPost.setContent(content);    discussPost.setCreateTime(<span class="hljs-keyword">new</span> Date());    <span class="hljs-comment">// 报错将来统一处理</span>    discussPostService.addDiscussPost(discussPost);&#125;</code></pre></li><li><p>修改前端</p><pre><code class="hljs js">$(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;   $(<span class="hljs-string">&quot;#publishBtn&quot;</span>).click(publish);&#125;);<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">publish</span>(<span class="hljs-params"></span>) </span>&#123;   $(<span class="hljs-string">&quot;#publishModal&quot;</span>).modal(<span class="hljs-string">&quot;hide&quot;</span>);   <span class="hljs-comment">// 获取标题和内容</span>   <span class="hljs-keyword">var</span> title = $(<span class="hljs-string">&quot;#recipient-name&quot;</span>).val();   <span class="hljs-keyword">var</span> content = $(<span class="hljs-string">&quot;#message-text&quot;</span>).val();   <span class="hljs-comment">// 发送异步请求(POST)</span>   $.post(      CONTEXT_PATH + <span class="hljs-string">&quot;/discuss/add&quot;</span>,      &#123;<span class="hljs-string">&quot;title&quot;</span>:title,<span class="hljs-string">&quot;content&quot;</span>:content&#125;,      <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>) </span>&#123;         data = $.parseJSON(data);         <span class="hljs-comment">// 在提示框中显示返回消息</span>         $(<span class="hljs-string">&quot;#hintBody&quot;</span>).text(data.msg);         <span class="hljs-comment">// 显示提示框</span>         $(<span class="hljs-string">&quot;#hintModal&quot;</span>).modal(<span class="hljs-string">&quot;show&quot;</span>);         <span class="hljs-comment">// 2秒后,自动隐藏提示框</span>         <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;            $(<span class="hljs-string">&quot;#hintModal&quot;</span>).modal(<span class="hljs-string">&quot;hide&quot;</span>);            <span class="hljs-comment">// 刷新页面</span>            <span class="hljs-keyword">if</span>(data.code == <span class="hljs-number">0</span>) &#123;               <span class="hljs-built_in">window</span>.location.reload();            &#125;         &#125;, <span class="hljs-number">2000</span>);      &#125;   );&#125;</code></pre></li><li><p>修改模版引擎</p></li></ol><h3 id="业务流程图-1"><a href="#业务流程图-1" class="headerlink" title="业务流程图"></a>业务流程图</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201221173121.png" alt="流程图"></p><h2 id="帖子详情"><a href="#帖子详情" class="headerlink" title="帖子详情"></a>帖子详情</h2><ul><li>index.html在帖子标题上增加访问路径</li><li>discuss-detail.html<ul><li>处理静态资源访问路径</li><li>复用index.html的header区</li><li>显示标题、作者、发布时间、正文等内容</li></ul></li></ul><h3 id="开发流程-3"><a href="#开发流程-3" class="headerlink" title="开发流程"></a>开发流程</h3><ol><li><p>编写discussPost-mapper 增select</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectDiscussPostById&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;DiscussPost&quot;</span> &gt;</span>    select    <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">&quot;selectFields&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span>    from discuss_post    where id = #&#123;id&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre></li><li><p>编写discussPostService 增find</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> DiscussPost <span class="hljs-title">findDiscussPostById</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span></span>&#123;    <span class="hljs-keyword">return</span> discussPostMapper.selectDiscussPostById(id);&#125;</code></pre></li><li><p>编写DiscussPostController</p><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(path = &quot;/detail/&#123;discussPostId&#125;&quot;, method = RequestMethod.GET)</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getDiscussPost</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;discussPostId&quot;)</span> <span class="hljs-keyword">int</span> discussPostId, Page page, Model model)</span></span>&#123;    DiscussPost post = discussPostService.findDiscussPostById(discussPostId);    model.addAttribute(<span class="hljs-string">&quot;post&quot;</span>, post);    <span class="hljs-comment">// 获取user得到username 还可以用关联查询 之后改为redis缓存</span>    User user = userService.findUserById(post.getUserId());    model.addAttribute(<span class="hljs-string">&quot;user&quot;</span>, user);    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;site/discuss-detail&quot;</span>;&#125;</code></pre></li><li><p>处理模版引擎，详情查看源码</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201221173900.png" alt="其他省略"></p></li></ol><h2 id="显示评论"><a href="#显示评论" class="headerlink" title="显示评论"></a>显示评论</h2><ul><li>数据层<ul><li>根据实体查询一页评论数据</li><li>根据实体查询评论的数量</li></ul></li><li>业务层<ul><li>处理查询评论业务</li><li>处理查询评论数量业务</li></ul></li><li>表现层<ul><li>显示帖子详情数据时，同时显示帖子所有的评论数据</li></ul></li></ul><h3 id="开发流程-4"><a href="#开发流程-4" class="headerlink" title="开发流程"></a>开发流程</h3><ol><li><p>编写评论pojo</p><pre><code class="hljs java"><span class="hljs-meta">@Data</span><span class="hljs-meta">@AllArgsConstructor</span><span class="hljs-meta">@NoArgsConstructor</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Comment</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> userId;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> entityType;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> entityId;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> targetId;    <span class="hljs-keyword">private</span> String content;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> status;    <span class="hljs-keyword">private</span> Date createTime;&#125;</code></pre></li><li><p>编写comment-mapper.xml和CommentMapper基础</p><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><span class="hljs-comment">//@Repository</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CommentMapper</span> </span>&#123;        <span class="hljs-function">List&lt;Comment&gt; <span class="hljs-title">selectCommentsByEntity</span><span class="hljs-params">(<span class="hljs-keyword">int</span> entityType, <span class="hljs-keyword">int</span> entityId, <span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">int</span> limit)</span></span>;        <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">selectCountByEntity</span><span class="hljs-params">(<span class="hljs-keyword">int</span> entityType, <span class="hljs-keyword">int</span> entityId)</span></span>;&#125;</code></pre><pre><code class="hljs java">&lt;sql id=<span class="hljs-string">&quot;selectFields&quot;</span> &gt;    id, user_id, entity_type, entity_id, target_id, content, status, create_time&lt;/sql&gt;&lt;select id=<span class="hljs-string">&quot;selectCommentsByEntity&quot;</span> resultType=<span class="hljs-string">&quot;Comment&quot;</span>&gt;    select    &lt;include refid=&quot;selectFields&quot;&gt;&lt;/include&gt;    from comment    where status = <span class="hljs-number">0</span>    and entity_type = #&#123;entityType&#125;    and entity_id = #&#123;entityId&#125;    order by create_time asc    limit #&#123;offset&#125;,#&#123;limit&#125;&lt;/select&gt;&lt;select id=<span class="hljs-string">&quot;selectCountByEntity&quot;</span> resultType=<span class="hljs-string">&quot;int&quot;</span>&gt;    <span class="hljs-function">select <span class="hljs-title">count</span><span class="hljs-params">(id)</span></span><span class="hljs-function">    from comment</span><span class="hljs-function">    where status </span>= <span class="hljs-number">0</span>    and entity_type = #&#123;entityType&#125;    and entity_id = #&#123;entityId&#125;&lt;/select&gt;</code></pre></li><li><p>编写service</p><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CommentService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CommunityConstant</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> CommentMapper commentMapper;       <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Comment&gt; <span class="hljs-title">findCommentsByEntity</span><span class="hljs-params">(<span class="hljs-keyword">int</span> entityType, <span class="hljs-keyword">int</span> entityId, <span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">int</span> limit)</span></span>&#123;        <span class="hljs-keyword">return</span> commentMapper.selectCommentsByEntity(entityType, entityId, offset, limit);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findCommentCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> entityType, <span class="hljs-keyword">int</span> entityId)</span></span>&#123;        <span class="hljs-keyword">return</span> commentMapper.selectCountByEntity(entityType, entityId);    &#125;</code></pre></li><li><p>编写DiscussPostController, 丰富/detail/{discussPostId}请求</p><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(path = &quot;/detail/&#123;discussPostId&#125;&quot;, method = RequestMethod.GET)</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getDiscussPost</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;discussPostId&quot;)</span> <span class="hljs-keyword">int</span> discussPostId, Page page, Model model)</span></span>&#123;    DiscussPost post = discussPostService.findDiscussPostById(discussPostId);    model.addAttribute(<span class="hljs-string">&quot;post&quot;</span>, post);    <span class="hljs-comment">// 获取user得到username 还可以用关联查询 之后改为redis缓存</span>    User user = userService.findUserById(post.getUserId());    model.addAttribute(<span class="hljs-string">&quot;user&quot;</span>, user);    <span class="hljs-comment">// 评论区</span>    page.setLimit(<span class="hljs-number">5</span>);    page.setPath(<span class="hljs-string">&quot;/discuss/detail/&quot;</span> + discussPostId);    page.setRows(post.getCommentCount());    List&lt;Comment&gt; comments = commentService.findCommentsByEntity(            ENTITY_TYPE_POST, post.getId(), page.getOffset(), page.getLimit());    List&lt;Map&lt;String, Object&gt;&gt; show_comments = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">if</span> (comments != <span class="hljs-keyword">null</span>)&#123;        <span class="hljs-keyword">for</span> (Comment comment: comments             ) &#123;            Map&lt;String,Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();            <span class="hljs-comment">// 评论</span>            map.put(<span class="hljs-string">&quot;comment&quot;</span>, comment);            User userOfComment = userService.findUserById(comment.getUserId());            <span class="hljs-comment">// 评论作者</span>            map.put(<span class="hljs-string">&quot;user&quot;</span>, userOfComment);            <span class="hljs-comment">// 评论也有评论</span>            <span class="hljs-comment">// 回复不进行分页</span>            List&lt;Comment&gt; replyList = commentService.findCommentsByEntity(                    ENTITY_TYPE_COMMENT, comment.getId(), <span class="hljs-number">0</span>, Integer.MAX_VALUE);            List&lt;Map&lt;String, Object&gt;&gt; show_reply = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();            <span class="hljs-keyword">if</span> (show_reply != <span class="hljs-keyword">null</span>)&#123;                <span class="hljs-keyword">for</span> (Comment reply: replyList                     ) &#123;                    Map&lt;String,Object&gt; replyMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();                    replyMap.put(<span class="hljs-string">&quot;reply&quot;</span>, reply);                    User userOfReply = userService.findUserById(reply.getUserId());                    replyMap.put(<span class="hljs-string">&quot;user&quot;</span>, userOfReply );                    <span class="hljs-comment">// 回复目标！</span>                    User target = reply.getTargetId() == <span class="hljs-number">0</span> ? <span class="hljs-keyword">null</span> : userService.findUserById(reply.getTargetId());                    replyMap.put(<span class="hljs-string">&quot;target&quot;</span>, target);                &#125;            &#125;            map.put(<span class="hljs-string">&quot;replys&quot;</span>,show_reply);            <span class="hljs-comment">// 回复数量</span>            <span class="hljs-keyword">int</span> replyCount = commentService.findCommentCount(ENTITY_TYPE_COMMENT, comment.getId());            map.put(<span class="hljs-string">&quot;replyCount&quot;</span>,replyCount);            show_comments.add(map);        &#125;    &#125;    model.addAttribute(<span class="hljs-string">&quot;comments&quot;</span>,show_comments);    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;site/discuss-detail&quot;</span>;&#125;</code></pre><p>对应的常量接口</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 实体类型:帖子</span><span class="hljs-comment"> */</span><span class="hljs-keyword">int</span> ENTITY_TYPE_POST = <span class="hljs-number">1</span>;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 实体类型:评论</span><span class="hljs-comment"> */</span><span class="hljs-keyword">int</span> ENTITY_TYPE_COMMENT = <span class="hljs-number">2</span>;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 实体类型:用户</span><span class="hljs-comment"> */</span><span class="hljs-keyword">int</span> ENTITY_TYPE_USER = <span class="hljs-number">3</span>;</code></pre></li><li><p>修改discuss-detail.html模版引擎(代码众多，查看源文件)</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201222143039.png" alt="模版引擎"></p></li></ol><h3 id="开发流程图"><a href="#开发流程图" class="headerlink" title="开发流程图"></a>开发流程图</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201222145118.png" alt="流程图"></p><h1 id="评论私信模块"><a href="#评论私信模块" class="headerlink" title="评论私信模块"></a>评论私信模块</h1><h2 id="添加评论"><a href="#添加评论" class="headerlink" title="添加评论"></a>添加评论</h2><ul><li>数据层<ul><li>增加评论数据</li><li>修改帖子评论的数量</li><li>（事务）</li></ul></li><li>业务层<ul><li>处理添加评论的业务</li><li>先增再更新评论数量</li></ul></li><li>表现层<ul><li>处理添加评论数据的请求</li><li>设置添加评论的表单</li></ul></li></ul><h3 id="开发流程-5"><a href="#开发流程-5" class="headerlink" title="开发流程"></a>开发流程</h3><ol><li><p>编写CommentMapper 以及mapper文件</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">insertComment</span><span class="hljs-params">(Comment comment)</span></span>;</code></pre><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">sql</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insertFields&quot;</span> &gt;</span>        user_id, entity_type, entity_id, target_id, content, status, create_time<span class="hljs-tag">&lt;/<span class="hljs-name">sql</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insertComment&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;Comment&quot;</span>&gt;</span>    insert into comment (<span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">&quot;insertFields&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span>)    values(#&#123;userId&#125;,#&#123;entityType&#125;,#&#123;entityId&#125;,#&#123;targetId&#125;,#&#123;content&#125;,#&#123;status&#125;,#&#123;createTime&#125;)<span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span></code></pre></li><li><p>编写DiscussPostMapper 更新评论方法</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">updateCommentCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, <span class="hljs-keyword">int</span> commentCount)</span></span>;</code></pre><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;updateCommentCount&quot;</span> &gt;</span>    update discuss_post set comment_count = #&#123;commentCount&#125;    where id = #&#123;id&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span></code></pre></li><li><p>编写DiscussPostService</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">updateCommentCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, <span class="hljs-keyword">int</span> commentCount)</span></span>&#123;    <span class="hljs-keyword">return</span> discussPostMapper.updateCommentCount(id, commentCount);&#125;</code></pre></li><li><p>编写CommentService add方法</p><pre><code class="hljs java"><span class="hljs-meta">@Transactional(isolation = Isolation.READ_COMMITTED, propagation = Propagation.REQUIRED)</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">addComment</span><span class="hljs-params">(Comment comment)</span></span>&#123;    <span class="hljs-comment">// 要过滤</span>    <span class="hljs-keyword">if</span> (comment == <span class="hljs-keyword">null</span>)&#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;参数为空！&quot;</span>);    &#125;    comment.setContent(HtmlUtils.htmlEscape(comment.getContent()));    comment.setContent(sensitiveFilter.Filter(comment.getContent()));    <span class="hljs-keyword">int</span> rows = commentMapper.insertComment(comment);    <span class="hljs-comment">// 更新帖子评论数量</span>    <span class="hljs-keyword">if</span> (comment.getEntityType() == ENTITY_TYPE_POST)&#123;        <span class="hljs-keyword">int</span> count = commentMapper.selectCountByEntity(ENTITY_TYPE_POST, comment.getEntityId());        discussPostService.updateCommentCount(comment.getEntityId(), count);    &#125;    <span class="hljs-keyword">return</span> rows;&#125;</code></pre></li><li><p>编写CommentController</p><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><span class="hljs-keyword">private</span> RedisTemplate redisTemplate;<span class="hljs-meta">@RequestMapping(path = &quot;/add/&#123;discussPostId&#125;&quot;, method = RequestMethod.POST)</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">addComment</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;discussPostId&quot;)</span><span class="hljs-keyword">int</span> discussPostId,Comment comment)</span></span>&#123;    comment.setUserId(hostHolder.getUsers().getId());    comment.setStatus(<span class="hljs-number">0</span>);    comment.setCreateTime(<span class="hljs-keyword">new</span> Date());    commentService.addComment(comment);    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;redirect:/discuss/detail/&quot;</span> + discussPostId;&#125;</code></pre></li><li><p>修改模版引擎</p></li></ol><h3 id="开发流程图-1"><a href="#开发流程图-1" class="headerlink" title="开发流程图"></a>开发流程图</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201222150634.png" alt="流程图"></p><h2 id="私信列表-数据库小游戏"><a href="#私信列表-数据库小游戏" class="headerlink" title="私信列表(数据库小游戏)"></a>私信列表(数据库小游戏)</h2><ul><li>私信列表<ul><li>查询当前会话列表</li><li>每个会话只显示一条最新的私信</li><li>支持分页</li></ul></li><li>私信详情<ul><li>查询某个会话所包含的私信</li><li>支持分页显示</li></ul></li></ul><h3 id="私信首页和详情开发流程"><a href="#私信首页和详情开发流程" class="headerlink" title="私信首页和详情开发流程"></a>私信首页和详情开发流程</h3><ol><li><p>编写MessageMapper 添加方法</p><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MessageMapper</span> </span>&#123;    <span class="hljs-comment">// 查询当前用户会话列表,针对每个会话只返回一条最新私信</span>    <span class="hljs-function">List&lt;Message&gt; <span class="hljs-title">selectConversations</span><span class="hljs-params">(<span class="hljs-keyword">int</span> userId, <span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">int</span> limit)</span></span>;    <span class="hljs-comment">// 查询当前用户会话数量</span>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">selectConversationCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> userId)</span></span>;    <span class="hljs-comment">// 查询某个会话所包含的私信列表</span>    <span class="hljs-function">List&lt;Message&gt; <span class="hljs-title">selectLetters</span><span class="hljs-params">(String conversationId, <span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">int</span> limit)</span></span>;    <span class="hljs-comment">// 查询某个会话所包含的私信数量</span>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">selectLetterCount</span><span class="hljs-params">(String conversationId)</span></span>;    <span class="hljs-comment">// 查询未读私信数量,查询总未读,查询对某用户未读需动态conversationId</span>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">selectLetterUnreadCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> userId, String conversationId)</span></span>;&#125;</code></pre></li><li><p>编写mapper文件</p><pre><code class="hljs java">&lt;sql id=<span class="hljs-string">&quot;selectFields&quot;</span>&gt;    id,from_id,to_id,conversation_id,content,status,create_time&lt;/sql&gt;&lt;sql id=<span class="hljs-string">&quot;insertFields&quot;</span>&gt;    from_id,to_id,conversation_id,content,status,create_time&lt;/sql&gt;&lt;!--  获取每个通话中最新的一条消息  --&gt;&lt;select id=<span class="hljs-string">&quot;selectConversations&quot;</span> resultType=<span class="hljs-string">&quot;Message&quot;</span>&gt;    select &lt;include refid=&quot;selectFields&quot;&gt;&lt;/include&gt;    from message    <span class="hljs-function">where id <span class="hljs-title">in</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">        select max(id)</span> from message</span><span class="hljs-function">        where status !</span>= <span class="hljs-number">2</span>        and from_id != <span class="hljs-number">1</span>        and (from_id = #&#123;userId&#125; or to_id = #&#123;userId&#125;)        group by conversation_id    )    order by create_time desc    limit #&#123;offset&#125;,#&#123;limit&#125;&lt;/select&gt;&lt;select id=<span class="hljs-string">&quot;selectConversationCount&quot;</span> resultType=<span class="hljs-string">&quot;int&quot;</span>&gt;    <span class="hljs-function">select <span class="hljs-title">count</span><span class="hljs-params">(m.maxid)</span> <span class="hljs-title">from</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">        select max(id)</span> as maxid from message</span><span class="hljs-function">        where status !</span>= <span class="hljs-number">2</span>        and from_id != <span class="hljs-number">1</span>        and (from_id = #&#123;userId&#125; or to_id = #&#123;userId&#125;)        group by conversation_id    )as m&lt;/select&gt;&lt;select id=<span class="hljs-string">&quot;selectLetters&quot;</span> resultType=<span class="hljs-string">&quot;Message&quot;</span>&gt;    select &lt;include refid=&quot;selectFields&quot;&gt;&lt;/include&gt;    from message    where status != <span class="hljs-number">2</span>    and from_id != <span class="hljs-number">1</span>    and conversation_id = #&#123;conversationId&#125;    order by create_time desc    limit #&#123;offset&#125;,#&#123;limit&#125;&lt;/select&gt;&lt;select id=<span class="hljs-string">&quot;selectLetterCount&quot;</span> resultType=<span class="hljs-string">&quot;int&quot;</span>&gt;    <span class="hljs-function">select <span class="hljs-title">count</span><span class="hljs-params">(id)</span></span><span class="hljs-function">    from message</span><span class="hljs-function">    where status !</span>= <span class="hljs-number">2</span>    and from_id != <span class="hljs-number">1</span>    and conversation_id = #&#123;conversationId&#125;&lt;/select&gt;&lt;select id=<span class="hljs-string">&quot;selectLetterUnreadCount&quot;</span> resultType=<span class="hljs-string">&quot;int&quot;</span>&gt;    <span class="hljs-function">select <span class="hljs-title">count</span><span class="hljs-params">(id)</span></span><span class="hljs-function">    from message</span><span class="hljs-function">    where status </span>= <span class="hljs-number">0</span>    and from_id != <span class="hljs-number">1</span>    and to_id = #&#123;userId&#125;    &lt;<span class="hljs-keyword">if</span> test=<span class="hljs-string">&quot;conversationId!=null&quot;</span>&gt;        and conversation_id = #&#123;conversationId&#125;    &lt;/if&gt;&lt;/select&gt;</code></pre></li><li><p>编写MessageService</p><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> MessageMapper messageMapper;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Message&gt; <span class="hljs-title">findConversations</span><span class="hljs-params">(<span class="hljs-keyword">int</span> userId, <span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">int</span> limit)</span></span>&#123;        <span class="hljs-keyword">return</span> messageMapper.selectConversations(userId, offset, limit);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findConversationCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> userId)</span></span>&#123;        <span class="hljs-keyword">return</span> messageMapper.selectConversationCount(userId);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Message&gt; <span class="hljs-title">findLetters</span><span class="hljs-params">(String conversationId, <span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">int</span> limit)</span></span>&#123;        <span class="hljs-keyword">return</span> messageMapper.selectLetters(conversationId, offset, limit);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findLetterCount</span><span class="hljs-params">(String conversationId)</span></span>&#123;        <span class="hljs-keyword">return</span> messageMapper.selectLetterCount(conversationId);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findeLetterUnreadCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> userId, String conversationId)</span></span>&#123;        <span class="hljs-keyword">return</span> messageMapper.selectLetterUnreadCount(userId, conversationId);    &#125;&#125;</code></pre></li><li><p>编写MessageController 展示私信首页</p><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(path = &quot;/list&quot;,method = RequestMethod.GET)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getMessageList</span><span class="hljs-params">(Model model, Page page)</span></span>&#123;        User user = hostHolder.getUsers();        <span class="hljs-comment">// 设置分页信息</span>        page.setPath(<span class="hljs-string">&quot;/message/list&quot;</span>);        page.setLimit(<span class="hljs-number">5</span>);        page.setRows(messageService.findConversationCount(user.getId()));        List&lt;Message&gt; conversations = messageService.findConversations(user.getId(), page.getOffset(), page.getLimit());        List&lt;Map&lt;String, Object&gt;&gt; show_conversations = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">for</span> (Message m: conversations             ) &#123;            Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();            map.put(<span class="hljs-string">&quot;conversation&quot;</span>, m);            map.put(<span class="hljs-string">&quot;unreadCount&quot;</span>, messageService.findeLetterUnreadCount(user.getId(), m.getConversationId()));            map.put(<span class="hljs-string">&quot;letterCount&quot;</span>, messageService.findLetterCount(m.getConversationId()));            <span class="hljs-keyword">int</span> targetId = user.getId() == m.getFromId() ? m.getToId() : m.getFromId();            map.put(<span class="hljs-string">&quot;targetUser&quot;</span>, userService.findUserById(targetId));            show_conversations.add(map);        &#125;        model.addAttribute(<span class="hljs-string">&quot;conversations&quot;</span>, show_conversations);        <span class="hljs-comment">// 查询未读消息数量</span>        <span class="hljs-keyword">int</span> unreadCountAll = messageService.findeLetterUnreadCount(user.getId(), <span class="hljs-keyword">null</span>);        model.addAttribute(<span class="hljs-string">&quot;unreadCountAll&quot;</span>, unreadCountAll);        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;site/letter&quot;</span>;    &#125;</code></pre></li><li><p>修改模版引擎</p></li><li><p>编写MessageController 展示私信详情页面</p><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(path = &quot;/detail/&#123;conversationId&#125;&quot;,method = RequestMethod.GET)</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getMessageDetail</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> String conversationId, Model model, Page page)</span></span>&#123;    page.setPath(<span class="hljs-string">&quot;/message/detail/&quot;</span>+conversationId);    page.setRows(messageService.findLetterCount(conversationId));    page.setLimit(<span class="hljs-number">5</span>);    List&lt;Message&gt; letters = messageService.findLetters(conversationId, page.getOffset(), page.getLimit());    List&lt;Map&lt;String, Object&gt;&gt; show_letters = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">for</span> (Message m:letters         ) &#123;        Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        map.put(<span class="hljs-string">&quot;letter&quot;</span>, m);        map.put(<span class="hljs-string">&quot;fromUser&quot;</span>, userService.findUserById(m.getFromId()));        show_letters.add(map);    &#125;    model.addAttribute(<span class="hljs-string">&quot;targetUser&quot;</span>, findTargetUser(conversationId));    model.addAttribute(<span class="hljs-string">&quot;letters&quot;</span>, show_letters);    <span class="hljs-comment">// 设置已读</span>    List&lt;Integer&gt; ids = getMessageIds(letters);    <span class="hljs-keyword">if</span> (ids != <span class="hljs-keyword">null</span> &amp;&amp; !ids.isEmpty())&#123;        messageService.readMessage(ids);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;site/letter-detail&quot;</span>;&#125;</code></pre></li></ol><p>​     期间涉及私有方法:</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> User <span class="hljs-title">findTargetUser</span><span class="hljs-params">(String conversationId)</span></span>&#123;    String[] s = conversationId.split(<span class="hljs-string">&quot;_&quot;</span>);    <span class="hljs-keyword">int</span> id0 = Integer.valueOf(s[<span class="hljs-number">0</span>]);    <span class="hljs-keyword">int</span> id1 = Integer.valueOf(s[<span class="hljs-number">1</span>]);    <span class="hljs-keyword">if</span> (hostHolder.getUsers().getId() == id0)&#123;        <span class="hljs-keyword">return</span> userService.findUserById(id1);    &#125;<span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">return</span> userService.findUserById(id0);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> List&lt;Integer&gt; <span class="hljs-title">getMessageIds</span><span class="hljs-params">(List&lt;Message&gt; messageList)</span></span>&#123;    List&lt;Integer&gt; ids = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">if</span> (messageList!=<span class="hljs-keyword">null</span>)&#123;        <span class="hljs-keyword">for</span> (Message message :messageList                ) &#123;            <span class="hljs-keyword">if</span> (hostHolder.getUsers().getId() == message.getToId() &amp;&amp; message.getStatus() == <span class="hljs-number">0</span>)&#123;                <span class="hljs-comment">// 接收者身份</span>                ids.add(message.getId());            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> ids;&#125;</code></pre><h3 id="开发流程图-2"><a href="#开发流程图-2" class="headerlink" title="开发流程图"></a>开发流程图</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201222160141.png" alt="流程图"></p><h2 id="发送私信"><a href="#发送私信" class="headerlink" title="发送私信"></a>发送私信</h2><ul><li><p>发送私信</p><ul><li>采用异步的方式发送私信</li><li>发送成功后刷新私信列表</li></ul></li><li><p>设置已读</p></li></ul><h3 id="开发流程-6"><a href="#开发流程-6" class="headerlink" title="开发流程"></a>开发流程</h3><ol><li><p>编写MessageMapper以及mapper文件</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">insertMessage</span><span class="hljs-params">(Message message)</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">updateMessageStatus</span><span class="hljs-params">(List&lt;Integer&gt; ids, <span class="hljs-keyword">int</span> status)</span></span>;</code></pre><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insertMessage&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;Message&quot;</span> <span class="hljs-attr">keyProperty</span>=<span class="hljs-string">&quot;id&quot;</span>&gt;</span>    insert into message(<span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">&quot;insertFields&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span>)    values(#&#123;fromId&#125;,#&#123;toId&#125;,#&#123;conversationId&#125;,#&#123;content&#125;,#&#123;status&#125;,#&#123;createTime&#125;)<span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;updateMessageStatus&quot;</span>&gt;</span>    update message set status = #&#123;status&#125;    where id in    <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;ids&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">open</span>=<span class="hljs-string">&quot;(&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;,&quot;</span> <span class="hljs-attr">close</span>=<span class="hljs-string">&quot;)&quot;</span>&gt;</span>        #&#123;id&#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span></code></pre></li><li><p>编写MessageService</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">insertLetter</span><span class="hljs-params">(Message message)</span></span>&#123;    <span class="hljs-comment">// 敏感词过滤</span>    message.setContent(HtmlUtils.htmlEscape(message.getContent()));    message.setContent(sensitiveFilter.Filter(message.getContent()));    <span class="hljs-keyword">return</span> messageMapper.insertMessage(message);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">readMessage</span><span class="hljs-params">(List&lt;Integer&gt; ids)</span></span>&#123;    <span class="hljs-keyword">return</span> messageMapper.updateMessageStatus(ids, <span class="hljs-number">1</span>);&#125;</code></pre></li><li><p>编写MessageController</p><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(path = &quot;/send&quot;,method = RequestMethod.POST)</span><span class="hljs-meta">@ResponseBody</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">sendMessage</span><span class="hljs-params">(String toName, String content)</span></span>&#123;    User toUser = userService.findUserByUsername(toName);    <span class="hljs-keyword">if</span> (toUser == <span class="hljs-keyword">null</span>)&#123;        <span class="hljs-keyword">return</span> CommunityUtil.getJSONString(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;目标用户不存在&quot;</span>);    &#125;    Message message = <span class="hljs-keyword">new</span> Message();    message.setFromId(hostHolder.getUsers().getId());    message.setToId(toUser.getId());    <span class="hljs-keyword">if</span> (message.getFromId() &lt; message.getToId())&#123;        message.setConversationId(message.getFromId()+<span class="hljs-string">&quot;_&quot;</span>+message.getToId());    &#125;<span class="hljs-keyword">else</span> &#123;        message.setConversationId(message.getToId()+<span class="hljs-string">&quot;_&quot;</span>+message.getFromId());    &#125;    message.setContent(content);    message.setCreateTime(<span class="hljs-keyword">new</span> Date());    messageService.insertLetter(message);    <span class="hljs-keyword">return</span> CommunityUtil.getJSONString(<span class="hljs-number">0</span>);&#125;</code></pre></li><li><p>编写js</p><pre><code class="hljs java">$(function()&#123;   $(<span class="hljs-string">&quot;#sendBtn&quot;</span>).click(send_letter);   $(<span class="hljs-string">&quot;.close&quot;</span>).click(delete_msg);&#125;);<span class="hljs-function">function <span class="hljs-title">send_letter</span><span class="hljs-params">()</span> </span>&#123;   $(<span class="hljs-string">&quot;#sendModal&quot;</span>).modal(<span class="hljs-string">&quot;hide&quot;</span>);   <span class="hljs-keyword">var</span> toName = $(<span class="hljs-string">&quot;#recipient-name&quot;</span>).val();   <span class="hljs-keyword">var</span> content = $(<span class="hljs-string">&quot;#message-text&quot;</span>).val();   $.post(      CONTEXT_PATH + <span class="hljs-string">&quot;/message/send&quot;</span>,      &#123;<span class="hljs-string">&quot;toName&quot;</span>:toName,<span class="hljs-string">&quot;content&quot;</span>:content&#125;,      function(data) &#123;         data = $.parseJSON(data);         <span class="hljs-keyword">if</span>(data.code == <span class="hljs-number">0</span>) &#123;            $(<span class="hljs-string">&quot;#hintBody&quot;</span>).text(<span class="hljs-string">&quot;发送成功!&quot;</span>);         &#125; <span class="hljs-keyword">else</span> &#123;            $(<span class="hljs-string">&quot;#hintBody&quot;</span>).text(data.msg);         &#125;         $(<span class="hljs-string">&quot;#hintModal&quot;</span>).modal(<span class="hljs-string">&quot;show&quot;</span>);         setTimeout(function()&#123;            $(<span class="hljs-string">&quot;#hintModal&quot;</span>).modal(<span class="hljs-string">&quot;hide&quot;</span>);            location.reload();         &#125;, <span class="hljs-number">2000</span>);      &#125;   );&#125;<span class="hljs-function">function <span class="hljs-title">delete_msg</span><span class="hljs-params">()</span> </span>&#123;   <span class="hljs-comment">// TODO 删除数据</span>   $(<span class="hljs-keyword">this</span>).parents(<span class="hljs-string">&quot;.media&quot;</span>).remove();&#125;</code></pre></li></ol><h3 id="开发流程-7"><a href="#开发流程-7" class="headerlink" title="开发流程"></a>开发流程</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201222161836.png" alt="设置未读"></p><h1 id="项目管理模块"><a href="#项目管理模块" class="headerlink" title="项目管理模块"></a>项目管理模块</h1><h2 id="统一异常处理"><a href="#统一异常处理" class="headerlink" title="统一异常处理"></a>统一异常处理</h2><ul><li>@ControllerAdvice<ul><li>用于修饰类,表示该类是Controller的全局配置类。</li><li>在此类中，可以对Controller进行如下三种全局配置:异常处理方案、绑定数据方案、绑定参数方案。</li></ul></li><li>@ExceptionHandler<ul><li>用于修饰方法，该方法会在Controller出现异常后被调用，用于处理捕获到的异常。</li></ul></li><li>@ModelAttribute<ul><li>用于修饰方法，该方法会在Controller方法执行前被调用，用 于为Model对象绑定参数。</li></ul></li><li>@DataBinder<ul><li>用于修饰方法，该方法会在Controller方法执行前被调用，用于绑定参数的转换器。</li></ul></li></ul><h3 id="error页面"><a href="#error页面" class="headerlink" title="error页面"></a>error页面</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201222164736.png" alt="error"></p><h3 id="统一异常处理-1"><a href="#统一异常处理-1" class="headerlink" title="统一异常处理"></a>统一异常处理</h3><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(path = &quot;/error&quot;,method = RequestMethod.GET)</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getErrorPage</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;error/500&quot;</span>;&#125;<span class="hljs-comment">// 拒绝访问时的提示页面</span><span class="hljs-meta">@RequestMapping(path = &quot;/denied&quot;, method = RequestMethod.GET)</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getDeniedPage</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;/error/404&quot;</span>;&#125;</code></pre><h3 id="Controller全局配置类"><a href="#Controller全局配置类" class="headerlink" title="Controller全局配置类"></a>Controller全局配置类</h3><blockquote><p>不需要对任何Controller加处理，只需要编写全局配置类</p></blockquote><pre><code class="hljs java"><span class="hljs-meta">@ControllerAdvice(annotations = Controller.class)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExceptionAdvice</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger logger = LoggerFactory.getLogger(ExceptionAdvice.class);    <span class="hljs-meta">@ExceptionHandler(&#123;Exception.class&#125;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handlerException</span><span class="hljs-params">(Exception e, HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        logger.error(<span class="hljs-string">&quot;服务器发生异常&quot;</span> + e.getMessage());        <span class="hljs-keyword">for</span> (StackTraceElement element : e.getStackTrace())&#123;            logger.error(element.toString());        &#125;        String xRequestedWith = request.getHeader(<span class="hljs-string">&quot;x-requested-with&quot;</span>);        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;XMLHttpRequest&quot;</span>.equals(xRequestedWith))&#123;            <span class="hljs-comment">// 异步请求</span>            response.setContentType(<span class="hljs-string">&quot;application/plain;charset=utf-8&quot;</span>);            PrintWriter writer = response.getWriter();            writer.write(CommunityUtil.getJSONString(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;服务器异常&quot;</span>));        &#125;<span class="hljs-keyword">else</span> &#123;            response.sendRedirect(request.getContextPath() + <span class="hljs-string">&quot;/error&quot;</span>);        &#125;    &#125;&#125;</code></pre><h2 id="统一记录日志"><a href="#统一记录日志" class="headerlink" title="统一记录日志"></a>统一记录日志</h2><ul><li>AOP实现<ul><li><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201222165608.png" alt="AOP"></li></ul></li></ul><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201222170059.png" alt="原理图"></p><p>详细原理查看Spring AOP</p><h3 id="Aspect实现AOP"><a href="#Aspect实现AOP" class="headerlink" title="Aspect实现AOP"></a>Aspect实现AOP</h3><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-meta">@Aspect</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServiceLogAspect</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger logger = LoggerFactory.getLogger(ServiceLogAspect.class);    <span class="hljs-meta">@Pointcut(&quot;execution(* com.nowcoder.community.service.*.*(..))&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pointcut</span><span class="hljs-params">()</span></span>&#123;&#125;    <span class="hljs-meta">@Before(&quot;pointcut()&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">(JoinPoint joinPoint)</span></span>&#123;        <span class="hljs-comment">// 用户[ip],在[xxx]时间 访问[com.xxx.xxx]功能</span>        ServletRequestAttributes attributes =(ServletRequestAttributes) RequestContextHolder.getRequestAttributes();        <span class="hljs-keyword">if</span> (attributes == <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-comment">// 是特殊调用 kafka</span>            <span class="hljs-keyword">return</span>;        &#125;        HttpServletRequest request = attributes.getRequest();        String ip = request.getRemoteHost();        String now = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>).format(<span class="hljs-keyword">new</span> Date());        String classname = joinPoint.getSignature().getDeclaringTypeName() + <span class="hljs-string">&quot;.&quot;</span> + joinPoint.getSignature().getName();        logger.info(String.format(<span class="hljs-string">&quot;用户[%s],在[%s],访问了[%s]&quot;</span>, ip, now, classname));    &#125;&#125;</code></pre><h1 id="点赞关注模块"><a href="#点赞关注模块" class="headerlink" title="点赞关注模块"></a>点赞关注模块</h1><h2 id="整合redis"><a href="#整合redis" class="headerlink" title="整合redis"></a>整合redis</h2><h3 id="开发流程-8"><a href="#开发流程-8" class="headerlink" title="开发流程"></a>开发流程</h3><ol><li><p>引入依赖</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></li><li><p>配置redis</p><p>ymal配置：</p><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span>  <span class="hljs-comment">#RedisProperties</span>  <span class="hljs-attr">redis:</span>    <span class="hljs-attr">database:</span> <span class="hljs-number">1</span>    <span class="hljs-attr">host:</span> <span class="hljs-string">localhost</span>    <span class="hljs-attr">port:</span> <span class="hljs-number">6379</span></code></pre><p>编写配置类</p><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisConfig</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="hljs-title">redisTemplate</span><span class="hljs-params">(RedisConnectionFactory factory)</span></span>&#123;        RedisTemplate&lt;String, Object&gt; template = <span class="hljs-keyword">new</span> RedisTemplate&lt;&gt;();        template.setConnectionFactory(factory);        <span class="hljs-comment">// 设置key序列化方式</span>        template.setKeySerializer(RedisSerializer.string());        <span class="hljs-comment">// 设置value序列化方式</span>        template.setValueSerializer(RedisSerializer.json());        <span class="hljs-comment">// 设置hash key序列化方式</span>        template.setHashKeySerializer(RedisSerializer.string());        <span class="hljs-comment">// 设置hash value序列化方式</span>        template.setHashValueSerializer(RedisSerializer.json());        template.afterPropertiesSet();        <span class="hljs-keyword">return</span> template;    &#125;&#125;</code></pre></li><li><p>测试</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201222170723.png" alt="测试"></p><p>测试类在测试包下，可自行使用</p></li></ol><h2 id="点赞、取消赞"><a href="#点赞、取消赞" class="headerlink" title="点赞、取消赞"></a>点赞、取消赞</h2><ul><li>点赞<ul><li>支持对帖子、评论点赞</li><li>第一次点赞、第二次取消点赞</li></ul></li><li>首页点赞数量<ul><li>统计帖子点赞数量</li></ul></li><li>详情页点赞数量<ul><li>统计点赞数量</li><li>显示点赞状态</li></ul></li></ul><h3 id="帖子点赞开发流程"><a href="#帖子点赞开发流程" class="headerlink" title="帖子点赞开发流程"></a>帖子点赞开发流程</h3><ol><li><p>编写RedisKeyUtil 设置业务key</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisKeyUtil</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String SPILIT = <span class="hljs-string">&quot;:&quot;</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String PREFIX_ENTITY_LIKE = <span class="hljs-string">&quot;like:entity&quot;</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String PREFIX_USER_LIKE = <span class="hljs-string">&quot;like:user&quot;</span>;    <span class="hljs-comment">// 某个实体赞的key</span>    <span class="hljs-comment">// 格式:  like:entity:entityType:entityId -&gt; set(userId)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getEntityLikeKey</span><span class="hljs-params">(<span class="hljs-keyword">int</span> entityType, <span class="hljs-keyword">int</span> entityId)</span></span>&#123;        <span class="hljs-keyword">return</span> PREFIX_ENTITY_LIKE + SPILIT + entityType + SPILIT + entityId;    &#125;    <span class="hljs-comment">// 某个用户的赞</span>    <span class="hljs-comment">// 格式:  like:user:userid -&gt; int</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getUserLikeKey</span><span class="hljs-params">(<span class="hljs-keyword">int</span> userId)</span></span>&#123;        <span class="hljs-keyword">return</span> PREFIX_USER_LIKE + SPILIT + userId;    &#125;&#125;</code></pre></li><li><p>编写LikeService</p><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LikeService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> RedisTemplate redisTemplate;    <span class="hljs-comment">// 点赞</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">like</span><span class="hljs-params">(<span class="hljs-keyword">int</span> userId, <span class="hljs-keyword">int</span> entityType, <span class="hljs-keyword">int</span> entityId, <span class="hljs-keyword">int</span> entityUserId)</span></span>&#123;        redisTemplate.execute(<span class="hljs-keyword">new</span> SessionCallback() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">execute</span><span class="hljs-params">(RedisOperations redisOperations)</span> <span class="hljs-keyword">throws</span> DataAccessException </span>&#123;                <span class="hljs-comment">// 实体用户同时更新 保证事务性</span>                String entityLikeKey = RedisKeyUtil.getEntityLikeKey(entityType, entityId);                String userLikeKey = RedisKeyUtil.getUserLikeKey(entityUserId);                Boolean isMember = redisOperations.opsForSet().isMember(entityLikeKey, userId);                redisOperations.multi();                <span class="hljs-keyword">if</span> (isMember)&#123;                    <span class="hljs-comment">// 已经点赞</span>                    redisOperations.opsForSet().remove(entityLikeKey, userId);                    redisOperations.opsForValue().decrement(userLikeKey);                &#125;<span class="hljs-keyword">else</span> &#123;                    redisOperations.opsForSet().add(entityLikeKey, userId);                    redisOperations.opsForValue().increment(userLikeKey);                &#125;                <span class="hljs-keyword">return</span> redisOperations.exec();            &#125;        &#125;);    &#125;    <span class="hljs-comment">// 查询某实体(帖子\评论)点赞数量</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">findEntityLikeCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> entityType, <span class="hljs-keyword">int</span> entityId)</span></span>&#123;        String entityLikeKey = RedisKeyUtil.getEntityLikeKey(entityType, entityId);        <span class="hljs-keyword">return</span> redisTemplate.opsForSet().size(entityLikeKey);    &#125;    <span class="hljs-comment">// 查询对某实体(帖子\评论)点赞状态</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findEntityLikeStatus</span><span class="hljs-params">(<span class="hljs-keyword">int</span> userId, <span class="hljs-keyword">int</span> entityType, <span class="hljs-keyword">int</span> entityId)</span></span>&#123;        String entityLikeKey = RedisKeyUtil.getEntityLikeKey(entityType, entityId);        <span class="hljs-keyword">return</span> redisTemplate.opsForSet().isMember(entityLikeKey, userId) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;    &#125;&#125;</code></pre></li><li><p>编写LikeController</p><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LikeController</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CommunityConstant</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> LikeService likeService;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> HostHolder hostHolder;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> RedisTemplate redisTemplate;    <span class="hljs-meta">@RequestMapping(path = &quot;/like&quot;, method = RequestMethod.POST)</span>    <span class="hljs-meta">@ResponseBody</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">like</span><span class="hljs-params">(<span class="hljs-keyword">int</span> entityType, <span class="hljs-keyword">int</span> entityId, <span class="hljs-keyword">int</span> entityUserId, <span class="hljs-keyword">int</span> postId)</span></span>&#123;        User user = hostHolder.getUsers();        likeService.like(user.getId(), entityType, entityId, entityUserId);        <span class="hljs-comment">// 点赞数量和状态</span>        Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        <span class="hljs-keyword">int</span> likeStatus = likeService.findEntityLikeStatus(user.getId(), entityType, entityId);        map.put(<span class="hljs-string">&quot;likeCount&quot;</span>, likeService.findEntityLikeCount(entityType, entityId));        map.put(<span class="hljs-string">&quot;likeStatus&quot;</span>, likeStatus);        <span class="hljs-keyword">return</span> CommunityUtil.getJSONString(<span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>, map);    &#125;&#125;</code></pre></li><li><p>修改模版引擎</p></li><li><p>编写js</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">like</span>(<span class="hljs-params">btn, entityType, entityId, entityUserId, postId</span>) </span>&#123;    $.post(        CONTEXT_PATH + <span class="hljs-string">&quot;/like&quot;</span>,        &#123;<span class="hljs-string">&quot;entityType&quot;</span>:entityType,<span class="hljs-string">&quot;entityId&quot;</span>:entityId,<span class="hljs-string">&quot;entityUserId&quot;</span>:entityUserId,<span class="hljs-string">&quot;postId&quot;</span>:postId&#125;,        <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>) </span>&#123;            data = $.parseJSON(data);            <span class="hljs-keyword">if</span>(data.code == <span class="hljs-number">0</span>) &#123;                $(btn).children(<span class="hljs-string">&quot;i&quot;</span>).text(data.likeCount);                $(btn).children(<span class="hljs-string">&quot;b&quot;</span>).text(data.likeStatus==<span class="hljs-number">1</span>?<span class="hljs-string">&#x27;已赞&#x27;</span>:<span class="hljs-string">&quot;赞&quot;</span>);            &#125; <span class="hljs-keyword">else</span> &#123;                alert(data.msg);            &#125;        &#125;    );&#125;</code></pre></li><li><p>给其他Controller添加查询赞的功能</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201222172546.png" alt="DiscussPostController添加like"></p><p>再更改模版引擎即可</p></li></ol><h3 id="获取用户主页获得的赞数开发流程"><a href="#获取用户主页获得的赞数开发流程" class="headerlink" title="获取用户主页获得的赞数开发流程"></a>获取用户主页获得的赞数开发流程</h3><ol><li><p>添加RedisKeyUtil</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String PREFIX_USER_LIKE = <span class="hljs-string">&quot;like:user&quot;</span>; <span class="hljs-comment">// 某个用户的赞</span> <span class="hljs-comment">// 格式:  like:user:userid -&gt; int</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getUserLikeKey</span><span class="hljs-params">(<span class="hljs-keyword">int</span> userId)</span></span>&#123;     <span class="hljs-keyword">return</span> PREFIX_USER_LIKE + SPILIT + userId; &#125;</code></pre></li><li><p>事务化点赞Service，点赞后更新用户获赞数</p><pre><code class="hljs java">redisTemplate.execute(<span class="hljs-keyword">new</span> SessionCallback() &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">execute</span><span class="hljs-params">(RedisOperations redisOperations)</span> <span class="hljs-keyword">throws</span> DataAccessException </span>&#123;        <span class="hljs-comment">// 实体用户同时更新 保证事务性</span>        String entityLikeKey = RedisKeyUtil.getEntityLikeKey(entityType, entityId);        String userLikeKey = RedisKeyUtil.getUserLikeKey(entityUserId);        Boolean isMember = redisOperations.opsForSet().isMember(entityLikeKey, userId);        redisOperations.multi();        <span class="hljs-keyword">if</span> (isMember)&#123;            <span class="hljs-comment">// 已经点赞</span>            redisOperations.opsForSet().remove(entityLikeKey, userId);            redisOperations.opsForValue().decrement(userLikeKey);        &#125;<span class="hljs-keyword">else</span> &#123;            redisOperations.opsForSet().add(entityLikeKey, userId);            redisOperations.opsForValue().increment(userLikeKey);        &#125;        <span class="hljs-keyword">return</span> redisOperations.exec();    &#125;&#125;);</code></pre></li><li><p>添加用户获得赞个数方法</p><pre><code class="hljs java"><span class="hljs-comment">// 查询用户获得的点赞数量</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findUserLikeCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> userId)</span></span>&#123;    String UserLikeKey = RedisKeyUtil.getUserLikeKey(userId);    <span class="hljs-keyword">return</span> (Integer) redisTemplate.opsForValue().get(UserLikeKey) == <span class="hljs-keyword">null</span>?<span class="hljs-number">0</span>:(Integer) ((Integer) redisTemplate.opsForValue().get(UserLikeKey)).intValue();&#125;</code></pre></li><li><p>给Controller和js添加一个entityUserId参数即可（上述点赞代码已给出）</p></li><li><p>编写UserController 定位个人主页</p><pre><code class="hljs java"><span class="hljs-comment">// 个人主页</span><span class="hljs-meta">@RequestMapping(path = &quot;/profile/&#123;userId&#125;&quot;, method = RequestMethod.GET)</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getProfilePage</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;userId&quot;)</span> <span class="hljs-keyword">int</span> userId, Model model)</span> </span>&#123;    User user = userService.findUserById(userId);    <span class="hljs-keyword">if</span> (user == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;该用户不存在&quot;</span>);    &#125;    model.addAttribute(<span class="hljs-string">&quot;user&quot;</span>, user);    <span class="hljs-comment">// 获赞数量</span>    <span class="hljs-keyword">int</span> userLikeCount = likeService.findUserLikeCount(userId);    model.addAttribute(<span class="hljs-string">&quot;userLikeCount&quot;</span>, userLikeCount);    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;site/profile&quot;</span>;&#125;</code></pre></li><li><p>修改模版引擎profile.html</p></li></ol><h3 id="开发流程图-3"><a href="#开发流程图-3" class="headerlink" title="开发流程图"></a>开发流程图</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201222180108.png" alt="开发流程图"></p><p>上图应该是 <strong>json装入点赞数、状态</strong> </p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201222184143.png" alt="redisKey"></p><h2 id="关注、取消关注"><a href="#关注、取消关注" class="headerlink" title="关注、取消关注"></a>关注、取消关注</h2><ul><li>需求<ul><li>开发关注、取消关注功能</li><li>统计用户的关注数、粉丝数</li></ul></li><li>rediskey<ul><li>若A关注B，则A是B的粉丝（Follower），B是A的目标（Followee）</li></ul></li></ul><h3 id="开发流程-9"><a href="#开发流程-9" class="headerlink" title="开发流程"></a>开发流程</h3><ol><li><p>编写RedisKeyUtil</p><pre><code class="hljs java"><span class="hljs-comment">// 关注</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String PREFIX_FOLLOWEE = <span class="hljs-string">&quot;followee&quot;</span>;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String PREFIX_FOLLOWER = <span class="hljs-string">&quot;follower&quot;</span>;<span class="hljs-comment">// 某个用户关注的实体</span><span class="hljs-comment">// 格式: followee:userId:entityType -&gt; zset(entityId, now date()) 时间排序</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getFolloweeKey</span><span class="hljs-params">(<span class="hljs-keyword">int</span> userId, <span class="hljs-keyword">int</span> entityType)</span></span>&#123;    <span class="hljs-keyword">return</span> PREFIX_FOLLOWEE + SPILIT + userId + SPILIT + entityType;&#125;   <span class="hljs-comment">// 某个实体的粉丝</span><span class="hljs-comment">// 格式: follower:entityType:entityId -&gt; zset(userId, now date()) 时间排序</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getFollowerKey</span><span class="hljs-params">(<span class="hljs-keyword">int</span> entityType, <span class="hljs-keyword">int</span> entityId)</span></span>&#123;    <span class="hljs-keyword">return</span> PREFIX_FOLLOWER + SPILIT + entityType + SPILIT + entityId;&#125;</code></pre></li><li><p>编写FollowService</p><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FollowService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CommunityConstant</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> RedisTemplate redisTemplate;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">follow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> userId, <span class="hljs-keyword">int</span> entityType, <span class="hljs-keyword">int</span> entityId)</span></span>&#123;        redisTemplate.execute(<span class="hljs-keyword">new</span> SessionCallback() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">execute</span><span class="hljs-params">(RedisOperations redisOperations)</span> <span class="hljs-keyword">throws</span> DataAccessException </span>&#123;                String followeeKey = RedisKeyUtil.getFolloweeKey(userId, entityType);                String followerKey = RedisKeyUtil.getFollowerKey(entityType, entityId);                redisOperations.multi();                redisOperations.opsForZSet().add(followeeKey, entityId, System.currentTimeMillis());                redisOperations.opsForZSet().add(followerKey, userId, System.currentTimeMillis());                <span class="hljs-keyword">return</span> redisOperations.exec();            &#125;        &#125;);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unfollow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> userId, <span class="hljs-keyword">int</span> entityType, <span class="hljs-keyword">int</span> entityId)</span></span>&#123;        redisTemplate.execute(<span class="hljs-keyword">new</span> SessionCallback() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">execute</span><span class="hljs-params">(RedisOperations redisOperations)</span> <span class="hljs-keyword">throws</span> DataAccessException </span>&#123;                String followeeKey = RedisKeyUtil.getFolloweeKey(userId, entityType);                String followerKey = RedisKeyUtil.getFollowerKey(entityType, entityId);                redisOperations.multi();                redisOperations.opsForZSet().remove(followeeKey, entityId);                redisOperations.opsForZSet().remove(followerKey, userId);                <span class="hljs-keyword">return</span> redisOperations.exec();            &#125;        &#125;);    &#125; &#125;</code></pre></li><li><p>Service添加查询关注、粉丝数以及关注状态</p><pre><code class="hljs java"><span class="hljs-comment">// 关注列表数量</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">findFolloweeCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> userId, <span class="hljs-keyword">int</span> entityType)</span></span>&#123;    String followeeKey = RedisKeyUtil.getFolloweeKey(userId, entityType);    <span class="hljs-keyword">return</span> redisTemplate.opsForZSet().zCard(followeeKey);&#125;<span class="hljs-comment">// 粉丝列表数量</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">findFollowerCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> entityType, <span class="hljs-keyword">int</span> entityId)</span></span>&#123;    String followerKey = RedisKeyUtil.getFolloweeKey(entityType, entityId);    <span class="hljs-keyword">return</span> redisTemplate.opsForZSet().zCard(followerKey);&#125;<span class="hljs-comment">// 查询关注状态</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasFollow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> userId, <span class="hljs-keyword">int</span> entityType, <span class="hljs-keyword">int</span> entityId)</span></span>&#123;    String followeeKey = RedisKeyUtil.getFolloweeKey(userId, entityType);    <span class="hljs-keyword">return</span> redisTemplate.opsForZSet().score(followeeKey, entityId) != <span class="hljs-keyword">null</span>;&#125;</code></pre></li><li><p>编写FollowController以及js</p><pre><code class="hljs js">$(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;   $(<span class="hljs-string">&quot;.follow-btn&quot;</span>).click(follow);&#125;);<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">follow</span>(<span class="hljs-params"></span>) </span>&#123;   <span class="hljs-keyword">var</span> btn = <span class="hljs-built_in">this</span>;   <span class="hljs-keyword">if</span>($(btn).hasClass(<span class="hljs-string">&quot;btn-info&quot;</span>)) &#123;      <span class="hljs-comment">// 关注TA</span>      $.post(         CONTEXT_PATH + <span class="hljs-string">&quot;/follow&quot;</span>,         &#123;<span class="hljs-string">&quot;entityType&quot;</span>:<span class="hljs-number">3</span>,<span class="hljs-string">&quot;entityId&quot;</span>:$(btn).prev().val()&#125;,         <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>) </span>&#123;            data = $.parseJSON(data);            <span class="hljs-keyword">if</span>(data.code == <span class="hljs-number">0</span>) &#123;               <span class="hljs-built_in">window</span>.location.reload();            &#125; <span class="hljs-keyword">else</span> &#123;               alert(data.msg);            &#125;         &#125;      );      <span class="hljs-comment">// $(btn).text(&quot;已关注&quot;).removeClass(&quot;btn-info&quot;).addClass(&quot;btn-secondary&quot;);</span>   &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-comment">// 取消关注</span>      $.post(         CONTEXT_PATH + <span class="hljs-string">&quot;/unfollow&quot;</span>,         &#123;<span class="hljs-string">&quot;entityType&quot;</span>:<span class="hljs-number">3</span>,<span class="hljs-string">&quot;entityId&quot;</span>:$(btn).prev().val()&#125;,         <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>) </span>&#123;            data = $.parseJSON(data);            <span class="hljs-keyword">if</span>(data.code == <span class="hljs-number">0</span>) &#123;               <span class="hljs-built_in">window</span>.location.reload();            &#125; <span class="hljs-keyword">else</span> &#123;               alert(data.msg);            &#125;         &#125;      );      <span class="hljs-comment">//$(btn).text(&quot;关注TA&quot;).removeClass(&quot;btn-secondary&quot;).addClass(&quot;btn-info&quot;);</span>   &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FollowController</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CommunityConstant</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> HostHolder hostHolder;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> FollowService followService;    <span class="hljs-meta">@RequestMapping(path = &quot;/follow&quot;, method = RequestMethod.POST)</span>    <span class="hljs-meta">@ResponseBody</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">follow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> entityType, <span class="hljs-keyword">int</span> entityId)</span></span>&#123;        User user = hostHolder.getUsers();        followService.follow(user.getId(), entityType, entityId);        <span class="hljs-keyword">return</span> CommunityUtil.getJSONString(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;已关注&quot;</span>);    &#125;    <span class="hljs-meta">@RequestMapping(path = &quot;/unfollow&quot;, method = RequestMethod.POST)</span>    <span class="hljs-meta">@ResponseBody</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">unfollow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> entityType, <span class="hljs-keyword">int</span> entityId)</span></span>&#123;        User user = hostHolder.getUsers();        followService.unfollow(user.getId(), entityType, entityId);        <span class="hljs-keyword">return</span> CommunityUtil.getJSONString(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;已取消关注&quot;</span>);    &#125;</code></pre></li><li><p>编写UserController主页显示请求 添加关注状态</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201222181231.png" alt="usercontroller"></p><h3 id="业务流程图-2"><a href="#业务流程图-2" class="headerlink" title="业务流程图"></a>业务流程图</h3></li></ol><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201222183222.png" alt="流程图"></p><h2 id="关注列表、粉丝列表"><a href="#关注列表、粉丝列表" class="headerlink" title="关注列表、粉丝列表"></a>关注列表、粉丝列表</h2><ul><li>业务层<ul><li>查询某个用户关注的人，支持分页</li><li>查询某个用户的粉丝，支持分页</li></ul></li><li>表现层<ul><li>处理请求</li><li>编写模版</li></ul></li></ul><h3 id="开发流程-10"><a href="#开发流程-10" class="headerlink" title="开发流程"></a>开发流程</h3><ol><li><p>编写FollowService</p><pre><code class="hljs java"><span class="hljs-comment">// 查询关注的用户</span><span class="hljs-keyword">public</span> List&lt;Map&lt;String, Object&gt;&gt; findFollowees(<span class="hljs-keyword">int</span> userId, <span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">int</span> limit)&#123;    String followeeKey = RedisKeyUtil.getFolloweeKey(userId, ENTITY_TYPE_USER);    Set&lt;Integer&gt; targetIds = redisTemplate.opsForZSet().reverseRange(followeeKey, offset, offset + limit - <span class="hljs-number">1</span>);    List&lt;Map&lt;String, Object&gt;&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">if</span> (targetIds == <span class="hljs-keyword">null</span>)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-keyword">for</span> (Integer targetId :targetIds            ) &#123;        User user = userService.findUserById(targetId);        Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        map.put(<span class="hljs-string">&quot;user&quot;</span>, user);        Double time = redisTemplate.opsForZSet().score(followeeKey, targetId);        map.put(<span class="hljs-string">&quot;userFolloweeDate&quot;</span>, <span class="hljs-keyword">new</span> Date(time.longValue()));        list.add(map);    &#125;    <span class="hljs-keyword">return</span> list;&#125;<span class="hljs-comment">// 查询用户的粉丝</span><span class="hljs-keyword">public</span> List&lt;Map&lt;String, Object&gt;&gt; findFollowers(<span class="hljs-keyword">int</span> userId, <span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">int</span> limit)&#123;    String followerKey = RedisKeyUtil.getFollowerKey(ENTITY_TYPE_USER, userId);    Set&lt;Integer&gt; targetIds = redisTemplate.opsForZSet().reverseRange(followerKey, offset, offset + limit - <span class="hljs-number">1</span>);    List&lt;Map&lt;String, Object&gt;&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">if</span> (targetIds == <span class="hljs-keyword">null</span>)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-keyword">for</span> (Integer targetId :targetIds    ) &#123;        User user = userService.findUserById(targetId);        Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        map.put(<span class="hljs-string">&quot;user&quot;</span>, user);        Double time = redisTemplate.opsForZSet().score(followerKey, targetId);        map.put(<span class="hljs-string">&quot;userFollowerDate&quot;</span>, <span class="hljs-keyword">new</span> Date(time.longValue()));        list.add(map);    &#125;    <span class="hljs-keyword">return</span> list;&#125;</code></pre></li><li><p>编写FollowController</p><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(path = &quot;/followees/&#123;userId&#125;&quot;, method = RequestMethod.GET)</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getFollowees</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;userId&quot;)</span> <span class="hljs-keyword">int</span> userId, Page page, Model model)</span></span>&#123;    User user = userService.findUserById(userId);    <span class="hljs-keyword">if</span> (user == <span class="hljs-keyword">null</span>)&#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;用户不存在&quot;</span>);    &#125;    model.addAttribute(<span class="hljs-string">&quot;user&quot;</span>, user);    page.setLimit(<span class="hljs-number">5</span>);    page.setPath(<span class="hljs-string">&quot;/followees/&quot;</span> + userId);    page.setRows((<span class="hljs-keyword">int</span>) followService.findFolloweeCount(userId, ENTITY_TYPE_USER));    <span class="hljs-comment">// 给list加入关注状态</span>    List&lt;Map&lt;String, Object&gt;&gt; followeesList = followService.findFollowees(userId, page.getOffset(), page.getLimit());    <span class="hljs-keyword">if</span> (followeesList != <span class="hljs-keyword">null</span>)&#123;        <span class="hljs-keyword">for</span> (Map&lt;String, Object&gt; followeeMap : followeesList                ) &#123;            <span class="hljs-comment">// 加入当前登陆用户对每个关注列表用户的关注状态</span>            User followeeUser = (User) followeeMap.get(<span class="hljs-string">&quot;user&quot;</span>);            followeeMap.put(<span class="hljs-string">&quot;followStatus&quot;</span>, hasFollow(followeeUser.getId()));        &#125;    &#125;    model.addAttribute(<span class="hljs-string">&quot;followees&quot;</span>, followeesList);    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;/site/followee&quot;</span>;&#125;<span class="hljs-meta">@RequestMapping(path = &quot;/followers/&#123;userId&#125;&quot;, method = RequestMethod.GET)</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getFollowers</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;userId&quot;)</span> <span class="hljs-keyword">int</span> userId, Page page, Model model)</span></span>&#123;    User user = userService.findUserById(userId);    <span class="hljs-keyword">if</span> (user == <span class="hljs-keyword">null</span>)&#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;用户不存在&quot;</span>);    &#125;    model.addAttribute(<span class="hljs-string">&quot;user&quot;</span>, user);    page.setLimit(<span class="hljs-number">5</span>);    page.setPath(<span class="hljs-string">&quot;/followers/&quot;</span> + userId);    page.setRows((<span class="hljs-keyword">int</span>) followService.findFollowerCount(ENTITY_TYPE_USER, userId));    <span class="hljs-comment">// 给list加入关注状态</span>    List&lt;Map&lt;String, Object&gt;&gt; followersList = followService.findFollowers(userId, page.getOffset(), page.getLimit());    <span class="hljs-keyword">if</span> (followersList != <span class="hljs-keyword">null</span>)&#123;        <span class="hljs-keyword">for</span> (Map&lt;String, Object&gt; followerMap : followersList        ) &#123;            <span class="hljs-comment">// 加入当前登陆用户对每个关注列表用户的关注状态</span>            User followerUser = (User) followerMap.get(<span class="hljs-string">&quot;user&quot;</span>);            followerMap.put(<span class="hljs-string">&quot;followStatus&quot;</span>, hasFollow(followerUser.getId()));        &#125;    &#125;    model.addAttribute(<span class="hljs-string">&quot;followers&quot;</span>, followersList);    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;/site/follower&quot;</span>;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasFollow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> userId)</span></span>&#123;    <span class="hljs-keyword">if</span> (hostHolder.getUsers() == <span class="hljs-keyword">null</span>)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-keyword">return</span> followService.hasFollow(hostHolder.getUsers().getId(), ENTITY_TYPE_USER, userId);&#125;</code></pre></li><li><p>修改模版引擎</p></li></ol><h3 id="业务流程图-3"><a href="#业务流程图-3" class="headerlink" title="业务流程图"></a>业务流程图</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201222183920.png" alt="流程图"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201222184215.png" alt="redisKey"></p><h1 id="缓存与消息队列模块"><a href="#缓存与消息队列模块" class="headerlink" title="缓存与消息队列模块"></a>缓存与消息队列模块</h1><ul><li>使用Redis存储验证码<ul><li>验证码需要频繁的访问与刷新,对性能要求较高。</li><li>验证码不需永久保存，通常在很短的时间后就会失效。</li><li>分布式部署时，存在Session共享的问题</li></ul></li><li>使用Redis存储登录凭证<ul><li>处理每次请求时，都要查询用户的登录凭证，访问的频率非常高。</li></ul></li><li>使用Redis缓存用户信息<ul><li>处理每次请求时，都要根据凭证查询用户信息，访问的频率非常高。</li></ul></li></ul><h2 id="储存验证码"><a href="#储存验证码" class="headerlink" title="储存验证码"></a>储存验证码</h2><h3 id="储存验证码开发流程"><a href="#储存验证码开发流程" class="headerlink" title="储存验证码开发流程"></a>储存验证码开发流程</h3><ol><li><p>编写RedisKeyUtil</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String KAPTCHA = <span class="hljs-string">&quot;kaptcha&quot;</span>; <span class="hljs-comment">// 登录验证码</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getKaptchaKey</span><span class="hljs-params">(String owner)</span></span>&#123;     <span class="hljs-keyword">return</span> KAPTCHA + SPILIT + owner; &#125;</code></pre></li><li><p>修改LoginController中/kaptcha请求</p><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(path = &quot;/kaptcha&quot;,method = RequestMethod.GET)</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getKaptcha</span><span class="hljs-params">(HttpServletResponse response)</span></span>&#123;    <span class="hljs-comment">// 生成验证码</span>    String text = kaptchProducer.createText();    BufferedImage image = kaptchProducer.createImage(text);    <span class="hljs-comment">// 验证码的归属者</span>    String kaptchaOwner = CommunityUtil.generateUUID();    <span class="hljs-comment">// 存入cookie</span>    Cookie cookie = <span class="hljs-keyword">new</span> Cookie(<span class="hljs-string">&quot;kaptchaOwner&quot;</span>, kaptchaOwner);    cookie.setMaxAge(<span class="hljs-number">60</span>);    cookie.setPath(contextPath);    response.addCookie(cookie);    <span class="hljs-comment">// 验证码文字存入redis</span>    String kaptchaKey = RedisKeyUtil.getKaptchaKey(kaptchaOwner);    redisTemplate.opsForValue().set(kaptchaKey, text, <span class="hljs-number">60</span> , TimeUnit.SECONDS);    <span class="hljs-comment">// 将图片输出给浏览器</span>    response.setContentType(<span class="hljs-string">&quot;image/png&quot;</span>);    <span class="hljs-keyword">try</span> &#123;        OutputStream os = response.getOutputStream();        ImageIO.write(image, <span class="hljs-string">&quot;png&quot;</span>, os);    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;        logger.error(<span class="hljs-string">&quot;验证码响应失败：&quot;</span> + e.getMessage());    &#125;&#125;</code></pre></li><li><p>修改LoginController中/login请求</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201223090056.png" alt="redis存验证码"></p></li></ol><h3 id="开发流程图-4"><a href="#开发流程图-4" class="headerlink" title="开发流程图"></a>开发流程图</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201223095133.png" alt="开发流程图"></p><h2 id="存储登录凭证"><a href="#存储登录凭证" class="headerlink" title="存储登录凭证"></a>存储登录凭证</h2><h3 id="存储登录凭证开发流程"><a href="#存储登录凭证开发流程" class="headerlink" title="存储登录凭证开发流程"></a>存储登录凭证开发流程</h3><ol><li><p>编写redisKeyUtil</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String PREFIX_TICKET = <span class="hljs-string">&quot;ticket&quot;</span>; <span class="hljs-comment">// 登录凭证</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getTicketKey</span><span class="hljs-params">(String ticket)</span></span>&#123;     <span class="hljs-keyword">return</span> PREFIX_TICKET + SPILIT + ticket; &#125;</code></pre></li><li><p>废弃LoginTicketMapper(不再MySql存储登录凭证)</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201223090329.png" alt="废弃"></p></li><li><p>修改UserService login方法</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201223090538.png" alt="redis"></p></li><li><p>修改UserService logout方法</p><pre><code class="hljs java">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">logout</span><span class="hljs-params">(String ticket)</span></span>&#123;<span class="hljs-comment">//        loginTicketMapper.updateStatus(ticket,1);</span>        String redisKey = RedisKeyUtil.getTicketKey(ticket);        LoginTicket loginTicket =(LoginTicket) redisTemplate.opsForValue().get(redisKey);        loginTicket.setStatus(<span class="hljs-number">1</span>);        redisTemplate.opsForValue().set(redisKey, loginTicket);    &#125;</code></pre></li><li><p>修改findLoginTicket方法</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> LoginTicket <span class="hljs-title">findLoginTicket</span><span class="hljs-params">(String ticket)</span></span>&#123;    String redisKey = RedisKeyUtil.getTicketKey(ticket);    <span class="hljs-keyword">return</span> (LoginTicket) redisTemplate.opsForValue().get(redisKey);&#125;</code></pre><p>这样拦截器能通过redis找到</p></li></ol><h3 id="开发流程图-5"><a href="#开发流程图-5" class="headerlink" title="开发流程图"></a>开发流程图</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201223095906.png" alt="流程图"></p><h2 id="存储用户信息"><a href="#存储用户信息" class="headerlink" title="存储用户信息"></a>存储用户信息</h2><h3 id="存储用户信息开发流程"><a href="#存储用户信息开发流程" class="headerlink" title="存储用户信息开发流程"></a>存储用户信息开发流程</h3><ol><li><p>编写RedisKeyUtil</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String PREFIX_USER = <span class="hljs-string">&quot;user&quot;</span>;<span class="hljs-comment">// 用户</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getUserKey</span><span class="hljs-params">(<span class="hljs-keyword">int</span> userId)</span></span>&#123;    <span class="hljs-keyword">return</span> PREFIX_USER + SPILIT + userId;&#125;</code></pre></li><li><p>修改UserService</p><pre><code class="hljs java">    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">findUserById</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span></span>&#123;<span class="hljs-comment">//        return userMapper.selectById(id);</span>        User user = getCache(id);        <span class="hljs-keyword">if</span> (user == <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-comment">// 初始化</span>            user = initCache(id);        &#125;        <span class="hljs-keyword">return</span> user;    &#125;    <span class="hljs-comment">// 缓存管理用户信息:</span>    <span class="hljs-comment">// 1. 优先从缓存中取值</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> User <span class="hljs-title">getCache</span><span class="hljs-params">(<span class="hljs-keyword">int</span> userId)</span></span>&#123;        String redisKey = RedisKeyUtil.getUserKey(userId);        <span class="hljs-keyword">return</span> (User) redisTemplate.opsForValue().get(redisKey);    &#125;    <span class="hljs-comment">// 2. 取不到时初始化缓存数据</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> User <span class="hljs-title">initCache</span><span class="hljs-params">(<span class="hljs-keyword">int</span> userId)</span></span>&#123;        User user = userMapper.selectById(userId);        String redisKey = RedisKeyUtil.getUserKey(userId);        redisTemplate.opsForValue().set(redisKey, user, <span class="hljs-number">36000</span>, TimeUnit.SECONDS);        <span class="hljs-keyword">return</span> user;    &#125;    <span class="hljs-comment">// 3. 数据变更时清楚缓存</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clearCache</span><span class="hljs-params">(<span class="hljs-keyword">int</span> userId)</span></span>&#123;        String redisKey = RedisKeyUtil.getUserKey(userId);        redisTemplate.delete(redisKey);    &#125;</code></pre></li><li><p>给相应方法添加清除缓存</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201223091454.png" alt="activation"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201223091512.png" alt="pwd"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201223091535.png" alt="headerUrl"></p></li></ol><h3 id="开发流程图-6"><a href="#开发流程图-6" class="headerlink" title="开发流程图"></a>开发流程图</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201223100648.png" alt="开发流程图"></p><h2 id="Spring整合Kafka"><a href="#Spring整合Kafka" class="headerlink" title="Spring整合Kafka"></a>Spring整合Kafka</h2><ul><li>引入依赖<ul><li>spring-kafka</li></ul></li><li>配置kafka<ul><li>配置server、consumer</li></ul></li><li>访问kafka<ul><li>生产者</li><li>消费者</li></ul></li></ul><h3 id="开发流程-11"><a href="#开发流程-11" class="headerlink" title="开发流程"></a>开发流程</h3><ol><li><p>Maven</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--    kafka    --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.kafka<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-kafka<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></li><li><p>配置kafka</p><pre><code class="hljs properties"><span class="hljs-comment"># KafkaProperties</span><span class="hljs-meta">spring.kafka.bootstrap-servers</span>=<span class="hljs-string">localhost:9092</span><span class="hljs-meta">spring.kafka.consumer.group-id</span>=<span class="hljs-string">test</span><span class="hljs-meta">spring.kafka.consumer.enable-auto-commit</span>=<span class="hljs-string">true</span><span class="hljs-meta">spring.kafka.consumer.auto-commit-interval</span>=<span class="hljs-string">3000</span><span class="hljs-meta">spring.kafka.listener.missing-topics-fatal</span>=<span class="hljs-string">false</span><span class="hljs-comment">#如果无主题会报错 选择false</span></code></pre></li><li><p>检查kafka本地配置</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201223101350.png" alt="kafka"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201223101442.png" alt="与properties对应"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201223101528.png" alt="开端口"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201223101557.png" alt="开端口"></p></li></ol><ol start="4"><li><p>编写测试类</p><pre><code class="hljs java"><span class="hljs-meta">@RunWith(SpringRunner.class)</span><span class="hljs-meta">@SpringBootTest</span><span class="hljs-meta">@ContextConfiguration(classes = CommunityApplication.class)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">KafkaTest</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> KafkaProducer kafkaProducer;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testKafka</span><span class="hljs-params">()</span> </span>&#123;        kafkaProducer.sendMessage(<span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-string">&quot;你好&quot;</span>);        System.out.println(<span class="hljs-number">1</span>);        kafkaProducer.sendMessage(<span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-string">&quot;在吗&quot;</span>);        <span class="hljs-keyword">try</span> &#123;            Thread.sleep(<span class="hljs-number">1000</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;<span class="hljs-meta">@Component</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">KafkaProducer</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> KafkaTemplate kafkaTemplate;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendMessage</span><span class="hljs-params">(String topic, String content)</span> </span>&#123;        kafkaTemplate.send(topic, content);    &#125;&#125;<span class="hljs-meta">@Component</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">KafkaConsumer</span> </span>&#123;    <span class="hljs-meta">@KafkaListener(topics = &#123;&quot;test&quot;&#125;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleMessage</span><span class="hljs-params">(ConsumerRecord record)</span> </span>&#123;        System.out.println(record.value()        );    &#125;&#125;</code></pre><p>单元测试源文件已给出</p></li></ol><h2 id="发送系统通知"><a href="#发送系统通知" class="headerlink" title="发送系统通知"></a>发送系统通知</h2><ul><li>触发事件<ul><li>评论后，发布通知</li><li>点赞后，发布通知</li><li>关注后，发布通知</li></ul></li><li>处理事件<ul><li>封装事件对象</li><li>开发事件的生产者</li><li>开发事件的消费者</li></ul></li></ul><h3 id="开发原理"><a href="#开发原理" class="headerlink" title="开发原理"></a>开发原理</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201223102514.png" alt="原理"></p><h3 id="开发流程-12"><a href="#开发流程-12" class="headerlink" title="开发流程"></a>开发流程</h3><ol><li><p>创建事件对象</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Event</span> </span>&#123;     <span class="hljs-comment">// return this的原因是让其可以链式编程</span>    <span class="hljs-keyword">private</span> String topic;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> userId;    <span class="hljs-comment">// type为1 id为帖子id type为2 id为评论表当前回复的id</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> entityType;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> entityId;    <span class="hljs-comment">// 发布帖子/发表评论的人</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> entityUserId;    <span class="hljs-comment">// 拓展其他业务</span>    <span class="hljs-keyword">private</span> Map&lt;String, Object&gt; data = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getTopic</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> topic;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Event <span class="hljs-title">setTopic</span><span class="hljs-params">(String topic)</span> </span>&#123;        <span class="hljs-keyword">this</span>.topic = topic;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getUserId</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> userId;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Event <span class="hljs-title">setUserId</span><span class="hljs-params">(<span class="hljs-keyword">int</span> userId)</span> </span>&#123;        <span class="hljs-keyword">this</span>.userId = userId;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getEntityType</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> entityType;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Event <span class="hljs-title">setEntityType</span><span class="hljs-params">(<span class="hljs-keyword">int</span> entityType)</span> </span>&#123;        <span class="hljs-keyword">this</span>.entityType = entityType;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getEntityId</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> entityId;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Event <span class="hljs-title">setEntityId</span><span class="hljs-params">(<span class="hljs-keyword">int</span> entityId)</span> </span>&#123;        <span class="hljs-keyword">this</span>.entityId = entityId;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getEntityUserId</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> entityUserId;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Event <span class="hljs-title">setEntityUserId</span><span class="hljs-params">(<span class="hljs-keyword">int</span> entityUserId)</span> </span>&#123;        <span class="hljs-keyword">this</span>.entityUserId = entityUserId;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String, Object&gt; <span class="hljs-title">getData</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> data;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Event <span class="hljs-title">setData</span><span class="hljs-params">(String key, Object value)</span> </span>&#123;        <span class="hljs-keyword">this</span>.data.put(key, value);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;&#125;</code></pre></li><li><p>业务层角度创建事件生产者</p><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EventProducer</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> KafkaTemplate kafkaTemplate;    <span class="hljs-comment">// 处理事件</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fireEvent</span><span class="hljs-params">(Event event)</span></span>&#123;        <span class="hljs-comment">// 将事件发送指定主题</span>        kafkaTemplate.send(event.getTopic(), JSONObject.toJSONString(event));    &#125;&#125;</code></pre></li><li><p>创建事件消费者</p><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EventConsumer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CommunityConstant</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger logger = LoggerFactory.getLogger(EventConsumer.class);    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> MessageService messageService;    <span class="hljs-meta">@KafkaListener(topics = &#123;TOPIC_COMMENT, TOPIC_LIKE, TOPIC_FOLLOW&#125;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleEventMessage</span><span class="hljs-params">(ConsumerRecord record)</span></span>&#123;        <span class="hljs-keyword">if</span> (record == <span class="hljs-keyword">null</span> || record.value() == <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-comment">// 空消息</span>            logger.error(<span class="hljs-string">&quot;消息内容为空！&quot;</span>);            <span class="hljs-keyword">return</span>;        &#125;        Event event = JSONObject.parseObject(record.value().toString(), Event.class);        <span class="hljs-keyword">if</span> (event == <span class="hljs-keyword">null</span>)&#123;            logger.error(<span class="hljs-string">&quot;消息格式为空！&quot;</span>);            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">// 发送站内通知</span>        Message message = <span class="hljs-keyword">new</span> Message();        message.setFromId(SYSTEM_USERID);        message.setToId(event.getEntityUserId());        message.setConversationId(event.getTopic());        message.setCreateTime(<span class="hljs-keyword">new</span> Date());        Map&lt;String, Object&gt; content = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        content.put(<span class="hljs-string">&quot;userId&quot;</span>, event.getUserId());        content.put(<span class="hljs-string">&quot;entityType&quot;</span>, event.getEntityType());        content.put(<span class="hljs-string">&quot;entityId&quot;</span>, event.getEntityId());        <span class="hljs-comment">// 额外date</span>        <span class="hljs-keyword">if</span> (!event.getData().isEmpty())&#123;            <span class="hljs-keyword">for</span> (Map.Entry&lt;String, Object&gt; entry:event.getData().entrySet())&#123;                content.put(entry.getKey(), entry.getValue());            &#125;        &#125;        message.setContent(JSONObject.toJSONString(content));        messageService.insertLetter(message);    &#125;&#125;</code></pre></li><li><p>修改常量接口</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 主题:评论</span><span class="hljs-comment"> */</span>String TOPIC_COMMENT = <span class="hljs-string">&quot;comment&quot;</span>;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 主题:点赞</span><span class="hljs-comment"> */</span>String TOPIC_LIKE = <span class="hljs-string">&quot;like&quot;</span>;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 主题:关注</span><span class="hljs-comment"> */</span>String TOPIC_FOLLOW = <span class="hljs-string">&quot;follow&quot;</span>;</code></pre></li><li><p>修改评论、点赞、关注Controller</p></li><li><p>评论事件</p><pre><code class="hljs java"><span class="hljs-comment">// 触发评论事件</span><span class="hljs-comment">// type为1 id为帖子id</span><span class="hljs-comment">// type为2 id为评论的id</span>Event event = <span class="hljs-keyword">new</span> Event()        .setTopic(TOPIC_COMMENT)        .setUserId(hostHolder.getUsers().getId())        .setEntityType(comment.getEntityType())        .setEntityId(comment.getEntityId())        .setData(<span class="hljs-string">&quot;postId&quot;</span>, discussPostId);<span class="hljs-keyword">if</span> (comment.getEntityType() == ENTITY_TYPE_POST)&#123;    <span class="hljs-comment">// EntityUserId 存帖子作者id 给作者发消息</span>    DiscussPost target = discussPostService.findDiscussPostById(comment.getEntityId());    event.setEntityUserId(target.getUserId());&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (comment.getEntityType() == ENTITY_TYPE_COMMENT)&#123;    <span class="hljs-comment">// EntityUserId 存当前评论的id 给评论作者发消息</span>    Comment target = commentService.findCommentById(comment.getEntityId());    event.setEntityUserId(target.getUserId());&#125;eventProducer.fireEvent(event);</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201223103720.png" alt="评论事件"></p></li><li><p>点赞事件</p><pre><code class="hljs java"><span class="hljs-comment">// 触发点赞事件</span><span class="hljs-keyword">if</span> (likeStatus == <span class="hljs-number">1</span>)&#123;    Event event = <span class="hljs-keyword">new</span> Event()            .setTopic(TOPIC_LIKE)            .setUserId(user.getId())            .setEntityType(entityType)            .setEntityId(entityId)            .setEntityUserId(entityUserId)            .setData(<span class="hljs-string">&quot;postId&quot;</span>, postId);    eventProducer.fireEvent(event);&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201223103905.png" alt="点赞事件"></p></li><li><p>关注事件</p><pre><code class="hljs java"><span class="hljs-comment">// 触发关注事件</span>Event event = <span class="hljs-keyword">new</span> Event()        .setTopic(TOPIC_FOLLOW)        .setUserId(user.getId())        .setEntityType(entityType)        .setEntityId(entityId)        .setEntityUserId(entityId);eventProducer.fireEvent(event);</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201223103952.png" alt="image-20201223103949547"></p></li></ol><h3 id="开发流程图-7"><a href="#开发流程图-7" class="headerlink" title="开发流程图"></a>开发流程图</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201223110623.png" alt="流程图"></p><h2 id="显示系统消息"><a href="#显示系统消息" class="headerlink" title="显示系统消息"></a>显示系统消息</h2><ul><li>通知列表<ul><li>显示评论、点赞、关注三种类型通知</li></ul></li><li>通知详情<ul><li>分页显示某一类主题通知</li></ul></li><li>未读<ul><li>页面头部显示所有未读消息</li></ul></li></ul><h3 id="开发流程-13"><a href="#开发流程-13" class="headerlink" title="开发流程"></a>开发流程</h3><ol><li><p>编写MessageMapper和mapper.xml</p><pre><code class="hljs java"><span class="hljs-comment">// 查询某个主题下最新的通知</span><span class="hljs-function">Message <span class="hljs-title">selectLatestNotice</span><span class="hljs-params">(<span class="hljs-keyword">int</span> userId, String topic)</span></span>;<span class="hljs-comment">// 查询某个主题包含通知数量</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">selectNoticeCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> userId, String topic)</span></span>;<span class="hljs-comment">// 查询未读通知数量</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">selectNoticeUnreadCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> userId, String topic)</span></span>;<span class="hljs-comment">// 查询某个主题所有的通知</span><span class="hljs-function">List&lt;Message&gt; <span class="hljs-title">selectNotices</span><span class="hljs-params">(<span class="hljs-keyword">int</span> userId, String topic, <span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">int</span> limit)</span></span>;</code></pre><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectLatestNotice&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Message&quot;</span>&gt;</span>    select <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">&quot;selectFields&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span>    from message    where id in (    select max(id) from message    where status != 2    and from_id = 1    and to_id = #&#123;userId&#125;    and conversation_id = #&#123;topic&#125;    )<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectNoticeCount&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;int&quot;</span>&gt;</span>    select count(id) from message    where status != 2    and from_id = 1    and to_id = #&#123;userId&#125;    and conversation_id = #&#123;topic&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectNoticeUnreadCount&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;int&quot;</span>&gt;</span>    select count(id) from message    where status = 0    and from_id = 1    and to_id = #&#123;userId&#125;    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;topic!=null&quot;</span>&gt;</span>        and conversation_id = #&#123;topic&#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectNotices&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Message&quot;</span>&gt;</span>    select <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">&quot;selectFields&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span>    from message    where status != 2    and from_id = 1    and to_id = #&#123;userId&#125;    and conversation_id = #&#123;topic&#125;    order by create_time desc    limit #&#123;offset&#125;, #&#123;limit&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre></li><li><p>编写MessageService</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Message <span class="hljs-title">findLatestNotice</span><span class="hljs-params">(<span class="hljs-keyword">int</span> userId, String topic)</span></span>&#123;    <span class="hljs-keyword">return</span> messageMapper.selectLatestNotice(userId, topic);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findNoticeCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> userId, String topic)</span></span>&#123;    <span class="hljs-keyword">return</span> messageMapper.selectNoticeCount(userId, topic);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findNoticeUnreadCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> userId, String topic)</span></span>&#123;    <span class="hljs-keyword">return</span> messageMapper.selectNoticeUnreadCount(userId, topic);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Message&gt; <span class="hljs-title">findNotices</span><span class="hljs-params">(<span class="hljs-keyword">int</span> userId, String topic, <span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">int</span> limit)</span></span>&#123;    <span class="hljs-keyword">return</span> messageMapper.selectNotices(userId, topic, offset, limit);&#125;</code></pre></li><li><p>编写MessageController 显示消息主页</p><pre><code class="hljs java">    <span class="hljs-meta">@RequestMapping(path = &quot;/notice/list&quot;, method = RequestMethod.GET)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getNoticeList</span><span class="hljs-params">(Model model)</span></span>&#123;        User user = hostHolder.getUsers();        <span class="hljs-comment">// 查询评论类通知</span>        Message message = messageService.findLatestNotice(user.getId(), TOPIC_COMMENT);        Map&lt;String, Object&gt; messageVo = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        <span class="hljs-keyword">if</span> (message != <span class="hljs-keyword">null</span>)&#123;            messageVo.put(<span class="hljs-string">&quot;message&quot;</span>, message);            String content = HtmlUtils.htmlUnescape(message.getContent());            Map&lt;String, Object&gt; data = JSONObject.parseObject(content, HashMap.class);            messageVo.put(<span class="hljs-string">&quot;user&quot;</span>, userService.findUserById((Integer) data.get(<span class="hljs-string">&quot;userId&quot;</span>)));            messageVo.put(<span class="hljs-string">&quot;entityType&quot;</span>, data.get(<span class="hljs-string">&quot;entityType&quot;</span>));            messageVo.put(<span class="hljs-string">&quot;entityId&quot;</span>, data.get(<span class="hljs-string">&quot;entityId&quot;</span>));            messageVo.put(<span class="hljs-string">&quot;postId&quot;</span>, data.get(<span class="hljs-string">&quot;postid&quot;</span>));            <span class="hljs-keyword">int</span> count = messageService.findNoticeCount(user.getId(), TOPIC_COMMENT);            messageVo.put(<span class="hljs-string">&quot;count&quot;</span>, count);            <span class="hljs-keyword">int</span> unread = messageService.findNoticeUnreadCount(user.getId(), TOPIC_COMMENT);            messageVo.put(<span class="hljs-string">&quot;unread&quot;</span>, unread);        &#125;<span class="hljs-keyword">else</span> &#123;            messageVo.put(<span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-keyword">null</span>);        &#125;        model.addAttribute(<span class="hljs-string">&quot;commentNotice&quot;</span>, messageVo);        <span class="hljs-comment">// 查询点赞类通知</span>        message = messageService.findLatestNotice(user.getId(), TOPIC_LIKE);        messageVo = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        <span class="hljs-keyword">if</span> (message != <span class="hljs-keyword">null</span>)&#123;            messageVo.put(<span class="hljs-string">&quot;message&quot;</span>, message);            String content = HtmlUtils.htmlUnescape(message.getContent());            Map&lt;String, Object&gt; data = JSONObject.parseObject(content, HashMap.class);            messageVo.put(<span class="hljs-string">&quot;user&quot;</span>, userService.findUserById((Integer) data.get(<span class="hljs-string">&quot;userId&quot;</span>)));            messageVo.put(<span class="hljs-string">&quot;entityType&quot;</span>, data.get(<span class="hljs-string">&quot;entityType&quot;</span>));            messageVo.put(<span class="hljs-string">&quot;entityId&quot;</span>, data.get(<span class="hljs-string">&quot;entityId&quot;</span>));            messageVo.put(<span class="hljs-string">&quot;postId&quot;</span>, data.get(<span class="hljs-string">&quot;postid&quot;</span>));            <span class="hljs-keyword">int</span> count = messageService.findNoticeCount(user.getId(), TOPIC_LIKE);            messageVo.put(<span class="hljs-string">&quot;count&quot;</span>, count);            <span class="hljs-keyword">int</span> unread = messageService.findNoticeUnreadCount(user.getId(), TOPIC_LIKE);            messageVo.put(<span class="hljs-string">&quot;unread&quot;</span>, unread);        &#125;<span class="hljs-keyword">else</span> &#123;            messageVo.put(<span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-keyword">null</span>);        &#125;        model.addAttribute(<span class="hljs-string">&quot;likeNotice&quot;</span>, messageVo);        <span class="hljs-comment">// 查询关注类通知</span>        message = messageService.findLatestNotice(user.getId(), TOPIC_FOLLOW);        messageVo = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        <span class="hljs-keyword">if</span> (message != <span class="hljs-keyword">null</span>)&#123;            messageVo.put(<span class="hljs-string">&quot;message&quot;</span>, message);            String content = HtmlUtils.htmlUnescape(message.getContent());            Map&lt;String, Object&gt; data = JSONObject.parseObject(content, HashMap.class);            messageVo.put(<span class="hljs-string">&quot;user&quot;</span>, userService.findUserById((Integer) data.get(<span class="hljs-string">&quot;userId&quot;</span>)));            messageVo.put(<span class="hljs-string">&quot;entityType&quot;</span>, data.get(<span class="hljs-string">&quot;entityType&quot;</span>));            messageVo.put(<span class="hljs-string">&quot;entityId&quot;</span>, data.get(<span class="hljs-string">&quot;entityId&quot;</span>));<span class="hljs-comment">//            messageVo.put(&quot;postId&quot;, data.get(&quot;postid&quot;));</span>            <span class="hljs-keyword">int</span> count = messageService.findNoticeCount(user.getId(), TOPIC_FOLLOW);            messageVo.put(<span class="hljs-string">&quot;count&quot;</span>, count);            <span class="hljs-keyword">int</span> unread = messageService.findNoticeUnreadCount(user.getId(), TOPIC_FOLLOW);            messageVo.put(<span class="hljs-string">&quot;unread&quot;</span>, unread);        &#125;<span class="hljs-keyword">else</span> &#123;            messageVo.put(<span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-keyword">null</span>);        &#125;        model.addAttribute(<span class="hljs-string">&quot;followNotice&quot;</span>, messageVo);        <span class="hljs-comment">// 查询未读消息数量</span>        <span class="hljs-keyword">int</span> letterUnreadCount = messageService.findeLetterUnreadCount(user.getId(), <span class="hljs-keyword">null</span>);        <span class="hljs-keyword">int</span> noticeUnreadCount = messageService.findNoticeUnreadCount(user.getId(), <span class="hljs-keyword">null</span>);        model.addAttribute(<span class="hljs-string">&quot;letterUnreadCount&quot;</span>, letterUnreadCount);        model.addAttribute(<span class="hljs-string">&quot;noticeUnreadCount&quot;</span>, noticeUnreadCount);        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;site/notice&quot;</span>;    &#125;</code></pre></li><li><p>编写MessageController 显示具体消息的全部页面</p><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(path = &quot;/notice/detail/&#123;topic&#125;&quot;, method = RequestMethod.GET)</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getNoticeDetail</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;topic&quot;)</span>String topic,Page page, Model model)</span></span>&#123;    User user = hostHolder.getUsers();    page.setLimit(<span class="hljs-number">5</span>);    page.setRows(messageService.findNoticeCount(user.getId(), topic));    page.setPath(<span class="hljs-string">&quot;/message/notice/detail/&quot;</span>+topic);    List&lt;Message&gt; noticeList = messageService.findNotices(user.getId(), topic, page.getOffset(), page.getLimit());    List&lt;Map&lt;String, Object&gt;&gt; noticeVoList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">if</span> (noticeList!=<span class="hljs-keyword">null</span>)&#123;        <span class="hljs-keyword">for</span> (Message notice: noticeList) &#123;            Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();            <span class="hljs-comment">// 通知</span>            map.put(<span class="hljs-string">&quot;notice&quot;</span>, notice);            <span class="hljs-comment">// 内容</span>            String content = HtmlUtils.htmlUnescape(notice.getContent());            Map&lt;String, Object&gt; data = JSONObject.parseObject(content, HashMap.class);            map.put(<span class="hljs-string">&quot;user&quot;</span>, userService.findUserById((Integer) data.get(<span class="hljs-string">&quot;userId&quot;</span>)));            map.put(<span class="hljs-string">&quot;entityType&quot;</span>, data.get(<span class="hljs-string">&quot;entityType&quot;</span>));            map.put(<span class="hljs-string">&quot;entityId&quot;</span>, data.get(<span class="hljs-string">&quot;entityId&quot;</span>));            map.put(<span class="hljs-string">&quot;postId&quot;</span>, data.get(<span class="hljs-string">&quot;postId&quot;</span>));            map.put(<span class="hljs-string">&quot;fromUser&quot;</span>, userService.findUserById(notice.getFromId()));            noticeVoList.add(map);        &#125;    &#125;    model.addAttribute(<span class="hljs-string">&quot;notices&quot;</span>, noticeVoList);    <span class="hljs-comment">// 设置已读</span>    List&lt;Integer&gt; ids = getMessageIds(noticeList);    <span class="hljs-keyword">if</span> (!ids.isEmpty())&#123;        messageService.readMessage(ids);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;site/notice-detail&quot;</span>;&#125;</code></pre></li><li><p>编写拦截器记录全局消息未读数</p><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageUnreadInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HandlerInterceptor</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> HostHolder hostHolder;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> MessageService messageService;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        User user = hostHolder.getUsers();        <span class="hljs-keyword">if</span> (user != <span class="hljs-keyword">null</span> &amp;&amp; modelAndView!=<span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">int</span> letterUnreadCount = messageService.findeLetterUnreadCount(user.getId(), <span class="hljs-keyword">null</span>);            <span class="hljs-keyword">int</span> noticeUnreadCount = messageService.findNoticeUnreadCount(user.getId(), <span class="hljs-keyword">null</span>);            modelAndView.addObject(<span class="hljs-string">&quot;unread&quot;</span>, letterUnreadCount + noticeUnreadCount);        &#125;    &#125;&#125;</code></pre></li><li><p>添加至WebMvcConfig</p><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><span class="hljs-keyword">private</span> MessageUnreadInterceptor messageUnreadInterceptor;    registry.addInterceptor(messageUnreadInterceptor)            .excludePathPatterns(<span class="hljs-string">&quot;/**/*.css&quot;</span>, <span class="hljs-string">&quot;/**/*.js&quot;</span>, <span class="hljs-string">&quot;/**/*.png&quot;</span>, <span class="hljs-string">&quot;/**/*.jpg&quot;</span>, <span class="hljs-string">&quot;/**/*.jpeg&quot;</span>);&#125;</code></pre></li><li><p>修改模版引擎（查看源文件）</p></li></ol><h3 id="开发流程图-8"><a href="#开发流程图-8" class="headerlink" title="开发流程图"></a>开发流程图</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201223111729.png" alt="流程图"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201223112157.png" alt="拦截器"></p><h1 id="ES与Security模块"><a href="#ES与Security模块" class="headerlink" title="ES与Security模块"></a>ES与Security模块</h1><h2 id="Spring-整合-Elastic-Search"><a href="#Spring-整合-Elastic-Search" class="headerlink" title="Spring 整合 Elastic Search"></a>Spring 整合 Elastic Search</h2><ul><li>引入依赖<ul><li>spirng-boot-starter-data-elastcsearch</li></ul></li><li>配置Elasticsearch<ul><li>cluster-name、cluster-nodes</li></ul></li><li>Spring Data Elasticsearch<ul><li>ElasticsearchTemplate</li><li>ElasticsearchRepository</li></ul></li></ul><p>注意：Elasticsearch版本与Spring Boot版本必须严格遵循统一</p><p>本项目使用elasticsearch 6.4.3</p><h3 id="开发流程-14"><a href="#开发流程-14" class="headerlink" title="开发流程"></a>开发流程</h3><ol><li><p>Maven依赖</p><pre><code class="hljs java">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-elasticsearch&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre></li><li><p>配置es</p><pre><code class="hljs properties"><span class="hljs-comment"># ElasticSearchProperties</span><span class="hljs-meta">spring.data.elasticsearch.cluster-name</span>=<span class="hljs-string">nowcoder</span><span class="hljs-meta">spring.data.elasticsearch.cluster-nodes</span>=<span class="hljs-string">127.0.0.1:9300</span></code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201223113939.png" alt="配置本地"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201223114002.png" alt="与上面一致"></p></li></ol><ol start="3"><li><p>解决es和redis同时占用netty问题</p><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CommunityApplication</span> </span>&#123;    <span class="hljs-meta">@PostConstruct</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-comment">// 解决redis和es同时使用NettyRuntime启动冲突问题</span>        <span class="hljs-comment">// Netty4Utils setAvailableProcessors</span>        System.setProperty(<span class="hljs-string">&quot;es.set.netty.runtime.available.processors&quot;</span>, <span class="hljs-string">&quot;false&quot;</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(CommunityApplication.class, args);    &#125;&#125;</code></pre></li><li><p>配置表对象和es存储对应的索引关系</p><pre><code class="hljs java"><span class="hljs-meta">@Data</span><span class="hljs-meta">@AllArgsConstructor</span><span class="hljs-meta">@NoArgsConstructor</span><span class="hljs-meta">@Document(indexName = &quot;discusspost&quot;, type =&quot;_doc&quot;, shards = 6, replicas = 3)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DiscussPost</span> </span>&#123;    <span class="hljs-meta">@Id</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;    <span class="hljs-meta">@Field(type = FieldType.Integer)</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> userId;    <span class="hljs-comment">// 往es存 互联网校招 analyzer把搜索的内容进行拆解最多单词 进行搜索匹配</span>    <span class="hljs-comment">// searchAnalyzer 把搜索条目拆解最少单词, searchAnalyzer = &quot;ik_smart&quot;</span>    <span class="hljs-meta">@Field(type = FieldType.Text, analyzer = &quot;ik_max_word&quot;, searchAnalyzer = &quot;ik_smart&quot;)</span>    <span class="hljs-keyword">private</span> String title;    <span class="hljs-meta">@Field(type = FieldType.Text, analyzer = &quot;ik_max_word&quot;, searchAnalyzer = &quot;ik_smart&quot;)</span>    <span class="hljs-keyword">private</span> String content;    <span class="hljs-meta">@Field(type = FieldType.Integer)</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> type;    <span class="hljs-meta">@Field(type = FieldType.Integer)</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> status;    <span class="hljs-meta">@Field(type = FieldType.Date)</span>    <span class="hljs-keyword">private</span> Date createTime;    <span class="hljs-meta">@Field(type = FieldType.Integer)</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> commentCount;    <span class="hljs-meta">@Field(type = FieldType.Double)</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> score;&#125;</code></pre><p>其中es的ik插件请前往github下载对应版本 <a href="https://github.com/medcl/elasticsearch-analysis-ik">ik</a></p></li><li><p>编写接口文件</p><pre><code class="hljs java"><span class="hljs-meta">@Repository</span><span class="hljs-comment">// 声明主键类型</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">DiscussPostRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ElasticsearchRepository</span>&lt;<span class="hljs-title">DiscussPost</span>, <span class="hljs-title">Integer</span>&gt; </span>&#123;&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201223114530.png" alt="es"></p></li><li><p>编写测试类（源文件给出）</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201223114717.png" alt="测试类"></p></li></ol><h2 id="搜索功能"><a href="#搜索功能" class="headerlink" title="搜索功能"></a>搜索功能</h2><ul><li>搜索服务<ul><li>将帖子保存至Elasticsearch服务器。</li><li>从Elasticsearch服务器删除帖子。</li><li>从Elasticsearch服务器搜索帖子。</li></ul></li><li>发布事件<ul><li>发布帖子时，将帖子异步的提交到Elasticsearch服务器。</li><li>增加评论时，将帖子异步的提交到Elasticsearch服务器。</li><li>在消费组件中增加一个方法，消费帖子发布事件。</li></ul></li><li>显示结果<ul><li>在控制器中处理搜索请求，在HTML上显示搜索结果。</li></ul></li></ul><h3 id="开发流程-15"><a href="#开发流程-15" class="headerlink" title="开发流程"></a>开发流程</h3><ol><li><p>编写ElasticsearchService</p><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ElasticSearchService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> DiscussPostRepository discussPostRepository;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> ElasticsearchTemplate elasticTemplate;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">saveDiscussPost</span><span class="hljs-params">(DiscussPost discussPost)</span></span>&#123;        discussPostRepository.save(discussPost);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteDiscussPost</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span></span>&#123;        discussPostRepository.deleteById(id);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Page&lt;DiscussPost&gt; <span class="hljs-title">searchDiscussPost</span><span class="hljs-params">(String keywords, <span class="hljs-keyword">int</span> current, <span class="hljs-keyword">int</span> limit)</span></span>&#123;        SearchQuery searchQuery = <span class="hljs-keyword">new</span> NativeSearchQueryBuilder()                .withQuery(QueryBuilders.multiMatchQuery(keywords, <span class="hljs-string">&quot;title&quot;</span>, <span class="hljs-string">&quot;content&quot;</span>))                .withSort(SortBuilders.fieldSort(<span class="hljs-string">&quot;type&quot;</span>).order(SortOrder.DESC))                .withSort(SortBuilders.fieldSort(<span class="hljs-string">&quot;score&quot;</span>).order(SortOrder.DESC))                .withSort(SortBuilders.fieldSort(<span class="hljs-string">&quot;createTime&quot;</span>).order(SortOrder.DESC))                .withPageable(PageRequest.of(current, limit))                .withHighlightFields(                        <span class="hljs-keyword">new</span> HighlightBuilder.Field(<span class="hljs-string">&quot;title&quot;</span>).preTags(<span class="hljs-string">&quot;&lt;em&gt;&quot;</span>).postTags(<span class="hljs-string">&quot;&lt;/em&gt;&quot;</span>),                        <span class="hljs-keyword">new</span> HighlightBuilder.Field(<span class="hljs-string">&quot;content&quot;</span>).preTags(<span class="hljs-string">&quot;&lt;em&gt;&quot;</span>).postTags(<span class="hljs-string">&quot;&lt;/em&gt;&quot;</span>)                ).build();        <span class="hljs-keyword">return</span> elasticTemplate.queryForPage(searchQuery, DiscussPost.class, <span class="hljs-keyword">new</span> SearchResultMapper() &#123;                       <span class="hljs-meta">@Override</span>            <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">AggregatedPage&lt;T&gt; <span class="hljs-title">mapResults</span><span class="hljs-params">(SearchResponse response, Class&lt;T&gt; aClass, Pageable pageable)</span> </span>&#123;                SearchHits hits = response.getHits();                <span class="hljs-keyword">if</span> (hits.getTotalHits() &lt;= <span class="hljs-number">0</span>) &#123;                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;                &#125;                List&lt;DiscussPost&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();                <span class="hljs-keyword">for</span> (SearchHit hit : hits) &#123;                    DiscussPost post = <span class="hljs-keyword">new</span> DiscussPost();                    String id = hit.getSourceAsMap().get(<span class="hljs-string">&quot;id&quot;</span>).toString();                    post.setId(Integer.valueOf(id));                    String userId = hit.getSourceAsMap().get(<span class="hljs-string">&quot;userId&quot;</span>).toString();                    post.setUserId(Integer.valueOf(userId));                    String title = hit.getSourceAsMap().get(<span class="hljs-string">&quot;title&quot;</span>).toString();                    post.setTitle(title);                    String content = hit.getSourceAsMap().get(<span class="hljs-string">&quot;content&quot;</span>).toString();                    post.setContent(content);                    String status = hit.getSourceAsMap().get(<span class="hljs-string">&quot;status&quot;</span>).toString();                    post.setStatus(Integer.valueOf(status));                    String createTime = hit.getSourceAsMap().get(<span class="hljs-string">&quot;createTime&quot;</span>).toString();                    post.setCreateTime(<span class="hljs-keyword">new</span> Date(Long.valueOf(createTime)));                    String commentCount = hit.getSourceAsMap().get(<span class="hljs-string">&quot;commentCount&quot;</span>).toString();                    post.setCommentCount(Integer.valueOf(commentCount));                    <span class="hljs-comment">// 处理高亮显示的结果</span>                    HighlightField titleField = hit.getHighlightFields().get(<span class="hljs-string">&quot;title&quot;</span>);                    <span class="hljs-keyword">if</span> (titleField != <span class="hljs-keyword">null</span>) &#123;                        post.setTitle(titleField.getFragments()[<span class="hljs-number">0</span>].toString());                    &#125;                    HighlightField contentField = hit.getHighlightFields().get(<span class="hljs-string">&quot;content&quot;</span>);                    <span class="hljs-keyword">if</span> (contentField != <span class="hljs-keyword">null</span>) &#123;                        post.setContent(contentField.getFragments()[<span class="hljs-number">0</span>].toString());                    &#125;                    list.add(post);                &#125;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AggregatedPageImpl(list, pageable,                        hits.getTotalHits(), response.getAggregations(), response.getScrollId(), hits.getMaxScore());            &#125;            <span class="hljs-meta">@Override</span>            <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">mapSearchHit</span><span class="hljs-params">(SearchHit searchHit, Class&lt;T&gt; aClass)</span> </span>&#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;            &#125;        &#125;);    &#125;&#125;</code></pre></li><li><p>处理发帖事件</p><p>常量接口添加：</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 主题:发帖</span><span class="hljs-comment"> */</span>String TOPIC_PUBLISH = <span class="hljs-string">&quot;publish&quot;</span>;</code></pre></li><li><p>处理事件消费者</p><pre><code class="hljs java"><span class="hljs-meta">@KafkaListener(topics = TOPIC_PUBLISH)</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleEventPublish</span><span class="hljs-params">(ConsumerRecord record)</span></span>&#123;    <span class="hljs-keyword">if</span> (record == <span class="hljs-keyword">null</span> || record.value() == <span class="hljs-keyword">null</span>)&#123;        <span class="hljs-comment">// 空消息</span>        logger.error(<span class="hljs-string">&quot;消息内容为空！&quot;</span>);        <span class="hljs-keyword">return</span>;    &#125;    Event event = JSONObject.parseObject(record.value().toString(), Event.class);    <span class="hljs-keyword">if</span> (event == <span class="hljs-keyword">null</span>)&#123;        logger.error(<span class="hljs-string">&quot;消息格式为空！&quot;</span>);        <span class="hljs-keyword">return</span>;    &#125;    DiscussPost post = discussPostService.findDiscussPostById(event.getEntityId());    elasticSearchService.saveDiscussPost(post);&#125;</code></pre></li><li><p>DiscusspostController处理发帖事件</p><pre><code class="hljs java"><span class="hljs-comment">// 触发发帖事件</span>Event event = <span class="hljs-keyword">new</span> Event()        .setTopic(TOPIC_PUBLISH)        .setUserId(user.getId())        .setEntityType(ENTITY_TYPE_POST)        .setEntityId(discussPost.getId());eventProducer.fireEvent(event);</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201223140158.png" alt="发帖事件"></p></li><li><p>CommentController 处理发帖事件</p><pre><code class="hljs java"><span class="hljs-keyword">if</span> (comment.getEntityType() == ENTITY_TYPE_POST)&#123;    <span class="hljs-comment">// 触发发帖事件</span>    event = <span class="hljs-keyword">new</span> Event()            .setTopic(TOPIC_PUBLISH)            .setUserId(comment.getUserId())            .setEntityType(ENTITY_TYPE_POST)            <span class="hljs-comment">// 更新的是帖子</span>            .setEntityId(discussPostId);    eventProducer.fireEvent(event);&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201223140313.png" alt="发帖事件"></p></li><li><p>编写SearchController</p><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SearchController</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CommunityConstant</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> UserService userService;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> ElasticSearchService elasticSearchService;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> LikeService likeService;    <span class="hljs-comment">//    /serach?keywords=</span>    <span class="hljs-meta">@RequestMapping(path = &quot;/search&quot;, method = RequestMethod.GET)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">search</span><span class="hljs-params">(String keywords, Page page, Model model)</span></span>&#123;        org.springframework.data.domain.Page&lt;DiscussPost&gt; discussPosts                = elasticSearchService.searchDiscussPost(keywords, page.getCurrent() - <span class="hljs-number">1</span>, page.getLimit());        List&lt;Map&lt;String, Object&gt;&gt; discussposts = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">for</span> (DiscussPost post: discussPosts             ) &#123;            Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();            <span class="hljs-comment">// 帖子</span>            map.put(<span class="hljs-string">&quot;post&quot;</span>, post);            <span class="hljs-comment">// 作者</span>            map.put(<span class="hljs-string">&quot;user&quot;</span>, userService.findUserById(post.getUserId()));            <span class="hljs-comment">// 点赞</span>            map.put(<span class="hljs-string">&quot;likeCount&quot;</span>, likeService.findEntityLikeCount(ENTITY_TYPE_POST, post.getId()));            discussposts.add(map);        &#125;        <span class="hljs-comment">// 分页信息</span>        page.setPath(<span class="hljs-string">&quot;/search?keywords=&quot;</span>+keywords);        page.setRows(discussPosts == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : (<span class="hljs-keyword">int</span>) discussPosts.getTotalElements());        model.addAttribute(<span class="hljs-string">&quot;discussPosts&quot;</span>, discussposts);        model.addAttribute(<span class="hljs-string">&quot;keywords&quot;</span>, keywords);        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;site/search&quot;</span>;    &#125;&#125;</code></pre></li><li><p>处理模版引擎</p></li></ol><h3 id="开发流程图-9"><a href="#开发流程图-9" class="headerlink" title="开发流程图"></a>开发流程图</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201223142518.png" alt="流程图"></p><h2 id="Spring-Security-权限管理"><a href="#Spring-Security-权限管理" class="headerlink" title="Spring Security 权限管理"></a>Spring Security 权限管理</h2><h3 id="Spring-Security原理大概"><a href="#Spring-Security原理大概" class="headerlink" title="Spring Security原理大概"></a>Spring Security原理大概</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201223143326.png" alt="原理"></p><ul><li>登录检查<ul><li>之前采用拦截器实现了登录检查,这是简单的权限管理方案,现在将其废弃。</li></ul></li><li>授权配置<ul><li>对当前系统内包含的所有的请求，分配访问权限(普通用户、版主、管理员)。</li></ul></li><li>认证方案<ul><li>绕过Security认证流程, 采用系统原来的认证方案。</li></ul></li><li>CSRF配置<ul><li>防止CSRF攻击的基本原理，以及表单、AJAX相关的配置。</li></ul></li></ul><blockquote><p>Spring Security 写的我差点脑溢血</p></blockquote><h3 id="开发流程-16"><a href="#开发流程-16" class="headerlink" title="开发流程"></a>开发流程</h3><ol><li><p>Maven引入</p><pre><code class="hljs java">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre></li><li><p>废弃之前的LoginRequired注解</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201223143832.png" alt="废弃"></p></li></ol><ol start="3"><li><p>常量接口增加权限常量</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 普通用户</span><span class="hljs-comment"> */</span>String AUTHORITY_USER = <span class="hljs-string">&quot;user&quot;</span>;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 管理员(删除)</span><span class="hljs-comment"> */</span>String AUTHORITY_ADMIN = <span class="hljs-string">&quot;admin&quot;</span>;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 版主(置顶、加精)</span><span class="hljs-comment"> */</span>String AUTHORITY_MODERATOR = <span class="hljs-string">&quot;moderator&quot;</span>;</code></pre></li><li><p>SecurityConfig配置</p><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringSecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CommunityConstant</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(WebSecurity web)</span> </span>&#123;        web.ignoring().antMatchers(<span class="hljs-string">&quot;/resources/**&quot;</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        http.authorizeRequests()                .antMatchers(                      <span class="hljs-string">&quot;/user/setting&quot;</span>,<span class="hljs-string">&quot;/user/upload&quot;</span>,<span class="hljs-string">&quot;/user/updatePassword&quot;</span>,<span class="hljs-string">&quot;/user/mypost&quot;</span>,<span class="hljs-string">&quot;/user/myreply&quot;</span>,                        <span class="hljs-string">&quot;/discuss/add&quot;</span>, <span class="hljs-string">&quot;/comment/add/**&quot;</span>, <span class="hljs-string">&quot;/message/**&quot;</span>,                        <span class="hljs-string">&quot;/like&quot;</span>, <span class="hljs-string">&quot;/follow&quot;</span>, <span class="hljs-string">&quot;/unfollow&quot;</span>                )                .hasAnyAuthority(                        AUTHORITY_USER, AUTHORITY_MODERATOR, AUTHORITY_ADMIN                )                .antMatchers(                        <span class="hljs-string">&quot;/discuss/top&quot;</span>,                        <span class="hljs-string">&quot;/discuss/wonderful&quot;</span>                )                .hasAnyAuthority(                        AUTHORITY_MODERATOR                )                .antMatchers(                        <span class="hljs-string">&quot;/data/**&quot;</span>,                        <span class="hljs-string">&quot;/discuss/delete&quot;</span>,                        <span class="hljs-string">&quot;/actuator/**&quot;</span>                )                .hasAnyAuthority(                        AUTHORITY_ADMIN                )                .anyRequest().permitAll()                .and().csrf().disable();        <span class="hljs-comment">// 权限冲突处理 普通请求(返回html)和异步请求(返回json)</span>        http.exceptionHandling()                <span class="hljs-comment">// 未登录处理</span>                .authenticationEntryPoint(<span class="hljs-keyword">new</span> AuthenticationEntryPoint() &#123;                    <span class="hljs-meta">@Override</span>                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">commence</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, AuthenticationException e)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;                        <span class="hljs-comment">// 分普通和异步请求</span>                        String xRequestedWith = request.getHeader(<span class="hljs-string">&quot;x-requested-with&quot;</span>);                        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;XMLHttpRequest&quot;</span>.equals(xRequestedWith))&#123;                            <span class="hljs-comment">// 异步请求</span>                            response.setContentType(<span class="hljs-string">&quot;application/plain;charset=utf-8&quot;</span>);                            PrintWriter writer = response.getWriter();                            writer.write(CommunityUtil.getJSONString(<span class="hljs-number">403</span>, <span class="hljs-string">&quot;用户未登录!&quot;</span>));                        &#125;<span class="hljs-keyword">else</span> &#123;                            response.sendRedirect(request.getContextPath() + <span class="hljs-string">&quot;/login&quot;</span>);                        &#125;                    &#125;                &#125;)                <span class="hljs-comment">// 登录处理</span>                .accessDeniedHandler(<span class="hljs-keyword">new</span> AccessDeniedHandler() &#123;                    <span class="hljs-meta">@Override</span>                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, AccessDeniedException e)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;                        <span class="hljs-comment">// 分普通和异步请求</span>                        String xRequestedWith = request.getHeader(<span class="hljs-string">&quot;x-requested-with&quot;</span>);                        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;XMLHttpRequest&quot;</span>.equals(xRequestedWith))&#123;                            <span class="hljs-comment">// 异步请求</span>                            response.setContentType(<span class="hljs-string">&quot;application/plain;charset=utf-8&quot;</span>);                            PrintWriter writer = response.getWriter();                            writer.write(CommunityUtil.getJSONString(<span class="hljs-number">403</span>, <span class="hljs-string">&quot;用户权限不足&quot;</span>));                        &#125;<span class="hljs-keyword">else</span> &#123;                            response.sendRedirect(request.getContextPath() + <span class="hljs-string">&quot;/denied&quot;</span>);                        &#125;                    &#125;                &#125;);        <span class="hljs-comment">// SpringSecurity底层默认拦截/logout请求,并运行其logout逻辑</span>        <span class="hljs-comment">// SpringSecurity为Filter filter在controller之前</span>        <span class="hljs-comment">// 想要运行自己的/logout 覆盖其默认逻辑 欺骗</span>        http.logout().logoutUrl(<span class="hljs-string">&quot;/securitylogout&quot;</span>);    &#125;&#125;</code></pre></li><li><p>UserService权限配置</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> Collection&lt;? extends GrantedAuthority&gt; getAuthorities(<span class="hljs-keyword">int</span> userId) &#123;    User user = userMapper.selectById(userId);    List&lt;GrantedAuthority&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    list.add(<span class="hljs-keyword">new</span> GrantedAuthority() &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getAuthority</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">switch</span> (user.getType()) &#123;                <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:                    <span class="hljs-keyword">return</span> AUTHORITY_ADMIN;                <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:                    <span class="hljs-keyword">return</span> AUTHORITY_MODERATOR;                    <span class="hljs-keyword">default</span>:                        <span class="hljs-keyword">return</span> AUTHORITY_USER;            &#125;        &#125;    &#125;);    <span class="hljs-keyword">return</span> list;&#125;</code></pre></li><li><p>拦截器预判断用户权限</p><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    <span class="hljs-comment">// 从cookie中获取ticket</span>    String ticket = CookieUtil.getValue(request, <span class="hljs-string">&quot;ticket&quot;</span>);    <span class="hljs-keyword">if</span> (ticket != <span class="hljs-keyword">null</span>)&#123;        <span class="hljs-comment">// 查询</span>        LoginTicket loginTicket = userService.findLoginTicket(ticket);        <span class="hljs-comment">// 检测有效</span>        <span class="hljs-keyword">if</span> (loginTicket != <span class="hljs-keyword">null</span> &amp;&amp; loginTicket.getStatus() == <span class="hljs-number">0</span> &amp;&amp; loginTicket.getExpired().after(<span class="hljs-keyword">new</span> Date()))&#123;            <span class="hljs-comment">// 根据凭证找到用户</span>            User user = userService.findUserById(loginTicket.getUserId());            <span class="hljs-comment">// 在本次请求中持有用户</span>            hostHolder.setUsers(user);            <span class="hljs-comment">// 构建用户认证结果 存入SecurityContext 以便与security进行授权(越过了security认证 用了自己的认证 需要自己授权)</span>            Authentication authentication = <span class="hljs-keyword">new</span> UsernamePasswordAuthenticationToken(                    user, user.getPassword(), userService.getAuthorities(user.getId())            );            SecurityContextHolder.setContext(<span class="hljs-keyword">new</span> SecurityContextImpl(authentication));        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201223144555.png" alt="退出功能"></p></li></ol><h2 id="置顶、加精、删除"><a href="#置顶、加精、删除" class="headerlink" title="置顶、加精、删除"></a>置顶、加精、删除</h2><ul><li>功能实现<ul><li>点击置顶，修改帖子的类型。</li><li>点击“加精”、“删除”， 修改帖子的状态。</li></ul></li><li>权限管理<ul><li>版主可以执行“置顶”</li><li>管理员可以执行“删除”操作。</li></ul></li><li>按钮显示<ul><li>版主可以看到“置顶”</li><li>管理员可以看到“删除”按钮。</li></ul></li></ul><h3 id="开发流程-17"><a href="#开发流程-17" class="headerlink" title="开发流程"></a>开发流程</h3><ol><li><p>Maven导入</p><pre><code class="hljs java">&lt;dependency&gt;    &lt;groupId&gt;org.thymeleaf.extras&lt;/groupId&gt;    &lt;artifactId&gt;thymeleaf-extras-springsecurity5&lt;/artifactId&gt;    &lt;version&gt;3.0.4.RELEASE&lt;/version&gt;&lt;/dependency&gt;</code></pre></li><li><p>便DiscusspostMapper 和 mapper文件</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">updateType</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, <span class="hljs-keyword">int</span> type)</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">updateStatus</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, <span class="hljs-keyword">int</span> status)</span></span>;</code></pre><pre><code class="hljs java">&lt;update id=<span class="hljs-string">&quot;updateType&quot;</span>&gt;    update discuss_post set type = #&#123;type&#125;    where id = #&#123;id&#125;&lt;/update&gt;&lt;update id=<span class="hljs-string">&quot;updateStatus&quot;</span>&gt;    update discuss_post set status = #&#123;status&#125;    where id = #&#123;id&#125;&lt;/update&gt;</code></pre></li><li><p>编写DiscusspostService</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">updateType</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, <span class="hljs-keyword">int</span> type)</span></span>&#123;    <span class="hljs-keyword">return</span> discussPostMapper.updateType(id, type);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">updateStatus</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, <span class="hljs-keyword">int</span> status)</span></span>&#123;    <span class="hljs-keyword">return</span> discussPostMapper.updateStatus(id, status);&#125;</code></pre></li><li><p>编写DiscusspostController</p><pre><code class="hljs java"><span class="hljs-comment">// 置顶</span><span class="hljs-meta">@RequestMapping(path = &quot;/top&quot;, method = RequestMethod.POST)</span><span class="hljs-meta">@ResponseBody</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">setTop</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span></span>&#123;    discussPostService.updateType(id, <span class="hljs-number">1</span>);    <span class="hljs-comment">// 触发发帖事件 ES更新</span>    Event event = <span class="hljs-keyword">new</span> Event()            .setTopic(TOPIC_PUBLISH)            .setUserId(hostHolder.getUsers().getId())            .setEntityType(ENTITY_TYPE_POST)            .setEntityId(id);    eventProducer.fireEvent(event);    <span class="hljs-keyword">return</span> CommunityUtil.getJSONString(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;置顶成功！&quot;</span>);&#125;<span class="hljs-comment">// 加精</span><span class="hljs-meta">@RequestMapping(path = &quot;/wonderful&quot;, method = RequestMethod.POST)</span><span class="hljs-meta">@ResponseBody</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">setWonderful</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span></span>&#123;    discussPostService.updateStatus(id, <span class="hljs-number">1</span>);    <span class="hljs-comment">// 触发发帖事件 ES更新</span>    Event event = <span class="hljs-keyword">new</span> Event()            .setTopic(TOPIC_PUBLISH)            .setUserId(hostHolder.getUsers().getId())            .setEntityType(ENTITY_TYPE_POST)            .setEntityId(id);    eventProducer.fireEvent(event);&#125;<span class="hljs-comment">// 删除</span><span class="hljs-meta">@RequestMapping(path = &quot;/delete&quot;, method = RequestMethod.POST)</span><span class="hljs-meta">@ResponseBody</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">setDelete</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span></span>&#123;    discussPostService.updateStatus(id, <span class="hljs-number">2</span>);    <span class="hljs-comment">// ES删除帖 触发删帖事件</span>    Event event = <span class="hljs-keyword">new</span> Event()            .setTopic(TOPIC_DELETE)            .setUserId(hostHolder.getUsers().getId())            .setEntityType(ENTITY_TYPE_POST)            .setEntityId(id);    eventProducer.fireEvent(event);    <span class="hljs-keyword">return</span> CommunityUtil.getJSONString(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;删除成功！&quot;</span>);&#125;</code></pre></li><li><p>编写js</p><pre><code class="hljs js"><span class="hljs-comment">// 置顶</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setTop</span>(<span class="hljs-params"></span>) </span>&#123;    $.post(        CONTEXT_PATH + <span class="hljs-string">&quot;/discuss/top&quot;</span>,        &#123;<span class="hljs-string">&quot;id&quot;</span>:$(<span class="hljs-string">&quot;#postId&quot;</span>).val()&#125;,        <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>) </span>&#123;            data = $.parseJSON(data);            <span class="hljs-keyword">if</span>(data.code == <span class="hljs-number">0</span>) &#123;                $(<span class="hljs-string">&quot;#topBtn&quot;</span>).attr(<span class="hljs-string">&quot;disabled&quot;</span>, <span class="hljs-string">&quot;disabled&quot;</span>);            &#125; <span class="hljs-keyword">else</span> &#123;                alert(data.msg);            &#125;        &#125;    );&#125;<span class="hljs-comment">// 加精</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setWonderful</span>(<span class="hljs-params"></span>) </span>&#123;    $.post(        CONTEXT_PATH + <span class="hljs-string">&quot;/discuss/wonderful&quot;</span>,        &#123;<span class="hljs-string">&quot;id&quot;</span>:$(<span class="hljs-string">&quot;#postId&quot;</span>).val()&#125;,        <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>) </span>&#123;            data = $.parseJSON(data);            <span class="hljs-keyword">if</span>(data.code == <span class="hljs-number">0</span>) &#123;                $(<span class="hljs-string">&quot;#wonderfulBtn&quot;</span>).attr(<span class="hljs-string">&quot;disabled&quot;</span>, <span class="hljs-string">&quot;disabled&quot;</span>);            &#125; <span class="hljs-keyword">else</span> &#123;                alert(data.msg);            &#125;        &#125;    );&#125;<span class="hljs-comment">// 删除</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setDelete</span>(<span class="hljs-params"></span>) </span>&#123;    $.post(        CONTEXT_PATH + <span class="hljs-string">&quot;/discuss/delete&quot;</span>,        &#123;<span class="hljs-string">&quot;id&quot;</span>:$(<span class="hljs-string">&quot;#postId&quot;</span>).val()&#125;,        <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>) </span>&#123;            data = $.parseJSON(data);            <span class="hljs-keyword">if</span>(data.code == <span class="hljs-number">0</span>) &#123;                location.href = CONTEXT_PATH + <span class="hljs-string">&quot;/index&quot;</span>;            &#125; <span class="hljs-keyword">else</span> &#123;                alert(data.msg);            &#125;        &#125;    );&#125;</code></pre></li><li><p>修改模版引擎</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201223145804.png" alt="权限"></p></li><li><p>SecurityConfig配置权限 源码已给出</p></li></ol><h3 id="开发流程图-10"><a href="#开发流程图-10" class="headerlink" title="开发流程图"></a>开发流程图</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201223150722.png" alt="流程图"></p><h1 id="额外功能丰富模块"><a href="#额外功能丰富模块" class="headerlink" title="额外功能丰富模块"></a>额外功能丰富模块</h1><h2 id="网站数据统计"><a href="#网站数据统计" class="headerlink" title="网站数据统计"></a>网站数据统计</h2><ul><li>UV (Unique Visitor)<ul><li>独立访客，需通过用户IP排重统计数据。</li><li>每次访问都要进行统计。</li><li>HyperLogLog，性能好，且存储空间小。</li></ul></li><li>DAU (Daily Active User)<ul><li>日活跃用户，需通过用户ID排重统计数据。访问过一次， 则认为其活跃。</li><li>Bitmap,性能好、且可以统计精确的结果</li></ul></li></ul><h3 id="开发流程-18"><a href="#开发流程-18" class="headerlink" title="开发流程"></a>开发流程</h3><ol><li><p>编写RedisKeyUtil</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String PREFIX_UV = <span class="hljs-string">&quot;uv&quot;</span>;   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String PREFIX_DAU = <span class="hljs-string">&quot;dau&quot;</span>;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getUVkey</span><span class="hljs-params">(String date)</span></span>&#123;    <span class="hljs-keyword">return</span> PREFIX_UV + SPILIT + date;&#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getUVkey</span><span class="hljs-params">(String startDate, String endDate)</span></span>&#123;    <span class="hljs-keyword">return</span> PREFIX_UV + SPILIT + startDate + SPILIT + endDate;&#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getDAUkey</span><span class="hljs-params">(String date)</span></span>&#123;    <span class="hljs-keyword">return</span> PREFIX_DAU + SPILIT + date;&#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getDAUkey</span><span class="hljs-params">(String startDate, String endDate)</span></span>&#123;    <span class="hljs-keyword">return</span> PREFIX_DAU + SPILIT + startDate + SPILIT + endDate;&#125;</code></pre><p>看一天/多天的</p></li><li><p>编写DataService</p><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DataService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> RedisTemplate redisTemplate;    <span class="hljs-keyword">private</span> SimpleDateFormat df = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyyMMdd&quot;</span>);    <span class="hljs-comment">// 将ip存入UV</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">recordUV</span><span class="hljs-params">(String ip)</span></span>&#123;        String redisKey = RedisKeyUtil.getUVkey(df.format(<span class="hljs-keyword">new</span> Date()));        redisTemplate.opsForHyperLogLog().add(redisKey, ip);    &#125;    <span class="hljs-comment">// 统计UV</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">calculateUV</span><span class="hljs-params">(Date start, Date end)</span></span>&#123;        <span class="hljs-keyword">if</span> (start == <span class="hljs-keyword">null</span> || end == <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;参数异常&quot;</span>);        &#125;        String redisKey = RedisKeyUtil.getUVkey(df.format(start), df.format(end));        List&lt;String&gt; keys = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        Calendar calendar = Calendar.getInstance();        calendar.setTime(start);        <span class="hljs-keyword">while</span> (!calendar.getTime().after(end))&#123;            String key = RedisKeyUtil.getUVkey(df.format(calendar.getTime()));            keys.add(key);            calendar.add(Calendar.DATE, <span class="hljs-number">1</span>);        &#125;        redisTemplate.opsForHyperLogLog().union(redisKey, keys.toArray());        <span class="hljs-keyword">return</span> redisTemplate.opsForHyperLogLog().size(redisKey);    &#125;    <span class="hljs-comment">// 将指定用户计入DAU</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">recordDAU</span><span class="hljs-params">(<span class="hljs-keyword">int</span> userId)</span></span>&#123;        String redisKey = RedisKeyUtil.getDAUkey(df.format(<span class="hljs-keyword">new</span> Date()));        redisTemplate.opsForValue().setBit(redisKey, userId, <span class="hljs-keyword">true</span>);    &#125;    <span class="hljs-comment">// 统计DAU</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">calculateDAU</span><span class="hljs-params">(Date start, Date end)</span></span>&#123;        <span class="hljs-keyword">if</span> (start == <span class="hljs-keyword">null</span> || end == <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;参数异常&quot;</span>);        &#125;        String redisKey = RedisKeyUtil.getDAUkey(df.format(start), df.format(end));        List&lt;<span class="hljs-keyword">byte</span>[]&gt; keys = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        Calendar calendar = Calendar.getInstance();        calendar.setTime(start);        <span class="hljs-keyword">while</span> (!calendar.getTime().after(end))&#123;            String key = RedisKeyUtil.getDAUkey(df.format(calendar.getTime()));            keys.add(key.getBytes());            calendar.add(Calendar.DATE, <span class="hljs-number">1</span>);        &#125;        <span class="hljs-comment">// 进行OR运算</span>        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">long</span>)redisTemplate.execute(<span class="hljs-keyword">new</span> RedisCallback() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">doInRedis</span><span class="hljs-params">(RedisConnection connection)</span> <span class="hljs-keyword">throws</span> DataAccessException </span>&#123;                connection.bitOp(RedisStringCommands.BitOperation.OR,                        redisKey.getBytes(), keys.toArray(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]));                <span class="hljs-keyword">return</span> connection.bitCount(redisKey.getBytes());            &#125;        &#125;);    &#125;&#125;</code></pre></li><li><p>编写data拦截器 统计并计入</p><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DataInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HandlerInterceptor</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> DataService dataService;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> HostHolder hostHolder;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">// 统计UV DAU</span>        <span class="hljs-comment">// UV:ip</span>        String ip = request.getRemoteHost();        dataService.recordUV(ip);        <span class="hljs-comment">// DAU:userId</span>        User user = hostHolder.getUsers();        <span class="hljs-keyword">if</span> (user!=<span class="hljs-keyword">null</span>)&#123;            dataService.recordDAU(user.getId());        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;</code></pre></li><li><p>WebMvcConfig添加拦截器</p><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><span class="hljs-keyword">private</span> DataInterceptor dataInterceptor;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> </span>&#123;    registry.addInterceptor(dataInterceptor)            .excludePathPatterns(<span class="hljs-string">&quot;/**/*.css&quot;</span>, <span class="hljs-string">&quot;/**/*.js&quot;</span>, <span class="hljs-string">&quot;/**/*.png&quot;</span>, <span class="hljs-string">&quot;/**/*.jpg&quot;</span>, <span class="hljs-string">&quot;/**/*.jpeg&quot;</span>);&#125;</code></pre></li><li><p>编写DataController</p><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DataController</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> DataService dataService;    <span class="hljs-comment">// 统计页面</span>    <span class="hljs-meta">@RequestMapping(path = &quot;/data&quot;, method = &#123;RequestMethod.GET, RequestMethod.POST&#125;)</span>    <span class="hljs-comment">// 后续用到转发 转发用的一个请求 后面为post</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getDataPage</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;site/admin/data&quot;</span>;    &#125;    <span class="hljs-comment">// 统计网站UV</span>    <span class="hljs-meta">@RequestMapping(path = &quot;/data/uv&quot;, method = RequestMethod.POST)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getUV</span><span class="hljs-params">(<span class="hljs-meta">@DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)</span> Date start,</span></span><span class="hljs-function"><span class="hljs-params">                        <span class="hljs-meta">@DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)</span> Date end, Model model)</span> </span>&#123;        <span class="hljs-keyword">long</span> uv = dataService.calculateUV(start, end);        model.addAttribute(<span class="hljs-string">&quot;uvResult&quot;</span>, uv);        model.addAttribute(<span class="hljs-string">&quot;uvStartDate&quot;</span>, start);        model.addAttribute(<span class="hljs-string">&quot;uvEndDate&quot;</span>, end);        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;forward:/data&quot;</span>;    &#125;    <span class="hljs-comment">// 统计活跃用户</span>    <span class="hljs-meta">@RequestMapping(path = &quot;/data/dau&quot;, method = RequestMethod.POST)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getDAU</span><span class="hljs-params">(<span class="hljs-meta">@DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)</span> Date start,</span></span><span class="hljs-function"><span class="hljs-params">                         <span class="hljs-meta">@DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)</span> Date end, Model model)</span> </span>&#123;        <span class="hljs-keyword">long</span> dau = dataService.calculateDAU(start, end);        model.addAttribute(<span class="hljs-string">&quot;dauResult&quot;</span>, dau);        model.addAttribute(<span class="hljs-string">&quot;dauStartDate&quot;</span>, start);        model.addAttribute(<span class="hljs-string">&quot;dauEndDate&quot;</span>, end);        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;forward:/data&quot;</span>;    &#125;&#125;</code></pre></li><li><p>处理模版引擎</p></li></ol><h3 id="开发流程图-11"><a href="#开发流程图-11" class="headerlink" title="开发流程图"></a>开发流程图</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201223161822.png" alt="流程图"></p><h2 id="热帖排行"><a href="#热帖排行" class="headerlink" title="热帖排行"></a>热帖排行</h2><ul><li>JDK线程池<ul><li>ExecutorService</li><li>ScheduledExecutorService</li></ul></li><li>Spring线程池<ul><li>ThreadPoolTaskExecutor</li><li>ThreadPoolTaskScheduler</li></ul></li><li>分布式定时任务<ul><li>Spring Quartz</li></ul></li></ul><p>JDK和Spring定时任务组件是基于内存的，配置参数基于内存，不同服务器内存不共享。</p><p>Quartz参数存到数据库，可以实现共享。</p><h3 id="Quartz原理"><a href="#Quartz原理" class="headerlink" title="Quartz原理"></a>Quartz原理</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201223162549.png" alt="原理图"></p><h3 id="Spring-整合-Quartz"><a href="#Spring-整合-Quartz" class="headerlink" title="Spring 整合 Quartz"></a>Spring 整合 Quartz</h3><ol><li><p>导入Quartz数据库</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201223162756.png" alt="Quartz_db"></p></li><li><p>Maven</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-quartz<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></li><li><p>配置</p><pre><code class="hljs properties"><span class="hljs-comment"># QuartzProperties</span><span class="hljs-meta">spring.quartz.job-store-type</span>=<span class="hljs-string">jdbc</span><span class="hljs-meta">spring.quartz.scheduler-name</span>=<span class="hljs-string">communityScheduler</span><span class="hljs-meta">spring.quartz.properties.org.quartz.scheduler.instanceId</span>=<span class="hljs-string">AUTO</span><span class="hljs-meta">spring.quartz.properties.org.quartz.jobStore.class</span>=<span class="hljs-string">org.quartz.impl.jdbcjobstore.JobStoreTX</span><span class="hljs-meta">spring.quartz.properties.org.quartz.jobStore.driverDelegateClass</span>=<span class="hljs-string">org.quartz.impl.jdbcjobstore.StdJDBCDelegate</span><span class="hljs-meta">spring.quartz.properties.org.quartz.jobStore.isClustered</span>=<span class="hljs-string">true</span><span class="hljs-meta">spring.quartz.properties.org.quartz.threadPool.class</span>=<span class="hljs-string">org.quartz.simpl.SimpleThreadPool</span><span class="hljs-meta">spring.quartz.properties.org.quartz.threadPool.threadCount</span>=<span class="hljs-string">5</span></code></pre></li></ol><h3 id="热帖开发流程"><a href="#热帖开发流程" class="headerlink" title="热帖开发流程"></a>热帖开发流程</h3><ol><li><p>编写rediskey</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String PREFIX_POST = <span class="hljs-string">&quot;post&quot;</span>; <span class="hljs-comment">//帖子分数(点赞加精等操作 存入postId)</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getPostScoreKey</span><span class="hljs-params">()</span></span>&#123;     <span class="hljs-keyword">return</span> PREFIX_POST + SPILIT + <span class="hljs-string">&quot;score&quot;</span>; &#125;</code></pre></li><li><p>编写DiscusspotsController</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201223163417.png" alt="1"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201223163438.png" alt="2"></p></li></ol><ol start="3"><li><p>编写likeController</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201223163525.png" alt="like"></p></li><li><p>编写CommentController</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201223163613.png" alt="comment"></p></li><li><p>编写job（任务）</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PostScoreRefreshJob</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Job</span>, <span class="hljs-title">CommunityConstant</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger logger = LoggerFactory.getLogger(PostScoreRefreshJob.class);    <span class="hljs-comment">// 牛客纪元</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Date epoch;    <span class="hljs-keyword">static</span> &#123;        <span class="hljs-keyword">try</span> &#123;            epoch = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>).parse(<span class="hljs-string">&quot;2014-08-01 00:00:00&quot;</span>);        &#125; <span class="hljs-keyword">catch</span> (ParseException e) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;初始化牛客纪元失败!&quot;</span>, e);        &#125;    &#125;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> RedisTemplate redisTemplate;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> DiscussPostService discussPostService;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> LikeService likeService;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> ElasticSearchService elasticSearchService;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(JobExecutionContext context)</span> <span class="hljs-keyword">throws</span> JobExecutionException </span>&#123;        String redisKey = RedisKeyUtil.getPostScoreKey();        BoundSetOperations operations = redisTemplate.boundSetOps(redisKey);        <span class="hljs-keyword">if</span> (operations.size() == <span class="hljs-number">0</span>) &#123;            logger.info(<span class="hljs-string">&quot;[任务取消] 没有需要刷新的帖子!&quot;</span>);            <span class="hljs-keyword">return</span>;        &#125;        logger.info(<span class="hljs-string">&quot;[任务开始] 正在刷新帖子分数: &quot;</span> + operations.size());        <span class="hljs-keyword">while</span> (operations.size() &gt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">this</span>.refresh((Integer) operations.pop());        &#125;        logger.info(<span class="hljs-string">&quot;[任务结束] 帖子分数刷新完毕!&quot;</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">refresh</span><span class="hljs-params">(<span class="hljs-keyword">int</span> postId)</span> </span>&#123;        DiscussPost post = discussPostService.findDiscussPostById(postId);        <span class="hljs-keyword">if</span> (post == <span class="hljs-keyword">null</span>) &#123;            logger.error(<span class="hljs-string">&quot;该帖子不存在: id = &quot;</span> + postId);            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">// 是否精华</span>        <span class="hljs-keyword">boolean</span> wonderful = post.getStatus() == <span class="hljs-number">1</span>;        <span class="hljs-comment">// 评论数量</span>        <span class="hljs-keyword">int</span> commentCount = post.getCommentCount();        <span class="hljs-comment">// 点赞数量</span>        <span class="hljs-keyword">long</span> likeCount = likeService.findEntityLikeCount(ENTITY_TYPE_POST, postId);        <span class="hljs-comment">// 计算权重</span>        <span class="hljs-keyword">double</span> w = (wonderful ? <span class="hljs-number">75</span> : <span class="hljs-number">0</span>) + commentCount * <span class="hljs-number">10</span> + likeCount * <span class="hljs-number">2</span>;        <span class="hljs-comment">// 分数 = 帖子权重 + 距离天数</span>        <span class="hljs-keyword">double</span> score = Math.log10(Math.max(w, <span class="hljs-number">1</span>))                + (post.getCreateTime().getTime() - epoch.getTime()) / (<span class="hljs-number">1000</span> * <span class="hljs-number">3600</span> * <span class="hljs-number">24</span>);        <span class="hljs-comment">// 更新帖子分数</span>        discussPostService.updateScore(postId, score);        <span class="hljs-comment">// 同步搜索数据</span>        post.setScore(score);        elasticSearchService.saveDiscussPost(post);    &#125;&#125;</code></pre></li><li><p>编写DiscusspostService</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">updateScore</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, <span class="hljs-keyword">double</span> score)</span></span>&#123;    <span class="hljs-keyword">return</span> discussPostMapper.updateScore(id, score);&#125;</code></pre></li><li><p>编写QuartzConfig</p><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-comment">// 配置 -&gt; 数据库 -&gt; 访问db调度任务</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QuartzConfig</span> </span>&#123;    <span class="hljs-comment">// BeanFactory 是IOC容器顶层接口</span>    <span class="hljs-comment">// FactoryBean 可简化Bean的实例化过程:</span>    <span class="hljs-comment">// 1.Spring通过FactoryBean封装了Bean的实例化过程</span>    <span class="hljs-comment">// 2.将FactoryBean装配到Spring容器中</span>    <span class="hljs-comment">// 3.将FactoryBean注入给其他的Bean</span>    <span class="hljs-comment">// 4.该Bean得到的是FactoryBean所管理的对象实例</span>    <span class="hljs-comment">// 配置JobDetail</span>    <span class="hljs-comment">//@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> JobDetailFactoryBean <span class="hljs-title">jobDetailTest</span><span class="hljs-params">()</span></span>&#123;        JobDetailFactoryBean jobDetailFactoryBean = <span class="hljs-keyword">new</span>  JobDetailFactoryBean();        jobDetailFactoryBean.setJobClass(JobTest.class);        jobDetailFactoryBean.setName(<span class="hljs-string">&quot;JobTest&quot;</span>);        jobDetailFactoryBean.setGroup(<span class="hljs-string">&quot;testJobGroup&quot;</span>);        <span class="hljs-comment">// 声明任务持久保存</span>        jobDetailFactoryBean.setDurability(<span class="hljs-keyword">true</span>);        <span class="hljs-comment">// 任务是否可恢复</span>        jobDetailFactoryBean.setRequestsRecovery(<span class="hljs-keyword">true</span>);        <span class="hljs-keyword">return</span> jobDetailFactoryBean;    &#125;    <span class="hljs-comment">// trigger 触发器 与 JobDetail有关系</span>    <span class="hljs-comment">// 配置Trigger(SimpleTriggerFactoryBean, CronTriggerFactoryBea(复杂,解决每个月月底何时xxx))</span>    <span class="hljs-comment">//@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> SimpleTriggerFactoryBean <span class="hljs-title">triggerTest</span><span class="hljs-params">(JobDetail jobDetailTest)</span></span>&#123;        SimpleTriggerFactoryBean factoryBean = <span class="hljs-keyword">new</span> SimpleTriggerFactoryBean();        factoryBean.setJobDetail(jobDetailTest);        factoryBean.setName(<span class="hljs-string">&quot;triggerTest&quot;</span>);        factoryBean.setGroup(<span class="hljs-string">&quot;testTriggerGroup&quot;</span>);        <span class="hljs-comment">// 执行频率</span>        factoryBean.setRepeatInterval(<span class="hljs-number">3000</span>);        <span class="hljs-comment">// trigger底层存储job状态</span>        factoryBean.setJobDataMap(<span class="hljs-keyword">new</span> JobDataMap());        <span class="hljs-keyword">return</span> factoryBean;    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> JobDetailFactoryBean <span class="hljs-title">postScoreRefreshJobDetail</span><span class="hljs-params">()</span></span>&#123;        JobDetailFactoryBean jobDetailFactoryBean = <span class="hljs-keyword">new</span>  JobDetailFactoryBean();        jobDetailFactoryBean.setJobClass(PostScoreRefreshJob.class);        jobDetailFactoryBean.setName(<span class="hljs-string">&quot;postScoreRefreshJob&quot;</span>);        jobDetailFactoryBean.setGroup(<span class="hljs-string">&quot;communityJobGroup&quot;</span>);        <span class="hljs-comment">// 声明任务持久保存</span>        jobDetailFactoryBean.setDurability(<span class="hljs-keyword">true</span>);        <span class="hljs-comment">// 任务是否可恢复</span>        jobDetailFactoryBean.setRequestsRecovery(<span class="hljs-keyword">true</span>);        <span class="hljs-keyword">return</span> jobDetailFactoryBean;    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> SimpleTriggerFactoryBean <span class="hljs-title">postScoreRefreshTrigger</span><span class="hljs-params">(JobDetail postScoreRefreshJobDetail)</span></span>&#123;        SimpleTriggerFactoryBean factoryBean = <span class="hljs-keyword">new</span> SimpleTriggerFactoryBean();        factoryBean.setJobDetail(postScoreRefreshJobDetail);        factoryBean.setName(<span class="hljs-string">&quot;postScoreRefreshTrigger&quot;</span>);        factoryBean.setGroup(<span class="hljs-string">&quot;communityTriggerGroup&quot;</span>);        <span class="hljs-comment">// 执行频率</span>        factoryBean.setRepeatInterval(<span class="hljs-number">1000</span> * <span class="hljs-number">60</span> * <span class="hljs-number">5</span>);        <span class="hljs-comment">// trigger底层存储job状态</span>        factoryBean.setJobDataMap(<span class="hljs-keyword">new</span> JobDataMap());        <span class="hljs-keyword">return</span> factoryBean;    &#125;&#125;</code></pre></li></ol><h3 id="开发流程图-12"><a href="#开发流程图-12" class="headerlink" title="开发流程图"></a>开发流程图</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201223164912.png" alt="流程图"></p><h2 id="头像上传七牛云"><a href="#头像上传七牛云" class="headerlink" title="头像上传七牛云"></a>头像上传七牛云</h2><h3 id="开发流程-19"><a href="#开发流程-19" class="headerlink" title="开发流程"></a>开发流程</h3><ol><li><p>Maven</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/com.qiniu/qiniu-java-sdk --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.qiniu<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>qiniu-java-sdk<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>7.2.28<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></li><li><p>配置qini</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201223165129.png" alt="配置"></p><p>具体依赖自己的qiniu配置</p></li><li><p>修改UserController</p><pre><code class="hljs java"><span class="hljs-meta">@Value(&quot;$&#123;qiniu.key.access&#125;&quot;)</span><span class="hljs-keyword">private</span> String accessKey;   <span class="hljs-meta">@Value(&quot;$&#123;qiniu.key.secret&#125;&quot;)</span><span class="hljs-keyword">private</span> String secretKey;   <span class="hljs-meta">@Value(&quot;$&#123;qiniu.bucket.header.name&#125;&quot;)</span><span class="hljs-keyword">private</span> String headerBucketName;   <span class="hljs-meta">@Value(&quot;$&#123;qiniu.bucket.header.url&#125;&quot;)</span><span class="hljs-keyword">private</span> String headerBucketUrl;   <span class="hljs-meta">@LoginRequired</span><span class="hljs-meta">@RequestMapping(path = &quot;/setting&quot;, method = RequestMethod.GET)</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getSettingPage</span><span class="hljs-params">(Model model)</span> </span>&#123;    <span class="hljs-comment">// 生成上传文件名称</span>    String fileName = CommunityUtil.generateUUID();    <span class="hljs-comment">// 设置响应信息</span>    StringMap policy = <span class="hljs-keyword">new</span> StringMap();    policy.put(<span class="hljs-string">&quot;returnBody&quot;</span>, CommunityUtil.getJSONString(<span class="hljs-number">0</span>));    <span class="hljs-comment">// 生成上传凭证</span>    Auth auth = Auth.create(accessKey, secretKey);    String uploadToken = auth.uploadToken(headerBucketName, fileName, <span class="hljs-number">3600</span>, policy);       model.addAttribute(<span class="hljs-string">&quot;uploadToken&quot;</span>, uploadToken);    model.addAttribute(<span class="hljs-string">&quot;fileName&quot;</span>, fileName);       <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;site/setting&quot;</span>;&#125;   <span class="hljs-comment">// 更新头像路径 异步</span><span class="hljs-meta">@RequestMapping(path = &quot;/header/url&quot;, method = RequestMethod.POST)</span><span class="hljs-meta">@ResponseBody</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">updateHeader</span><span class="hljs-params">(String fileName)</span> </span>&#123;    <span class="hljs-keyword">if</span> (StringUtils.isBlank(fileName)) &#123;        <span class="hljs-keyword">return</span> CommunityUtil.getJSONString(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;文件名不能为空&quot;</span>);    &#125;       String url = headerBucketUrl + <span class="hljs-string">&quot;/&quot;</span> + fileName;    userService.updateHeadUrl(hostHolder.getUsers().getId(), url);       <span class="hljs-keyword">return</span> CommunityUtil.getJSONString(<span class="hljs-number">0</span>);&#125;</code></pre></li><li><p>更新前端表单</p><pre><code class="hljs js">$(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;    $(<span class="hljs-string">&quot;#uploadForm&quot;</span>).submit(upload);&#125;);<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">upload</span>(<span class="hljs-params"></span>) </span>&#123;    $.ajax(&#123;        url: <span class="hljs-string">&quot;http://upload-z2.qiniup.com&quot;</span>,        method: <span class="hljs-string">&quot;post&quot;</span>,        processData: <span class="hljs-literal">false</span>,        contentType: <span class="hljs-literal">false</span>,        data: <span class="hljs-keyword">new</span> FormData($(<span class="hljs-string">&quot;#uploadForm&quot;</span>)[<span class="hljs-number">0</span>]),        success: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>) </span>&#123;            <span class="hljs-keyword">if</span>(data &amp;&amp; data.code == <span class="hljs-number">0</span>) &#123;                <span class="hljs-comment">// 更新头像访问路径</span>                $.post(                    CONTEXT_PATH + <span class="hljs-string">&quot;/user/header/url&quot;</span>,                    &#123;<span class="hljs-string">&quot;fileName&quot;</span>:$(<span class="hljs-string">&quot;input[name=&#x27;key&#x27;]&quot;</span>).val()&#125;,                    <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>) </span>&#123;                        data = $.parseJSON(data);                        <span class="hljs-keyword">if</span>(data.code == <span class="hljs-number">0</span>) &#123;                            <span class="hljs-built_in">window</span>.location.reload();                        &#125; <span class="hljs-keyword">else</span> &#123;                            alert(data.msg);                        &#125;                    &#125;                );            &#125; <span class="hljs-keyword">else</span> &#123;                alert(<span class="hljs-string">&quot;上传失败!&quot;</span>);            &#125;        &#125;    &#125;);    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;</code></pre></li><li><p>更新表单</p><pre><code class="hljs java">&lt;form <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;mt-5&quot;</span> id=<span class="hljs-string">&quot;uploadForm&quot;</span>&gt;   &lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;form-group row mt-4&quot;</span>&gt;      &lt;label for=&quot;head-image&quot; class=&quot;col-sm-2 col-form-label text-right&quot;&gt;选择头像:&lt;/label&gt;      &lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;col-sm-10&quot;</span>&gt;         &lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;custom-file&quot;</span>&gt;            &lt;input type=<span class="hljs-string">&quot;hidden&quot;</span> name=<span class="hljs-string">&quot;token&quot;</span> th:value=<span class="hljs-string">&quot;$&#123;uploadToken&#125;&quot;</span>&gt;            &lt;input type=<span class="hljs-string">&quot;hidden&quot;</span> name=<span class="hljs-string">&quot;key&quot;</span> th:value=<span class="hljs-string">&quot;$&#123;fileName&#125;&quot;</span>&gt;            &lt;input type=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;custom-file-input&quot;</span> id=<span class="hljs-string">&quot;head-image&quot;</span> name=<span class="hljs-string">&quot;file&quot;</span> lang=<span class="hljs-string">&quot;es&quot;</span> required=<span class="hljs-string">&quot;&quot;</span>&gt;            &lt;label class=&quot;custom-file-label&quot; for=&quot;head-image&quot; data-browse=&quot;文件&quot;&gt;选择一张图片&lt;/label&gt;            &lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;invalid-feedback&quot;</span>&gt;               该账号不存在!            &lt;/div&gt;         &lt;/div&gt;      &lt;/div&gt;   &lt;/div&gt;   &lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;form-group row mt-4&quot;</span>&gt;      &lt;div class=&quot;col-sm-2&quot;&gt;&lt;/div&gt;      &lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;col-sm-10 text-center&quot;</span>&gt;         &lt;button type=&quot;submit&quot; class=&quot;btn btn-info text-white form-control&quot;&gt;立即上传&lt;/button&gt;      &lt;/div&gt;   &lt;/div&gt;&lt;/form&gt;</code></pre></li></ol><h3 id="开发流程图-13"><a href="#开发流程图-13" class="headerlink" title="开发流程图"></a>开发流程图</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201223170535.png" alt="流程图"></p><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><ul><li>本地缓存<ul><li>将数据缓存在应用服务器上,性能最好。</li><li>常用缓存工具: Ehcache、 Guava、 Caffeine等。</li></ul></li><li>分布式缓存<ul><li>将数据缓存在NoSQL数据库上，跨服务器。常用缓存工具: MemCache、Redis等。</li></ul></li><li>多级缓存<ul><li>一级缓存(本地缓存)&gt;二级缓存(分布式缓存)&gt;DB</li></ul></li><li>避免缓存雪崩(缓存失效，大量请求直达DB )，提高系统的可用性。</li></ul><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201223171345.png" alt="redis共享缓存"></p><p>​       redis可以跨服务器</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201223171726.png" alt="redis单体"></p><h3 id="caffeine-作缓存开发流程"><a href="#caffeine-作缓存开发流程" class="headerlink" title="caffeine 作缓存开发流程"></a>caffeine 作缓存开发流程</h3><ol><li><p>Maven</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/com.github.ben-manes.caffeine/caffeine --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.ben-manes.caffeine<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>caffeine<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.8.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></li><li><p>配置caffeine</p><pre><code class="hljs properties"><span class="hljs-comment"># caffeine 缓存热帖</span><span class="hljs-meta">caffeine.posts.max-size</span>=<span class="hljs-string">15</span><span class="hljs-comment"># 三分钟</span><span class="hljs-meta">caffeine.posts.expire-seconds</span>=<span class="hljs-string">180</span></code></pre></li><li><p>编写DiscussPostService</p><pre><code class="hljs java"><span class="hljs-meta">@Value(&quot;$&#123;caffeine.posts.max-size&#125;&quot;)</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> maxSize;   <span class="hljs-meta">@Value(&quot;$&#123;caffeine.posts.expire-seconds&#125;&quot;)</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> expireSeconds;   <span class="hljs-comment">// caffeine 核心接口: Cache, LoadingCache, AsyncLoadingCache</span>   <span class="hljs-comment">// 缓存帖子列表</span><span class="hljs-keyword">private</span> LoadingCache&lt;String, List&lt;DiscussPost&gt;&gt; postListCache;   <span class="hljs-comment">// 缓存帖子总数</span><span class="hljs-keyword">private</span> LoadingCache&lt;Integer, Integer&gt; postRowsCache;   <span class="hljs-meta">@PostConstruct</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-comment">// 初始化缓存</span>    <span class="hljs-comment">// 帖子列表</span>    postListCache = Caffeine.newBuilder()            .maximumSize(maxSize)            .expireAfterWrite(expireSeconds, TimeUnit.SECONDS)            .build(<span class="hljs-keyword">new</span> CacheLoader&lt;String, List&lt;DiscussPost&gt;&gt;() &#123;                <span class="hljs-meta">@Nullable</span>                <span class="hljs-meta">@Override</span>                <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;DiscussPost&gt; <span class="hljs-title">load</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> String key)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                    <span class="hljs-keyword">if</span> (key == <span class="hljs-keyword">null</span> || key.length() == <span class="hljs-number">0</span>)&#123;                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;参数错误&quot;</span>);                    &#125;                       String[] params = key.split(<span class="hljs-string">&quot;:&quot;</span>);                    <span class="hljs-keyword">if</span> (params == <span class="hljs-keyword">null</span> || params.length!=<span class="hljs-number">2</span>)&#123;                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;参数错误&quot;</span>);                    &#125;                    <span class="hljs-keyword">int</span> offset = Integer.valueOf(params[<span class="hljs-number">0</span>]);                    <span class="hljs-keyword">int</span> limit = Integer.valueOf(params[<span class="hljs-number">1</span>]);                    <span class="hljs-comment">// 可以加入二级缓存:Redis -&gt; mysql</span>                    logger.debug(<span class="hljs-string">&quot;load post list from DB.&quot;</span>);                    <span class="hljs-keyword">return</span> discussPostMapper.selectDiscussPosts(<span class="hljs-number">0</span>, offset, limit, <span class="hljs-number">1</span>);                &#125;            &#125;);    <span class="hljs-comment">// 帖子总数</span>    postRowsCache = Caffeine.newBuilder()            .maximumSize(maxSize)            .expireAfterWrite(expireSeconds, TimeUnit.SECONDS)            .build(<span class="hljs-keyword">new</span> CacheLoader&lt;Integer, Integer&gt;() &#123;                <span class="hljs-meta">@Nullable</span>                <span class="hljs-meta">@Override</span>                <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">load</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Integer integer)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                    logger.debug(<span class="hljs-string">&quot;load post rows from DB.&quot;</span>);                    <span class="hljs-keyword">return</span> discussPostMapper.selectDiscussPostRows(integer);                &#125;            &#125;);&#125;</code></pre></li><li><p>对find方法修改</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201223172210.png" alt="修改"></p></li></ol><h3 id="caffeine缓存性能测试"><a href="#caffeine缓存性能测试" class="headerlink" title="caffeine缓存性能测试"></a>caffeine缓存性能测试</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201223173220.png" alt="添加缓存"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201223173259.png" alt="添加缓存"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201223173344.png" alt="优化去除后"></p><p>再次测试</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201223173436.png" alt="吞吐量变化"></p>]]></content>
    
    
    
    <tags>
      
      <tag>项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM解密</title>
    <link href="/2020/12/02/JVM%E8%A7%A3%E5%AF%86/"/>
    <url>/2020/12/02/JVM%E8%A7%A3%E5%AF%86/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><h2 id="什么是JVM"><a href="#什么是JVM" class="headerlink" title="什么是JVM?"></a>什么是JVM?</h2><blockquote><p>定义</p></blockquote><p>​ Java Virtual Machine - java 程序的运行环境(java 二进制字节码的运行环境)</p><blockquote><p>好处</p></blockquote><ul><li>一次编写，到处运行的一个基石</li><li>自动内存的管理机制，提供垃圾回收功能</li><li>数组下标越界的检查</li><li>实现多态</li></ul><blockquote><p>比较</p></blockquote><p>​ jvm jre jdk(java开发工具包):</p><p>​ <img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201202202613.png" alt="区别" style="zoom:50%;" /></p><p>​ JVM去屏蔽java代码与底层操作系统的差异</p><blockquote><p>常见的JVM</p></blockquote><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201202203444.png" alt="JVM种类"></p><h1 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h1><h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201202203747.png" alt="整体架构"></p><pre><code class="hljs js">ClassLoader为类加载器，java源代码编译为java二进制字节码后通过类加载器加载到JVM里运行，类放在方法区，创建的实例、对象放在堆里，其间所用到的方法放入虚拟机栈、程序计数器以及本地方法栈，方法执行时每行代码由执行引擎解释器逐行执行，方法中的热点代码(频繁调用的代码)由JIT优化后执行，GC对堆中不再被引用的对象引用回收。与操作系统打交道则需要本地方法接口调用。</code></pre><h2 id="1、程序计数器"><a href="#1、程序计数器" class="headerlink" title="1、程序计数器"></a>1、程序计数器</h2><h3 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h3><blockquote><p>Program Counter Register 程序计数器(寄存器)</p></blockquote><h3 id="1-2-作用"><a href="#1-2-作用" class="headerlink" title="1.2 作用"></a>1.2 作用</h3><ul><li><p>作用:  记住下一条jvm指令的执行地址</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201202205624.png" alt="执行流程"></p><p>​   java源代码被编译成为 <strong>二进制字节码, 左侧为jvm指令</strong>, 对所有平台都是一致的, 指令交给解释器翻译为机器码, 再交给cpu执行, 期间 <strong>程序计数器</strong>记录下一条指令地址, 物理上 <strong>程序计数器由寄存器实现</strong>, 是cpu上读取最快的单元</p></li><li><p>特点:  </p><ul><li><p><strong>线程私有的</strong></p><ul><li>CPU会为每个线程分配时间片，当当前线程的时间片使用完以后，CPU就会去执行另一个线程中的代码</li><li>程序计数器是 <strong>每个线程</strong> 所 <strong>私有</strong> 的，每个线程都有自己的程序计数器，当另一个线程的时间片用完，又返回来执行当前线程的代码时，通过程序计数器可以知道应该执行哪一句指令</li></ul></li><li><p> 唯一一个<strong>不会存在内存溢出</strong>的区</p></li></ul></li></ul><h2 id="2、虚拟机栈"><a href="#2、虚拟机栈" class="headerlink" title="2、虚拟机栈"></a>2、虚拟机栈</h2><h3 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h3><blockquote><p>Java Virtual Machine Stacks (Java 虚拟机栈)</p></blockquote><ul><li>每个 <strong>线程</strong> 运行需要的内存空间，称为 <strong>虚拟机栈</strong></li><li>每个栈由多个 <strong>栈帧</strong> 组成，对应着每次调用方法时所占用的内存</li><li>每个线程只能有 <strong>一个活动栈帧</strong> ，对应着 <strong>当前正在执行的方法</strong></li></ul><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201202210927.png" alt="例子" style="zoom:50%;" /><h3 id="2-2-演示"><a href="#2-2-演示" class="headerlink" title="2.2 演示"></a>2.2 演示</h3><p>代码：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo_01</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        method1();    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span> </span>&#123;        method2(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">method2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;        <span class="hljs-keyword">int</span> c =  a + b;        <span class="hljs-keyword">return</span> c;    &#125;&#125;</code></pre><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201202211143.png" alt="图样" style="zoom:50%;" /><h3 id="2-3-栈问题"><a href="#2-3-栈问题" class="headerlink" title="2.3 栈问题"></a>2.3 栈问题</h3><ul><li><p>垃圾回收是否涉及 <strong>栈内存</strong>？</p><ul><li><p> <strong>不需要</strong>，因为虚拟机栈中是由一个个栈帧组成的，在方法执行完毕后，对应的 <strong>栈帧就会被弹出栈</strong>。所以无需通过垃圾回收机制去回收内存。</p></li><li><p>垃圾回收是对 <strong>堆内存</strong> 中的无用对象回收。</p></li></ul></li><li><p><strong>栈内存分配越大越好吗</strong>？</p><ul><li><p><a href="https://docs.oracle.com/en/java/javase/11/tools/java.html#GUID-3B1CE181-CD30-4178-9602-230B800D4FAE">引用</a></p></li><li><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201203182734.png" alt="栈帧分配"></p></li><li><p>不是。因为 <strong>物理内存是一定的</strong>，栈内存越大，可以支持更多的递归调用，但是 <strong>可执行的线程数就会越少</strong>。</p></li></ul></li><li><p>方法内的局部变量是否是线程安全的？</p><ul><li><p>如果方法内 <strong>局部变量没有逃离方法的作用范围</strong>，则是 <strong>线程安全</strong>的</p></li><li><p>如果如果 <strong>局部变量引用了对象</strong>，并<strong>逃离了方法的作用范围</strong>，则需要考虑线程安全问题</p></li></ul></li></ul><p>  例子:</p>  <pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 局部变量的线程安全问题</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo_01_18</span> </span>&#123;    <span class="hljs-comment">// 多个线程同时执行此方法</span>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m1</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;            x++;        &#125;        System.out.println(x);    &#125;&#125;</code></pre><p>  x变量为方法内的局部变量，一个线程一个栈，每次方法调用都产生一个栈帧，分配局部变量。</p>  <img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201203183431.png" alt="局部变量" style="zoom: 33%;" /><p>  现在每个线程都有一个私有的x变量，各自加五千互不干扰，最终都得出相同的结果。</p><p>   <strong>但如果x为 int static</strong> ，结果就不一样:</p>  <img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201203183659.png" alt="static" style="zoom:33%;" /><p>​ 但如果例子为:</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 局部变量的线程安全问题</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo_01_17</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();        sb.append(<span class="hljs-number">4</span>);        sb.append(<span class="hljs-number">5</span>);        sb.append(<span class="hljs-number">6</span>);        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;            m2(sb);        &#125;).start();    &#125;    <span class="hljs-comment">// m1()不会产生线程安全问题，sb为局部变量，线程私有</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m1</span><span class="hljs-params">()</span> </span>&#123;        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();        sb.append(<span class="hljs-number">1</span>);        sb.append(<span class="hljs-number">2</span>);        sb.append(<span class="hljs-number">3</span>);        System.out.println(sb.toString());    &#125;    <span class="hljs-comment">// m2()会产生线程安全问题，sb对多个线程是共享的(例如main函数里，main线程和新线程都在修改sb)</span>    <span class="hljs-comment">// 不能用到StringBuilder，应该StringBuffer</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m2</span><span class="hljs-params">(StringBuilder sb)</span> </span>&#123;        sb.append(<span class="hljs-number">1</span>);        sb.append(<span class="hljs-number">2</span>);        sb.append(<span class="hljs-number">3</span>);        System.out.println(sb.toString());    &#125;    <span class="hljs-comment">// m3()会产生线程安全问题，sb被返回了</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> StringBuilder <span class="hljs-title">m3</span><span class="hljs-params">()</span> </span>&#123;        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();        sb.append(<span class="hljs-number">1</span>);        sb.append(<span class="hljs-number">2</span>);        sb.append(<span class="hljs-number">3</span>);        <span class="hljs-keyword">return</span> sb;    &#125;&#125;</code></pre><h3 id="2-4-栈内存溢出问题"><a href="#2-4-栈内存溢出问题" class="headerlink" title="2.4 栈内存溢出问题"></a>2.4 栈内存溢出问题</h3><blockquote><p> <strong>Java.lang.stackOverflowError</strong> 栈内存溢出</p></blockquote><h4 id="发生原因"><a href="#发生原因" class="headerlink" title="发生原因"></a>发生原因</h4><ul><li><p>虚拟机栈中， <strong>栈帧过多</strong>（无限递归）</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 演示栈内存溢出 java.lang.StackOverflowError</span><span class="hljs-comment"> * -Xss256k</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo_01_2</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> count;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            method1();        &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;            e.printStackTrace();            System.out.println(count);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span> </span>&#123;        count++;        method1();    &#125;&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201203185104.png" alt="次数"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201203185225.png" alt="修改栈内存"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201203185256.png" alt="结果"></p></li></ul><ul><li>每个栈帧 <strong>所占用过大</strong></li></ul><p>​ 引用的包导致栈溢出的例子:</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * json 数据转换</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo_01_19</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> JsonProcessingException </span>&#123;        Dept d = <span class="hljs-keyword">new</span> Dept();        d.setName(<span class="hljs-string">&quot;Market&quot;</span>);        Emp e1 = <span class="hljs-keyword">new</span> Emp();        e1.setName(<span class="hljs-string">&quot;zhang&quot;</span>);        e1.setDept(d);        Emp e2 = <span class="hljs-keyword">new</span> Emp();        e2.setName(<span class="hljs-string">&quot;li&quot;</span>);        e2.setDept(d);        d.setEmps(Arrays.asList(e1, e2));        <span class="hljs-comment">// &#123; name: &#x27;Market&#x27;, emps: [&#123; name:&#x27;zhang&#x27;, dept:&#123; name:&#x27;&#x27;, emps: [ &#123;&#125;]&#125; &#125;,] &#125;</span>        ObjectMapper mapper = <span class="hljs-keyword">new</span> ObjectMapper();        System.out.println(mapper.writeValueAsString(d));    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Emp</span> </span>&#123;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> Dept dept;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Dept <span class="hljs-title">getDept</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> dept;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setDept</span><span class="hljs-params">(Dept dept)</span> </span>&#123;        <span class="hljs-keyword">this</span>.dept = dept;    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dept</span> </span>&#123;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> List&lt;Emp&gt; emps;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Emp&gt; <span class="hljs-title">getEmps</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> emps;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setEmps</span><span class="hljs-params">(List&lt;Emp&gt; emps)</span> </span>&#123;        <span class="hljs-keyword">this</span>.emps = emps;    &#125;&#125;</code></pre><p>Json转换时:{ name: ‘Market’, emps: [{ name:’zhang’, dept:{ name:’’, emps: [ {}]} },] }</p><p>解决方案:</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Emp</span> </span>&#123;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-meta">@JsonIgnore</span>    <span class="hljs-keyword">private</span> Dept dept;    <span class="hljs-comment">// ....</span>&#125;</code></pre><h3 id="2-5-线程运行诊断"><a href="#2-5-线程运行诊断" class="headerlink" title="2.5 线程运行诊断"></a>2.5 线程运行诊断</h3><h4 id="案例1-cpu占用过高"><a href="#案例1-cpu占用过高" class="headerlink" title="案例1: cpu占用过高"></a>案例1: cpu占用过高</h4><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 演示 cpu 占用过高</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo_01_16</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">null</span>, () -&gt; &#123;            System.out.println(<span class="hljs-string">&quot;1...&quot;</span>);            <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;            &#125;        &#125;, <span class="hljs-string">&quot;thread1&quot;</span>).start();        <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">null</span>, () -&gt; &#123;            System.out.println(<span class="hljs-string">&quot;2...&quot;</span>);            <span class="hljs-keyword">try</span> &#123;                Thread.sleep(<span class="hljs-number">1000000L</span>);            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;, <span class="hljs-string">&quot;thread2&quot;</span>).start();        <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">null</span>, () -&gt; &#123;            System.out.println(<span class="hljs-string">&quot;3...&quot;</span>);            <span class="hljs-keyword">try</span> &#123;                Thread.sleep(<span class="hljs-number">1000000L</span>);            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;, <span class="hljs-string">&quot;thread3&quot;</span>).start();    &#125;&#125;</code></pre><p>此代码运行到linux环境下:</p><p>top命令:</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201203191313.png" alt="top"></p><p> <strong>只能定位到进程，无法定位到线程</strong></p><p> <strong>ps H -eo pid, tid（线程id）, %cpu | grep 刚才通过top查到的进程号</strong></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201203191646.png" alt="结果"></p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201203191750.png" alt="test" style="zoom: 50%;" /><blockquote><p>总结</p></blockquote><ul><li><p>Linux环境下运行某些程序的时候，可能导致CPU的占用过高，这时需要定位占用CPU过高的线程</p><ul><li><p><strong>top</strong>命令，查看是哪个 <strong>进程</strong>占用CPU过高</p></li><li><p><strong>ps H -eo pid, tid（线程id）, %cpu | grep 刚才通过top查到的进程号</strong> 通过ps命令进一步查看是哪个线程占用CPU过高</p></li><li><p><strong>jstack 进程id</strong> 通过查看进程中的线程的nid，刚才通过ps命令看到的tid来 <strong>对比定位</strong>，注意jstack查找出的线程id是 <strong>16进制的</strong>， <strong>需要转换</strong></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201204100850.png" alt="16进制"></p><p>32665的十六进制对应为7f99, 所以定位到线程thread1</p><p>下面提示第八行代码出现问题</p></li></ul></li></ul><h4 id="案例2-程序运行很长时间没有结果"><a href="#案例2-程序运行很长时间没有结果" class="headerlink" title="案例2: 程序运行很长时间没有结果"></a>案例2: 程序运行很长时间没有结果</h4><p>代码:</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 演示线程死锁</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>&#123;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span></span>&#123;&#125;;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo_01_03</span> </span>&#123;    <span class="hljs-keyword">static</span> A a = <span class="hljs-keyword">new</span> A();    <span class="hljs-keyword">static</span> B b = <span class="hljs-keyword">new</span> B();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;            <span class="hljs-keyword">synchronized</span> (a) &#123;                <span class="hljs-keyword">try</span> &#123;                    Thread.sleep(<span class="hljs-number">2000</span>);                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                &#125;                <span class="hljs-keyword">synchronized</span> (b) &#123;                    System.out.println(<span class="hljs-string">&quot;我获得了 a 和 b&quot;</span>);                &#125;            &#125;        &#125;).start();        Thread.sleep(<span class="hljs-number">1000</span>);        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;            <span class="hljs-keyword">synchronized</span> (b) &#123;                <span class="hljs-keyword">synchronized</span> (a) &#123;                    System.out.println(<span class="hljs-string">&quot;我获得了 a 和 b&quot;</span>);                &#125;            &#125;        &#125;).start();    &#125;&#125;</code></pre><p>同样可以利用jstack来查询</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201204101456.png" alt="结果"></p><h2 id="3、本地方法栈"><a href="#3、本地方法栈" class="headerlink" title="3、本地方法栈"></a>3、本地方法栈</h2><blockquote><p>java虚拟机调用本地方法时需要提供的内存空间</p></blockquote><p>本地方法: 一些带有 <strong>native关键字</strong>的方法就是需要JAVA去调用本地的 <strong>C或者C++方法</strong>，因为JAVA有时候没法直接和 <strong>操作系统底层</strong>交互，所以需要用到本地方法。</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201204102423.png" alt="clone()"></p><h2 id="4、堆"><a href="#4、堆" class="headerlink" title="4、堆"></a>4、堆</h2><blockquote><p>堆和方法区是 <strong>线程共享</strong>的</p></blockquote><h3 id="4-1-定义"><a href="#4-1-定义" class="headerlink" title="4.1 定义"></a>4.1 定义</h3><ul><li>通过new关键字 <strong>创建的对象</strong>都会被放在堆内存</li></ul><h3 id="4-2-特点"><a href="#4-2-特点" class="headerlink" title="4.2 特点"></a>4.2 特点</h3><ul><li> <strong>所有线程共享</strong>，堆内存中的对象都需要<strong>考虑线程安全问题</strong></li><li>有垃圾回收机制</li></ul><h3 id="4-3-堆内存溢出问题"><a href="#4-3-堆内存溢出问题" class="headerlink" title="4.3 堆内存溢出问题"></a>4.3 堆内存溢出问题</h3><blockquote><p> <strong>java.lang.OutofMemoryError</strong> ：java heap space. 堆内存溢出</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1_5</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;        <span class="hljs-keyword">try</span> &#123;            List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();            String a = <span class="hljs-string">&quot;hello&quot;</span>;            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;                list.add(a); <span class="hljs-comment">// hello, hellohello, hellohellohellohello ...</span>                a = a + a;  <span class="hljs-comment">// hellohellohellohello</span>                i++;            &#125;        &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;            e.printStackTrace();            System.out.println(i);        &#125;    &#125;&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201204103052.png" alt="结果"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201204103650.png" alt="修改"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201204103719.png" alt="结果"></p><h3 id="4-4-堆内存诊断"><a href="#4-4-堆内存诊断" class="headerlink" title="4.4 堆内存诊断"></a>4.4 堆内存诊断</h3><h4 id="jps-工具"><a href="#jps-工具" class="headerlink" title="jps 工具"></a>jps 工具</h4><ul><li>查看当前系统中有哪些 <strong>java进程</strong></li></ul><h4 id="jmap工具"><a href="#jmap工具" class="headerlink" title="jmap工具"></a>jmap工具</h4><ul><li>查看 <strong>某个时刻</strong> 堆内存占用情况 ( - heap pid)</li><li>Jdk 9以上 jhsdb jmap –heap –pid pid</li></ul><h4 id="jconsole工具"><a href="#jconsole工具" class="headerlink" title="jconsole工具"></a>jconsole工具</h4><ul><li><p>图形界面的，多功能的检测工具，可以 <strong>连续监测</strong></p><p>代码:</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1_4</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        System.out.println(<span class="hljs-string">&quot;1...&quot;</span>);        Thread.sleep(<span class="hljs-number">30000</span>);        <span class="hljs-keyword">byte</span>[] array = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">10</span>]; <span class="hljs-comment">// 10 Mb, 堆空间</span>        System.out.println(<span class="hljs-string">&quot;2...&quot;</span>);        Thread.sleep(<span class="hljs-number">30000</span>);        array = <span class="hljs-keyword">null</span>;        System.gc();        System.out.println(<span class="hljs-string">&quot;3...&quot;</span>);        Thread.sleep(<span class="hljs-number">1000000L</span>);    &#125;&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201204105859.png" alt="检测"></p></li></ul><h3 id="案例-gc回收之后-内存占用仍然很高"><a href="#案例-gc回收之后-内存占用仍然很高" class="headerlink" title="案例: gc回收之后, 内存占用仍然很高"></a>案例: gc回收之后, 内存占用仍然很高</h3><p>​ 代码:</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 演示查看对象个数 堆转储 dump</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1_13</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        List&lt;Student&gt; students = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">200</span>; i++) &#123;            students.add(<span class="hljs-keyword">new</span> Student());<span class="hljs-comment">//            Student student = new Student();</span>        &#125;        Thread.sleep(<span class="hljs-number">1000000000L</span>);    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">byte</span>[] big = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>];&#125;</code></pre><p>​ 执行完gc后, 内存占用还是很高:</p><p>​ <img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201204135214.png" alt="执行完gc后"></p><h3 id="使用jvisualvm"><a href="#使用jvisualvm" class="headerlink" title="使用jvisualvm"></a>使用jvisualvm</h3><p>堆快照:</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201204135748.png" alt="堆快照"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201204135854.png" alt="查找堆"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201204140353.png" alt="查到结果"></p><p>查到结果为Student对象中浪费空间, list一直未被回收, 内存占用高</p><h2 id="5、方法区"><a href="#5、方法区" class="headerlink" title="5、方法区"></a>5、方法区</h2><h3 id="5-1-定义"><a href="#5-1-定义" class="headerlink" title="5.1 定义"></a>5.1 定义</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201204142845.png" alt="定义"></p><h3 id="5-2-结构"><a href="#5-2-结构" class="headerlink" title="5.2 结构"></a>5.2 结构</h3><p>​ <img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201204142945.png" alt="结构"></p><p>​   元空间已经不由jvm管理内存了</p><h3 id="5-3-内存溢出"><a href="#5-3-内存溢出" class="headerlink" title="5.3 内存溢出"></a>5.3 内存溢出</h3><ul><li><p>1.8以后会导致 <strong>元空间</strong>内存溢出</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 演示元空间内存溢出 java.lang.OutOfMemoryError: Metaspace</span><span class="hljs-comment"> * -XX:MaxMetaspaceSize=8m</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1_8</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ClassLoader</span> </span>&#123; <span class="hljs-comment">// 可以用来加载类的二进制字节码</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;        <span class="hljs-keyword">try</span> &#123;            Demo1_8 test = <span class="hljs-keyword">new</span> Demo1_8();            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++, j++) &#123;                <span class="hljs-comment">// ClassWriter 作用是生成类的二进制字节码</span>                ClassWriter cw = <span class="hljs-keyword">new</span> ClassWriter(<span class="hljs-number">0</span>);                <span class="hljs-comment">// 版本号， public， 类名, 包名, 父类， 接口</span>                cw.visit(Opcodes.V1_8, Opcodes.ACC_PUBLIC, <span class="hljs-string">&quot;Class&quot;</span> + i, <span class="hljs-keyword">null</span>, <span class="hljs-string">&quot;java/lang/Object&quot;</span>, <span class="hljs-keyword">null</span>);                <span class="hljs-comment">// 返回 byte[]</span>                <span class="hljs-keyword">byte</span>[] code = cw.toByteArray();                <span class="hljs-comment">// 执行了类的加载</span>                test.defineClass(<span class="hljs-string">&quot;Class&quot;</span> + i, code, <span class="hljs-number">0</span>, code.length); <span class="hljs-comment">// Class 对象</span>            &#125;        &#125; <span class="hljs-keyword">finally</span> &#123;            System.out.println(j);        &#125;    &#125;&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201204143911.png" alt="配置"></p><p>（元空间默认用系统内存，很难演示元空间溢出）</p><p>若改为8m:Error occurred during initialization of VM MaxMetaspaceSize is too small.</p><p>所以改为10m再次测试:          <img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201204144143.png" alt="结果"></p></li></ul><ul><li><p>1.8以前会导致 <strong>永久代</strong>内存溢出</p><p>使用java1.6:</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201204144418.png" alt="结果"></p></li></ul><h3 id="5-4-真实场景"><a href="#5-4-真实场景" class="headerlink" title="5.4 真实场景"></a>5.4 真实场景</h3><p>​ <img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201204145437.png" alt="区别"></p><ul><li><p>Spring</p><ul><li><p><strong>cjlib</strong> 生成代理类, AOP核心</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201204145057.png" alt="cjlib"></p><p>都有ClassWriter和ClassVisitor，都是 <strong>运行期间动态生成类的字节码，完成动态的类加载，代理技术广泛应用这种字节码动态生成技术</strong></p></li></ul></li><li><p>mybatis</p><ul><li> <strong>cjlib</strong> 生成Mapper接口的实现类</li></ul><p>所以使用这种框架, 是很容易产生 <strong>永久代溢出</strong> 的情况的！</p></li></ul><h3 id="5-5-常量池"><a href="#5-5-常量池" class="headerlink" title="5.5 常量池"></a>5.5 常量池</h3><p>常量池最初存在字节码文件，运行时被加载到运行时常量池（constant pool）</p><pre><code class="hljs java"><span class="hljs-comment">// 运行先编译二进制字节码，包含了(类的基本信息、常量池、类的方法定义（包含了虚拟机指令）)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorld</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;hello!&quot;</span>);    &#125;&#125;</code></pre><p>找到class文件:</p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201204150212.png" alt="class文件" style="zoom:50%;" /><p>javap -v HelloWorld.class 进行反编译,并显示全部信息:</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201204150438.png" alt="类的基本信息"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201204150537.png" alt="常量池1"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201204150609.png" alt="常量池2"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201204150719.png" alt="无参构造方法"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201204150745.png" alt="main方法"></p><p>0,3,5,8后为虚拟机指令, getstatic为获取 <strong>静态变量</strong> , 即得到sout, ldc加载参数(hello!), invokevirtual虚方法调用,调用println, return为结束</p><p>#2,#3,#4查表翻译:</p><pre><code class="hljs clean">根据#<span class="hljs-number">2</span>查到常量池的表 -&gt; Fieldref -&gt; #<span class="hljs-number">21.</span>#<span class="hljs-number">22</span>#<span class="hljs-number">21</span> -&gt; Class -&gt; #<span class="hljs-number">28</span>(说明要找java/lang/System类的成员变量)#<span class="hljs-number">22</span> -&gt; #<span class="hljs-number">29</span> #<span class="hljs-number">30</span>(说明要找java/lang/System类中out的变量, 类型为java/io/PrintStream)根据#<span class="hljs-number">3</span>查到常量池的表 -&gt; #<span class="hljs-number">23</span>(String) -&gt; hello!(utf<span class="hljs-number">-8</span>) 加载进来#<span class="hljs-number">4</span> -&gt; 方法调用Methodref -&gt; ....</code></pre><blockquote><p>常量池作用</p></blockquote><p> <strong>给指令提供一些常量符号, 根据常量符号查表找到, 虚拟机指令才可正常执行</strong></p><h3 id="5-6-运行时常量池"><a href="#5-6-运行时常量池" class="headerlink" title="5.6 运行时常量池"></a>5.6 运行时常量池</h3><ul><li>常量池<ul><li>就是一张表（如上图中的constant pool），虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量信息</li></ul></li><li>运行时常量池<ul><li>常量池是*.class文件中的，当该 <strong>类被加载以后</strong>，它的常量池信息就会 <strong>放入运行时常量池</strong>，并把里面的 <strong>符号地址变为真实地址</strong></li></ul></li></ul><h3 id="5-7-String-Table-（串池）"><a href="#5-7-String-Table-（串池）" class="headerlink" title="5.7 String Table （串池）"></a>5.7 String Table （串池）</h3><h4 id="字节码和常量池角度理解底层原理"><a href="#字节码和常量池角度理解底层原理" class="headerlink" title="字节码和常量池角度理解底层原理"></a>字节码和常量池角度理解底层原理</h4><p>测试代码：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    String s1 = <span class="hljs-string">&quot;a&quot;</span>; <span class="hljs-comment">// 懒惰的</span>    String s2 = <span class="hljs-string">&quot;b&quot;</span>;    String s3 = <span class="hljs-string">&quot;ab&quot;</span>;&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201225100606.png" alt="进行编译"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201225100858.png" alt="加载"></p><p>Ldc #n 从常量池n号位置加载对应信息（常量、对象引用）</p><p>astore_1 加载好的信息放入局部变量表编号1</p><p>常量池中的信息，都会被加载到运行时常量池中，但这是a b ab 仅是常量池中的符号， <strong>还没有成为java字符串</strong> ；</p><p>当执行到 ldc #2 时，会把符号 a 变为 “a” 字符串对象， <strong>并放入串池中</strong> （hashtable结构 不可扩容）</p><p>当执行到 ldc #3 时，会把符号 b 变为 “b” 字符串对象，并放入串池中</p><p>当执行到 ldc #4 时，会把符号 ab 变为 “ab” 字符串对象，并放入串池中</p><p>最终 <strong>StringTable [“a”, “b”, “ab”]</strong> </p><p> <strong>注意</strong> ：字符串对象的创建都是 <strong>懒惰的</strong> ，只有当运行到那一行字符串且在串池中不存在的时候（如 ldc #2）时，该字符串才会被创建并放入串池中。</p><pre><code class="hljs js">常量池中的信息，都会被加载到运行时常量池中， 这时 a b ab 都是常量池中的符号，还没有变为 java 字符串对象执行到ldc #2 会把 a 符号变为 &quot;a&quot; 字符串对象，此时会准备一份空间为String table[] （哈希表,不可扩容）也就是串池，存入，然后去找，看看有没有取值相同的key执行到ldc #3 会把 b 符号变为 &quot;b&quot; 字符串对象执行到ldc #4 会把 ab 符号变为 &quot;ab&quot; 字符串对象#懒惰的 用到了才会创建，用不到不会提前创建</code></pre><h4 id="字符串变量拼接"><a href="#字符串变量拼接" class="headerlink" title="字符串变量拼接"></a>字符串变量拼接</h4><p>修改代码：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    String s1 = <span class="hljs-string">&quot;a&quot;</span>; <span class="hljs-comment">// 懒惰的 用到了才会创建，用不到不会提前创建</span>    String s2 = <span class="hljs-string">&quot;b&quot;</span>;    String s3 = <span class="hljs-string">&quot;ab&quot;</span>;    String s4 = s1 + s2;&#125;</code></pre><p>再次编译：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201225102356.png" alt="编译"></p><p>先创建一个 <strong>StringBuilder</strong> 对象，invokespecial调用方法， init为 <strong>构造方法，且无参</strong>，aload_1把s1加载进来，和astore_1相对，调用append方法，再aload_2，append方法，再调用toString方法，再存储astore_4</p><p>所以是会调用StringBuilder的toString()方法的，我们找到这个方法</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201225102830.png" alt="toString"></p><pre><code class="hljs java">System.out.println(s3 == s4);<span class="hljs-comment">// false</span></code></pre><p> s3值为ab，是串池中的一个对象，s4引用的是一个新的字符串对象，存在 <strong>堆</strong> 里面，new出来的。</p><p>通过拼接的方式来创建字符串的 <strong>过程</strong> 是：StringBuilder().append(“a”).append(“b”).toString()</p><p>最后的toString方法的返回值是一个 <strong>新的字符串</strong> ，但字符串的 <strong>值</strong> 和拼接的字符串一致，但是两个不同的字符串， <strong>一个存在于串池之中，一个存在于堆内存之中</strong> </p><h4 id="编译期优化"><a href="#编译期优化" class="headerlink" title="编译期优化"></a>编译期优化</h4><p>代码修改为</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    String s1 = <span class="hljs-string">&quot;a&quot;</span>; <span class="hljs-comment">// 懒惰的 用到了才会创建，用不到不会提前创建</span>    String s2 = <span class="hljs-string">&quot;b&quot;</span>;    String s3 = <span class="hljs-string">&quot;ab&quot;</span>;    String s4 = s1 + s2;<span class="hljs-comment">// new StringBuilder().append(&quot;a&quot;).append(&quot;b&quot;).toString()  new String(&quot;ab&quot;)</span>    String s5 = <span class="hljs-string">&quot;a&quot;</span> + <span class="hljs-string">&quot;b&quot;</span>;    System.out.println(s3 == s5);&#125;<span class="hljs-comment">// true</span></code></pre><p>编译后发现是直接去取值</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201225103458.png" alt="取值"></p><p>直接引用串池中已有的对象</p><blockquote><p>原理</p></blockquote><p> <strong>javac 在编译期间的优化</strong> ，结果已经在编译期确定为ab，并在StringTable中查找。</p><ul><li>使用 <strong>拼接字符串常量</strong> 的方法来创建新的字符串时，因为 <strong>内容是常量，javac在编译期会进行优化，结果已在编译期确定为ab</strong> ，而创建ab的时候已经在串池中放入了“ab”，所以ab3直接从串池中获取值，所以进行的操作和 ab = “ab” 一致。</li><li>使用 <strong>拼接字符串变量</strong> 的方法来创建新的字符串时，因为内容是变量，只能 <strong>在运行期确定它的值，所以需要使用StringBuilder来创建</strong> </li></ul><h4 id="字符串延迟实例化"><a href="#字符串延迟实例化" class="headerlink" title="字符串延迟实例化"></a>字符串延迟实例化</h4><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    <span class="hljs-keyword">int</span> x = args.length;    System.out.println(); <span class="hljs-comment">// 字符串个数 2275</span>    System.out.print(<span class="hljs-string">&quot;1&quot;</span>);    System.out.print(<span class="hljs-string">&quot;2&quot;</span>);    System.out.print(<span class="hljs-string">&quot;3&quot;</span>);    System.out.print(<span class="hljs-string">&quot;4&quot;</span>);    System.out.print(<span class="hljs-string">&quot;5&quot;</span>);    System.out.print(<span class="hljs-string">&quot;6&quot;</span>);    System.out.print(<span class="hljs-string">&quot;7&quot;</span>);    System.out.print(<span class="hljs-string">&quot;8&quot;</span>);    System.out.print(<span class="hljs-string">&quot;9&quot;</span>);    System.out.print(<span class="hljs-string">&quot;0&quot;</span>);    System.out.print(<span class="hljs-string">&quot;1&quot;</span>); <span class="hljs-comment">// 字符串个数 2285</span>    System.out.print(<span class="hljs-string">&quot;2&quot;</span>);    System.out.print(<span class="hljs-string">&quot;3&quot;</span>);    System.out.print(<span class="hljs-string">&quot;4&quot;</span>);    System.out.print(<span class="hljs-string">&quot;5&quot;</span>);    System.out.print(<span class="hljs-string">&quot;6&quot;</span>);    System.out.print(<span class="hljs-string">&quot;7&quot;</span>);    System.out.print(<span class="hljs-string">&quot;8&quot;</span>);    System.out.print(<span class="hljs-string">&quot;9&quot;</span>);    System.out.print(<span class="hljs-string">&quot;0&quot;</span>);    System.out.print(x); <span class="hljs-comment">// 字符串个数</span>&#125;</code></pre><p>用的IDEA memory工具查看</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201225110206.png" alt="memory"></p><p>debug</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201225110250.png" alt="memory"></p><p>正好十一个，再到后面，串池重复，String个数不增加</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201225110427.png" alt="memory"></p><blockquote><p>总结</p></blockquote><p>StringTable特征：</p><p>用来放字符串对象且里面的 <strong>元素不重复</strong></p><ul><li>常量池中的字符串仅是符号，<code>第一次用到时才变为对象 </code></li><li>利用串池的机制，来 <code>避免重复创建字符串对象 </code></li><li>字符串 <code>变量拼接</code> 的原理是 <code>StringBuilder (1.8) </code> </li><li>字符串 <code>常量拼接</code> 的原理是 <code>编译期优化</code></li><li>可以使用 <strong>intern方法</strong> ，主动将串池中还没有的字符串对象放入串池中</li><li> <strong>注意</strong> ：无论是串池还是堆里面的字符串，<code>都是对象</code></li></ul><h4 id="intern方法"><a href="#intern方法" class="headerlink" title="intern方法"></a>intern方法</h4><blockquote><p>主动将串池中没有的串放入</p><p>1.8:</p><p>无论放入是否成功，都会返回 <strong>串池中</strong> 的字符串对象</p><p> <strong>注意</strong> ：此时如果调用intern方法成功，堆内存与串池中的字符串对象是同一个对象；如果失败，则不是同一个对象</p><p>1.6:</p><p>无论放入是否成功，都会返回 <strong>串池中</strong> 的字符串对象</p><p><strong>注意</strong>：此时无论调用intern方法成功与否，串池中的字符串对象和堆内存中的字符串对象 <strong>都不是同一个对象</strong> </p></blockquote><h5 id="intern-1-8"><a href="#intern-1-8" class="headerlink" title="intern 1.8"></a>intern 1.8</h5><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    <span class="hljs-comment">// a b都是常量，放在串池 两个 a b</span>    <span class="hljs-comment">// new的String放在堆中 三个 a b ab 动态拼接的字符串开始都放在堆中，不在串池</span>    String s = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;a&quot;</span>) + <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;b&quot;</span>);    <span class="hljs-comment">// 堆  new String(&quot;a&quot;)   new String(&quot;b&quot;) new String(&quot;ab&quot;)</span>    String s2 = s.intern();    <span class="hljs-comment">// 将这个字符串对象尝试放入串池</span>    <span class="hljs-comment">// 如果有则并不会放入</span>    <span class="hljs-comment">// 如果没有则放入串池， 会把串池中的对象返回</span>    System.out.println(s2 == <span class="hljs-string">&quot;ab&quot;</span>); <span class="hljs-comment">// ab用的上一步放入串池的</span>    <span class="hljs-comment">// true</span>    System.out.println(s == <span class="hljs-string">&quot;ab&quot;</span>); <span class="hljs-comment">// intern会将s尝试放入串池</span>    <span class="hljs-comment">// true</span>&#125;</code></pre><p>如果“ab”一开始就放入</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    String x = <span class="hljs-string">&quot;ab&quot;</span>; <span class="hljs-comment">// ab放入串池</span>        <span class="hljs-comment">// a b都是常量，放在串池 三个 a b ab</span>    <span class="hljs-comment">// new的String放在堆中 三个 a b ab 动态拼接的字符串开始都放在堆中，不在串池</span>    String s = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;a&quot;</span>) + <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;b&quot;</span>);    <span class="hljs-comment">// 堆  new String(&quot;a&quot;)   new String(&quot;b&quot;) new String(&quot;ab&quot;)</span>    String s2 = s.intern();    <span class="hljs-comment">// 将这个字符串对象尝试放入串池</span>    <span class="hljs-comment">// 如果有则并不会放入</span>    <span class="hljs-comment">// 如果没有则放入串池， 会把串池中的对象返回</span>    System.out.println(s2 == x); <span class="hljs-comment">// 拿串池返回的比</span>    <span class="hljs-comment">// true</span>    System.out.println(s == x); <span class="hljs-comment">// 拿堆的比，intern没有放入</span>    <span class="hljs-comment">// false</span>&#125;</code></pre><p>s.intern()，如果串池没有，s会放入；如果有，会返回串池中的对象</p><p>所以如果串池没有 s == “ab” ，s放入了，所以相等</p><p>但是如果串池有，s == x，s没有放入但返回了s2，所以s2 == x，但s != x</p><h5 id="intern-1-6"><a href="#intern-1-6" class="headerlink" title="intern 1.6"></a>intern 1.6</h5><p>代码：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201225135149.png" alt="code"></p><p>true和false</p><p>另外一种情况：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201225135446.png" alt="new code"></p><p>s.intern是拷贝，返回的串池中的ab，和s不是同一个对象</p><p>所以x、s2都是 <strong>串池中的ab</strong> ，s还是 <strong>堆里的对象</strong></p><p>还是true false</p><p>相同代码 1.8环境两个true</p><h5 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h5><ul><li>可以使用 intern 方法，主动将串池中还没有的字符串对象放入串池<ul><li>1.8 将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有则放入串池， 会把串 池中的对象返回</li><li>1.6 将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有会把此对象 <strong>复制一份， 放入串池</strong> ， 会把串池中的对象返回</li></ul></li></ul><h4 id="String-Table-面试题"><a href="#String-Table-面试题" class="headerlink" title="String Table 面试题"></a>String Table 面试题</h4><p>code：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        String s1 = <span class="hljs-string">&quot;a&quot;</span>;        String s2 = <span class="hljs-string">&quot;b&quot;</span>;        String s3 = <span class="hljs-string">&quot;a&quot;</span> + <span class="hljs-string">&quot;b&quot;</span>; <span class="hljs-comment">// ab</span>        String s4 = s1 + s2;   <span class="hljs-comment">// init,apend,toString -&gt; new String(&quot;ab&quot;)</span>        String s5 = <span class="hljs-string">&quot;ab&quot;</span>;        String s6 = s4.intern();<span class="hljs-comment">// s4不会放入，还是堆上</span>        System.out.println(s3 == s4); <span class="hljs-comment">// false</span>        System.out.println(s3 == s5); <span class="hljs-comment">// true</span>        System.out.println(s3 == s6); <span class="hljs-comment">// true</span>        String x2 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;c&quot;</span>) + <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;d&quot;</span>); <span class="hljs-comment">// new String(&quot;cd&quot;)</span>        String x1 = <span class="hljs-string">&quot;cd&quot;</span>;<span class="hljs-comment">// 串池</span>        x2.intern();<span class="hljs-comment">// x2放入串池失败，堆中</span>               System.out.println(x1 == x2); <span class="hljs-comment">// false</span>    &#125;</code></pre><p>如果代码：</p><pre><code class="hljs java">String x2 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;c&quot;</span>) + <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;d&quot;</span>); <span class="hljs-comment">// new String(&quot;cd&quot;)</span>        x2.intern(); <span class="hljs-comment">// x2放入串池</span>        String x1 = <span class="hljs-string">&quot;cd&quot;</span>;<span class="hljs-comment">// 问，如果调换了【最后两行代码】的位置呢，如果是jdk1.6呢</span>        System.out.println(x1 == x2); <span class="hljs-comment">// 1.8 true 1.6 false</span>    &#125;</code></pre><h4 id="StringTable-位置"><a href="#StringTable-位置" class="headerlink" title="StringTable 位置"></a>StringTable 位置</h4><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201225141334.png" alt="位置"></p><p>原因：永久代内存回收效率很低，永久代需要 <strong>Full GC</strong> 才会触发 <strong>永久代垃圾回收</strong>，Full GC需要等到 <strong>老年代空间不足</strong> 才能触发，间接导致串池回收效率很低。</p><p>堆里面串池只需要 <strong>minor GC</strong> 就可以触发垃圾回收。</p><h5 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h5><p>1.6 环境下运行和1.8环境报错不同</p><p>code：</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 演示 StringTable 位置</span><span class="hljs-comment"> * 在jdk8下设置 -Xmx10m -XX:-UseGCOverheadLimit</span><span class="hljs-comment"> * 在jdk6下设置 -XX:MaxPermSize=10m</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1_6</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">260000</span>; j++) &#123;                list.add(String.valueOf(j).intern());                i++;            &#125;        &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">finally</span> &#123;            System.out.println(i);        &#125;    &#125;&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201225142201.png" alt="VM setting"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201225142737.png" alt="堆错误"></p><p>如果是1.6</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201225143029.png" alt="1.6"></p><p>显示永久代空间不足</p><p>如果只加-Xmx10m：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201225143310.png" alt="xmx10m"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201225143329.png" alt="GC overhead"></p><p>后面的参数实际上是设置 <strong>GC limit开关</strong></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201225143455.png" alt="开关"></p><p>加号表示开启，减号表示关闭</p><h4 id="String-Table-垃圾回收"><a href="#String-Table-垃圾回收" class="headerlink" title="String Table 垃圾回收"></a>String Table 垃圾回收</h4><p>字符串常量并不是永久的，也是会被GC回收的。</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 演示 StringTable 垃圾回收</span><span class="hljs-comment"> * 堆内存最大值       打印字符串表统计信息          打印GC信息</span><span class="hljs-comment"> * -Xmx10m -XX:+PrintStringTableStatistics -XX:+PrintGCDetails -verbose:gc</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1_7</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">100000</span>; j++) &#123; <span class="hljs-comment">// j=100, j=10000</span>                String.valueOf(j).intern();                i++;            &#125;        &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">finally</span> &#123;            System.out.println(i);        &#125;    &#125;&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201225144248.png" alt="JVM配置"></p><p>SymbolTable statistics: 符号表 也在常量池</p><p>StringTable statistics: 串池统计信息（哈希表实现）</p><p>哈希表：数组 + 链表， 数组个数称为桶（bucket），键值对：entries， literals（字符串常量对象个数）</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201225144722.png" alt="结果"></p><p>如果删除循环</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201225144808.png" alt="结果"></p><blockquote><p>为什么循环一万次 字符串常量数没有这么多产生</p></blockquote><p>进行了gc回收</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210309081832.png" alt="gc"></p><h4 id="String-Table-性能调优"><a href="#String-Table-性能调优" class="headerlink" title="String Table 性能调优"></a>String Table 性能调优</h4><ul><li>jvm参数调优</li></ul><p>主要就是调整 桶 的个数</p><pre><code class="hljs java">-XX:StringTableSize=<span class="hljs-number">1009</span></code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210309082342.png" alt="案例文件"></p><p>存储近48万单词</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210309082519.png" alt="结果"></p><p>最终结果为毫秒</p><p>为什么这么快？</p><p>桶开的个数多 扩大了哈希分布 减少了哈希冲突 更好的效率</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210309082800.png" alt="桶个数"></p><p>缩小桶大小会变慢</p><ul><li><p>考虑将字符串对象是否入池</p><p>intern方法</p></li></ul><p>code: 把单词十遍存入list</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210309084523.png" alt="code"></p><p>运行后jvm显示</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210309084936.png" alt="jvm"></p><p>如果listadd的时候 不用line.intern()</p><p>直接add的话</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210309085031.png" alt="不用intern"></p><p>明显char[]的占用率变高 占用也变高很多</p><h2 id="6、-直接内存"><a href="#6、-直接内存" class="headerlink" title="6、 直接内存"></a>6、 直接内存</h2><p>直接内存并不属于JVM管理，而是属于 <strong>系统内存</strong> </p><p>也就是操作系统的内存</p><p> <strong><em>Direct Memory</em></strong> </p><ul><li>常见于 NIO 操作时，用于数据缓冲区 </li><li>分配回收成本较高，但读写性能高 </li><li>不受 JVM 内存回收管理</li></ul><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 演示 ByteBuffer 作用</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1_9</span> </span>&#123;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String FROM = <span class="hljs-string">&quot;/Users/qiuke/Desktop/test1.mp4&quot;</span>;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String TO = <span class="hljs-string">&quot;/Users/qiuke/Desktop/test2.mp4&quot;</span>;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _1Mb = <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">// 传统io方法</span>        io(); <span class="hljs-comment">// io 用时</span>        directBuffer(); <span class="hljs-comment">// directBuffer 用时：</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">directBuffer</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">long</span> start = System.nanoTime();        <span class="hljs-keyword">try</span> (FileChannel from = <span class="hljs-keyword">new</span> FileInputStream(FROM).getChannel();             FileChannel to = <span class="hljs-keyword">new</span> FileOutputStream(TO).getChannel();        ) &#123;            ByteBuffer bb = ByteBuffer.allocateDirect(_1Mb);            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;                <span class="hljs-keyword">int</span> len = from.read(bb);                <span class="hljs-keyword">if</span> (len == -<span class="hljs-number">1</span>) &#123;                    <span class="hljs-keyword">break</span>;                &#125;                bb.flip();                to.write(bb);                bb.clear();            &#125;        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            e.printStackTrace();        &#125;        <span class="hljs-keyword">long</span> end = System.nanoTime();        System.out.println(<span class="hljs-string">&quot;directBuffer 用时：&quot;</span> + (end - start) / <span class="hljs-number">1000_000.0</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">io</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">long</span> start = System.nanoTime();        <span class="hljs-keyword">try</span> (FileInputStream from = <span class="hljs-keyword">new</span> FileInputStream(FROM);             FileOutputStream to = <span class="hljs-keyword">new</span> FileOutputStream(TO);        ) &#123;            <span class="hljs-keyword">byte</span>[] buf = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[_1Mb];            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;                <span class="hljs-keyword">int</span> len = from.read(buf);                <span class="hljs-keyword">if</span> (len == -<span class="hljs-number">1</span>) &#123;                    <span class="hljs-keyword">break</span>;                &#125;                to.write(buf, <span class="hljs-number">0</span>, len);            &#125;        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            e.printStackTrace();        &#125;        <span class="hljs-keyword">long</span> end = System.nanoTime();        System.out.println(<span class="hljs-string">&quot;io 用时：&quot;</span> + (end - start) / <span class="hljs-number">1000_000.0</span>);    &#125;&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210309090747.png" alt="结果"></p><h3 id="6-1-直接内存的基础使用"><a href="#6-1-直接内存的基础使用" class="headerlink" title="6.1 直接内存的基础使用"></a>6.1 直接内存的基础使用</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210309090918.png" alt="原理"></p><p>java不具备调用磁盘读写的能力，要调用系统函数本地方法才能操控磁盘。</p><p>但由于两块缓冲区，需要读两份，效率低下；</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210316081400.png" alt="direct"></p><pre><code class="hljs java">ByteBuffer bb = ByteBuffer.allocateDirect(_1Mb)</code></pre><p>Direct memory 系统和java代码都能直接访问；</p><h3 id="6-2-直接内存的垃圾回收"><a href="#6-2-直接内存的垃圾回收" class="headerlink" title="6.2 直接内存的垃圾回收"></a>6.2 直接内存的垃圾回收</h3><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 演示直接内存溢出</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1_10</span> </span>&#123;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> _100Mb = <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">100</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        List&lt;ByteBuffer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;                ByteBuffer byteBuffer = ByteBuffer.allocateDirect(_100Mb);                list.add(byteBuffer);                i++;            &#125;        &#125; <span class="hljs-keyword">finally</span> &#123;            System.out.println(i);        &#125;        <span class="hljs-comment">// 方法区是jvm规范， jdk6 中对方法区的实现称为永久代</span>        <span class="hljs-comment">//                  jdk8 对方法区的实现称为元空间</span>    &#125;&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210316081820.png" alt="报错"></p><h3 id="6-3-直接内存的释放原理"><a href="#6-3-直接内存的释放原理" class="headerlink" title="6.3 直接内存的释放原理"></a>6.3 直接内存的释放原理</h3><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 禁用显式回收对直接内存的影响</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1_26</span> </span>&#123;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> _1Gb = <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;    <span class="hljs-comment">/*</span><span class="hljs-comment">     * -XX:+DisableExplicitGC 显式的</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        ByteBuffer byteBuffer = ByteBuffer.allocateDirect(_1Gb);        System.out.println(<span class="hljs-string">&quot;分配完毕...&quot;</span>);        System.in.read();        System.out.println(<span class="hljs-string">&quot;开始释放...&quot;</span>);        byteBuffer = <span class="hljs-keyword">null</span>;        System.gc(); <span class="hljs-comment">// 显式的垃圾回收，Full GC</span>        System.in.read();    &#125;&#125;</code></pre><p>运行后</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210316082205.png" alt="分配"></p><p>敲回车后</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210316082251.png" alt="结束"></p><blockquote><p>为什么这里垃圾回收会直接导致直接内存被回收掉？</p></blockquote><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 直接内存分配的底层原理：Unsafe</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1_27</span> </span>&#123;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> _1Gb = <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        Unsafe unsafe = getUnsafe();        <span class="hljs-comment">// 分配内存 base返回的是直接内存的地址</span>        <span class="hljs-keyword">long</span> base = unsafe.allocateMemory(_1Gb);        unsafe.setMemory(base, _1Gb, (<span class="hljs-keyword">byte</span>) <span class="hljs-number">0</span>);        System.in.read();        <span class="hljs-comment">// 释放内存</span>        unsafe.freeMemory(base);        System.in.read();    &#125;    <span class="hljs-comment">// 反射得到unsafe对象</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Unsafe <span class="hljs-title">getUnsafe</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            Field f = Unsafe.class.getDeclaredField(<span class="hljs-string">&quot;theUnsafe&quot;</span>);            f.setAccessible(<span class="hljs-keyword">true</span>);            Unsafe unsafe = (Unsafe) f.get(<span class="hljs-keyword">null</span>);            <span class="hljs-keyword">return</span> unsafe;        &#125; <span class="hljs-keyword">catch</span> (NoSuchFieldException | IllegalAccessException e) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);        &#125;    &#125;&#125;</code></pre><p>直接内存的释放和分配由unsafe对象管理</p><p>再分析ByteBuffer源码：</p><p>在构造器里就直接构造了一个unsafe对象</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210316083002.png" alt="unsafe"></p><blockquote><p>那直接内存又是如何自动释放的呢？</p></blockquote><ul><li>分配和回收原理<ul><li>使用了 Unsafe 对象完成直接内存的分配回收，并且回收需要主动调用 freeMemory 方法 </li><li>ByteBuffer 的实现类内部，使用了 Cleaner (虚引用)来监测 ByteBuffer 对象，一旦 ByteBuffer 对象被垃圾回收，那么就会由 ReferenceHandler 线程通过 Cleaner 的 clean 方法调 用 freeMemory 来释放直接内存</li></ul></li></ul><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210316083251.png" alt="任务对象"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210316083323.png" alt="任务对象实现的run方法"></p><p>将来还是得调用unsafe的方法释放内存</p><p>Cleaner是一个“虚引用”类型，当关联对象被回收时，回收被关联对象。</p><p>上段的源码中，this是指ByteBuffer对象，还是受到JVM管理的，当ByteBuffer被回收时，触发“虚引用”对象中的clean方法，执行任务对象中的run方法</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210316083629.png" alt="clean"></p><p>并且clean不是在主线程被执行，后台有一个referencehandler线程检测“虚引用”对象，一旦虚引用对象所关联的实际对象被回收，他就会调用虚引用对象的clean方法，执行任务对象的run方法。</p><pre><code class="hljs java">-XX:+DisableExplicitGC 禁用显式的gc</code></pre><p>让System.gc无效，其是一种显示的代码方式的垃圾回收；是一种FullGC，处理时间很长，所以需要优化。</p><p>但会造成直接内存长时间占用；</p><p>所以直接内存使用多时，推荐用unsafe来管理直接内存。</p><h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><h2 id="1、如何判断对象可以回收"><a href="#1、如何判断对象可以回收" class="headerlink" title="1、如何判断对象可以回收"></a>1、如何判断对象可以回收</h2><h3 id="1-1-引用计数法"><a href="#1-1-引用计数法" class="headerlink" title="1.1 引用计数法"></a>1.1 引用计数法</h3><p>只要对象被引用，计数就加一，不再被引用，计数减一；为0的时候回收；</p><p><strong>弊端</strong> ：循环引用</p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210316091521.png" alt="循环引用" style="zoom:50%;" /><p>虽然这两个对象都没在使用，但两个计数都是1，不能被回收；早期python使用该方法。</p><h3 id="1-2-可达性分析算法"><a href="#1-2-可达性分析算法" class="headerlink" title="1.2 可达性分析算法"></a>1.2 可达性分析算法</h3><p>确定 <strong>根对象</strong>  （肯定不能当成垃圾被垃圾回收的对象）</p><ul><li>JVM中的垃圾回收器通过 <strong>可达性分析</strong> 来探索所有存活的对象</li><li>扫描堆中的对象，看能否沿着 <code>GC Root对象</code>为起点的引用链找到该对象，如果<strong>找不到，则表示可以回收</strong></li><li>可以作为 <code>GC Root</code> 的对象<ul><li> <code>虚拟机栈（栈帧中的本地变量表）</code> 中引用的对象。　</li><li>方法区中 <code>类静态属性引用的对象</code> </li><li>方法区中 <code>常量引用的对象</code></li><li>本地方法栈中 <code>JNI（即一般说的Native方法）</code> 引用的对象</li></ul></li></ul><p>可以使用Memory Analyzer(MAT)来判断GC root</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210501162703.png"></p><p>运行：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo2_2</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException, IOException </span>&#123;        List&lt;Object&gt; list1 = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        list1.add(<span class="hljs-string">&quot;a&quot;</span>);        list1.add(<span class="hljs-string">&quot;b&quot;</span>);        System.out.println(<span class="hljs-number">1</span>);        System.in.read();        list1 = <span class="hljs-keyword">null</span>;        System.out.println(<span class="hljs-number">2</span>);        System.in.read();        System.out.println(<span class="hljs-string">&quot;end...&quot;</span>);    &#125;&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210501163707.png"></p><p>第一个快找是list置为空之前：</p><p>让代码执行到2；</p><p>再次获取：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210501163849.png"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210501163955.png"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210501164011.png"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210501164117.png"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210501164549.png"></p><p>第二种：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210501164653.png"></p><p>jmap命令带了live参数，会执行一次垃圾回收，所以找不到new的ArrayList了</p><h3 id="1-3-四种引用"><a href="#1-3-四种引用" class="headerlink" title="1.3 四种引用"></a>1.3 四种引用</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210501164927.png"></p><p>所有的 <code>实线</code> 为强引用</p><ul><li>强引用<ul><li>只有所有 <code>GC Roots 对象</code>  <strong>都不通过</strong> 【强引用】引用该对象，该对象才能被垃圾回收</li></ul></li><li>软引用（SoftReference）<ul><li> <strong>仅有软引用引用</strong> 该对象时，在垃圾回收后，内存仍不足时会再次出发垃圾回收，回收软引用对象</li><li>可以配合 <code>引用队列</code> 来 <strong>释放</strong> 软引用 <strong>自身</strong> </li></ul></li><li>弱引用（WeakReference）<ul><li> <strong>仅有弱引用引用</strong> 该对象时，在垃圾回收时，无论内存是否充足，都会回收弱引用对象</li><li>可以配合 <code>引用队列</code> 来 <strong>释放</strong> 弱引用 <strong>自身</strong> </li></ul></li><li>虚引用（PhantomReference）<ul><li><code>必须配合引用队列使用</code> ，主要配合 ByteBuffer 使用，被引用对象回收时，会将虚引用入队，<br>由 Reference Handler 线程调用虚引用相关方法释放直接内存</li><li>引用的一个体现是 <strong>释放直接内存所分配的内存</strong> ，当引用的对象ByteBuffer被垃圾回收以后，虚引用对象Cleaner就会被放入引用队列中，然后调用Cleaner的clean方法来释放直接内存</li></ul></li><li>终结器引用（FinalReference）<ul><li>无需手动编码，但其 <code>内部配合引用队列使用</code> ，在垃圾回收时，终结器引用入队（被引用对象暂时没有被回收），再由 <code>Finalizer 线程</code> 通过终结器引用找到被引用对象并调用它的 <code>finalize 方法</code> ，第二次 GC 时才能回收被引用对象。</li></ul></li></ul><h4 id="软引用例子"><a href="#软引用例子" class="headerlink" title="软引用例子"></a>软引用例子</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo2_3</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _4MB = <span class="hljs-number">4</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        <span class="hljs-comment">/*List&lt;byte[]&gt; list = new ArrayList&lt;&gt;();</span><span class="hljs-comment">        for (int i = 0; i &lt; 5; i++) &#123;</span><span class="hljs-comment">            list.add(new byte[_4MB]);</span><span class="hljs-comment">        &#125;</span><span class="hljs-comment"></span><span class="hljs-comment">        System.in.read();*/</span>        soft();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">soft</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// list --&gt; SoftReference --&gt; byte[]</span>        List&lt;SoftReference&lt;<span class="hljs-keyword">byte</span>[]&gt;&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;            SoftReference&lt;<span class="hljs-keyword">byte</span>[]&gt; ref = <span class="hljs-keyword">new</span> SoftReference&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[_4MB]);            System.out.println(ref.get());            list.add(ref);            System.out.println(list.size());        &#125;        System.out.println(<span class="hljs-string">&quot;循环结束：&quot;</span> + list.size());        <span class="hljs-keyword">for</span> (SoftReference&lt;<span class="hljs-keyword">byte</span>[]&gt; ref : list) &#123;            System.out.println(ref.get());        &#125;    &#125;&#125;</code></pre><p>一开始method1:</p><p>首先会设置一个堆内存的大小为 20m，然后运行 mehtod1 方法，会抛异常，堆内存不足，因为 mehtod1 中的 list 都是强引用。</p><p>随后修改弱引用：在 list 集合中存放了 软引用对象，当内存不足时，会触发 full gc，将软引用的对象回收。细节如图：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210501170546.png"></p><p>上面的代码中，当软引用引用的对象被回收了，但是软引用还存在，所以，一般软引用需要搭配一个引用队列一起使用。</p><pre><code class="hljs java">List&lt;SoftReference&lt;<span class="hljs-keyword">byte</span>[]&gt;&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<span class="hljs-comment">// 引用队列</span>ReferenceQueue&lt;<span class="hljs-keyword">byte</span>[]&gt; queue = <span class="hljs-keyword">new</span> ReferenceQueue&lt;&gt;();<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;    <span class="hljs-comment">// 关联了引用队列， 当软引用所关联的 byte[]被回收时，软引用自己会加入到 queue 中去</span>    SoftReference&lt;<span class="hljs-keyword">byte</span>[]&gt; ref = <span class="hljs-keyword">new</span> SoftReference&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[_4MB], queue);    System.out.println(ref.get());    list.add(ref);    System.out.println(list.size());&#125;<span class="hljs-comment">// 从队列中获取无用的 软引用对象，并移除</span>Reference&lt;? extends <span class="hljs-keyword">byte</span>[]&gt; poll = queue.poll();<span class="hljs-keyword">while</span>( poll != <span class="hljs-keyword">null</span>) &#123;    list.remove(poll);    poll = queue.poll();&#125;System.out.println(<span class="hljs-string">&quot;===========================&quot;</span>);<span class="hljs-keyword">for</span> (SoftReference&lt;<span class="hljs-keyword">byte</span>[]&gt; reference : list) &#123;    System.out.println(reference.get());&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210501171044.png"></p><p>弱引用例子类似</p><h2 id="2、-垃圾回收算法"><a href="#2、-垃圾回收算法" class="headerlink" title="2、 垃圾回收算法"></a>2、 垃圾回收算法</h2><h3 id="2-1-标记清除"><a href="#2-1-标记清除" class="headerlink" title="2.1 标记清除"></a>2.1 标记清除</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210501173124.png"></p><p> <strong>定义</strong> ：标记清除算法顾名思义，是指在虚拟机执行垃圾回收的过程中，先采用 <code>标记算法</code> 确定可回收对象，然后垃圾收集器根据标识<code>清除</code>相应的内容，给堆内存腾出相应的空间</p><ul><li>这里的腾出内存空间并 <code>不是将内存空间的字节清0</code> ，而是 <strong>记录下这段内存的起始结束地址</strong> ，下次分配内存的时候，会直接 <strong>覆盖</strong> 这段内存</li></ul><p> <strong>缺点</strong> ： <strong>容易产生大量的内存碎片</strong> ，可能 <code>无法满足大对象的内存分配</code> ，一旦导致无法分配对象，那就会导致jvm启动gc，一旦启动gc，我们的应用程序就会暂停，这就导致应用的响应速度变慢</p><h3 id="2-2-标记整理"><a href="#2-2-标记整理" class="headerlink" title="2.2 标记整理"></a>2.2 标记整理</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210501173345.png"></p><p>标记-整理 会将不被GC Root引用的对象回收，清楚其占用的内存空间。然后整理剩余的对象，可以有效避免因内存碎片而导致的问题，但是因为整体需要消耗一定的时间，所以 <code>效率较低</code></p><h3 id="2-3-复制"><a href="#2-3-复制" class="headerlink" title="2.3 复制"></a>2.3 复制</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210501173429.png"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210501173512.png"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210501173520.png"></p><p>将内存分为等大小的两个区域，<code>FROM和TO</code>（TO中为空）。先将被GC Root引用的对象从FROM放入TO中，再回收不被GC Root引用的对象。<code>然后交换FROM和TO</code>。这样也可以避免内存碎片的问题，但是会 <code>占用双倍的内存空间</code>。</p><h2 id="3、分代垃圾回收"><a href="#3、分代垃圾回收" class="headerlink" title="3、分代垃圾回收"></a>3、分代垃圾回收</h2><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210501173654.png"></p><h3 id="3-1-回收流程"><a href="#3-1-回收流程" class="headerlink" title="3.1 回收流程"></a>3.1 回收流程</h3><p>新创建的对象都被放在了 <strong>新生代的伊甸园</strong> 中</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210501174017.png"></p><p>当伊甸园中的内存不足时，就会进行一次垃圾回收，这时的回收叫做 <strong>Minor GC</strong></p><p>Minor GC 会将 <strong>伊甸园和幸存区FROM</strong> 存活的对象 <strong>先</strong> 复制到  <strong>幸存区 TO</strong> 中， 并让其 <strong>寿命加1</strong> ，再 <strong>交换两个幸存区</strong> </p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210501174722.png"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210501174732.png"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210501174751.png"></p><p>再次创建对象，若新生代的伊甸园又满了，则会 <strong>再次触发 Minor GC</strong> （会触发  <strong>stop the world</strong> ， 暂停其他用户线程，只让垃圾回收线程工作），这时不仅会回收伊甸园中的垃圾， <strong>还会回收幸存区中的垃圾</strong> ，再将活跃对象复制到幸存区TO中。回收以后会交换两个幸存区，并让幸存区中的对象 <strong>寿命加1</strong> </p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210501175545.png"></p><p>如果幸存区中的对象的 <strong>寿命超过某个阈值</strong> （最大为15，4bit），就会被 <strong>放入老年代</strong> 中</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210501175125.png"></p><p>如果新生代老年代中的内存都满了，就会先触发Minor GC，再触发 <strong>Full GC</strong> ，扫描 <strong>新生代和老年代中</strong> 所有不再使用的对象并回收 STW</p><h3 id="3-2-VM参数"><a href="#3-2-VM参数" class="headerlink" title="3.2 VM参数"></a>3.2 VM参数</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210501180051.png"></p><h3 id="3-3-GC-分析"><a href="#3-3-GC-分析" class="headerlink" title="3.3 GC 分析"></a>3.3 GC 分析</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210501181000.png"></p><p>当遇到一个<strong>较大的对象</strong>时，就算新生代的<strong>伊甸园</strong>为空，也<strong>无法容纳该对象</strong>时，会将该对象<strong>直接晋升为老年代</strong></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210501181231.png"></p><p>误区：别的线程的OOM不会影响main线程的运行</p><h2 id="4、垃圾回收器"><a href="#4、垃圾回收器" class="headerlink" title="4、垃圾回收器"></a>4、垃圾回收器</h2><h3 id="4-1-相关概念"><a href="#4-1-相关概念" class="headerlink" title="4.1 相关概念"></a>4.1 相关概念</h3><p> <strong>并行收集</strong> ：指多条垃圾收集线程并行工作，但此时 <strong>用户线程仍处于等待状态</strong> 。</p><p> <strong>并发收集</strong> ：指用户线程与垃圾收集线程 <strong>同时工作</strong> （不一定是并行的可能会交替执行）。 <strong>用户程序在继续运行</strong> ，而垃圾收集程序运行在另一个CPU上</p><p> <strong>吞吐量</strong> ：即CPU用于 <strong>运行用户代码的时间</strong> 与CPU <strong>总消耗时间</strong> 的比值（吞吐量 = 运行用户代码时间 / ( 运行用户代码时间 + 垃圾收集时间 )），也就是。例如：虚拟机共运行100分钟，垃圾收集器花掉1分钟，那么吞吐量就是99%</p><h3 id="4-2-串行"><a href="#4-2-串行" class="headerlink" title="4.2 串行"></a>4.2 串行</h3><p>底层是单线程</p><ul><li>单线程</li><li>内存较小，个人电脑（CPU核数较少）</li></ul><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210501182119.png"></p><p> <strong>安全点</strong> ：让其他线程都在这个点停下来，以免垃圾回收时移动对象地址，使得其他线程找不到被移动的对象</p><p>因为是串行的，所以只有一个垃圾回收线程。且在该线程执行回收工作时，其他线程进入 <strong>阻塞</strong> 状态</p><h4 id="Serial-收集器"><a href="#Serial-收集器" class="headerlink" title="Serial 收集器"></a>Serial 收集器</h4><p>Serial收集器是最基本的、发展历史最悠久的收集器</p><p> <strong>特点：</strong> 单线程、简单高效（与其他收集器的单线程相比），采用 <strong>复制算法</strong> 。对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程手机效率。收集器进行垃圾回收时，必须暂停其他所有的工作线程，直到它结束（Stop The World）</p><h4 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a>ParNew 收集器</h4><p>ParNew收集器其实就是Serial收集器的多线程版本</p><p> <strong>特点</strong> ：多线程、ParNew收集器默认开启的收集线程数与CPU的数量相同，在CPU非常多的环境中，可以使用-XX:ParallelGCThreads参数来限制垃圾收集的线程数。和Serial收集器一样存在Stop The World问题</p><h4 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h4><p>Serial Old是Serial收集器的老年代版本</p><p> <strong>特点</strong> ：同样是单线程收集器，采用 <strong>标记-整理算法</strong> </p><h3 id="4-3-吞吐量优先"><a href="#4-3-吞吐量优先" class="headerlink" title="4.3 吞吐量优先"></a>4.3 吞吐量优先</h3><ul><li>多线程</li><li>堆内存较大，多核CPU</li><li> <strong>单位时间内</strong> ，STW（stop the world，停掉其他所有工作线程）时间最短</li><li> <strong>JDK1.8默认使用</strong> 的垃圾回收器</li></ul><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210501183102.png"></p><p>1和4 ：动态调整伊甸园和幸存区比例 和 gc线程大小</p><p>2和3：根据吞吐量目标尝试调整堆大小（1/1+ratio） 和 根据垃圾回收暂停时间目标调整堆大小</p><h4 id="Parallel-Scavenge-收集器"><a href="#Parallel-Scavenge-收集器" class="headerlink" title="Parallel Scavenge 收集器"></a>Parallel Scavenge 收集器</h4><p>与吞吐量关系密切，故也称为吞吐量优先收集器</p><p> <strong>特点</strong> ：属于新生代收集器也是采用 <strong>复制算法</strong> 的收集器（用到了新生代的幸存区），又是并行的多线程收集器（与ParNew收集器类似）</p><p>该收集器的目标是达到一个可控制的吞吐量。还有一个值得关注的点是： <strong>GC自适应调节策略</strong> （与ParNew收集器最重要的一个区别）</p><p> <strong>GC自适应调节策略</strong> ：Parallel Scavenge收集器可设置-XX:+UseAdptiveSizePolicy参数。当开关打开时 <strong>不需要</strong> 手动指定新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX:SurvivorRation）、晋升老年代的对象年龄（-XX:PretenureSizeThreshold）等，虚拟机会根据系统的运行状况收集性能监控信息，动态设置这些参数以提供最优的停顿时间和最高的吞吐量，这种调节方式称为GC的自适应调节策略。</p><p>Parallel Scavenge收集器使用两个参数控制吞吐量：</p><ul><li>XX:MaxGCPauseMillis 控制最大的垃圾收集停顿时间</li><li>XX:GCRatio 直接设置吞吐量的大小</li></ul><h4 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a><strong>Parallel Old 收集器</strong></h4><p>是Parallel Scavenge收集器的老年代版本</p><p><strong>特点</strong>：多线程，采用<strong>标记-整理算法</strong>（老年代没有幸存区）</p><h4 id="响应时间优先"><a href="#响应时间优先" class="headerlink" title="响应时间优先"></a>响应时间优先</h4><ul><li>多线程</li><li>堆内存较大，多核CPU</li><li>尽可能让 <strong>单次STW时间变短</strong> （尽量不影响其他线程运行）</li></ul><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210501183233.png"></p><p>2参数表示并行、并发执行gc线程数（并发一般1/4的并行，比如说1个gc，3个工作）</p><p>3参数因为运行时也可能产生垃圾，所以不能等到内存满了再gc，所以需要预留空间，参数为预留空间数（百分之六十五左右）</p><p>4参数重新标记阶段有可能新生代对象可能会引用老年代对象，所以需要扫描整个堆，这样性能影响大，设置参数可以重新标记前对新生代进行gc一次，再扫描；</p><h4 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h4><p>Concurrent Mark Sweep，一种以获取 <strong>最短回收停顿时间</strong> 为目标的 <strong>老年代</strong> 收集器</p><p> <strong>特点</strong> ：基于 <strong>标记-清除算法</strong> 实现。并发收集、低停顿，但是会产生内存碎片</p><p> <strong>应用场景</strong> ：适用于注重服务的响应速度，希望系统停顿时间最短，给用户带来更好的体验等场景下。如web程序、b/s服务</p><p> <strong>CMS收集器的运行过程分为下列4步：</strong> </p><p> <strong>初始标记</strong> ：标记GC Roots能直接到的对象。速度很快但是 <strong>仍存在Stop The World问题</strong> </p><p> <strong>并发标记</strong> ：进行GC Roots Tracing 的过程，找出存活对象且用户线程可并发执行</p><p> <strong>重新标记</strong> ：为了 <strong>修正并发标记期间</strong> 因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录。仍然存在Stop The World问题</p><p> <strong>并发清除</strong> ：对标记的对象进行清除回收（运行时候也可能产生垃圾，要等到下一次；所以需要预留空间）</p><p>CMS收集器的内存回收过程是与用户线程一起 <strong>并发执行</strong> 的，可以搭配 ParNew 收集器（多线程，新生代，复制算法）与 Serial Old 收集器（单线程，老年代，标记-整理算法）使用。</p><h3 id="4-4-G1"><a href="#4-4-G1" class="headerlink" title="4.4 G1"></a>4.4 G1</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>Garbage First</p><p>2004 论文发布<br>2009 JDK 6u14 体验<br>2012 JDK 7u4 官方支持<br>2017 JDK 9 默认</p><p>JDK 9以后默认使用，而且替代了CMS 收集器，也是并发的</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210501191028.png"></p><p>适用场景：</p><ul><li>同时注重吞吐量和低延迟（响应时间），（Throughput）和（Low latency），默认的暂停目标是 200 ms</li><li>超大堆内存（内存大的），会将堆内存划分为多个<strong>大小相等</strong>的区域 <code>Region</code> </li><li>整体上是 <strong>标记-整理</strong> 算法，两个区域之间是 <strong>复制</strong> 算法</li></ul><p> <strong>相关参数</strong> ：JDK8 并不是默认开启的，所需要参数开启</p><pre><code class="hljs java">-XX:+UseG1GC-XX:G1HeapRegionSize=size <span class="hljs-comment">// 区域大小 1 2 4 8 16.....</span>-XX:MaxGCPauseMillis=time <span class="hljs-comment">// 设置暂停目标</span></code></pre><h4 id="1-垃圾回收阶段"><a href="#1-垃圾回收阶段" class="headerlink" title="1) 垃圾回收阶段"></a>1) 垃圾回收阶段</h4><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210501191227.png" alt="img" style="zoom:50%;" /><p>Young Collection：对<code>新生代</code>垃圾收集<br>Young Collection + Concurrent Mark：如果<code>老年代</code>内存到达一定的阈值了，新生代垃圾收集同时会执行一些并发的<code>标记</code>。<br>Mixed Collection：会对<code>新生代 + 老年代 + 幸存区</code>等进行混合收集，然后收集结束，会<code>重新进入新生代收集</code>。</p><h4 id="2-Young-Collection"><a href="#2-Young-Collection" class="headerlink" title="2) Young Collection"></a>2) Young Collection</h4><p> <strong>分区算法region</strong> </p><p>分代是按对象的生命周期划分，分区则是将堆空间划分连续几个不同小区间，每一个小区间独立回收，可以控制一次回收多少个小区间，方便控制 GC 产生的停顿时间</p><p>E：伊甸园 S：幸存区 O：老年代</p><ul><li><p>会STW</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210502165809.png"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210502165921.png"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210502165845.png"></p></li></ul><h4 id="3-Young-Collection-CM"><a href="#3-Young-Collection-CM" class="headerlink" title="3) Young Collection + CM"></a>3) Young Collection + CM</h4><p>CM指的是并发标记</p><ul><li>在 Young GC 时会 <strong>对 GC Root 进行初始标记</strong>  （标记根对象，并发指的是从根出发找到）</li><li>在老年代 <strong>占用堆内存的比例</strong> 达到阈值时，对进行并发标记 <code>（不会STW）</code>，阈值可以根据用户来进行设定</li></ul><pre><code class="hljs java">XX:InitiatingHeapOccupancyPercent=percent （默认<span class="hljs-number">45</span>%）</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210502170242.png"></p><h4 id="4-Mixed-Collection"><a href="#4-Mixed-Collection" class="headerlink" title="4) Mixed Collection"></a>4) Mixed Collection</h4><p>会对E S O 进行 <strong>全面的回收</strong> </p><ul><li>最终标记 （Remark）会STW</li><li> <strong>拷贝</strong> 存活 （Evacuation）会STW</li></ul><pre><code class="hljs java">-XX:MaxGCPauseMills:xxx 用于指定最长的停顿时间</code></pre><p> <strong>问</strong> ：为什么有的老年代被拷贝了，有的没拷贝？</p><p>因为指定了最大停顿时间，如果对所有老年代都进行回收，耗时可能过高。为了保证时间不超过设定的停顿时间，会 <strong>回收最有价值的老年代</strong> （回收后，能够得到更多内存）</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210502170445.png"></p><h4 id="5-Full-GC"><a href="#5-Full-GC" class="headerlink" title="5) Full GC"></a>5) Full GC</h4><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210502170927.png"></p><p>串行和并行老年代full gc</p><p>CMS和G1在老年代内存不足时（老年代所占内存超过阈值）</p><ul><li>如果垃圾产生速度慢于垃圾回收速度，不会触发Full GC，还是并发地进行清理</li><li>如果垃圾产生速度快于垃圾回收速度，便会触发Full GC</li></ul><h4 id="6-Young-Collection-跨代引用"><a href="#6-Young-Collection-跨代引用" class="headerlink" title="6) Young Collection 跨代引用"></a>6) Young Collection 跨代引用</h4><ul><li><p>新生代回收的 <code>跨代引用</code> （老年代引用新生代）问题</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210502170759.png"></p></li><li><p>卡表与 <code>Remembered Set</code></p><ul><li>Remembered Set 存在于E中，用于保存新生代对象对应的脏卡<ul><li>脏卡：O被划分为多个区域（一个区域512K），如果该区域引用了新生代对象，则该区域被称为脏卡</li></ul></li></ul></li><li><p>在引用变更时通过post-write barried (写屏障) + dirty card queue（脏卡队列）</p></li><li><p>concurrent refinement threads （脏卡更新线程）更新 Remembered Set</p></li></ul><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210502171127.png"></p><h4 id="6-重新标记-Remark"><a href="#6-重新标记-Remark" class="headerlink" title="6) 重新标记 Remark"></a>6) 重新标记 Remark</h4><p>重新标记阶段</p><p>在垃圾回收时，收集器处理对象的过程中</p><ul><li><p>pre-write barrier + satb_mark_queue</p></li><li><p>并发标记时，对象处理状态</p><p>黑色：已被处理，需要保留的 ，与引用在引用他们</p><p>灰色：正在处理中的，最终还有引用，则变黑</p><p>白色：还未处理的，最后有引用的存活，没有则回收</p></li></ul><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210502171930.png"></p><p>但是在 <strong>并发标记过程中</strong> ，有可能A被处理了以后未引用C，但该处理过程还未结束，在处理过程结束之前A引用了C，这时就会用到remark</p><p>过程如下</p><ul><li>之前C未被引用，这时A引用了C(对象引用发生改变)，就会给C加一个写屏障，写屏障的指令会被执行，将C放入一个队列当中，并将C变为 <code>处理中</code> 状态 (灰色)</li></ul><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210502172327.png"></p><ul><li>在 <strong>并发标记</strong> 阶段结束以后，重新标记阶段会STW，然后将放在该队列中的对象 <code>重新处理</code> ，发现有强引用引用它，就会处理它(变黑)</li></ul><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210502172151.png"></p><h4 id="7-JDK-8u20-字符串去重"><a href="#7-JDK-8u20-字符串去重" class="headerlink" title="7) JDK 8u20 字符串去重"></a>7) JDK 8u20 字符串去重</h4><p><code>过程</code> </p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210502172841.png"></p><ul><li>将所有新分配的字符串（底层是char[]）放入一个队列</li><li>当 <code>新生代回收时</code> ，G1并发检查是否有重复的字符串</li><li>如果字符串的值一样，就让他们 <strong>引用同一个字符串对象</strong> </li><li>注意，其与String.intern的区别<ul><li><code>intern</code>关注的是 <code>字符串对象</code></li><li><code>字符串去重</code> 关注的是 <code>char[]</code> </li><li>在JVM内部，使用了 <code>不同的字符串标</code></li></ul></li></ul><p><code>优点与缺点</code> </p><ul><li>节省了大量内存</li><li>新生代回收时间略微增加，导致略微多占用CPU</li></ul><pre><code class="hljs java">-XX:+UseStringDeduplication</code></pre><h4 id="8-JDK-8u40-并发标记类卸载"><a href="#8-JDK-8u40-并发标记类卸载" class="headerlink" title="8) JDK 8u40 并发标记类卸载"></a>8) JDK 8u40 并发标记类卸载</h4><p>在 <code>并发标记阶段结束以后</code> ，就能知道哪些类不再被使用。如果一个 <code>类加载器的所有类都不在使用</code> ，则卸载它所加载的所有类。</p><pre><code class="hljs java">-XX:+ClassUnloadingWithConcurrentMark 默认启用</code></pre><h4 id="9-JDK-8u60-回收巨型对象"><a href="#9-JDK-8u60-回收巨型对象" class="headerlink" title="9) JDK 8u60 回收巨型对象"></a>9) JDK 8u60 回收巨型对象</h4><ul><li>一个对象大于region的一半时，就称为 <code>巨型对象</code></li><li>G1 <strong>不会对巨型对象进行拷贝</strong> </li><li>回收时 <strong>被优先考虑</strong> </li><li>G1会跟踪老年代所有incoming引用，如果老年代incoming引用为0的巨型对象就可以在新生代垃圾回收时处理掉</li></ul><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210502173510.png"></p><h4 id="10-JDK-9-并发标记起始时间的调整"><a href="#10-JDK-9-并发标记起始时间的调整" class="headerlink" title="10) JDK 9 并发标记起始时间的调整"></a>10) JDK 9 并发标记起始时间的调整</h4><ul><li>并发标记必须在堆空间占满前完成( <code>防止跟不上垃圾产生速度</code> )，否则退化为 FulGC</li><li>JDK 9 之前需要使用 -XX:InitiatingHeapOccupancyPercent</li><li>JDK 9 可以动态调整<ul><li>-XX:InitiatingHeapOccupancyPercent 用来设置初始值</li><li>进行数据采样并动态调整</li><li>总会添加一个安全的空挡空间</li></ul></li></ul><h2 id="5、GC调优"><a href="#5、GC调优" class="headerlink" title="5、GC调优"></a>5、GC调优</h2><h3 id="调优领域"><a href="#调优领域" class="headerlink" title="调优领域"></a>调优领域</h3><ul><li>内存</li><li>锁竞争</li><li>CPU占用</li><li>IO</li><li>GC</li></ul><h3 id="确定目标"><a href="#确定目标" class="headerlink" title="确定目标"></a>确定目标</h3><p>低延迟(web)/高吞吐量(科学领域计算)？ 选择合适的GC</p><ul><li>CMS G1 ZGC （低延迟）</li><li>ParallelGC （高吞吐量）</li><li>Zing （超低延迟）</li></ul><h3 id="最快的GC是不发生GC"><a href="#最快的GC是不发生GC" class="headerlink" title="最快的GC是不发生GC"></a>最快的GC是不发生GC</h3><p>首先排除减少因为自身编写的代码而引发的内存问题</p><ul><li>查看Full GC前后的内存占用，考虑以下几个问题<ul><li>数据是不是太多？</li><li>数据表示是否太臃肿<ul><li>对象图</li><li>对象大小</li></ul></li><li>是否存在内存泄漏</li></ul></li></ul><h3 id="新生代调优"><a href="#新生代调优" class="headerlink" title="新生代调优"></a>新生代调优</h3><ul><li><p>新生代的特点</p><ul><li>所有的new操作分配内存都是非常廉价的<ul><li>TLAB thread-local allocation buffer</li><li>每个线程用线程私有的伊甸园区</li></ul></li><li>死亡对象回收零代价</li><li>大部分对象用过即死（朝生夕死）</li><li>MInor GC 所用时间远小于Full GC</li></ul></li><li><p>新生代内存越大越好么？</p><ul><li><p>不是</p><ul><li><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210503165355.png"></li><li>新生代内存太小：频繁触发Minor GC，会STW，会使得吞吐量下降</li><li>新生代内存太大：老年代内存占比有所降低，会更频繁地触发Full GC。而且触发Minor GC时，清理新生代所花费的时间会更长</li></ul></li><li><p>新生代内存设置能容纳 <code>[并发量*(请求-响应)]</code> 的数据为宜</p></li><li><p>晋升阈值配置得当，让长时间存活对象尽快晋升</p></li></ul></li></ul><h3 id="幸存区调优"><a href="#幸存区调优" class="headerlink" title="幸存区调优"></a>幸存区调优</h3><ul><li>幸存区需要能够保存 <strong>当前活跃对象</strong>+<strong>需要晋升的对象</strong></li><li>晋升阈值配置得当，让长时间存活的对象尽快晋升</li></ul><h3 id="老年代调优"><a href="#老年代调优" class="headerlink" title="老年代调优"></a>老年代调优</h3><p>以 CMS 为例</p><ul><li>CMS 的老年代内存越大越好（避免浮动垃圾产生并发失败）</li><li>先尝试不做调优，如果没有 Full GC 那么已经…，否则先尝试调优新生代</li><li>观察发生 Full GC 时老年代内存占用，将老年代内存预设调大 1/4 ~ 1/3<br>-XX:CMSInitiatingOccupancyFraction=percent</li></ul><h3 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h3><ul><li>案例1 Full GC 和 Minor GC频繁<ul><li>可能是新生代太小，增大空间，再让阈值提高</li></ul></li><li>案例2 请求高峰期发生 Full GC，单次暂停时间特别长 （CMS）<ul><li>比较慢的在 <code>重新标记</code> （会扫描整个堆内存），定位重新标记</li><li>在重新标记前把一些新生代的对象回收一下</li></ul></li><li>案例3 老年代充裕情况下，发生 Full GC （CMS jdk1.7）<ul><li>jdk1.8有元空间，以前是永久代</li></ul></li></ul><h1 id="类加载和字节码技术"><a href="#类加载和字节码技术" class="headerlink" title="类加载和字节码技术"></a>类加载和字节码技术</h1><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504100558.png"></p><h2 id="1、类文件结构"><a href="#1、类文件结构" class="headerlink" title="1、类文件结构"></a>1、类文件结构</h2><p>一个简单的 HelloWorld.java</p><pre><code class="hljs java"><span class="hljs-comment">// 二进制字节码（类基本信息，常量池，类方法定义，包含了虚拟机指令）</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorld</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;hello world&quot;</span>);    &#125;&#125;</code></pre><p>执行 <code>javac -parameters -d . HelloWorld.java</code></p><p>parameters会保留方法中参数的名称信息，编译为 HelloWorld.class 后是这个样子的：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504101314.png"></p><p>od -t xC HelloWorld.class </p><p>根据JVM规范， <strong>类文件结构</strong> 如下</p><pre><code class="hljs java">ClassFile&#123;    u4             magic    u2             minor_version;        u2             major_version;        u2             constant_pool_count;     <span class="hljs-comment">// 常量池信息</span>    cp_info        constant_pool[constant_pool_count-<span class="hljs-number">1</span>];        u2             access_flags;    <span class="hljs-comment">// 访问修饰（公共、私有）</span>    u2             this_class;    <span class="hljs-comment">// 包名类名</span>    u2             super_class;   <span class="hljs-comment">// 父类信息</span>    u2             interfaces_count;     <span class="hljs-comment">// 接口信息</span>    u2             interfaces[interfaces_count];       u2             fields_count;    <span class="hljs-comment">// 成员、静态变量信息</span>    field_info     fields[fields_count];       u2             methods_count;    <span class="hljs-comment">// 成员、静态方法信息</span>    method_info    methods[methods_count];        u2             attributes_count;    <span class="hljs-comment">// 附加属性信息</span>    attribute_info attributes[attributes_count];&#125;</code></pre><h3 id="魔数"><a href="#魔数" class="headerlink" title="魔数"></a>魔数</h3><p>u4 magic</p><p>对应字节码文件的0~3个字节</p><p>0000000  <strong>ca fe ba be</strong>  00 00 00 34 00 23 0a 00 06 00 15 09</p><h3 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h3><p>u2 minor_version; 小版本号</p><p>u2 major_version; 主版本号</p><p>0000000 ca fe ba be  <strong>00 00 00 34</strong>  00 23 0a 00 06 00 15 09</p><p>34H = 52，代表JDK8</p><h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504102530.png"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504102543.png"></p><p>具体参考pdf</p><h3 id="访问标识和继承信息"><a href="#访问标识和继承信息" class="headerlink" title="访问标识和继承信息"></a>访问标识和继承信息</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504103232.png"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504103244.png"></p><h3 id="Filed-成员变量"><a href="#Filed-成员变量" class="headerlink" title="Filed 成员变量"></a>Filed 成员变量</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504103500.png"></p><h3 id="Method-信息"><a href="#Method-信息" class="headerlink" title="Method 信息"></a>Method 信息</h3><h4 id="lt-init-gt-函数"><a href="#lt-init-gt-函数" class="headerlink" title="&lt; init &gt; 函数"></a>&lt; init &gt; 函数</h4><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504103811.png"> </p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504103659.png"></p><p>红色具体分类：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504103857.png"></p><h4 id="lt-main-gt-函数"><a href="#lt-main-gt-函数" class="headerlink" title="&lt; main &gt;函数"></a>&lt; main &gt;函数</h4><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504105009.png"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504105036.png"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504105057.png"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504105439.png"></p><h3 id="附加属性"><a href="#附加属性" class="headerlink" title="附加属性"></a>附加属性</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504105516.png"></p><p>参考文献<br><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html</a></p><h2 id="2、字节码指令"><a href="#2、字节码指令" class="headerlink" title="2、字节码指令"></a>2、字节码指令</h2><h3 id="2-1-入门"><a href="#2-1-入门" class="headerlink" title="2.1 入门"></a>2.1 入门</h3><p>接着上一节，研究一下两组字节码指令，一个是<br><code>public cn.itcast.jvm.t5.HelloWorld()</code> ; 构造方法的字节码指令</p><pre><code class="hljs js">2a b7 <span class="hljs-number">00</span> <span class="hljs-number">01</span> b1</code></pre><ol><li><p>2a =&gt; aload_0(this) 加载 slot 0 的局部变量，即 this，做为下面的 invokespecial 构造方法调用的参数</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504105925.png"></p></li><li><p>b7 =&gt; invokespecial 预备调用构造方法，哪个方法呢？</p></li><li><p>00 01 引用常量池中 #1 项，即【 Method java/lang/Object.”&lt; init &gt;”:()V 】</p></li><li><p>b1 表示返回</p></li></ol><p>另一个是 <code>public static void main(java.lang.String[]);</code> 主方法的字节码指令</p><pre><code class="hljs js">b2 <span class="hljs-number">00</span> <span class="hljs-number">02</span> <span class="hljs-number">12</span> <span class="hljs-number">03</span> b6 <span class="hljs-number">00</span> <span class="hljs-number">04</span> b1</code></pre><ol><li>b2 =&gt; getstatic 用来加载静态变量，哪个静态变量呢？</li><li>00 02 引用常量池中 #2 项，即【Field java/lang/System.out:Ljava/io/PrintStream;】</li><li>12 =&gt; ldc 加载参数，哪个参数呢？</li><li>03 引用常量池中 #3 项，即 【String hello world】</li><li>b6 =&gt; invokevirtual 预备调用成员方法，哪个方法呢？</li><li>00 04 引用常量池中 #4 项，即【Method java/io/PrintStream.println:(Ljava/lang/String;)V】</li><li>b1 表示返回</li></ol><p>请参考<br><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5</a></p><h3 id="2-2-javap-工具"><a href="#2-2-javap-工具" class="headerlink" title="2.2 javap 工具"></a>2.2 javap 工具</h3><p>Oracle 提供了 <strong>javap</strong> 工具来反编译 class 文件</p><pre><code class="hljs js">javap -v xxx.class</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504110755.png"></p><p>常量池：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504110837.png"></p><p>方法：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504111014.png"></p><h3 id="2-3-图解方法执行流程"><a href="#2-3-图解方法执行流程" class="headerlink" title="2.3 图解方法执行流程"></a>2.3 图解方法执行流程</h3><h4 id="1-原始java代码"><a href="#1-原始java代码" class="headerlink" title="1) 原始java代码"></a>1) 原始java代码</h4><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 演示 字节码指令 和 操作数栈、常量池的关系</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3_1</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;        <span class="hljs-keyword">int</span> b = Short.MAX_VALUE + <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> c = a + b;        System.out.println(c);    &#125;&#125;</code></pre><h4 id="2-编译后的字节码文件"><a href="#2-编译后的字节码文件" class="headerlink" title="2) 编译后的字节码文件"></a>2) 编译后的字节码文件</h4><pre><code class="hljs java">qiukedeMacBook-Pro-<span class="hljs-number">2</span>:class03 qiuke$ javap -v Demo3_1.class Classfile /Users/qiuke/Desktop/ideaProject/jvm/src/com/qiuke/jvm/class03/Demo3_1.class  Last modified <span class="hljs-number">2021</span>-<span class="hljs-number">5</span>-<span class="hljs-number">4</span>; size <span class="hljs-number">454</span> bytes  MD5 checksum 4d2c98439aed862544493fafae9889f5  Compiled from <span class="hljs-string">&quot;Demo3_1.java&quot;</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">com</span>.<span class="hljs-title">qiuke</span>.<span class="hljs-title">jvm</span>.<span class="hljs-title">class03</span>.<span class="hljs-title">Demo3_1</span></span>  minor version: 0  major version: <span class="hljs-number">52</span>  flags: ACC_PUBLIC, ACC_SUPERConstant pool:   #1 = Methodref          #7.#16         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V   #2 = Class              #17            // java/lang/Short   #3 = Integer            32768   #4 = Fieldref           #18.#19        // java/lang/System.out:Ljava/io/PrintStream;   #5 = Methodref          #20.#21        // java/io/PrintStream.println:(I)V   #6 = Class              #22            // com/qiuke/jvm/class03/Demo3_1   #7 = Class              #23            // java/lang/Object   #8 = Utf8               &lt;init&gt;   #9 = Utf8               ()V  #10 = Utf8               Code  #11 = Utf8               LineNumberTable  #12 = Utf8               main  #13 = Utf8               ([Ljava/lang/String;)V  #14 = Utf8               SourceFile  #15 = Utf8               Demo3_1.java  #16 = NameAndType        #8:#9          // &quot;&lt;init&gt;&quot;:()V  #17 = Utf8               java/lang/Short  #18 = Class              #24            // java/lang/System  #19 = NameAndType        #25:#26        // out:Ljava/io/PrintStream;  #20 = Class              #27            // java/io/PrintStream  #21 = NameAndType        #28:#29        // println:(I)V  #22 = Utf8               com/qiuke/jvm/class03/Demo3_1  #23 = Utf8               java/lang/Object  #24 = Utf8               java/lang/System  #25 = Utf8               out  #26 = Utf8               Ljava/io/PrintStream;  #27 = Utf8               java/io/PrintStream  #28 = Utf8               println  #29 = Utf8               (I)V&#123;  <span class="hljs-keyword">public</span> com.qiuke.jvm.class03.Demo3_1();    descriptor: ()V    flags: ACC_PUBLIC    Code:      stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">1</span>, args_size=<span class="hljs-number">1</span>         <span class="hljs-number">0</span>: aload_0         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V         <span class="hljs-number">4</span>: <span class="hljs-keyword">return</span>      LineNumberTable:        line <span class="hljs-number">6</span>: <span class="hljs-number">0</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(java.lang.String[])</span></span>;    descriptor: ([Ljava/lang/String;)V    flags: ACC_PUBLIC, ACC_STATIC    Code:      stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">4</span>, args_size=<span class="hljs-number">1</span>         <span class="hljs-number">0</span>: bipush        <span class="hljs-number">10</span>         <span class="hljs-number">2</span>: istore_1         3: ldc           #3                  // int 32768         <span class="hljs-number">5</span>: istore_2         <span class="hljs-number">6</span>: iload_1         <span class="hljs-number">7</span>: iload_2         <span class="hljs-number">8</span>: iadd         <span class="hljs-number">9</span>: istore_3        10: getstatic     #4                  // Field java/lang/System.out:Ljava/io/PrintStream;        <span class="hljs-number">13</span>: iload_3        14: invokevirtual #5                  // Method java/io/PrintStream.println:(I)V        <span class="hljs-number">17</span>: <span class="hljs-keyword">return</span>      LineNumberTable:        line <span class="hljs-number">8</span>: <span class="hljs-number">0</span>        line <span class="hljs-number">9</span>: <span class="hljs-number">3</span>        line <span class="hljs-number">10</span>: <span class="hljs-number">6</span>        line <span class="hljs-number">11</span>: <span class="hljs-number">10</span>        line <span class="hljs-number">12</span>: <span class="hljs-number">17</span>&#125;SourceFile: <span class="hljs-string">&quot;Demo3_1.java&quot;</span></code></pre><h4 id="3-常量池加载入运行时常量池"><a href="#3-常量池加载入运行时常量池" class="headerlink" title="3) 常量池加载入运行时常量池"></a>3) 常量池加载入运行时常量池</h4><p>运行时常量池也属于方法区，只不过这里单独提出来了</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504112138.png"></p><p>范围内跟随方法的字节码指令存在一起，一旦超过了数值范围，存储在常量池中。</p><h4 id="4-方法字节码载入方法区"><a href="#4-方法字节码载入方法区" class="headerlink" title="4) 方法字节码载入方法区"></a>4) 方法字节码载入方法区</h4><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504112613.png"></p><h4 id="5-main-线程开始运行，分配栈帧内存"><a href="#5-main-线程开始运行，分配栈帧内存" class="headerlink" title="5) main 线程开始运行，分配栈帧内存"></a>5) main 线程开始运行，分配栈帧内存</h4><p>（stack=2，locals=4） 对应操作数栈有2个空间（每个空间4个字节），局部变量表中有4个槽位</p><p>绿色局部变量表，蓝色操作数栈</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504112539.png"></p><h4 id="6-执行引擎开始执行字节码"><a href="#6-执行引擎开始执行字节码" class="headerlink" title="6) 执行引擎开始执行字节码"></a>6) 执行引擎开始执行字节码</h4><p> <strong>bipush 10</strong> </p><ul><li><p>将一个 <code>byte</code> 压入操作数栈</p><p>（其长度会<code>补齐 4 个字节</code>），类似的指令还有</p><ul><li>sipush 将一个 short 压入操作数栈（其长度会补齐 4 个字节）</li><li>ldc 将一个 int 压入操作数栈</li><li>ldc2_w 将一个 long 压入操作数栈（ <strong>分两次压入</strong> ，因为 long 是 8 个字节）</li><li>这里小的数字都是和字节码指令存在一起， <strong>超过 short 范围的数字存入了常量池</strong> </li></ul></li></ul><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504112934.png"></p><p> <strong>istore 1</strong> </p><p>将<code>操作数栈栈顶元素弹出，放入局部变量表的slot 1</code>中</p><p>对应代码中的</p><pre><code class="hljs java">a = <span class="hljs-number">10</span></code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504113100.png"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504113112.png"></p><p> <strong>ldc #3</strong> </p><ul><li>读取运行时常量池中#3，即32768(超过short最大值范围的数会被放到运行时常量池中)，将其加载到<code>操作数栈中</code></li><li>注意 Short.MAX_VALUE 是 32767，所以 32768 = Short.MAX_VALUE + 1 实际是在编译期间计算好的</li></ul><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504113840.png"></p><p> <strong>istore 2</strong> </p><p>将操作数栈中的元素弹出，放到局部变量表的2号位置</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504113904.png"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504113917.png"></p><p> <strong>iload1 iload2</strong> </p><p>将局部变量表中1号位置和2号位置的元素放入操作数栈中</p><pre><code class="hljs java"><span class="hljs-keyword">int</span> c = a + b</code></pre><ul><li>因为只能在操作数栈中执行运算操作</li></ul><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504114024.png"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504114049.png"></p><p> <strong>iadd</strong> </p><p>将操作数栈中的两个元素 <strong>弹出栈</strong> 并相加，结果在压入操作数栈中</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504114130.png"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504114141.png"></p><p> <strong>istore 3</strong> </p><p>将操作数栈中的元素弹出，放入局部变量表的3号位置</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504114211.png"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504114220.png"></p><p> <strong>getstatic #4</strong> </p><p>在运行时常量池中找到#4，发现是一个对象</p><p>在堆内存中找到该对象，并将其 <strong>引用</strong> 放入操作数栈中</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504114256.png"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504114307.png"></p><p> <strong>iload 3</strong> </p><p>将局部变量表中3号位置的元素压入操作数栈中</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504114343.png"></p><p> <strong>invokevirtual 5</strong> </p><p>找到常量池 #5 项，定位到<code>方法区 java/io/PrintStream.println:(I)V 方法</code></p><p>生成新的栈帧（分配 locals、stack等）</p><p>传递参数，执行新栈帧中的字节码</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504114542.png"></p><p>执行完毕，弹出栈帧</p><p>清除 main 操作数栈内容</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504114628.png"></p><p> <strong>return</strong><br>完成 main 方法调用，弹出 main 栈帧，程序结束</p><h3 id="2-4-分析a"><a href="#2-4-分析a" class="headerlink" title="2.4 分析a++"></a>2.4 分析a++</h3><h4 id="1-代码"><a href="#1-代码" class="headerlink" title="1) 代码"></a>1) 代码</h4><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 从字节码角度分析　a++  相关题目</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3_2</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;        <span class="hljs-keyword">int</span> b = a++ + ++a + a--;        System.out.println(a);        System.out.println(b);    &#125;&#125;</code></pre><h4 id="2-字节码"><a href="#2-字节码" class="headerlink" title="2) 字节码"></a>2) 字节码</h4><pre><code class="hljs java">Code:      stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">1</span>         <span class="hljs-number">0</span>: bipush        <span class="hljs-number">10</span>         <span class="hljs-number">2</span>: istore_1         <span class="hljs-number">3</span>: iload_1         <span class="hljs-number">4</span>: iinc          <span class="hljs-number">1</span>, <span class="hljs-number">1</span>         <span class="hljs-number">7</span>: iinc          <span class="hljs-number">1</span>, <span class="hljs-number">1</span>        <span class="hljs-number">10</span>: iload_1        <span class="hljs-number">11</span>: iadd        <span class="hljs-number">12</span>: iload_1        <span class="hljs-number">13</span>: iinc          <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>        <span class="hljs-number">16</span>: iadd        <span class="hljs-number">17</span>: istore_2        18: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;        <span class="hljs-number">21</span>: iload_1        22: invokevirtual #3                  // Method java/io/PrintStream.println:(I)V        25: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;        <span class="hljs-number">28</span>: iload_2        29: invokevirtual #3                  // Method java/io/PrintStream.println:(I)V        <span class="hljs-number">32</span>: <span class="hljs-keyword">return</span></code></pre><h4 id="3-分析"><a href="#3-分析" class="headerlink" title="3) 分析"></a>3) 分析</h4><ul><li>注意 iinc 指令是直接在局部变量 slot（<code>局部变量槽位</code>） 上进行运算</li><li>a++ 和 ++a 的区别是先执行 iload 还是 先执行 iinc<ul><li>a++ 先load再inc，++a先inc再load</li></ul></li></ul><p>bipush 10</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504115518.png"></p><p>iStore 1</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504115543.png"></p><p>Iload 1</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504115624.png"></p><p>iinc 1, 1 (对哪个槽位自增，自增多少)；直接在局部变量表中发生</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504115639.png"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504115714.png"></p><p>发现a++ 和 ++a分别对应</p><p>iload_1</p><p>iinc 1, 1</p><p>iinc 1, 1</p><p>iload_ 1</p><p>iload_1</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504115947.png"></p><p>iadd</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504120029.png"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504120046.png"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504120103.png"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504120121.png"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504120139.png"></p><h3 id="2-5-条件判断指令"><a href="#2-5-条件判断指令" class="headerlink" title="2.5 条件判断指令"></a>2.5 条件判断指令</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504120438.png"></p><p>几点说明：</p><ul><li>byte，short，char 都会按 int 比较，因为操作数栈都是 4 字节</li><li>goto 用来进行跳转到指定行号的字节码</li></ul><blockquote><p>以上比较指令中没有 long，float，double 的比较，那么它们要比较怎么办？<br>参考 <a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html#jvms-6.5.lcmp">https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html#jvms-6.5.lcmp</a></p></blockquote><h4 id="1-源码"><a href="#1-源码" class="headerlink" title="1) 源码"></a>1) 源码</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3_3</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span>(a == <span class="hljs-number">0</span>) &#123;            a = <span class="hljs-number">10</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            a = <span class="hljs-number">20</span>;        &#125;    &#125;&#125;</code></pre><h4 id="2-字节码-1"><a href="#2-字节码-1" class="headerlink" title="2) 字节码"></a>2) 字节码</h4><pre><code class="hljs java">Code:  stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">2</span>, args_size=<span class="hljs-number">1</span>     <span class="hljs-number">0</span>: iconst_0 <span class="hljs-comment">// -1 至 5 之间的数字用iconst</span>     <span class="hljs-number">1</span>: istore_1     <span class="hljs-number">2</span>: iload_1     <span class="hljs-number">3</span>: ifne          <span class="hljs-number">12</span> <span class="hljs-comment">// ！= 0</span>     <span class="hljs-number">6</span>: bipush        <span class="hljs-number">10</span>     <span class="hljs-number">8</span>: istore_1     <span class="hljs-number">9</span>: goto          <span class="hljs-number">15</span>    <span class="hljs-number">12</span>: bipush        <span class="hljs-number">20</span>    <span class="hljs-number">14</span>: istore_1    <span class="hljs-number">15</span>: <span class="hljs-keyword">return</span></code></pre><h3 id="2-6-循环控制指令"><a href="#2-6-循环控制指令" class="headerlink" title="2.6 循环控制指令"></a>2.6 循环控制指令</h3><h4 id="1-源码-1"><a href="#1-源码-1" class="headerlink" title="1) 源码"></a>1) 源码</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3_4</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (a &lt; <span class="hljs-number">10</span>) &#123;            a++;        &#125;    &#125;&#125;</code></pre><h4 id="2-字节码-2"><a href="#2-字节码-2" class="headerlink" title="2) 字节码"></a>2) 字节码</h4><pre><code class="hljs java">Code:  stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">2</span>, args_size=<span class="hljs-number">1</span>     <span class="hljs-number">0</span>: iconst_0     <span class="hljs-number">1</span>: istore_1     <span class="hljs-number">2</span>: iload_1     <span class="hljs-number">3</span>: bipush        <span class="hljs-number">10</span>     <span class="hljs-number">5</span>: if_icmpge     <span class="hljs-number">14</span>     <span class="hljs-number">8</span>: iinc          <span class="hljs-number">1</span>, <span class="hljs-number">1</span>    <span class="hljs-number">11</span>: goto          <span class="hljs-number">2</span>    <span class="hljs-number">14</span>: <span class="hljs-keyword">return</span></code></pre><p>dowhile:</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504121456.png"></p><p>for</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504121538.png"></p><blockquote><p>注意<br>比较 while 和 for 的字节码，你发现它们是一模一样的，殊途也能同归</p></blockquote><h4 id="3-练习-x-0"><a href="#3-练习-x-0" class="headerlink" title="3) 练习 x= 0"></a>3) 练习 x= 0</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3_6_1</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (i &lt; <span class="hljs-number">10</span>) &#123;            x = x++;            i++;        &#125;        System.out.println(x); <span class="hljs-comment">// 0</span>    &#125;&#125;</code></pre><pre><code class="hljs java">Code:     stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">1</span> <span class="hljs-comment">//操作数栈分配2个空间，局部变量表分配3个空间</span>        <span class="hljs-number">0</span>: iconst_0 <span class="hljs-comment">//准备一个常数0</span>        <span class="hljs-number">1</span>: istore_1 <span class="hljs-comment">//将常数0放入局部变量表的1号槽位 i=0</span>        <span class="hljs-number">2</span>: iconst_0 <span class="hljs-comment">//准备一个常数0</span>        <span class="hljs-number">3</span>: istore_2 <span class="hljs-comment">//将常数0放入局部变量的2号槽位 x=0 </span>        <span class="hljs-number">4</span>: iload_1    <span class="hljs-comment">//将局部变量表1号槽位的数放入操作数栈中</span>        <span class="hljs-number">5</span>: bipush        <span class="hljs-number">10</span> <span class="hljs-comment">//将数字10放入操作数栈中，此时操作数栈中有2个数</span>        <span class="hljs-number">7</span>: if_icmpge     <span class="hljs-number">21</span> <span class="hljs-comment">//比较操作数栈中的两个数，如果下面的数大于上面的数，就跳转到21。这里的比较是将两个数做减法。因为涉及运算操作，所以会将两个数弹出操作数栈来进行运算。运算结束后操作数栈为空</span>       <span class="hljs-number">10</span>: iload_2    <span class="hljs-comment">//将局部变量2号槽位的数放入操作数栈中，放入的值是0</span>       <span class="hljs-number">11</span>: iinc          <span class="hljs-number">2</span>, <span class="hljs-number">1</span> <span class="hljs-comment">//将局部变量2号槽位的数加1，自增后，槽位中的值为1</span>       <span class="hljs-number">14</span>: istore_2 <span class="hljs-comment">//将操作数栈中的数放入到局部变量表的2号槽位，2号槽位的值又变为了0</span>       <span class="hljs-number">15</span>: iinc          <span class="hljs-number">1</span>, <span class="hljs-number">1</span> <span class="hljs-comment">//1号槽位的值自增1</span>       <span class="hljs-number">18</span>: goto          <span class="hljs-number">4</span> <span class="hljs-comment">//跳转到第4条指令</span>       21: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;       <span class="hljs-number">24</span>: iload_2       25: invokevirtual #3                  // Method java/io/PrintStream.println:(I)V       <span class="hljs-number">28</span>: <span class="hljs-keyword">return</span></code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504122713.png"></p><p>x值先放到操作数栈是0，x在局部变量表自增变成1，但是又把操作数栈的0赋值给了局部变量x，循环完了还是0</p><h3 id="2-7-构造方法"><a href="#2-7-构造方法" class="headerlink" title="2.7 构造方法"></a>2.7 构造方法</h3><h4 id="1-lt-cinit-gt-V"><a href="#1-lt-cinit-gt-V" class="headerlink" title="1. &lt; cinit &gt;()V"></a>1. &lt; cinit &gt;()V</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3_8_1</span> </span>&#123;        <span class="hljs-keyword">static</span> &#123;        i = <span class="hljs-number">20</span>;    &#125;     <span class="hljs-keyword">static</span> &#123;        i = <span class="hljs-number">30</span>;        <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        System.out.println(Demo3_8_1.i);    &#125;&#125;</code></pre><p>编译器会按<code>从上至下的顺序</code>，收集所有 static 静态代码块和静态成员赋值的代码，合并为一个特殊的方<br>法 &lt; cinit &gt;()V ：</p><pre><code class="hljs java">Code:  stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">0</span>, args_size=<span class="hljs-number">0</span>     <span class="hljs-number">0</span>: bipush        <span class="hljs-number">20</span>     2: putstatic     #3                  // Field i:I     <span class="hljs-number">5</span>: bipush        <span class="hljs-number">30</span>     7: putstatic     #3                  // Field i:I    <span class="hljs-number">10</span>: bipush        <span class="hljs-number">10</span>    12: putstatic     #3                  // Field i:I    <span class="hljs-number">15</span>: <span class="hljs-keyword">return</span></code></pre><p>&lt; cinit &gt;()V 方法会在类加载的初始化阶段被调用</p><h4 id="2-lt-init-gt-V"><a href="#2-lt-init-gt-V" class="headerlink" title="2. &lt; init &gt;()V"></a>2. &lt; init &gt;()V</h4><p>编译器会按 <strong>从上至下</strong> 的顺序，收集所有 {} 代码块和成员变量赋值的代码，  <strong>形成新的构造方法</strong>  ，但  <strong>原始构造方法</strong>  内的代码 <strong>总是在后</strong> </p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3_8_2</span> </span>&#123;    <span class="hljs-keyword">private</span> String a = <span class="hljs-string">&quot;s1&quot;</span>;    &#123;        b = <span class="hljs-number">20</span>;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> b = <span class="hljs-number">10</span>;    &#123;        a = <span class="hljs-string">&quot;s2&quot;</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Demo3_8_2</span><span class="hljs-params">(String a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;        <span class="hljs-keyword">this</span>.a = a;        <span class="hljs-keyword">this</span>.b = b;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Demo3_8_2 d = <span class="hljs-keyword">new</span> Demo3_8_2(<span class="hljs-string">&quot;s3&quot;</span>, <span class="hljs-number">30</span>);        System.out.println(d.a);        System.out.println(d.b);    &#125;&#125;</code></pre><pre><code class="hljs ruby">s3<span class="hljs-number">30</span></code></pre><p>生成新的构造，给a赋值s1，给b赋值20，给b赋值10，给a赋值s2，最后执行构造方法this.a = a….</p><pre><code class="hljs java">Code:     stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">3</span>        <span class="hljs-number">0</span>: aload_0        1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V        <span class="hljs-number">4</span>: aload_0        5: ldc           #2                  // String s1        7: putfield      #3                  // Field a:Ljava/lang/String;       <span class="hljs-number">10</span>: aload_0       <span class="hljs-number">11</span>: bipush        <span class="hljs-number">20</span>       13: putfield      #4                  // Field b:I       <span class="hljs-number">16</span>: aload_0       <span class="hljs-number">17</span>: bipush        <span class="hljs-number">10</span>       19: putfield      #4                  // Field b:I       <span class="hljs-number">22</span>: aload_0       23: ldc           #5                  // String s2       25: putfield      #3                  // Field a:Ljava/lang/String;       <span class="hljs-comment">//原始构造方法在最后执行</span>       <span class="hljs-number">28</span>: aload_0       <span class="hljs-number">29</span>: aload_1       30: putfield      #3                  // Field a:Ljava/lang/String;       <span class="hljs-number">33</span>: aload_0       <span class="hljs-number">34</span>: iload_2       35: putfield      #4                  // Field b:I       <span class="hljs-number">38</span>: <span class="hljs-keyword">return</span></code></pre><h3 id="2-8-方法调用"><a href="#2-8-方法调用" class="headerlink" title="2.8 方法调用"></a>2.8 方法调用</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo5</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Demo5</span><span class="hljs-params">()</span> </span>&#123;&#125;  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;&#125;  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> </span>&#123;&#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span> </span>&#123;&#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test4</span><span class="hljs-params">()</span> </span>&#123;&#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    Demo5 demo5 = <span class="hljs-keyword">new</span> Demo5();    demo5.test1();    demo5.test2();    demo5.test3();    Demo5.test4();  &#125;&#125;</code></pre><p>不同方法在调用时，对应的虚拟机指令有所区别</p><pre><code class="hljs java">Code:     stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">2</span>, args_size=<span class="hljs-number">1</span>        0: new           #2                  // class com/qiuke/jvm/class03/Demo3_9        <span class="hljs-number">3</span>: dup        4: invokespecial #3                  // Method &quot;&lt;init&gt;&quot;:()V        <span class="hljs-number">7</span>: astore_1        <span class="hljs-number">8</span>: aload_1        9: invokespecial #4                  // Method test1:()V       <span class="hljs-number">12</span>: aload_1       13: invokespecial #5                  // Method test2:()V       <span class="hljs-number">16</span>: aload_1       17: invokevirtual #6                  // Method test3:()V       <span class="hljs-number">20</span>: aload_1       <span class="hljs-number">21</span>: pop       22: invokestatic  #7                  // Method test4:()V       25: invokestatic  #7                  // Method test4:()V       <span class="hljs-number">28</span>: <span class="hljs-keyword">return</span></code></pre><ul><li>new 是 <strong>创建【对象】</strong> ，给对象分配堆内存，执行成功会将【对象引用】压入操作数栈</li><li>dup 是赋值操作数栈栈顶的内容，本例即为【对象引用】，为什么需要两份引用呢，一个是要配<br>合 invokespecial 调用该对象的构造方法 “&lt; init &gt;”:()V （会消耗掉栈顶一个引用），另一个要<br>配合 astore_1 赋值给局部变量</li><li>最终方法（final），私有方法（private），构造方法都是由 <code>invokespecial</code> 指令来调用，属于<code>静 态绑定</code>，在字节码指令生成的时候就知道如何找到哪个类的哪个方法<ul><li>普通成员方法是由 <code>invokevirtual</code> 调用，属于<code>动态绑定，即支持多态</code></li></ul></li><li>成员方法与静态方法调用的另一个区别是，执行方法前<code>是否需要【对象引用】</code></li><li>比较有意思的是 d.test4(); 是通过【对象引用】调用一个静态方法，可以看到在调用<br><code>invokestatic</code> 之前<code>执行了 pop 指令，把【对象引用】从操作数栈弹掉了</code></li><li>还有一个执行 invokespecial 的情况是<code>通过 super 调用父类方法</code></li></ul><h3 id="2-9-多态原理"><a href="#2-9-多态原理" class="headerlink" title="2.9 多态原理"></a>2.9 多态原理</h3><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 演示多态原理，注意加上下面的 JVM 参数，禁用指针压缩</span><span class="hljs-comment"> * -XX:-UseCompressedOops -XX:-UseCompressedClassPointers</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3_10</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(Animal animal)</span> </span>&#123;        animal.eat();        System.out.println(animal.toString());    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        test(<span class="hljs-keyword">new</span> Cat());        test(<span class="hljs-keyword">new</span> Dog());        System.in.read();    &#125;&#125;<span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;我是&quot;</span> + <span class="hljs-keyword">this</span>.getClass().getSimpleName();    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;啃骨头&quot;</span>);    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;吃鱼&quot;</span>);    &#125;&#125;</code></pre><h4 id="1-运行代码"><a href="#1-运行代码" class="headerlink" title="1) 运行代码"></a>1) 运行代码</h4><p>停在 System.in.read() 方法上，这时运行 jps 获取进程 id</p><h4 id="2-运行HSDB工具"><a href="#2-运行HSDB工具" class="headerlink" title="2) 运行HSDB工具"></a>2) 运行HSDB工具</h4><p>进入 JDK 安装目录，执行</p><pre><code class="hljs js">java -cp ./lib/sa-jdi.jar sun.jvm.hotspot.HSDB</code></pre><p>进入图形界面 attach 进程 id</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504130417.png"></p><h4 id="3-查找"><a href="#3-查找" class="headerlink" title="3) 查找"></a>3) 查找</h4><p>打开 Tools -&gt; Find Object By Query</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504130501.png"></p><p>输入 <code>select d from cn.itcast.jvm.t3.bytecode.Dog d</code> 点击 <code>Execute</code> 执行</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504130602.png"></p><h4 id="4）查看对象内存结构"><a href="#4）查看对象内存结构" class="headerlink" title="4）查看对象内存结构"></a>4）查看对象内存结构</h4><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504130748.png"></p><p>点击超链接可以看到对象的内存结构，此对象没有任何属性，因此只有对象头的 16 字节，前 8 字节是<br>MarkWord，后 8 字节就是对象的 Class 指针<br>但目前看不到它的实际地址</p><p>可以通过 Windows -&gt; Console 进入命令行模式，执行</p><pre><code class="hljs js">mem <span class="hljs-number">0x00000001299b4978</span> <span class="hljs-number">2</span></code></pre><p>mem 有两个参数，参数 1 是对象地址，参数 2 是查看 2 行（即 16 字节）<br>结果中第二行 0x000000001b7d4028 即为 Class 的内存地址</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504131204.png"></p><p>再次打开inspector输入内存地址</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504131514.png"></p><h4 id="5-查看类的-vtable"><a href="#5-查看类的-vtable" class="headerlink" title="5) 查看类的 vtable"></a>5) 查看类的 vtable</h4><p>找虚方法表vtable：</p><p>内存地址 + 1B8就是vtable位置</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504132151.png"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504132217.png"></p><p>Tools -&gt; Class Browser 输入 Dog 查找，可以得到相同的结果</p><p>无论通过哪种方法，都可以找到 Dog Class 的 vtable 长度为 6，意思就是 Dog 类有 6 个虚方法（多态<br>相关的，final，static 不会列入）<br>那么这 6 个方法都是谁呢？从 Class 的起始地址开始算，偏移 0x1b8 就是 vtable 的起始地址，进行计<br>算得到：</p><pre><code class="hljs js">mem <span class="hljs-number">0x000000001b7d41e0</span> <span class="hljs-number">6</span><span class="hljs-number">0x000000001b7d41e0</span>: <span class="hljs-number">0x000000001b3d1b10</span><span class="hljs-number">0x000000001b7d41e8</span>: <span class="hljs-number">0x000000001b3d15e8</span><span class="hljs-number">0x000000001b7d41f0</span>: <span class="hljs-number">0x000000001b7d35e8</span><span class="hljs-number">0x000000001b7d41f8</span>: <span class="hljs-number">0x000000001b3d1540</span><span class="hljs-number">0x000000001b7d4200</span>: <span class="hljs-number">0x000000001b3d1678</span><span class="hljs-number">0x000000001b7d4208</span>: <span class="hljs-number">0x000000001b7d3fa8</span></code></pre><h4 id="6-验证方法地址"><a href="#6-验证方法地址" class="headerlink" title="6) 验证方法地址"></a>6) 验证方法地址</h4><p>通过 Tools -&gt; Class Browser 查看每个类的方法定义，比较可知</p><pre><code class="hljs js">Dog - public <span class="hljs-keyword">void</span> eat() @<span class="hljs-number">0x000000001b7d3fa8</span>Animal - public java.lang.String toString() @<span class="hljs-number">0x000000001b7d35e8</span>;<span class="hljs-built_in">Object</span> - protected <span class="hljs-keyword">void</span> finalize() @<span class="hljs-number">0x000000001b3d1b10</span>;<span class="hljs-built_in">Object</span> - public boolean equals(java.lang.Object) @<span class="hljs-number">0x000000001b3d15e8</span>;<span class="hljs-built_in">Object</span> - public native int hashCode() @<span class="hljs-number">0x000000001b3d1540</span>;<span class="hljs-built_in">Object</span> - protected native java.lang.Object clone() @<span class="hljs-number">0x000000001b3d1678</span>;</code></pre><p>发现：</p><p>eat() 方法是 Dog 类自己的</p><p>对比Animal类：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504133348.png"></p><p>对比Object类</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504133437.png"></p><h4 id="7-小结"><a href="#7-小结" class="headerlink" title="7) 小结"></a>7) 小结</h4><p>因为普通成员方法需要在运行时才能确定具体的内容，所以虚拟机需要调用 <strong>invokevirtual</strong> 指令</p><p>在执行invokevirtual指令时，经历了以下几个步骤</p><ul><li>先通过栈帧中对象的引用找到对象</li><li>分析对象头，找到对象实际的Class</li><li>Class结构中有 <strong>vtable</strong> </li><li>查询vtable找到方法的具体地址</li><li>执行方法的字节码</li></ul><h3 id="2-10-异常处理"><a href="#2-10-异常处理" class="headerlink" title="2.10 异常处理"></a>2.10 异常处理</h3><h4 id="1-try-catch"><a href="#1-try-catch" class="headerlink" title="1) try-catch"></a>1) try-catch</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3_11_1</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;        <span class="hljs-keyword">try</span> &#123;            i = <span class="hljs-number">10</span>;        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            i = <span class="hljs-number">20</span>;        &#125;    &#125;&#125;</code></pre><p>对应字节码：</p><pre><code class="hljs java">Code:     stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">1</span>        <span class="hljs-number">0</span>: iconst_0        <span class="hljs-number">1</span>: istore_1        <span class="hljs-number">2</span>: bipush        <span class="hljs-number">10</span>        <span class="hljs-number">4</span>: istore_1        <span class="hljs-number">5</span>: goto          <span class="hljs-number">12</span>        <span class="hljs-number">8</span>: astore_2        <span class="hljs-number">9</span>: bipush        <span class="hljs-number">20</span>       <span class="hljs-number">11</span>: istore_1       <span class="hljs-number">12</span>: <span class="hljs-keyword">return</span>     <span class="hljs-comment">//多出来一个异常表</span>     Exception table:        from    to  target type            <span class="hljs-number">2</span>     <span class="hljs-number">5</span>     <span class="hljs-number">8</span>   Class java/lang/Exception <span class="hljs-comment">// 检测[2, 5) 行代码</span></code></pre><ul><li>可以看到多出来一个<code> Exception table</code> 的结构，[from, to) 是 <strong>前闭后开</strong> （也就是检测2~4行）的检测范围，一旦这个范围内的字节码执行出现异常，则通过 <code>type 匹配异常类型</code>，如果一致，进入 target 所指示行号</li><li>8行的字节码指令 astore_2 是将异常对象引用存入局部变量表的2号位置（为e）</li></ul><h4 id="2-多个catch块"><a href="#2-多个catch块" class="headerlink" title="2) 多个catch块"></a>2) 多个catch块</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3_11_2</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;        <span class="hljs-keyword">try</span> &#123;            i = <span class="hljs-number">10</span>;        &#125; <span class="hljs-keyword">catch</span> (ArithmeticException e) &#123;            i = <span class="hljs-number">30</span>;        &#125; <span class="hljs-keyword">catch</span> (NullPointerException e) &#123;            i = <span class="hljs-number">40</span>;        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            i = <span class="hljs-number">50</span>;        &#125;    &#125;&#125;</code></pre><p>字节码：</p><pre><code class="hljs java">Code:  stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">1</span>     <span class="hljs-number">0</span>: iconst_0     <span class="hljs-number">1</span>: istore_1     <span class="hljs-number">2</span>: bipush        <span class="hljs-number">10</span>     <span class="hljs-number">4</span>: istore_1     <span class="hljs-number">5</span>: goto          <span class="hljs-number">26</span>     <span class="hljs-number">8</span>: astore_2     <span class="hljs-number">9</span>: bipush        <span class="hljs-number">30</span>    <span class="hljs-number">11</span>: istore_1    <span class="hljs-number">12</span>: goto          <span class="hljs-number">26</span>    <span class="hljs-number">15</span>: astore_2    <span class="hljs-number">16</span>: bipush        <span class="hljs-number">40</span>    <span class="hljs-number">18</span>: istore_1    <span class="hljs-number">19</span>: goto          <span class="hljs-number">26</span>    <span class="hljs-number">22</span>: astore_2    <span class="hljs-number">23</span>: bipush        <span class="hljs-number">50</span>    <span class="hljs-number">25</span>: istore_1    <span class="hljs-number">26</span>: <span class="hljs-keyword">return</span>  Exception table:     from    to  target type         <span class="hljs-number">2</span>     <span class="hljs-number">5</span>     <span class="hljs-number">8</span>   Class java/lang/ArithmeticException         <span class="hljs-number">2</span>     <span class="hljs-number">5</span>    <span class="hljs-number">15</span>   Class java/lang/NullPointerException         <span class="hljs-number">2</span>     <span class="hljs-number">5</span>    <span class="hljs-number">22</span>   Class java/lang/Exception</code></pre><ul><li>因为异常出现时， <strong>只能进入</strong>  Exception table 中 <strong>一个分支</strong> ，所以局部变量表 slot 2 位置 <strong>被共用</strong> </li></ul><h4 id="3-multicatch"><a href="#3-multicatch" class="headerlink" title="3) multicatch"></a>3) multicatch</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3_11_3</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            Method test = Demo3_11_3.class.getMethod(<span class="hljs-string">&quot;test&quot;</span>);            test.invoke(<span class="hljs-keyword">null</span>);        &#125; <span class="hljs-keyword">catch</span> (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) &#123;            e.printStackTrace();        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;ok&quot;</span>);    &#125;&#125;</code></pre><p>字节码：</p><pre><code class="hljs java">Code:  stack=<span class="hljs-number">3</span>, locals=<span class="hljs-number">2</span>, args_size=<span class="hljs-number">1</span>     0: ldc           #2                  // class com/qiuke/jvm/class03/Demo3_11_3     2: ldc           #3                  // String test     <span class="hljs-number">4</span>: iconst_0     5: anewarray     #4                  // class java/lang/Class     8: invokevirtual #5                  // Method java/lang/Class.getMethod:(Ljava/lang/String;[Ljava/lang/Class;)Ljava/lang/reflect/Method;    <span class="hljs-number">11</span>: astore_1    <span class="hljs-number">12</span>: aload_1    <span class="hljs-number">13</span>: aconst_null    <span class="hljs-number">14</span>: iconst_0    15: anewarray     #6                  // class java/lang/Object    18: invokevirtual #7                  // Method java/lang/reflect/Method.invoke:(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;    <span class="hljs-number">21</span>: pop    <span class="hljs-number">22</span>: goto          <span class="hljs-number">30</span>    <span class="hljs-number">25</span>: astore_1    <span class="hljs-number">26</span>: aload_1    27: invokevirtual #11                 // Method java/lang/ReflectiveOperationException.printStackTrace:()V    <span class="hljs-number">30</span>: <span class="hljs-keyword">return</span>  Exception table:     from    to  target type         <span class="hljs-number">0</span>    <span class="hljs-number">22</span>    <span class="hljs-number">25</span>   Class java/lang/NoSuchMethodException         <span class="hljs-number">0</span>    <span class="hljs-number">22</span>    <span class="hljs-number">25</span>   Class java/lang/IllegalAccessException         <span class="hljs-number">0</span>    <span class="hljs-number">22</span>    <span class="hljs-number">25</span>   Class java/lang/reflect/InvocationTargetException</code></pre><h4 id="4-finally"><a href="#4-finally" class="headerlink" title="4) finally"></a>4) finally</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3_11_4</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;        <span class="hljs-keyword">try</span> &#123;            i = <span class="hljs-number">10</span>;        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            i = <span class="hljs-number">20</span>;        &#125; <span class="hljs-keyword">finally</span> &#123;            i = <span class="hljs-number">30</span>;        &#125;    &#125;&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504135807.png"></p><p>可以看到 ﬁnally 中的代码被 <strong>复制了 3 份</strong> ，分别放入 <code>try 流程，catch 流程以及 catch剩余的异常类型</code>流程</p><p> <strong>注意</strong> ：虽然从字节码指令看来，每个块中都有finally块，但是finally块中的代码 <strong>只会被执行一次</strong> </p><h4 id="5-finally面试题"><a href="#5-finally面试题" class="headerlink" title="5) finally面试题"></a>5) finally面试题</h4><h5 id="1-finally中的return"><a href="#1-finally中的return" class="headerlink" title="1. finally中的return"></a>1. finally中的return</h5><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    <span class="hljs-keyword">int</span> i = Demo3.test();        <span class="hljs-comment">//结果为20</span>    System.out.println(i);  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> i;    <span class="hljs-keyword">try</span> &#123;      i = <span class="hljs-number">10</span>;      <span class="hljs-keyword">return</span> i;    &#125; <span class="hljs-keyword">finally</span> &#123;      i = <span class="hljs-number">20</span>;      <span class="hljs-keyword">return</span> i;    &#125;  &#125;&#125;</code></pre><p>对应字节码</p><pre><code class="hljs java">Code:     stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">0</span>        <span class="hljs-number">0</span>: bipush        <span class="hljs-number">10</span>        <span class="hljs-number">2</span>: istore_0        <span class="hljs-number">3</span>: iload_0        <span class="hljs-number">4</span>: istore_1  <span class="hljs-comment">//暂存返回值</span>        <span class="hljs-number">5</span>: bipush        <span class="hljs-number">20</span>        <span class="hljs-number">7</span>: istore_0        <span class="hljs-number">8</span>: iload_0        <span class="hljs-number">9</span>: ireturn  <span class="hljs-comment">//ireturn会返回操作数栈顶的整型值20</span>       <span class="hljs-comment">//如果出现异常，还是会执行finally块中的内容，没有抛出异常</span>       <span class="hljs-number">10</span>: astore_2       <span class="hljs-number">11</span>: bipush        <span class="hljs-number">20</span>       <span class="hljs-number">13</span>: istore_0       <span class="hljs-number">14</span>: iload_0       <span class="hljs-number">15</span>: ireturn  <span class="hljs-comment">//这里没有athrow了，也就是如果在finally块中如果有返回操作的话，且try块中出现异常，会吞掉异常！</span>     Exception table:        from    to  target type            <span class="hljs-number">0</span>     <span class="hljs-number">5</span>    <span class="hljs-number">10</span>   any</code></pre><ul><li>由于 ﬁnally 中的 <strong>ireturn</strong> 被插入了所有可能的流程，因此返回结果肯定以ﬁnally的为准</li><li>至于字节码中第 2 行，似乎没啥用，且留个伏笔，看下个例子</li><li>跟上例中的 ﬁnally 相比，发现 <strong>没有 athrow 了</strong> ，这告诉我们：如果在 ﬁnally 中出现了 return，会 <strong>吞掉异常</strong> </li><li>所以 <strong>不要在finally中进行返回操作</strong> </li></ul><h5 id="2-finally中出现异常但有return"><a href="#2-finally中出现异常但有return" class="headerlink" title="2. finally中出现异常但有return"></a>2. finally中出现异常但有return</h5><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      <span class="hljs-keyword">int</span> i = Demo3.test();      <span class="hljs-comment">//最终结果为20</span>      System.out.println(i);   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">int</span> i;      <span class="hljs-keyword">try</span> &#123;         i = <span class="hljs-number">10</span>;         <span class="hljs-comment">//这里应该会抛出异常</span>         i = i/<span class="hljs-number">0</span>;         <span class="hljs-keyword">return</span> i;      &#125; <span class="hljs-keyword">finally</span> &#123;         i = <span class="hljs-number">20</span>;         <span class="hljs-keyword">return</span> i;      &#125;   &#125;&#125;</code></pre><p>会发现打印结果为20，并未抛出异常</p><h5 id="3-finally-return的影响"><a href="#3-finally-return的影响" class="headerlink" title="3. finally return的影响"></a>3. finally return的影响</h5><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo4</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    <span class="hljs-keyword">int</span> i = Demo4.test();    System.out.println(i); <span class="hljs-comment">// 10</span>  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span>;    <span class="hljs-keyword">try</span> &#123;      <span class="hljs-keyword">return</span> i;    &#125; <span class="hljs-keyword">finally</span> &#123;      i = <span class="hljs-number">20</span>;    &#125;  &#125;&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504151738.png"></p><p>原来就是把要返回的值先保存到局部变量中，返回前再load到栈中返回</p><h3 id="2-11-synchronized"><a href="#2-11-synchronized" class="headerlink" title="2.11 synchronized"></a>2.11 synchronized</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo5</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    <span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span>;    Lock lock = <span class="hljs-keyword">new</span> Lock();    <span class="hljs-keyword">synchronized</span> (lock) &#123;      System.out.println(i);    &#125;  &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Lock</span></span>&#123;&#125;</code></pre><pre><code class="hljs java">Code:     stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">5</span>, args_size=<span class="hljs-number">1</span>        <span class="hljs-number">0</span>: bipush        <span class="hljs-number">10</span>        <span class="hljs-number">2</span>: istore_1        3: new           #2                  // class com/nyima/JVM/day06/Lock        <span class="hljs-number">6</span>: dup <span class="hljs-comment">//复制一份，放到操作数栈顶，用于构造函数消耗</span>        7: invokespecial #3                  // Method com/nyima/JVM/day06/Lock.&quot;&lt;init&gt;&quot;:()V       <span class="hljs-number">10</span>: astore_2 <span class="hljs-comment">//剩下的一份放到局部变量表的2号位置</span>       <span class="hljs-number">11</span>: aload_2 <span class="hljs-comment">//加载到操作数栈</span>       <span class="hljs-number">12</span>: dup <span class="hljs-comment">//复制一份，放到操作数栈，用于加锁时消耗</span>       <span class="hljs-number">13</span>: astore_3 <span class="hljs-comment">//将操作数栈顶元素弹出，暂存到局部变量表的三号槽位。这时操作数栈中有一份对象的引用</span>       <span class="hljs-number">14</span>: monitorenter <span class="hljs-comment">//加锁</span>       <span class="hljs-comment">//锁住后代码块中的操作    </span>       15: getstatic     #4                  // Field java/lang/System.out:Ljava/io/PrintStream;       <span class="hljs-number">18</span>: iload_1       19: invokevirtual #5                  // Method java/io/PrintStream.println:(I)V       <span class="hljs-comment">//加载局部变量表中三号槽位对象的引用，用于解锁    </span>       <span class="hljs-number">22</span>: aload_3           <span class="hljs-number">23</span>: monitorexit <span class="hljs-comment">//解锁</span>       <span class="hljs-number">24</span>: goto          <span class="hljs-number">34</span>       <span class="hljs-comment">//异常操作    </span>       <span class="hljs-number">27</span>: astore        <span class="hljs-number">4</span>       <span class="hljs-number">29</span>: aload_3       <span class="hljs-number">30</span>: monitorexit <span class="hljs-comment">//解锁</span>       <span class="hljs-number">31</span>: aload         <span class="hljs-number">4</span>       <span class="hljs-number">33</span>: athrow       <span class="hljs-number">34</span>: <span class="hljs-keyword">return</span>     <span class="hljs-comment">//可以看出，无论何时出现异常，都会跳转到27行，将异常放入局部变量中，并进行解锁操作，然后加载异常并抛出异常。      </span>     Exception table:        from    to  target type           <span class="hljs-number">15</span>    <span class="hljs-number">24</span>    <span class="hljs-number">27</span>   any           <span class="hljs-number">27</span>    <span class="hljs-number">31</span>    <span class="hljs-number">27</span>   any</code></pre><p>如果是：</p><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    Object lock = <span class="hljs-keyword">new</span> Object();    <span class="hljs-keyword">synchronized</span> (lock) &#123;        System.out.println(<span class="hljs-string">&quot;ok&quot;</span>);    &#125;&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504152231.png"></p><h2 id="3、编译期间处理"><a href="#3、编译期间处理" class="headerlink" title="3、编译期间处理"></a>3、编译期间处理</h2><p>所谓的 <strong>语法糖</strong> ，其实就是指 java 编译器把 <em>.java 源码编译为 \</em>.class 字节码的过程中， <strong>自动生成</strong> 和 <strong>转换</strong> 的一些代码，主要是为了减轻程序员的负担，算是 java 编译器给我们的一个额外福利</p><p> <strong>注意</strong> ，以下代码的分析，借助了 javap 工具，idea 的反编译功能，idea 插件 jclasslib 等工具。另外， 编译器转换的 <strong>结果直接就是 class 字节码</strong> ，只是为了便于阅读，给出了 几乎等价 的 java 源码方式，并不是编译器还会转换出中间的 java 源码，切记。</p><h3 id="3-1-默认构造器"><a href="#3-1-默认构造器" class="headerlink" title="3.1 默认构造器"></a>3.1 默认构造器</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Candy1</span> </span>&#123;&#125;</code></pre><p>经过编译期优化后</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Candy1</span> </span>&#123;   <span class="hljs-comment">//这个无参构造器是java编译器帮我们加上的</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Candy1</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-comment">//即调用父类 Object 的无参构造方法，即调用 java/lang/Object.&quot; &lt;init&gt;&quot;:()V</span>      <span class="hljs-keyword">super</span>();   &#125;&#125;</code></pre><h3 id="3-2-自动拆装箱"><a href="#3-2-自动拆装箱" class="headerlink" title="3.2 自动拆装箱"></a>3.2 自动拆装箱</h3><p><code>基本类型和其包装类型的相互转换</code>过程，称为<code>拆装箱</code></p><p>在JDK 5以后，它们的转换可以在编译期自动完成</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo2</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      Integer x = <span class="hljs-number">1</span>;      <span class="hljs-keyword">int</span> y = x;   &#125;&#125;<span class="hljs-comment">//这段代码在 JDK 5 之前是无法编译通过的，必须改写成下面:</span></code></pre><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo2</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      <span class="hljs-comment">//基本类型赋值给包装类型，称为装箱</span>      Integer x = Integer.valueOf(<span class="hljs-number">1</span>);      <span class="hljs-comment">//包装类型赋值给基本类型，称谓拆箱</span>      <span class="hljs-keyword">int</span> y = x.intValue();   &#125;&#125;</code></pre><h3 id="3-3-泛型集合取值"><a href="#3-3-泛型集合取值" class="headerlink" title="3.3 泛型集合取值"></a>3.3 泛型集合取值</h3><p>泛型也是在 JDK 5 开始加入的特性，但 java 在 <strong>编译泛型代码后</strong> 会执行 <strong>泛型擦除</strong> 的动作，即泛型信息在编译为字节码之后就 <strong>丢失</strong> 了，实际的类型都当做了 <strong>Object</strong> 类型来处理：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();      list.add(<span class="hljs-number">10</span>);<span class="hljs-comment">// 实际调用的是 List.add(Object e)</span>      Integer x = list.get(<span class="hljs-number">0</span>);<span class="hljs-comment">// 实际调用的是 Object obj = List.get(int index);</span>   &#125;&#125;</code></pre><p>所以在取值时，编译器真正生成的字节码中，还要额外做一个类型转换的操作：</p><p>查看字节码：</p><pre><code class="hljs java">Code:    stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">1</span>       0: new           #2                  // class java/util/ArrayList       <span class="hljs-number">3</span>: dup       4: invokespecial #3                  // Method java/util/ArrayList.&quot;&lt;init&gt;&quot;:()V       <span class="hljs-number">7</span>: astore_1       <span class="hljs-number">8</span>: aload_1       <span class="hljs-number">9</span>: bipush        <span class="hljs-number">10</span>      11: invokestatic  #4                  // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer; // 基本类型包装              <span class="hljs-comment">//这里进行了泛型擦除，实际调用的是add(Objcet o)</span>      14: invokeinterface #5,  2            // InterfaceMethod java/util/List.add:(Ljava/lang/Object;)Z      <span class="hljs-number">19</span>: pop      <span class="hljs-number">20</span>: aload_1      <span class="hljs-number">21</span>: iconst_0      <span class="hljs-comment">//这里也进行了泛型擦除，实际调用的是get(Object o)   </span>      22: invokeinterface #6,  2            // InterfaceMethod java/util/List.get:(I)Ljava/lang/Object;<span class="hljs-comment">//这里进行了类型转换，将Object转换成了Integer</span>      27: checkcast     #7                  // class java/lang/Integer      <span class="hljs-number">30</span>: astore_2      <span class="hljs-number">31</span>: <span class="hljs-keyword">return</span></code></pre><pre><code class="hljs java"><span class="hljs-comment">// 需要将 Object 转为 Integer</span>Integer x = (Integer)list.get(<span class="hljs-number">0</span>);</code></pre><p>如果前面的 x 变量类型修改为 int 基本类型那么最终生成的字节码是：</p><pre><code class="hljs java"><span class="hljs-comment">// 需要将 Object 转为 Integer, 并执行拆箱操作</span><span class="hljs-keyword">int</span> x = ((Integer)list.get(<span class="hljs-number">0</span>)).intValue();</code></pre><p>擦除的是字节码上的泛型信息，可以看到 LocalVariableTypeTable 仍然保留了方法参数泛型的信息</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210508084303.png"></p><p>使用反射，仍然能够获得这些信息：</p><p>(局部变量无法通过反射信息拿到，方法参数、返回值带的信息才能被反射拿到)</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Set&lt;Integer&gt; <span class="hljs-title">test</span><span class="hljs-params">(List&lt;String&gt; list, Map&lt;Integer, Object&gt; map)</span> </span>&#123;&#125;</code></pre><pre><code class="hljs java">Method test = Candy3.class.getMethod(<span class="hljs-string">&quot;test&quot;</span>, List.class, Map.class);Type[] types = test.getGenericParameterTypes();  <span class="hljs-keyword">for</span> (Type type : types) &#123;  <span class="hljs-keyword">if</span> (type <span class="hljs-keyword">instanceof</span> ParameterizedType) &#123;    ParameterizedType parameterizedType = (ParameterizedType) type;    System.out.println(<span class="hljs-string">&quot;原始类型 -&quot;</span> + parameterizedType.getRawType());    Type[] arguments = parameterizedType.getActualTypeArguments();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arguments.length; i++) &#123;      System.out.printf(<span class="hljs-string">&quot;泛型参数[%d] - %s\n&quot;</span>, i, arguments[i]);    &#125;  &#125;&#125;</code></pre><pre><code class="hljs java">原始类型 - <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">java</span>.<span class="hljs-title">util</span>.<span class="hljs-title">List</span></span>泛型参数[0] - class java.lang.String原始类型 - <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">java</span>.<span class="hljs-title">util</span>.<span class="hljs-title">Map</span></span>泛型参数[0] - class java.lang.Integer泛型参数[<span class="hljs-number">1</span>] - <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">java</span>.<span class="hljs-title">lang</span>.<span class="hljs-title">Object</span></span></code></pre><h3 id="3-4-可变参数"><a href="#3-4-可变参数" class="headerlink" title="3.4 可变参数"></a>3.4 可变参数</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Candy4</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(String... args)</span> </span>&#123;        String[] array = args; <span class="hljs-comment">// 直接赋值</span>        System.out.println(array);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        foo(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>);    &#125;&#125;</code></pre><p>可变参数  <strong>String…</strong>  args 其实是一个  <strong>String[]</strong>  args ，从代码中的赋值语句中就可以看出来。 同 样 java 编译器会在编译期间将上述代码变换为：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Candy4</span> </span>&#123;   <span class="hljs-keyword">public</span> Candy4 &#123;&#125;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(String[] args)</span> </span>&#123;      String[] arr = args;      System.out.println(arr.length);   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      foo(<span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>&#125;);   &#125;&#125;</code></pre><p> <strong>注意</strong> ，如果调用的是foo()，即未传递参数时，<code>等价代码为foo(new String[]&#123;&#125;)</code>，创建了一个空数组，而不是直接传递的null</p><h3 id="3-5-foreach"><a href="#3-5-foreach" class="headerlink" title="3.5 foreach"></a>3.5 foreach</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Candy5_1</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">int</span>[] array = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;; <span class="hljs-comment">// 数组赋初值的简化写法也是语法糖哦</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> e : array) &#123;            System.out.println(e);        &#125;    &#125;&#125;</code></pre><p>编译器会帮我们转换为</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Candy5_1</span> </span>&#123;    <span class="hljs-keyword">public</span> Candy5_1 &#123;&#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    <span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;arr.length; ++i) &#123;      <span class="hljs-keyword">int</span> x = arr[i];      System.out.println(x);    &#125;  &#125;&#125;</code></pre><p> <strong>如果是集合使用foreach</strong> </p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Candy5_2</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);        <span class="hljs-keyword">for</span> (Integer i : list) &#123;            System.out.println(i);        &#125;    &#125;&#125;</code></pre><p>集合要使用foreach，需要该集合类实现了 <strong>Iterable接口</strong> ，因为集合的遍历需要用到 <strong>迭代器Iterator</strong> </p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo5</span> </span>&#123;    <span class="hljs-keyword">public</span> Demo5 &#123;&#125;       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);      <span class="hljs-comment">//获得该集合的迭代器</span>      Iterator&lt;Integer&gt; iterator = list.iterator();      <span class="hljs-keyword">while</span>(iterator.hasNext()) &#123;         Integer x = iterator.next();         System.out.println(x);      &#125;   &#125;&#125;</code></pre><h3 id="3-6-switch字符串"><a href="#3-6-switch字符串" class="headerlink" title="3.6 switch字符串"></a>3.6 switch字符串</h3><p>从 JDK 7 开始，switch 可以作用于字符串和枚举类，这个功能其实也是语法糖</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo6</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      String str = <span class="hljs-string">&quot;hello&quot;</span>;      <span class="hljs-keyword">switch</span> (str) &#123;         <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;hello&quot;</span> :            System.out.println(<span class="hljs-string">&quot;h&quot;</span>);            <span class="hljs-keyword">break</span>;         <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;world&quot;</span> :            System.out.println(<span class="hljs-string">&quot;w&quot;</span>);            <span class="hljs-keyword">break</span>;         <span class="hljs-keyword">default</span>:            <span class="hljs-keyword">break</span>;      &#125;   &#125;&#125;</code></pre><blockquote><p>注意 switch 配合 String 和枚举使用时，变量不能为null，原因分析完语法糖转换后的代码应当自<br>然清楚</p></blockquote><p>在编译器中执行的操作</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo6</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Demo6</span><span class="hljs-params">()</span> </span>&#123;         &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      String str = <span class="hljs-string">&quot;hello&quot;</span>;      <span class="hljs-keyword">int</span> x = -<span class="hljs-number">1</span>;      <span class="hljs-comment">//通过字符串的hashCode+value来判断是否匹配</span>      <span class="hljs-keyword">switch</span> (str.hashCode()) &#123;         <span class="hljs-comment">//hello的hashCode</span>         <span class="hljs-keyword">case</span> <span class="hljs-number">99162322</span> :            <span class="hljs-comment">//再次比较，因为字符串的hashCode有可能相等</span>            <span class="hljs-keyword">if</span>(str.equals(<span class="hljs-string">&quot;hello&quot;</span>)) &#123;               x = <span class="hljs-number">0</span>;            &#125;            <span class="hljs-keyword">break</span>;         <span class="hljs-comment">//world的hashCode</span>         <span class="hljs-keyword">case</span> <span class="hljs-number">11331880</span> :            <span class="hljs-keyword">if</span>(str.equals(<span class="hljs-string">&quot;world&quot;</span>)) &#123;               x = <span class="hljs-number">1</span>;            &#125;            <span class="hljs-keyword">break</span>;         <span class="hljs-keyword">default</span>:            <span class="hljs-keyword">break</span>;      &#125;      <span class="hljs-comment">//用第二个switch在进行输出判断</span>      <span class="hljs-keyword">switch</span> (x) &#123;         <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:            System.out.println(<span class="hljs-string">&quot;h&quot;</span>);            <span class="hljs-keyword">break</span>;         <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:            System.out.println(<span class="hljs-string">&quot;w&quot;</span>);            <span class="hljs-keyword">break</span>;         <span class="hljs-keyword">default</span>:            <span class="hljs-keyword">break</span>;      &#125;   &#125;&#125;</code></pre><p>过程说明：</p><ul><li><p>在编译期间，单个的switch被分为了两个</p><ul><li>第一个用来匹配字符串，并给x赋值<ul><li>字符串的匹配用到了字符串的hashCode，还用到了equals方法</li><li>使用hashCode是为了提高比较效率，使用equals是防止有hashCode冲突（如BM和C.）</li></ul></li><li>第二个用来根据x的值来决定输出语句</li></ul></li><li><p>可以看到，执行了两遍 switch，第一遍是根据字符串的 <code>hashCode 和 equals</code> 将字符串的转换为相应<br><code>byte 类型</code>，第二遍才是利用 byte 执行进行比较。</p></li><li><p>为什么第一遍时必须既比较 hashCode，又利用 equals 比较呢？hashCode 是为了提高效率，减少可<br>能的比较；而 <code>equals 是为了防止 hashCode 冲突</code>，例如 BM 和 C. 这两个字符串的hashCode值都是<br>2123 ，如果有如下代码：</p></li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">choose</span><span class="hljs-params">(String str)</span> </span>&#123;        <span class="hljs-keyword">switch</span> (str) &#123;            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;BM&quot;</span>: &#123;                System.out.println(<span class="hljs-string">&quot;h&quot;</span>);                <span class="hljs-keyword">break</span>;            &#125;            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;C.&quot;</span>: &#123;                System.out.println(<span class="hljs-string">&quot;w&quot;</span>);                <span class="hljs-keyword">break</span>;            &#125;        &#125;    &#125;</code></pre><p>会被优化为</p><p><img src=""></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Candy6_2</span></span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Candy6_2</span><span class="hljs-params">()</span></span>&#123; &#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">choose</span><span class="hljs-params">(String str)</span></span>&#123;        <span class="hljs-keyword">byte</span> x=-<span class="hljs-number">1</span>;        <span class="hljs-keyword">switch</span>(str.hashCode())&#123;            <span class="hljs-keyword">case</span> <span class="hljs-number">2123</span>: <span class="hljs-comment">// hashCode 值可能相同，需要进一步用 equals 比较</span>                <span class="hljs-keyword">if</span>(str.equals(<span class="hljs-string">&quot;C. &quot;</span>)) &#123;                    x=<span class="hljs-number">1</span>;                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(str.equals(<span class="hljs-string">&quot;BM&quot;</span>))&#123;                    x=<span class="hljs-number">0</span>;                &#125;<span class="hljs-keyword">default</span>:        <span class="hljs-keyword">switch</span>(x)&#123;            <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:                System.out.println(<span class="hljs-string">&quot;h&quot;</span>);                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:                System.out.println(<span class="hljs-string">&quot;w&quot;</span>);        &#125;        &#125;        &#125;        &#125;</code></pre><h3 id="3-7-switch枚举"><a href="#3-7-switch枚举" class="headerlink" title="3.7 switch枚举"></a>3.7 switch枚举</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Sex</span> </span>&#123;    MALE, FEMALE;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Candy7</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(Sex sex)</span> </span>&#123;        <span class="hljs-keyword">switch</span> (sex) &#123;            <span class="hljs-keyword">case</span> MALE:                System.out.println(<span class="hljs-string">&quot;男&quot;</span>); <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> FEMALE:                System.out.println(<span class="hljs-string">&quot;女&quot;</span>); <span class="hljs-keyword">break</span>;        &#125;    &#125;&#125;</code></pre><p>转化为</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo7</span> </span>&#123;   <span class="hljs-comment">/**     </span><span class="hljs-comment">    * 定义一个合成类（仅 jvm 使用，对我们不可见）     </span><span class="hljs-comment">    * 用来映射枚举的 ordinal 与数组元素的关系     </span><span class="hljs-comment">    * 枚举的 ordinal 表示枚举对象的序号，从 0 开始     </span><span class="hljs-comment">    * 即 MALE 的 ordinal()=0，FEMALE 的 ordinal()=1     </span><span class="hljs-comment">    */</span>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> $<span class="hljs-title">MAP</span> </span>&#123;      <span class="hljs-comment">//数组大小即为枚举元素个数，里面存放了case用于比较的数字</span>      <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] map = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2</span>];      <span class="hljs-keyword">static</span> &#123;         <span class="hljs-comment">//ordinal即枚举元素对应所在的位置，MALE为0，FEMALE为1</span>         map[SEX.MALE.ordinal()] = <span class="hljs-number">1</span>;         map[SEX.FEMALE.ordinal()] = <span class="hljs-number">2</span>;      &#125;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      SEX sex = SEX.MALE;      <span class="hljs-comment">//将对应位置枚举元素的值赋给x，用于case操作</span>      <span class="hljs-keyword">int</span> x = $MAP.map[sex.ordinal()];      <span class="hljs-keyword">switch</span> (x) &#123;         <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:            System.out.println(<span class="hljs-string">&quot;man&quot;</span>);            <span class="hljs-keyword">break</span>;         <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:            System.out.println(<span class="hljs-string">&quot;woman&quot;</span>);            <span class="hljs-keyword">break</span>;         <span class="hljs-keyword">default</span>:            <span class="hljs-keyword">break</span>;      &#125;   &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">SEX</span> </span>&#123;   MALE, FEMALE;&#125;</code></pre><h3 id="3-8-枚举类"><a href="#3-8-枚举类" class="headerlink" title="3.8 枚举类"></a>3.8 枚举类</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">SEX</span> </span>&#123;   MALE, FEMALE;  <span class="hljs-comment">// 本质Class， 里面两个实例对象</span>&#125;</code></pre><p>转换后的代码</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sex</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Enum</span>&lt;<span class="hljs-title">Sex</span>&gt; </span>&#123;      <span class="hljs-comment">//对应枚举类中的元素</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Sex MALE;       <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Sex FEMALE;       <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Sex[] $VALUES;       <span class="hljs-keyword">static</span> &#123;             <span class="hljs-comment">//调用构造函数，传入枚举元素的值及ordinal</span>      MALE = <span class="hljs-keyword">new</span> Sex(<span class="hljs-string">&quot;MALE&quot;</span>, <span class="hljs-number">0</span>);            FEMALE = <span class="hljs-keyword">new</span> Sex(<span class="hljs-string">&quot;FEMALE&quot;</span>, <span class="hljs-number">1</span>);           $VALUES = <span class="hljs-keyword">new</span> Sex[]&#123;MALE, FEMALE&#125;;    &#125;     <span class="hljs-comment">//调用父类中的方法</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Sex</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> ordinal)</span> </span>&#123;             <span class="hljs-keyword">super</span>(name, ordinal);        &#125;       <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Sex[] values() &#123;          <span class="hljs-keyword">return</span> $VALUES.clone();      &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Sex <span class="hljs-title">valueOf</span><span class="hljs-params">(String name)</span> </span>&#123;         <span class="hljs-keyword">return</span> Enum.valueOf(Sex.class, name);      &#125;    &#125;</code></pre><h3 id="3-9-try-with-resources"><a href="#3-9-try-with-resources" class="headerlink" title="3.9 try-with-resources"></a>3.9 try-with-resources</h3><p>JDK 7 开始新增了对需要关闭的资源处理的特殊语法，‘try-with-resources’</p><pre><code class="hljs java"><span class="hljs-keyword">try</span>(资源变量 = 创建资源对象) &#123;  &#125; <span class="hljs-keyword">catch</span>() &#123;&#125;</code></pre><p>其中资源对象需要实现 <code>AutoCloseable 接口</code>，例如 InputStream 、 OutputStream 、 Connection 、 Statement 、 ResultSet 等接口都实现了 AutoCloseable ，使用 try-with- resources <code>可以不用写 finally 语句块，编译器会帮助生成关闭资源代码</code>，例如：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Candy9</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    <span class="hljs-keyword">try</span>(InputStream is = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;d:\\1.txt&quot;</span>))&#123;       System.out.println(is);     &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;       e.printStackTrace();     &#125;   &#125; &#125;</code></pre><p>会被转换为：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Candy9</span> </span>&#123;         <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Candy9</span><span class="hljs-params">()</span> </span>&#123; &#125;       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;         <span class="hljs-keyword">try</span> &#123;            InputStream is = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;d:\\1.txt&quot;</span>);            Throwable t = <span class="hljs-keyword">null</span>;             <span class="hljs-keyword">try</span> &#123;                System.out.println(is);             &#125; <span class="hljs-keyword">catch</span> (Throwable e1) &#123;                 <span class="hljs-comment">// t 是我们代码出现的异常 </span>                t = e1;                 <span class="hljs-keyword">throw</span> e1;             &#125; <span class="hljs-keyword">finally</span> &#123;                <span class="hljs-comment">// 判断了资源不为空 </span>                <span class="hljs-keyword">if</span> (is != <span class="hljs-keyword">null</span>) &#123;                     <span class="hljs-comment">// 如果我们代码有异常</span>                    <span class="hljs-keyword">if</span> (t != <span class="hljs-keyword">null</span>) &#123;                         <span class="hljs-keyword">try</span> &#123;                            is.close();                         &#125; <span class="hljs-keyword">catch</span> (Throwable e2) &#123;                             <span class="hljs-comment">// 如果 close 出现异常，作为被压制异常添加</span>                            t.addSuppressed(e2);                         &#125;                     &#125; <span class="hljs-keyword">else</span> &#123;                         <span class="hljs-comment">// 如果我们代码没有异常，close 出现的异常就是最后 catch 块中的 e </span>                        is.close();                     &#125;                 &#125;             &#125;         &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            e.printStackTrace();         &#125;     &#125;&#125;</code></pre><p>为什么要设计一个 <code>addSuppressed(Throwable e) （添加被压制异常）</code>的方法呢？是为了防止异常信息的丢失（想想 try-with-resources 生成的 fianlly 中如果抛出了异常）：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test6</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;     <span class="hljs-keyword">try</span> (MyResource resource = <span class="hljs-keyword">new</span> MyResource()) &#123;       <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>/<span class="hljs-number">0</span>;     &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;       e.printStackTrace();     &#125;   &#125; &#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyResource</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AutoCloseable</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;     <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">&quot;close 异常&quot;</span>);   &#125; &#125;</code></pre><pre><code class="hljs ruby">java.lang.<span class="hljs-symbol">ArithmeticException:</span> / by zero   at test.Test6.main(Test6.<span class="hljs-symbol">java:</span><span class="hljs-number">7</span>)   <span class="hljs-symbol">Suppressed:</span> java.lang.<span class="hljs-symbol">Exception:</span> close 异常     at test.MyResource.close(Test6.<span class="hljs-symbol">java:</span><span class="hljs-number">18</span>)     at test.Test6.main(Test6.<span class="hljs-symbol">java:</span><span class="hljs-number">6</span>)/<span class="hljs-regexp">/ 防止资源类自己的异常丢失</span></code></pre><h3 id="3-10-方法重写时的桥接方法"><a href="#3-10-方法重写时的桥接方法" class="headerlink" title="3.10 方法重写时的桥接方法"></a>3.10 方法重写时的桥接方法</h3><p>我们都知道，方法重写时对返回值分两种情况：</p><ul><li>父子类的返回值完全一致</li><li>子类返回值可以是父类返回值的子类（比较绕口，见下面的例子）</li></ul><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> Number <span class="hljs-title">m</span><span class="hljs-params">()</span> </span>&#123;     <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;   &#125; &#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> </span>&#123;   <span class="hljs-meta">@Override</span>   <span class="hljs-comment">// 子类 m 方法的返回值是 Integer 是父类 m 方法返回值 Number 的子类  </span>  <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">m</span><span class="hljs-params">()</span> </span>&#123;     <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;   &#125; &#125;</code></pre><p>对于子类，java 编译器会做如下处理：</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">m</span><span class="hljs-params">()</span> </span>&#123;     <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;   &#125;  <span class="hljs-comment">// 此方法才是真正重写了父类 public Number m() 方法 </span>  <span class="hljs-function"><span class="hljs-keyword">public</span> synthetic bridge Number <span class="hljs-title">m</span><span class="hljs-params">()</span> </span>&#123;     <span class="hljs-comment">// 调用 public Integer m() </span>    <span class="hljs-keyword">return</span> m();   &#125; &#125;</code></pre><p>其中桥接方法比较特殊，仅对 java 虚拟机可见，并且与原来的 public Integer m() 没有命名冲突，可以<br>用下面反射代码来验证：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">for</span>(Method m : B.class.getDeclaredMethods()) &#123;            System.out.println(m);        &#125;    &#125;</code></pre><p>结果：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> java.lang.Integer cn.ali.jvm.test.B.m()<span class="hljs-keyword">public</span> java.lang.Number cn.ali.jvm.test.B.m()</code></pre><h3 id="3-11-匿名内部类"><a href="#3-11-匿名内部类" class="headerlink" title="3.11 匿名内部类"></a>3.11 匿名内部类</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Candy10</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      Runnable runnable = <span class="hljs-keyword">new</span> Runnable() &#123;         <span class="hljs-meta">@Override</span>         <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;            System.out.println(<span class="hljs-string">&quot;running...&quot;</span>);         &#125;      &#125;;   &#125;&#125;</code></pre><p>转换后的代码</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Candy10</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      <span class="hljs-comment">// 用额外创建的类来创建匿名内部类对象</span>      Runnable runnable = <span class="hljs-keyword">new</span> Candy10$<span class="hljs-number">1</span>();   &#125;&#125;<span class="hljs-comment">// 创建了一个额外的类，实现了 Runnable 接口</span><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Candy10</span>$1 <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;   <span class="hljs-keyword">public</span> Candy10$<span class="hljs-number">1</span>() &#123;&#125;   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;      System.out.println(<span class="hljs-string">&quot;running...&quot;</span>);   &#125;&#125;</code></pre><p>引用局部变量的匿名内部类，源代码：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Candy11</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> x)</span> </span>&#123;     Runnable runnable = <span class="hljs-keyword">new</span> Runnable() &#123;       <span class="hljs-meta">@Override</span>       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;           System.out.println(<span class="hljs-string">&quot;ok:&quot;</span> + x);       &#125;     &#125;;   &#125; &#125;</code></pre><p>转换后代码：</p><pre><code class="hljs java"><span class="hljs-comment">// 额外生成的类 </span><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Candy11</span>$1 <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;   <span class="hljs-keyword">int</span> val$x;   Candy11$<span class="hljs-number">1</span>(<span class="hljs-keyword">int</span> x) &#123;     <span class="hljs-keyword">this</span>.val$x = x;   &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;     System.out.println(<span class="hljs-string">&quot;ok:&quot;</span> + <span class="hljs-keyword">this</span>.val$x);   &#125; &#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Candy11</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> x)</span> </span>&#123;     Runnable runnable = <span class="hljs-keyword">new</span> Candy11$<span class="hljs-number">1</span>(x);   &#125; &#125;</code></pre><p>匿名内部类将这个局部变量的传入到匿名内部类中，以成员变量的形式存在，值传递有构造函数完成。保存线程安全;</p><p>注意：这同时解释了为什么匿名内部类引用局部变量时，局部变量必须是 final 的：因为在创建 Candy11$1 对象时，将 x 的值赋值给了 Candy11$1 对象的 值后，如果不是 final 声明的 x 值发生了改变，匿名内部类则值不一致。</p><h2 id="4、类加载阶段"><a href="#4、类加载阶段" class="headerlink" title="4、类加载阶段"></a>4、类加载阶段</h2><h3 id="1-加载"><a href="#1-加载" class="headerlink" title="1) 加载"></a>1) 加载</h3><ul><li>将类的字节码载入方法区（1.8后为元空间，在本地内存中）中，内部采用 C++ 的<code>instanceKlass</code>描述 java 类，它的重要 ﬁeld 有：<ul><li> <code>_java_mirror</code> 即 java 的类镜像，例如对 String 来说，它的镜像类就是 String.class，作用是把 klass 暴露给 java 使用 (桥梁)</li><li>_super 即父类</li><li>_ﬁelds 即成员变量</li><li>_methods 即方法</li><li>_constants 即常量池</li><li>_class_loader 即类加载器</li><li>_vtable 虚方法表</li><li>_itable 接口方法</li></ul></li><li>如果这个类还有父类没有加载， <strong>先加载父类</strong> </li><li>加载和链接可能是 <strong>交替运行</strong> 的</li></ul><blockquote><p><strong>注意</strong></p><ul><li>instanceKlass 这样的【元数据】是存储在<code>方法区</code>（1.8 后的元空间内），但 _java_mirror 是存储在<code>堆中</code></li><li>可以通过前面介绍的 HSDB 工具查看</li></ul></blockquote><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210508161739.png"></p><ul><li>instanceKlass保存在 <strong>方法区</strong> 。JDK 8以后，方法区位于元空间中，而元空间又位于本地内存中</li><li>_java_mirror则是保存在 <strong>堆内存</strong> 中</li><li>InstanceKlass和*.class(JAVA镜像类)互相保存了对方的地址</li><li>类的对象在对象头(每个实例对象16字节对象头，8字节对应对象的class地址)中保存了*.class的地址。让对象可以通过其找到方法区中的instanceKlass，从而获取类的各种信息</li></ul><h3 id="2-链接"><a href="#2-链接" class="headerlink" title="2)  链接"></a>2)  链接</h3><h4 id="1-验证"><a href="#1-验证" class="headerlink" title="1. 验证"></a>1. 验证</h4><p>验证类是否符合 JVM规范，安全性检查<br>用 UE 等支持二进制的编辑器修改 HelloWorld.class 的魔数，在控制台运行</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210508162241.png"></p><h4 id="2-准备"><a href="#2-准备" class="headerlink" title="2. 准备"></a>2. 准备</h4><p>为 static 变量分配空间，设置默认值</p><ul><li>static变量在 <code>JDK 7以前是存储与instanceKlass末尾</code>。但在<code>JDK 7以后就存储在_java_mirror末尾</code>了</li><li>static变量在分配空间和赋值是在两个阶段完成的。<code>分配空间在准备阶段完成</code>，<code>赋值在初始化阶段完成</code></li><li>如果 static 变量是 ﬁnal 的 <strong>基本类型</strong> ，以及 <strong>字符串常量</strong> ，那么编译阶段值就确定了， <strong>赋值在准备阶段完成</strong> </li><li>如果 static 变量是 ﬁnal 的，但属于 <strong>引用类型</strong> ，那么赋值也会在 <strong>初始化阶段完成</strong> </li></ul><h4 id="3-解析"><a href="#3-解析" class="headerlink" title="3. 解析"></a>3. 解析</h4><p>将常量池中的符号引用解析为直接引用</p><ul><li>未解析时，常量池中的看到的对象仅是符号，未真正的存在于内存中</li></ul><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Code_22_AnalysisTest</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, IOException </span>&#123;        ClassLoader classLoader = Code_22_AnalysisTest.class.getClassLoader();        Class&lt;?&gt; c = classLoader.loadClass(<span class="hljs-string">&quot;cn.ali.jvm.test.C&quot;</span>);        <span class="hljs-comment">// 只会进行类C的加载，不会对D初始化</span>        <span class="hljs-comment">// new C(); 这时候才会触发初始化，间接让D初始化</span>        System.in.read();    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> </span>&#123;    D d = <span class="hljs-keyword">new</span> D();&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">D</span> </span>&#123;&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210508163525.png"></p><p>打开hsdb连接进程id</p><p>找不到类D</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210508163613.png"></p><p>点进类C</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210508163709.png"></p><p>显示为“未经解析的类”</p><p>这时候我们 <code>添加new操作</code></p><ul><li>解析以后，会将常量池中的符号引用解析为直接引用<ul><li>可以看到，此时已加载并解析了类C和类D</li></ul></li></ul><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210508163824.png"></p><p>找到类C：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210508163839.png"></p><h3 id="3-初始化阶段"><a href="#3-初始化阶段" class="headerlink" title="3) 初始化阶段"></a>3) 初始化阶段</h3><p>初始化阶段就是 <strong>执行类构造器clinit()方法的过程</strong> ，虚拟机会保证这个类的『构造方法』的线程安全</p><ul><li>clinit()方法是由编译器自动收集类中的所有类变量的 <strong>赋值动作和静态语句块</strong> （static{}块）中的语句合并产生的</li></ul><h4 id="1-lt-cinit-gt-v-方法"><a href="#1-lt-cinit-gt-v-方法" class="headerlink" title="1. &lt; cinit &gt;()v 方法"></a>1. &lt; cinit &gt;()v 方法</h4><p> <strong>注意</strong> </p><p>编译器收集的顺序是由语句在源文件中 <strong>出现的顺序决定</strong> 的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它 <strong>之后</strong> 的变量，在前面的静态语句块 <strong>可以赋值，但是不能访问</strong> ，如</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210508164206.png"></p><h4 id="2-发生时机"><a href="#2-发生时机" class="headerlink" title="2. 发生时机"></a>2. 发生时机</h4><p> <strong>类的初始化的懒惰的</strong> ，以下情况会初始化</p><ul><li>main 方法所在的类，总会被首先初始化</li><li>首次访问这个类的<code>静态变量或静态方法</code>时</li><li>子类初始化，如果父类还没初始化，会引发</li><li><code>子类访问父类的静态变量</code>，只会触发父类的初始化</li><li>Class.forName</li><li>new 会导致初始化</li></ul><p>以下情况不会初始化</p><ul><li>访问类的<code>static ﬁnal</code>静态常量（基本类型和字符串）</li><li>类对象.class 不会触发初始化</li><li>创建该类对象的<code>数组</code></li><li>类加载器的.loadClass方法</li><li>Class.forNamed的参数2为false时</li></ul><p> <strong>验证类是否被初始化，可以看改类的静态代码块是否被执行</strong> </p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Load3</span> </span>&#123;    <span class="hljs-keyword">static</span> &#123;        System.out.println(<span class="hljs-string">&quot;main init&quot;</span>);    &#125; <span class="hljs-comment">// main方法所在类的 Load3 ，会被初始化，static会被运行</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, IOException </span>&#123;<span class="hljs-comment">//        // 1. 静态常量不会触发初始化</span>          System.out.println(B.b);<span class="hljs-comment">//        // 2. 类对象.class 不会触发初始化</span>          System.out.println(B.class);<span class="hljs-comment">//        // 3. 创建该类的数组不会触发初始化</span>          System.out.println(<span class="hljs-keyword">new</span> B[<span class="hljs-number">0</span>]);        <span class="hljs-comment">// 4. 不会初始化类 B，但会加载 B、A</span>        ClassLoader cl = Thread.currentThread().getContextClassLoader();        cl.loadClass(<span class="hljs-string">&quot;cn.itcast.jvm.t3.load.B&quot;</span>);<span class="hljs-comment">//        // 5. 不会初始化类 B，但会加载 B、A</span>        ClassLoader c2 = Thread.currentThread().getContextClassLoader();        Class.forName(<span class="hljs-string">&quot;cn.itcast.jvm.t3.load.B&quot;</span>, <span class="hljs-keyword">false</span>, c2);        System.in.read();<span class="hljs-comment">//        // 1. 首次访问这个类的静态变量或静态方法时会初始化</span>          System.out.println(A.a);<span class="hljs-comment">//        // 2. 子类初始化，如果父类还没初始化，会引发</span>          System.out.println(B.c);<span class="hljs-comment">//        // 3. 子类访问父类静态变量，只触发父类初始化</span>          System.out.println(B.a);<span class="hljs-comment">//        // 4. 会初始化类 B，并先初始化类 A</span>          Class.forName(<span class="hljs-string">&quot;cn.itcast.jvm.t3.load.B&quot;</span>);    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>;    <span class="hljs-keyword">static</span> &#123;        System.out.println(<span class="hljs-string">&quot;a init&quot;</span>);    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> </span>&#123;    <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">double</span> b = <span class="hljs-number">5.0</span>;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> c = <span class="hljs-keyword">false</span>;    <span class="hljs-keyword">static</span> &#123;        System.out.println(<span class="hljs-string">&quot;b init&quot;</span>);    &#125;&#125;</code></pre><h3 id="4-练习"><a href="#4-练习" class="headerlink" title="4) 练习"></a>4) 练习</h3><p>从字节码分析，使用 a，b，c 这三个常量是否会导致 E 初始化</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Load4</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        System.out.println(E.a);<span class="hljs-comment">// no</span>        System.out.println(E.b);<span class="hljs-comment">// no</span>        System.out.println(E.c);<span class="hljs-comment">// 包装类型, 会初始化</span>    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">E</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String b = <span class="hljs-string">&quot;hello&quot;</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Integer c = <span class="hljs-number">20</span>;  <span class="hljs-comment">// Integer.valueOf(20)</span>    <span class="hljs-keyword">static</span> &#123;        System.out.println(<span class="hljs-string">&quot;init E&quot;</span>);    &#125;&#125;</code></pre><p>懒汉单例：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Load9</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Singleton.getInstance();    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;&#125;  <span class="hljs-comment">// 静态内部类是为了可以访问外部类资源</span>  <span class="hljs-comment">// 静态内部类初始化过程：静态代码块、静态变量赋值的时候，加载器保证初始化线程安全</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LazyHolder</span></span>&#123;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton SINGLETON = <span class="hljs-keyword">new</span> Singleton();        <span class="hljs-keyword">static</span> &#123;            System.out.println(<span class="hljs-string">&quot;lazy holder init&quot;</span>);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> LazyHolder.SINGLETON;    &#125;&#125;</code></pre><p>以上的实现特点是：</p><ul><li>懒惰实例化</li><li>初始化时的线程安全是有保障的</li></ul><h2 id="5、类加载器"><a href="#5、类加载器" class="headerlink" title="5、类加载器"></a>5、类加载器</h2><p>以JDK 8为例</p><table><thead><tr><th>名称</th><th>加载的类</th><th>说明</th></tr></thead><tbody><tr><td>Bootstrap ClassLoader（启动类加载器）</td><td>JAVA_HOME/jre/lib</td><td>无法直接访问(cpp)</td></tr><tr><td>Extension ClassLoader(拓展类加载器)</td><td>JAVA_HOME/jre/lib/ext</td><td>上级为Bootstrap，<strong>显示为null</strong></td></tr><tr><td>Application ClassLoader(应用程序类加载器)</td><td>classpath</td><td>上级为Extension</td></tr><tr><td>自定义类加载器</td><td>自定义</td><td>上级为Application</td></tr></tbody></table><p>Java虚拟机设计团队有意把类加载阶段中的 <strong>“通过一个类的全限定名来获取描述该类的二进制字节流”</strong> 这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需的类。实现这个动作的代码被称为 <strong>“类加载器”</strong> （ClassLoader）</p><p>类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远超类加载阶段</p><p>对于任意一个类，都必须由加载它的 <strong>类加载器</strong> 和这个 <strong>类本身</strong> 一起共同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个<code>独立的类名称空间</code>。这句话可以表达得更通俗一些： <strong>比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义</strong> ，否则，即使这两个类来源于同一个Class文件，被同一个Java虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等</p><h3 id="1-启动类加载器"><a href="#1-启动类加载器" class="headerlink" title="1) 启动类加载器"></a>1) 启动类加载器</h3><p>用 Bootstrap 类加载器加载类：</p><p>可通过在控制台输入指令，使得类被启动类加器加载</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">F</span> </span>&#123;    <span class="hljs-keyword">static</span> &#123;        System.out.println(<span class="hljs-string">&quot;bootstrap F init&quot;</span>);    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Load5_1</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException </span>&#123;        Class&lt;?&gt; aClass = Class.forName(<span class="hljs-string">&quot;com.qiuke.jvm.class03.load.F&quot;</span>);        System.out.println(aClass.getClassLoader()); <span class="hljs-comment">// AppClassLoader  ExtClassLoader</span>    &#125;&#125;</code></pre><p>执行：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210508172848.png"></p><pre><code class="hljs java">qiukedeMacBook-Pro-<span class="hljs-number">2</span>:jvm qiuke$ java -Xbootclasspath/a:. com.qiuke.jvm.class03.load.Load5_1bootstrap F init<span class="hljs-keyword">null</span></code></pre><ul><li>-Xbootclasspath 表示设置 bootclasspath</li><li>其中 /a:. 表示将当前目录追加至 bootclasspath 之后</li><li>可以用这个办法替换核心类<ul><li>java -Xbootclasspath:&lt; new bootclasspath &gt;</li><li>java -Xbootclasspath/a:&lt;后追加路径&gt;</li><li>java -Xbootclasspath/p:&lt;前追加路径&gt;</li></ul></li></ul><h3 id="2-扩展类的加载器"><a href="#2-扩展类的加载器" class="headerlink" title="2) 扩展类的加载器"></a>2) 扩展类的加载器</h3><p>如果 classpath 和 JAVA_HOME/jre/lib/ext 下有同名类，加载时会使用<code>拓展类加载器加载</code>。当应用程序类加载器发现拓展类加载器已将该同名类加载过了，则不会再次加载。</p><p>上述一样的代码demo</p><pre><code class="hljs java">bootstrap F initsun.misc.Launcher$AppClassLoader@18b4aac2</code></pre><p>如果写一个同名的类</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">F</span> </span>&#123;    <span class="hljs-keyword">static</span> &#123;        System.out.println(<span class="hljs-string">&quot;Extension F init&quot;</span>);    &#125;&#125;</code></pre><p>打个 jar 包</p><pre><code class="hljs ruby">jar -cvf my.jar com.qiuke.jvm.class03.load.F.<span class="hljs-keyword">class</span>已添加清单正在添加: com.qiuke.jvm.class03.load.F.CLASS(输入 = <span class="hljs-number">481</span>) (输出 = <span class="hljs-number">322</span>)(压缩了 <span class="hljs-number">33</span>%)</code></pre><p>将 jar 包拷贝到 JAVA_HOME/jre/lib/ext<br>重新执行 Load5_2<br>输出</p><pre><code class="hljs ruby">ext G initsun.misc.Launcher$ExtClassLoader<span class="hljs-variable">@29453f4</span>4</code></pre><h3 id="3-双亲委派模式"><a href="#3-双亲委派模式" class="headerlink" title="3) 双亲委派模式"></a>3) 双亲委派模式</h3><p>所谓的双亲委派，就是指调用类加载器的 loadClass 方法时，查找类的规则</p><blockquote><p>双亲翻译为上级更合体，没有继承关系</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="hljs-keyword">boolean</span> resolve)    <span class="hljs-keyword">throws</span> ClassNotFoundException&#123;    <span class="hljs-keyword">synchronized</span> (getClassLoadingLock(name)) &#123;        <span class="hljs-comment">// 1.首先查找该类是否已经被该类加载器加载过了</span>        Class&lt;?&gt; c = findLoadedClass(name);        <span class="hljs-comment">//如果没有被加载过</span>        <span class="hljs-keyword">if</span> (c == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">long</span> t0 = System.nanoTime();            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-comment">// 2. 有上级，委派上级</span>                <span class="hljs-comment">//看是否被它的上级加载器加载过了 Extension的上级是Bootstarp，但它显示为null</span>                <span class="hljs-keyword">if</span> (parent != <span class="hljs-keyword">null</span>) &#123;                    c = parent.loadClass(name, <span class="hljs-keyword">false</span>);                &#125; <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-comment">// 3. 没有上级，委派bootstrap</span>                    <span class="hljs-comment">//看是否被启动类加载器加载过</span>                    c = findBootstrapClassOrNull(name);                &#125;            &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;                <span class="hljs-comment">// ClassNotFoundException thrown if class not found</span>                <span class="hljs-comment">// from the non-null parent class loader</span>                <span class="hljs-comment">//捕获异常，但不做任何处理</span>            &#125;            <span class="hljs-keyword">if</span> (c == <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-comment">//4. 如果还是没有找到，先让拓展类加载器调用findClass方法去找到该类，如果还是没找到，就抛出异常</span>                <span class="hljs-keyword">long</span> t1 = System.nanoTime();                c = findClass(name);                <span class="hljs-comment">// 5. 记录时间</span>                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);                sun.misc.PerfCounter.getFindClasses().increment();            &#125;        &#125;        <span class="hljs-keyword">if</span> (resolve) &#123;            resolveClass(c);        &#125;        <span class="hljs-keyword">return</span> c;    &#125;&#125;</code></pre><p>逐步分析：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Load5_3</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException </span>&#123;        System.out.println(Load5_3.class.getClassLoader());        Class&lt;?&gt; aClass = Load5_3.class.getClassLoader().loadClass(<span class="hljs-string">&quot;cn.itcast.jvm.t3.load.H&quot;</span>);        System.out.println(aClass.getClassLoader());    &#125;&#125;</code></pre><ol><li><p>sun.misc.Launcher$AppClassLoader //1 处， 开始查看已加载的类，结果没有</p></li><li><p>sun.misc.Launcher$AppClassLoader // 2 处，委派上级<br>sun.misc.Launcher$ExtClassLoader.loadClass()</p></li><li><p>sun.misc.Launcher$ExtClassLoader // 1 处，查看已加载的类，结果没有</p></li><li><p>委派上级sun.misc.Launcher$BootstrapClassLoader.loadClass()</p></li><li><p>BootstrapClassLoader 是在 JAVA_HOME/jre/lib 下找 H 这个类，显然没有</p></li><li><p>sun.misc.Launcher$ExtClassLoader // 4 处，调用自己的 findClass 方法，是在<br>JAVA_HOME/jre/lib/ext 下找 H 这个类，<code>显然没有(抛异常)</code>，回到 sun.misc.Launcher$AppClassLoader<br>的 // 2 处</p></li><li><p>继续执行到 sun.misc.Launcher$AppClassLoader // 4 处，调用它自己的 findClass 方法，在<br>classpath 下查找，找到了</p></li></ol><p>总体：先往上找有没有已经加载，再从最上层往下加载</p><h3 id="4-线程上下文类加载器"><a href="#4-线程上下文类加载器" class="headerlink" title="4) 线程上下文类加载器"></a>4) 线程上下文类加载器</h3><p>我们在使用 JDBC 时，都需要加载 Driver 驱动，不知道你注意到没有，不写</p><pre><code class="hljs java">Class.forName(<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>)</code></pre><p>也是可以让 <code>com.mysql.jdbc.Driver</code> 正确加载的，你知道是怎么做的吗？<br>让我们追踪一下源码：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DriverManager</span> </span>&#123;  <span class="hljs-comment">// 注册驱动的集合</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> CopyOnWriteArrayList&lt;DriverInfo&gt; registeredDrivers  = <span class="hljs-keyword">new</span> CopyOnWriteArrayList&lt;&gt;();  <span class="hljs-comment">// 初始化驱动</span>  <span class="hljs-keyword">static</span> &#123;    loadInitialDrivers();    println(<span class="hljs-string">&quot;JDBC DriverManager initialized&quot;</span>);&#125;</code></pre><p>先不看别的，看看 DriverManager 的类加载器：</p><pre><code class="hljs java">System.out.println(DriverManager.class.getClassLoader());</code></pre><p>打印 null，表示它的类加载器是 Bootstrap ClassLoader，会到 JAVA_HOME/jre/lib 下搜索类，但<br>JAVA_HOME/jre/lib 下显然没有 mysql-connector-java-5.1.47.jar 包，这样问题来了，在<br>DriverManager 的静态代码块中，怎么能正确加载 com.mysql.jdbc.Driver 呢？<br>继续看 loadInitialDrivers() 方法：</p><ol><li>使用ServiceLoader机制加载驱动</li><li>使用 jdbc.drivers 定义的驱动名加载驱动</li></ol><p>先看 2）发现它最后是使用 <code>Class.forName</code> 完成类的加载和初始化，关联的是<code>应用程序类加载器</code>，因此<br>可以顺利完成类加载<br>再看 1）它就是大名鼎鼎的<code> Service Provider Interface （SPI）</code><br>约定如下，在 jar 包的 META-INF/services 包下，以接口全限定名名为文件，文件内容是实现类名称</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210510100657.png"></p><p>这样就可以使用</p><pre><code class="hljs java">ServiceLoader&lt;接口类型&gt; allImpls = ServiceLoader.load(接口类型.class);Iterator&lt;接口类型&gt; iter = allImpls.iterator();<span class="hljs-keyword">while</span>(iter.hasNext()) &#123;iter.next();&#125;</code></pre><p>来得到实现类，体现的是【面向接口编程+解耦】的思想，在下面一些框架中都运用了此思想：</p><ul><li><p>JDBC</p></li><li><p>Servlet 初始化器</p></li><li><p>Spring 容器</p></li><li><p>Dubbo（对 SPI 进行了扩展）</p><p>接着看 ServiceLoader.load 方法：</p></li></ul><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;S&gt; <span class="hljs-function">ServiceLoader&lt;S&gt; <span class="hljs-title">load</span><span class="hljs-params">(Class&lt;S&gt; service)</span> </span>&#123;<span class="hljs-comment">// 获取线程上下文类加载器</span>ClassLoader cl = Thread.currentThread().getContextClassLoader();<span class="hljs-keyword">return</span> ServiceLoader.load(service, cl);&#125;</code></pre><p>线程上下文类加载器是<code>当前线程使用的类加载器</code>，默认就是<code>应用程序类加载器</code>，它内部又是由<br>Class.forName 调用了线程上下文类加载器完成类加载，具体代码在 ServiceLoader 的内部类<br>LazyIterator 中：</p><h3 id="5-自定义类加载器"><a href="#5-自定义类加载器" class="headerlink" title="5) 自定义类加载器"></a>5) 自定义类加载器</h3><blockquote><p>使用场景</p></blockquote><ul><li>想加载非 classpath 随意路径中的类文件</li><li>通过接口来使用实现，希望解耦时，常用在框架设计</li><li>这些类希望予以隔离，不同应用的同名类都可以加载，不冲突，常见于 tomcat 容器</li></ul><blockquote><p>步骤</p></blockquote><ul><li>继承 ClassLoader 父类</li><li>要遵从双亲委派机制，重写 ﬁndClass 方法<ul><li>不是重写 loadClass 方法，否则不会走双亲委派机制</li></ul></li><li>读取类文件的字节码</li><li>调用父类的 deﬁneClass 方法来加载类</li><li>使用者调用该类加载器的 loadClass 方法</li></ul><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClassLoader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ClassLoader</span> </span>&#123;    <span class="hljs-meta">@Override</span> <span class="hljs-comment">// name 就是类名称</span>    <span class="hljs-keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;        String path = <span class="hljs-string">&quot;e:\\myclasspath\\&quot;</span> + name + <span class="hljs-string">&quot;.class&quot;</span>;        <span class="hljs-keyword">try</span> &#123;            ByteArrayOutputStream os = <span class="hljs-keyword">new</span> ByteArrayOutputStream();            Files.copy(Paths.get(path), os);            <span class="hljs-comment">// 得到字节数组</span>            <span class="hljs-keyword">byte</span>[] bytes = os.toByteArray();            <span class="hljs-comment">// byte[] -&gt; *.class</span>            <span class="hljs-keyword">return</span> defineClass(name, bytes, <span class="hljs-number">0</span>, bytes.length);        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            e.printStackTrace();            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ClassNotFoundException(<span class="hljs-string">&quot;类文件未找到&quot;</span>, e);        &#125;    &#125;&#125;</code></pre><h3 id="6-破坏双亲委派模式"><a href="#6-破坏双亲委派模式" class="headerlink" title="6) 破坏双亲委派模式"></a>6) 破坏双亲委派模式</h3><ul><li>双亲委派模型的第一次“被破坏”其实发生在双亲委派模型出现之前——即JDK1.2面世以前的“远古”时代<ul><li>建议用户重写findClass()方法，在类加载器中的loadClass()方法中也会调用该方法</li></ul></li><li>双亲委派模型的第二次“被破坏”是由这个模型自身的缺陷导致的<ul><li>如果有基础类型又要调用回用户的代码，此时也会破坏双亲委派模式</li></ul></li><li>双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求而导致的<ul><li>这里所说的“动态性”指的是一些非常“热”门的名词：代码热替换（Hot Swap）、模块热部署（Hot Deployment）等</li></ul></li></ul><h2 id="6、运行期优化"><a href="#6、运行期优化" class="headerlink" title="6、运行期优化"></a>6、运行期优化</h2><h3 id="1-即时编译"><a href="#1-即时编译" class="headerlink" title="1) 即时编译"></a>1) 即时编译</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JIT1</span> </span>&#123;    <span class="hljs-comment">// -XX:+PrintCompilation -XX:-DoEscapeAnalysis</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">200</span>; i++) &#123;            <span class="hljs-keyword">long</span> start = System.nanoTime();            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">1000</span>; j++) &#123;                <span class="hljs-keyword">new</span> Object();            &#125;            <span class="hljs-keyword">long</span> end = System.nanoTime();            System.out.printf(<span class="hljs-string">&quot;%d\t%d\n&quot;</span>,i,(end - start));        &#125;    &#125;&#125;</code></pre><p>时间逐渐减小；</p><p>JVM 将执行状态分成了<code> 5 个层次：</code></p><ul><li>0层：<code>解释执行</code>，用<code>解释器</code>将字节码翻译为机器码</li><li>1层：使用 C1 <strong>即时编译器</strong> 编译执行（不带 proﬁling）</li><li>2层：使用 C1 即时编译器编译执行（带基本的profiling）</li><li>3层：使用 C1 即时编译器编译执行（带完全的profiling）</li><li>4层：使用 C2 即时编译器编译执行</li></ul><blockquote><p> proﬁling 是指在运行过程中收集一些程序执行状态的数据，例如【方法的调用次数】，【循环的 回边次数】等</p></blockquote><h4 id="即时编译器（JIT）与解释器的区别"><a href="#即时编译器（JIT）与解释器的区别" class="headerlink" title="即时编译器（JIT）与解释器的区别"></a>即时编译器（JIT）与解释器的区别</h4><ul><li>解释器<ul><li>将字节码 <strong>解释</strong> 为机器码，下次即使遇到相同的字节码，仍会执行重复的解释</li><li>是将字节码解释为针对所有平台都通用的机器码</li></ul></li><li>即时编译器<ul><li>将一些字节码 <strong>编译</strong> 为机器码， <strong>并存入 Code Cache</strong> ，下次遇到相同的代码，直接执行，无需再编译</li><li>根据平台类型，<code>生成平台特定的机器码</code></li></ul></li></ul><p>对于大部分的不常用的代码，我们无需耗费时间将其编译成机器码，而是采取解释执行的方式运行；另一方面，对于仅占据小部分的<code>热点代码</code>，我们则可以将其编译成机器码，以达到理想的运行速度。 执行效率上简单比较一下 Interpreter &lt; C1 &lt; C2，总的目标是<code>发现热点代码（hotspot名称的由来）</code>，并优化这些热点代码</p><h4 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h4><p>刚才的一种优化手段称之为【逃逸分析】，发现新建的对象是否逃逸。简单来讲就是，Java Hotspot 虚拟机可以分析新创建对象的使用范围，并决定是否在 Java 堆上分配内存的一项技术。可以使用 -XX:-<br>DoEscapeAnalysis 关闭逃逸分析，再运行刚才的示例观察结果</p><p>参考资料：<a href="https://docs.oracle.com/en/java/javase/12/vm/java-hotspot-virtual-machine">https://docs.oracle.com/en/java/javase/12/vm/java-hotspot-virtual-machine</a><br>performance-enhancements.html#GUID-D2E3DC58-D18B-4A6C-8167-4A1DFB4888E4</p><p>  <strong>全局逃逸（GlobalEscape）</strong>  </p><ul><li>即一个对象的作用范围逃出了当前方法或者当前线程，有以下几种场景：<ul><li>对象是一个静态变量</li><li>对象是一个已经发生逃逸的对象</li><li>对象作为当前方法的返回值</li></ul></li></ul><p> <strong>参数逃逸（ArgEscape）</strong> </p><ul><li>即一个对象被作为方法参数传递或者被参数引用，但在调用过程中不会发生全局逃逸，这个状态是通过被调方法的字节码确定的</li></ul><p> <strong>没有逃逸</strong> </p><ul><li>即方法中的对象没有发生逃逸</li></ul><p><strong>逃逸分析优化</strong></p><p>针对上面第三点，当一个对象 <strong>没有逃逸</strong> 时，可以得到以下几个虚拟机的优化</p><p> <strong>锁消除</strong> </p><p>我们知道线程同步锁是非常牺牲性能的，当编译器确定当前对象只有当前线程使用，那么就会移除该对象的同步锁</p><p>例如，StringBuffer 和 Vector 都是用 synchronized 修饰线程安全的，但大部分情况下，它们都只是在当前线程中用到，这样编译器就会优化移除掉这些锁操作</p><p>锁消除的 JVM 参数如下：</p><ul><li>开启锁消除：-XX:+EliminateLocks</li><li>关闭锁消除：-XX:-EliminateLocks</li></ul><p>锁消除在 JDK8 中都是默认开启的，并且锁消除都要建立在逃逸分析的基础上</p><p> <strong>标量替换</strong> </p><p>首先要明白标量和聚合量， <strong>基础类型</strong> 和 <strong>对象的引用</strong> 可以理解为<strong>标量</strong>，它们不能被进一步分解。而能被进一步分解的量就是聚合量，比如：对象</p><p>对象是聚合量，它又可以被进一步分解成标量，将其成员变量分解为分散的变量，这就叫做 <strong>标量替换</strong> 。</p><p>这样，如果一个对象没有发生逃逸，那压根就不用创建它，只会在栈或者寄存器上创建它用到的成员标量，节省了内存空间，也提升了应用程序性能</p><p>标量替换的 JVM 参数如下：</p><ul><li>开启标量替换：-XX:+EliminateAllocations</li><li>关闭标量替换：-XX:-EliminateAllocations</li><li>显示标量替换详情：-XX:+PrintEliminateAllocations</li></ul><p>标量替换同样在 JDK8 中都是默认开启的，并且都要建立在逃逸分析的基础上</p><p> <strong>栈上分配</strong> </p><p>当对象没有发生逃逸时，该 <strong>对象</strong> 就可以通过标量替换分解成成员标量分配在 <strong>栈内存</strong> 中，和方法的生命周期一致，随着栈帧出栈时销毁，减少了 GC 压力，提高了应用程序性能</p><h4 id="方法内联"><a href="#方法内联" class="headerlink" title="方法内联"></a>方法内联</h4><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">square</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> i)</span> </span>&#123;<span class="hljs-keyword">return</span> i * i;&#125;</code></pre><pre><code class="hljs java">System.out.println(square(<span class="hljs-number">9</span>));</code></pre><p>如果发现 square 是热点方法，并且长度不太长时，会进行内联，所谓的内联就是把方法内代码拷贝、<br>粘贴到调用者的位置：</p><pre><code class="hljs java">System.out.println(<span class="hljs-number">9</span> * <span class="hljs-number">9</span>);</code></pre><p>还能够进行常量折叠（constant folding）的优化</p><p>内联函数就是在程序编译时，编译器将程序中出现的内联函数的调用表达式用内联函数的函数体来直接进行替换</p><p>C++是否为内联函数由自己决定，Java由 <strong>编译器决定</strong> 。Java不支持直接声明为内联函数的，如果想让他内联，你只能够向编译器提出请求: 关键字 <strong>final修饰</strong> 用来指明那个函数是希望被JVM内联的，如</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span> </span>&#123;          <span class="hljs-comment">// to do something  </span>&#125;</code></pre><p>总的来说，一般的函数都不会被当做内联函数，只有声明了final后，编译器才会考虑是不是要把你的函数变成内联函数</p><p>JVM内建有许多运行时优化。首先 <strong>短方法</strong> 更利于JVM推断。流程更明显，作用域更短，副作用也更明显。如果是长方法JVM可能直接就跪了。</p><p>第二个原因则更重要： <strong>方法内联</strong> </p><p>如果JVM监测到一些 <strong>小方法被频繁的执行</strong> ，它会把方法的调用替换成方法体本身，如：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">add4</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x1, <span class="hljs-keyword">int</span> x2, <span class="hljs-keyword">int</span> x3, <span class="hljs-keyword">int</span> x4)</span> </span>&#123;     <span class="hljs-comment">//这里调用了add2方法</span>        <span class="hljs-keyword">return</span> add2(x1, x2) + add2(x3, x4);      &#125;      <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">add2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x1, <span class="hljs-keyword">int</span> x2)</span> </span>&#123;          <span class="hljs-keyword">return</span> x1 + x2;      &#125;</code></pre><p>方法调用被替换后</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">add4</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x1, <span class="hljs-keyword">int</span> x2, <span class="hljs-keyword">int</span> x3, <span class="hljs-keyword">int</span> x4)</span> </span>&#123;        <span class="hljs-comment">//被替换为了方法本身</span>        <span class="hljs-keyword">return</span> x1 + x2 + x3 + x4;      &#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式</title>
    <link href="/2020/12/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2020/12/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="设计模式七大原则"><a href="#设计模式七大原则" class="headerlink" title="设计模式七大原则"></a>设计模式七大原则</h1><h2 id="设计模式的目的"><a href="#设计模式的目的" class="headerlink" title="设计模式的目的"></a>设计模式的目的</h2><blockquote><p>编写软件过程中, 程序员面临着来自 <strong><em>耦合性</em></strong>, <strong><em>内聚性</em></strong>, 以及 <strong><em>可维护性</em></strong>, <strong><em>可扩展性</em></strong>, <strong><em>重用性</em></strong>, <strong><em>灵活性</em></strong> 等多方面的挑战, 设计模式是为了让 <strong><em>程序(软件)</em></strong>具有更好的:</p></blockquote><ol><li><p> 代码重用性 (即:相同功能的代码，不用多次编写)</p></li><li><p> 可读性 (即:编程规范性, 便于其他程序员的阅读和理解)</p></li><li><p> 可扩展性 (即:当需要增加新的功能时，非常的方便，称为可维护)</p></li><li><p> 可靠性 (即:当我们增加新的功能后，对原来的功能没有影响)</p></li><li><p>使程序呈现 <strong><em>高内聚，低耦合</em></strong>的特性</p><p> <strong>分享金句</strong>: </p><p>设计模式包含了面向对象的精髓，“懂了设计模式，你就懂了面向对象分析和设计(OOA/D)的精要”</p><p>Scott Mayers 在其巨著《Effective C++》就曾经说过:C++老手和 C++新手的区别就是前者手背上有很多伤疤</p></li></ol><h2 id="设计模式七大原则-1"><a href="#设计模式七大原则-1" class="headerlink" title="设计模式七大原则"></a>设计模式七大原则</h2><blockquote><p>设计模式原则，其实就是 <strong><em>程序员在编程时，应当遵守的原则</em></strong>，也是各种设计模式的基础(即:设计模式为什么这样设计的依据)</p></blockquote><p>设计模式常用的七大原则有:</p><ol><li><p>单一职责原则</p></li><li><p>接口隔离原则</p></li><li><p>依赖倒转(倒置)原则 </p></li><li><p>里氏替换原则</p></li><li><p>开闭原则</p></li><li><p>迪米特法则</p></li><li><p>合成复用原则</p></li></ol><h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>​        对类来说的，即一个类应该 <strong><em>只负责一项职责</em></strong>。如类 A 负责两个不同职责:职责 1，职责 2。当职责 1 需求变更 而改变 A 时，可能造成职责 2 执行错误，所以需要将类 A 的 <strong><em>粒度分解</em></strong>为 A1，A2</p><h4 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h4><p>以交通工具案例讲解</p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201201195254.png" alt="test" style="zoom:50%;" /><p>//  交通工具类<br>// 方式 1<br>// 1)在方式 1 的 run 方法中，违反了 <strong><em>单一职责原则</em></strong><br>// 2)解决的方案非常的简单，根据交通工具运行方法不同，分解成不同类即可</p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201201195739.png" alt="解耦后" style="zoom:50%;" /><p>// 方案 2 的分析<br>// 1. 遵守单一职责原则<br>// 2. 但是这样做的改动很大，即将类分解，同时修改客户端 </p><p> 改进:直接修改 Vehicle 类，改动的代码会比较少=&gt;方案 3</p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201201200149.png" alt="方案3" style="zoom:50%;" /><p>​    // 方式 3 的分析</p><p>​    //  1. 这种修改方法没有对原来的类做大的修改，只是增加方法<br>   //   2. 这里虽然没有在类这个级别上遵守单一职责原则，但是在方法级别上，仍然是遵守单一职责</p><pre><code>#### 单一职责原则注意事项和细节</code></pre><blockquote><p>  方法数量足够少，可以在方法级别保持单一职责原则</p></blockquote><ol><li> 降低类的复杂度，一个类只负责一项职责。</li><li> 提高类的可读性，可维护性</li><li> 降低变更引起的风险</li><li> 通常情况下， <strong>我们应当遵守单一职责原则</strong>，只有  <strong>逻辑足够简单，才可以在代码级违反单一职责原则</strong>;只有类中方法数量足够少，可以在方法级别保持单一职责原则</li></ol><h3 id="接口隔离原则-Interface-Segregation-Principle"><a href="#接口隔离原则-Interface-Segregation-Principle" class="headerlink" title="接口隔离原则(Interface Segregation Principle)"></a>接口隔离原则(Interface Segregation Principle)</h3><h4 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h4><ol><li><p>客户端不应该依赖它不需要的接口，即 <strong>一个类对另一个类的依赖应该建立在最小的接口</strong>上</p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201201201726.png" alt="接口隔离原则" style="zoom: 50%;" /></li></ol><p>B、D代表实现</p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201201203605.png" alt="接口实现" style="zoom:50%;" /><p>​    3.     类A通过接口Interface1依赖类B，类C通过接口Interface1依赖类D，如果接口Interface1对于类A和类C</p><p>来说不是最小接口，那么类 B 和类 D 必须去实现他们不需要的方法。 </p><p>​    4.    按隔离原则应当这样处理:</p><p>​    将接口  Interface1 拆分为独立的几个接口(这里我们拆分成 3 个接口)，类 A 和类 C 分别与他们需要的接口建立 依赖关系。也就是采用接口隔离原则</p><h4 id="应用实例-1"><a href="#应用实例-1" class="headerlink" title="应用实例"></a>应用实例</h4><ol><li>实现方案1+分析说明</li></ol><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Interface1</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operation1</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operation2</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operation3</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operation4</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operation5</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Interface1</span></span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation1</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;B&quot;</span> + <span class="hljs-number">1</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation2</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;B&quot;</span> + <span class="hljs-number">2</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation3</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;B&quot;</span> + <span class="hljs-number">3</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation4</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;B&quot;</span> + <span class="hljs-number">4</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation5</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;B&quot;</span> + <span class="hljs-number">5</span>);    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">D</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Interface1</span></span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation1</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;D&quot;</span> + <span class="hljs-number">1</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation2</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;D&quot;</span> + <span class="hljs-number">2</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation3</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;D&quot;</span> + <span class="hljs-number">3</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation4</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;D&quot;</span> + <span class="hljs-number">4</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation5</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;D&quot;</span> + <span class="hljs-number">5</span>);    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123; <span class="hljs-comment">// A类通过接口Interface1 依赖(使用)B类 但是只会用到1,2,3方法</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">depend1</span><span class="hljs-params">(Interface1 i)</span> </span>&#123;        i.operation1();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">depend2</span><span class="hljs-params">(Interface1 i)</span> </span>&#123;        i.operation2();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">depend3</span><span class="hljs-params">(Interface1 i)</span> </span>&#123;        i.operation3();    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> </span>&#123; <span class="hljs-comment">// C类通过接口Interface1 依赖(使用)D类 但是只会用到1,4,5方法</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">depend1</span><span class="hljs-params">(Interface1 i)</span> </span>&#123;        i.operation1();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">depend4</span><span class="hljs-params">(Interface1 i)</span> </span>&#123;        i.operation4();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">depend5</span><span class="hljs-params">(Interface1 i)</span> </span>&#123;        i.operation5();    &#125;&#125;</code></pre><h4 id="应传统方法的问题和使用接口隔离原则改进"><a href="#应传统方法的问题和使用接口隔离原则改进" class="headerlink" title="应传统方法的问题和使用接口隔离原则改进"></a>应传统方法的问题和使用接口隔离原则改进</h4><ol><li><p>类A通过接口Interface1依赖类B，类C通过接口Interface1依赖类D，如果接口Interface1对于类A和类C</p><p>来说不是最小接口，那么类 B 和类 D 必须去实现他们不需要的方法</p></li><li><p>将接口 <strong>Interface1</strong>拆分为独立的几个接口，类A和类C分别与他们需要的接口建立依赖关系。也就是采用接口 隔离原则</p><p>接口Interface1中出现的方法，根据实际情况拆分为三个接口</p></li></ol><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201201204019.png" alt="原理" style="zoom:50%;" /><img src="../../Library/Application Support/typora-user-images/image-20201201204856491.png" alt="解耦后" style="zoom:50%;" /><pre><code class="hljs java"><span class="hljs-comment">// 接口 1</span><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Interface1</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operation1</span><span class="hljs-params">()</span></span>; &#125;<span class="hljs-comment">// 接口 2</span><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Interface2</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operation2</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operation3</span><span class="hljs-params">()</span></span>; &#125;<span class="hljs-comment">// 接口 3</span><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Interface3</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operation4</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operation5</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Interface1</span>, <span class="hljs-title">Interface2</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation1</span><span class="hljs-params">()</span> </span>&#123; System.out.println(<span class="hljs-string">&quot;B 1&quot;</span>);&#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation2</span><span class="hljs-params">()</span> </span>&#123; System.out.println(<span class="hljs-string">&quot;B 1&quot;</span>);&#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation3</span><span class="hljs-params">()</span> </span>&#123; System.out.println(<span class="hljs-string">&quot;B 3&quot;</span>);&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">D</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Interface1</span>, <span class="hljs-title">Interface3</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation1</span><span class="hljs-params">()</span> </span>&#123; System.out.println(<span class="hljs-string">&quot;D 1&quot;</span>);&#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation4</span><span class="hljs-params">()</span> </span>&#123; System.out.println(<span class="hljs-string">&quot;D 4&quot;</span>);&#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation5</span><span class="hljs-params">()</span> </span>&#123; System.out.println(<span class="hljs-string">&quot;D 5&quot;</span>);&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123; <span class="hljs-comment">// A 类通过接口 Interface1,Interface2 依赖(使用) B 类，但是只会用到 1,2,3 方法 public void depend1(Interface1 i) &#123;</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">depend1</span><span class="hljs-params">(Interface1 i)</span> </span>&#123; i.operation1(); &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">depend2</span><span class="hljs-params">(Interface2 i)</span> </span>&#123; i.operation2(); &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">depend3</span><span class="hljs-params">(Interface2 i)</span> </span>&#123; i.operation3(); &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> </span>&#123; <span class="hljs-comment">// C 类通过接口 Interface1,Interface3 依赖(使用) D 类，但是只会用到 1,4,5 方法 public void depend1(Interface1 i) &#123;</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">depend1</span><span class="hljs-params">(Interface1 i)</span> </span>&#123; i.operation1(); &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">depend4</span><span class="hljs-params">(Interface3 i)</span> </span>&#123; i.operation4(); &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">depend5</span><span class="hljs-params">(Interface3 i)</span> </span>&#123; i.operation5(); &#125;&#125;</code></pre><pre><code class="hljs java">A a = <span class="hljs-keyword">new</span> A();a.depend1(<span class="hljs-keyword">new</span> B()); <span class="hljs-comment">// A类通过接口去依赖B类</span>a.depend2(<span class="hljs-keyword">new</span> B());a.depend3(<span class="hljs-keyword">new</span> B());C c = <span class="hljs-keyword">new</span> C();c.depend1(<span class="hljs-keyword">new</span> D()); <span class="hljs-comment">// C类通过接口去依赖D类</span>c.depend4(<span class="hljs-keyword">new</span> D());c.depend5(<span class="hljs-keyword">new</span> D());</code></pre><h3 id="依赖倒转原则-Dependence-Inversion-Principle"><a href="#依赖倒转原则-Dependence-Inversion-Principle" class="headerlink" title="依赖倒转原则(Dependence Inversion Principle)"></a>依赖倒转原则(Dependence Inversion Principle)</h3><h4 id="基本介绍-2"><a href="#基本介绍-2" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>依赖倒转原则(Dependence Inversion Principle)是指:</p><ol><li><p> 高层模块不应该依赖低层模块，二者都应该依赖其抽象(抽象类、接口都可以)</p></li><li><p> <strong><em>抽象不应该依赖细节，细节应该依赖抽象</em></strong></p></li><li><p> 依赖倒转(倒置)的中心思想是 <strong><em>面向接口编程</em></strong></p></li><li><p> 依赖倒转原则是基于这样的设计理念:相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架 构比以细节为基础的架构要稳定的多。在 java 中，抽象指的是接口或抽象类，细节就是具体的实现类</p></li><li><p>使用 <strong><em>接口或抽象类</em></strong>的目的是制定好 <strong><em>规范</em></strong>，而不涉及任何具体的操作，把 <strong><em>展现细节的任务交给他们的实现类</em></strong>去完成</p><h4 id="应用实例-2"><a href="#应用实例-2" class="headerlink" title="应用实例"></a>应用实例</h4></li></ol><p>请编程完成 Person 接收消息 的功能。</p><ol><li>实现方案1+分析说明</li></ol><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DependecyInversion1</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Person person = <span class="hljs-keyword">new</span> Person();        person.receive(<span class="hljs-keyword">new</span> Email());    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Email</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getInfo</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;电子邮件信息: hello,world&quot;</span>; &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receive</span><span class="hljs-params">(Email email )</span> </span>&#123; System.out.println(email.getInfo()); &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-comment">//  方式 1 分析</span><span class="hljs-number">1.</span> 简单，比较容易想到<span class="hljs-number">2.</span> 如果我们获取的对象是 微信，短信等等，则新增类，同时 Perons 也要增加相应的接收方法<span class="hljs-number">3.</span> 解决思路:引入一个抽象的接口 IReceiver, 表示接收者, 这样 Person 类与接口 IReceiver 发生依赖</code></pre><ol start="2"><li>实现方案2+分析说明</li></ol><pre><code class="hljs java"><span class="hljs-comment">// 定义接口</span><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IReceiver</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getInfo</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EmailImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IReceiver</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getInfo</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;电子邮件信息: hello,world&quot;</span>;    &#125;&#125;<span class="hljs-comment">//增加微信</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WeiXin</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IReceiver</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getInfo</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;微信信息: hello,ok&quot;</span>;    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PersonNew</span> </span>&#123;    <span class="hljs-comment">//这里我们是对接口的依赖</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receive</span><span class="hljs-params">(IReceiver receiver )</span> </span>&#123;        System.out.println(receiver.getInfo());    &#125;&#125;</code></pre><h4 id="依赖关系传递的三种方式和应用案例"><a href="#依赖关系传递的三种方式和应用案例" class="headerlink" title="依赖关系传递的三种方式和应用案例"></a>依赖关系传递的三种方式和应用案例</h4><blockquote><p>接口传递</p></blockquote><pre><code class="hljs java"><span class="hljs-comment">// 方式1：通过接口传递实现依赖</span><span class="hljs-comment">// 开关的接口</span><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IOpenAndClose</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">open</span><span class="hljs-params">(ITV tv)</span></span>; <span class="hljs-comment">//抽象方法，接收接口</span>&#125;<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ITV</span> </span>&#123; <span class="hljs-comment">//ITV接口</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">play</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OpenAndClose</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IOpenAndClose</span></span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">open</span><span class="hljs-params">(ITV tv)</span></span>&#123;   tv.play();   &#125;&#125;<span class="hljs-comment">// 如何使用?</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChangHong</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ITV</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">play</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;打开changhong TV&quot;</span>);    &#125;&#125;<span class="hljs-comment">// 使用</span>ChangHong changHong = <span class="hljs-keyword">new</span> ChangHong();OpenAndClose openAndClose = <span class="hljs-keyword">new</span> OpenAndClose();openAndClose.open(changHong);</code></pre><blockquote><p>构造方法传递 </p></blockquote><pre><code class="hljs java"><span class="hljs-comment">// 方式2：通过构造方法依赖传递</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IOpenAndClose</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">open</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//抽象方法</span> &#125; <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ITV</span> </span>&#123; <span class="hljs-comment">//ITV接口</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">play</span><span class="hljs-params">()</span></span>; &#125; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OpenAndClose</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IOpenAndClose</span></span>&#123;   <span class="hljs-keyword">public</span> ITV tv;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">OpenAndClose</span><span class="hljs-params">(ITV tv)</span></span>&#123; <span class="hljs-comment">//构造器</span>      <span class="hljs-keyword">this</span>.tv = tv;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">open</span><span class="hljs-params">()</span></span>&#123;   <span class="hljs-keyword">this</span>.tv.play();   &#125; &#125;<span class="hljs-comment">// 如何使用？</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChangHong</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ITV</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">play</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;打开changhong TV&quot;</span>);    &#125;&#125;<span class="hljs-comment">// 使用：</span>ChangHong changHong = <span class="hljs-keyword">new</span> ChangHong();OpenAndClose openAndClose = <span class="hljs-keyword">new</span> OpenAndClose(changHong);openAndClose.open();</code></pre><blockquote><p>setter 方式传递</p></blockquote><pre><code class="hljs java"><span class="hljs-comment">// 方式3：setter方法实现</span><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IOpenAndClose</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">open</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 抽象方法</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setTv</span><span class="hljs-params">(ITV tv)</span></span>;&#125;<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ITV</span> </span>&#123; <span class="hljs-comment">// ITV接口</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">play</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OpenAndClose</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IOpenAndClose</span> </span>&#123;   <span class="hljs-keyword">private</span> ITV tv;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setTv</span><span class="hljs-params">(ITV tv)</span> </span>&#123;      <span class="hljs-keyword">this</span>.tv = tv;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">open</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">this</span>.tv.play();   &#125;&#125;<span class="hljs-comment">// 如何使用？</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChangHong</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ITV</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">play</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;打开changhong TV&quot;</span>);    &#125;&#125;        ChangHong changHong = <span class="hljs-keyword">new</span> ChangHong();        OpenAndClose openAndClose = <span class="hljs-keyword">new</span> OpenAndClose();        openAndClose.setTv(changHong);        openAndClose.open();</code></pre><h4 id="依赖倒转原则的注意事项和细节"><a href="#依赖倒转原则的注意事项和细节" class="headerlink" title="依赖倒转原则的注意事项和细节"></a>依赖倒转原则的注意事项和细节</h4><ol><li>  低层模块尽量都要有抽象类或接口，或者两者都有，程序稳定性更好.</li><li>   <strong><em>变量的声明类型尽量是抽象类或接口</em></strong>, 这样我们的变量引用和实际对象间，就存在一个 <strong><em>缓冲层</em></strong>，利于程序扩展和优化</li><li>  继承时遵循 <strong><em>里氏替换</em></strong>原则</li></ol><h3 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h3><h4 id="OO-中的继承性的思考和说明"><a href="#OO-中的继承性的思考和说明" class="headerlink" title="OO 中的继承性的思考和说明"></a>OO 中的继承性的思考和说明</h4><ol><li>继承包含这样一层含义: <strong>父类中凡是已经实现好的方法，实际上是在设定规范和契约</strong>，虽然它不强制要求所有 的子类必须遵循这些契约，但是如果子类对这些已经实现的方法任意修改，就会对整个继承体系造成破坏。</li><li> <strong>继承在给程序设计带来便利的同时，也带来了弊端</strong>。比如使用继承会给程序带来 <strong>侵入性</strong>，程序的可移植性降低， <strong>增加对象间的耦合性</strong>，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且 父类修改后，所有涉及到子类的功能都有可能产生故障</li><li>问题提出: <strong>在编程中，如何正确的使用继承?</strong> =&gt;  <strong>里氏替换原则</strong></li></ol><h4 id="基本介绍-3"><a href="#基本介绍-3" class="headerlink" title="基本介绍"></a>基本介绍</h4><ol><li>里氏替换原则(LiskovSubstitutionPrinciple)在1988年，由麻省理工学院的以为姓里的女士提出的。</li><li>如果对每个类型为T1的对象o1，都有类型为T2的对象o2，使得以T1定义的所有程序P在所有的对象o1都 代换成 o2 时，程序 P 的行为没有发生变化，那么类型 T2 是类型 T1 的子类型。换句话说， <strong><em>所有引用基类的地 方必须能透明地使用其子类的对象</em></strong>。</li><li>在使用继承时，遵循里氏替换原则，在 <strong><em>子类中尽量不要重写父类的方法</em></strong>。</li><li>里氏替换原则告诉我们，继承实际上让两个类耦合性增强了，在适当的情况下，可以通过 <strong><em>聚合，组合，依赖</em></strong>来解决问题。</li></ol><h4 id="一个程序引出的问题和思考"><a href="#一个程序引出的问题和思考" class="headerlink" title="一个程序引出的问题和思考"></a>一个程序引出的问题和思考</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Liskov1</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        A a = <span class="hljs-keyword">new</span> A();        System.out.println(<span class="hljs-string">&quot;11-3=&quot;</span> + a.func1(<span class="hljs-number">11</span>, <span class="hljs-number">3</span>));        System.out.println(<span class="hljs-string">&quot;1-8=&quot;</span> + a.func1(<span class="hljs-number">1</span>, <span class="hljs-number">8</span>));        System.out.println(<span class="hljs-string">&quot;-----------------------&quot;</span>);        B b = <span class="hljs-keyword">new</span> B();        System.out.println(<span class="hljs-string">&quot;11-3=&quot;</span> + b.func1(<span class="hljs-number">11</span>, <span class="hljs-number">3</span>));<span class="hljs-comment">//这里本意是求出 11-3</span>        System.out.println(<span class="hljs-string">&quot;1-8=&quot;</span> + b.func1(<span class="hljs-number">1</span>, <span class="hljs-number">8</span>));        <span class="hljs-comment">// 1-8</span>        System.out.println(<span class="hljs-string">&quot;11+3+9=&quot;</span> + b.func2(<span class="hljs-number">11</span>, <span class="hljs-number">3</span>));    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;    <span class="hljs-comment">// 返回两个数的差</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">func1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num1, <span class="hljs-keyword">int</span> num2)</span> </span>&#123; <span class="hljs-keyword">return</span> num1 - num2; &#125;&#125;<span class="hljs-comment">// B 类继承了 A</span><span class="hljs-comment">// 增加了一个新功能:完成两个数相加,然后和 9 求和</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> </span>&#123;    <span class="hljs-comment">//这里，重写了 A 类的方法, 可能是无意识</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">func1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123; <span class="hljs-keyword">return</span> a + b; &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">func2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123; <span class="hljs-keyword">return</span> func1(a, b) + <span class="hljs-number">9</span>; &#125;&#125;</code></pre><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><ol><li><p>我们发现原来运行正常的相减功能发生了错误。原因就是 <strong><em>类B无意中重写了父类的方法，造成原有功能出现错误</em></strong>。在实际编程中，我们常常会通过重写父类的方法完成新的功能，这样写起来虽然简单，但整个继承体系的复用性会比较差。特别是运行多态比较频繁的时候</p></li><li><p>通用的做法是: <strong><em>原来的父类和子类都继承一个更通俗的基类，原有的继承关系去掉，采用依赖，聚合，组合等 关系代替</em></strong>.</p></li></ol><pre><code class="hljs java"><span class="hljs-comment">//创建一个更加基础的基类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span> </span>&#123;    <span class="hljs-comment">//把更加基础的方法和成员写到 Base 类</span>&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Base</span></span>&#123;    <span class="hljs-comment">// 返回两个数的差</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">func1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num1, <span class="hljs-keyword">int</span> num2)</span> </span>&#123; <span class="hljs-keyword">return</span> num1 - num2; &#125;&#125;<span class="hljs-comment">// 增加了一个新功能:完成两个数相加,然后和 9 求和</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Base</span> </span>&#123;    <span class="hljs-comment">//如果 B 需要使用 A 类的方法,使用组合关系</span>    <span class="hljs-keyword">private</span> A a = <span class="hljs-keyword">new</span> A();    <span class="hljs-comment">//我们仍然想使用 A 的方法</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">func3</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.a.func1(a, b)&#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">func1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123; <span class="hljs-keyword">return</span> a + b; &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">func2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123; <span class="hljs-keyword">return</span> func1(a, b) + <span class="hljs-number">9</span>; &#125;&#125;</code></pre><h3 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h3><h4 id="基本介绍-4"><a href="#基本介绍-4" class="headerlink" title="基本介绍"></a>基本介绍</h4><ol><li><p>开闭原则(OpenClosedPrinciple)是编程中 <strong><em>最基础、最重要</em></strong>的设计原则</p></li><li><p> 一个软件实体如类，模块和函数应该对 <strong><em>扩展开放(对提供方)，对修改关闭(对使用方)</em></strong>。用抽象构建框架，用实</p></li></ol><p>现扩展细节。</p><ol start="3"><li><p> 当软件需要变化时，尽量 <strong>通过扩展</strong>软件实体的行为来实现变化，而不是 <strong>通过修改</strong>已有的代码来实现变化。</p></li><li><p>编程中遵循其它原则，以及使用设计模式的目的就是遵循开闭原则。</p></li></ol><h4 id="应用实例-3"><a href="#应用实例-3" class="headerlink" title="应用实例"></a>应用实例</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ocp</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        GraphicEditor graphicEditor = <span class="hljs-keyword">new</span> GraphicEditor();        graphicEditor.drawShape(<span class="hljs-keyword">new</span> Rectangle());        graphicEditor.drawShape(<span class="hljs-keyword">new</span> Circle());        graphicEditor.drawShape(<span class="hljs-keyword">new</span> Triangle());    &#125;&#125;<span class="hljs-comment">//绘图类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GraphicEditor</span> </span>&#123;    <span class="hljs-comment">//接受Shape对象 根据m_type绘制图像</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">drawShape</span><span class="hljs-params">(Shape s)</span> </span>&#123;        <span class="hljs-keyword">if</span> (s.m_type == <span class="hljs-number">1</span>)            drawRectangle(s);        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s.m_type == <span class="hljs-number">2</span>)            drawCircle(s);    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">drawRectangle</span><span class="hljs-params">(Shape r)</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot; 矩形 &quot;</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">drawCircle</span><span class="hljs-params">(Shape r)</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot; 圆形 &quot;</span>);    &#125;&#125;<span class="hljs-comment">//Shape类 基类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Shape</span> </span>&#123;    <span class="hljs-keyword">int</span> m_type;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Shape</span> </span>&#123;    Rectangle() &#123;        <span class="hljs-keyword">super</span>.m_type = <span class="hljs-number">1</span>;    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Shape</span> </span>&#123;    Circle() &#123;        <span class="hljs-keyword">super</span>.m_type = <span class="hljs-number">2</span>;    &#125;&#125;</code></pre><p> 问题出在, 如果要新增一个, 需要修改许多:</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Triangle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Shape</span> </span>&#123;    Triangle() &#123;        <span class="hljs-keyword">super</span>.m_type = <span class="hljs-number">3</span>;    &#125;&#125;<span class="hljs-comment">// 如果新增 则需要</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">drawTriangle</span><span class="hljs-params">(Shape r)</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;  &quot;</span>);    &#125;<span class="hljs-comment">// 还需要</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">drawShape</span><span class="hljs-params">(Shape s)</span> </span>&#123;        <span class="hljs-keyword">if</span> (s.m_type == <span class="hljs-number">1</span>)            drawRectangle(s);        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s.m_type == <span class="hljs-number">2</span>)            drawCircle(s);        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s.m_type == <span class="hljs-number">3</span>)            drawTriangle(s);&#125;</code></pre><ol><li><p>优点是比较好理解，简单易操作。</p></li><li><p>缺点是 <strong>违反了设计模式的ocp原则</strong>，即对扩展开放(提供方)，对修改关闭(使用方)。即当我们给类增加新功能的时候，尽量不修改代码，或者尽可能少修改代码.</p></li><li><p>比如我们这时要新增加一个图形种类三角形，我们需要做如上修改，修改的地方较多</p></li></ol><h4 id="改进的思路分析"><a href="#改进的思路分析" class="headerlink" title="改进的思路分析"></a>改进的思路分析</h4><p>思路:把创建 <strong>Shape</strong> 类做成抽象类，并提供一个抽象的 <strong>draw</strong> 方法，让子类去实现即可，这样我们有新的图形 种类时，只需要让新的图形类继承 Shape，并实现 draw 方法即可，使用方的代码就不需要修 -&gt; 满足了开闭原则</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ocp</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        GraphicEditor graphicEditor = <span class="hljs-keyword">new</span> GraphicEditor();        graphicEditor.drawShape(<span class="hljs-keyword">new</span> Rectangle());        graphicEditor.drawShape(<span class="hljs-keyword">new</span> Circle());        graphicEditor.drawShape(<span class="hljs-keyword">new</span> Triangle());        graphicEditor.drawShape(<span class="hljs-keyword">new</span> OtherGraphic());    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GraphicEditor</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">drawShape</span><span class="hljs-params">(Shape s)</span> </span>&#123;        s.draw();    &#125;&#125;<span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Shape</span> </span>&#123;    <span class="hljs-keyword">int</span> m_type;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Shape</span> </span>&#123;    Rectangle() &#123;        <span class="hljs-keyword">super</span>.m_type = <span class="hljs-number">1</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot; 矩形 &quot;</span>);    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Shape</span> </span>&#123;    Circle() &#123;        <span class="hljs-keyword">super</span>.m_type = <span class="hljs-number">2</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot; 圆形 &quot;</span>);    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Triangle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Shape</span> </span>&#123;    Triangle() &#123;        <span class="hljs-keyword">super</span>.m_type = <span class="hljs-number">3</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// TODO Auto-generated method stub</span>        System.out.println(<span class="hljs-string">&quot; 三角形 &quot;</span>);    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OtherGraphic</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Shape</span> </span>&#123;    OtherGraphic() &#123;        <span class="hljs-keyword">super</span>.m_type = <span class="hljs-number">4</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// TODO Auto-generated method stub</span>        System.out.println(<span class="hljs-string">&quot; 其他 &quot;</span>);    &#125;&#125;</code></pre><h3 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h3><h4 id="基本介绍-5"><a href="#基本介绍-5" class="headerlink" title="基本介绍"></a>基本介绍</h4><ol><li>一个对象应该对其他对象 <strong>保持最少的了解</strong></li><li>类与类关系越密切，耦合度越大</li><li>迪米特法则(DemeterPrinciple)又叫 <strong>最少知道原则</strong>，即一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类不管多么复杂，都尽量 <strong>将逻辑封装在类的内部</strong>。对外除了提供的 public 方法，不对外泄露任何信息</li><li>迪米特法则还有个更简单的定义: <strong>只与直接的朋友通信</strong></li><li>直接的朋友:每个对象都会与其他对象有 <strong>耦合关系</strong>，只要两个对象之间有耦合关系，我们就说这两个对象之间 是朋友关系。耦合的方式很多，依赖，关联，组合，聚合等。其中，我们称出现 <strong>成员变量，方法参数，方法返 回值中的类</strong>为直接的朋友，而出现在 <strong>局部变量中的类不是直接的朋友</strong>。也就是说，陌生的类最好不要以局部变 量的形式出现在类的内部。</li></ol><h4 id="应用实例-4"><a href="#应用实例-4" class="headerlink" title="应用实例"></a>应用实例</h4><ol><li><p>有一个学校，下属有各个学院和总部，现要求打印出学校总部员工ID和学院员工的id </p></li><li><p>编程实现上面的功能, 看代码演示</p></li><li><p>代码演示</p></li></ol><pre><code class="hljs java"><span class="hljs-comment">//迪米特法则</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demeter1</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SchoolManager schoolManager = <span class="hljs-keyword">new</span> SchoolManager();        schoolManager.printAllEmployee(<span class="hljs-keyword">new</span> CollegeManager());    &#125;&#125;<span class="hljs-comment">// 学校总部员工</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span> </span>&#123;    <span class="hljs-keyword">private</span> String id;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(String id)</span> </span>&#123;        <span class="hljs-keyword">this</span>.id = id;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> id;    &#125;&#125;<span class="hljs-comment">// 学院员工</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CollegeEmployee</span> </span>&#123;    <span class="hljs-keyword">private</span> String id;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(String id)</span> </span>&#123;        <span class="hljs-keyword">this</span>.id = id;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> id;    &#125;&#125;<span class="hljs-comment">// 管理学院员工类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CollegeManager</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;CollegeEmployee&gt; <span class="hljs-title">getAllEmployee</span><span class="hljs-params">()</span> </span>&#123;        List&lt;CollegeEmployee&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;CollegeEmployee&gt;();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;            CollegeEmployee emp = <span class="hljs-keyword">new</span> CollegeEmployee();            emp.setId(<span class="hljs-string">&quot;学校员工id= &quot;</span> + i);            list.add(emp);        &#125;        <span class="hljs-keyword">return</span> list;    &#125;&#125;<span class="hljs-comment">// 管理学校员工类</span><span class="hljs-comment">//分析 SchoolManager 类的直接朋友类有哪些 Employee、CollegeManager </span><span class="hljs-comment">//CollegeEmployee 不是 直接朋友 而是一个陌生类，这样违背了 迪米特法则</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SchoolManager</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Employee&gt; <span class="hljs-title">getAllEmployee</span><span class="hljs-params">()</span> </span>&#123;        List&lt;Employee&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Employee&gt;();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;            Employee emp = <span class="hljs-keyword">new</span> Employee();            emp.setId(<span class="hljs-string">&quot;学院员工id= &quot;</span> + i);            list.add(emp);        &#125;        <span class="hljs-keyword">return</span> list;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printAllEmployee</span><span class="hljs-params">(CollegeManager sub)</span> </span>&#123;                <span class="hljs-comment">//分析问题</span>                <span class="hljs-comment">//1. 这里的 CollegeEmployee 不是 SchoolManager 的直接朋友 </span>        <span class="hljs-comment">//2. CollegeEmployee 是以局部变量方式出现在 SchoolManager</span>        <span class="hljs-comment">//3. 违反了 迪米特法则</span>        List&lt;CollegeEmployee&gt; list1 = sub.getAllEmployee();        System.out.println(<span class="hljs-string">&quot;------------学院总部------------&quot;</span>);        <span class="hljs-keyword">for</span> (CollegeEmployee e : list1) &#123;            System.out.println(e.getId());        &#125;        List&lt;Employee&gt; list2 = <span class="hljs-keyword">this</span>.getAllEmployee();        System.out.println(<span class="hljs-string">&quot;------------学校总部------------&quot;</span>);        <span class="hljs-keyword">for</span> (Employee e : list2) &#123;            System.out.println(e.getId());        &#125;    &#125;&#125;</code></pre><h4 id="应用实例改进"><a href="#应用实例改进" class="headerlink" title="应用实例改进"></a>应用实例改进</h4><ol><li><p>前面设计的问题在于SchoolManager中，<strong>CollegeEmployee</strong>类并不是<strong>SchoolManager</strong>类的直接朋友(分析) </p></li><li><p>按照迪米特法则，应该避免类中出现这样非直接朋友关系的耦合</p></li></ol><pre><code class="hljs java"><span class="hljs-comment">//迪米特法则</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demeter1</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SchoolManager schoolManager = <span class="hljs-keyword">new</span> SchoolManager();        schoolManager.printAllEmployee(<span class="hljs-keyword">new</span> CollegeManager());    &#125;&#125;<span class="hljs-comment">// 学校总部员工</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span> </span>&#123;    <span class="hljs-keyword">private</span> String id;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(String id)</span> </span>&#123;        <span class="hljs-keyword">this</span>.id = id;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> id;    &#125;&#125;<span class="hljs-comment">// 学院员工</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CollegeEmployee</span> </span>&#123;    <span class="hljs-keyword">private</span> String id;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(String id)</span> </span>&#123;        <span class="hljs-keyword">this</span>.id = id;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> id;    &#125;&#125;<span class="hljs-comment">// 管理学院员工类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CollegeManager</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;CollegeEmployee&gt; <span class="hljs-title">getAllEmployee</span><span class="hljs-params">()</span> </span>&#123;        List&lt;CollegeEmployee&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;CollegeEmployee&gt;();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;            CollegeEmployee emp = <span class="hljs-keyword">new</span> CollegeEmployee();            emp.setId(<span class="hljs-string">&quot;学校员工id= &quot;</span> + i);            list.add(emp);        &#125;        <span class="hljs-keyword">return</span> list;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printAllCollegeEmployee</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-comment">// 将输出转移到CollegeManager类中</span>        List&lt;CollegeEmployee&gt; list1 = <span class="hljs-keyword">this</span>.getAllEmployee();        System.out.println(<span class="hljs-string">&quot;------------学院总部------------&quot;</span>);        <span class="hljs-keyword">for</span> (CollegeEmployee e : list1) &#123;            System.out.println(e.getId());        &#125;    &#125;&#125;<span class="hljs-comment">// 管理学校员工类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SchoolManager</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Employee&gt; <span class="hljs-title">getAllEmployee</span><span class="hljs-params">()</span> </span>&#123;        List&lt;Employee&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Employee&gt;();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;            Employee emp = <span class="hljs-keyword">new</span> Employee();            emp.setId(<span class="hljs-string">&quot;学院员工id= &quot;</span> + i);            list.add(emp);        &#125;        <span class="hljs-keyword">return</span> list;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printAllEmployee</span><span class="hljs-params">(CollegeManager sub)</span> </span>&#123;        <span class="hljs-comment">// 将输出转移到CollegeManager类中</span>        sub.printAllCollegeEmployee();        List&lt;Employee&gt; list2 = <span class="hljs-keyword">this</span>.getAllEmployee();        System.out.println(<span class="hljs-string">&quot;------------学校总部------------&quot;</span>);        <span class="hljs-keyword">for</span> (Employee e : list2) &#123;            System.out.println(e.getId());        &#125;    &#125;&#125;</code></pre><h4 id="迪米特法则注意事项和细节"><a href="#迪米特法则注意事项和细节" class="headerlink" title="迪米特法则注意事项和细节"></a>迪米特法则注意事项和细节</h4><ol><li>迪米特法则的核心是 <strong>降低类之间的耦合</strong></li><li>但是注意:由于每个类都减少了不必要的依赖，因此迪米特法则 <strong>只是要求降低类间(对象间)耦合关系，并不是要求完全没有依赖关系</strong></li></ol><h3 id="合成复用原则-Composite-Reuse-Principle"><a href="#合成复用原则-Composite-Reuse-Principle" class="headerlink" title="合成复用原则(Composite Reuse Principle)"></a>合成复用原则(Composite Reuse Principle)</h3><h4 id="基本介绍-6"><a href="#基本介绍-6" class="headerlink" title="基本介绍"></a>基本介绍</h4><blockquote><p>原则是尽量使用合成/聚合的方式，而不是使用继承</p></blockquote><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201202110642.png" alt="不使用继承" style="zoom:50%;" /><h4 id="设计原则核心思想"><a href="#设计原则核心思想" class="headerlink" title="设计原则核心思想"></a>设计原则核心思想</h4><ol><li><p>找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。 </p></li><li><p>针对 <strong>接口编程</strong>，而不是针对实现编程。</p></li><li><p>为了交互对象之间的 <strong>松耦合设计而努力</strong></p></li></ol><h2 id="UML-基本介绍"><a href="#UML-基本介绍" class="headerlink" title="UML 基本介绍"></a>UML 基本介绍</h2><ul><li><p>UML——Unified modeling language UML (统一建模语言)，是一种用于软件系统分析和设计的语言工具，它用 于帮助软件开发人员进行思考和记录思路的结果</p></li><li><p>UML 本身是一套符号的规定，就像数学符号和化学符号一样，这些符号用于描述软件模型中的各个元素和他 们之间的关系，比如类、接口、实现、泛化、依赖、组合、聚合等，如右图:</p></li></ul><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201202111756.png" alt="test" style="zoom:50%;" /><h3 id="类图—依赖关系-Dependence"><a href="#类图—依赖关系-Dependence" class="headerlink" title="类图—依赖关系(Dependence)"></a>类图—依赖关系(Dependence)</h3><blockquote><p>只要是在类中用到了对方，那么他们之间就存在依赖关系。如果没有对方，连编绎都通过不了。</p></blockquote><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201202112951.png" alt="依赖"></p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201202113519.png" alt="依赖关系" style="zoom:50%;" /><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PersonServiceBean</span> </span>&#123;<span class="hljs-keyword">private</span> PersonDao personDao;<span class="hljs-comment">//类 public void save(Person person)&#123;&#125;</span><span class="hljs-function"><span class="hljs-keyword">public</span> IDCard <span class="hljs-title">getIDCard</span><span class="hljs-params">(Integer personid)</span></span>&#123;&#125; <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">modify</span><span class="hljs-params">()</span></span>&#123;Department department = <span class="hljs-keyword">new</span> Department(); &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PersonDao</span></span>&#123;&#125; <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IDCard</span></span>&#123;&#125; <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;&#125; <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Department</span></span>&#123;&#125;</code></pre><pre><code class="hljs plain">1) 类中用到了对方2) 如果是类的成员属性 3) 如果是方法的返回类型 4) 是方法接收的参数类型 5) 方法中使用到</code></pre><h3 id="类图—泛化关系-generalization"><a href="#类图—泛化关系-generalization" class="headerlink" title="类图—泛化关系(generalization)"></a>类图—泛化关系(generalization)</h3><blockquote><p>泛化关系实际上就是继承关系，他是依赖关系的特例</p></blockquote><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201202113350.png" alt="依赖关系" style="zoom:50%;" /><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201202113543.png" alt="泛化关系" style="zoom:50%;" /><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DaoSupport</span></span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">save</span><span class="hljs-params">(Object entity)</span></span>&#123; &#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delete</span><span class="hljs-params">(Object id)</span></span>&#123;&#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PersonServiceBean</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Daosupport</span></span>&#123; &#125;</code></pre><pre><code class="hljs dns"><span class="hljs-number">1</span>) 泛化关系实际上就是继承关系<span class="hljs-number">2</span>) 如果<span class="hljs-keyword">A</span>类继承了B类，我们就说<span class="hljs-keyword">A</span>和B存在泛化关系</code></pre><h3 id="类图—实现关系-Implementation"><a href="#类图—实现关系-Implementation" class="headerlink" title="类图—实现关系(Implementation)"></a>类图—实现关系(Implementation)</h3><p>实现关系实际上就是 <strong>A</strong> 类实现 <strong>B</strong> 接口，他是 <strong>依赖关系的特例</strong></p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201202113728.png" alt="实现关系" style="zoom:50%;" /><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201202113745.png" alt="实现关系" style="zoom:50%;" /><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">PersonService</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delete</span><span class="hljs-params">(Interger id)</span></span>;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PersonServiceBean</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">PersonService</span> </span>&#123; <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delete</span><span class="hljs-params">(Interger id)</span></span>&#123;&#125;&#125;</code></pre><h3 id="类图—关联关系-Association"><a href="#类图—关联关系-Association" class="headerlink" title="类图—关联关系(Association)"></a>类图—关联关系(Association)</h3><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201202113841.png" alt="关联关系" style="zoom:67%;" /><h3 id="类图—聚合关系-Aggregation"><a href="#类图—聚合关系-Aggregation" class="headerlink" title="类图—聚合关系(Aggregation)"></a>类图—聚合关系(Aggregation)</h3><h4 id="基本介绍-7"><a href="#基本介绍-7" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>聚合关系(Aggregation)表示的是整体和部分的关系，整体与部分可以分开。聚合关系是关联关系的特例，所以他具有 <strong>关联的导航性与多重性</strong>。</p><p>如:一台电脑由键盘(keyboard)、显示器(monitor)，鼠标等组成;组成电脑的各个配件是可以从电脑上分离出来 的，使用带空心菱形的实线来表示:</p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201202114201.png" alt="聚合" style="zoom:50%;" /><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201202114230.png" alt="聚合" style="zoom:50%;" /><h3 id="类图—组合关系-Composition"><a href="#类图—组合关系-Composition" class="headerlink" title="类图—组合关系(Composition)"></a>类图—组合关系(Composition)</h3><h4 id="基本介绍-8"><a href="#基本介绍-8" class="headerlink" title="基本介绍"></a>基本介绍</h4><blockquote><p>组合关系:也是整体与部分的关系，但是整体与部分 <strong><em>不可以分开</em></strong>。</p></blockquote><p>再看一个案例:在程序中我们定义实体:Person 与 IDCard、Head, 那么 Head 和 Person 就是 组合，IDCard 和 Person 就是聚合。</p><p>但是如果在程序中 Person 实体中定义了对 IDCard 进行级联删除，即删除 Person 时连同 IDCard 一起删除，那 么 IDCard 和 Person 就是组合了.</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;    <span class="hljs-keyword">private</span> IDCard card;     <span class="hljs-keyword">private</span> Head head = <span class="hljs-keyword">new</span> Head(); <span class="hljs-comment">// 注意区别</span>&#125;</code></pre><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201202114443.png" alt="组合" style="zoom:50%;" /><p>如果把聚合案例代码改成:</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Computer</span> </span>&#123;<span class="hljs-keyword">private</span> Mouse mouse = <span class="hljs-keyword">new</span> Mouse(); <span class="hljs-comment">//鼠标可以和 computer 不能分离 </span><span class="hljs-keyword">private</span> Moniter moniter = <span class="hljs-keyword">new</span> Moniter();<span class="hljs-comment">//显示器可以和 Computer 不能分离</span>&#125;</code></pre><h2 id="设计模式介绍"><a href="#设计模式介绍" class="headerlink" title="设计模式介绍"></a>设计模式介绍</h2><ol><li>设计模式是程序员在面对同类软件工程设计问题所总结出来的有用的经验， <strong>模式不是代码</strong>，而是某类问题的通 用解决方案， <strong>设计模式(Design pattern)代表了最佳的实践</strong>。这些解决方案是众多软件开发人员经过相当长的 一段时间的试验和错误总结出来的。</li><li>设计模式的本质 <strong>提高软件的维护性，通用性和扩展性，并降低软件的复杂度</strong>。</li><li>&lt;&lt;设计模式&gt;&gt; 是经典的书，作者是 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides Design(俗称 “四人组 GOF”)</li><li>设计模式并 <strong>不局限于某种语言</strong>，java，php，c++ 都有设计模式.</li></ol><h2 id="设计模式类型"><a href="#设计模式类型" class="headerlink" title="设计模式类型"></a>设计模式类型</h2><blockquote><p>设计模式分为三种类型，共 <strong>23</strong> 种</p></blockquote><ol><li><p>创建型模式: <strong><em>单例模式</em></strong>、抽象工厂模式、原型模式、建造者模式、 <strong><em>工厂模式</em></strong>。</p></li><li><p>结构型模式:适配器模式、桥接模式、 <strong><em>装饰模式</em></strong>、组合模式、外观模式、享元模式、 <strong><em>代理模式</em></strong>。</p></li><li><p>行为型模式:模版方法模式、命令模式、访问者模式、迭代器模式、 <strong><em>观察者模式</em></strong>、中介者模式、备忘录模式、 解释器模式(Interpreter 模式)、状态模式、策略模式、职责链模式(责任链模式)。</p></li></ol><p>注意: <strong>不同的书籍上对分类和名称略有差别</strong></p><h1 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h1><h2 id="单例设计模式介绍"><a href="#单例设计模式介绍" class="headerlink" title="单例设计模式介绍"></a>单例设计模式介绍</h2><blockquote><p>所谓类的单例设计模式, 就是 **采取一定的方法保证在整个的软件系统中, 对某一个类只能存在一个对象实例, 并且该类只提供一个取得其对象实例的方法(静态方法)**。</p></blockquote><p>​       比如 Hibernate 的 SessionFactory，它充当数据存储源的代理，并负责创建 Session 对象。SessionFactory 并不是 轻量级的，一般情况下，一个项目通常只需要一个 SessionFactory 就够，这是就会使用到单例模式。</p><h2 id="单例设计模式八种方式"><a href="#单例设计模式八种方式" class="headerlink" title="单例设计模式八种方式"></a>单例设计模式八种方式</h2><p><strong>1) 饿汉式(静态常量)</strong></p><p><strong>2) 饿汉式(静态代码块)</strong></p><ol start="3"><li><p>懒汉式(线程不安全)</p></li><li><p>懒汉式(线程安全，同步方法) </p></li><li><p>懒汉式(线程不安全，同步代码块) </p></li></ol><p> <strong>6) 双重检查</strong></p><p> <strong>7) 静态内部类</strong></p><p> <strong>8) 枚举</strong></p><h3 id="饿汉式-静态常量"><a href="#饿汉式-静态常量" class="headerlink" title="饿汉式(静态常量)"></a>饿汉式(静态常量)</h3><ol><li>构造器私有化 (防止 new )</li><li>类的内部创建对象</li><li>向外暴露一个静态的公共方法。getInstance </li></ol><p>代码实现:</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 饿汉式(静态常量)实现单例模式</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonTest</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Singleton singleton1 = Singleton.getInstance();        Singleton singleton2 = Singleton.getInstance();        System.out.println(singleton1 == singleton2); <span class="hljs-comment">// true</span>        System.out.println(<span class="hljs-string">&quot;singleton1.hashCode():&quot;</span>+singleton1.hashCode());        System.out.println(<span class="hljs-string">&quot;singleton2.hashCode():&quot;</span>+singleton2.hashCode());        <span class="hljs-comment">//singleton1.hashCode():1639705018</span>        <span class="hljs-comment">//singleton2.hashCode():1639705018</span>    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span></span>&#123;    <span class="hljs-comment">// 1. 构造器私有化</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span></span>&#123;&#125;    <span class="hljs-comment">// 2. 本类内部创建对象实例</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton instance = <span class="hljs-keyword">new</span> Singleton();    <span class="hljs-comment">// 3. 提供公有的静态方法返回实例对象</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> instance;    &#125;&#125;</code></pre><ol><li><p>优点:这种写法比较简单，就是在 <strong>类装载的时候就完成实例化</strong>。 <strong>避免了线程同步问题</strong>。</p></li><li><p>缺点:在类装载的时候就完成实例化，<strong>没有达到LazyLoading的效果</strong>。如果从始至终从未使用过这个实例，则</p><p>会造成内存的浪费</p></li><li><p>这种方式基于classloder机制避免了多线程的同步问题，不过，instance在类装载时就实例化，在单例模式中大多数都是调用 getInstance 方法，但是 <strong>导致类装载的原因有很多种</strong>，因此不能确定有其他的方式(或者其他的静态方法)导致类装载，这时候初始化 instance 就 <strong>没有达到 lazy loading 的效果</strong></p></li></ol><p>结论:这种单例模式 <strong><em>可用</em></strong>，可能造成 <strong><em>内存浪费</em></strong></p><h3 id="饿汉式-静态代码块"><a href="#饿汉式-静态代码块" class="headerlink" title="饿汉式(静态代码块)"></a>饿汉式(静态代码块)</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonTest</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Singleton singleton1 = Singleton.getInstance();        Singleton singleton2 = Singleton.getInstance();        System.out.println(singleton1 == singleton2); <span class="hljs-comment">// true</span>        System.out.println(<span class="hljs-string">&quot;singleton1.hashCode():&quot;</span>+singleton1.hashCode());        System.out.println(<span class="hljs-string">&quot;singleton2.hashCode():&quot;</span>+singleton2.hashCode());        <span class="hljs-comment">//singleton1.hashCode():1639705018</span>        <span class="hljs-comment">//singleton2.hashCode():1639705018</span>    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span></span>&#123;    <span class="hljs-comment">// 1.构造器私有化</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span></span>&#123;&#125;    <span class="hljs-comment">// 2.类中创建对象事例</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;    <span class="hljs-keyword">static</span> &#123;        <span class="hljs-comment">// 静态代码块中创建事例</span>        instance = <span class="hljs-keyword">new</span> Singleton();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> instance;&#125;&#125;</code></pre><ol><li>这种方式和上面的方式其实类似，只不过将类实例化的过程放在了静态代码块中，也是在类装载的时候，就执行静态代码块中的代码，初始化类的实例。优缺点和上面是一样的。</li></ol><p>结论:这种单例模式可用，但是可能造成内存浪费</p><h3 id="懒汉式-线程不安全"><a href="#懒汉式-线程不安全" class="headerlink" title="懒汉式(线程不安全)"></a>懒汉式(线程不安全)</h3><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 懒汉式(线程不安全写法)</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonTest</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Singleton singleton1 = Singleton.getInstance();        Singleton singleton2 = Singleton.getInstance();        System.out.println(singleton1 == singleton2); <span class="hljs-comment">// true</span>        System.out.println(<span class="hljs-string">&quot;singleton1.hashCode():&quot;</span>+singleton1.hashCode());        System.out.println(<span class="hljs-string">&quot;singleton2.hashCode():&quot;</span>+singleton2.hashCode());        <span class="hljs-comment">// singleton1.hashCode():1639705018</span>        <span class="hljs-comment">// singleton2.hashCode():1639705018</span>    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span></span>&#123;&#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;    <span class="hljs-comment">// 构造一个静态方法, 当用到该方法时, 才创建实例</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>)&#123;            instance = <span class="hljs-keyword">new</span> Singleton();        &#125;        <span class="hljs-keyword">return</span> instance;    &#125;&#125;</code></pre><ol><li><p>起到了 <strong>LazyLoading</strong>的效果，但是只能在 <strong>单线程</strong>下使用。</p></li><li><p>如果在多线程下，一个线程进入了if(singleton==null)判断语句块，还未来得及往下执行，另一个线程也通过</p><p>了这个判断语句，这时便会产生 <strong>多个实例</strong>。所以在多线程环境下不可使用这种方式 </p></li></ol><p>​   结论:在实际开发中，<strong>不要使用这种方式</strong>.</p><h3 id="懒汉式-线程安全，同步方法"><a href="#懒汉式-线程安全，同步方法" class="headerlink" title="懒汉式(线程安全，同步方法)"></a>懒汉式(线程安全，同步方法)</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span></span>&#123;&#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>)&#123;            instance = <span class="hljs-keyword">new</span> Singleton();        &#125;        <span class="hljs-keyword">return</span> instance;    &#125;&#125;</code></pre><ol><li><p><strong>解决了线程安全问题</strong></p></li><li><p><strong>效率太低</strong>了，每个线程在想获得类的实例时候，执行getInstance()方法 <strong>都要进行同步</strong>。而其实这个方法只执行一次实例化代码就够了，后面的想获得该类实例，直接 return 就行了。方法进行同步效率太低 </p><p>结论:在实际开发中，<strong>不推荐使用这种方式</strong></p></li></ol><h3 id="懒汉式-线程不安全，同步代码块"><a href="#懒汉式-线程不安全，同步代码块" class="headerlink" title="懒汉式(线程不安全，同步代码块)"></a>懒汉式(线程不安全，同步代码块)</h3><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201202150123.png" alt="无效" style="zoom:50%;" /><p>​   在这里加入synchronized无效, 无法解决线程安全问题, 一个线程进入了if(singleton==null)判断语句块, 还未来得及往下执行, 另一个线程也通过了这个判断语句, 这时便会产生 <strong>多个实例</strong>。</p><h3 id="双重检查"><a href="#双重检查" class="headerlink" title="双重检查"></a>双重检查</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span></span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Singleton instance;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span></span>&#123;&#125;    <span class="hljs-comment">// 提供一个静态代码块，双重检查，解决线程安全问题，同时解决懒加载问题</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">synchronized</span> (Singleton.class)&#123;                <span class="hljs-keyword">if</span>(instance == <span class="hljs-keyword">null</span>)&#123;                    instance = <span class="hljs-keyword">new</span> Singleton();                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> instance;    &#125;&#125;</code></pre><ol><li>Double-Check 概念是多线程开发中常使用到的，如代码中所示，我们进行了两次 if (singleton == null)检查，这 样就可以保证线程安全了。</li><li>这样，实例化代码只用执行一次，后面再次访问时，判断if(singleton==null)，直接return实例化对象，也避免的反复进行方法同步.</li><li><strong>线程安全; 延迟加载;效率较高</strong></li></ol><p>结论:在实际开发中， <strong>推荐使用这种单例设计模式</strong></p><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><blockquote><p>JVM装载类的时候线程是安全的</p></blockquote><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span></span>&#123;&#125;    <span class="hljs-comment">// 写一个静态内部类，该类中有一个静态属性Singleton</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonInstance</span></span>&#123;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton INSTANCE = <span class="hljs-keyword">new</span> Singleton();    &#125;    <span class="hljs-comment">// 提供一个静态公有方法，返回SingletonInstance.INSTANCE</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> SingletonInstance.INSTANCE;    &#125;&#125;</code></pre><ol><li><p>这种方式采用了 <strong>类装载的机制</strong>来保证初始化实例时只有一个线程。(因为类装载是线程安全的)</p></li><li><p>  <strong>静态内部类方式在Singleton类被装载时并不会立即实例化</strong>，而是在需要实例化时， <strong>调用getInstance方法</strong>， <strong>才会装载 SingletonInstance 类</strong>，从而完成 Singleton 的实例化。</p></li><li><p> 类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM帮助我们保证了线程的安全性，在类进行   初始化时，别的线程是无法进入的。</p></li><li><p> 优点: <strong>避免了线程不安全，利用静态内部类特点实现延迟加载，效率高</strong></p></li><li><p> 结论: <strong>推荐</strong>使用.</p></li></ol><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Singleton</span></span>&#123;    INSTANCE;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayOK</span><span class="hljs-params">()</span></span>&#123;        System.out.println(<span class="hljs-string">&quot;ok!&quot;</span>);    &#125;&#125;</code></pre><p>使用:</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    Singleton instance = Singleton.INSTANCE;    Singleton instance2 = Singleton.INSTANCE;    System.out.println(instance == instance2);    System.out.println(instance.hashCode());    System.out.println(instance2.hashCode());    instance.sayOK(); &#125;</code></pre><ol><li><p> 这 <strong>借助JDK1.5中添加的枚举</strong>来实现单例模式。不仅能 <strong>避免多线程同步问题，而且还能防止反序列化重新创建 新的对象</strong>。</p></li><li><p> 这种方式是<strong>EffectiveJava</strong>作者<strong>JoshBloch</strong>提倡的方式</p></li></ol><p>​    结论: <strong>推荐</strong>使用</p>]]></content>
    
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java并发编程 学习笔记</title>
    <link href="/2020/11/27/Java%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    <url>/2020/11/27/Java%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1、进程与线程"><a href="#1、进程与线程" class="headerlink" title="1、进程与线程"></a>1、进程与线程</h2><h3 id="1-1、概念"><a href="#1-1、概念" class="headerlink" title="1.1、概念"></a>1.1、概念</h3><blockquote><p> 进程</p></blockquote><ul><li>程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至 CPU，数据加载至内存。在 指令运行过程中还需要用到磁盘、网络等设备。进程就是用来加载指令、管理内存、管理 IO 的 </li><li>当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。 </li><li>进程就可以视为程序的一个实例。大部分程序可以同时运行多个实例进程(例如记事本、画图、浏览器 等)，也有的程序只能启动一个实例进程(例如网易云音乐、360 安全卫士等)</li></ul><blockquote><p>线程</p></blockquote><ul><li>一个进程之内可以分为一到多个线程。 </li><li>一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给 CPU 执行</li><li>Java 中，线程作为最小调度单位，进程作为资源分配的最小单位。 在 windows 中进程是不活动的，只是作为线程的容器</li></ul><blockquote><p>二者对比</p></blockquote><ul><li><p>进程基本上相互独立的，而线程存在于进程内，是进程的一个子集</p></li><li><p>进程拥有共享的资源，如内存空间等，供其内部的线程共享</p></li><li><p>进程间通信较为复杂</p><ul><li>同一台计算机的进程通信称为 IPC(Inter-process communication) </li><li>不同计算机之间的进程通信，需要通过网络，并遵守共同的协议，例如 HTTP</li></ul></li><li><p>线程通信相对简单，因为它们共享进程内的内存，一个例子是多个线程可以访问同一个共享变量</p></li><li><p>线程更轻量，线程上下文切换成本一般上要比进程上下文切换低</p></li></ul><h3 id="1-2-并行与并发"><a href="#1-2-并行与并发" class="headerlink" title="1.2 并行与并发"></a>1.2 并行与并发</h3><blockquote><p>并发</p></blockquote><p>单核 cpu 下，线程实际还是 <strong><em>串行执行</em></strong> 的。操作系统中有一个组件叫做 <strong><em>任务调度器</em></strong>，将 cpu 的时间片(windows 下时间片最小约为 15 毫秒)分给不同的程序使用，只是由于 cpu 在线程间(时间片很短)的切换非常快，人类感 觉是 同时运行的 。总结为一句话就是: <strong><em>微观串行，宏观并行</em></strong> ，</p><p>一般会将这种 <strong><em>线程轮流使用 CPU</em></strong> 的做法称为 <strong><em>并发</em></strong>， concurrent</p><table><thead><tr><th align="center">CPU</th><th>时间片1</th><th>时间片2</th><th>时间片3</th><th>时间片4</th></tr></thead><tbody><tr><td align="center">core</td><td>线程1</td><td>线程2</td><td>线程3</td><td>线程4</td></tr></tbody></table><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201127140415.png" alt="执行" style="zoom:33%;" /><blockquote><p>并行</p></blockquote><p>多核 cpu下，每个 核(core) 都可以调度运行线程，这时候线程可以是并行的。</p><table><thead><tr><th align="center">CPU</th><th>时间片1</th><th>时间片2</th><th>时间片3</th><th>时间片4</th></tr></thead><tbody><tr><td align="center">Core1</td><td>线程1</td><td>线程1</td><td>线程3</td><td>线程3</td></tr><tr><td align="center">Core2</td><td>线程2</td><td>线程4</td><td>线程2</td><td>线程4</td></tr></tbody></table><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201127140834.png" alt="执行" style="zoom:33%;" /><p>引用 Rob Pike (golang 创始人)的一段描述: </p><ul><li><p><strong>并发(concurrent)是同一时间应对(dealing with)多件事情的能力</strong></p></li><li><p><strong>并行(parallel)是同一时间动手做(doing)多件事情的能力</strong></p></li></ul><blockquote><p>例子</p></blockquote><ul><li><p>家庭主妇做饭、打扫卫生、给孩子喂奶，她一个人轮流交替做这多件事，这时就是并发</p></li><li><p>家庭主妇雇了个保姆，她们一起这些事，这时既有并发，也有并行(这时会产生竞争，例如锅只有一口，一<br>  个人用锅时，另一个人就得等待)</p></li><li><p>雇了3个保姆，一个专做饭、一个专打扫卫生、一个专喂奶，互不干扰，这时是并行</p></li></ul><h3 id="1-3、应用"><a href="#1-3、应用" class="headerlink" title="1.3、应用"></a>1.3、应用</h3><blockquote><p>应用之异步调用(案例1)</p></blockquote><p>以调用方角度来讲，如果</p><ul><li>需要等待结果返回，才能继续运行就是同步</li><li>不需要等待结果返回，就能继续运行就是异步</li></ul><ol><li>设计<br>多线程可以让方法执行变为异步的(即不要巴巴干等着)比如说读取磁盘文件时，假设读取操作花费了 5 秒钟，如</li></ol><p>果没有线程调度机制，这 5 秒 cpu 什么都做不了，其它代码都得暂停…</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201127144136.png" alt="同步"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201127144618.png" alt="异步"></p><ol start="2"><li>结论</li></ol><ul><li>比如在项目中，视频文件需要转换格式等操作比较费时，这时开一个新线程处理视频转换，避免阻塞主线程 - </li><li>tomcat 的异步 servlet 也是类似的目的，让用户线程处理耗时较长的操作，避免阻塞 tomcat 的工作线程 </li><li>ui 程序中，开线程进行其他操作，避免阻塞 ui 线程</li></ul><blockquote><p>应用之提高效率(案例1)</p></blockquote><p>充分利用多核 cpu 的优势，提高运行效率。想象下面的场景，执行 3 个计算，最后将计算结果汇总。</p><pre><code class="hljs crmsh">计算 <span class="hljs-number">1</span> 花费 <span class="hljs-number">10</span> <span class="hljs-keyword">ms</span> <span class="hljs-title"></span><span class="hljs-title">计算 2</span> 花费 <span class="hljs-number">11</span> <span class="hljs-keyword">ms</span> <span class="hljs-title"></span><span class="hljs-title">计算 3</span> 花费 <span class="hljs-number">9</span> <span class="hljs-keyword">ms</span> <span class="hljs-title"></span><span class="hljs-title">汇总需要 1</span> ms</code></pre><ul><li>如果是串行执行，那么总共花费的时间是 10 + 11 + 9 + 1 = 31ms</li><li> 但如果是四核 cpu，各个核心分别使用线程 1 执行计算 1，线程 2 执行计算 2，线程 3 执行计算 3，那么 3 个 线程是并行的，花费时间只取决于最长的那个线程运行的时间，即 11ms 最后加上汇总时间只会花费 12ms</li></ul><p><strong><em>注意</em></strong>:<strong><em>需要在多核 cpu 才能提高效率，单核仍然时是轮流执行</em></strong></p><hr><h4 id="1-3、效率案例"><a href="#1-3、效率案例" class="headerlink" title="1.3、效率案例"></a>1.3、效率案例</h4><blockquote><p>// TODO JMH测试</p></blockquote><p>1)设计代码:</p><pre><code class="hljs java"><span class="hljs-meta">@Fork(1)</span><span class="hljs-meta">@BenchmarkMode(Mode.AverageTime)</span><span class="hljs-meta">@Warmup(iterations=3)</span><span class="hljs-meta">@Measurement(iterations=5)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBenchmark</span> </span>&#123;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] ARRAY = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">1000_000_00</span>];    <span class="hljs-keyword">static</span> &#123;        Arrays.fill(ARRAY, <span class="hljs-number">1</span>);    &#125;    <span class="hljs-meta">@Benchmark</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">c</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-keyword">int</span>[] array = ARRAY;        FutureTask&lt;Integer&gt; t1 = <span class="hljs-keyword">new</span> FutureTask&lt;&gt;(()-&gt;&#123;            <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">250_000_00</span>;i++) &#123;                sum += array[<span class="hljs-number">0</span>+i];            &#125;            <span class="hljs-keyword">return</span> sum;        &#125;);        FutureTask&lt;Integer&gt; t2 = <span class="hljs-keyword">new</span> FutureTask&lt;&gt;(()-&gt;&#123;            <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">250_000_00</span>;i++) &#123;                sum += array[<span class="hljs-number">250_000_00</span>+i];            &#125;            <span class="hljs-keyword">return</span> sum;        &#125;);        FutureTask&lt;Integer&gt; t3 = <span class="hljs-keyword">new</span> FutureTask&lt;&gt;(()-&gt;&#123;            <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">250_000_00</span>;i++) &#123;                sum += array[<span class="hljs-number">500_000_00</span>+i];            &#125;            <span class="hljs-keyword">return</span> sum;        &#125;);        FutureTask&lt;Integer&gt; t4 = <span class="hljs-keyword">new</span> FutureTask&lt;&gt;(()-&gt;&#123;            <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">250_000_00</span>;i++) &#123;                sum += array[<span class="hljs-number">750_000_00</span>+i];            &#125;            <span class="hljs-keyword">return</span> sum;        &#125;);        <span class="hljs-keyword">new</span> Thread(t1).start();        <span class="hljs-keyword">new</span> Thread(t2).start();        <span class="hljs-keyword">new</span> Thread(t3).start();        <span class="hljs-keyword">new</span> Thread(t4).start();        <span class="hljs-keyword">return</span> t1.get() + t2.get() + t3.get()+ t4.get();    &#125;    <span class="hljs-meta">@Benchmark</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">d</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-keyword">int</span>[] array = ARRAY;        FutureTask&lt;Integer&gt; t1 = <span class="hljs-keyword">new</span> FutureTask&lt;&gt;(()-&gt;&#123;            <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000_000_00</span>;i++) &#123;                sum += array[<span class="hljs-number">0</span>+i];            &#125;            <span class="hljs-keyword">return</span> sum;        &#125;);        <span class="hljs-keyword">new</span> Thread(t1).start();        <span class="hljs-keyword">return</span> t1.get();    &#125;&#125;</code></pre><p>测试结果:</p><blockquote><p>多核</p></blockquote><pre><code class="hljs apache"><span class="hljs-attribute">Benchmark</span> Mode Samples Score Score error Units <span class="hljs-attribute">o</span>.s.MyBenchmark.c avgt <span class="hljs-number">5</span> <span class="hljs-number">0</span>.<span class="hljs-number">020</span> <span class="hljs-number">0</span>.<span class="hljs-number">001</span> s/op <span class="hljs-attribute">o</span>.s.MyBenchmark.d avgt <span class="hljs-number">5</span> <span class="hljs-number">0</span>.<span class="hljs-number">043</span> <span class="hljs-number">0</span>.<span class="hljs-number">003</span> s/op</code></pre><blockquote><p>单核</p></blockquote><pre><code class="hljs apache"><span class="hljs-attribute">Benchmark</span> Mode Samples Score Score error Units <span class="hljs-attribute">o</span>.s.MyBenchmark.c avgt <span class="hljs-number">5</span> <span class="hljs-number">0</span>.<span class="hljs-number">061</span> <span class="hljs-number">0</span>.<span class="hljs-number">060</span> s/op <span class="hljs-attribute">o</span>.s.MyBenchmark.d avgt <span class="hljs-number">5</span> <span class="hljs-number">0</span>.<span class="hljs-number">064</span> <span class="hljs-number">0</span>.<span class="hljs-number">071</span> s/op</code></pre><p>2)结论:</p><ul><li><p>单核 cpu 下，多线程不能实际提高程序运行效率，只是为了能够在不同的任务之间切换，不同线程轮流使用 cpu ，不至于一个线程总占用 cpu，别的线程没法干活</p></li><li><p>多核 cpu 可以并行跑多个线程，但能否提高程序运行效率还是要分情况的</p><ul><li>有些任务，经过精心设计，将任务拆分，并行执行，当然可以提高程序的运行效率。但不是所有计算任<br> 务都能拆分(参考后文的 <strong><em>【阿姆达尔定律】</em></strong>)</li><li> 也不是所有任务都需要拆分，任务的目的如果不同，谈拆分和效率没啥意义</li></ul></li><li><p>IO 操作不占用 cpu，只是我们一般拷贝文件使用的是 <strong><em>【阻塞 IO】</em></strong>，这时相当于线程虽然不用 cpu，但需要一 直等待 IO 结束，没能充分利用线程。所以才有后面的 <strong><em>【非阻塞 IO】</em></strong>和 <strong><em>【异步 IO】</em></strong>优化</p></li></ul><h2 id="2、Java-线程"><a href="#2、Java-线程" class="headerlink" title="2、Java 线程"></a>2、Java 线程</h2><h3 id="2-1、创建和运行线程"><a href="#2-1、创建和运行线程" class="headerlink" title="2.1、创建和运行线程"></a>2.1、创建和运行线程</h3><h4 id="方法一-直接使用Thread"><a href="#方法一-直接使用Thread" class="headerlink" title="方法一, 直接使用Thread"></a>方法一, 直接使用Thread</h4><pre><code class="hljs java"><span class="hljs-comment">// 创建线程对象</span>Thread t = <span class="hljs-keyword">new</span> Thread()&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 要执行的任务</span>    &#125;&#125;;t.setName(<span class="hljs-string">&quot;t0&quot;</span>);<span class="hljs-comment">// 启动线程</span>t.start();</code></pre><p>例如:</p><pre><code class="hljs java"><span class="hljs-comment">// 构造方法的参数是给线程指定名字，推荐 </span>Thread t1 = <span class="hljs-keyword">new</span> Thread(<span class="hljs-string">&quot;t1&quot;</span>)&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        log.info(<span class="hljs-string">&quot;hello&quot;</span>);    &#125;&#125;;t1.start();</code></pre><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201127161656.png" alt="test" style="zoom:50%;" /><h4 id="方法二-使用Runnable配合thread"><a href="#方法二-使用Runnable配合thread" class="headerlink" title="方法二, 使用Runnable配合thread"></a>方法二, 使用Runnable配合thread</h4><p>把【线程】和【任务】(要执行的代码)分开</p><ul><li>Thread 代表线程</li><li>Runnable 可运行的任务(线程要执行的代码)</li></ul><pre><code class="hljs java">Runnable runnable = <span class="hljs-keyword">new</span> Runnable() &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 要执行的任务</span>        log.debug(<span class="hljs-string">&quot;running&quot;</span>);    &#125;&#125;;<span class="hljs-comment">// 创建线程对象</span>Thread t = <span class="hljs-keyword">new</span> Thread(runnable, <span class="hljs-string">&quot;t2&quot;</span>);<span class="hljs-comment">// 启动线程</span>t.start();</code></pre><pre><code class="hljs css">16<span class="hljs-selector-pseudo">:22</span><span class="hljs-selector-pseudo">:02</span> <span class="hljs-selector-attr">[t2]</span> <span class="hljs-selector-tag">c</span><span class="hljs-selector-class">.Test</span> <span class="hljs-selector-tag">-</span> <span class="hljs-selector-tag">running</span></code></pre><h4 id="lambda精简代码"><a href="#lambda精简代码" class="headerlink" title="lambda精简代码"></a>lambda精简代码</h4><blockquote><p>JDK中只有一个抽象方法的接口会加一个 @FunctionalInterface 注解，可被lambda表达式简化</p></blockquote><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201127162415.png" alt="注解" style="zoom:33%;" /><pre><code class="hljs java">Runnable r2 = () -&gt; &#123;log.debug(<span class="hljs-string">&quot;running&quot;</span>);&#125;;Thread t2 = <span class="hljs-keyword">new</span> Thread(r2, <span class="hljs-string">&quot;t2&quot;</span>);t2.start();Runnable r3 = () -&gt; log.debug(<span class="hljs-string">&quot;running&quot;</span>);Thread t3 = <span class="hljs-keyword">new</span> Thread(r3, <span class="hljs-string">&quot;t3&quot;</span>);t3.start();Thread t4 = <span class="hljs-keyword">new</span> Thread(()-&gt;log.debug(<span class="hljs-string">&quot;running&quot;</span>), <span class="hljs-string">&quot;t4&quot;</span>);        t4.start();</code></pre><h4 id="原理之-Thread-与-Runnable-的关系"><a href="#原理之-Thread-与-Runnable-的关系" class="headerlink" title="原理之 Thread 与 Runnable 的关系"></a>原理之 Thread 与 Runnable 的关系</h4><p>1.跟随Thread(Runnable target)源码</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Thread</span><span class="hljs-params">(Runnable target)</span> </span>&#123;    init(<span class="hljs-keyword">null</span>, target, <span class="hljs-string">&quot;Thread-&quot;</span> + nextThreadNum(), <span class="hljs-number">0</span>);&#125;</code></pre><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-comment">// 对于Runnable创建Thread, 最终target(Runnable)在run方法中被调到, 优先采用Runnable对象的run方法</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">if</span> (target != <span class="hljs-keyword">null</span>) &#123;        target.run();    &#125;&#125;<span class="hljs-comment">// 而对于未采用Runnable, 直接创建的Thread子类对象, 重写了Thread中的run()方法, 最终执行子类中的run()方法</span>Thread t = <span class="hljs-keyword">new</span> Thread()&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 要执行的任务</span>    &#125;&#125;;</code></pre><blockquote><p>小结</p></blockquote><ul><li><p>方法1 是把线程和任务合并在了一起，方法2 是把线程和任务分开了 </p></li><li><p>用 Runnable 更容易与线程池等高级 API 配合</p></li><li><p>用 Runnable 让任务类脱离了 Thread 继承体系，更灵活</p><p> java中组合由于继承!</p></li></ul><h4 id="方法三-FutureTask配合Thread"><a href="#方法三-FutureTask配合Thread" class="headerlink" title="方法三, FutureTask配合Thread"></a>方法三, FutureTask配合Thread</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">RunnableFuture</span>&lt;<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Runnable</span>, <span class="hljs-title">Future</span>&lt;<span class="hljs-title">V</span>&gt; </span><span class="hljs-class">  // 说明能返回运行结果</span></code></pre><blockquote><p> FutureTask 能够接收 Callable 类型的参数，用来处理有返回结果的情况</p></blockquote><pre><code class="hljs java">FutureTask&lt;Integer&gt; task1 = <span class="hljs-keyword">new</span> FutureTask(<span class="hljs-keyword">new</span> Callable() &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        log.debug(<span class="hljs-string">&quot;running&quot;</span>);        Thread.sleep(<span class="hljs-number">3000</span>);        <span class="hljs-keyword">return</span> <span class="hljs-number">200</span>;    &#125;&#125;);Thread t5 = <span class="hljs-keyword">new</span> Thread(task1, <span class="hljs-string">&quot;t_task1&quot;</span>);t5.start();log.debug(<span class="hljs-string">&quot;&#123;&#125;,&quot;</span>, task1.get());<span class="hljs-comment">// 等待task返回结果</span>FutureTask&lt;Integer&gt; task2 = <span class="hljs-keyword">new</span> FutureTask(()-&gt;log.debug(<span class="hljs-string">&quot;running&quot;</span>), <span class="hljs-number">200</span>);<span class="hljs-keyword">new</span> Thread(task2, <span class="hljs-string">&quot;t_task2&quot;</span>).start();log.debug(<span class="hljs-string">&quot;&#123;&#125;,&quot;</span>, task2.get());</code></pre><pre><code class="hljs css">17<span class="hljs-selector-pseudo">:19</span><span class="hljs-selector-pseudo">:44</span> <span class="hljs-selector-attr">[t_task1]</span> <span class="hljs-selector-tag">c</span><span class="hljs-selector-class">.Test</span> <span class="hljs-selector-tag">-</span> <span class="hljs-selector-tag">running</span>17<span class="hljs-selector-pseudo">:19</span><span class="hljs-selector-pseudo">:47</span> <span class="hljs-selector-attr">[main]</span> <span class="hljs-selector-tag">c</span><span class="hljs-selector-class">.Test</span> <span class="hljs-selector-tag">-</span> 200,17<span class="hljs-selector-pseudo">:19</span><span class="hljs-selector-pseudo">:47</span> <span class="hljs-selector-attr">[t_task2]</span> <span class="hljs-selector-tag">c</span><span class="hljs-selector-class">.Test</span> <span class="hljs-selector-tag">-</span> <span class="hljs-selector-tag">running</span>17<span class="hljs-selector-pseudo">:19</span><span class="hljs-selector-pseudo">:47</span> <span class="hljs-selector-attr">[main]</span> <span class="hljs-selector-tag">c</span><span class="hljs-selector-class">.Test</span> <span class="hljs-selector-tag">-</span> 200,</code></pre><h3 id="2-2-观察多个线程同时运行"><a href="#2-2-观察多个线程同时运行" class="headerlink" title="2.2 观察多个线程同时运行"></a>2.2 观察多个线程同时运行</h3><pre><code class="hljs java"><span class="hljs-keyword">new</span> Thread(() -&gt; &#123;    <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;        log.debug(<span class="hljs-string">&quot;running...&quot;</span>);    &#125;&#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();<span class="hljs-keyword">new</span> Thread(()-&gt;&#123;    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>)&#123;        log.debug(<span class="hljs-string">&quot;running...&quot;</span>);    &#125;&#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();</code></pre><p>主要是理解:</p><ul><li>交替执行</li><li>谁先谁后，不由我们控制</li></ul><p>由底层任务调度器控制</p><h3 id="2-3-查看进程线程的方法"><a href="#2-3-查看进程线程的方法" class="headerlink" title="2.3 查看进程线程的方法"></a>2.3 查看进程线程的方法</h3><blockquote><p>windows</p></blockquote><ul><li><p>任务管理器可以查看进程和线程数，也可以用来杀死进程</p></li><li><p>tasklist 查看进程</p></li><li><p>taskkill 杀死进程</p></li></ul><blockquote><p>linux</p></blockquote><ul><li><p>ps -fe 查看所有进程</p></li><li><p>ps -fT -p <PID> 查看某个进程(PID)的所有线程 kill 杀死进程</p></li><li><p>top 按大写 H 切换是否显示线程</p></li><li><p>top -H -p <PID> 查看某个进程(PID)的所有线程</p></li></ul><blockquote><p>Java</p></blockquote><ul><li> jps 命令查看所有 Java 进程</li><li> jstack <PID> 查看某个 Java 进程(PID)的所有线程状态</li><li> jconsole 来查看某个 Java 进程中线程的运行情况(图形界面)</li></ul><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201127172857.png" alt="test" style="zoom:50%;" /><p>jconsole 远程监控配置 </p><ul><li>需要以如下方式运行你的 java 类</li></ul><pre><code class="hljs java"><span class="hljs-comment">//输入linux 根据选择true/false</span>java -Djava.rmi.server.hostname=`ip地址` -Dcom.sun.management.jmxremote - Dcom.sun.management.jmxremote.port=`连接端口` -Dcom.sun.management.jmxremote.ssl=是否安全连接 - Dcom.sun.management.jmxremote.authenticate=是否认证 java类</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201127174348.png" alt="连接"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201127174536.png" alt="线程"></p><h3 id="2-4-线程运行原理"><a href="#2-4-线程运行原理" class="headerlink" title="2.4 线程运行原理"></a>2.4 线程运行原理</h3><h4 id="栈与栈帧"><a href="#栈与栈帧" class="headerlink" title="栈与栈帧"></a>栈与栈帧</h4><blockquote><p>Java Virtual Machine Stacks (Java 虚拟机栈)</p><p>我们都知道 JVM 中由堆、栈、方法区所组成，其中栈内存是给谁用的呢?其实就是线程，每个线程启动后，虚拟 机就会为其分配一块栈内存。</p></blockquote><ul><li>每个栈由多个栈帧(Frame)组成，对应着每次方法调用时所占用的内存 </li><li>每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法</li></ul><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestFrames</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Thread t1 = <span class="hljs-keyword">new</span> Thread()&#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                method1(<span class="hljs-number">20</span>);            &#125;        &#125;;        t1.setName(<span class="hljs-string">&quot;t1&quot;</span>);        t1.start();        method1(<span class="hljs-number">10</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;        <span class="hljs-keyword">int</span> y = x + <span class="hljs-number">1</span>;        Object m = method2();        System.out.println(m);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title">method2</span><span class="hljs-params">()</span> </span>&#123;        Object n = <span class="hljs-keyword">new</span> Object();        <span class="hljs-keyword">return</span> n;    &#125;&#125;</code></pre><p>debug:</p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201127175404.png" alt="为主方法分配的栈帧" style="zoom:50%;" /><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201127175543.png" alt="开辟method1栈帧" style="zoom:50%;" /><blockquote><p>里面有参数信息, 局部变量信息</p></blockquote><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201127175648.png" alt="参数存放于局部变量表中"></p><blockquote><p>这些参数都存在于 <strong><em>局部变量表</em></strong>中</p></blockquote><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201127175800.png" alt="栈结构很明显"></p><h4 id="栈帧图解"><a href="#栈帧图解" class="headerlink" title="栈帧图解"></a>栈帧图解</h4><blockquote><p>当我们运行TestFrames时发生了什么?</p></blockquote><pre><code class="hljs less">首先执行 类加载 把<span class="hljs-selector-tag">TestFrames</span>字节码加载到<span class="hljs-selector-tag">Java</span>虚拟机中(放入方法区)类加载完成后<span class="hljs-selector-tag">Java</span>虚拟机启动一个名称为<span class="hljs-selector-tag">main</span>的主线程, 并分配一块栈内存, 线程再交给任务调度器执行线程栈中有一个程序计数器组件, 记录了当前该执行哪行代码栈帧中的局部变量表(栈帧创建时就会分配, 非边运行边分配, 但赋值是边运行边执行的)包含当前方法局部变量和方法参数返回地址对应退出地址,</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201127181557.png" alt="执行method2之前"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201127181744.png" alt="继续执行"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201127181939.png" alt="执行完method2"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201127182209.png" alt="执行完method2后, 栈帧消失"></p><p>之后同样出栈并根据返回地址返回, 继续执行下面的代码</p><h4 id="多线程栈与栈帧原理"><a href="#多线程栈与栈帧原理" class="headerlink" title="多线程栈与栈帧原理"></a>多线程栈与栈帧原理</h4><blockquote><p>把Debug模式改成Thread</p></blockquote><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201127182651.png" alt="debug" style="zoom:50%;" /><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201127182814.png" alt="主线程栈内存"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201127182912.png" alt="t1线程栈内存"></p><h4 id="线程的上下文切换-Thread-Context-Switch"><a href="#线程的上下文切换-Thread-Context-Switch" class="headerlink" title="线程的上下文切换(Thread Context Switch)"></a>线程的上下文切换(Thread Context Switch)</h4><blockquote><p>当任务调度器把时间片分配给每个线程运行的时候, 每个线程的时间片用完后把cpu使用权交给其他线程, 此时就会发生上下文切换</p></blockquote><p>因为以下一些原因导致 cpu 不再执行当前的线程，转而执行另一个线程的代码</p><ul><li>线程的 cpu 时间片用完</li><li> 垃圾回收  (<strong>会暂停当前所有的工作线程, 让垃圾回收线程回收垃圾</strong>)</li><li> 有更高优先级的线程需要运行</li><li> 线程自己调用了 sleep、yield、wait、join、park、synchronized、lock 等方法</li></ul><p>当 Context Switch 发生时，需要由操作系统保存当前线程的状态（ <strong>比如执行到第n行代码时间片结束，要记录n，否则下次再次轮到该线程，cpu不知道该从哪执行</strong>），并恢复另一个线程的状态，Java 中对应的概念 就是 <strong><em>程序计数器(Program Counter Register)</em></strong>，它的作用是记住 <strong><em>下一条 jvm 指令的执行地址</em></strong>，是线程 <strong><em>私有</em></strong>的</p><ul><li><p>状态包括 <strong><em>程序计数器</em></strong>、 <strong><em>虚拟机栈中每个栈帧的信息</em></strong>，如 <strong><em>局部变量</em></strong>、 <strong><em>操作数栈</em></strong>、 <strong><em>返回地址</em></strong>等 </p></li><li><p>Context Switch 频繁发生会影响性能</p><blockquote><p>假如运行到return n;的时候时间片结束</p></blockquote><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201127184513.png" alt="图解"></p><blockquote><p>加入t1执行完后</p></blockquote><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201127184706.png" alt="t1执行完后, main重新开始执行"></p></li></ul><h3 id="2-5-线程常用方法"><a href="#2-5-线程常用方法" class="headerlink" title="2.5 线程常用方法"></a>2.5 线程常用方法</h3><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法:"></a>常用方法:</h4><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201209100229.png" alt="1"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201209100254.png" alt="2"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201209100315.png" alt="3"></p><h4 id="start-vs-run"><a href="#start-vs-run" class="headerlink" title="start vs run"></a>start vs run</h4><blockquote><p>如果直接run会发生什么？</p></blockquote><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201209101753.png" alt="单独run"></p><p>并不是t1线程执行，并不能起到异步效果。</p><p>start启用线程，再由新的线程执行。</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 打印线程状态</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Slf4j(topic = &quot;c.Test&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test5</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            log.debug(<span class="hljs-string">&quot;running&quot;</span>);        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);        System.out.println(t1.getState());        t1.run();        System.out.println(t1.getState());        t1.start();        System.out.println(t1.getState());    &#125;&#125;</code></pre><pre><code class="hljs css"><span class="hljs-selector-tag">NEW</span>10<span class="hljs-selector-pseudo">:25</span><span class="hljs-selector-pseudo">:53</span> <span class="hljs-selector-attr">[main]</span> <span class="hljs-selector-tag">c</span><span class="hljs-selector-class">.Test</span> <span class="hljs-selector-tag">-</span> <span class="hljs-selector-tag">running</span><span class="hljs-selector-tag">NEW</span><span class="hljs-selector-tag">RUNNABLE</span>10<span class="hljs-selector-pseudo">:25</span><span class="hljs-selector-pseudo">:53</span> <span class="hljs-selector-attr">[t1]</span> <span class="hljs-selector-tag">c</span><span class="hljs-selector-class">.Test</span> <span class="hljs-selector-tag">-</span> <span class="hljs-selector-tag">running</span></code></pre><blockquote><p>不能调用多次start()方法</p></blockquote><pre><code class="hljs css"><span class="hljs-selector-tag">Exception</span> <span class="hljs-selector-tag">in</span> <span class="hljs-selector-tag">thread</span> &quot;<span class="hljs-selector-tag">main</span>&quot; 10<span class="hljs-selector-pseudo">:27</span><span class="hljs-selector-pseudo">:05</span> <span class="hljs-selector-attr">[t1]</span> <span class="hljs-selector-tag">c</span><span class="hljs-selector-class">.Test</span> <span class="hljs-selector-tag">-</span> <span class="hljs-selector-tag">running</span><span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.IllegalThreadStateException</span>    <span class="hljs-selector-tag">at</span> <span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.Thread</span><span class="hljs-selector-class">.start</span>(<span class="hljs-selector-tag">Thread</span><span class="hljs-selector-class">.java</span><span class="hljs-selector-pseudo">:708)</span>    <span class="hljs-selector-tag">at</span> <span class="hljs-selector-tag">com</span><span class="hljs-selector-class">.qiuke</span><span class="hljs-selector-class">.test</span><span class="hljs-selector-class">.Test5</span><span class="hljs-selector-class">.main</span>(<span class="hljs-selector-tag">Test5</span><span class="hljs-selector-class">.java</span><span class="hljs-selector-pseudo">:19)</span>// 多次调用<span class="hljs-selector-tag">start</span>()</code></pre><blockquote><p>小结</p></blockquote><p>直接调用 run 是在 <strong>主线程中执行了 run</strong>，没有启动新的线程<br> 使用 start 是 <strong>启动新的线程</strong>，通过新的线程间接执行 run 中的代码</p><h4 id="sleep-vs-yield"><a href="#sleep-vs-yield" class="headerlink" title="sleep vs yield"></a>sleep vs yield</h4><p> <strong><em>sleep</em></strong></p><ul><li><p>调用 sleep 会让当前线程从  <strong>Running 进入 Timed Waiting 状态(阻塞)</strong></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201209103716.png" alt="Timed Waiting"></p></li><li><p>其它线程可以使用  <strong>interrupt</strong> 方法打断正在睡眠的线程，这时 sleep 方法会抛出  **InterruptedException **</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201209104226.png" alt="interrupted异常"></p></li><li><p>睡眠结束后的线程 <strong>未必会立刻得到执行</strong></p><ul><li>要等任务调度器分配时间片</li></ul></li><li><p>建议用 <strong>TimeUnit 的 sleep</strong> 代替 Thread 的 sleep 来获得更好的可读性</p><ul><li><pre><code class="java">public void sleep(long timeout) throws InterruptedException &#123;    if (timeout &gt; 0) &#123;        long ms = toMillis(timeout);        int ns = excessNanos(timeout, ms);        Thread.sleep(ms, ns);    &#125;&#125;// 内部仍然是sleep<pre><code class="hljs reasonml">- ```java  <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">TimeUnit</span>.</span><span class="hljs-module"><span class="hljs-identifier">SECONDS</span>.</span></span>sleep(<span class="hljs-number">2000</span>);</code></pre></code></pre></li></ul></li></ul><p> <strong><em>yield</em></strong></p><ul><li><p>调用 yield 会让当前线程从  <strong>Running 进入 Runnable 就绪状态</strong>，然后调度执行其它线程</p><ul><li>任务调度器会把时间片分配给 <strong>就绪状态</strong>，但不会分配给 <strong>阻塞状态</strong>。</li><li>yield几乎没有 <strong>等待时间</strong>。</li></ul></li><li><p>具体的实现依赖于操作系统的任务调度器</p><ul><li>想让，但没有其他线程要运行， <strong>任务调度器还是会把时间片分配给自己</strong>。</li></ul></li></ul><h4 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h4><ul><li>线程优先级会 <strong>提示(hint)**调度器优先调度该线程，但它 **仅仅是一个提示</strong>，调度器可以忽略它。</li><li>如果 cpu 比较忙，那么优先级高的线程会获得更多的时间片，但 cpu 闲时，优先级几乎没作用</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Runnable task1 = () -&gt; &#123;            <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;            <span class="hljs-keyword">for</span> (;;) &#123;                System.out.println(<span class="hljs-string">&quot;----&gt;1 &quot;</span> + count++);            &#125;        &#125;;        Runnable task2 = () -&gt; &#123;            <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;            <span class="hljs-keyword">for</span> (;;) &#123;<span class="hljs-comment">//                Thread.yield();</span>                System.out.println(<span class="hljs-string">&quot;              ----&gt;2 &quot;</span> + count++);            &#125;        &#125;;        Thread t1 = <span class="hljs-keyword">new</span> Thread(task1, <span class="hljs-string">&quot;t1&quot;</span>);        Thread t2 = <span class="hljs-keyword">new</span> Thread(task2, <span class="hljs-string">&quot;t2&quot;</span>);        t1.setPriority(Thread.MIN_PRIORITY);        t2.setPriority(Thread.MAX_PRIORITY);        t1.start();        t2.start();    &#125;</code></pre><blockquote><p>优先级高的，最终打印的count应该更大</p></blockquote><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201209110407.png" alt="结果"></p><p>如果线程2开启yield：</p><pre><code class="hljs java">Runnable task2 = () -&gt; &#123;    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (;;) &#123;        Thread.yield();        System.out.println(<span class="hljs-string">&quot;              ----&gt;2 &quot;</span> + count++);    &#125;&#125;;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201209110459.png" alt="新结果"></p><p>如果将优先级注释掉：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201209110557.png" alt="新结果"></p><h4 id="sleep案例-防止cpu占用百分之百"><a href="#sleep案例-防止cpu占用百分之百" class="headerlink" title="sleep案例:防止cpu占用百分之百"></a>sleep案例:防止cpu占用百分之百</h4><h5 id="sleep实现"><a href="#sleep实现" class="headerlink" title="sleep实现"></a>sleep实现</h5><ul><li><p>在没有利用 cpu 来计算时，不要让 while(true) 空转浪费 cpu，这时可以使用 yield 或 sleep 来让出 cpu 的使用权 给其他程序</p><pre><code class="hljs java"><span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;   <span class="hljs-keyword">try</span> &#123;      Thread.sleep(<span class="hljs-number">50</span>);  &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;      e.printStackTrace(); &#125;&#125;</code></pre><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201209111647.png" alt="测试(加了sleep)" style="zoom: 50%;" /><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201209112407.png" alt="服务器"></p><p>注意：自己服务器多核，可能没有这样的效果！</p><ul><li><p>如果没有加sleep：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201209112645.png" alt="没有sleep"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201209112747.png" alt="cpu直接被打满"></p><p>如图，cpu直接被打满。</p></li></ul></li><li><p>可以用 wait 或 条件变量达到类似的效果 </p></li><li><p>不同的是，后两种都 <strong>需要加锁</strong>，并且需要相应的唤醒操作，一般适用于要进行同步的场景 </p></li><li><p>sleep 适用于 <strong>无需锁同步的场景</strong></p></li></ul><h4 id="join"><a href="#join" class="headerlink" title="join"></a>join</h4><blockquote><p>下面的代码执行，打印 r 是什么?</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    test1();&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;    log.debug(<span class="hljs-string">&quot;开始&quot;</span>);    Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;        log.debug(<span class="hljs-string">&quot;开始&quot;</span>);        <span class="hljs-keyword">try</span> &#123;            Thread.sleep(<span class="hljs-number">1</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        log.debug(<span class="hljs-string">&quot;结束&quot;</span>);         r = <span class="hljs-number">10</span>;    &#125;);    t1.start();    log.debug(<span class="hljs-string">&quot;结果为:&#123;&#125;&quot;</span>, r);    log.debug(<span class="hljs-string">&quot;结束&quot;</span>);&#125;</code></pre><pre><code class="hljs css">11<span class="hljs-selector-pseudo">:32</span><span class="hljs-selector-pseudo">:52</span> <span class="hljs-selector-attr">[main]</span> <span class="hljs-selector-tag">c</span><span class="hljs-selector-class">.Test10</span> <span class="hljs-selector-tag">-</span> 开始11<span class="hljs-selector-pseudo">:32</span><span class="hljs-selector-pseudo">:52</span> <span class="hljs-selector-attr">[Thread-0]</span> <span class="hljs-selector-tag">c</span><span class="hljs-selector-class">.Test10</span> <span class="hljs-selector-tag">-</span> 开始11<span class="hljs-selector-pseudo">:32</span><span class="hljs-selector-pseudo">:52</span> <span class="hljs-selector-attr">[main]</span> <span class="hljs-selector-tag">c</span><span class="hljs-selector-class">.Test10</span> <span class="hljs-selector-tag">-</span> 结果为<span class="hljs-selector-pseudo">:0</span>11<span class="hljs-selector-pseudo">:32</span><span class="hljs-selector-pseudo">:52</span> <span class="hljs-selector-attr">[Thread-0]</span> <span class="hljs-selector-tag">c</span><span class="hljs-selector-class">.Test10</span> <span class="hljs-selector-tag">-</span> 结束11<span class="hljs-selector-pseudo">:32</span><span class="hljs-selector-pseudo">:52</span> <span class="hljs-selector-attr">[main]</span> <span class="hljs-selector-tag">c</span><span class="hljs-selector-class">.Test10</span> <span class="hljs-selector-tag">-</span> 结束</code></pre><p>主线程调用test1，线程1被启动，主线程继续往下运行，不会等到t1结束，直接打印结果r=0；</p><blockquote><p>分析</p></blockquote><p>因为 **主线程和线程 t1 是并行执行的 **，t1 线程需要 1 秒之后才能算出 r=10</p><p>而主线程一开始就要打印 r 的结果，所以只能打印出 r=0</p><blockquote><p>解决方法</p></blockquote><p>用 sleep 行不行?为什么?</p><ul><li><p>可实现，但不推荐，因为未知线程t1执行到r赋值语句所需执行的时间</p><p>用 join，加在 t1.start() 之后即可</p></li><li><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201209135850.png" alt="join"></p></li></ul><h4 id="join案例-同步"><a href="#join案例-同步" class="headerlink" title="join案例:同步"></a>join案例:同步</h4><ul><li>需要等待结果返回，才能继续运行就是 <strong>同步</strong><ul><li>刚才的案例中：</li><li><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201209140223.png" alt="主线程在同步等待t1线程"></li></ul></li><li>不需要等待结果返回，就能继续运行就是 <strong>异步</strong></li></ul><h5 id="等待多个结果"><a href="#等待多个结果" class="headerlink" title="等待多个结果"></a>等待多个结果</h5><blockquote><p>下面代码 cost 大约多少秒?</p></blockquote><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;    Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;        <span class="hljs-keyword">try</span> &#123;            TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        r1 = <span class="hljs-number">10</span>;    &#125;);    Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;        <span class="hljs-keyword">try</span> &#123;            TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        r2 = <span class="hljs-number">20</span>;    &#125;);    t1.start();    t2.start();    <span class="hljs-keyword">long</span> start = System.currentTimeMillis();    log.debug(<span class="hljs-string">&quot;join begin&quot;</span>);    <span class="hljs-comment">// t1先join</span>    t1.join();    log.debug(<span class="hljs-string">&quot;t2 join end&quot;</span>);    <span class="hljs-comment">// t2再join</span>    t2.join();    log.debug(<span class="hljs-string">&quot;t1 join end&quot;</span>);    <span class="hljs-keyword">long</span> end = System.currentTimeMillis();    log.debug(<span class="hljs-string">&quot;r1: &#123;&#125; r2: &#123;&#125; cost: &#123;&#125;&quot;</span>, r1, r2, end - start);&#125;</code></pre><pre><code class="hljs css">14<span class="hljs-selector-pseudo">:07</span><span class="hljs-selector-pseudo">:10</span> <span class="hljs-selector-attr">[main]</span> <span class="hljs-selector-tag">c</span><span class="hljs-selector-class">.TestJoin</span> <span class="hljs-selector-tag">-</span> <span class="hljs-selector-tag">join</span> <span class="hljs-selector-tag">begin</span>14<span class="hljs-selector-pseudo">:07</span><span class="hljs-selector-pseudo">:12</span> <span class="hljs-selector-attr">[main]</span> <span class="hljs-selector-tag">c</span><span class="hljs-selector-class">.TestJoin</span> <span class="hljs-selector-tag">-</span> <span class="hljs-selector-tag">t2</span> <span class="hljs-selector-tag">join</span> <span class="hljs-selector-tag">end</span>14<span class="hljs-selector-pseudo">:07</span><span class="hljs-selector-pseudo">:12</span> <span class="hljs-selector-attr">[main]</span> <span class="hljs-selector-tag">c</span><span class="hljs-selector-class">.TestJoin</span> <span class="hljs-selector-tag">-</span> <span class="hljs-selector-tag">t1</span> <span class="hljs-selector-tag">join</span> <span class="hljs-selector-tag">end</span>14<span class="hljs-selector-pseudo">:07</span><span class="hljs-selector-pseudo">:12</span> <span class="hljs-selector-attr">[main]</span> <span class="hljs-selector-tag">c</span><span class="hljs-selector-class">.TestJoin</span> <span class="hljs-selector-tag">-</span> <span class="hljs-selector-tag">r1</span>: 10 <span class="hljs-selector-tag">r2</span>: 20 <span class="hljs-selector-tag">cost</span>: 2002</code></pre><p>时间差值为 <strong>2s</strong>！</p><p>如果t2先join，t1再join呢？</p><p>时间差值仍为 <strong>2s</strong>！</p><blockquote><p>分析如下</p></blockquote><ul><li><p>第一个 join:等待 t1 时, t2 并没有停止, 而在运行</p></li><li><p>第二个 join:1s 后, 执行到此, t2 也运行了 1s, 因此也只需再等待 1s</p></li></ul><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201209141248.png" alt="流程图"></p><h5 id="join的限时同步"><a href="#join的限时同步" class="headerlink" title="join的限时同步"></a>join的限时同步</h5><blockquote><p>Join(long n)等待n毫秒</p></blockquote><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201209141710.png" alt="测试"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201209141803.png" alt="测试2"></p><h4 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt"></a>interrupt</h4><h5 id="打断-sleep，wait，join-的线程"><a href="#打断-sleep，wait，join-的线程" class="headerlink" title="打断 sleep，wait，join 的线程"></a>打断 <strong>sleep，wait，join</strong> 的线程</h5><blockquote><p>打断 <strong>sleep，wait，join</strong> 的线程，且清空打断标记，置为false</p></blockquote><p>这几个方法都会让线程 <strong>进入阻塞状态</strong><br> 打断 sleep 的线程, 会 <strong>清空打断状态</strong>，以 sleep 为例</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201209142900.png" alt="测试interrupt"></p><p>注意：一定要 <strong>先sleep再打断</strong>，如果先打断再sleep，打断表示为true！</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201209143036.png" alt="先打断再sleep情况"></p><h5 id="打断正常运行的线程"><a href="#打断正常运行的线程" class="headerlink" title="打断正常运行的线程"></a>打断正常运行的线程</h5><p>Code:</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;    Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;            <span class="hljs-keyword">boolean</span> interrupted = Thread.currentThread().isInterrupted();            <span class="hljs-keyword">if</span>(interrupted) &#123;                log.debug(<span class="hljs-string">&quot;被打断了, 退出循环&quot;</span>);                <span class="hljs-keyword">break</span>;            &#125;        &#125;    &#125;, <span class="hljs-string">&quot;t1&quot;</span>);    t1.start();    Thread.sleep(<span class="hljs-number">1000</span>);    log.debug(<span class="hljs-string">&quot;interrupt&quot;</span>);    t1.interrupt();&#125;</code></pre><p>如果不加break，退不出循环。并不会影响程序正常运行。</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201209143718.png" alt="不加break 程序仍在运行"></p><p>主线程执行打断，只是告诉线程你要打断， <strong>继续运行还是停止运行由该线程自己决定</strong>。</p><h5 id="模式之两阶段终止"><a href="#模式之两阶段终止" class="headerlink" title="* 模式之两阶段终止"></a>* 模式之两阶段终止</h5><blockquote><p>Two Phase Termination</p></blockquote><p>在一个线程T1中如何“ <strong>优雅</strong> ”的终止线程T2？这里的优雅指的是给T2一个料理后事的机会。</p><blockquote><p>错误思想</p></blockquote><ul><li><p>使用线程对象的 <strong>stop()</strong> 方法停止线程</p><ul><li>stop方法会 <strong>真正杀死线程</strong>，如果这时线程锁住了 <strong>共享资源</strong> ，那么当它被杀死后就再也 <strong>没有机会释放锁</strong>，其他线程将永远无法获取锁</li></ul></li><li><p>使用 <strong>System.exit(int)</strong> 方法停止线程</p><ul><li>目的仅是停止一个线程，这种做法会 <strong>让整个程序都停止</strong></li></ul></li></ul><blockquote><p>对于监控线程来说，应该使用while(true)不断运行</p></blockquote><ul><li><p>怎么让监控线程停止监控，就得使用 <strong>两阶段终止模式</strong></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201209145702.png" alt="流程"></p><p>​ 需要sleep，不然会打满cpu。</p><p>​ 如果在 <strong>监控阶段被打断</strong>，打断标记为 true，下一轮判断是否被打断后会退出。</p><p>​ 如果在 <strong>睡眠阶段被打断</strong>，抛出InterruptedException异常，打断标记清空。可以抓住这个异常，重新设计打断标记，下一轮继续判断。</p><p>​ code模拟:</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 通过两阶段终止模式实现监控线程</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Slf4j(topic = &quot;c.Test13&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test13</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        TwoPhaseTermination tpt = <span class="hljs-keyword">new</span> TwoPhaseTermination();        tpt.start();        Thread.sleep(<span class="hljs-number">4000</span>);        tpt.stop();    &#125;&#125;<span class="hljs-meta">@Slf4j(topic = &quot;c.TwoPhaseTermination&quot;)</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TwoPhaseTermination</span></span>&#123;    <span class="hljs-keyword">private</span> Thread monitorThread;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span></span>&#123;        monitorThread.interrupt();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span></span>&#123;        monitorThread = <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>)&#123;                Thread current = Thread.currentThread();                <span class="hljs-keyword">if</span> (current.isInterrupted())&#123;                    log.debug(<span class="hljs-string">&quot;料理后事&quot;</span>);                    <span class="hljs-keyword">break</span>;                &#125;                <span class="hljs-keyword">try</span> &#123;                    Thread.sleep(<span class="hljs-number">1000</span>); <span class="hljs-comment">// 如果期间被打断 需要捕获异常 重置打断标记</span>                    log.debug(<span class="hljs-string">&quot;执行监控中...&quot;</span>);                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                    <span class="hljs-comment">// 重新设置打断标记</span>                    current.interrupt();                    System.out.println(current.isInterrupted());                &#125;            &#125;        &#125;,<span class="hljs-string">&quot;monitor&quot;</span>);        monitorThread.start();    &#125;&#125;</code></pre></li></ul><p>  <img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201209162750.png" alt="结果演示"></p><p>  isInterrupted()不会清除打断标记</p><p>  <img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210423143906.png"></p><p>  Interrupted()会清除</p><h5 id="打断park线程"><a href="#打断park线程" class="headerlink" title="打断park线程"></a>打断park线程</h5><p>​```java<br>private static void test3() throws InterruptedException {<br>    Thread t1 = new Thread(() -&gt; {<br>        log.debug(“park…”);<br>        LockSupport.park();<br>        log.debug(“unpark…”);<br>        log.debug(“打断状态：{}”, Thread.currentThread().isInterrupted());<br>    }, “t1”);<br>    t1.start();<br>}</p><pre><code class="hljs autohotkey">线程park状态能被打断：加入```javat1.interrupt()<span class="hljs-comment">;</span></code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210423144534.png"></p><p>但是打断之后，再也无法park了</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210423144938.png"></p><p>怎么能够再次park？</p><p>只需要 <strong>把打断标记设置为假</strong> </p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210423145303.png"></p><h4 id="2-5-9-sleep、yield、wait、join的区别-阿里"><a href="#2-5-9-sleep、yield、wait、join的区别-阿里" class="headerlink" title="2.5.9 sleep、yield、wait、join的区别(阿里)"></a>2.5.9 sleep、yield、wait、join的区别(阿里)</h4><p><a href="https://www.cnblogs.com/aspirant/p/8876670.html">区别</a></p><p>关于join的原理和这几个方法的对比：<a href="https://blog.csdn.net/dataiyangu/article/details/104956755">看这里</a></p><blockquote><p>补充：</p><ol><li>sleep，join，yield，interrupted是Thread类中的方法</li><li>wait/notify是object中的方法</li></ol><p>sleep 不释放锁、释放cpu join 释放锁、抢占cpu yiled 不释放锁、释放cpu wait 释放锁、释放cpu</p></blockquote><h4 id="2-5-10-不推荐的方法"><a href="#2-5-10-不推荐的方法" class="headerlink" title="2.5.10 不推荐的方法"></a>2.5.10 不推荐的方法</h4><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210423145444.png"></p><p>还有一些不推荐使用的方法，这些方法已过时，容易破坏同步代码块，造成 <strong>线程死锁</strong> </p><h4 id="2-5-11-主线程和守护线程"><a href="#2-5-11-主线程和守护线程" class="headerlink" title="2.5.11 主线程和守护线程"></a>2.5.11 主线程和守护线程</h4><p>默认情况下，java进程 <strong>需要等待所有的线程结束</strong> 后才会停止，但是有一种特殊的线程，叫做守护线程，在其他线程全部结束的时候即使守护线程还未结束代码未执行完java进程也会停止。普通线程t1可以调用     <strong>t1.setDeamon(true);</strong>   方法变成守护线程。</p><pre><code class="hljs js">注意 垃圾回收器线程就是一种守护线程 Tomcat 中的 Acceptor 和 Poller 线程都是守护线程，所以 Tomcat 接收到 shutdown 命令后，不会等 待它们处理完当前请求</code></pre><p>例子：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;    Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;            <span class="hljs-keyword">if</span> (Thread.currentThread().isInterrupted()) &#123;                <span class="hljs-keyword">break</span>;            &#125;        &#125;        log.debug(<span class="hljs-string">&quot;结束&quot;</span>);    &#125;, <span class="hljs-string">&quot;t1&quot;</span>);    <span class="hljs-comment">//t1.setDaemon(true);</span>    t1.start();    Thread.sleep(<span class="hljs-number">1000</span>);    log.debug(<span class="hljs-string">&quot;结束&quot;</span>);&#125;</code></pre><p>t1线程在不断的执行，无法结束，main线程要等待t1，设置t1位守护进程后：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210423150045.png"></p><h3 id="2-6-线程的状态"><a href="#2-6-线程的状态" class="headerlink" title="2.6 线程的状态"></a>2.6 线程的状态</h3><h4 id="2-6-1-线程的五种状态"><a href="#2-6-1-线程的五种状态" class="headerlink" title="2.6.1 线程的五种状态"></a>2.6.1 线程的五种状态</h4><p>从 <strong>操作系统</strong>  层面来描述的</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210423150427.png"></p><ul><li>【 <strong>初始状态</strong> 】仅是在语言层面创建了线程对象，还未与操作系统线程关联</li><li>【可运行状态】（ <strong>就绪状态</strong> ）指该线程已经被创建（与操作系统线程关联）， <strong>可以由 CPU 调度执行</strong> </li><li>【运行状态】指 <strong>获取了 CPU 时间片</strong> 运行中的状态<br>当 CPU 时间片用完，会从【运行状态】转换至【可运行状态】，会 <strong>导致线程的上下文切换</strong> </li><li>【阻塞状态】<ul><li>如果调用了阻塞 API，如 BIO 读写文件，这时该线程实际不会用到 CPU，会导致线程上下文切换，进入<br>【阻塞状态】</li><li>等 BIO 操作完毕，会由操作系统唤醒阻塞的线程，转换至【可运行状态】</li><li>与【可运行状态】的区别是，对【阻塞状态】的线程来说 <strong>只要它们一直不唤醒，调度器就一直不会考虑<br>调度它们</strong> </li></ul></li><li>【终止状态】表示线程已经执行完毕，生命周期已经结束，不会再转换为其它状态</li></ul><h4 id="2-6-2-线程的-6-种状态"><a href="#2-6-2-线程的-6-种状态" class="headerlink" title="2.6.2 线程的 6 种状态"></a>2.6.2 线程的 6 种状态</h4><p>这是从 <strong>Java API 层面</strong> 来描述的，我们主要研究的就是这种。可以参考文章，<a href="https://blog.csdn.net/pange1991/article/details/53860651">点这里</a></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210423150842.png"></p><ul><li> <strong><em>NEW</em></strong>  线程刚被创建，但是还没有调用 start() 方法</li><li><strong><em>RUNNABLE</em></strong>  当调用了 start() 方法之后，注意，Java API 层面的 RUNNABLE 状态涵盖了 操作系统 层面的<br>【可运行状态】、【运行状态】和【阻塞状态】（由于 BIO 导致的线程阻塞，在 Java 里无法区分，仍然认为<br>是可运行）</li><li> <strong><em>BLOCKED</em></strong>  ，  <strong><em>WAITING</em></strong>  ， <strong><em>TIMED_WAITING</em></strong>  都是 Java API 层面对【阻塞状态】的细分，后面会在状态转换一节详述</li><li> <strong><em>TERMINATED</em></strong>  当线程代码运行结束</li></ul><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.TestState&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestState</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        Thread t1 = <span class="hljs-keyword">new</span> Thread(<span class="hljs-string">&quot;t1&quot;</span>) &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                log.debug(<span class="hljs-string">&quot;running...&quot;</span>);            &#125;        &#125;;        Thread t2 = <span class="hljs-keyword">new</span> Thread(<span class="hljs-string">&quot;t2&quot;</span>) &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123; <span class="hljs-comment">// runnable</span>                &#125;            &#125;        &#125;;        t2.start();        Thread t3 = <span class="hljs-keyword">new</span> Thread(<span class="hljs-string">&quot;t3&quot;</span>) &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                log.debug(<span class="hljs-string">&quot;running...&quot;</span>);            &#125;        &#125;;        t3.start();        Thread t4 = <span class="hljs-keyword">new</span> Thread(<span class="hljs-string">&quot;t4&quot;</span>) &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                <span class="hljs-keyword">synchronized</span> (TestState.class) &#123;                    <span class="hljs-keyword">try</span> &#123;                        Thread.sleep(<span class="hljs-number">1000000</span>); <span class="hljs-comment">// timed_waiting</span>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                        e.printStackTrace();                    &#125;                &#125;            &#125;        &#125;;        t4.start();        Thread t5 = <span class="hljs-keyword">new</span> Thread(<span class="hljs-string">&quot;t5&quot;</span>) &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                <span class="hljs-keyword">try</span> &#123;                    t2.join(); <span class="hljs-comment">// waiting</span>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;;        t5.start();        Thread t6 = <span class="hljs-keyword">new</span> Thread(<span class="hljs-string">&quot;t6&quot;</span>) &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                <span class="hljs-keyword">synchronized</span> (TestState.class) &#123; <span class="hljs-comment">// blocked</span>                    <span class="hljs-keyword">try</span> &#123;                        Thread.sleep(<span class="hljs-number">1000000</span>);                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                        e.printStackTrace();                    &#125;                &#125;            &#125;        &#125;;        t6.start();        <span class="hljs-keyword">try</span> &#123;            Thread.sleep(<span class="hljs-number">500</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        log.debug(<span class="hljs-string">&quot;t1 state &#123;&#125;&quot;</span>, t1.getState());        log.debug(<span class="hljs-string">&quot;t2 state &#123;&#125;&quot;</span>, t2.getState());        log.debug(<span class="hljs-string">&quot;t3 state &#123;&#125;&quot;</span>, t3.getState());        log.debug(<span class="hljs-string">&quot;t4 state &#123;&#125;&quot;</span>, t4.getState());        log.debug(<span class="hljs-string">&quot;t5 state &#123;&#125;&quot;</span>, t5.getState());        log.debug(<span class="hljs-string">&quot;t6 state &#123;&#125;&quot;</span>, t6.getState());        System.in.read();    &#125;&#125;</code></pre><p>结果：</p><pre><code class="hljs js"><span class="hljs-number">15</span>:<span class="hljs-number">19</span>:<span class="hljs-number">26</span> [t3] c.TestState - running...<span class="hljs-number">15</span>:<span class="hljs-number">19</span>:<span class="hljs-number">27</span> [main] c.TestState - t1 state NEW<span class="hljs-number">15</span>:<span class="hljs-number">19</span>:<span class="hljs-number">27</span> [main] c.TestState - t2 state RUNNABLE<span class="hljs-number">15</span>:<span class="hljs-number">19</span>:<span class="hljs-number">27</span> [main] c.TestState - t3 state TERMINATED<span class="hljs-number">15</span>:<span class="hljs-number">19</span>:<span class="hljs-number">27</span> [main] c.TestState - t4 state TIMED_WAITING<span class="hljs-number">15</span>:<span class="hljs-number">19</span>:<span class="hljs-number">27</span> [main] c.TestState - t5 state WAITING<span class="hljs-number">15</span>:<span class="hljs-number">19</span>:<span class="hljs-number">27</span> [main] c.TestState - t6 state BLOCKED</code></pre><h3 id="2-7-习题：应用之统筹规划"><a href="#2-7-习题：应用之统筹规划" class="headerlink" title="2.7 习题：应用之统筹规划"></a>2.7 习题：应用之统筹规划</h3><p>阅读华罗庚《统筹方法》，给出 <strong>烧水泡茶</strong> 的多线程解决方案，提示</p><ul><li><p>参考图二，用两个线程（两个人协作）模拟烧水泡茶过程</p><ul><li>文中办法乙、丙都相当于任务串行</li><li>而图一相当于启动了 4 个线程，有点浪费</li></ul></li><li><p>用 sleep(n) 模拟洗茶壶、洗水壶等耗费的时间</p></li></ul><p>附：华罗庚《统筹方法》</p><blockquote><p>统筹方法，是一种安排工作进程的数学方法。它的实用范围极广泛，在企业管理和基本建设中，以及关系复杂的科研项目的组织与管理中，都可以应用。怎样应用呢？主要是把工序安排好。</p><p>比如，想泡壶茶喝。当时的情况是：开水没有；水壶要洗，茶壶、茶杯要洗；火已生了，茶叶也有了。怎么办？</p><ul><li>办法甲：洗好水壶，灌上凉水，放在火上；在等待水开的时间里，洗茶壶、洗茶杯、拿茶叶；等水开<br>了，泡茶喝。</li><li>办法乙：先做好一些准备工作，洗水壶，洗茶壶茶杯，拿茶叶；一切就绪，灌水烧水；坐待水开了，泡<br>茶喝。</li><li>办法丙：洗净水壶，灌上凉水，放在火上，坐待水开；水开了之后，急急忙忙找茶叶，洗茶壶茶杯，泡<br>茶喝。</li></ul><p>哪一种办法省时间？我们能一眼看出，第一种办法好，后两种办法都窝了工。<br>这是小事，但这是引子，可以引出生产管理等方面有用的方法来。<br>水壶不洗，不能烧开水，因而洗水壶是烧开水的前提。没开水、没茶叶、不洗茶壶茶杯，就不能泡茶，因而这些又是泡茶的前提。它们的相互关系，可以用下边的箭头图来表示：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210427095258.png"></p><p>从这个图上可以一眼看出，办法甲总共要16分钟（而办法乙、丙需要20分钟）。如果要缩短工时、提高工作效率，应当主要抓烧开水这个环节，而不是抓拿茶叶等环节。同时，洗茶壶茶杯、拿茶叶总共不过4分钟，大可利用“等水开”的时间来做。<br>是的，这好像是废话，卑之无甚高论。有如走路要用两条腿走，吃饭要一口一口吃，这些道理谁都懂得。但稍有变化，临事而迷的情况，常常是存在的。在近代工业的错综复杂的工艺过程中，往往就不是像泡茶喝这么简单了。任务多了，几百几千，甚至有好几万个任务。关系多了，错综复杂，千头万绪，往往出现“万事俱备，只欠东风”的情况。由于一两个零件没完成，耽误了一台复杂机器的出厂时间。或往往因为抓的不是关键，连夜三班，急急忙忙，完成这一环节之后，还得等待旁的环节才能装配。<br>洗茶壶，洗茶杯，拿茶叶，或先或后，关系不大，而且同是一个人的活儿，因而可以合并成为：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210427095321.png"></p><p>看来这是“小题大做”，但在工作环节太多的时候，这样做就非常必要了。<br>这里讲的主要是时间方面的事，但在具体生产实践中，还有其他方面的许多事。这种方法虽然不一定能直接解决所有问题，但是，我们利用这种方法来考虑问题，也是不无裨益的。</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test16</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            log.debug(<span class="hljs-string">&quot;洗水壶&quot;</span>);            sleep(<span class="hljs-number">1</span>);            log.debug(<span class="hljs-string">&quot;烧开水&quot;</span>);            sleep(<span class="hljs-number">5</span>);        &#125;,<span class="hljs-string">&quot;老王&quot;</span>);        Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            log.debug(<span class="hljs-string">&quot;洗茶壶&quot;</span>);            sleep(<span class="hljs-number">1</span>);            log.debug(<span class="hljs-string">&quot;洗茶杯&quot;</span>);            sleep(<span class="hljs-number">2</span>);            log.debug(<span class="hljs-string">&quot;拿茶叶&quot;</span>);            sleep(<span class="hljs-number">1</span>);            <span class="hljs-keyword">try</span> &#123;                t1.join();            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;            log.debug(<span class="hljs-string">&quot;泡茶&quot;</span>);        &#125;,<span class="hljs-string">&quot;小王&quot;</span>);        t1.start();        t2.start();    &#125;&#125;</code></pre><p>结果：</p><pre><code class="hljs js"><span class="hljs-number">10</span>:<span class="hljs-number">02</span>:<span class="hljs-number">54</span> [小王] c.Test16 - 洗茶壶<span class="hljs-number">10</span>:<span class="hljs-number">02</span>:<span class="hljs-number">54</span> [老王] c.Test16 - 洗水壶<span class="hljs-number">10</span>:<span class="hljs-number">02</span>:<span class="hljs-number">55</span> [老王] c.Test16 - 烧开水<span class="hljs-number">10</span>:<span class="hljs-number">02</span>:<span class="hljs-number">55</span> [小王] c.Test16 - 洗茶杯<span class="hljs-number">10</span>:<span class="hljs-number">02</span>:<span class="hljs-number">57</span> [小王] c.Test16 - 拿茶叶<span class="hljs-number">10</span>:<span class="hljs-number">03</span>:<span class="hljs-number">00</span> [小王] c.Test16 - 泡茶</code></pre><p>缺陷：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210427100610.png"></p><h2 id="3、并发之共享模型"><a href="#3、并发之共享模型" class="headerlink" title="3、并发之共享模型"></a>3、并发之共享模型</h2><p>本章内容</p><ul><li>共享问题</li><li>synchronized</li><li>线程安全分析</li><li>Monitor</li><li>wait/notify</li><li>线程状态转换</li><li>活跃性</li><li>Lock</li></ul><h3 id="3-1-共享带来的问题"><a href="#3-1-共享带来的问题" class="headerlink" title="3.1 共享带来的问题"></a>3.1 共享带来的问题</h3><h4 id="3-1-1-小故事"><a href="#3-1-1-小故事" class="headerlink" title="3.1.1 小故事"></a>3.1.1 小故事</h4><ul><li><p>老王（操作系统）有一个功能强大的算盘（CPU），现在想把它租出去，赚一点外快</p></li><li><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210427101307.png"></p></li><li><p>小南、小女（线程）来使用这个算盘来进行一些计算，并按照时间给老王支付费用</p></li><li><p>但小南不能一天24小时使用算盘，他经常要小憩一会（sleep），又或是去吃饭上厕所（阻塞 io 操作），有时还需要一根烟，没烟时思路全无（wait）这些情况统称为（阻塞）</p></li><li><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210427101344.png"></p></li><li><p>在这些时候，算盘没利用起来（不能收钱了），老王觉得有点不划算</p></li><li><p>另外，小女也想用用算盘，如果总是小南占着算盘，让小女觉得不公平</p></li><li><p>于是，老王灵机一动，想了个办法 [ 让他们每人用一会， <strong>轮流使用算盘</strong>  ]</p></li><li><p>这样，当小南阻塞的时候，算盘可以分给小女使用，不会浪费，反之亦然</p></li><li><p>最近执行的计算比较复杂，需要存储一些中间结果，而学生们的脑容量（工作内存）不够，所以老王申请了一个笔记本（主存），把一些中间结果先记在本上</p></li><li><p>计算流程是这样的</p></li><li><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210427101550.png"></p></li><li><p>但是由于分时系统，有一天还是发生了事故</p></li><li><p>小南刚读取了初始值 0 做了个 +1 运算，还没来得及写回结果</p></li><li><p>老王说 [ 小南，你的时间到了，该别人了，记住结果走吧 ]，于是小南念叨着 [ 结果是1，结果是1…] 不甘心地到一边待着去了（上下文切换）</p></li><li><p>老王说 [ 小女，该你了 ]，小女看到了笔记本上还写着 0 做了一个 -1 运算，将结果 -1 写入笔记本</p></li><li><p>这时小女的时间也用完了，老王又叫醒了小南：[小南，把你上次的题目算完吧]，小南将他脑海中的结果 1 写入了笔记本</p></li><li><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210427101951.png"></p></li><li><p>小南和小女都觉得自己没做错，但笔记本里的结果是 1 而不是 0</p></li></ul><h4 id="3-1-2-java体现"><a href="#3-1-2-java体现" class="headerlink" title="3.1.2 java体现"></a>3.1.2 java体现</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;    Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt; <span class="hljs-number">5000</span>; i++)&#123;            count++;        &#125;    &#125;);    Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt; <span class="hljs-number">5000</span>; i++)&#123;            count--;        &#125;    &#125;);    t1.start();    t2.start();    t1.join();    t2.join();    log.debug(<span class="hljs-string">&quot;count的值是&#123;&#125;&quot;</span>,count);&#125;</code></pre><p>结果：</p><pre><code class="hljs js"><span class="hljs-number">10</span>:<span class="hljs-number">24</span>:<span class="hljs-number">00</span> [main] c.Test17 - count的值是<span class="hljs-number">814</span></code></pre><h4 id="3-1-3-问题分析"><a href="#3-1-3-问题分析" class="headerlink" title="3.1.3 问题分析"></a>3.1.3 问题分析</h4><p>线程出现问题的根本原因是因为线程上下文切换，导致线程里的指令没有执行完就切换执行其它线程了。如上代码，当执行 count++ 或者 count– 操作的时候，从字节码分析，实际上是 4 步操作。</p><pre><code class="hljs js">getstatic i <span class="hljs-comment">// 获取静态变量i的值</span>iconst_1 <span class="hljs-comment">// 准备常量1</span>iadd <span class="hljs-comment">// 自增</span>putstatic i <span class="hljs-comment">// 将修改后的值存入静态变量i</span>    getstatic i <span class="hljs-comment">// 获取静态变量i的值</span>iconst_1 <span class="hljs-comment">// 准备常量1</span>isub <span class="hljs-comment">// 自减</span>putstatic i <span class="hljs-comment">// 将修改后的值存入静态变量i</span></code></pre><p>而 Java 的内存模型如下，完成静态变量的自增，自减需要在主存和工作内存中进行数据交换：</p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210427102737.png" style="zoom:33%;" /><p>如果是 <strong>单线程</strong> 以上 8 行代码是顺序执行（不会交错） <strong>没有问题</strong> ：</p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210427102809.png" style="zoom:33%;" /><p>但多线程下这 8 行代码可能交错运行：</p><ul><li><p>出现负数的情况：</p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210427102854.png" style="zoom:50%;" /></li><li><p>正数的情况：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210427102937.png"></p></li></ul><h4 id="3-1-4-临界区Critical-Section"><a href="#3-1-4-临界区Critical-Section" class="headerlink" title="3.1.4 临界区Critical Section"></a>3.1.4 临界区Critical Section</h4><ul><li>一个程序运行多个线程本身是没有问题的</li><li>问题出在多个线程访问 <strong>共享资源</strong> <ul><li>多个线程读共享资源其实也没有问题</li><li>在多个线程对共享资源读写操作时发生 <strong>指令交错</strong> ，就会出现问题</li></ul></li><li>一段代码块内如果存在对共享资源的多线程读写操作，称这段代码块为 <strong>临界区</strong> </li></ul><p>例如，下面代码中的临界区</p><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> counter = <span class="hljs-number">0</span>; <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increment</span><span class="hljs-params">()</span> </span><span class="hljs-function"><span class="hljs-comment">// 临界区 </span></span><span class="hljs-function"></span>&#123;       counter++; &#125; <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decrement</span><span class="hljs-params">()</span> </span><span class="hljs-function"><span class="hljs-comment">// 临界区 </span></span><span class="hljs-function"></span>&#123;     counter--; &#125;</code></pre><h4 id="3-1-5-竞态条件-Race-Condition"><a href="#3-1-5-竞态条件-Race-Condition" class="headerlink" title="3.1.5 竞态条件 Race Condition"></a>3.1.5 竞态条件 Race Condition</h4><p>多个线程在临界区内执行，由于代码的 <strong>执行序列不同</strong> 而导致结果无法预测，称之为发生了 <strong>竞态条件</strong> </p><h3 id="3-2-synchronized-解决方案"><a href="#3-2-synchronized-解决方案" class="headerlink" title="3.2 synchronized 解决方案"></a>3.2 synchronized 解决方案</h3><blockquote><p>应用之互斥</p></blockquote><p>为了避免临界区的竞态条件发生，有多种手段可以达到目的。</p><ul><li>阻塞式的解决方案：synchronized，Lock</li><li>非阻塞式的解决方案：原子变量</li></ul><p>本次使用阻塞式的解决方案： <strong>synchronized</strong> ，来解决上述问题，即俗称的 【 <strong>对象锁</strong> 】，它采用互斥的方式让同一时刻 <strong>至多只有一个线程</strong> 能持有【对象锁】，其它线程再想获取这个【对象锁】时就会阻塞住。这样就能保证拥有锁的线程可以安全的执行临界区内的代码，不用担心线程上下文切换</p><blockquote><p>注意<br>虽然 java 中互斥和同步都可以采用 synchronized 关键字来完成，但它们还是有区别的：</p><ul><li>互斥是保证临界区的竞态条件发生，同一时刻只能有一个线程执行临界区代码</li><li>同步是由于线程执行的先后、顺序不同、需要一个线程等待其它线程运行到某个点</li></ul></blockquote><h4 id="3-2-1-synchronized"><a href="#3-2-1-synchronized" class="headerlink" title="3.2.1 synchronized"></a>3.2.1 synchronized</h4><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>(对象) <span class="hljs-comment">// 线程1获得对象上的锁， 那么线程2再来到时的状态是(blocked)</span>&#123; 临界区&#125;</code></pre><p>代码：</p><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> counter = <span class="hljs-number">0</span>;<span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object lock = <span class="hljs-keyword">new</span> Object();<span class="hljs-function">rivate <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">synchronizedDemo</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;                <span class="hljs-keyword">synchronized</span> (lock) &#123;                    counter++;                &#125;            &#125;        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);        Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;                <span class="hljs-keyword">synchronized</span> (lock) &#123;                    counter--;                &#125;            &#125;        &#125;, <span class="hljs-string">&quot;t2&quot;</span>);        t1.start();        t2.start();        t1.join();        t2.join();        log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,counter);    &#125;</code></pre><pre><code class="hljs js"><span class="hljs-number">10</span>:<span class="hljs-number">39</span>:<span class="hljs-number">32</span> [main] c.Test17 - <span class="hljs-number">0</span></code></pre><h4 id="3-2-2-synchronized理解"><a href="#3-2-2-synchronized理解" class="headerlink" title="3.2.2  synchronized理解"></a>3.2.2  synchronized理解</h4><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210427104124.png"></p><p>你可以做这样的类比：</p><ul><li> <strong>synchronized(对象)</strong>  中的对象，可以想象为一个 <strong>房间（room）</strong> ，有 <strong>唯一入口</strong> （门）房间只能 <strong>一次进入一人</strong> 进行计算，线程 t1，t2 想象成两个人</li><li>当线程 t1 执行到 synchronized(room) 时就好比 t1 进入了这个房间，并锁住了门拿走了钥匙，在门内执行count++ 代码</li><li>这时候如果 t2 也运行到了 synchronized(room) 时，它发现门被锁住了，只能在 <strong>门外等待</strong> ，发生了上下文切换， <strong>阻塞住了</strong> </li><li>这中间即使 t1 的 cpu 时间片不幸用完，被踢出了门外（ <strong>不要错误理解为锁住了对象就能一直执行下去哦</strong> ），这时门还是锁住的，t1 仍拿着钥匙，t2 线程还在阻塞状态进不来， <strong>只有下次轮到 t1 自己再次获得时间片时才能开门进入</strong> </li><li>当 t1 执行完 synchronized{} 块内的代码，这时候才会从 obj 房间出来并解开门上的锁， <strong>唤醒</strong>  t2 线程把钥匙给他。t2 线程这时才可以进入 obj 房间，锁住了门拿上钥匙，执行它的 count– 代码</li></ul><p>用图：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210427104349.png"></p><h4 id="3-2-3-思考"><a href="#3-2-3-思考" class="headerlink" title="3.2.3 思考"></a>3.2.3 思考</h4><p>synchronized 实际是用 <strong>对象锁</strong> 保证了 <strong>临界区内代码的原子性</strong> ，临界区内的代码对外是不可分割的，不会被线程切换所打断。<br>为了加深理解，请思考下面的问题</p><ul><li><p>如果把 synchronized(obj) 放在 for 循环的外面，如何理解？– 原子性</p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210427105330.png" style="zoom:50%;" /><p>这里面的代码作为原子操作</p></li><li><p>如果 t1 synchronized(obj1) 而 t2 synchronized(obj2) 会怎样运作？– 锁对象</p><p>不行，不是同一把对象锁。</p></li><li><p>如果 t1 synchronized(obj) 而 t2 没有加会怎么样？如何理解？– 锁对象</p><p>不行，上下文切换时，不直接获取锁了，不会被阻塞住。</p></li></ul><h4 id="3-2-4-面向对象改进"><a href="#3-2-4-面向对象改进" class="headerlink" title="3.2.4 面向对象改进"></a>3.2.4 面向对象改进</h4><p>把需要保护的共享变量放入一个类</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Room</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> counter = <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increment</span><span class="hljs-params">()</span> </span>&#123;        counter++;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decrement</span><span class="hljs-params">()</span> </span>&#123;        counter--;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getCounter</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> counter;    &#125;&#125;</code></pre><p>对象；</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">synchronizedClassDemo</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException</span>&#123;    Room room = <span class="hljs-keyword">new</span> Room();    Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;            room.increment();        &#125;    &#125;, <span class="hljs-string">&quot;t1&quot;</span>);    Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;            room.decrement();        &#125;    &#125;, <span class="hljs-string">&quot;t2&quot;</span>);    t1.start();    t2.start();    t1.join();    t2.join();    log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, room.getCounter());&#125;</code></pre><pre><code class="hljs js"><span class="hljs-number">10</span>:<span class="hljs-number">57</span>:<span class="hljs-number">47</span> [main] c.Test17 - <span class="hljs-number">0</span></code></pre><h3 id="3-3-方法上的synchronized"><a href="#3-3-方法上的synchronized" class="headerlink" title="3.3 方法上的synchronized"></a>3.3 方法上的synchronized</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;        &#125;    &#125;    <span class="hljs-comment">//等价于</span>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">synchronized</span>(<span class="hljs-keyword">this</span>) &#123;                            <span class="hljs-comment">// 成员方法上锁住this对象</span>            &#125;        &#125;    &#125;<span class="hljs-comment">//------------------------------------------------------------------------------------------------</span>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;        &#125;    &#125;   <span class="hljs-comment">// 等价于</span>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">synchronized</span>(Test.class) &#123;                            <span class="hljs-comment">// 静态方法锁住类对象</span>            &#125;        &#125;    &#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210427110137.png"></p><h5 id="3-3-1-“线程八锁”"><a href="#3-3-1-“线程八锁”" class="headerlink" title="3.3.1 “线程八锁”"></a>3.3.1 “线程八锁”</h5><p>其实就是考察 synchronized 锁住的是哪个对象</p><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Test8Locks&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test8Locks</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Number n1 = <span class="hljs-keyword">new</span> Number();        <span class="hljs-comment">//Number n2 = new Number();</span>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            log.debug(<span class="hljs-string">&quot;begin&quot;</span>);            n1.a();        &#125;).start();        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            log.debug(<span class="hljs-string">&quot;begin&quot;</span>);            n1.b();        &#125;).start();    &#125;&#125;<span class="hljs-meta">@Slf4j(topic = &quot;c.Number&quot;)</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Number</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//        try &#123;</span><span class="hljs-comment">//            sleep(1);</span><span class="hljs-comment">//        &#125; catch (InterruptedException e) &#123;</span><span class="hljs-comment">//            e.printStackTrace();</span><span class="hljs-comment">//        &#125;</span>        log.debug(<span class="hljs-string">&quot;1&quot;</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">b</span><span class="hljs-params">()</span> </span>&#123;        log.debug(<span class="hljs-string">&quot;2&quot;</span>);    &#125;&#125;</code></pre><pre><code class="hljs js"><span class="hljs-number">11</span>:<span class="hljs-number">06</span>:<span class="hljs-number">35</span> [Thread-<span class="hljs-number">0</span>] c.Test8Locks - begin<span class="hljs-number">11</span>:<span class="hljs-number">06</span>:<span class="hljs-number">35</span> [Thread-<span class="hljs-number">1</span>] c.Test8Locks - begin<span class="hljs-number">11</span>:<span class="hljs-number">06</span>:<span class="hljs-number">35</span> [Thread-<span class="hljs-number">0</span>] c.Number - <span class="hljs-number">1</span><span class="hljs-number">11</span>:<span class="hljs-number">06</span>:<span class="hljs-number">35</span> [Thread-<span class="hljs-number">1</span>] c.Number - <span class="hljs-number">2</span></code></pre><ul><li><ol><li>最基础情况：打印12或者21，锁住的是同一个对象</li></ol></li><li><ol start="2"><li>如果把a()方法的sleep打开，一种是一秒后12 一种是2一秒后1；</li></ol></li></ul><p>情况3:</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Number</span></span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">()</span> </span>&#123;    sleep(<span class="hljs-number">1</span>);    log.debug(<span class="hljs-string">&quot;1&quot;</span>);  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">b</span><span class="hljs-params">()</span> </span>&#123;    log.debug(<span class="hljs-string">&quot;2&quot;</span>);  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">c</span><span class="hljs-params">()</span> </span>&#123;    log.debug(<span class="hljs-string">&quot;3&quot;</span>);  &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;  Number n1 = <span class="hljs-keyword">new</span> Number();  <span class="hljs-keyword">new</span> Thread(()-&gt;&#123; n1.a(); &#125;).start();  <span class="hljs-keyword">new</span> Thread(()-&gt;&#123; n1.b(); &#125;).start();  <span class="hljs-keyword">new</span> Thread(()-&gt;&#123; n1.c(); &#125;).start();&#125;</code></pre><ul><li><ol start="3"><li>c方法被调用没有互斥效果，3 1s后 12 或 2 3 1s后 1 或 3 2 1s后 1</li></ol></li></ul><p>情况3:</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Number</span></span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">()</span> </span>&#123;    sleep(<span class="hljs-number">1</span>);    log.debug(<span class="hljs-string">&quot;1&quot;</span>);  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">b</span><span class="hljs-params">()</span> </span>&#123;    log.debug(<span class="hljs-string">&quot;2&quot;</span>);  &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;  Number n1 = <span class="hljs-keyword">new</span> Number();  Number n2 = <span class="hljs-keyword">new</span> Number();  <span class="hljs-keyword">new</span> Thread(()-&gt;&#123; n1.a(); &#125;).start();  <span class="hljs-keyword">new</span> Thread(()-&gt;&#123; n2.b(); &#125;).start();&#125;</code></pre><ul><li><ol start="4"><li>2 1s 后 1 线程1执行时锁住n1，线程2锁住n2，所以2一定会先被打印</li></ol></li></ul><p>情况5:</p><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Number&quot;)</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Number</span></span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">()</span> </span>&#123;    sleep(<span class="hljs-number">1</span>);    log.debug(<span class="hljs-string">&quot;1&quot;</span>);    &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">b</span><span class="hljs-params">()</span> </span>&#123;    log.debug(<span class="hljs-string">&quot;2&quot;</span>);  &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;  Number n1 = <span class="hljs-keyword">new</span> Number();  <span class="hljs-keyword">new</span> Thread(()-&gt;&#123; n1.a(); &#125;).start();  <span class="hljs-keyword">new</span> Thread(()-&gt;&#123; n1.b(); &#125;).start();&#125;</code></pre><ul><li><ol start="5"><li>a锁住类对象，b锁住n1对象，不同对象，没有互斥，同时执行，一定是2先打印，2 1s后 1</li></ol></li></ul><p>情况6:</p><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Number&quot;)</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Number</span></span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">()</span> </span>&#123;    sleep(<span class="hljs-number">1</span>);    log.debug(<span class="hljs-string">&quot;1&quot;</span>);  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">b</span><span class="hljs-params">()</span> </span>&#123;    log.debug(<span class="hljs-string">&quot;2&quot;</span>);  &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;  Number n1 = <span class="hljs-keyword">new</span> Number();  <span class="hljs-keyword">new</span> Thread(()-&gt;&#123; n1.a(); &#125;).start();  <span class="hljs-keyword">new</span> Thread(()-&gt;&#123; n1.b(); &#125;).start();&#125;</code></pre><ul><li><ol start="6"><li>a b同一把锁，都是类对象，所以2 1s后 1或者1s后 1 2</li></ol></li></ul><p>情况7:</p><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Number&quot;)</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Number</span></span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">()</span> </span>&#123;    sleep(<span class="hljs-number">1</span>);    log.debug(<span class="hljs-string">&quot;1&quot;</span>);  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">b</span><span class="hljs-params">()</span> </span>&#123;    log.debug(<span class="hljs-string">&quot;2&quot;</span>);  &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;  Number n1 = <span class="hljs-keyword">new</span> Number();  Number n2 = <span class="hljs-keyword">new</span> Number();  <span class="hljs-keyword">new</span> Thread(()-&gt;&#123; n1.a(); &#125;).start();  <span class="hljs-keyword">new</span> Thread(()-&gt;&#123; n2.b(); &#125;).start();&#125;</code></pre><ul><li><ol start="7"><li>不是同一个对象，先打印2，2 1s后 1</li></ol></li></ul><p>情况8:</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Number</span></span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">()</span> </span>&#123;  sleep(<span class="hljs-number">1</span>);  log.debug(<span class="hljs-string">&quot;1&quot;</span>);  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">b</span><span class="hljs-params">()</span> </span>&#123;  log.debug(<span class="hljs-string">&quot;2&quot;</span>);  &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;  Number n1 = <span class="hljs-keyword">new</span> Number();  Number n2 = <span class="hljs-keyword">new</span> Number();  <span class="hljs-keyword">new</span> Thread(()-&gt;&#123; n1.a(); &#125;).start();  <span class="hljs-keyword">new</span> Thread(()-&gt;&#123; n2.b(); &#125;).start();&#125;</code></pre><ul><li><ol start="8"><li>是同一把锁，类对象一致，两种情况：1s后 1 2或者 2 1s后 1</li></ol></li></ul><h3 id="3-4-变量的线程安全分析"><a href="#3-4-变量的线程安全分析" class="headerlink" title="3.4 变量的线程安全分析"></a>3.4 变量的线程安全分析</h3><h4 id="3-4-1-成员变量和静态变量是否线程安全？"><a href="#3-4-1-成员变量和静态变量是否线程安全？" class="headerlink" title="3.4.1 成员变量和静态变量是否线程安全？"></a>3.4.1 成员变量和静态变量是否线程安全？</h4><ul><li>如果它们没有共享，则线程安全</li><li>如果它们被共享了，根据它们的状态是否能够改变，又分两种情况<ul><li>如果只有读操作，则线程安全</li><li>如果有读写操作，则这段代码是临界区，需要考虑线程安</li></ul></li></ul><h4 id="3-4-2-局部变量是否线程安全"><a href="#3-4-2-局部变量是否线程安全" class="headerlink" title="3.4.2 局部变量是否线程安全"></a>3.4.2 局部变量是否线程安全</h4><ul><li>局部变量是线程安全的</li><li>但局部变量引用的对象则未必<ul><li>如果该对象没有逃离方法的作用访问，它是线程安全的</li><li>如果该对象逃离方法的作用范围（return），需要考虑线程安全</li></ul></li></ul><h4 id="3-4-3-局部变量线程安全分析"><a href="#3-4-3-局部变量线程安全分析" class="headerlink" title="3.4.3 局部变量线程安全分析"></a>3.4.3 局部变量线程安全分析</h4><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;     <span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span>;     i++;&#125;</code></pre><p>每个线程调用 test1() 方法时局部变量 i，会在每个线程的栈帧内存中被创建多份，因此不存在共享</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210427112925.png"></p><p>i++操作和静态成员变量i++不一样。</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210427113103.png"></p><p>不安全例子：</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadUnsafe</span> </span>&#123;    ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> loopNumber)</span> </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; loopNumber; i++) &#123;            method2();            method3();        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">()</span> </span>&#123;        list.add(<span class="hljs-string">&quot;1&quot;</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method3</span><span class="hljs-params">()</span> </span>&#123;        list.remove(<span class="hljs-number">0</span>);    &#125;&#125;</code></pre><p>执行：</p><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> THREAD_NUMBER = <span class="hljs-number">2</span>;<span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> LOOP_NUMBER = <span class="hljs-number">200</span>;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    ThreadSafeSubClass test = <span class="hljs-keyword">new</span> ThreadSafeSubClass();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; THREAD_NUMBER; i++) &#123;        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            test.method1(LOOP_NUMBER);        &#125;, <span class="hljs-string">&quot;Thread&quot;</span> + (i+<span class="hljs-number">1</span>)).start();    &#125;&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210427113534.png"></p><p>线程读取集合到内存中添加了一个元素还 <strong>没有来得及写回</strong> ;</p><p>另一个线程 <strong>又来添加</strong> ，这个线程执行完毕之后之前的线程又把自己修改好的集合写回然后就少了一个元素，但会删除两次；</p><h5 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h5><p>无论哪个线程中的 method2 和method3 引用的都是同一个对象中的 list 成员变量：</p><p>一个 ArrayList ，在添加一个元素的时候，它可能会有两步来完成：</p><ol><li>第一步，在 arrayList[Size] 的位置 <strong>存放此元素； 第二步增大 Size 的值</strong> 。</li><li>在单线程运行的情况下，如果 Size = 0，添加一个元素后，此元素在位置 0，而且 Size=1；而如果是在多线程情下，比如有两个线程，线程 A 先将元素存放在位置 0。但是此时  <strong>CPU 调线程A暂停</strong> ，线程 B 得到运行的机会。线程B也向此 ArrayList 添加元素，因为此时 Size 仍等于 0 （注意哦，我们假设的是添加一个元素是要两个步骤哦，而线程A仅仅完成了步骤1），所以线程B也将元素存放在位置0。然后线程A和线程B都继续运行，都增加 Size 的值。 那好，现在我们来看看 ArrayList 的情况，元素实际上只有一个，存放在位置 0，而 Size 却等于 2。这就是“线程不 安全”了。</li></ol><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210427114224.png"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210427114334.png"></p><h5 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h5><p>可以将list修改成局部变量，那么就不会有上述问题了</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210427114442.png"></p><h5 id="思考-private-或-final的重要性"><a href="#思考-private-或-final的重要性" class="headerlink" title="思考 private 或 final的重要性"></a>思考 private 或 final的重要性</h5><p>方法访问修饰符带来的思考，如果把 method2 和 method3 的方法修改为 public 会不会代理线程安全问题？</p><ul><li>情况1：有其它线程调用 method2 和 method3</li><li>情况2：在 情况1 的基础上，为 ThreadSafe 类添加 <strong>子类</strong> ，子类覆盖 method2 或 method3 方法，即</li></ul><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadSafeSubClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ThreadSafe</span></span>&#123;    <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method3</span><span class="hljs-params">(ArrayList&lt;String&gt; list)</span> </span>&#123;    <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;    list.remove(<span class="hljs-number">0</span>);    &#125;).start();  &#125;&#125;</code></pre><blockquote><p>从这个例子可以看出 private 或 final 提供【安全】的意义所在，请体会开闭原则中的【闭】</p></blockquote><h4 id="3-4-4-常见线程安全类"><a href="#3-4-4-常见线程安全类" class="headerlink" title="3.4.4 常见线程安全类"></a>3.4.4 常见线程安全类</h4><ol><li>String</li><li>Integer</li><li>StringBuffer</li><li>Random</li><li>Vector</li><li>Hashtable</li><li>java.util.concurrent 包下的类</li></ol><p>这里说它们是线程安全的是指，多个线程调用它们 <strong>同一个实例的某个方法时</strong> ， <strong>是线程安全的</strong> 。也可以理解为</p><ul><li>它们的每个方法是原子的</li><li>但 <strong>注意</strong> 它们多个方法的 <strong>组合不是原子的</strong> ，见后面分析</li></ul><pre><code class="hljs java">Hashtable table = <span class="hljs-keyword">new</span> Hashtable();<span class="hljs-keyword">new</span> Thread(()-&gt;&#123;  table.put(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;value1&quot;</span>);&#125;).start();<span class="hljs-keyword">new</span> Thread(()-&gt;&#123;  table.put(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;value2&quot;</span>);&#125;).start();</code></pre><h5 id="线程安全类方法的组合"><a href="#线程安全类方法的组合" class="headerlink" title="线程安全类方法的组合"></a>线程安全类方法的组合</h5><p>分析下面代码是否线程安全？</p><pre><code class="hljs java">Hashtable table = <span class="hljs-keyword">new</span> Hashtable();<span class="hljs-comment">// 线程1，线程2</span><span class="hljs-keyword">if</span>( table.get(<span class="hljs-string">&quot;key&quot;</span>) == <span class="hljs-keyword">null</span>) &#123;  table.put(<span class="hljs-string">&quot;key&quot;</span>, value);&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210427115824.png"></p><h5 id="不可变类线程安全性"><a href="#不可变类线程安全性" class="headerlink" title="不可变类线程安全性"></a>不可变类线程安全性</h5><p><code>Sring</code>和<code>Integer</code>类都是不可变的类，因为其类内部状态是不可改变的，因此它们的方法都是线程安全的，或许有疑问，<code>String</code> 有 <code>replace</code>，<code>substring</code> 等方法【可以】改变值，其实调用这些方法返回的已经是一个新创建的对象了！</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210427120230.png"></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Immutable</span></span>&#123;     <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> value = <span class="hljs-number">0</span>;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Immutable</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span></span>&#123;     <span class="hljs-keyword">this</span>.value = value;    &#125;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getValue</span><span class="hljs-params">()</span></span>&#123;         <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.value;     &#125;     <span class="hljs-function"><span class="hljs-keyword">public</span> Immutable <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v)</span></span>&#123;         <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Immutable(<span class="hljs-keyword">this</span>.value + v);     &#125;&#125;</code></pre><h4 id="3-4-5-实例分析-是否线程安全"><a href="#3-4-5-实例分析-是否线程安全" class="headerlink" title="3.4.5 实例分析 是否线程安全"></a>3.4.5 实例分析 是否线程安全</h4><h5 id="实例一"><a href="#实例一" class="headerlink" title="实例一"></a>实例一</h5><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210427120705.png"></p><p>日期是可变类，属性可发生修改，这种都是线程不安全的</p><h5 id="实例二"><a href="#实例二" class="headerlink" title="实例二"></a>实例二</h5><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210427120933.png"></p><p>有共享资源</p><h5 id="实例三"><a href="#实例三" class="headerlink" title="实例三"></a>实例三</h5><p>分析线程是否安全，先对 <strong>类的成员变量，类变量，局部变量</strong> 进行考虑，如果变量会在各个线程之间 <strong>共享</strong> ，那么就得考虑线程安全问题了，如果 <strong>变量A引用的是线程安全类的实例</strong> ，并且 <strong>只调用该线程安全类的一个方法</strong> ，那么该变量A是 <strong>线程安全的</strong> 。下面对实例一进行分析：此类不是线程安全的，<code>MyAspect</code>切面类 <strong>只有一个实例</strong> ，成员变量<code>start</code> 会被多个线程同时进行读写操作</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210427121111.png"></p><p>可以用环绕通知，环绕通知会变成局部变量</p><h5 id="实例四"><a href="#实例四" class="headerlink" title="实例四"></a>实例四</h5><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210427153104.png"></p><p>此例是典型的三层模型调用，<code>MyServlet</code> <code>UserServiceImpl</code> <code>UserDaoImpl</code>类都只有一个实例，<code>UserDaoImpl</code>类中没有成员变量，<code>update</code>方法里的变量引用的对象不是线程共享的，所以是线程安全的；<code>UserServiceImpl</code>类中只有一个线程安全的<code>UserDaoImpl</code>类的实例，那么<code>UserServiceImpl</code>类也是线程安全的，同理 <code>MyServlet</code>也是线程安全的</p><h5 id="实例五"><a href="#实例五" class="headerlink" title="实例五"></a>实例五</h5><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210427153248.png"></p><p>跟示例二大体相似，<code>UserDaoImpl</code>类中有成员变量，那么多个线程可以对成员变量<code>conn</code> 同时进行操作，故是 <code>不安全的</code></p><h5 id="实例六"><a href="#实例六" class="headerlink" title="实例六"></a>实例六</h5><p>跟示例三大体相似，<code>UserServiceImpl</code>类的update方法中 UserDao是作为局部变量存在的，所以每个线程访问的时候都会新建有一个<code>UserDao</code>对象，新建的对象是线程独有的，所以是 <code>线程安全</code> 的</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210427153435.png"></p><h5 id="实例七"><a href="#实例七" class="headerlink" title="实例七"></a>实例七</h5><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210427153555.png"></p><p>foo是一个抽象方法，其中 foo 的行为是不确定的(即有可能并发访问到sdf，sdf对象里面的方法不是安全的)，所以可能导致不安全的发生，被称之为 <strong>外星方法</strong> ，因为foo方法可以被重写，导致线程不安全。在String类中就考虑到了这一点，String类是<code>finally</code>的，子类不能重写它的方法（从而无法破坏其线程安全的特性）。</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210427153736.png"></p><h4 id="3-4-6-卖票问题"><a href="#3-4-6-卖票问题" class="headerlink" title="3.4.6 卖票问题"></a>3.4.6 卖票问题</h4><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.ExerciseSell&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExerciseSell</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        <span class="hljs-comment">// 模拟多人买票</span>        TicketWindow window = <span class="hljs-keyword">new</span> TicketWindow(<span class="hljs-number">1000</span>);        <span class="hljs-comment">// 所有线程的集合</span>        List&lt;Thread&gt; threadList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-comment">// 卖出的票数统计</span>        List&lt;Integer&gt; amountList = <span class="hljs-keyword">new</span> Vector&lt;&gt;();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4000</span>; i++) &#123;            Thread thread = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;                                               <span class="hljs-comment">// 让线程不安全问题更加明显</span>                <span class="hljs-keyword">try</span> &#123;                    Thread.sleep(random(<span class="hljs-number">1000</span>));                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                &#125;                <span class="hljs-comment">// 买票</span>                <span class="hljs-keyword">int</span> amount = window.sell(random(<span class="hljs-number">5</span>));                <span class="hljs-comment">// 统计买票数</span>                amountList.add(amount);            &#125;);            threadList.add(thread);            thread.start();        &#125;        <span class="hljs-keyword">for</span> (Thread thread : threadList) &#123;            thread.join();        &#125;        <span class="hljs-comment">// 统计卖出的票数和剩余票数</span>        log.debug(<span class="hljs-string">&quot;余票：&#123;&#125;&quot;</span>,window.getCount());        log.debug(<span class="hljs-string">&quot;卖出的票数：&#123;&#125;&quot;</span>, amountList.stream().mapToInt(i-&gt; i).sum());    &#125;    <span class="hljs-comment">// Random 为线程安全</span>    <span class="hljs-keyword">static</span> Random random = <span class="hljs-keyword">new</span> Random();    <span class="hljs-comment">// 随机 1~5</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">random</span><span class="hljs-params">(<span class="hljs-keyword">int</span> amount)</span> </span>&#123;        <span class="hljs-keyword">return</span> random.nextInt(amount) + <span class="hljs-number">1</span>;    &#125;&#125;<span class="hljs-comment">// 售票窗口</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TicketWindow</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TicketWindow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> count)</span> </span>&#123;        <span class="hljs-keyword">this</span>.count = count;    &#125;    <span class="hljs-comment">// 获取余票数量</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getCount</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> count;    &#125;    <span class="hljs-comment">// 售票</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sell</span><span class="hljs-params">(<span class="hljs-keyword">int</span> amount)</span> </span>&#123;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.count &gt;= amount) &#123;            <span class="hljs-keyword">this</span>.count -= amount;            <span class="hljs-keyword">return</span> amount;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;    &#125;&#125;</code></pre><p>结果：</p><pre><code class="hljs js"><span class="hljs-number">15</span>:<span class="hljs-number">57</span>:<span class="hljs-number">15</span> [main] c.ExerciseSell - 余票：<span class="hljs-number">0</span><span class="hljs-number">15</span>:<span class="hljs-number">57</span>:<span class="hljs-number">15</span> [main] c.ExerciseSell - 卖出的票数：<span class="hljs-number">1013</span></code></pre><p>给sell方法加上synchronized即可</p><h4 id="3-4-7-转账问题"><a href="#3-4-7-转账问题" class="headerlink" title="3.4.7 转账问题"></a>3.4.7 转账问题</h4><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.ExerciseTransfer&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExerciseTransfer</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        Account a = <span class="hljs-keyword">new</span> Account(<span class="hljs-number">1000</span>);        Account b = <span class="hljs-keyword">new</span> Account(<span class="hljs-number">1000</span>);        Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;                a.transfer(b, randomAmount());            &#125;        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);        Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;                b.transfer(a, randomAmount());            &#125;        &#125;, <span class="hljs-string">&quot;t2&quot;</span>);        t1.start();        t2.start();        t1.join();        t2.join();        <span class="hljs-comment">// 查看转账2000次后的总金额</span>        log.debug(<span class="hljs-string">&quot;total:&#123;&#125;&quot;</span>, (a.getMoney() + b.getMoney()));    &#125;    <span class="hljs-comment">// Random 为线程安全</span>    <span class="hljs-keyword">static</span> Random random = <span class="hljs-keyword">new</span> Random();    <span class="hljs-comment">// 随机 1~100</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">randomAmount</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> random.nextInt(<span class="hljs-number">100</span>) + <span class="hljs-number">1</span>;    &#125;&#125;<span class="hljs-comment">// 账户</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Account</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> money;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Account</span><span class="hljs-params">(<span class="hljs-keyword">int</span> money)</span> </span>&#123;        <span class="hljs-keyword">this</span>.money = money;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMoney</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> money;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setMoney</span><span class="hljs-params">(<span class="hljs-keyword">int</span> money)</span> </span>&#123;        <span class="hljs-keyword">this</span>.money = money;    &#125;    <span class="hljs-comment">// 转账</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">transfer</span><span class="hljs-params">(Account target, <span class="hljs-keyword">int</span> amount)</span> </span>&#123;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.money &gt;= amount) &#123;            <span class="hljs-keyword">this</span>.setMoney(<span class="hljs-keyword">this</span>.getMoney() - amount);            target.setMoney(target.getMoney() + amount);        &#125;    &#125;&#125;</code></pre><pre><code class="hljs js"><span class="hljs-number">18</span>:<span class="hljs-number">27</span>:<span class="hljs-number">00</span> [main] c.ExerciseTransfer - total:<span class="hljs-number">85</span></code></pre><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> (Account.class)&#123;    <span class="hljs-comment">// 是Account.class</span>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.money &gt;= amount) &#123;        <span class="hljs-keyword">this</span>.setMoney(<span class="hljs-keyword">this</span>.getMoney() - amount);        target.setMoney(target.getMoney() + amount);    &#125;&#125;</code></pre><p>为什么不直接在方法上加上synchronized？</p><p>等于</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210427183002.png"></p><p>this对象和target不是一个</p><h3 id="3-5-Monitor-概念"><a href="#3-5-Monitor-概念" class="headerlink" title="3.5 Monitor 概念"></a>3.5 Monitor 概念</h3><h4 id="3-5-1-Java对象头"><a href="#3-5-1-Java对象头" class="headerlink" title="3.5.1 Java对象头"></a>3.5.1 Java对象头</h4><p>以 32 位虚拟机为例，普通对象的对象头结构如下，其中的Klass Word为指针，指向对象从属的class（Student or ….），即找到类对象。</p><p>32 位虚拟机中int4个字节，integer 对象头 8 + int 的value 4 = 12字节</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210428075640.png"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210428080224.png"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210428080236.png"></p><p>Biased_lock 偏向锁，01为加锁状态</p><p>所以一个对象的结构：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210428080644.png"></p><h4 id="3-5-2-Monitor-锁"><a href="#3-5-2-Monitor-锁" class="headerlink" title="3.5.2 Monitor(锁)"></a>3.5.2 Monitor(锁)</h4><p>Monitor被翻译为 <code>监视器</code> 或者说 <code>管程</code></p><p>每个java对象都可以关联一个Monitor，如果使用<code>synchronized</code>给对象上锁（重量级），该对象头的 <strong>Mark Word中就被设置为指向Monitor对象的指针</strong> </p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210428080900.png"></p><p>obj是java对象，Monitor的操作系统提供的对象</p><p>obj mark word修改为10</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210428081139.png"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210428081235.png"></p><ul><li>刚开始时Monitor中的Owner为null</li><li>当Thread-2 执行synchronized(obj){}代码时就会将Monitor的所有者Owner 设置为 Thread-2，上锁成功，Monitor中同一时刻只能有一个Owner</li><li>当Thread-2 占据锁时，如果线程Thread-3，Thread-4也来执行synchronized(obj){}代码，就会进入EntryList(等待队列，阻塞队列)中变成BLOCKED状态</li><li>Thread-2 执行完同步代码块的内容，然后唤醒 EntryList 中等待的线程来竞争锁，竞争时是 <strong>非公平的</strong> </li><li>图中 WaitSet 中的 Thread-0，Thread-1 是 <strong>之前获得过锁，但条件不满足进入 WAITING 状态的线程</strong> ，后面讲wait-notify 时会分析</li></ul><blockquote><p>注意：synchronized 必须是进入同一个对象的 monitor 才有上述的效果，不加 synchronized 的对象不会关联监视器，不遵从以上规则</p></blockquote><h5 id="原理之synchronized"><a href="#原理之synchronized" class="headerlink" title="原理之synchronized"></a>原理之synchronized</h5><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object lock=<span class="hljs-keyword">new</span> Object();    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> counter = <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">synchronized</span> (lock) &#123;            counter++;        &#125;    &#125;</code></pre><p>反编译后的部分字节码</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210428082324.png"></p><p>下面有检测范围 6 - 16 异常则到19；e为异常对象</p><pre><code class="hljs ruby"><span class="hljs-number">0</span> getstatic <span class="hljs-comment">#2 &lt;com/concurrent/test/Test17.lock&gt;</span> <span class="hljs-comment"># 取得lock的引用（synchronized开始了）</span> <span class="hljs-number">3</span> dup     <span class="hljs-comment"># 复制操作数栈栈顶的值放入栈顶，即复制了一份lock的引用</span> <span class="hljs-number">4</span> astore_1 <span class="hljs-comment"># 操作数栈栈顶的值弹出，即将lock的引用存到局部变量表中</span> <span class="hljs-number">5</span> monitorenter <span class="hljs-comment"># 将lock对象的Mark Word置为指向Monitor指针</span> <span class="hljs-number">6</span> getstatic <span class="hljs-comment">#3 &lt;com/concurrent/test/Test17.counter&gt;</span> <span class="hljs-number">9</span> iconst_1<span class="hljs-number">10</span> iadd<span class="hljs-number">11</span> putstatic <span class="hljs-comment">#3 &lt;com/concurrent/test/Test17.counter&gt;</span><span class="hljs-number">14</span> aload_1<span class="hljs-comment"># 从局部变量表中取得lock的引用，放入操作数栈栈顶</span><span class="hljs-number">15</span> monitorexit<span class="hljs-comment"># 将lock对象的Mark Word重置，唤醒EntryList</span><span class="hljs-number">16</span> goto <span class="hljs-number">24</span> (+<span class="hljs-number">8</span>)<span class="hljs-comment"># 下面是异常处理指令，可以看到，如果出现异常，也能自动地释放锁</span><span class="hljs-number">19</span> astore_2<span class="hljs-number">20</span> aload_1<span class="hljs-number">21</span> monitorexit<span class="hljs-number">22</span> aload_2<span class="hljs-number">23</span> athrow<span class="hljs-number">24</span> <span class="hljs-keyword">return</span></code></pre><p>注意： <strong>方法级别的 synchronized 不会在字节码指令中有所体现</strong> </p><h5 id="synchronized-原理进阶"><a href="#synchronized-原理进阶" class="headerlink" title="synchronized 原理进阶"></a>synchronized 原理进阶</h5><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210428083344.png"></p><p>​   </p><h5 id="1-轻量级锁"><a href="#1-轻量级锁" class="headerlink" title="1. 轻量级锁"></a>1. 轻量级锁</h5><p>轻量级锁的使用场景是：如果一个对象虽然有多个线程要对它进行加锁，但是加锁的 <strong>时间是错开的</strong> （也就是没有人可以竞争的），那么可以使用轻量级锁来进行优化。</p><p>轻量级锁对使用者是透明的，即语法仍然是<code>synchronized</code></p><p>假设有两个方法同步块，利用同一个对象加锁</p><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object obj = <span class="hljs-keyword">new</span> Object();<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span> </span>&#123;     <span class="hljs-keyword">synchronized</span>( obj ) &#123;         <span class="hljs-comment">// 同步块 A</span>         method2();     &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">()</span> </span>&#123;     <span class="hljs-keyword">synchronized</span>( obj ) &#123;         <span class="hljs-comment">// 同步块 B</span>     &#125;&#125;</code></pre><ul><li><p>每次指向到synchronized代码块时，都会创建 <strong>锁记录（Lock Record）</strong> 对象，每个线程的栈帧都会包含一个 <strong>锁记录的结构</strong> ，内部可以存储锁定对象的 <strong>Mark Word</strong> ，还有一个对象指针 Object reference</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210428084101.png"></p></li><li><p>让锁记录中的Object reference指向对象，并且尝试用 <strong>cas(compare and sweep)</strong> 替换Object对象的Mark Word ，将Mark Word 的值存入锁记录中</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210428084149.png"></p></li><li><p>如果cas替换成功，那么对象的对象头储存的就是 <code>锁记录的地址和状态00</code> ，表示由线程给对象加锁，如下所示</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210428084247.png"></p></li><li><p>如果cas失败，有两种情况</p><ul><li>如果是其它线程已经持有了该Object的轻量级锁（已经替换成了00），那么表示有竞争，将进入 <strong>锁膨胀阶段</strong> </li><li>如果是自己的线程已经执行了synchronized进行加锁，那么那么 <strong>再添加一条 Lock Record 作为重入的计数</strong> </li></ul><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210428085820.png"></p></li><li><p>当线程退出synchronized代码块的时候， **如果获取的是取值为 null 的锁记录 ** ，表示有重入，这时重置锁记录，表示重入计数减一</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210428090021.png"></p></li><li><p>当线程退出synchronized代码块的时候，如果获取的锁记录取值不为 null，那么使用cas将Mark Word的值恢复给对象</p><ul><li><p>成功则解锁成功</p></li><li><p>失败，则说明轻量级锁进行了 <strong>锁膨胀或已经升级为重量级锁</strong> ， <strong>进入重量级锁解锁流程</strong> </p></li></ul></li></ul><h5 id="2-锁膨胀"><a href="#2-锁膨胀" class="headerlink" title="2. 锁膨胀"></a>2. 锁膨胀</h5><p>如果在尝试加轻量级锁的过程中， <strong>CAS 操作无法成功</strong> ，这时一种情况就是有其它线程为此对象加上了轻量级锁（ <code>有竞争</code> ），这时需要进行 <code>锁膨胀</code> ，将轻量级锁变为重量级锁。</p><pre><code class="hljs java"><span class="hljs-keyword">static</span> Object obj = <span class="hljs-keyword">new</span> Object();  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">synchronized</span>( obj ) &#123;    <span class="hljs-comment">// 同步块</span>&#125;</code></pre><ul><li><p>当 Thread-1 进行轻量级加锁时，Thread-0 已经对该对象加了轻量级锁</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210428090410.png"></p></li><li><p>这时 Thread-1 加轻量级锁失败，进入锁膨胀流程</p><ul><li>即为对象申请Monitor锁，让Object指向 <strong>重量级锁地址</strong> ，然后自己进入Monitor 的EntryList 变成BLOCKED状态</li><li><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210428090610.png"><ul><li>当Thread-0 退出synchronized同步块时，使用cas将Mark Word的值恢复给对象头， <code>失败</code> ，那么会进入 <strong>重量级锁的解锁过程</strong> ，即按照Monitor的地址找到Monitor对象，将 <strong>Owner设置为null</strong> ，  <strong>唤醒</strong> EntryList 中的Thread-1线程</li></ul></li></ul></li></ul><h5 id="3-自旋优化"><a href="#3-自旋优化" class="headerlink" title="3. 自旋优化"></a>3. 自旋优化</h5><p>重量级锁竞争的时候，还可以使用 <code>自旋</code> 来进行优化，如果当前线程 <code>自旋成功</code>（即这时候持锁线程已经退出了同步块，释放了锁），这时当前线程就可以避免阻塞。  <code>阻塞</code> 是会发生 <strong>上下文切换的</strong> 。</p><ul><li><p>自旋成功</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210428091416.png"></p></li><li><p>自旋失败</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210428091529.png"></p></li><li><p>自旋会 <strong>占用 CPU 时间</strong> ，单核 CPU 自旋就是浪费，多核 CPU 自旋才能发挥优势。</p></li><li><p>在 Java 6 之后自旋锁是 <strong>自适应的</strong> ，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会高，就多自旋几次；反之，就少自旋甚至不自旋，总之，比较智能。</p></li><li><p>Java 7 之后 <strong>不能控制是否开启自旋功能</strong> </p></li></ul><h5 id="4-偏向锁"><a href="#4-偏向锁" class="headerlink" title="4. 偏向锁"></a>4. 偏向锁</h5><p>轻量级锁在没有竞争时（就自己这个线程）， <strong>每次重入仍然需要执行 CAS 操作</strong> 。<br>Java 6 中引入了偏向锁来做进一步优化：只有第一次使用 CAS 将线程 ID 设置到对象的 Mark Word 头，之后 <strong>发现这个线程 ID 是自己的就表示没有竞争</strong> ，不用重新 CAS。以后只要不发生竞争，这个对象就归该线程所有。</p><p>例如：</p><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object obj = <span class="hljs-keyword">new</span> Object();<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m1</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">synchronized</span>(obj) &#123;        <span class="hljs-comment">// 同步块 A</span>        m2();    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m2</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">synchronized</span>(obj) &#123;        <span class="hljs-comment">// 同步块 B</span>        m3();    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m3</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">synchronized</span>(obj) &#123;        <span class="hljs-comment">// 同步块 C</span>    &#125;&#125;</code></pre><p>每次都要CAS；</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210428091938.png"></p><p>偏向锁时：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210428092008.png"></p><h6 id="偏向状态"><a href="#偏向状态" class="headerlink" title="偏向状态"></a>偏向状态</h6><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210428093024.png"></p><p>一个对象创建时：</p><ul><li>如果开启了偏向锁（默认开启），那么对象创建后，markword 值为 0x05 即最后 3 位为  <code>101</code> ，这时它的thread、epoch、age 都为 0</li><li>偏向锁是默认是 <code>延迟的</code> ，不会在程序启动时立即生效，如果想避免延迟，可以加 VM 参数 -<br> <code>-XX:BiasedLockingStartupDelay=0</code>  来禁用延迟</li><li>如果没有开启偏向锁，那么对象创建后，markword 值为 0x01 即最后 3 位为 001，这时它的 hashcode、age 都为 0，第一次用到 hashcode 时才会赋值</li></ul><h6 id="测试偏向锁"><a href="#测试偏向锁" class="headerlink" title="测试偏向锁"></a>测试偏向锁</h6><pre><code class="hljs java"><span class="hljs-comment">// 测试偏向锁</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;    Dog d = <span class="hljs-keyword">new</span> Dog();    log.debug(ClassLayout.parseInstance(d).toPrintable());    <span class="hljs-keyword">try</span> &#123;        Thread.sleep(<span class="hljs-number">4000</span>);    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;        e.printStackTrace();    &#125;    log.debug(ClassLayout.parseInstance(<span class="hljs-keyword">new</span> Dog()).toPrintable());&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210428100027.png"></p><p>如果加上<code>-XX:BiasedLockingStartupDelay=0</code></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210428100232.png"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210428100406.png"></p><h6 id="测试偏向锁Thread-ID"><a href="#测试偏向锁Thread-ID" class="headerlink" title="测试偏向锁Thread-ID"></a>测试偏向锁Thread-ID</h6><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210428100549.png"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210428100642.png"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210428100658.png"></p><h6 id="测试禁用和hashcode"><a href="#测试禁用和hashcode" class="headerlink" title="测试禁用和hashcode"></a>测试禁用和hashcode</h6><p>如果没有开启偏向锁，那么对象创建后最后三位的值为001，这时候它的hashcode，age都为0，hashcode是第一次用到<code>hashcode</code>时才赋值的。在上面测试代码运行时在添加 VM 参数<code>-XX:-UseBiasedLocking</code>禁用偏向锁（禁用偏向锁则优先使用轻量级锁），退出<code>synchronized</code>状态变回001</p><ol><li>测试代码Test18.java 虚拟机参数<code>-XX:-UseBiasedLocking</code></li><li>输出结果如下，最开始状态为001，然后加轻量级锁变成00，最后恢复成001</li></ol><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;    Dog d = <span class="hljs-keyword">new</span> Dog();    log.debug(ClassLayout.parseInstance(d).toPrintable());    <span class="hljs-keyword">synchronized</span> (d)&#123;        log.debug(ClassLayout.parseInstance(d).toPrintable());    &#125;    <span class="hljs-keyword">try</span> &#123;        Thread.sleep(<span class="hljs-number">1000</span>);    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;        e.printStackTrace();    &#125;    log.debug(ClassLayout.parseInstance(<span class="hljs-keyword">new</span> Dog()).toPrintable());&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210428101359.png"></p><p>正常状态对象一开始是没有 hashCode 的，第一次调用才生成</p><p>d.hashcode()会禁用偏向锁</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210428101642.png"></p><p>当一个可偏向的对象，调用hashcode方法会 <code>撤销可偏向状态</code> ，然后把线程id清掉替换成hash码，因为没有地方存储了。</p><h6 id="撤销偏向锁-hashcode方法"><a href="#撤销偏向锁-hashcode方法" class="headerlink" title="撤销偏向锁-hashcode方法"></a>撤销偏向锁-hashcode方法</h6><p>如上，当一个可偏向的对象，调用hashcode方法会 <code>撤销可偏向状态</code> ，然后把线程id清掉替换成hash码，因为没有地方存储了。</p><h6 id="撤销偏向锁-其它线程使用对象"><a href="#撤销偏向锁-其它线程使用对象" class="headerlink" title="撤销偏向锁-其它线程使用对象"></a>撤销偏向锁-其它线程使用对象</h6><p>这里我们演示的是偏向锁撤销变成轻量级锁的过程，那么就得满足轻量级锁的使用条件，就是没有线程对同一个对象进行锁竞争，我们使用<code>wait</code> 和 <code>notify</code> 来辅助实现</p><ol><li>虚拟机参数<code>-XX:BiasedLockingStartupDelay=0</code>确保我们的程序最开始使用了偏向锁</li><li>输出结果，最开始使用的是偏向锁，但是第二个线程尝试获取对象锁时，发现本来对象偏向的是线程一，那么偏向锁就会失效，加的就是轻量级锁</li></ol><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;    Dog d = <span class="hljs-keyword">new</span> Dog();    Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;        log.debug(ClassLayout.parseInstance(d).toPrintable());        <span class="hljs-keyword">synchronized</span> (d) &#123;            log.debug(ClassLayout.parseInstance(d).toPrintable());        &#125;        log.debug(ClassLayout.parseInstance(d).toPrintable());        <span class="hljs-keyword">synchronized</span> (TestBiased.class) &#123;            TestBiased.class.notify();        &#125;    &#125;, <span class="hljs-string">&quot;t1&quot;</span>);    t1.start();    <span class="hljs-comment">// 如果不用 wait/notify 使用 join 必须打开下面的注释</span>  <span class="hljs-comment">// 因为：t1 线程不能结束，否则底层线程可能被 jvm 重用作为 t2 线程，底层线程 id 是一样的</span>  <span class="hljs-comment">/*try &#123;</span><span class="hljs-comment">  System.in.read();</span><span class="hljs-comment">  &#125; catch (IOException e) &#123;</span><span class="hljs-comment">  e.printStackTrace();</span><span class="hljs-comment">  &#125;*/</span>    Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;        <span class="hljs-keyword">synchronized</span> (TestBiased.class) &#123;            <span class="hljs-keyword">try</span> &#123;                TestBiased.class.wait();            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;        log.debug(ClassLayout.parseInstance(d).toPrintable());        <span class="hljs-keyword">synchronized</span> (d) &#123;            log.debug(ClassLayout.parseInstance(d).toPrintable());        &#125;        log.debug(ClassLayout.parseInstance(d).toPrintable());    &#125;, <span class="hljs-string">&quot;t2&quot;</span>);    t2.start();&#125;</code></pre><p>t1线程：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210428102835.png"></p><p>t2线程：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210428102933.png"></p><h6 id="撤销-调用-wait-notify"><a href="#撤销-调用-wait-notify" class="headerlink" title="撤销 - 调用 wait/notify"></a>撤销 - 调用 wait/notify</h6><p>会使对象的锁变成重量级锁，因为wait/notify方法之后 <code>重量级锁</code> 才支持</p><p>8是xxxxx1000 即后面为00，加的是 <code>轻量级锁</code> </p><h5 id="5-批量重偏向和撤销"><a href="#5-批量重偏向和撤销" class="headerlink" title="5. 批量重偏向和撤销"></a>5. 批量重偏向和撤销</h5><h6 id="批量重偏向"><a href="#批量重偏向" class="headerlink" title="批量重偏向"></a>批量重偏向</h6><p>如果对象虽然被多个线程访问，但没有竞争，这时偏向了线程 T1 的对象仍有机会重新偏向 T2，重偏向会重置对象的 Thread ID<br>当撤销偏向锁阈值超过 20 次后，jvm 会这样觉得，我是不是偏向错了呢，于是会在给这些对象加锁时 <code>重新偏向</code> 至加锁线程</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;    Vector&lt;Dog&gt; list = <span class="hljs-keyword">new</span> Vector&lt;&gt;();    Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">30</span>; i++) &#123;            Dog d = <span class="hljs-keyword">new</span> Dog();            list.add(d);            <span class="hljs-keyword">synchronized</span> (d) &#123;                log.debug(i + <span class="hljs-string">&quot;\t&quot;</span> + ClassLayout.parseInstance(d).toPrintable());            &#125;        &#125;        <span class="hljs-keyword">synchronized</span> (list) &#123;            list.notify();        &#125;    &#125;, <span class="hljs-string">&quot;t1&quot;</span>);    t1.start();    Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;        <span class="hljs-keyword">synchronized</span> (list) &#123;            <span class="hljs-keyword">try</span> &#123;                list.wait();            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;        log.debug(<span class="hljs-string">&quot;===============&gt; &quot;</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">30</span>; i++) &#123;            Dog d = list.get(i);            log.debug(i + <span class="hljs-string">&quot;\t&quot;</span> + ClassLayout.parseInstance(d).toPrintable());            <span class="hljs-keyword">synchronized</span> (d) &#123;                log.debug(i + <span class="hljs-string">&quot;\t&quot;</span> + ClassLayout.parseInstance(d).toPrintable());            &#125;            log.debug(i + <span class="hljs-string">&quot;\t&quot;</span> + ClassLayout.parseInstance(d).toPrintable());        &#125;    &#125;, <span class="hljs-string">&quot;t2&quot;</span>);    t2.start();&#125;</code></pre><p>一开始：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210428104035.png"></p><p>t1的thread-id</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210428104237.png"></p><p>运行20次之后：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210428104444.png"></p><h6 id="批量撤销"><a href="#批量撤销" class="headerlink" title="批量撤销"></a>批量撤销</h6><p>当撤销偏向锁阈值超过 <code>40</code>  次后，jvm 会这样觉得，自己确实偏向错了，根本就不该偏向。于是 <strong>整个类的所有对象都会变为不可偏向的</strong> ， <code>新建的对象也是不可偏向的</code> </p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test4</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;    Vector&lt;Dog&gt; list = <span class="hljs-keyword">new</span> Vector&lt;&gt;();    <span class="hljs-keyword">int</span> loopNumber = <span class="hljs-number">39</span>;    t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; loopNumber; i++) &#123;            Dog d = <span class="hljs-keyword">new</span> Dog();            list.add(d);            <span class="hljs-keyword">synchronized</span> (d) &#123;                log.debug(i + <span class="hljs-string">&quot;\t&quot;</span> + ClassLayout.parseInstance(d).toPrintable());            &#125;        &#125;        LockSupport.unpark(t2);    &#125;, <span class="hljs-string">&quot;t1&quot;</span>);    t1.start();    t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;        LockSupport.park();        log.debug(<span class="hljs-string">&quot;===============&gt; &quot;</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; loopNumber; i++) &#123;            Dog d = list.get(i);            log.debug(i + <span class="hljs-string">&quot;\t&quot;</span> + ClassLayout.parseInstance(d).toPrintable());            <span class="hljs-keyword">synchronized</span> (d) &#123;                log.debug(i + <span class="hljs-string">&quot;\t&quot;</span> + ClassLayout.parseInstance(d).toPrintable());            &#125;            log.debug(i + <span class="hljs-string">&quot;\t&quot;</span> + ClassLayout.parseInstance(d).toPrintable());        &#125;        LockSupport.unpark(t3);    &#125;, <span class="hljs-string">&quot;t2&quot;</span>);    t2.start();    t3 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;        LockSupport.park();        log.debug(<span class="hljs-string">&quot;===============&gt; &quot;</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; loopNumber; i++) &#123;            Dog d = list.get(i);            log.debug(i + <span class="hljs-string">&quot;\t&quot;</span> + ClassLayout.parseInstance(d).toPrintable());            <span class="hljs-keyword">synchronized</span> (d) &#123;                log.debug(i + <span class="hljs-string">&quot;\t&quot;</span> + ClassLayout.parseInstance(d).toPrintable());            &#125;            log.debug(i + <span class="hljs-string">&quot;\t&quot;</span> + ClassLayout.parseInstance(d).toPrintable());        &#125;    &#125;, <span class="hljs-string">&quot;t3&quot;</span>);    t3.start();    t3.join();    log.debug(ClassLayout.parseInstance(<span class="hljs-keyword">new</span> Dog()).toPrintable());&#125;</code></pre><p>一开始全偏向t1，t2 20次后变成t2，t3 20次后变成t3，当  <code>第40次撤销偏向锁</code> 的时候，对象不会再变为可偏向的。</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210428110241.png"></p><p>如果把循环次数变成38次：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210428110305.png"></p><blockquote><p>参考资料<br><a href="https://github.com/farmerjohngit/myblog/issues/12">https://github.com/farmerjohngit/myblog/issues/12</a><br><a href="https://www.cnblogs.com/LemonFive/p/11246086.html">https://www.cnblogs.com/LemonFive/p/11246086.html</a><br><a href="https://www.cnblogs.com/LemonFive/p/11248248.html">https://www.cnblogs.com/LemonFive/p/11248248.html</a><br>偏向锁论文</p></blockquote><h5 id="6-锁消除"><a href="#6-锁消除" class="headerlink" title="6. 锁消除"></a>6. 锁消除</h5><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210428110653.png"></p><p>比较不加锁和加锁性能多少</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210428111209.png"></p><ul><li><p>为什么普通java -jar 显示性能得分相差不大？</p><p>java中有 <code>JIT（即时编译器）</code> ，（反复执行的代码）会对java字节码进一步优化，查看局部变量是否会优化，发现不会逃离范围，不可能会被共享，加锁就没有意义，JIT就直接会优化掉synchronized</p><ul><li>选择 -XX: -EliminateLocks 关掉JIT</li></ul></li></ul><p>锁粗化<br>对相同对象多次加锁，导致线程发生多次重入，可以使用锁粗化方式来优化，这不同于之前讲的细分锁的粒度。</p><h3 id="3-6-wait-notify"><a href="#3-6-wait-notify" class="headerlink" title="3.6 wait notify"></a>3.6 wait notify</h3><h4 id="3-6-1-小故事-为什么需要-wait"><a href="#3-6-1-小故事-为什么需要-wait" class="headerlink" title="3.6.1 小故事 - 为什么需要 wait"></a>3.6.1 小故事 - 为什么需要 wait</h4><p>​   <img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210428190523.png"></p><h4 id="3-6-2-wait-notify-原理"><a href="#3-6-2-wait-notify-原理" class="headerlink" title="3.6.2 wait notify 原理"></a>3.6.2 wait notify 原理</h4><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210428205321.png"></p><ul><li>Owner 线程发现条件不满足，调用  <code>wait</code>  方法，即可进入 WaitSet 变为 WAITING 状态</li><li>BLOCKED 和 WAITING 的线程都处于 <code>阻塞状态</code> ，不占用 CPU 时间片</li><li>BLOCKED 线程会在 Owner 线程释放锁时唤醒</li><li>WAITING 线程会在 Owner 线程调用 notify 或 notifyAll 时唤醒，但唤醒后并不意味者立刻获得锁， <strong>仍需进入EntryList 重新竞争</strong> </li></ul><h4 id="3-6-3-API介绍"><a href="#3-6-3-API介绍" class="headerlink" title="3.6.3 API介绍"></a>3.6.3 API介绍</h4><ul><li> <code>obj.wait()</code>  让 <strong>进入 object 监视器</strong> 的线程 <code>(称为owner才能wait)</code> 到  <strong>waitSet</strong>  等待</li><li><code>obj.notify()</code> 在 object 上正在 waitSet 等待的线程 <code>(成为owner才能notify) </code>中挑一个唤醒</li><li><code>obj.notifyAll() </code>让 object 上正在 waitSet 等待的线程全部唤醒</li></ul><p>它们都是线程之间进行协作的手段，都属于 Object 对象的方法。必须 <strong>获得此对象的锁</strong> ， <strong>才能调用</strong> 这几个方法</p><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object lock = <span class="hljs-keyword">new</span> Object();<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    <span class="hljs-keyword">synchronized</span> (lock) &#123;        <span class="hljs-keyword">try</span> &#123;            lock.wait();        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> Object obj = <span class="hljs-keyword">new</span> Object();<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;    <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;        <span class="hljs-keyword">synchronized</span> (obj) &#123;            log.debug(<span class="hljs-string">&quot;执行....&quot;</span>);            <span class="hljs-keyword">try</span> &#123;                obj.wait(); <span class="hljs-comment">// 让线程在obj上一直等待下去</span>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;            log.debug(<span class="hljs-string">&quot;其它代码....&quot;</span>);        &#125;    &#125;,<span class="hljs-string">&quot;t1&quot;</span>).start();    <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;        <span class="hljs-keyword">synchronized</span> (obj) &#123;            log.debug(<span class="hljs-string">&quot;执行....&quot;</span>);            <span class="hljs-keyword">try</span> &#123;                obj.wait(); <span class="hljs-comment">// 让线程在obj上一直等待下去</span>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;            log.debug(<span class="hljs-string">&quot;其它代码....&quot;</span>);        &#125;    &#125;,<span class="hljs-string">&quot;t2&quot;</span>).start();    <span class="hljs-comment">// 主线程两秒后执行</span>    TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);    log.debug(<span class="hljs-string">&quot;唤醒 obj 上其它线程&quot;</span>);    <span class="hljs-keyword">synchronized</span> (obj) &#123;        obj.notify(); <span class="hljs-comment">// 唤醒obj上一个线程</span>        <span class="hljs-comment">//obj.notifyAll(); // 唤醒obj上所有等待线程</span>    &#125;&#125;</code></pre><pre><code class="hljs js"><span class="hljs-number">21</span>:<span class="hljs-number">03</span>:<span class="hljs-number">02</span> [t1] c.TestWaitNotify - 执行....<span class="hljs-number">21</span>:<span class="hljs-number">03</span>:<span class="hljs-number">02</span> [t2] c.TestWaitNotify - 执行....<span class="hljs-number">21</span>:<span class="hljs-number">03</span>:<span class="hljs-number">03</span> [main] c.TestWaitNotify - 唤醒 obj 上其它线程<span class="hljs-number">21</span>:<span class="hljs-number">03</span>:<span class="hljs-number">03</span> [t1] c.TestWaitNotify - 其它代码....</code></pre><p>如果是notifyAll：</p><pre><code class="hljs js"><span class="hljs-number">21</span>:<span class="hljs-number">03</span>:<span class="hljs-number">47</span> [t1] c.TestWaitNotify - 执行....<span class="hljs-number">21</span>:<span class="hljs-number">03</span>:<span class="hljs-number">47</span> [t2] c.TestWaitNotify - 执行....<span class="hljs-number">21</span>:<span class="hljs-number">03</span>:<span class="hljs-number">48</span> [main] c.TestWaitNotify - 唤醒 obj 上其它线程<span class="hljs-number">21</span>:<span class="hljs-number">03</span>:<span class="hljs-number">48</span> [t2] c.TestWaitNotify - 其它代码....<span class="hljs-number">21</span>:<span class="hljs-number">03</span>:<span class="hljs-number">48</span> [t1] c.TestWaitNotify - 其它代码....</code></pre><p><code>wait() </code>方法会释放对象的锁，进入 WaitSet 等待区，从而让其他线程就机会获取对象的锁。无限制等待，直到notify 为止<br><code>wait(long n) </code> 有时限的等待, 到 n 毫秒后结束等待，或是被 notify</p><h3 id="3-7-wait-notify-正确姿势"><a href="#3-7-wait-notify-正确姿势" class="headerlink" title="3.7 wait notify 正确姿势"></a>3.7 wait notify 正确姿势</h3><p><code>sleep(long n) </code> 和 <code>wait(long n)</code> 的区别</p><ol><li><p>sleep 是 Thread 方法，而 wait 是 Object 的方法 </p></li><li><p>sleep 不需要强制和 synchronized 配合使用，但 wait 需要和 synchronized 一起用 </p></li><li><p>sleep 在睡眠的同时， <strong>不会释放对象锁</strong> 的，但 wait 在等待的时候 **会释放对象锁 ** </p></li><li><p><code>共同点 </code>它们状态 TIMED_WAITING</p></li></ol><h4 id="step-1"><a href="#step-1" class="headerlink" title="step 1"></a>step 1</h4><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object room = <span class="hljs-keyword">new</span> Object();<span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> hasCigarette = <span class="hljs-keyword">false</span>; <span class="hljs-comment">// 有没有烟</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> hasTakeout = <span class="hljs-keyword">false</span>;</code></pre><p>下列是否可行：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;    <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;        <span class="hljs-keyword">synchronized</span> (room) &#123;            log.debug(<span class="hljs-string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);            <span class="hljs-keyword">if</span> (!hasCigarette) &#123;                log.debug(<span class="hljs-string">&quot;没烟，先歇会！&quot;</span>);                <span class="hljs-keyword">try</span> &#123;                    Thread.sleep(<span class="hljs-number">2000</span>);                    <span class="hljs-comment">//room.wait();</span>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;            log.debug(<span class="hljs-string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);            <span class="hljs-keyword">if</span> (hasCigarette) &#123;                log.debug(<span class="hljs-string">&quot;可以开始干活了&quot;</span>);            &#125;        &#125;    &#125;, <span class="hljs-string">&quot;小南&quot;</span>).start();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            <span class="hljs-keyword">synchronized</span> (room) &#123;                log.debug(<span class="hljs-string">&quot;可以开始干活了&quot;</span>);            &#125;        &#125;, <span class="hljs-string">&quot;其它人&quot;</span>).start();    &#125;    Thread.sleep(<span class="hljs-number">1000</span>);    <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;        <span class="hljs-comment">// 这里能不能加 synchronized (room)？</span>        hasCigarette = <span class="hljs-keyword">true</span>;        log.debug(<span class="hljs-string">&quot;烟到了噢！&quot;</span>);    &#125;, <span class="hljs-string">&quot;送烟的&quot;</span>).start();&#125;</code></pre><pre><code class="hljs ruby">09<span class="hljs-symbol">:</span><span class="hljs-number">56</span><span class="hljs-symbol">:</span><span class="hljs-number">16</span> [小南] c.TestCorrectPosture - 有烟没？[<span class="hljs-literal">false</span>]09<span class="hljs-symbol">:</span><span class="hljs-number">56</span><span class="hljs-symbol">:</span><span class="hljs-number">16</span> [小南] c.TestCorrectPosture - 没烟，先歇会！09<span class="hljs-symbol">:</span><span class="hljs-number">56</span><span class="hljs-symbol">:</span><span class="hljs-number">17</span> [送烟的] c.TestCorrectPosture - 烟到了噢！09<span class="hljs-symbol">:</span><span class="hljs-number">56</span><span class="hljs-symbol">:</span><span class="hljs-number">18</span> [小南] c.TestCorrectPosture - 有烟没？[<span class="hljs-literal">true</span>]09<span class="hljs-symbol">:</span><span class="hljs-number">56</span><span class="hljs-symbol">:</span><span class="hljs-number">18</span> [小南] c.TestCorrectPosture - 可以开始干活了09<span class="hljs-symbol">:</span><span class="hljs-number">56</span><span class="hljs-symbol">:</span><span class="hljs-number">18</span> [其它人] c.TestCorrectPosture - 可以开始干活了09<span class="hljs-symbol">:</span><span class="hljs-number">56</span><span class="hljs-symbol">:</span><span class="hljs-number">18</span> [其它人] c.TestCorrectPosture - 可以开始干活了09<span class="hljs-symbol">:</span><span class="hljs-number">56</span><span class="hljs-symbol">:</span><span class="hljs-number">18</span> [其它人] c.TestCorrectPosture - 可以开始干活了09<span class="hljs-symbol">:</span><span class="hljs-number">56</span><span class="hljs-symbol">:</span><span class="hljs-number">18</span> [其它人] c.TestCorrectPosture - 可以开始干活了09<span class="hljs-symbol">:</span><span class="hljs-number">56</span><span class="hljs-symbol">:</span><span class="hljs-number">18</span> [其它人] c.TestCorrectPosture - 可以开始干活了</code></pre><ul><li>其它干活的线程，都要一直阻塞，效率太低</li><li>小南线程必须睡足 2s 后才能醒来，就算烟提前送到，也无法立刻醒来</li><li>加了 synchronized (room) 后，就好比小南在里面 <code>反锁了门</code> 睡觉，烟根本没法送进门，main 没加<br>synchronized 就好像 main 线程是 <code>翻窗户进来</code> 的</li><li>解决方法，使用 wait - notify 机制</li></ul><h4 id="step-2"><a href="#step-2" class="headerlink" title="step 2"></a>step 2</h4><p>改进：</p><pre><code class="hljs java"><span class="hljs-keyword">new</span> Thread(() -&gt; &#123;    <span class="hljs-keyword">synchronized</span> (room) &#123;        log.debug(<span class="hljs-string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);        <span class="hljs-keyword">if</span> (!hasCigarette) &#123;            log.debug(<span class="hljs-string">&quot;没烟，先歇会！&quot;</span>);            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-comment">//Thread.sleep(2000);</span>                room.wait(<span class="hljs-number">2000</span>);            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;        log.debug(<span class="hljs-string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);        <span class="hljs-keyword">if</span> (hasCigarette) &#123;            log.debug(<span class="hljs-string">&quot;可以开始干活了&quot;</span>);        &#125;    &#125;&#125;, <span class="hljs-string">&quot;小南&quot;</span>).start();<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            <span class="hljs-comment">// 这里能不能加 synchronized (room)？</span>            <span class="hljs-keyword">synchronized</span> (room) &#123;                hasCigarette = <span class="hljs-keyword">true</span>;                log.debug(<span class="hljs-string">&quot;烟到了噢！&quot;</span>);                room.notify();                <span class="hljs-comment">// notify要放在synchronized里面</span>            &#125;&#125;, <span class="hljs-string">&quot;送烟的&quot;</span>).start();</code></pre><pre><code class="hljs ruby"><span class="hljs-number">10</span><span class="hljs-symbol">:</span><span class="hljs-number">00</span><span class="hljs-symbol">:</span><span class="hljs-number">44</span> [小南] c.TestCorrectPosture - 有烟没？[<span class="hljs-literal">false</span>]<span class="hljs-number">10</span><span class="hljs-symbol">:</span><span class="hljs-number">00</span><span class="hljs-symbol">:</span><span class="hljs-number">44</span> [小南] c.TestCorrectPosture - 没烟，先歇会！<span class="hljs-number">10</span><span class="hljs-symbol">:</span><span class="hljs-number">00</span><span class="hljs-symbol">:</span><span class="hljs-number">44</span> [其它人] c.TestCorrectPosture - 可以开始干活了<span class="hljs-number">10</span><span class="hljs-symbol">:</span><span class="hljs-number">00</span><span class="hljs-symbol">:</span><span class="hljs-number">44</span> [其它人] c.TestCorrectPosture - 可以开始干活了<span class="hljs-number">10</span><span class="hljs-symbol">:</span><span class="hljs-number">00</span><span class="hljs-symbol">:</span><span class="hljs-number">44</span> [其它人] c.TestCorrectPosture - 可以开始干活了<span class="hljs-number">10</span><span class="hljs-symbol">:</span><span class="hljs-number">00</span><span class="hljs-symbol">:</span><span class="hljs-number">44</span> [其它人] c.TestCorrectPosture - 可以开始干活了<span class="hljs-number">10</span><span class="hljs-symbol">:</span><span class="hljs-number">00</span><span class="hljs-symbol">:</span><span class="hljs-number">44</span> [其它人] c.TestCorrectPosture - 可以开始干活了<span class="hljs-number">10</span><span class="hljs-symbol">:</span><span class="hljs-number">00</span><span class="hljs-symbol">:</span><span class="hljs-number">45</span> [送烟的] c.TestCorrectPosture - 烟到了噢！<span class="hljs-number">10</span><span class="hljs-symbol">:</span><span class="hljs-number">00</span><span class="hljs-symbol">:</span><span class="hljs-number">45</span> [小南] c.TestCorrectPosture - 有烟没？[<span class="hljs-literal">true</span>]<span class="hljs-number">10</span><span class="hljs-symbol">:</span><span class="hljs-number">00</span><span class="hljs-symbol">:</span><span class="hljs-number">45</span> [小南] c.TestCorrectPosture - 可以开始干活了</code></pre><ul><li>解决了其它干活的线程阻塞的问题</li><li>但如果有其它线程也在等待条件呢？</li></ul><h4 id="step-3"><a href="#step-3" class="headerlink" title="step 3"></a>step 3</h4><blockquote><p>虚假唤醒</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object room = <span class="hljs-keyword">new</span> Object();<span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> hasCigarette = <span class="hljs-keyword">false</span>;<span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> hasTakeout = <span class="hljs-keyword">false</span>;<span class="hljs-comment">// 虚假唤醒</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;    <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;        <span class="hljs-keyword">synchronized</span> (room) &#123;            log.debug(<span class="hljs-string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);            <span class="hljs-keyword">if</span> (!hasCigarette) &#123;                log.debug(<span class="hljs-string">&quot;没烟，先歇会！&quot;</span>);                <span class="hljs-keyword">try</span> &#123;                    room.wait();                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;            log.debug(<span class="hljs-string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);            <span class="hljs-keyword">if</span> (hasCigarette) &#123;                log.debug(<span class="hljs-string">&quot;可以开始干活了&quot;</span>);            &#125; <span class="hljs-keyword">else</span> &#123;                log.debug(<span class="hljs-string">&quot;没干成活...&quot;</span>);            &#125;        &#125;    &#125;, <span class="hljs-string">&quot;小南&quot;</span>).start();    <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;        <span class="hljs-keyword">synchronized</span> (room) &#123;            Thread thread = Thread.currentThread();            log.debug(<span class="hljs-string">&quot;外卖送到没？[&#123;&#125;]&quot;</span>, hasTakeout);            <span class="hljs-keyword">if</span> (!hasTakeout) &#123;                log.debug(<span class="hljs-string">&quot;没外卖，先歇会！&quot;</span>);                <span class="hljs-keyword">try</span> &#123;                    room.wait();                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;            log.debug(<span class="hljs-string">&quot;外卖送到没？[&#123;&#125;]&quot;</span>, hasTakeout);            <span class="hljs-keyword">if</span> (hasTakeout) &#123;                log.debug(<span class="hljs-string">&quot;可以开始干活了&quot;</span>);            &#125; <span class="hljs-keyword">else</span> &#123;                log.debug(<span class="hljs-string">&quot;没干成活...&quot;</span>);            &#125;        &#125;    &#125;, <span class="hljs-string">&quot;小女&quot;</span>).start();    sleep(<span class="hljs-number">1000</span>);    <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;        <span class="hljs-keyword">synchronized</span> (room) &#123;            hasTakeout = <span class="hljs-keyword">true</span>;            log.debug(<span class="hljs-string">&quot;外卖到了噢！&quot;</span>);            room.notify();        &#125;    &#125;, <span class="hljs-string">&quot;送外卖的&quot;</span>).start();&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210429100936.png"></p><p>应该改成</p><pre><code class="hljs java">room.notifyAll();</code></pre><ul><li>notify 只能随机唤醒一个 WaitSet 中的线程，这时如果有其它线程也在等待，那么就可能唤醒不了正确的线程，称之为 <code>虚假唤醒</code></li><li>解决方法，改为 notifyAll</li></ul><ul><li>用 notifyAll 仅解决某个线程的唤醒问题，但使用 if + wait 判断仅有一次机会，一旦条件不成立，就没有重新判断的机会了</li><li>解决方法，用 <code>while + wait</code>，当条件不成立，再次 wait</li></ul><h4 id="step-4"><a href="#step-4" class="headerlink" title="step 4"></a>step 4</h4><pre><code class="hljs java"><span class="hljs-keyword">new</span> Thread(() -&gt; &#123;    <span class="hljs-keyword">synchronized</span> (room) &#123;        log.debug(<span class="hljs-string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);        <span class="hljs-keyword">while</span> (!hasCigarette) &#123;            log.debug(<span class="hljs-string">&quot;没烟，先歇会！&quot;</span>);            <span class="hljs-keyword">try</span> &#123;                room.wait();            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;        log.debug(<span class="hljs-string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);        <span class="hljs-keyword">if</span> (hasCigarette) &#123;            log.debug(<span class="hljs-string">&quot;可以开始干活了&quot;</span>);        &#125; <span class="hljs-keyword">else</span> &#123;            log.debug(<span class="hljs-string">&quot;没干成活...&quot;</span>);        &#125;    &#125;&#125;, <span class="hljs-string">&quot;小南&quot;</span>).start();<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;    <span class="hljs-keyword">synchronized</span> (room) &#123;        Thread thread = Thread.currentThread();        log.debug(<span class="hljs-string">&quot;外卖送到没？[&#123;&#125;]&quot;</span>, hasTakeout);        <span class="hljs-keyword">while</span> (!hasTakeout) &#123;            log.debug(<span class="hljs-string">&quot;没外卖，先歇会！&quot;</span>);            <span class="hljs-keyword">try</span> &#123;                room.wait();            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;        log.debug(<span class="hljs-string">&quot;外卖送到没？[&#123;&#125;]&quot;</span>, hasTakeout);        <span class="hljs-keyword">if</span> (hasTakeout) &#123;            log.debug(<span class="hljs-string">&quot;可以开始干活了&quot;</span>);        &#125; <span class="hljs-keyword">else</span> &#123;            log.debug(<span class="hljs-string">&quot;没干成活...&quot;</span>);        &#125;    &#125;&#125;, <span class="hljs-string">&quot;小女&quot;</span>).start();sleep(<span class="hljs-number">1000</span>);<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;    <span class="hljs-keyword">synchronized</span> (room) &#123;        hasTakeout = <span class="hljs-keyword">true</span>;        log.debug(<span class="hljs-string">&quot;外卖到了噢！&quot;</span>);        room.notifyAll();    &#125;&#125;, <span class="hljs-string">&quot;送外卖的&quot;</span>).start();</code></pre><pre><code class="hljs ruby"><span class="hljs-number">10</span><span class="hljs-symbol">:</span><span class="hljs-number">13</span><span class="hljs-symbol">:</span><span class="hljs-number">47</span> [小南] c.TestCorrectPosture - 有烟没？[<span class="hljs-literal">false</span>]<span class="hljs-number">10</span><span class="hljs-symbol">:</span><span class="hljs-number">13</span><span class="hljs-symbol">:</span><span class="hljs-number">47</span> [小南] c.TestCorrectPosture - 没烟，先歇会！<span class="hljs-number">10</span><span class="hljs-symbol">:</span><span class="hljs-number">13</span><span class="hljs-symbol">:</span><span class="hljs-number">47</span> [小女] c.TestCorrectPosture - 外卖送到没？[<span class="hljs-literal">false</span>]<span class="hljs-number">10</span><span class="hljs-symbol">:</span><span class="hljs-number">13</span><span class="hljs-symbol">:</span><span class="hljs-number">47</span> [小女] c.TestCorrectPosture - 没外卖，先歇会！<span class="hljs-number">10</span><span class="hljs-symbol">:</span><span class="hljs-number">13</span><span class="hljs-symbol">:</span><span class="hljs-number">48</span> [送外卖的] c.TestCorrectPosture - 外卖到了噢！<span class="hljs-number">10</span><span class="hljs-symbol">:</span><span class="hljs-number">13</span><span class="hljs-symbol">:</span><span class="hljs-number">48</span> [小女] c.TestCorrectPosture - 外卖送到没？[<span class="hljs-literal">true</span>]<span class="hljs-number">10</span><span class="hljs-symbol">:</span><span class="hljs-number">13</span><span class="hljs-symbol">:</span><span class="hljs-number">48</span> [小女] c.TestCorrectPosture - 可以开始干活了<span class="hljs-number">10</span><span class="hljs-symbol">:</span><span class="hljs-number">13</span><span class="hljs-symbol">:</span><span class="hljs-number">48</span> [小南] c.TestCorrectPosture - 没烟，先歇会！</code></pre><h5 id="step-5"><a href="#step-5" class="headerlink" title="step 5"></a>step 5</h5><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>(lock) &#123;  <span class="hljs-keyword">while</span>(条件不成立) &#123;    lock.wait();    &#125;    <span class="hljs-comment">// 干活</span>  &#125;<span class="hljs-comment">//另一个线程</span><span class="hljs-keyword">synchronized</span>(lock) &#123;  lock.notifyAll();&#125;</code></pre><h4 id="同步模式之保护性暂停"><a href="#同步模式之保护性暂停" class="headerlink" title="同步模式之保护性暂停"></a>同步模式之保护性暂停</h4><p>即 Guarded Suspension，用在 <strong>一个线程等待另一个线程的执行结果</strong><br>要点</p><ul><li>有一个结果需要从一个线程传递到另一个线程，让他们关联同一个 <code>GuardedObject</code></li><li>如果有结果不断从一个线程到另一个线程那么可以使用消息队列（见生产者/消费者）</li><li>JDK 中，<code>join</code> 的实现、<code>Future</code> 的实现，采用的就是此模式</li><li>因为要等待另一方的结果，因此归类到<code>同步模式</code></li></ul><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210429101955.png"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210429102727.png"></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    GuardedObject guardedObject = <span class="hljs-keyword">new</span> GuardedObject();    <span class="hljs-keyword">new</span> Thread( ()-&gt;&#123;        log.info(<span class="hljs-string">&quot;等待结果&quot;</span>);        List&lt;String&gt; list = (List&lt;String&gt;)guardedObject.get();        System.out.println(list);        log.info(<span class="hljs-string">&quot;大小:&#123;&#125;&quot;</span>, list.size());    &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();    <span class="hljs-keyword">new</span> Thread( ()-&gt;&#123;        log.info(<span class="hljs-string">&quot;执行下载&quot;</span>);        List&lt;String&gt; list = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">try</span> &#123;            list = Downloader.download();        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            e.printStackTrace();        &#125;        guardedObject.complete(list);        log.info(<span class="hljs-string">&quot;下载完毕&quot;</span>);    &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GuardedObject</span> </span>&#123;    <span class="hljs-keyword">private</span> Object response;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object lock = <span class="hljs-keyword">new</span> Object();    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">synchronized</span> (lock) &#123;            <span class="hljs-comment">// 条件不满足则等待</span>            <span class="hljs-keyword">while</span> (response == <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-keyword">try</span> &#123;                    lock.wait();                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;            <span class="hljs-keyword">return</span> response;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">complete</span><span class="hljs-params">(Object response)</span> </span>&#123;        <span class="hljs-keyword">synchronized</span> (lock) &#123;            <span class="hljs-comment">// 条件满足，通知等待线程</span>            <span class="hljs-keyword">this</span>.response = response;            lock.notifyAll();        &#125;    &#125;&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210429103640.png"></p><h5 id="拓展1-保护性暂停增加超时"><a href="#拓展1-保护性暂停增加超时" class="headerlink" title="拓展1 保护性暂停增加超时"></a>拓展1 保护性暂停增加超时</h5><p>如果要控制超时时间呢?</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GuardedObjectV2</span> </span>&#123;    <span class="hljs-keyword">private</span> Object response;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object lock = <span class="hljs-keyword">new</span> Object();    Logger log = LoggerFactory.getLogger(<span class="hljs-string">&quot;log&quot;</span>);    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">long</span> millis)</span> </span>&#123;        <span class="hljs-keyword">synchronized</span> (lock) &#123;            <span class="hljs-comment">// 1) 记录最初时间</span>            <span class="hljs-keyword">long</span> begin = System.currentTimeMillis();            <span class="hljs-comment">// 2) 已经经历的时间</span>            <span class="hljs-keyword">long</span> timePassed = <span class="hljs-number">0</span>;            <span class="hljs-keyword">while</span> (response == <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-comment">// 还需要wait的时间，防止虚假唤醒</span>                <span class="hljs-keyword">long</span> waitTime = millis - timePassed;                log.debug(<span class="hljs-string">&quot;还需要wait的时间waitTime: &#123;&#125;&quot;</span>, waitTime);                <span class="hljs-keyword">if</span> (waitTime &lt;= <span class="hljs-number">0</span>) &#123;                    log.debug(<span class="hljs-string">&quot;break...&quot;</span>);                    <span class="hljs-keyword">break</span>;                &#125;                <span class="hljs-keyword">try</span> &#123;                    lock.wait(waitTime);                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                &#125;                <span class="hljs-comment">// 3) 如果提前被唤醒，下次进入循环后wait的时间应该是 需要的时间 - 已经wait的时间 = 还需等待的时间</span>                timePassed = System.currentTimeMillis() - begin;                log.debug(<span class="hljs-string">&quot;timePassed: &#123;&#125;, object is null &#123;&#125;&quot;</span>,                        timePassed, response == <span class="hljs-keyword">null</span>);            &#125;            <span class="hljs-keyword">return</span> response;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">complete</span><span class="hljs-params">(Object response)</span> </span>&#123;        <span class="hljs-keyword">synchronized</span> (lock) &#123;            <span class="hljs-comment">// 条件满足，通知等待线程</span>            <span class="hljs-keyword">this</span>.response = response;            log.debug(<span class="hljs-string">&quot;notify...&quot;</span>);            lock.notifyAll();        &#125;    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testGuardedV2</span><span class="hljs-params">()</span> </span>&#123;    GuardedObjectV2 v2 = <span class="hljs-keyword">new</span> GuardedObjectV2();    <span class="hljs-keyword">new</span> Thread( ()-&gt;&#123;        log.info(<span class="hljs-string">&quot;开始等待结果&quot;</span>);        Object o = v2.get(<span class="hljs-number">2000</span>);        log.info(<span class="hljs-string">&quot;等待完毕，结果是:&#123;&#125;&quot;</span>, o);    &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();    <span class="hljs-keyword">new</span> Thread( ()-&gt;&#123;        log.info(<span class="hljs-string">&quot;开始下载&quot;</span>);        <span class="hljs-keyword">try</span> &#123;            Thread.sleep(<span class="hljs-number">1000</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        v2.complete(<span class="hljs-keyword">new</span> Object());        log.info(<span class="hljs-string">&quot;下载完成&quot;</span>);    &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();&#125;</code></pre><pre><code class="hljs ruby"><span class="hljs-number">11</span><span class="hljs-symbol">:</span><span class="hljs-number">00</span><span class="hljs-symbol">:</span><span class="hljs-number">24</span> [t2] c.Test20 - 开始下载<span class="hljs-number">11</span><span class="hljs-symbol">:</span><span class="hljs-number">00</span><span class="hljs-symbol">:</span><span class="hljs-number">24</span> [t1] c.Test20 - 开始等待结果<span class="hljs-number">11</span><span class="hljs-symbol">:</span><span class="hljs-number">00</span><span class="hljs-symbol">:</span><span class="hljs-number">25</span> [t2] c.Test20 - 下载完成<span class="hljs-number">11</span><span class="hljs-symbol">:</span><span class="hljs-number">00</span><span class="hljs-symbol">:</span><span class="hljs-number">25</span> [t1] c.Test20 - 等待完毕，结果是<span class="hljs-symbol">:java</span>.lang.Object<span class="hljs-variable">@76671b</span>2e</code></pre><p>如果t1的等待时间弄小：</p><pre><code class="hljs java">Object o = v2.get(<span class="hljs-number">500</span>);</code></pre><pre><code class="hljs ruby"><span class="hljs-number">11</span><span class="hljs-symbol">:</span><span class="hljs-number">01</span><span class="hljs-symbol">:</span><span class="hljs-number">02</span> [t1] c.Test20 - 开始等待结果<span class="hljs-number">11</span><span class="hljs-symbol">:</span><span class="hljs-number">01</span><span class="hljs-symbol">:</span><span class="hljs-number">02</span> [t2] c.Test20 - 开始下载<span class="hljs-number">11</span><span class="hljs-symbol">:</span><span class="hljs-number">01</span><span class="hljs-symbol">:</span><span class="hljs-number">02</span> [t1] c.Test20 - 等待完毕，结果是<span class="hljs-symbol">:null</span><span class="hljs-number">11</span><span class="hljs-symbol">:</span><span class="hljs-number">01</span><span class="hljs-symbol">:</span><span class="hljs-number">03</span> [t2] c.Test20 - 下载完成</code></pre><p>如果发生虚假唤醒：</p><pre><code class="hljs java">v2.complete(<span class="hljs-keyword">null</span>);<span class="hljs-comment">// response没有值</span></code></pre><pre><code class="hljs ruby"><span class="hljs-number">11</span><span class="hljs-symbol">:</span><span class="hljs-number">01</span><span class="hljs-symbol">:</span><span class="hljs-number">48</span> [t1] c.Test20 - 开始等待结果<span class="hljs-number">11</span><span class="hljs-symbol">:</span><span class="hljs-number">01</span><span class="hljs-symbol">:</span><span class="hljs-number">48</span> [t2] c.Test20 - 开始下载<span class="hljs-number">11</span><span class="hljs-symbol">:</span><span class="hljs-number">01</span><span class="hljs-symbol">:</span><span class="hljs-number">49</span> [t2] c.Test20 - 下载完成<span class="hljs-number">11</span><span class="hljs-symbol">:</span><span class="hljs-number">01</span><span class="hljs-symbol">:</span><span class="hljs-number">50</span> [t1] c.Test20 - 等待完毕，结果是<span class="hljs-symbol">:null</span></code></pre><p>t1会等足两秒钟！</p><h5 id="拓展2-join原理"><a href="#拓展2-join原理" class="headerlink" title="拓展2 join原理"></a>拓展2 join原理</h5><p>是调用者 <code>轮询检查</code> 线程 alive 状态</p><pre><code class="hljs java">t1.join();</code></pre><p>等价于下面的代码</p><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> (t1) &#123;  <span class="hljs-comment">// 调用者线程进入 t1 的 waitSet 等待, 直到 t1 运行结束</span>  <span class="hljs-keyword">while</span> (t1.isAlive()) &#123;    t1.wait(<span class="hljs-number">0</span>);  &#125;&#125;</code></pre><blockquote><p>注意<br>join 体现的是【保护性暂停】模式，请参考之</p></blockquote><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210429111928.png"></p><h5 id="拓展3-保护性暂停增加多类使用"><a href="#拓展3-保护性暂停增加多类使用" class="headerlink" title="拓展3 保护性暂停增加多类使用"></a>拓展3 保护性暂停增加多类使用</h5><p>图中 Futures 就好比居民楼一层的信箱（每个信箱有房间编号），左侧的 t0，t2，t4 就好比 <code>等待邮件的居民</code> ，右侧的 t1，t3，t5 就好比 <code>邮递员</code><br>如果需要在多个类之间使用 GuardedObject 对象，作为参数传递不是很方便，因此设计一个用来解耦的中间类，这样不仅能够解耦【结果等待者】和【结果生产者】，还能够同时支持多个任务的管理</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210429113343.png"></p><p>新增 id 用来标识 Guarded Object</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GuardedObjectV3</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> id;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;        <span class="hljs-keyword">this</span>.id = id;    &#125;    <span class="hljs-keyword">private</span> Object response;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object lock = <span class="hljs-keyword">new</span> Object();    Logger log = LoggerFactory.getLogger(<span class="hljs-string">&quot;log&quot;</span>);    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">long</span> millis)</span> </span>&#123;        <span class="hljs-keyword">synchronized</span> (lock) &#123;            <span class="hljs-comment">// 1) 记录最初时间</span>            <span class="hljs-keyword">long</span> begin = System.currentTimeMillis();            <span class="hljs-comment">// 2) 已经经历的时间</span>            <span class="hljs-keyword">long</span> timePassed = <span class="hljs-number">0</span>;            <span class="hljs-keyword">while</span> (response == <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-comment">// 还需要wait的时间，防止虚假唤醒</span>                <span class="hljs-keyword">long</span> waitTime = millis - timePassed;                log.debug(<span class="hljs-string">&quot;还需要wait的时间waitTime: &#123;&#125;&quot;</span>, waitTime);                <span class="hljs-keyword">if</span> (waitTime &lt;= <span class="hljs-number">0</span>) &#123;                    log.debug(<span class="hljs-string">&quot;break...&quot;</span>);                    <span class="hljs-keyword">break</span>;                &#125;                <span class="hljs-keyword">try</span> &#123;                    lock.wait(waitTime);                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                &#125;                <span class="hljs-comment">// 3) 如果提前被唤醒，下次进入循环后wait的时间应该是 需要的时间 - 已经wait的时间 = 还需等待的时间</span>                timePassed = System.currentTimeMillis() - begin;                log.debug(<span class="hljs-string">&quot;timePassed: &#123;&#125;, object is null &#123;&#125;&quot;</span>,                        timePassed, response == <span class="hljs-keyword">null</span>);            &#125;            <span class="hljs-keyword">return</span> response;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">complete</span><span class="hljs-params">(Object response)</span> </span>&#123;        <span class="hljs-keyword">synchronized</span> (lock) &#123;            <span class="hljs-comment">// 条件满足，通知等待线程</span>            <span class="hljs-keyword">this</span>.response = response;            log.debug(<span class="hljs-string">&quot;notify...&quot;</span>);            lock.notifyAll();        &#125;    &#125;&#125;</code></pre><p>中间解耦类（邮箱box）</p><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.People&quot;)</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">People</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 收信</span>        GuardedObjectV3 guardedObject = Mailboxes.createGuardedObject();        log.debug(<span class="hljs-string">&quot;开始收信 id:&#123;&#125;&quot;</span>, guardedObject.getId());        Object mail = guardedObject.get(<span class="hljs-number">5000</span>);        log.debug(<span class="hljs-string">&quot;收到信 id:&#123;&#125;, 内容:&#123;&#125;&quot;</span>, guardedObject.getId(), mail);    &#125;&#125;<span class="hljs-meta">@Slf4j(topic = &quot;c.Postman&quot;)</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Postman</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;    <span class="hljs-keyword">private</span> String mail;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Postman</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, String mail)</span> </span>&#123;        <span class="hljs-keyword">this</span>.id = id;        <span class="hljs-keyword">this</span>.mail = mail;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        GuardedObjectV3 guardedObject = Mailboxes.getGuardedObject(id);        log.debug(<span class="hljs-string">&quot;送信 id:&#123;&#125;, 内容:&#123;&#125;&quot;</span>, id, mail);        guardedObject.complete(mail);    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Mailboxes</span> </span>&#123;    <span class="hljs-comment">// 为保证线程安全</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;Integer, GuardedObjectV3&gt; boxes = <span class="hljs-keyword">new</span> Hashtable&lt;&gt;();    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> id = <span class="hljs-number">1</span>;    <span class="hljs-comment">// 产生唯一 id</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">int</span> <span class="hljs-title">generateId</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> id++;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> GuardedObjectV3 <span class="hljs-title">getGuardedObject</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;        <span class="hljs-keyword">return</span> boxes.remove(id);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> GuardedObjectV3 <span class="hljs-title">createGuardedObject</span><span class="hljs-params">()</span> </span>&#123;        GuardedObjectV3 go = <span class="hljs-keyword">new</span> GuardedObjectV3(generateId());        boxes.put(go.getId(), go);        <span class="hljs-keyword">return</span> go;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Set&lt;Integer&gt; <span class="hljs-title">getIds</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> boxes.keySet();    &#125;&#125;</code></pre><p>Main:</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;        <span class="hljs-keyword">new</span> People().start();    &#125;    Thread.sleep(<span class="hljs-number">1000</span>);    <span class="hljs-keyword">for</span> (Integer id : Mailboxes.getIds()) &#123;        <span class="hljs-keyword">new</span> Postman(id, <span class="hljs-string">&quot;内容&quot;</span> + id).start();    &#125;&#125;</code></pre><pre><code class="hljs ruby"><span class="hljs-number">11</span><span class="hljs-symbol">:</span><span class="hljs-number">51</span><span class="hljs-symbol">:</span><span class="hljs-number">12</span> [Thread-<span class="hljs-number">0</span>] c.People - 开始收信 <span class="hljs-symbol">id:</span><span class="hljs-number">3</span><span class="hljs-number">11</span><span class="hljs-symbol">:</span><span class="hljs-number">51</span><span class="hljs-symbol">:</span><span class="hljs-number">12</span> [Thread-<span class="hljs-number">1</span>] c.People - 开始收信 <span class="hljs-symbol">id:</span><span class="hljs-number">1</span><span class="hljs-number">11</span><span class="hljs-symbol">:</span><span class="hljs-number">51</span><span class="hljs-symbol">:</span><span class="hljs-number">12</span> [Thread-<span class="hljs-number">2</span>] c.People - 开始收信 <span class="hljs-symbol">id:</span><span class="hljs-number">2</span><span class="hljs-number">11</span><span class="hljs-symbol">:</span><span class="hljs-number">51</span><span class="hljs-symbol">:</span><span class="hljs-number">13</span> [Thread-<span class="hljs-number">3</span>] c.Postman - 送信 <span class="hljs-symbol">id:</span><span class="hljs-number">3</span>, 内容<span class="hljs-symbol">:</span>内容<span class="hljs-number">3</span><span class="hljs-number">11</span><span class="hljs-symbol">:</span><span class="hljs-number">51</span><span class="hljs-symbol">:</span><span class="hljs-number">13</span> [Thread-<span class="hljs-number">4</span>] c.Postman - 送信 <span class="hljs-symbol">id:</span><span class="hljs-number">2</span>, 内容<span class="hljs-symbol">:</span>内容<span class="hljs-number">2</span><span class="hljs-number">11</span><span class="hljs-symbol">:</span><span class="hljs-number">51</span><span class="hljs-symbol">:</span><span class="hljs-number">13</span> [Thread-<span class="hljs-number">5</span>] c.Postman - 送信 <span class="hljs-symbol">id:</span><span class="hljs-number">1</span>, 内容<span class="hljs-symbol">:</span>内容<span class="hljs-number">1</span><span class="hljs-number">11</span><span class="hljs-symbol">:</span><span class="hljs-number">51</span><span class="hljs-symbol">:</span><span class="hljs-number">13</span> [Thread-<span class="hljs-number">0</span>] c.People - 收到信 <span class="hljs-symbol">id:</span><span class="hljs-number">3</span>, 内容<span class="hljs-symbol">:</span>内容<span class="hljs-number">3</span><span class="hljs-number">11</span><span class="hljs-symbol">:</span><span class="hljs-number">51</span><span class="hljs-symbol">:</span><span class="hljs-number">13</span> [Thread-<span class="hljs-number">2</span>] c.People - 收到信 <span class="hljs-symbol">id:</span><span class="hljs-number">2</span>, 内容<span class="hljs-symbol">:</span>内容<span class="hljs-number">2</span><span class="hljs-number">11</span><span class="hljs-symbol">:</span><span class="hljs-number">51</span><span class="hljs-symbol">:</span><span class="hljs-number">13</span> [Thread-<span class="hljs-number">1</span>] c.People - 收到信 <span class="hljs-symbol">id:</span><span class="hljs-number">1</span>, 内容<span class="hljs-symbol">:</span>内容<span class="hljs-number">1</span></code></pre><p>由结果可得到：</p><p>一个邮递员一定对应一个收件人</p><p>一一对应的关系；如果不是一一对应，应该是生产者与消费者模式；</p><h4 id="异步模式之生产者-消费者"><a href="#异步模式之生产者-消费者" class="headerlink" title="异步模式之生产者/消费者"></a>异步模式之生产者/消费者</h4><p>要点</p><ol><li>与前面的保护性暂停中的 GuardObject 不同， <strong>不需要</strong> 产生结果和消费结果的线程 <strong>一一对应</strong> </li><li>消费队列可以用来 <code>平衡生产和消费的线程资源</code></li><li>生产者仅负责产生结果数据，不关心数据该如何处理，而消费者专心处理结果数据</li><li>消息队列是有容量限制的，满时不会再加入数据，空时不会再消耗数据</li><li>JDK 中各种<a href="https://blog.csdn.net/yanpenglei/article/details/79556591">阻塞队列</a>，采用的就是这种模式</li></ol><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210430085646.png"></p><p>异步是因为t3生产的要等到t1，而保护性暂停会一一对应立刻消费</p><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Test21&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test21</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        MessageQueue queue = <span class="hljs-keyword">new</span> MessageQueue(<span class="hljs-number">2</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;            <span class="hljs-keyword">int</span> id = i;            <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;                queue.put(<span class="hljs-keyword">new</span> Message(id , <span class="hljs-string">&quot;值&quot;</span>+id));            &#125;, <span class="hljs-string">&quot;生产者&quot;</span> + i).start();        &#125;        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;                sleep(<span class="hljs-number">1</span>);                Message message = queue.take();            &#125;        &#125;, <span class="hljs-string">&quot;消费者&quot;</span>).start();    &#125;&#125;<span class="hljs-comment">// 消息队列类 ， java 线程之间通信</span><span class="hljs-meta">@Slf4j(topic = &quot;c.MessageQueue&quot;)</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageQueue</span> </span>&#123;    <span class="hljs-comment">// 消息的队列集合（双向队列）</span>    <span class="hljs-keyword">private</span> LinkedList&lt;Message&gt; list = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();    <span class="hljs-comment">// 队列容量</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> capcity;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MessageQueue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capcity)</span> </span>&#123;        <span class="hljs-keyword">this</span>.capcity = capcity;    &#125;    <span class="hljs-comment">// 获取消息</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Message <span class="hljs-title">take</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 检查队列是否为空</span>        <span class="hljs-keyword">synchronized</span> (list) &#123;            <span class="hljs-keyword">while</span>(list.isEmpty()) &#123;                <span class="hljs-keyword">try</span> &#123;                    log.debug(<span class="hljs-string">&quot;队列为空, 消费者线程等待&quot;</span>);                    list.wait();                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;            <span class="hljs-comment">// 从队列头部获取消息并返回</span>            Message message = list.removeFirst();            log.debug(<span class="hljs-string">&quot;已消费消息 &#123;&#125;&quot;</span>, message);            list.notifyAll();            <span class="hljs-keyword">return</span> message;        &#125;    &#125;    <span class="hljs-comment">// 存入消息</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(Message message)</span> </span>&#123;        <span class="hljs-keyword">synchronized</span> (list) &#123;            <span class="hljs-comment">// 检查对象是否已满</span>            <span class="hljs-keyword">while</span>(list.size() == capcity) &#123;                <span class="hljs-keyword">try</span> &#123;                    log.debug(<span class="hljs-string">&quot;队列已满, 生产者线程等待&quot;</span>);                    list.wait();                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;            <span class="hljs-comment">// 将消息加入队列尾部</span>            list.addLast(message);            log.debug(<span class="hljs-string">&quot;已生产消息 &#123;&#125;&quot;</span>, message);            list.notifyAll();        &#125;    &#125;&#125;<span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Message</span> </span>&#123;    <span class="hljs-comment">// final不能有子类，子类不可覆盖，更为保险</span>    <span class="hljs-comment">// 没有set 不能修改值，线程安全</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;    <span class="hljs-keyword">private</span> Object value;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Message</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, Object value)</span> </span>&#123;        <span class="hljs-keyword">this</span>.id = id;        <span class="hljs-keyword">this</span>.value = value;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> id;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getValue</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> value;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Message&#123;&quot;</span> +                <span class="hljs-string">&quot;id=&quot;</span> + id +                <span class="hljs-string">&quot;, value=&quot;</span> + value +                <span class="hljs-string">&#x27;&#125;&#x27;</span>;    &#125;&#125;</code></pre><pre><code class="hljs ruby">09<span class="hljs-symbol">:</span>08<span class="hljs-symbol">:</span><span class="hljs-number">14</span> [生产者<span class="hljs-number">0</span>] c.MessageQueue - 已生产消息 Message&#123;id=<span class="hljs-number">0</span>, value=值<span class="hljs-number">0</span>&#125;09<span class="hljs-symbol">:</span>08<span class="hljs-symbol">:</span><span class="hljs-number">14</span> [生产者<span class="hljs-number">1</span>] c.MessageQueue - 已生产消息 Message&#123;id=<span class="hljs-number">1</span>, value=值<span class="hljs-number">1</span>&#125;09<span class="hljs-symbol">:</span>08<span class="hljs-symbol">:</span><span class="hljs-number">14</span> [生产者<span class="hljs-number">2</span>] c.MessageQueue - 队列已满, 生产者线程等待09<span class="hljs-symbol">:</span>08<span class="hljs-symbol">:</span><span class="hljs-number">15</span> [消费者] c.MessageQueue - 已消费消息 Message&#123;id=<span class="hljs-number">0</span>, value=值<span class="hljs-number">0</span>&#125;09<span class="hljs-symbol">:</span>08<span class="hljs-symbol">:</span><span class="hljs-number">16</span> [生产者<span class="hljs-number">2</span>] c.MessageQueue - 已生产消息 Message&#123;id=<span class="hljs-number">2</span>, value=值<span class="hljs-number">2</span>&#125;09<span class="hljs-symbol">:</span>08<span class="hljs-symbol">:</span><span class="hljs-number">17</span> [消费者] c.MessageQueue - 已消费消息 Message&#123;id=<span class="hljs-number">1</span>, value=值<span class="hljs-number">1</span>&#125;09<span class="hljs-symbol">:</span>08<span class="hljs-symbol">:</span><span class="hljs-number">18</span> [消费者] c.MessageQueue - 已消费消息 Message&#123;id=<span class="hljs-number">2</span>, value=值<span class="hljs-number">2</span>&#125;09<span class="hljs-symbol">:</span>08<span class="hljs-symbol">:</span><span class="hljs-number">19</span> [消费者] c.MessageQueue - 队列为空, 消费者线程等待</code></pre><h3 id="3-8-park-amp-unpark"><a href="#3-8-park-amp-unpark" class="headerlink" title="3.8 park &amp; unpark"></a>3.8 park &amp; unpark</h3><h4 id="3-8-1-基本使用"><a href="#3-8-1-基本使用" class="headerlink" title="3.8.1 基本使用"></a>3.8.1 基本使用</h4><p>它们是 LockSupport 类中的方法</p><pre><code class="hljs java"><span class="hljs-comment">// 暂停当前线程</span>LockSupport.park();  <span class="hljs-comment">// WAIT状态</span><span class="hljs-comment">// 恢复某个线程的运行</span>LockSupport.unpark(暂停线程对象)</code></pre><p>先 park 再 unpark</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;        log.debug(<span class="hljs-string">&quot;start...&quot;</span>);        sleep(<span class="hljs-number">1</span>);        log.debug(<span class="hljs-string">&quot;park...&quot;</span>);        LockSupport.park();        log.debug(<span class="hljs-string">&quot;resume...&quot;</span>);    &#125;, <span class="hljs-string">&quot;t1&quot;</span>);    t1.start();    sleep(<span class="hljs-number">2</span>);    log.debug(<span class="hljs-string">&quot;unpark...&quot;</span>);    LockSupport.unpark(t1);&#125;</code></pre><pre><code class="hljs ruby">09<span class="hljs-symbol">:</span><span class="hljs-number">22</span><span class="hljs-symbol">:</span><span class="hljs-number">35</span> [t1] c.TestParkUnpark - start...09<span class="hljs-symbol">:</span><span class="hljs-number">22</span><span class="hljs-symbol">:</span><span class="hljs-number">36</span> [t1] c.TestParkUnpark - park...09<span class="hljs-symbol">:</span><span class="hljs-number">22</span><span class="hljs-symbol">:</span><span class="hljs-number">37</span> [main] c.TestParkUnpark - unpark...09<span class="hljs-symbol">:</span><span class="hljs-number">22</span><span class="hljs-symbol">:</span><span class="hljs-number">37</span> [t1] c.TestParkUnpark - resume...</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210430092548.png"></p><p>如果主线程1s后就unpark，t1 2s后才park，t1是否会继续运行？</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210430092720.png"></p><p><code>unpark既可以在线程暂停前调用，也可以在之后调用</code></p><h4 id="3-8-2-特点"><a href="#3-8-2-特点" class="headerlink" title="3.8.2 特点"></a>3.8.2 特点</h4><p>与 Object 的 wait &amp; notify 相比</p><ul><li><p>wait，notify 和 notifyAll 必须配合 Object Monitor 一起使用，而 park，unpark 不必</p></li><li><p>park &amp; unpark 是以 <code>线程为单位</code> 来【阻塞】和【唤醒】线程，而 notify 只能 <code>随机</code> 唤醒一个等待线程，notifyAll 是唤醒所有等待线程，就不那么【精确】</p></li><li><p>park &amp; unpark  <code>可以先 unpark</code> ，而 wait &amp; notify 不能先 notify</p></li></ul><h4 id="3-8-3-原理"><a href="#3-8-3-原理" class="headerlink" title="3.8.3 原理"></a>3.8.3 原理</h4><p> <strong>每个线程都有自己的一个 Parker 对象</strong> ，由三部分组成  <code>_counter </code> ， <code>_cond</code> 和 <code>_mutex</code> 打个比喻</p><ul><li>线程就像一个旅人，Parker 就像他随身携带的背包，cond 条件变量就好比背包中的帐篷。counter 就好比背包中的备用干粮（0 为耗尽，1 为充足）</li><li>调用 park 就是要看 <strong>需不需要停下来歇息</strong> <ul><li>如果备用干粮耗尽，那么钻进帐篷歇息</li><li>如果备用干粮充足，那么不需停留，继续前进</li></ul></li><li>调用 unpark，就好比 <strong>令干粮充足</strong> <ul><li>如果这时线程还在帐篷，就唤醒让他继续前进</li><li>如果这时线程还在运行，那么 <code>下次他调用 park 时，仅是消耗掉备用干粮</code> ，不需停留继续前进<ul><li>因为背包空间有限，<code>多次调用 unpark 仅会补充一份备用干粮</code></li></ul></li></ul></li></ul><h5 id="先调用park再调用upark的过程"><a href="#先调用park再调用upark的过程" class="headerlink" title="先调用park再调用upark的过程"></a>先调用park再调用upark的过程</h5><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210430093445.png"></p><ol><li>当前线程调用 Unsafe.park() 方法</li><li>检查 _counter ，本情况为 0，这时，获得  _mutex 互斥锁 </li><li>线程进入 _cond 条件变量阻塞</li><li>设置 _counter = 0</li></ol><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210430093840.png"></p><ol><li>调用 Unsafe.unpark(Thread_0) 方法，设置 _counter 为 1</li><li>唤醒 _cond 条件变量中的 Thread_0</li><li>Thread_0 恢复运行</li><li>设置 _counter 为 0</li></ol><h5 id="先调用unpark再调用park的过程"><a href="#先调用unpark再调用park的过程" class="headerlink" title="先调用unpark再调用park的过程"></a>先调用unpark再调用park的过程</h5><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210430093925.png"></p><ol><li>调用 Unsafe.unpark(Thread_0) 方法，设置 _counter 为 1</li><li>当前线程调用 Unsafe.park() 方法</li><li>检查 _counter ，本情况为 1，这时线程无需阻塞，继续运行</li><li>设置 _counter 为 0</li></ol><h3 id="3-9-重新理解线程状态"><a href="#3-9-重新理解线程状态" class="headerlink" title="3.9 重新理解线程状态"></a>3.9 重新理解线程状态</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210430094221.png"></p><p>假设有线程 <code>Thread t</code></p><h4 id="情况-1-NEW-–-gt-RUNNABLE"><a href="#情况-1-NEW-–-gt-RUNNABLE" class="headerlink" title="情况 1 NEW –&gt; RUNNABLE"></a>情况 1 NEW –&gt; RUNNABLE</h4><p>当调用 t.start() 方法时，由 NEW –&gt; RUNNABLE</p><h4 id="情况2-RUNNABLE-lt-–-gt-WAITING"><a href="#情况2-RUNNABLE-lt-–-gt-WAITING" class="headerlink" title="情况2 RUNNABLE &lt;–&gt; WAITING"></a>情况2 RUNNABLE &lt;–&gt; WAITING</h4><p> <strong>t 线程</strong> 用 <code>synchronized(obj) </code> 获取了对象锁后</p><ul><li><p>调用 <code>obj.wait() </code>方法时，t 线程从 <code>RUNNABLE --&gt; WAITING</code></p></li><li><p>调用 <code>obj.notify() ， obj.notifyAll() ， t.interrupt()</code> 时</p><ul><li>竞争锁成功，t 线程从<code>WAITING --&gt; RUNNABLE</code></li><li>竞争锁失败，t 线程从<code>WAITING --&gt; BLOCKED</code></li></ul><p>( <code>修正</code> ：线程被notify之后不会直接参与竞争锁，因为唤醒他们的线程正在使用锁，没有竞争锁成功失败之说，所以线程被notify之后直接从waitset进入entrylist，对应的状态就是从WAITING变为BLOCKED,至于锁的竞争成功与失败那是转变为BLOCKED状态之后的事情了)</p></li></ul><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210430100603.png"></p><p>运行到notifyAll的时候，由于t1和t2都执行了wait，会进入waitset中，处于 <strong>waiting状态</strong> ，之后主线程持有锁，唤醒他们，但执行到下一句 }的时候， <strong>主线程还在持有锁，t1和t2都无法获取锁，所以两个状态都是blocked</strong> （idea显示为monitor）</p><p>主线程释放锁后，竞争才会从blocked变成runnable</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210430101049.png"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210430101552.png"></p><h4 id="情况-3-RUNNABLE-lt-–-gt-WAITING"><a href="#情况-3-RUNNABLE-lt-–-gt-WAITING" class="headerlink" title="情况 3 RUNNABLE &lt;–&gt; WAITING"></a>情况 3 RUNNABLE &lt;–&gt; WAITING</h4><ul><li><strong>当前线程</strong> 调用 <code>t.join()</code> 方法时，当前线程从 <code>RUNNABLE --&gt; WAITING</code><ul><li>注意是 <strong>当前线程</strong> 在 <strong>t 线程对象的监视器上等待</strong> </li></ul></li><li> <strong>t 线程运行结束</strong> ，或调用了 <strong>当前线程的 interrupt()</strong>  时， <strong>当前线程</strong> 从 WAITING –&gt; RUNNABLE</li></ul><h4 id="情况-4-RUNNABLE-lt-–-gt-WAITING"><a href="#情况-4-RUNNABLE-lt-–-gt-WAITING" class="headerlink" title="情况 4 RUNNABLE &lt;–&gt; WAITING"></a>情况 4 RUNNABLE &lt;–&gt; WAITING</h4><ul><li>当前线程调用<code> LockSupport.park()</code> 方法会让当前线程从 <code>RUNNABLE --&gt; WAITING</code></li><li>调用 <code>LockSupport.unpark(目标线程)</code> 或调用了线程 的<code>interrupt()</code>，会让目标线程从 WAITING –&gt;<br>RUNNABLE</li></ul><h4 id="情况-5-RUNNABLE-lt-–-gt-TIMED-WAITING"><a href="#情况-5-RUNNABLE-lt-–-gt-TIMED-WAITING" class="headerlink" title="情况 5 RUNNABLE &lt;–&gt; TIMED_WAITING"></a>情况 5 RUNNABLE &lt;–&gt; TIMED_WAITING</h4><p> <strong>t 线程</strong> 用 <code>synchronized(obj)</code> 获取了对象锁后</p><ul><li>调用 <code>obj.wait(long n)</code> 方法时，t 线程从 <code>RUNNABLE --&gt; TIMED_WAITING</code></li><li>t 线程等待时间超过了 n 毫秒，或调用 obj.notify() ， obj.notifyAll() ， t.interrupt() 时<ul><li>竞争锁成功，t 线程从TIMED_WAITING –&gt; RUNNABLE</li><li>竞争锁失败，t 线程从TIMED_WAITING –&gt; BLOCKED</li></ul></li></ul><h4 id="情况-6-RUNNABLE-lt-–-gt-TIMED-WAITING"><a href="#情况-6-RUNNABLE-lt-–-gt-TIMED-WAITING" class="headerlink" title="情况 6 RUNNABLE &lt;–&gt; TIMED_WAITING"></a>情况 6 RUNNABLE &lt;–&gt; TIMED_WAITING</h4><ul><li>当前线程调用 <code>t.join(long n) </code>方法时，当前线程从 RUNNABLE –&gt; TIMED_WAITING<ul><li>注意是 <strong>当前线程</strong> 在 <strong>t 线程对象的监视器上等待</strong> </li></ul></li><li>当前线程等待时间超过了 n 毫秒，或t 线程运行结束，或调用了当前线程的 interrupt() 时，当前线程从<br>TIMED_WAITING –&gt; RUNNABLE</li></ul><h4 id="情况7-RUNNABLE-lt-–-gt-TIMED-WAITING"><a href="#情况7-RUNNABLE-lt-–-gt-TIMED-WAITING" class="headerlink" title="情况7 RUNNABLE &lt;–&gt; TIMED_WAITING"></a>情况7 RUNNABLE &lt;–&gt; TIMED_WAITING</h4><ul><li>当前线程调用 <code>Thread.sleep(long n)</code>  ，当前线程从 RUNNABLE –&gt; TIMED_WAITING</li><li>当前线程等待时间超过了 n 毫秒，当前线程从TIMED_WAITING –&gt; RUNNABLE-</li></ul><h4 id="情况-8-RUNNABLE-lt-–-gt-TIMED-WAITING"><a href="#情况-8-RUNNABLE-lt-–-gt-TIMED-WAITING" class="headerlink" title="情况 8 RUNNABLE &lt;–&gt; TIMED_WAITING"></a>情况 8 RUNNABLE &lt;–&gt; TIMED_WAITING</h4><ul><li>当前线程调用 <code>LockSupport.parkNanos(long nanos) 或 LockSupport.parkUntil(long millis)</code> 时， <strong>当前线程</strong> 从 RUNNABLE –&gt; TIMED_WAITING</li><li>调用 LockSupport.unpark(目标线程) 或调用了线程 的 interrupt() ，或是等待超时，会让目标线程从<br>TIMED_WAITING–&gt; RUNNABLE</li></ul><h4 id="情况-9-RUNNABLE-lt-–-gt-BLOCKED"><a href="#情况-9-RUNNABLE-lt-–-gt-BLOCKED" class="headerlink" title="情况 9 RUNNABLE &lt;–&gt; BLOCKED"></a>情况 9 RUNNABLE &lt;–&gt; BLOCKED</h4><ul><li> <strong>t 线程</strong> 用 **synchronized(obj) ** 获取了对象锁时如果竞争失败，从RUNNABLE –&gt; BLOCKED</li><li>持 obj 锁线程的同步代码块执行完毕，会唤醒该对象上所有 BLOCKED的线程重新竞争，如果其中 t 线程竞争成功，从 BLOCKED –&gt; RUNNABLE ，其它 <strong>失败的线程仍然BLOCKED</strong> </li></ul><h4 id="情况-10-RUNNABLE-lt-–-gt-TERMINATED"><a href="#情况-10-RUNNABLE-lt-–-gt-TERMINATED" class="headerlink" title="情况 10 RUNNABLE &lt;–&gt; TERMINATED"></a>情况 10 RUNNABLE &lt;–&gt; TERMINATED</h4><p>当前线程所有代码运行完毕，进入 <code>TERMINATED</code></p><h3 id="3-10-多把锁"><a href="#3-10-多把锁" class="headerlink" title="3.10 多把锁"></a>3.10 多把锁</h3><h4 id="多把不相干的锁"><a href="#多把不相干的锁" class="headerlink" title="多把不相干的锁"></a>多把不相干的锁</h4><p>一间大屋子有两个功能：睡觉、学习，互不相干。<br>现在小南要学习，小女要睡觉，但如果只用一间屋子（一个对象锁）的话，那么并发度很低解决方法是准备多个房间（多个对象锁）<br>例如</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BigRoom</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sleep</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;            log.debug(<span class="hljs-string">&quot;sleeping 2 小时&quot;</span>);            Sleeper.sleep(<span class="hljs-number">2</span>);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">study</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;            log.debug(<span class="hljs-string">&quot;study 1 小时&quot;</span>);            Sleeper.sleep(<span class="hljs-number">1</span>);        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        BigRoom bigRoom = <span class="hljs-keyword">new</span> BigRoom();        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            bigRoom.study();        &#125;,<span class="hljs-string">&quot;小南&quot;</span>).start();        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            bigRoom.sleep();        &#125;,<span class="hljs-string">&quot;小女&quot;</span>).start();    &#125;</code></pre><p>并发度低，解决方法：准备多个房间：</p><pre><code class="hljs java">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object studyRoom = <span class="hljs-keyword">new</span> Object();    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object bedRoom = <span class="hljs-keyword">new</span> Object();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sleep</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">synchronized</span> (bedRoom) &#123;            log.debug(<span class="hljs-string">&quot;sleeping 2 小时&quot;</span>);            Sleeper.sleep(<span class="hljs-number">2</span>);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">study</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">synchronized</span> (studyRoom) &#123;            log.debug(<span class="hljs-string">&quot;study 1 小时&quot;</span>);            Sleeper.sleep(<span class="hljs-number">1</span>);        &#125;    &#125;&#125;</code></pre><p>利用 <strong>细粒度锁</strong> </p><p>将锁的粒度细分</p><ul><li>好处，是可以增强并发度</li><li>坏处，如果一个线程需要同时获得多把锁，就容易发生 <code>死锁</code></li></ul><h3 id="3-11-活跃性"><a href="#3-11-活跃性" class="headerlink" title="3.11 活跃性"></a>3.11 活跃性</h3><h4 id="3-11-1-死锁"><a href="#3-11-1-死锁" class="headerlink" title="3.11.1 死锁"></a>3.11.1 死锁</h4><p>有这样的情况：一个线程需要 <strong>同时获取多把锁</strong> ，这时就容易发生死锁<br>t1 线程 获得 A对象 锁，接下来想获取 B对象 的锁 t2 线程 获得 B对象 锁，接下来想获取 A对象 的锁 例：</p><pre><code class="hljs java">Object A = <span class="hljs-keyword">new</span> Object();Object B = <span class="hljs-keyword">new</span> Object();Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;    <span class="hljs-keyword">synchronized</span> (A) &#123;        log.debug(<span class="hljs-string">&quot;lock A 已经获得&quot;</span>);        sleep(<span class="hljs-number">1</span>);        <span class="hljs-keyword">synchronized</span> (B) &#123;            log.debug(<span class="hljs-string">&quot;尝试获取 lock B&quot;</span>);            log.debug(<span class="hljs-string">&quot;操作...&quot;</span>);        &#125;    &#125;&#125;, <span class="hljs-string">&quot;t1&quot;</span>);Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;    <span class="hljs-keyword">synchronized</span> (B) &#123;        log.debug(<span class="hljs-string">&quot;lock B 已经获得&quot;</span>);        sleep(<span class="hljs-number">0.5</span>);        <span class="hljs-keyword">synchronized</span> (A) &#123;            log.debug(<span class="hljs-string">&quot;尝试获取 lock A&quot;</span>);            log.debug(<span class="hljs-string">&quot;操作...&quot;</span>);        &#125;    &#125;&#125;, <span class="hljs-string">&quot;t2&quot;</span>);t1.start();t2.start();</code></pre><pre><code class="hljs ruby">08<span class="hljs-symbol">:</span><span class="hljs-number">49</span><span class="hljs-symbol">:</span><span class="hljs-number">17</span> [t1] c.TestDeadLock - lock A 已经获得08<span class="hljs-symbol">:</span><span class="hljs-number">49</span><span class="hljs-symbol">:</span><span class="hljs-number">17</span> [t2] c.TestDeadLock - lock B 已经获得</code></pre><h4 id="3-11-2-定位死锁"><a href="#3-11-2-定位死锁" class="headerlink" title="3.11.2 定位死锁"></a>3.11.2 定位死锁</h4><ul><li><p>检测死锁可以使用 jconsole工具，或者使用 jps 定位进程 id，再用 jstack 定位死锁：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210501085403.png"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210501085527.png"></p></li><li><p>避免死锁要注意加锁顺序</p></li><li><p>另外如果由于某个线程进入了死循环，导致其它线程一直等待，对于这种情况 linux 下可以通过 top 先定位到CPU 占用高的 Java 进程，再利用 top -Hp 进程id 来定位是哪个线程，最后再用 jstack 排</p></li></ul><h4 id="3-11-3-哲学家进餐问题"><a href="#3-11-3-哲学家进餐问题" class="headerlink" title="3.11.3 哲学家进餐问题"></a>3.11.3 哲学家进餐问题</h4><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210501085854.png"></p><p>有五位哲学家，围坐在圆桌旁。</p><ul><li>他们只做两件事，思考和吃饭，思考一会吃口饭，吃完饭后接着思考。</li><li>吃饭时要用两根筷子吃，桌上共有 5 根筷子，每位哲学家左右手边各有一根筷子。</li><li>如果筷子被身边的人拿着，自己就得等待</li></ul><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Philosopher</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;    Chopstick left;    Chopstick right;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Philosopher</span><span class="hljs-params">(String name, Chopstick left, Chopstick right)</span> </span>&#123;        <span class="hljs-keyword">super</span>(name);        <span class="hljs-keyword">this</span>.left = left;        <span class="hljs-keyword">this</span>.right = right;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;            <span class="hljs-comment">//　尝试获得左手筷子</span>            <span class="hljs-keyword">synchronized</span> (left) &#123;                <span class="hljs-comment">// 尝试获得右手筷子</span>                <span class="hljs-keyword">synchronized</span> (right) &#123;                    eat();                &#125;            &#125;        &#125;    &#125;    Random random = <span class="hljs-keyword">new</span> Random();    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>&#123;        log.debug(<span class="hljs-string">&quot;eating...&quot;</span>);        Sleeper.sleep(<span class="hljs-number">0.5</span>);    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Chopstick</span> </span>&#123;    String name;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Chopstick</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;筷子&#123;&quot;</span> + name + <span class="hljs-string">&#x27;&#125;&#x27;</span>;    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    Chopstick c1 = <span class="hljs-keyword">new</span> Chopstick(<span class="hljs-string">&quot;1&quot;</span>);    Chopstick c2 = <span class="hljs-keyword">new</span> Chopstick(<span class="hljs-string">&quot;2&quot;</span>);    Chopstick c3 = <span class="hljs-keyword">new</span> Chopstick(<span class="hljs-string">&quot;3&quot;</span>);    Chopstick c4 = <span class="hljs-keyword">new</span> Chopstick(<span class="hljs-string">&quot;4&quot;</span>);    Chopstick c5 = <span class="hljs-keyword">new</span> Chopstick(<span class="hljs-string">&quot;5&quot;</span>);    <span class="hljs-keyword">new</span> Philosopher(<span class="hljs-string">&quot;苏格拉底&quot;</span>, c1, c2).start();    <span class="hljs-keyword">new</span> Philosopher(<span class="hljs-string">&quot;柏拉图&quot;</span>, c2, c3).start();    <span class="hljs-keyword">new</span> Philosopher(<span class="hljs-string">&quot;亚里士多德&quot;</span>, c3, c4).start();    <span class="hljs-keyword">new</span> Philosopher(<span class="hljs-string">&quot;赫拉克利特&quot;</span>, c4, c5).start();    <span class="hljs-keyword">new</span> Philosopher(<span class="hljs-string">&quot;阿基米德&quot;</span>, c5, c1).start();&#125;</code></pre><pre><code class="hljs ruby">09<span class="hljs-symbol">:</span><span class="hljs-number">06</span><span class="hljs-symbol">:</span><span class="hljs-number">43</span> [苏格拉底] c.Philosopher - eating...09<span class="hljs-symbol">:</span><span class="hljs-number">06</span><span class="hljs-symbol">:</span><span class="hljs-number">43</span> [亚里士多德] c.Philosopher - eating...09<span class="hljs-symbol">:</span><span class="hljs-number">06</span><span class="hljs-symbol">:</span><span class="hljs-number">43</span> [亚里士多德] c.Philosopher - eating...09<span class="hljs-symbol">:</span><span class="hljs-number">06</span><span class="hljs-symbol">:</span><span class="hljs-number">43</span> [苏格拉底] c.Philosopher - eating...09<span class="hljs-symbol">:</span><span class="hljs-number">06</span><span class="hljs-symbol">:</span><span class="hljs-number">43</span> [亚里士多德] c.Philosopher - eating...09<span class="hljs-symbol">:</span><span class="hljs-number">06</span><span class="hljs-symbol">:</span><span class="hljs-number">43</span> [亚里士多德] c.Philosopher - eating...09<span class="hljs-symbol">:</span><span class="hljs-number">06</span><span class="hljs-symbol">:</span><span class="hljs-number">43</span> [亚里士多德] c.Philosopher - eating...09<span class="hljs-symbol">:</span><span class="hljs-number">06</span><span class="hljs-symbol">:</span><span class="hljs-number">43</span> [亚里士多德] c.Philosopher - eating...09<span class="hljs-symbol">:</span><span class="hljs-number">06</span><span class="hljs-symbol">:</span><span class="hljs-number">43</span> [亚里士多德] c.Philosopher - eating...09<span class="hljs-symbol">:</span><span class="hljs-number">06</span><span class="hljs-symbol">:</span><span class="hljs-number">43</span> [亚里士多德] c.Philosopher - eating...</code></pre><p>使用jconsole：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210501090759.png"></p><h4 id="3-11-4-活锁"><a href="#3-11-4-活锁" class="headerlink" title="3.11.4 活锁"></a>3.11.4 活锁</h4><p>活锁出现在 <strong>两个线程互相改变对方的结束条件</strong> ，最后谁也无法结束，例如</p><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> count = <span class="hljs-number">10</span>;<span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object lock = <span class="hljs-keyword">new</span> Object();<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;        <span class="hljs-comment">// 期望减到 0 退出循环</span>        <span class="hljs-keyword">while</span> (count &gt; <span class="hljs-number">0</span>) &#123;            Sleeper.sleep(<span class="hljs-number">0.2</span>);            count--;            log.debug(<span class="hljs-string">&quot;count: &#123;&#125;&quot;</span>, count);        &#125;    &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();    <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;        <span class="hljs-comment">// 期望超过 20 退出循环</span>        <span class="hljs-keyword">while</span> (count &lt; <span class="hljs-number">20</span>) &#123;            Sleeper.sleep(<span class="hljs-number">0.2</span>);            count++;            log.debug(<span class="hljs-string">&quot;count: &#123;&#125;&quot;</span>, count);        &#125;    &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();&#125;</code></pre><p>解决活锁：睡眠时间随机。</p><h4 id="3-11-5-饥饿"><a href="#3-11-5-饥饿" class="headerlink" title="3.11.5 饥饿"></a>3.11.5 饥饿</h4><p>很多教程中把饥饿定义为， <strong>一个线程由于优先级太低，始终得不到 CPU 调度执行，也不能够结束</strong> ，饥饿的情况不易演示，讲读写锁时会涉及饥饿问题<br>下面我讲一下我遇到的一个线程饥饿的例子，先来看看使用顺序加锁的方式解决之前的死锁问题</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210501091458.png"></p><p>顺序加锁的解决方案</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210501091531.png"></p><p>把哲学家问题最后一个5,1顺序改成1,5</p><p>但是会产生 <code>饥饿</code> 现象</p><h3 id="3-12-ReentrantLock"><a href="#3-12-ReentrantLock" class="headerlink" title="3.12 ReentrantLock"></a>3.12 ReentrantLock</h3><p>ReentrantLock 可重入的</p><p>相对于 synchronized 它具备如下特点</p><ul><li><p>可 <strong>中断</strong> </p></li><li><p>可以设置 <strong>超时时间</strong> </p></li><li><p>可以设置为 <strong>公平锁</strong> </p></li><li><p>支持 <strong>多个条件变量</strong> （支持多个waitset，可以到不同waitset里面等）</p><p>与 synchronized 一样，都支持可重入</p></li></ul><p>基本语法：</p><pre><code class="hljs java"><span class="hljs-comment">// 获取锁</span>reentrantLock.lock();  <span class="hljs-keyword">try</span> &#123;    <span class="hljs-comment">// 临界区</span>  &#125; <span class="hljs-keyword">finally</span> &#123;    <span class="hljs-comment">// 释放锁</span>    reentrantLock.unlock();&#125;</code></pre><h4 id="3-12-1-可重入"><a href="#3-12-1-可重入" class="headerlink" title="3.12.1 可重入"></a>3.12.1 可重入</h4><p>可重入是指 <strong>同一个线程如果首次获得了这把锁，那么因为它是这把锁的拥有者，因此有权利再次获取这把锁</strong><br>如果是 <strong>不可重入锁，那么第二次获得锁时，自己也会被锁挡住</strong> </p><p>synchronized在关键字级别保护临界区，reentrantlock在对象级别</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testReentrant</span><span class="hljs-params">()</span> </span>&#123;    method1();&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span> </span>&#123;    lock.lock();    <span class="hljs-keyword">try</span> &#123;        log.debug(<span class="hljs-string">&quot;execute method1&quot;</span>);        method2();    &#125; <span class="hljs-keyword">finally</span> &#123;        lock.unlock();    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">()</span> </span>&#123;    lock.lock();    <span class="hljs-keyword">try</span> &#123;        log.debug(<span class="hljs-string">&quot;execute method2&quot;</span>);        method3();    &#125; <span class="hljs-keyword">finally</span> &#123;        lock.unlock();    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method3</span><span class="hljs-params">()</span> </span>&#123;    lock.lock();    <span class="hljs-keyword">try</span> &#123;        log.debug(<span class="hljs-string">&quot;execute method3&quot;</span>);    &#125; <span class="hljs-keyword">finally</span> &#123;        lock.unlock();    &#125;&#125;</code></pre><pre><code class="hljs ruby">09<span class="hljs-symbol">:</span><span class="hljs-number">30</span><span class="hljs-symbol">:</span><span class="hljs-number">21</span> [main] c.Test22 - execute method109<span class="hljs-symbol">:</span><span class="hljs-number">30</span><span class="hljs-symbol">:</span><span class="hljs-number">21</span> [main] c.Test22 - execute method209<span class="hljs-symbol">:</span><span class="hljs-number">30</span><span class="hljs-symbol">:</span><span class="hljs-number">21</span> [main] c.Test22 - execute method3</code></pre><h4 id="3-12-2-可打断"><a href="#3-12-2-可打断" class="headerlink" title="3.12.2 可打断"></a>3.12.2 可打断</h4><pre><code class="hljs java">lock.lockInterruptibly();</code></pre><ul><li>如果没有竞争那么此方法就会获取lock对象锁</li><li>如果有竞争就进入阻塞队列，可以被其他线程用interrupt打断</li></ul><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210501094147.png"></p><p>如果主线程已经获取锁：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210501094242.png"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210501094303.png"></p><h4 id="3-12-3-锁超时"><a href="#3-12-3-锁超时" class="headerlink" title="3.12.3 锁超时"></a>3.12.3 锁超时</h4><pre><code class="hljs java"><span class="hljs-comment">// 锁超时</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testDemo</span><span class="hljs-params">()</span> </span>&#123;    Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;        log.debug(<span class="hljs-string">&quot;尝试获得锁&quot;</span>);        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">if</span> (! lock.tryLock(<span class="hljs-number">2</span>, TimeUnit.SECONDS)) &#123;                log.debug(<span class="hljs-string">&quot;获取不到锁&quot;</span>);                <span class="hljs-keyword">return</span>;            &#125;        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();            log.debug(<span class="hljs-string">&quot;获取不到锁&quot;</span>);            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">try</span> &#123;            log.debug(<span class="hljs-string">&quot;获得到锁&quot;</span>);        &#125; <span class="hljs-keyword">finally</span> &#123;            lock.unlock();        &#125;    &#125;, <span class="hljs-string">&quot;t1&quot;</span>);    lock.lock();    log.debug(<span class="hljs-string">&quot;获得到锁&quot;</span>);    t1.start();    Sleeper.sleep(<span class="hljs-number">1</span>);    log.debug(<span class="hljs-string">&quot;释放了锁&quot;</span>);    lock.unlock();&#125;</code></pre><pre><code class="hljs ruby">09<span class="hljs-symbol">:</span><span class="hljs-number">44</span><span class="hljs-symbol">:</span><span class="hljs-number">46</span> [main] c.Test22 - 获得到锁09<span class="hljs-symbol">:</span><span class="hljs-number">44</span><span class="hljs-symbol">:</span><span class="hljs-number">46</span> [t1] c.Test22 - 尝试获得锁09<span class="hljs-symbol">:</span><span class="hljs-number">44</span><span class="hljs-symbol">:</span><span class="hljs-number">47</span> [main] c.Test22 - 释放了锁09<span class="hljs-symbol">:</span><span class="hljs-number">44</span><span class="hljs-symbol">:</span><span class="hljs-number">47</span> [t1] c.Test22 - 获得到锁</code></pre><h5 id="使用-tryLock-解决哲学家就餐问题"><a href="#使用-tryLock-解决哲学家就餐问题" class="headerlink" title="使用 tryLock 解决哲学家就餐问题"></a>使用 tryLock 解决哲学家就餐问题</h5><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210501095058.png"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210501095132.png"></p><p>原因：获取第二把筷子失败会释放手里的第一把筷子</p><h4 id="3-12-4-公平锁"><a href="#3-12-4-公平锁" class="headerlink" title="3.12.4 公平锁"></a>3.12.4 公平锁</h4><p>ReentrantLock 默认是不公平的</p><p>ReentrantLock lock = new ReentrantLock(false);</p><p>公平锁一般没有必要，会降低并发度，后面分析原理</p><h4 id="3-12-5-条件变量"><a href="#3-12-5-条件变量" class="headerlink" title="3.12.5 条件变量"></a>3.12.5 条件变量</h4><p>synchronized 中也有<code>条件变量</code>，就是我们讲原理时那个 <code>waitSet 休息室</code>，当条件不满足时进入 waitSet 等待<br>ReentrantLock 的条件变量比 synchronized 强大之处在于，它是支持 <code>多个条件变量的</code> ，这就好比</p><ul><li>synchronized 是那些不满足条件的线程都在一间休息室等消息</li><li>而 ReentrantLock 支持多间休息室，有专门等烟的休息室、专门等早餐的休息室、唤醒时也是按休息室来唤醒</li></ul><p>使用要点：</p><ul><li>await 前需要获得锁</li><li>await 执行后，会释放锁，进入 conditionObject 等待</li><li>await 的线程被唤醒（或打断、或超时）取重新竞争 lock 锁</li><li>竞争 lock 锁成功后，从 await 后继续执行</li></ul><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object room = <span class="hljs-keyword">new</span> Object();<span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> hasCigarette = <span class="hljs-keyword">false</span>;<span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> hasTakeout = <span class="hljs-keyword">false</span>;<span class="hljs-keyword">static</span> ReentrantLock ROOM = <span class="hljs-keyword">new</span> ReentrantLock();<span class="hljs-comment">// 等待烟的休息室</span><span class="hljs-keyword">static</span> Condition waitCigaretteSet = ROOM.newCondition();<span class="hljs-comment">// 等外卖的休息室</span><span class="hljs-keyword">static</span> Condition waitTakeoutSet = ROOM.newCondition();<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;        ROOM.lock();        <span class="hljs-keyword">try</span> &#123;            log.debug(<span class="hljs-string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);            <span class="hljs-keyword">while</span> (!hasCigarette) &#123;                log.debug(<span class="hljs-string">&quot;没烟，先歇会！&quot;</span>);                <span class="hljs-keyword">try</span> &#123;                    waitCigaretteSet.await();                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;            log.debug(<span class="hljs-string">&quot;可以开始干活了&quot;</span>);        &#125; <span class="hljs-keyword">finally</span> &#123;            ROOM.unlock();        &#125;    &#125;, <span class="hljs-string">&quot;小南&quot;</span>).start();    <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;        ROOM.lock();        <span class="hljs-keyword">try</span> &#123;            log.debug(<span class="hljs-string">&quot;外卖送到没？[&#123;&#125;]&quot;</span>, hasTakeout);            <span class="hljs-keyword">while</span> (!hasTakeout) &#123;                log.debug(<span class="hljs-string">&quot;没外卖，先歇会！&quot;</span>);                <span class="hljs-keyword">try</span> &#123;                    waitTakeoutSet.await();                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;            log.debug(<span class="hljs-string">&quot;可以开始干活了&quot;</span>);        &#125; <span class="hljs-keyword">finally</span> &#123;            ROOM.unlock();        &#125;    &#125;, <span class="hljs-string">&quot;小女&quot;</span>).start();    sleep(<span class="hljs-number">1</span>);    <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;        ROOM.lock();        <span class="hljs-keyword">try</span> &#123;            hasTakeout = <span class="hljs-keyword">true</span>;            waitTakeoutSet.signal();        &#125; <span class="hljs-keyword">finally</span> &#123;            ROOM.unlock();        &#125;    &#125;, <span class="hljs-string">&quot;送外卖的&quot;</span>).start();    sleep(<span class="hljs-number">1</span>);    <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;        ROOM.lock();        <span class="hljs-keyword">try</span> &#123;            hasCigarette = <span class="hljs-keyword">true</span>;            waitCigaretteSet.signal();        &#125; <span class="hljs-keyword">finally</span> &#123;            ROOM.unlock();        &#125;    &#125;, <span class="hljs-string">&quot;送烟的&quot;</span>).start();&#125;</code></pre><pre><code class="hljs ruby"><span class="hljs-number">10</span><span class="hljs-symbol">:</span>09<span class="hljs-symbol">:</span><span class="hljs-number">03</span> [小南] c.Test24 - 有烟没？[<span class="hljs-literal">false</span>]<span class="hljs-number">10</span><span class="hljs-symbol">:</span>09<span class="hljs-symbol">:</span><span class="hljs-number">03</span> [小南] c.Test24 - 没烟，先歇会！<span class="hljs-number">10</span><span class="hljs-symbol">:</span>09<span class="hljs-symbol">:</span><span class="hljs-number">03</span> [小女] c.Test24 - 外卖送到没？[<span class="hljs-literal">false</span>]<span class="hljs-number">10</span><span class="hljs-symbol">:</span>09<span class="hljs-symbol">:</span><span class="hljs-number">03</span> [小女] c.Test24 - 没外卖，先歇会！<span class="hljs-number">10</span><span class="hljs-symbol">:</span>09<span class="hljs-symbol">:</span><span class="hljs-number">04</span> [小女] c.Test24 - 可以开始干活了<span class="hljs-number">10</span><span class="hljs-symbol">:</span>09<span class="hljs-symbol">:</span><span class="hljs-number">05</span> [小南] c.Test24 - 可以开始干活了</code></pre><h3 id="同步模式之顺序控制"><a href="#同步模式之顺序控制" class="headerlink" title="同步模式之顺序控制"></a>同步模式之顺序控制</h3><p>必须先 2 后 1 打印</p><h4 id="1-wait-notify版实现"><a href="#1-wait-notify版实现" class="headerlink" title="1. wait/notify版实现"></a>1. wait/notify版实现</h4><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object lock = <span class="hljs-keyword">new</span> Object();<span class="hljs-comment">// 表示 t2 是否运行过</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> t2runned = <span class="hljs-keyword">false</span>;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;        <span class="hljs-keyword">synchronized</span> (lock) &#123;            <span class="hljs-keyword">while</span> (!t2runned) &#123;                <span class="hljs-keyword">try</span> &#123;                    lock.wait();                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;            log.debug(<span class="hljs-string">&quot;1&quot;</span>);        &#125;    &#125;, <span class="hljs-string">&quot;t1&quot;</span>);    Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;        <span class="hljs-keyword">synchronized</span> (lock) &#123;            log.debug(<span class="hljs-string">&quot;2&quot;</span>);            t2runned = <span class="hljs-keyword">true</span>;            lock.notify();        &#125;    &#125;, <span class="hljs-string">&quot;t2&quot;</span>);    t1.start();    t2.start();&#125;</code></pre><pre><code class="hljs ruby"><span class="hljs-number">10</span><span class="hljs-symbol">:</span><span class="hljs-number">17</span><span class="hljs-symbol">:</span>08 [t2] c.Test25 - <span class="hljs-number">2</span><span class="hljs-number">10</span><span class="hljs-symbol">:</span><span class="hljs-number">17</span><span class="hljs-symbol">:</span>08 [t1] c.Test25 - <span class="hljs-number">1</span></code></pre><h4 id="2-Park-Unpark-版"><a href="#2-Park-Unpark-版" class="headerlink" title="2.Park Unpark 版"></a>2.Park Unpark 版</h4><p>可以看到，实现上很麻烦：</p><ul><li>首先，需要保证先 wait 再 notify，否则 wait 线程永远得不到唤醒。因此使用了 <strong>『运行标记』</strong> 来判断该不该wait</li><li>第二，如果有些干扰线程错误地 notify 了 wait 线程，条件不满足时还要重新等待，使用了 while 循环来解决此问题</li><li>最后，唤醒对象上的 wait 线程需要使用 notifyAll，因为『同步对象』上的等待线程可能不止一个<br>可以使用 LockSupport 类的 park 和 unpark 来简化上面的题目：</li></ul><pre><code class="hljs java">Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;    LockSupport.park();    log.debug(<span class="hljs-string">&quot;1&quot;</span>);&#125;, <span class="hljs-string">&quot;t1&quot;</span>);t1.start();<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;    log.debug(<span class="hljs-string">&quot;2&quot;</span>);    LockSupport.unpark(t1);&#125;,<span class="hljs-string">&quot;t2&quot;</span>).start();</code></pre><p>park 和 unpark 方法比较灵活，他俩谁先调用，谁后调用无所谓。并且是以线程为单位进行『暂停』和『恢复』，不需要『同步对象』和『运行标记』</p><h3 id="同步模式之交替输出"><a href="#同步模式之交替输出" class="headerlink" title="同步模式之交替输出"></a>同步模式之交替输出</h3><p>线程 1 输出 a 5 次，线程 2 输出 b 5 次，线程 3 输出 c 5 次。现在要求输出 abcabcabcabcabc 怎么实现</p><h4 id="1-wait-notify版实现-1"><a href="#1-wait-notify版实现-1" class="headerlink" title="1. wait/notify版实现"></a>1. wait/notify版实现</h4><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Test27&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test27</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        WaitNotify wn = <span class="hljs-keyword">new</span> WaitNotify(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>);        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            wn.print(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>);        &#125;).start();        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            wn.print(<span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);        &#125;).start();        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            wn.print(<span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>);        &#125;).start();    &#125;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">输出内容       等待标记     下一个标记</span><span class="hljs-comment">   a           1             2</span><span class="hljs-comment">   b           2             3</span><span class="hljs-comment">   c           3             1</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WaitNotify</span> </span>&#123;    <span class="hljs-comment">// 打印               a           1             2</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(String str, <span class="hljs-keyword">int</span> waitFlag, <span class="hljs-keyword">int</span> nextFlag)</span> </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; loopNumber; i++) &#123;            <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;                <span class="hljs-keyword">while</span>(flag != waitFlag) &#123;                    <span class="hljs-keyword">try</span> &#123;                        <span class="hljs-keyword">this</span>.wait();                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                        e.printStackTrace();                    &#125;                &#125;                System.out.print(str);                flag = nextFlag;                <span class="hljs-keyword">this</span>.notifyAll();            &#125;        &#125;    &#125;    <span class="hljs-comment">// 等待标记</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> flag; <span class="hljs-comment">// 2</span>    <span class="hljs-comment">// 循环次数</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> loopNumber;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">WaitNotify</span><span class="hljs-params">(<span class="hljs-keyword">int</span> flag, <span class="hljs-keyword">int</span> loopNumber)</span> </span>&#123;        <span class="hljs-keyword">this</span>.flag = flag;        <span class="hljs-keyword">this</span>.loopNumber = loopNumber;    &#125;&#125;</code></pre><h4 id="2-Lock-条件变量版"><a href="#2-Lock-条件变量版" class="headerlink" title="2. Lock 条件变量版"></a>2. Lock 条件变量版</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test30</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        AwaitSignal awaitSignal = <span class="hljs-keyword">new</span> AwaitSignal(<span class="hljs-number">5</span>);        Condition a = awaitSignal.newCondition();        Condition b = awaitSignal.newCondition();        Condition c = awaitSignal.newCondition();        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            awaitSignal.print(<span class="hljs-string">&quot;a&quot;</span>, a, b);        &#125;).start();        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            awaitSignal.print(<span class="hljs-string">&quot;b&quot;</span>, b, c);        &#125;).start();        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            awaitSignal.print(<span class="hljs-string">&quot;c&quot;</span>, c, a);        &#125;).start();        Thread.sleep(<span class="hljs-number">1000</span>);        awaitSignal.lock();        <span class="hljs-keyword">try</span> &#123;            System.out.println(<span class="hljs-string">&quot;开始...&quot;</span>);            a.signal();        &#125; <span class="hljs-keyword">finally</span> &#123;            awaitSignal.unlock();        &#125;    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AwaitSignal</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ReentrantLock</span></span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> loopNumber;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AwaitSignal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> loopNumber)</span> </span>&#123;        <span class="hljs-keyword">this</span>.loopNumber = loopNumber;    &#125;    <span class="hljs-comment">//            参数1 打印内容， 参数2 进入哪一间休息室, 参数3 下一间休息室</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(String str, Condition current, Condition next)</span> </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; loopNumber; i++) &#123;            lock();            <span class="hljs-keyword">try</span> &#123;                current.await();                System.out.print(str);                next.signal();            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125; <span class="hljs-keyword">finally</span> &#123;                unlock();            &#125;        &#125;    &#125;&#125;</code></pre><p><code>该实现没有考虑 a，b，c 线程都就绪再开始</code></p><h4 id="3-Park-实现"><a href="#3-Park-实现" class="headerlink" title="3. Park 实现"></a>3. Park 实现</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test31</span> </span>&#123;    <span class="hljs-keyword">static</span> Thread t1;    <span class="hljs-keyword">static</span> Thread t2;    <span class="hljs-keyword">static</span> Thread t3;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        ParkUnpark pu = <span class="hljs-keyword">new</span> ParkUnpark(<span class="hljs-number">5</span>);        t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            pu.print(<span class="hljs-string">&quot;a&quot;</span>, t2);        &#125;);        t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            pu.print(<span class="hljs-string">&quot;b&quot;</span>, t3);        &#125;);        t3 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            pu.print(<span class="hljs-string">&quot;c&quot;</span>, t1);        &#125;);        t1.start();        t2.start();        t3.start();        LockSupport.unpark(t1);    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ParkUnpark</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(String str, Thread next)</span> </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; loopNumber; i++) &#123;            LockSupport.park();            System.out.print(str);            LockSupport.unpark(next);        &#125;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> loopNumber;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ParkUnpark</span><span class="hljs-params">(<span class="hljs-keyword">int</span> loopNumber)</span> </span>&#123;        <span class="hljs-keyword">this</span>.loopNumber = loopNumber;    &#125;&#125;</code></pre><h2 id="4、共享模型之内存"><a href="#4、共享模型之内存" class="headerlink" title="4、共享模型之内存"></a>4、共享模型之内存</h2><p>上一章讲解的 Monitor 主要关注的是访问共享变量时，保证临界区代码的原子性</p><p>这一章我们进一步深入学习 <strong>共享变量</strong> 在多线程间的 <strong>【可见性】</strong> 问题与多条 <strong>指令执行</strong> 时的 <strong>【有序性】</strong> 问题</p><h3 id="4-1-Java-内存模型"><a href="#4-1-Java-内存模型" class="headerlink" title="4.1 Java 内存模型"></a>4.1 Java 内存模型</h3><p>JMM 即 Java Memory Model，它定义了 <strong>主存（所有线程共享数据）、工作内存（线程私有数据）</strong> 抽象概念，底层对应着 CPU 寄存器、缓存、硬件内存、CPU 指令优化等。<br>JMM 体现在以下几个方面</p><ul><li>原子性 - 保证指令不会受到线程上下文切换的影响</li><li>可见性 - 保证指令不会受 cpu 缓存的影响</li><li>有序性 - 保证指令不会受 cpu 指令并行优化的影响</li></ul><h3 id="4-2-可见性"><a href="#4-2-可见性" class="headerlink" title="4.2 可见性"></a>4.2 可见性</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210501105649.png"></p><p>main 线程对 run 变量的修改对于 t 线程不可见，导致了 t 线程无法停止：</p><p>为什么呢？分析一下：</p><ol><li><p>初始状态， t 线程刚开始从 <strong>主内存</strong> 读取了 run 的值到工作内存。</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210501105903.png"></p></li><li><p>因为 t 线程要频繁从主内存中读取 run 的值， <strong>JIT 编译器</strong> 会将 run 的值 <strong>缓存</strong> 至自己 <strong>工作内存中的高速缓存中</strong> ，减少对主存中 run 的访问，提高效率</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210501105955.png"></p></li><li><p>1 秒之后，main 线程修改了 run 的值，并同步至主存，而 t 是从自己工作内存中的高速缓存中读取这个变量的值，结果永远是旧值</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210501110046.png"></p></li></ol><h4 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h4><p>volatile（易变关键字）<br>它可以用来修饰成员变量和静态成员变量，他可以 <strong>避免线程从自己的工作缓存中查找变量的值</strong> ，必须到主存中获取它的值，<code>线程操作 volatile 变量都是直接操作主存</code></p><p>或者：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210501110854.png"></p><h4 id="可见性-vs-原子性"><a href="#可见性-vs-原子性" class="headerlink" title="可见性 vs 原子性"></a>可见性 vs 原子性</h4><p>前面例子体现的实际就是可见性，它保证的是在多个线程之间，一个线程对 volatile 变量的修改对另一个线程可见，  <strong>不能保证原子性</strong> ， <strong>仅用在一个写线程，多个读线程</strong> 的情况： 上例从字节码理解是这样的：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210501111259.png"></p><blockquote><p>注意 </p><p>synchronized 语句块既可以保证代码块的原子性，也同时保证代码块内变量的可见性。但缺点是<br>synchronized 是属于重量级操作，性能相对更低<br>如果在前面示例的死循环中加入 System.out.println() 会发现即使不加 volatile 修饰符，线程 t 也能正确看到对 run 变量的修改了，想一想为什么？</p></blockquote><p>print里面有synchronized修饰</p><h4 id="两阶段终止模式改进"><a href="#两阶段终止模式改进" class="headerlink" title="两阶段终止模式改进"></a>两阶段终止模式改进</h4><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.TPTVolatile&quot;)</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TPTVolatile</span> </span>&#123;    <span class="hljs-keyword">private</span> Thread thread;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> stop = <span class="hljs-keyword">false</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span></span>&#123;        thread = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;                Thread current = Thread.currentThread();                <span class="hljs-keyword">if</span>(stop) &#123;                    log.debug(<span class="hljs-string">&quot;料理后事&quot;</span>);                    <span class="hljs-keyword">break</span>;                &#125;                <span class="hljs-keyword">try</span> &#123;                    Thread.sleep(<span class="hljs-number">1000</span>);                    log.debug(<span class="hljs-string">&quot;将结果保存&quot;</span>);                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                &#125;            &#125;        &#125;,<span class="hljs-string">&quot;监控线程&quot;</span>);        thread.start();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;        stop = <span class="hljs-keyword">true</span>;        <span class="hljs-comment">// 防止等待完毕再打断，执行立刻打断</span>        thread.interrupt();    &#125;&#125;</code></pre><h4 id="Balking（犹豫模式）"><a href="#Balking（犹豫模式）" class="headerlink" title="Balking（犹豫模式）"></a>Balking（犹豫模式）</h4><p>Balking （犹豫）模式用在 <strong>一个线程发现另一个线程或本线程已经做了某一件相同的事</strong> ，那么本线程就无需再做了，直接结束返回；如上面的两端暂停，可以多次start，每次都创建一个监控线程。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MonitorService</span> </span>&#123;  <span class="hljs-comment">// 用来表示是否已经有线程已经在执行启动了</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> starting;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;    log.info(<span class="hljs-string">&quot;尝试启动监控线程...&quot;</span>);    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;      <span class="hljs-keyword">if</span> (starting) &#123;      <span class="hljs-keyword">return</span>;    &#125;    starting = <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-comment">// 真正启动监控线程...</span>  &#125;&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210501113402.png"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210501114035.png"></p><p>懒惰初始化</p><h3 id="4-3-有序性"><a href="#4-3-有序性" class="headerlink" title="4.3 有序性"></a>4.3 有序性</h3><p>JVM 会在不影响正确性的前提下，可以调整语句的执行顺序，思考下面一段代码</p><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> i;<span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> j;<span class="hljs-comment">// 在某个线程内执行如下赋值操作</span>i = ...; j = ...;</code></pre><p>可以看到，至于是先执行 i 还是 先执行 j ，对最终的结果不会产生影响。所以，上面代码真正执行时，可以i先也可以j先。</p><p>这种特性称之为『指令重排』，多线程下『指令重排』会影响正确性。为什么要有重排指令这项优化呢？从 CPU执行指令的原理来理解：</p><h4 id="鱼罐头的故事"><a href="#鱼罐头的故事" class="headerlink" title="鱼罐头的故事"></a>鱼罐头的故事</h4><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210501114315.png"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210501114334.png"></p><h4 id="指令重排序优化"><a href="#指令重排序优化" class="headerlink" title="指令重排序优化"></a>指令重排序优化</h4><p>事实上，现代处理器会设计为一个时钟周期完成一条执行时间最长的 CPU 指令。为什么这么做呢？可以想到指令还可以再划分成一个个更小的阶段，例如，每条指令都可以分为： 取指令 - 指令译码 - 执行指令 - 内存访问 - 数据写回 <code>这 5 个阶段</code></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210501114735.png"></p><blockquote><p>术语参考：<br>instruction fetch (IF)<br>instruction decode (ID)<br>execute (EX)<br>memory access (MEM)<br>register write back (WB)</p></blockquote><p>在不改变程序结果的前提下，这些指令的各个阶段可以通过 <code>重排序</code> 和 <code>组合</code> 来实现 <code>指令级并行</code> ，这一技术在 80’s 中叶到 90’s 中叶占据了计算架构的重要地位。</p><blockquote><p>提示：<br>分阶段，分工是提升效率的关键！</p></blockquote><p>指令重排的前提是，重排指令 <code>不能影响结果</code> ，例如</p><pre><code class="hljs java"><span class="hljs-comment">// 可以重排的例子</span><span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>; <span class="hljs-comment">// 指令1</span><span class="hljs-keyword">int</span> b = <span class="hljs-number">20</span>; <span class="hljs-comment">// 指令2</span>System.out.println( a + b );<span class="hljs-comment">// 不能重排的例子</span><span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>; <span class="hljs-comment">// 指令1</span><span class="hljs-keyword">int</span> b = a - <span class="hljs-number">5</span>; <span class="hljs-comment">// 指令2</span></code></pre><blockquote><p>参考： Scoreboarding and the Tomasulo algorithm (which is similar to scoreboarding but makes use of<br>register renaming) are two of the most common techniques for implementing out-of-order execution<br>and instruction-level parallelism.</p></blockquote><h4 id="支持流水线的处理器"><a href="#支持流水线的处理器" class="headerlink" title="支持流水线的处理器"></a>支持流水线的处理器</h4><p>现代 CPU 支持 <code>多级指令流水线</code>，例如支持同时执行 <code>取指令 - 指令译码 - 执行指令 - 内存访问 - 数据写回</code>  的处理器，就可以称之为 <code>五级指令流水线</code>。这时 CPU 可以在一个时钟周期内，同时运行五条指令的不同阶段（相当于一条执行时间最长的复杂指令），IPC = 1，本质上，流水线技术并不能缩短单条指令的执行时间，但它变相地提高了指令地吞吐率。</p><blockquote><p>提示：<br>奔腾四（Pentium 4）支持高达 35 级流水线，但由于功耗太高被废弃</p></blockquote><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210501115237.png"></p><h4 id="诡异结果"><a href="#诡异结果" class="headerlink" title="诡异结果"></a>诡异结果</h4><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210501115510.png"></p><p>I_Result 是一个对象，有一个属性 r1 用来保存结果，问，可能的结果有几种？</p><p>情况1：线程1 先执行，这时 ready = false，所以进入 else 分支结果为 1</p><p>情况2：线程2 先执行 num = 2，但没来得及执行 ready = true，线程1 执行，还是进入 else 分支，结果为1</p><p>情况3：线程2 执行到 ready = true，线程1 执行，这回进入 if 分支，结果为 4（因为 num 已经执行过了）</p><p>情况4:   线程2 执行 ready = true，切换到线程1，进入 if 分支，相加为 0，再切回线程2 执行 num = 2</p><p>这种现象叫做指令重排，是 JIT 编译器在运行时的一些优化，这个现象需要通过大量测试才能复现：<br>借助 java 并发压测工具 <code> jcstress</code>  <a href="https://wiki.openjdk.java.net/display/CodeTools/jcstress">https://wiki.openjdk.java.net/display/CodeTools/jcstress</a></p><pre><code class="hljs maven">mvn archetype:generate -DinteractiveMode&#x3D;false -DarchetypeGroupId&#x3D;org.openjdk.jcstress -DarchetypeArtifactId&#x3D;jcstress-java-test-archetype -DarchetypeVersion&#x3D;0.5 -DgroupId&#x3D;cn.itcast -DartifactId&#x3D;ordering -Dversion&#x3D;1.0</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210501120311.png"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210501120338.png"></p><p>解决方法<br>volatile 修饰的变量，可以禁用指令重排</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210501120541.png"></p><p>加在ready上，ready之前的代码有屏障，都会禁止重排序</p><h3 id="4-4-Volatile-原理"><a href="#4-4-Volatile-原理" class="headerlink" title="4.4 Volatile 原理"></a>4.4 Volatile 原理</h3><p>volatile 的底层实现原理是 <code>内存屏障</code> ，Memory Barrier（Memory Fence）</p><ol><li>对 volatile 变量的 <strong>写指令后</strong> 会加入 <code>写屏障</code></li><li>对 volatile 变量的 <strong>读指令前</strong> 会加入 <code>读屏障</code></li></ol><h4 id="1-如何保证可见性"><a href="#1-如何保证可见性" class="headerlink" title="1.如何保证可见性"></a>1.如何保证可见性</h4><ul><li><p>写屏障（sfence）保证在该屏障之 <strong>前</strong> 的，对共享变量的改动，都同步到主存当中</p></li><li><pre><code class="java">public void actor2(I_Result r) &#123;     num = 2;     ready = true; // ready是被volatile修饰的 ，赋值带写屏障(之后)     // 写屏障&#125;<pre><code class="hljs arduino">- 而读屏障（lfence）保证在该屏障之 **后** ，对共享变量的读取，加载的是主存中最新数据- ```java  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">actor1</span><span class="hljs-params">(I_Result r)</span> </span>&#123;     <span class="hljs-comment">// 读屏障</span>     <span class="hljs-comment">//  ready是被volatile修饰的 ，读取值带读屏障</span>     <span class="hljs-keyword">if</span>(<span class="hljs-built_in">ready</span>) &#123;      r.r1 = num + num;     &#125; <span class="hljs-keyword">else</span> &#123;      r.r1 = <span class="hljs-number">1</span>;     &#125;  &#125;</code></pre></code></pre></li></ul><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210502101434.png"></p><h4 id="2-如何保证有序性"><a href="#2-如何保证有序性" class="headerlink" title="2.如何保证有序性"></a>2.如何保证有序性</h4><ol><li><p>写屏障会确保指令重排序时， <strong>不会</strong> 将写屏障之前的代码 <strong>排在写屏障之后</strong> </p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">actor2</span><span class="hljs-params">(I_Result r)</span> </span>&#123;   num = <span class="hljs-number">2</span>;   ready = <span class="hljs-keyword">true</span>; <span class="hljs-comment">//  ready是被volatile修饰的 ， 赋值带写屏障</span>   <span class="hljs-comment">// 写屏障</span>&#125;</code></pre></li><li><p>读屏障会确保指令重排序时， <strong>不会</strong> 将读屏障之后的代码 <strong>排在读屏障之前</strong> </p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">actor1</span><span class="hljs-params">(I_Result r)</span> </span>&#123;   <span class="hljs-comment">// 读屏障</span>   <span class="hljs-comment">//  ready是被volatile修饰的 ，读取值带读屏障</span>   <span class="hljs-keyword">if</span>(ready) &#123;    r.r1 = num + num;   &#125; <span class="hljs-keyword">else</span> &#123;    r.r1 = <span class="hljs-number">1</span>;   &#125;&#125;</code></pre></li></ol><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210502101906.png"></p><p>不能解决指令交错：</p><ol><li>写屏障仅仅是保证之后的读能够读到最新的结果，但 <strong>不能保证其它线程的读跑到它前面去</strong> </li><li>而有序性的保证也只是保证了本线程内相关代码不被重排序</li></ol><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210502101933.png"></p><h4 id="3-double-checked-locking-问题"><a href="#3-double-checked-locking-问题" class="headerlink" title="3. double-checked locking 问题"></a>3. double-checked locking 问题</h4><p>以著名的 double-checked locking 单例模式为例，这是volatile最常使用的地方。</p><pre><code class="hljs java">    <span class="hljs-comment">//最开始的单例模式是这样的</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123; &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton INSTANCE = <span class="hljs-keyword">null</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// 单例要求：首次访问会同步，而之后的使用不用进入synchronized</span>    <span class="hljs-comment">// 这样性能很低</span>    <span class="hljs-keyword">synchronized</span>(Singleton.class) &#123;        <span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// t1</span>            INSTANCE = <span class="hljs-keyword">new</span> Singleton();        &#125;    &#125;        <span class="hljs-keyword">return</span> INSTANCE;    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-comment">//但是上面的代码块的效率是有问题的，因为即使已经产生了单实例之后，之后调用了getInstance()方法之后还是会加锁，这会严重影响性能！因此就有了模式如下double-checked lockin：</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123; &#125;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton INSTANCE = <span class="hljs-keyword">null</span>;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">if</span>(INSTANCE == <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// t2</span>                <span class="hljs-comment">// 首次访问会同步，而之后的使用没有 synchronized</span>                <span class="hljs-keyword">synchronized</span>(Singleton.class) &#123;                    <span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// t1</span>                        INSTANCE = <span class="hljs-keyword">new</span> Singleton();                    &#125;                &#125;            &#125;            <span class="hljs-keyword">return</span> INSTANCE;        &#125;    &#125;<span class="hljs-comment">//但是上面的if(INSTANCE == null)判断代码没有在同步代码块synchronized中，不能享有synchronized保证的原子性，可见性。所以不安全</span></code></pre><p>以上的实现特点是：</p><ol><li>懒惰实例化</li><li>首次使用 getInstance() 才使用 synchronized 加锁，后续使用时无需加锁</li><li>有隐含的，但很关键的一点： <strong>第一个 if 使用了 INSTANCE 变量</strong> ，是在同步块之外</li></ol><p>但在多线程环境下，上面的代码是有问题的，getInstance 方法对应的字节码为：</p><pre><code class="hljs ruby"><span class="hljs-number">0</span>: getstatic <span class="hljs-comment">#2 // Field INSTANCE:Lcn/itcast/n5/Singleton;</span>/<span class="hljs-regexp">/ 判断是否为null</span><span class="hljs-regexp">3: ifnonnull 37 </span><span class="hljs-regexp">/</span><span class="hljs-regexp">/ ldc是获得类对象</span><span class="hljs-regexp">6: ldc #3 /</span><span class="hljs-regexp">/ class cn/itcast</span><span class="hljs-regexp">/n5/</span>Singleton 加锁，获得类对象/<span class="hljs-regexp">/ 复制操作数栈栈顶的值放入栈顶, 将类对象的引用地址复制了一份，解锁用</span><span class="hljs-regexp">8: dup</span><span class="hljs-regexp">/</span><span class="hljs-regexp">/ 操作数栈栈顶的值弹出，即将对象的引用地址存到局部变量表中</span><span class="hljs-regexp">/</span><span class="hljs-regexp">/ 将类对象的引用地址存储了一份，是为了将来解锁用</span><span class="hljs-regexp">9: astore_0</span><span class="hljs-regexp">10: monitorenter</span><span class="hljs-regexp">11: getstatic #2 /</span><span class="hljs-regexp">/ Field INSTANCE:Lcn/itcast</span><span class="hljs-regexp">/n5/</span>Singleton;<span class="hljs-number">14</span>: ifnonnull <span class="hljs-number">27</span>/<span class="hljs-regexp">/ 新建一个实例</span><span class="hljs-regexp">17: new #3 /</span><span class="hljs-regexp">/ class cn/itcast</span><span class="hljs-regexp">/n5/</span>Singleton/<span class="hljs-regexp">/ 复制了一个实例的引用</span><span class="hljs-regexp">20: dup</span><span class="hljs-regexp">/</span><span class="hljs-regexp">/ 通过这个复制的引用调用它的构造方法</span><span class="hljs-regexp">21: invokespecial #4 /</span><span class="hljs-regexp">/ Method &quot;&lt;init&gt;&quot;:()V</span><span class="hljs-regexp">/</span><span class="hljs-regexp">/ 最开始的这个引用用来进行赋值操作</span><span class="hljs-regexp">24: putstatic #2 /</span><span class="hljs-regexp">/ Field INSTANCE:Lcn/itcast</span><span class="hljs-regexp">/n5/</span>Singleton;<span class="hljs-number">27</span>: aload_0<span class="hljs-number">28</span>: monitorexit<span class="hljs-number">29</span>: goto <span class="hljs-number">37</span><span class="hljs-number">32</span>: astore_1<span class="hljs-number">33</span>: aload_0<span class="hljs-number">34</span>: monitorexit<span class="hljs-number">35</span>: aload_1<span class="hljs-number">36</span>: athrow<span class="hljs-number">37</span>: getstatic <span class="hljs-comment">#2 // Field INSTANCE:Lcn/itcast/n5/Singleton;</span><span class="hljs-number">40</span>: areturn</code></pre><p>其中</p><ol><li>17 表示创建对象，将对象引用入栈 // new Singleton</li><li>20 表示复制一份对象引用 // 复制了引用地址</li><li>21 表示利用一个对象引用，调用构造方法 // 根据复制的引用地址调用构造方法</li><li>24 表示利用一个对象引用，赋值给 static INSTANCE</li></ol><p>应该先构造，再赋值；</p><p>(Synchronized不能阻止代码块内指令重排，如果共享变量完全被Synchronized保护，就算重排，也不会出现有序性问题)</p><p>也许 jvm 会优化为：先执行 24，再执行 21。即有赋值，但无构造；如果两个线程 t1，t2 按如下时间序列执行：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210502103827.png"></p><p>关键在于 <code>0: getstatic</code> 这行代码在 monitor 控制之外，它就像之前举例中不守规则的人，可以越过 monitor 读取 INSTANCE 变量的值 这时 t1 还 <strong>未完全将构造方法执行完毕</strong> ，如果在构造方法中要执行很多初始化操作，那么 t2 拿到的是将是一个 <strong>未初始化完毕的单例</strong>  对 INSTANCE 使用 volatile 修饰即可，可以禁用指令重排，但要注意在 JDK 5 以上的版本的 volatile 才会真正有效</p><h4 id="4-double-checked-locking-解决"><a href="#4-double-checked-locking-解决" class="headerlink" title="4.double-checked locking 解决"></a>4.double-checked locking 解决</h4><p>加volatile就行了</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123; &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Singleton INSTANCE = <span class="hljs-keyword">null</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 实例没创建，才会进入内部的 synchronized代码块</span>        <span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123; <span class="hljs-comment">// t2</span>                <span class="hljs-comment">// 也许有其它线程已经创建实例，所以再判断一次</span>                <span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// t1</span>                    INSTANCE = <span class="hljs-keyword">new</span> Singleton();                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> INSTANCE;    &#125;&#125;</code></pre><p>字节码上看不出来 volatile 指令的效果</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210502104652.png"></p><h4 id="5-happens-before"><a href="#5-happens-before" class="headerlink" title="5.happens-before"></a>5.happens-before</h4><p>happens-before 规定了 <code>对共享变量的写操作对其它线程的读操作可见</code> ，它是可见性与有序性的一套规则总结，抛开以下 happens-before 规则，JMM 并不能保证一个线程对共享变量的写，对于其它线程对该共享变量的读可见</p><ul><li>线程解锁 m 之前对变量的写，对于接下来对 m 加锁的其它线程对该变量的读可见</li></ul><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> x;<span class="hljs-keyword">static</span> Object m = <span class="hljs-keyword">new</span> Object();<span class="hljs-keyword">new</span> Thread(()-&gt;&#123;    <span class="hljs-keyword">synchronized</span>(m) &#123;        x = <span class="hljs-number">10</span>;    &#125;&#125;,<span class="hljs-string">&quot;t1&quot;</span>).start();<span class="hljs-keyword">new</span> Thread(()-&gt;&#123;    <span class="hljs-keyword">synchronized</span>(m) &#123;        System.out.println(x);    &#125;&#125;,<span class="hljs-string">&quot;t2&quot;</span>).start();</code></pre><ul><li><p>线程对 volatile 变量的写，对接下来其它线程对该变量的读可见</p><pre><code class="hljs java"><span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> x;<span class="hljs-keyword">new</span> Thread(()-&gt;&#123; x = <span class="hljs-number">10</span>;&#125;,<span class="hljs-string">&quot;t1&quot;</span>).start();<span class="hljs-keyword">new</span> Thread(()-&gt;&#123; System.out.println(x);&#125;,<span class="hljs-string">&quot;t2&quot;</span>).start();</code></pre></li><li><p>线程 start 前对变量的写，对该线程开始后对该变量的读可见</p><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> x;x = <span class="hljs-number">10</span>;<span class="hljs-keyword">new</span> Thread(()-&gt;&#123; System.out.println(x);&#125;,<span class="hljs-string">&quot;t2&quot;</span>).start();</code></pre></li><li><p>线程结束前对变量的写，对其它线程得知它结束后的读可见（比如其它线程调用 t1.isAlive() 或 t1.join()等待它结束）</p><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> x;Thread t1 = <span class="hljs-keyword">new</span> Thread(()-&gt;&#123; x = <span class="hljs-number">10</span>;&#125;,<span class="hljs-string">&quot;t1&quot;</span>);t1.start();t1.join();System.out.println(x);</code></pre></li><li><p>线程 t1 打断 t2（interrupt）前对变量的写，对于其他线程得知 t2 被打断后对变量的读可见（通过 t2.interrupted 或 t2.isInterrupted）</p><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> x;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Thread t2 = <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;            <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;                <span class="hljs-keyword">if</span>(Thread.currentThread().isInterrupted()) &#123;                    System.out.println(x);                    <span class="hljs-keyword">break</span>;                &#125;            &#125;        &#125;,<span class="hljs-string">&quot;t2&quot;</span>);        t2.start();        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;            sleep(<span class="hljs-number">1</span>);            x = <span class="hljs-number">10</span>;            t2.interrupt();        &#125;,<span class="hljs-string">&quot;t1&quot;</span>).start();        <span class="hljs-keyword">while</span>(!t2.isInterrupted()) &#123;            Thread.yield();        &#125;        System.out.println(x);    &#125;</code></pre></li><li><p>对变量默认值（0，false，null）的写，对其它线程对该变量的读可见</p></li><li><p>具有传递性，如果 x hb-&gt; y 并且 y hb-&gt; z 那么有 x hb-&gt; z ，配合 volatile 的防指令重排，有下面的例子</p><pre><code class="hljs java">        <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> x;<span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> y;<span class="hljs-keyword">new</span> Thread(()-&gt;&#123;     y = <span class="hljs-number">10</span>;     x = <span class="hljs-number">20</span>;&#125;,<span class="hljs-string">&quot;t1&quot;</span>).start();<span class="hljs-keyword">new</span> Thread(()-&gt;&#123;    <span class="hljs-comment">// x=20 对 t2 可见, 同时 y=10 也对 t2 可见</span>    System.out.println(x); &#125;,<span class="hljs-string">&quot;t2&quot;</span>).start();</code></pre></li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>volatile主要用在一个线程改多个线程读时的来保证可见性，和double-checked locking模式中保证synchronized代码块外的共享变量的重排序问题</p><h4 id="balking-模式习题"><a href="#balking-模式习题" class="headerlink" title="balking 模式习题"></a>balking 模式习题</h4><p>希望 doInit() 方法仅被调用一次，下面的实现是否有问题，为什么？</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestVolatile</span> </span>&#123;    <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> initialized = <span class="hljs-keyword">false</span>; <span class="hljs-comment">// 只能保证可见性，有读有写，不能保证原子性</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (initialized) &#123;<span class="hljs-comment">// t1, t2</span>            <span class="hljs-keyword">return</span>;        &#125;        doInit();<span class="hljs-comment">// t1 t2</span>        initialized = <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doInit</span><span class="hljs-params">()</span> </span>&#123;    &#125;&#125;</code></pre><h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><p>单例模式有很多实现方法，饿汉、懒汉、静态内部类、枚举类，试分析每种实现下获取单例对象（即调用 getInstance）时的 <code>线程安全</code> ，并思考注释中的问题 </p><p>饿汉式：类加载就会导致该单实例对象被创建 </p><p>懒汉式：类加载不会导致该单实例对象被创建，而是首次使用该对象时才会创建</p><p>实现1： 饿汉式</p><pre><code class="hljs java"><span class="hljs-comment">// 问题1：为什么加 final ---&gt;  防止子类继承后更改</span><span class="hljs-comment">// 问题2：如果实现了序列化接口, 还要做什么来防止反序列化破坏单例，如果进行反序列化的时候会生成新的对象，这样跟单例模式生成的对象是不同的。要解决直接加上readResolve()方法就行了，如下所示</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;    <span class="hljs-comment">// 问题3：为什么设置为私有? 放弃其它类中使用new生成新的实例，是否能防止反射创建新的实例?不能。</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;&#125;    <span class="hljs-comment">// 问题4：这样初始化是否能保证单例对象创建时的线程安全?没有安全问题，这是类变量，是jvm在静态成员变量就进行了初始化（类加载阶段完成），jvm保证了此操作的线程安全性</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton INSTANCE = <span class="hljs-keyword">new</span> Singleton();    <span class="hljs-comment">// 问题5：为什么提供静态方法而不是直接将 INSTANCE 设置为 public, 说出你知道的理由。</span>    <span class="hljs-comment">//1.提供更好的封装性；2.提供范型的支持</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> INSTANCE;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">readResolve</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> INSTANCE;    &#125;&#125;</code></pre><p>实现2： 饿汉式</p><pre><code class="hljs java"><span class="hljs-comment">// 问题1：枚举单例是如何限制实例个数的：创建枚举类的时候就已经定义好了，每个枚举常量其实就是枚举类的一个静态成员变量</span><span class="hljs-comment">// 问题2：枚举单例在创建时是否有并发问题：没有，这是静态成员变量</span><span class="hljs-comment">// 问题3：枚举单例能否被反射破坏单例：不能</span><span class="hljs-comment">// 问题4：枚举单例能否被反序列化破坏单例：枚举类默认实现了序列化接口，枚举类已经考虑到此问题，无需担心破坏单例</span><span class="hljs-comment">// 问题5：枚举单例属于懒汉式还是饿汉式：饿汉式</span><span class="hljs-comment">// 问题6：枚举单例如果希望加入一些单例创建时的初始化逻辑该如何做：加构造方法就行了</span><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Singleton</span> </span>&#123; INSTANCE;&#125;</code></pre><p>实现3：懒汉式</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123; &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton INSTANCE = <span class="hljs-keyword">null</span>;    <span class="hljs-comment">// 分析这里的线程安全, 并说明有什么缺点：synchronized加载静态方法上，可以保证线程安全。缺点就是锁的范围过大，每次都要加锁解锁</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span>( INSTANCE != <span class="hljs-keyword">null</span> )&#123;            <span class="hljs-keyword">return</span> INSTANCE;        &#125;        INSTANCE = <span class="hljs-keyword">new</span> Singleton();        <span class="hljs-keyword">return</span> INSTANCE;    &#125;&#125;</code></pre><p>实现4：DCL 懒汉式</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123; &#125;    <span class="hljs-comment">// 问题1：解释为什么要加 volatile ?为了防止重排序问题</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Singleton INSTANCE = <span class="hljs-keyword">null</span>;    <span class="hljs-comment">// 问题2：对比实现3, 说出这样做的意义：提高了效率</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (INSTANCE != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> INSTANCE;        &#125;        <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;            <span class="hljs-comment">// 问题3：为什么还要在这里加为空判断, 之前不是判断过了吗？这是为了第一次判断时的并发问题。</span>            <span class="hljs-keyword">if</span> (INSTANCE != <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// t2</span>                <span class="hljs-keyword">return</span> INSTANCE;            &#125;            INSTANCE = <span class="hljs-keyword">new</span> Singleton();            <span class="hljs-keyword">return</span> INSTANCE;        &#125;    &#125;&#125;</code></pre><p>实现5：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123; &#125;    <span class="hljs-comment">// 问题1：属于懒汉式还是饿汉式：懒汉式，这是一个静态内部类。类加载本身就是懒惰的，在没有调用getInstance方法时是没有执行LazyHolder内部类的类加载操作的。</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LazyHolder</span> </span>&#123;        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton INSTANCE = <span class="hljs-keyword">new</span> Singleton();    &#125;    <span class="hljs-comment">// 问题2：在创建时是否有并发问题，这是线程安全的，类加载时，jvm保证类加载操作的线程安全</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> LazyHolder.INSTANCE;    &#125;&#125;</code></pre><h2 id="5、共享模型之无锁"><a href="#5、共享模型之无锁" class="headerlink" title="5、共享模型之无锁"></a>5、共享模型之无锁</h2><ul><li>CAS 与 volatile</li><li>juc包下API<ol><li>原子整数</li><li>原子引用</li><li>原子数组</li><li>字段更新器</li><li>原子累加器</li></ol></li><li>Unsafe</li><li>原理方面<ol><li>LongAdder 源码</li><li>伪共享</li></ol></li></ul><p>管程即monitor是 <code>阻塞式的悲观锁</code> 实现并发控制，这章我们将通过 <code>非阻塞式的乐观锁</code> 的来实现并发控制</p><h3 id="5-1-问题提出"><a href="#5-1-问题提出" class="headerlink" title="5.1 问题提出"></a>5.1 问题提出</h3><p>有如下需求，保证account.withdraw取款方法的线程安全</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccountUnsafe</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Account</span> </span>&#123;    <span class="hljs-keyword">private</span> Integer balance;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AccountUnsafe</span><span class="hljs-params">(Integer balance)</span> </span>&#123;        <span class="hljs-keyword">this</span>.balance = balance;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getBalance</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.balance;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">withdraw</span><span class="hljs-params">(Integer amount)</span> </span>&#123;        <span class="hljs-keyword">this</span>.balance -= amount;    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Account</span> </span>&#123;    <span class="hljs-comment">// 获取余额</span>    <span class="hljs-function">Integer <span class="hljs-title">getBalance</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">// 取款</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">withdraw</span><span class="hljs-params">(Integer amount)</span></span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 方法内会启动 1000 个线程，每个线程做 -10 元 的操作</span><span class="hljs-comment">     * 如果初始余额为 10000 那么正确的结果应当是 0</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">demo</span><span class="hljs-params">(Account account)</span> </span>&#123;        List&lt;Thread&gt; ts = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;            ts.add(<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;                account.withdraw(<span class="hljs-number">10</span>);            &#125;));        &#125;        <span class="hljs-keyword">long</span> start = System.nanoTime();        ts.forEach(Thread::start);        ts.forEach(t -&gt; &#123;            <span class="hljs-keyword">try</span> &#123;                t.join();            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;);        <span class="hljs-keyword">long</span> end = System.nanoTime();        System.out.println(account.getBalance()                + <span class="hljs-string">&quot; cost: &quot;</span> + (end-start)/<span class="hljs-number">1000_000</span> + <span class="hljs-string">&quot; ms&quot;</span>);    &#125;&#125;</code></pre><p>上面是不安全的例子：</p><pre><code class="hljs ruby"><span class="hljs-number">50</span> <span class="hljs-symbol">cost:</span> <span class="hljs-number">89</span> ms</code></pre><p>解决：</p><pre><code class="hljs java"><span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getBalance</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.balance;        &#125;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">withdraw</span><span class="hljs-params">(Integer amount)</span> </span>&#123;        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>)&#123;            <span class="hljs-keyword">this</span>.balance -= amount;        &#125;    &#125;</code></pre><pre><code class="hljs ruby"><span class="hljs-number">0</span> <span class="hljs-symbol">cost:</span> <span class="hljs-number">79</span> ms</code></pre><blockquote><p>如果根本不加锁该如何实现？</p></blockquote><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccountCas</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Account</span> </span>&#123;    <span class="hljs-keyword">private</span> AtomicInteger balance;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AccountCas</span><span class="hljs-params">(<span class="hljs-keyword">int</span> balance)</span> </span>&#123;        <span class="hljs-keyword">this</span>.balance = <span class="hljs-keyword">new</span> AtomicInteger(balance);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getBalance</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> balance.get();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">withdraw</span><span class="hljs-params">(Integer amount)</span> </span>&#123;        <span class="hljs-comment">/*while(true) &#123;</span><span class="hljs-comment">            // 获取余额的最新值</span><span class="hljs-comment">            int prev = balance.get();</span><span class="hljs-comment">            // 要修改的余额</span><span class="hljs-comment">            int next = prev - amount;</span><span class="hljs-comment">            // 真正修改</span><span class="hljs-comment">            if(balance.compareAndSet(prev, next)) &#123;</span><span class="hljs-comment">                break;</span><span class="hljs-comment">            &#125;</span><span class="hljs-comment">        &#125;*/</span>        balance.getAndAdd(-<span class="hljs-number">1</span> * amount);    &#125;&#125;</code></pre><pre><code class="hljs ruby"><span class="hljs-number">0</span> <span class="hljs-symbol">cost:</span> <span class="hljs-number">64</span> ms</code></pre><h3 id="5-2-CAS-与-volatile"><a href="#5-2-CAS-与-volatile" class="headerlink" title="5.2 CAS 与 volatile"></a>5.2 CAS 与 volatile</h3><h4 id="1-CAS"><a href="#1-CAS" class="headerlink" title="(1) CAS"></a>(1) CAS</h4><p>前面看到的AtomicInteger的解决方法，内部并 <code>没有用锁</code> 来保护共享变量的线程安全。那么它是如何实现的呢？</p><pre><code class="hljs java"><span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">withdraw</span><span class="hljs-params">(Integer amount)</span> </span>&#123;        <span class="hljs-comment">// 核心代码</span>        <span class="hljs-comment">// 需要不断尝试，直到成功为止</span>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>)&#123;            <span class="hljs-comment">// 比如拿到了旧值 1000</span>            <span class="hljs-keyword">int</span> pre = getBalance();            <span class="hljs-comment">// 在这个基础上 1000-10 = 990</span>            <span class="hljs-keyword">int</span> next = pre - amount;            <span class="hljs-comment">// 比较并交换值</span>            <span class="hljs-comment">/* </span><span class="hljs-comment">             compareAndSet 正是做这个检查，在 set 前，先比较 prev 与当前值</span><span class="hljs-comment">             1. 不一致了，next 作废，返回 false 表示失败</span><span class="hljs-comment">             比如，别的线程已经做了减法，当前值已经被减成了 990</span><span class="hljs-comment">             那么本线程的这次 990 就作废了，进入 while 下次循环重试</span><span class="hljs-comment">             2. 一致，以 next 设置为新值，返回 true 表示成功</span><span class="hljs-comment">                        */</span>            <span class="hljs-keyword">if</span> (atomicInteger.compareAndSet(pre,next))&#123;                <span class="hljs-keyword">break</span>;            &#125;        &#125;    &#125;</code></pre><p>其中的关键是 compareAndSet，它的简称就是 CAS （也有 Compare And Swap 的说法），它必须是原子操作。</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210502113551.png"></p><p>它的工作流程如下：</p><ul><li><p>当一个线程要去修改 Account 对象中的值时，先获取值 preVal（调用get方法），然后再将其设置为新的值 nextVal（调用 cas 方法）。在调用 cas 方法时，会将 pre 与 Account 中的余额进行比较。</p><ul><li><p>如果两者相等，就说明该值还未被其他线程修改，此时便可以进行修改操作。</p></li><li><p>如果两者不相等，就不设置值，重新获取值 preVal（调用get方法），然后再将其设置为新的值 nextVal（调用cas方法），直到修改成功为止。</p><p>注意：</p></li></ul></li><li><p>其实 CAS 的底层是 <code> lock cmpxchg 指令（X86 架构）</code> ，在单核 CPU 和多核 CPU 下都能够保证【比较-交换】的原子性。</p></li><li><p>在多核状态下，某个核执行到带 lock 的指令时，CPU 会 <code>让总线锁住</code> ，当这个核把此指令执行完毕，再开启总线。这个过程中不会被线程的调度机制所打断，保证了多个线程对内存操作的准确性，是原子的 。</p></li></ul><h4 id="2-volatile"><a href="#2-volatile" class="headerlink" title="(2) volatile"></a>(2) volatile</h4><p>获取共享变量时，为了 <code>保证该变量的可见性</code> ，需要使用  <code>volatile </code> 修饰。<br>它可以用来修饰成员变量和静态成员变量，他可以 <code>避免线程从自己的工作缓存中查找变量的值</code> ，必须到主存中获取 它的值，线程操作 volatile 变量都是直接操作主存。即一个线程对 volatile 变量的修改，对另一个线程可见。</p><blockquote><p>注意<br>volatile 仅仅保证了共享变量的可见性，让其它线程能够看到新值，但不能解决指令交错问题（不能保证原子性）</p></blockquote><p>CAS 是原子性操作借助 volatile 读取到共享变量的新值来实现【比较并交换】的效果</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210502114525.png"></p><h4 id="3-为什么无锁效率高"><a href="#3-为什么无锁效率高" class="headerlink" title="(3) 为什么无锁效率高"></a>(3) 为什么无锁效率高</h4><ul><li>无锁情况下，即使重试失败，<code>线程始终在高速运行</code>，没有停歇，而 <code>synchronized</code> 会让线程在没有获得锁的时候，<code>发生上下文切换，进入阻塞</code>。打个比喻：线程就好像高速跑道上的赛车，高速运行时，速度超快，一旦发生上下文切换，就好比赛车要减速、熄火，等被唤醒又得重新打火、启动、加速… 恢复到高速运行，代价比较大</li><li>但<code>无锁情况</code>下，因为线程要保持运行，需要额外 CPU 的支持，CPU 在这里就好比高速跑道，没有额外的跑道，线程想高速运行也无从谈起，虽然不会进入阻塞，但由于没有分到时间片，仍然会进入可运行状态，<code>还是会导致上下文切换</code>。</li></ul><h4 id="4-CAS-的特点"><a href="#4-CAS-的特点" class="headerlink" title="(4) CAS 的特点"></a>(4) CAS 的特点</h4><p>结合 CAS 和 volatile 可以实现 <code>无锁并发</code> ，适用于 <code>线程数少、多核 CPU </code> 的场景下。</p><ol><li>CAS 是基于 <code>乐观锁</code> 的思想：最乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，我吃亏点再重试呗。</li><li>synchronized 是基于 <code>悲观锁</code> 的思想：最悲观的估计，得防着其它线程来修改共享变量，我上了锁你们都别想改，我改完了解开锁，你们才有机会。</li><li>CAS 体现的是无锁并发、无阻塞并发，请仔细体会这两句话的意思<ol><li>因为没有使用 synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一</li><li>但如果竞争激烈(写操作多)，可以想到重试必然频繁发生，反而效率会受影响</li></ol></li></ol><h3 id="5-3-原子整数"><a href="#5-3-原子整数" class="headerlink" title="5.3 原子整数"></a>5.3 原子整数</h3><p>java.util.concurrent.atomic并发包提供了一些并发工具类，这里把它分成五类：</p><ol><li><p>使用原子的方式更新基本类型</p><ul><li>AtomicInteger：整型原子类</li><li>AtomicLong：长整型原子类</li><li>AtomicBoolean ：布尔型原子类</li></ul><p>上面三个类提供的方法几乎相同，所以我们将以 AtomicInteger 为例子来介绍。</p></li><li><p>原子引用</p></li><li><p>原子数组</p></li><li><p>字段更新器</p></li><li><p>原子累加器</p></li></ol><h4 id="1-原子整数"><a href="#1-原子整数" class="headerlink" title="1. 原子整数"></a>1. 原子整数</h4><p>以 AtomicInteger 为例讨论它的api接口：通过观察源码可以发现，AtomicInteger 内部都是通过cas的原理来实现的</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        AtomicInteger i = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">0</span>);        <span class="hljs-comment">// 获取并自增（i = 0, 结果 i = 1, 返回 0），类似于 i++</span>        System.out.println(i.getAndIncrement());        <span class="hljs-comment">// 自增并获取（i = 1, 结果 i = 2, 返回 2），类似于 ++i</span>        System.out.println(i.incrementAndGet());        <span class="hljs-comment">// 自减并获取（i = 2, 结果 i = 1, 返回 1），类似于 --i</span>        System.out.println(i.decrementAndGet());        <span class="hljs-comment">// 获取并自减（i = 1, 结果 i = 0, 返回 1），类似于 i--</span>        System.out.println(i.getAndDecrement());        <span class="hljs-comment">// 获取并加值（i = 0, 结果 i = 5, 返回 0）</span>        System.out.println(i.getAndAdd(<span class="hljs-number">5</span>));        <span class="hljs-comment">// 加值并获取（i = 5, 结果 i = 0, 返回 0）</span>        System.out.println(i.addAndGet(-<span class="hljs-number">5</span>));        <span class="hljs-comment">// 获取并更新（i = 0, p 为 i 的当前值, 结果 i = -2, 返回 0）</span>          <span class="hljs-comment">// 函数式编程接口，其中函数中的操作能保证原子，但函数需要无副作用</span>        System.out.println(i.getAndUpdate(p -&gt; p - <span class="hljs-number">2</span>));        <span class="hljs-comment">// 更新并获取（i = -2, p 为 i 的当前值, 结果 i = 0, 返回 0）</span>          <span class="hljs-comment">// 函数式编程接口，其中函数中的操作能保证原子，但函数需要无副作用</span>        System.out.println(i.updateAndGet(p -&gt; p + <span class="hljs-number">2</span>));          <span class="hljs-comment">// 获取并计算（i = 0, p 为 i 的当前值, x 为参数1, 结果 i = 10, 返回 0）</span>        <span class="hljs-comment">// 函数式编程接口，其中函数中的操作能保证原子，但函数需要无副作用</span>        <span class="hljs-comment">// getAndUpdate 如果在 lambda 中引用了外部的局部变量，要保证该局部变量是 final 的</span>        <span class="hljs-comment">// getAndAccumulate 可以通过 参数1 来引用外部的局部变量，但因为其不在 lambda 中因此不必是 final</span>        System.out.println(i.getAndAccumulate(<span class="hljs-number">10</span>, (p, x) -&gt; p + x));        <span class="hljs-comment">// 计算并获取（i = 10, p 为 i 的当前值, x 为参数1值, 结果 i = 0, 返回 0）</span>        <span class="hljs-comment">// 函数式编程接口，其中函数中的操作能保证原子，但函数需要无副作用</span>        System.out.println(i.accumulateAndGet(-<span class="hljs-number">10</span>, (p, x) -&gt; p + x));    &#125;</code></pre><p>底层：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">updateAndGet</span><span class="hljs-params">(AtomicInteger i, IntUnaryOperator operator)</span> </span>&#123;    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;        <span class="hljs-keyword">int</span> prev = i.get();        <span class="hljs-keyword">int</span> next = operator.applyAsInt(prev);        <span class="hljs-keyword">if</span> (i.compareAndSet(prev, next)) &#123;            <span class="hljs-keyword">return</span> next;        &#125;    &#125;&#125;</code></pre><h4 id="2-原子引用"><a href="#2-原子引用" class="headerlink" title="2. 原子引用"></a>2. 原子引用</h4><p>为什么需要原子引用类型？ <code>保证引用类型的共享变量是线程安全的（确保这个原子引用没有引用过别人）</code>。</p><p>基本类型原子类只能更新一个变量，如果需要原子 <code>更新多个变量</code> ，需要使用引用类型原子类。</p><ul><li>AtomicReference：引用类型原子类</li><li>AtomicStampedReference：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。</li><li>AtomicMarkableReference ：原子更新带有标记的引用类型。该类将 boolean 标记与引用关联起来，<del>也可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。</del></li></ul><h5 id="原子引用测试"><a href="#原子引用测试" class="headerlink" title="原子引用测试"></a>原子引用测试</h5><p>使用锁：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210502140543.png"></p><p>使用原子引用实现BigDecimal存取款的线程安全：</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DecimalAccountCas</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">DecimalAccount</span> </span>&#123;    <span class="hljs-keyword">private</span> AtomicReference&lt;BigDecimal&gt; balance;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DecimalAccountCas</span><span class="hljs-params">(BigDecimal balance)</span> </span>&#123;<span class="hljs-comment">//        this.balance = balance;</span>        <span class="hljs-keyword">this</span>.balance = <span class="hljs-keyword">new</span> AtomicReference&lt;&gt;(balance);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title">getBalance</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> balance.get();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">withdraw</span><span class="hljs-params">(BigDecimal amount)</span> </span>&#123;        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;            BigDecimal prev = balance.get();            BigDecimal next = prev.subtract(amount);            <span class="hljs-keyword">if</span> (balance.compareAndSet(prev, next)) &#123;                <span class="hljs-keyword">break</span>;            &#125;        &#125;    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">DecimalAccount</span> </span>&#123;    <span class="hljs-comment">// 获取余额</span>    <span class="hljs-function">BigDecimal <span class="hljs-title">getBalance</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">// 取款</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">withdraw</span><span class="hljs-params">(BigDecimal amount)</span></span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 方法内会启动 1000 个线程，每个线程做 -10 元 的操作</span><span class="hljs-comment">     * 如果初始余额为 10000 那么正确的结果应当是 0</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">demo</span><span class="hljs-params">(DecimalAccount account)</span> </span>&#123;        List&lt;Thread&gt; ts = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;            ts.add(<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;                account.withdraw(BigDecimal.TEN);            &#125;));        &#125;        ts.forEach(Thread::start);        ts.forEach(t -&gt; &#123;            <span class="hljs-keyword">try</span> &#123;                t.join();            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;);        System.out.println(account.getBalance());    &#125;&#125;</code></pre><h5 id="ABA-问题及解决"><a href="#ABA-问题及解决" class="headerlink" title="ABA 问题及解决"></a>ABA 问题及解决</h5><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210502135601.png"></p><p>修改中间的1s内可以做很多事情，A改为别的，再改回A；</p><pre><code class="hljs java"><span class="hljs-keyword">static</span> AtomicReference&lt;String&gt; ref = <span class="hljs-keyword">new</span> AtomicReference&lt;&gt;(<span class="hljs-string">&quot;A&quot;</span>);   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;       log.debug(<span class="hljs-string">&quot;main start...&quot;</span>);       <span class="hljs-comment">// 获取值 A</span>       <span class="hljs-comment">// 这个共享变量被它线程修改</span>       String prev = ref.get();       other();       utils.sleep(<span class="hljs-number">1</span>);       <span class="hljs-comment">// 尝试改为 C</span>       log.debug(<span class="hljs-string">&quot;change A-&gt;C &#123;&#125;&quot;</span>, ref.compareAndSet(prev, <span class="hljs-string">&quot;C&quot;</span>));   &#125;   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">other</span><span class="hljs-params">()</span> </span>&#123;       <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;           log.debug(<span class="hljs-string">&quot;change A-&gt;B &#123;&#125;&quot;</span>, ref.compareAndSet(ref.get(), <span class="hljs-string">&quot;B&quot;</span>));       &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();       utils.sleep(<span class="hljs-number">1</span>);       <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;           <span class="hljs-comment">// 注意：如果这里使用  log.debug(&quot;change B-&gt;A &#123;&#125;&quot;, ref.compareAndSet(ref.get(), new String(&quot;A&quot;)));</span>           <span class="hljs-comment">// 那么此实验中的 log.debug(&quot;change A-&gt;C &#123;&#125;&quot;, ref.compareAndSet(prev, &quot;C&quot;));</span>           <span class="hljs-comment">// 打印的就是false， 因为new String(&quot;A&quot;) 返回的对象的引用和&quot;A&quot;返回的对象的引用是不同的！</span>           log.debug(<span class="hljs-string">&quot;change B-&gt;A &#123;&#125;&quot;</span>, ref.compareAndSet(ref.get(), <span class="hljs-string">&quot;A&quot;</span>));       &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();   &#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210502135746.png"></p><p>主线程仅能判断出共享变量的值与最初值 A 是否相同，不能感知到这种从 A 改为 B 又改回 A 的情况，如果主线程希望：只要有其它线程【动过了】共享变量，那么自己的 cas 就算失败，这时，仅比较值是不够的，需要再加一个 <code>版本号</code> 。使用 <code>AtomicStampedReference</code> 来解决。</p><h5 id="AtomicStampedReference"><a href="#AtomicStampedReference" class="headerlink" title="AtomicStampedReference"></a>AtomicStampedReference</h5><pre><code class="hljs java"><span class="hljs-keyword">static</span> AtomicStampedReference&lt;String&gt; ref = <span class="hljs-keyword">new</span> AtomicStampedReference&lt;&gt;(<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-number">0</span>);    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        log.debug(<span class="hljs-string">&quot;main start...&quot;</span>);        <span class="hljs-comment">// 获取值 A</span>        <span class="hljs-keyword">int</span> stamp = ref.getStamp();        log.info(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,stamp);        String prev = ref.getReference();        other();        utils.sleep(<span class="hljs-number">1</span>);        <span class="hljs-comment">// 尝试改为 C</span>        log.debug(<span class="hljs-string">&quot;change A-&gt;C &#123;&#125;&quot;</span>, ref.compareAndSet(prev, <span class="hljs-string">&quot;C&quot;</span>,stamp,stamp+<span class="hljs-number">1</span>));    &#125;        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">other</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            <span class="hljs-keyword">int</span> stamp = ref.getStamp();            log.info(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,stamp);            log.debug(<span class="hljs-string">&quot;change A-&gt;B &#123;&#125;&quot;</span>, ref.compareAndSet(ref.getReference(), <span class="hljs-string">&quot;B&quot;</span>,stamp,stamp+<span class="hljs-number">1</span>));        &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();        utils.sleep(<span class="hljs-number">1</span>);        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            <span class="hljs-keyword">int</span> stamp = ref.getStamp();            log.info(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,stamp);            log.debug(<span class="hljs-string">&quot;change B-&gt;A &#123;&#125;&quot;</span>, ref.compareAndSet(ref.getReference(), <span class="hljs-string">&quot;A&quot;</span>,stamp,stamp+<span class="hljs-number">1</span>));        &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();    &#125;</code></pre><pre><code class="hljs ruby"><span class="hljs-number">14</span><span class="hljs-symbol">:</span><span class="hljs-number">01</span><span class="hljs-symbol">:</span><span class="hljs-number">03</span> [main] c.Test36 - main start...<span class="hljs-number">14</span><span class="hljs-symbol">:</span><span class="hljs-number">01</span><span class="hljs-symbol">:</span><span class="hljs-number">03</span> [main] c.Test36 - 版本 <span class="hljs-number">0</span><span class="hljs-number">14</span><span class="hljs-symbol">:</span><span class="hljs-number">01</span><span class="hljs-symbol">:</span><span class="hljs-number">03</span> [t1] c.Test36 - change A-&gt;B <span class="hljs-literal">true</span><span class="hljs-number">14</span><span class="hljs-symbol">:</span><span class="hljs-number">01</span><span class="hljs-symbol">:</span><span class="hljs-number">03</span> [t1] c.Test36 - 更新版本为 <span class="hljs-number">1</span><span class="hljs-number">14</span><span class="hljs-symbol">:</span><span class="hljs-number">01</span><span class="hljs-symbol">:</span><span class="hljs-number">04</span> [t2] c.Test36 - change B-&gt;A <span class="hljs-literal">true</span><span class="hljs-number">14</span><span class="hljs-symbol">:</span><span class="hljs-number">01</span><span class="hljs-symbol">:</span><span class="hljs-number">04</span> [t2] c.Test36 - 更新版本为 <span class="hljs-number">2</span><span class="hljs-number">14</span><span class="hljs-symbol">:</span><span class="hljs-number">01</span><span class="hljs-symbol">:</span><span class="hljs-number">05</span> [main] c.Test36 - change A-&gt;C <span class="hljs-literal">false</span></code></pre><h5 id="AtomicMarkableReference"><a href="#AtomicMarkableReference" class="headerlink" title="AtomicMarkableReference"></a>AtomicMarkableReference</h5><p><code>AtomicStampedReference</code> 可以给原子引用加上 <code>版本号</code>，追踪原子引用整个的变化过程，如：A -&gt; B -&gt; A -&gt;C，通过AtomicStampedReference，我们可以知道，引用变量中途被更改了几次。但是有时候，并不关心引用变量更改了几次，只是<code>单纯的关心是否更改过，所以就有了AtomicMarkableReference</code></p><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Test38&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test38</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        GarbageBag bag = <span class="hljs-keyword">new</span> GarbageBag(<span class="hljs-string">&quot;装满了垃圾&quot;</span>);        <span class="hljs-comment">// 参数2 mark 可以看作一个标记，表示垃圾袋满了</span>        AtomicMarkableReference&lt;GarbageBag&gt; ref = <span class="hljs-keyword">new</span> AtomicMarkableReference&lt;&gt;(bag, <span class="hljs-keyword">true</span>);        log.debug(<span class="hljs-string">&quot;start...&quot;</span>);        GarbageBag prev = ref.getReference();        log.debug(prev.toString());        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            log.debug(<span class="hljs-string">&quot;start...&quot;</span>);            bag.setDesc(<span class="hljs-string">&quot;空垃圾袋&quot;</span>);            ref.compareAndSet(bag, bag, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>);            log.debug(bag.toString());        &#125;,<span class="hljs-string">&quot;保洁阿姨&quot;</span>).start();        Sleeper.sleep(<span class="hljs-number">1</span>);        log.debug(<span class="hljs-string">&quot;想换一只新垃圾袋？&quot;</span>);        <span class="hljs-keyword">boolean</span> success = ref.compareAndSet(prev, <span class="hljs-keyword">new</span> GarbageBag(<span class="hljs-string">&quot;空垃圾袋&quot;</span>), <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>);        log.debug(<span class="hljs-string">&quot;换了么？&quot;</span> + success);        log.debug(ref.getReference().toString());    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GarbageBag</span> </span>&#123;    String desc;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GarbageBag</span><span class="hljs-params">(String desc)</span> </span>&#123;        <span class="hljs-keyword">this</span>.desc = desc;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setDesc</span><span class="hljs-params">(String desc)</span> </span>&#123;        <span class="hljs-keyword">this</span>.desc = desc;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.toString() + <span class="hljs-string">&quot; &quot;</span> + desc;    &#125;&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210502141536.png"></p><h4 id="3-原子数组"><a href="#3-原子数组" class="headerlink" title="3. 原子数组"></a>3. 原子数组</h4><p>使用原子的方式更新数组里的某个元素</p><ul><li>AtomicIntegerArray：整形数组原子类</li><li>AtomicLongArray：长整形数组原子类</li><li>AtomicReferenceArray ：引用类型数组原子类</li></ul><p>上面三个类提供的方法几乎相同，所以我们这里以 AtomicIntegerArray 为例子来介绍。实例代码：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test39</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        demo(                ()-&gt;<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>],                (array)-&gt;array.length,                (array, index) -&gt; array[index]++,                array-&gt; System.out.println(Arrays.toString(array))        );    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     参数1，提供数组、可以是线程不安全数组或线程安全数组</span><span class="hljs-comment">     参数2，获取数组长度的方法</span><span class="hljs-comment">     参数3，自增方法，回传 array, index</span><span class="hljs-comment">     参数4，打印数组的方法</span><span class="hljs-comment">     */</span>    <span class="hljs-comment">// supplier 提供者 无中生有  ()-&gt;结果</span>    <span class="hljs-comment">// function 函数   一个参数一个结果   (参数)-&gt;结果  ,  BiFunction (参数1,参数2)-&gt;结果</span>    <span class="hljs-comment">// consumer 消费者 一个参数没结果  (参数)-&gt;void,      BiConsumer (参数1,参数2)-&gt;</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">demo</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">            Supplier&lt;T&gt; arraySupplier,</span></span><span class="hljs-function"><span class="hljs-params">            Function&lt;T, Integer&gt; lengthFun,</span></span><span class="hljs-function"><span class="hljs-params">            BiConsumer&lt;T, Integer&gt; putConsumer,</span></span><span class="hljs-function"><span class="hljs-params">            Consumer&lt;T&gt; printConsumer )</span> </span>&#123;        List&lt;Thread&gt; ts = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        T array = arraySupplier.get();        <span class="hljs-keyword">int</span> length = lengthFun.apply(array);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;            <span class="hljs-comment">// 每个线程对数组作 10000 次操作</span>            ts.add(<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10000</span>; j++) &#123;                    putConsumer.accept(array, j%length);                &#125;            &#125;));        &#125;        ts.forEach(t -&gt; t.start()); <span class="hljs-comment">// 启动所有线程</span>        ts.forEach(t -&gt; &#123;            <span class="hljs-keyword">try</span> &#123;                t.join();            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;);     <span class="hljs-comment">// 等所有线程结束</span>        printConsumer.accept(array);    &#125;&#125;</code></pre><p>我们将使用函数式编程来实现，先看看一些函数式编程的接口的javadoc文档</p><pre><code class="hljs ruby">Represents a supplier of results.表示supplier的结果。There is no requirement that a new <span class="hljs-keyword">or</span> distinct result be returned each time the supplier is invoked.不要求每次调用供应商时都返回一个新的或不同的结果。This is a functional interface whose functional method is get().这是一个函数接口，其函数方法是get（）。public interface Supplier&lt;T&gt; &#123;    /**     * Gets a result.     * <span class="hljs-variable">@return</span> a result     *<span class="hljs-regexp">/</span><span class="hljs-regexp">    T get();</span><span class="hljs-regexp">&#125;</span><span class="hljs-regexp"></span><span class="hljs-regexp">Represents a function that accepts one argument and produces a result.</span><span class="hljs-regexp">表示接受一个参数并生成结果的函数。</span><span class="hljs-regexp">This is a functional interface whose functional method is apply(Object).</span><span class="hljs-regexp">这是一个函数接口，其函数方法是apply（Object）。</span><span class="hljs-regexp">public interface Function&lt;T, R&gt; &#123;</span><span class="hljs-regexp">/</span>*** Applies this function to the given argument.* <span class="hljs-variable">@param</span> t the function argument* <span class="hljs-variable">@return</span> the function result*<span class="hljs-regexp">/  </span><span class="hljs-regexp">  R apply(T t);</span><span class="hljs-regexp">  /</span><span class="hljs-regexp">/....</span><span class="hljs-regexp">  &#125;</span><span class="hljs-regexp">  </span><span class="hljs-regexp">  Represents an operation that accepts two input arguments and returns no result. This is the two-arity specialization of Consumer. Unlike most other functional interfaces, BiConsumer is expected to operate via side-effects.</span><span class="hljs-regexp">表示接受两个输入参数且不返回结果的操作。这就是Consumer的二元参数版本。与大多数其他功能性接口不同，BiConsumer期望执行带有副作用的操作。</span><span class="hljs-regexp">This is a functional interface whose functional method is accept(Object, Object).</span><span class="hljs-regexp">这是一个函数接口，其函数方法是accept（Object，Object）。</span><span class="hljs-regexp">public interface BiConsumer&lt;T, U&gt; &#123;</span><span class="hljs-regexp">   void accept(T t, U u);</span><span class="hljs-regexp">     /</span><span class="hljs-regexp">/....</span><span class="hljs-regexp">  &#125;</span><span class="hljs-regexp"></span><span class="hljs-regexp"></span><span class="hljs-regexp"></span><span class="hljs-regexp">Represents an operation that accepts a single input argument and returns no result. Unlike most other functional interfaces, Consumer is expected to operate via side-effects.</span><span class="hljs-regexp">表示接受单个输入参数但不返回结果的操作。与大多数其他功能接口不同，消费者期望执行带有副作用的操作。 </span><span class="hljs-regexp">public interface Consumer&lt;T&gt; &#123;</span><span class="hljs-regexp">void accept(T t);</span><span class="hljs-regexp">   /</span><span class="hljs-regexp">/....</span><span class="hljs-regexp">  &#125;</span></code></pre><p>普通数组结果：</p><p>[8824, 8801, 8810, 8817, 8858, 8801, 8818, 8826, 8823, 8818]</p><p>换成原子数组：</p><pre><code class="hljs java">demo(        ()-&gt; <span class="hljs-keyword">new</span> AtomicIntegerArray(<span class="hljs-number">10</span>),        (array) -&gt; array.length(),        (array, index) -&gt; array.getAndIncrement(index),        array -&gt; System.out.println(array));</code></pre><p>[10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000]</p><h4 id="4-字段更新器"><a href="#4-字段更新器" class="headerlink" title="4. 字段更新器"></a>4. 字段更新器</h4><ul><li><p>AtomicReferenceFieldUpdater // 域 字段</p></li><li><p>AtomicIntegerFieldUpdater</p></li><li><p>AtomicLongFieldUpdater</p><p>注意：利用字段更新器，可以针对对象的某个域（Field）进行原子操作，<code>只能配合 volatile 修饰的字段使用</code>，否则会出现异常</p></li></ul><pre><code class="hljs js">Exception <span class="hljs-keyword">in</span> thread <span class="hljs-string">&quot;main&quot;</span> java.lang.IllegalArgumentException: Must be volatile type</code></pre><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Test40&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test40</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Student stu = <span class="hljs-keyword">new</span> Student();        AtomicReferenceFieldUpdater updater =                AtomicReferenceFieldUpdater.newUpdater(Student.class, String.class, <span class="hljs-string">&quot;name&quot;</span>);        System.out.println(updater.compareAndSet(stu, <span class="hljs-keyword">null</span>, <span class="hljs-string">&quot;张三&quot;</span>));        System.out.println(stu);    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;    <span class="hljs-keyword">volatile</span> String name;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Student&#123;&quot;</span> +                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +                <span class="hljs-string">&#x27;&#125;&#x27;</span>;    &#125;&#125;</code></pre><h4 id="5-原子累加器"><a href="#5-原子累加器" class="headerlink" title="5. 原子累加器"></a>5. 原子累加器</h4><p>  <strong>累加器性能比较</strong> </p><p>LongAdder累加器的使用</p><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicLong;<span class="hljs-keyword">import</span> java.util.concurrent.atomic.LongAdder;<span class="hljs-keyword">import</span> java.util.function.Consumer;<span class="hljs-keyword">import</span> java.util.function.Supplier;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test41</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;            demo(                    () -&gt; <span class="hljs-keyword">new</span> AtomicLong(<span class="hljs-number">0</span>),                    (adder) -&gt; adder.getAndIncrement()            );        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;            demo(                    () -&gt; <span class="hljs-keyword">new</span> LongAdder(),                    adder -&gt; adder.increment()            );        &#125;    &#125;    <span class="hljs-comment">/*</span><span class="hljs-comment">    () -&gt; 结果    提供累加器对象</span><span class="hljs-comment">    (参数) -&gt;     执行累加操作</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">demo</span><span class="hljs-params">(Supplier&lt;T&gt; adderSupplier, Consumer&lt;T&gt; action)</span> </span>&#123;        T adder = adderSupplier.get();        List&lt;Thread&gt; ts = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-comment">// 4 个线程，每人累加 50 万</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;            ts.add(<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">500000</span>; j++) &#123;                    action.accept(adder);                &#125;            &#125;));        &#125;        <span class="hljs-keyword">long</span> start = System.nanoTime();        ts.forEach(t -&gt; t.start());        ts.forEach(t -&gt; &#123;            <span class="hljs-keyword">try</span> &#123;                t.join();            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;);        <span class="hljs-keyword">long</span> end = System.nanoTime();        System.out.println(adder + <span class="hljs-string">&quot; cost:&quot;</span> + (end - start) / <span class="hljs-number">1000_000</span>);    &#125;&#125;</code></pre><pre><code class="hljs ruby"><span class="hljs-number">2000000</span> <span class="hljs-symbol">cost:</span><span class="hljs-number">39</span><span class="hljs-number">2000000</span> <span class="hljs-symbol">cost:</span><span class="hljs-number">46</span><span class="hljs-number">2000000</span> <span class="hljs-symbol">cost:</span><span class="hljs-number">38</span><span class="hljs-number">2000000</span> <span class="hljs-symbol">cost:</span><span class="hljs-number">36</span><span class="hljs-number">2000000</span> <span class="hljs-symbol">cost:</span><span class="hljs-number">40</span><span class="hljs-number">2000000</span> <span class="hljs-symbol">cost:</span><span class="hljs-number">13</span><span class="hljs-number">2000000</span> <span class="hljs-symbol">cost:</span><span class="hljs-number">6</span><span class="hljs-number">2000000</span> <span class="hljs-symbol">cost:</span><span class="hljs-number">7</span><span class="hljs-number">2000000</span> <span class="hljs-symbol">cost:</span><span class="hljs-number">5</span><span class="hljs-number">2000000</span> <span class="hljs-symbol">cost:</span><span class="hljs-number">6</span></code></pre><p>性能提升的原因很简单，就是在有竞争时，设置多个 <code>累加单元</code> (但不会超过cpu的核心数)，Therad-0 累加 Cell[0]，而 Thread-1 累加Cell[1]… 最后将结果汇总。这样它们在累加时操作的不同的 Cell 变量，因此减少了 CAS 重试失败，从而提高性能。</p><h5 id="5-1-源码之LongAdder"><a href="#5-1-源码之LongAdder" class="headerlink" title="5.1 源码之LongAdder"></a>5.1 源码之LongAdder</h5><p>LongAdder 是并发大师 @author Doug Lea （大哥李）的作品，设计的非常精巧<br>LongAdder 类有几个关键域</p><pre><code class="hljs java"><span class="hljs-comment">// 累加单元数组, 懒惰初始化，减少重试，提高性能</span><span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Cell[] cells;<span class="hljs-comment">// 基础值, 如果没有竞争, 则用 cas 累加这个域</span><span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">long</span> base;<span class="hljs-comment">// 在 cells 创建或扩容时, 置为 1, 表示加锁</span><span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> cellsBusy;<span class="hljs-comment">// transient序列化时，不会把这些信息序列化</span></code></pre><h6 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h6><pre><code class="hljs java"><span class="hljs-comment">// 0 没加锁</span><span class="hljs-comment">// 1 加锁</span><span class="hljs-comment">// cellsbusy就类似于state</span><span class="hljs-keyword">private</span> AtomicInteger state = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">0</span>);<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;        <span class="hljs-keyword">if</span> (state.compareAndSet(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;            <span class="hljs-keyword">break</span>;        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span> </span>&#123;    log.debug(<span class="hljs-string">&quot;unlock...&quot;</span>);    state.set(<span class="hljs-number">0</span>);&#125;</code></pre><p>不要用于生产实践，cpu会空运转。</p><p>写两个线程测试：</p><pre><code class="hljs java">LockCas lock = <span class="hljs-keyword">new</span> LockCas();<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;    log.debug(<span class="hljs-string">&quot;begin...&quot;</span>);    lock.lock();    <span class="hljs-keyword">try</span> &#123;        log.debug(<span class="hljs-string">&quot;lock...&quot;</span>);        Sleeper.sleep(<span class="hljs-number">1</span>);    &#125; <span class="hljs-keyword">finally</span> &#123;        lock.unlock();    &#125;&#125;).start();<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;    log.debug(<span class="hljs-string">&quot;begin...&quot;</span>);    lock.lock();    <span class="hljs-keyword">try</span> &#123;        log.debug(<span class="hljs-string">&quot;lock...&quot;</span>);    &#125; <span class="hljs-keyword">finally</span> &#123;        lock.unlock();    &#125;&#125;).start();</code></pre><pre><code class="hljs ruby">09<span class="hljs-symbol">:</span><span class="hljs-number">38</span><span class="hljs-symbol">:</span><span class="hljs-number">07</span> [Thread-<span class="hljs-number">0</span>] c.Test42 - <span class="hljs-keyword">begin</span>...09<span class="hljs-symbol">:</span><span class="hljs-number">38</span><span class="hljs-symbol">:</span><span class="hljs-number">07</span> [Thread-<span class="hljs-number">0</span>] c.Test42 - lock...09<span class="hljs-symbol">:</span><span class="hljs-number">38</span><span class="hljs-symbol">:</span><span class="hljs-number">07</span> [Thread-<span class="hljs-number">1</span>] c.Test42 - <span class="hljs-keyword">begin</span>...09<span class="hljs-symbol">:</span><span class="hljs-number">38</span><span class="hljs-symbol">:</span>08 [Thread-<span class="hljs-number">0</span>] c.Test42 - unlock...09<span class="hljs-symbol">:</span><span class="hljs-number">38</span><span class="hljs-symbol">:</span>08 [Thread-<span class="hljs-number">1</span>] c.Test42 - lock...09<span class="hljs-symbol">:</span><span class="hljs-number">38</span><span class="hljs-symbol">:</span>08 [Thread-<span class="hljs-number">1</span>] c.Test42 - unlock...</code></pre><h6 id="原理之伪共享"><a href="#原理之伪共享" class="headerlink" title="原理之伪共享"></a>原理之伪共享</h6><p>其中 Cell类 即为累加单元</p><pre><code class="hljs java"><span class="hljs-comment">// 防止缓存行伪共享</span><span class="hljs-comment">// 伪共享就是一个缓存行存储多个cell对象</span><span class="hljs-meta">@sun</span>.misc.Contended<span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cell</span> </span>&#123;    <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">long</span> value;    Cell(<span class="hljs-keyword">long</span> x) &#123; value = x; &#125;    <span class="hljs-comment">// 最重要的方法, 用来 cas 方式进行累加, prev 表示旧值, next 表示新值</span>    <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">cas</span><span class="hljs-params">(<span class="hljs-keyword">long</span> prev, <span class="hljs-keyword">long</span> next)</span> </span>&#123;        <span class="hljs-keyword">return</span> UNSAFE.compareAndSwapLong(<span class="hljs-keyword">this</span>, valueOffset, prev, next);    &#125;    <span class="hljs-comment">// 省略不重要代码</span>&#125;</code></pre><p>下面讨论@sun.misc.Contended注解的重要意义</p><p>得从缓存说起，缓存与内存的速度比较</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210503094224.png"></p><p>因为 CPU 与 内存的 <code>速度差异很大</code> ，需要靠 <code>预读数据至缓存来提升效率</code> 。缓存离cpu越近速度越快。 而缓存以<code>缓存行</code>为单位，每个缓存行对应着一块内存，一般是 64 byte（8 个 long），缓存的加入会造成数据副本的产生，即同一份数据会缓存在不同核心的缓存行中，CPU 要保证数据的一致性，如果某个 CPU 核心更改了数据，其它 CPU 核心对应的整个缓存行必须失效。</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210503094409.png"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210503094740.png"></p><p>因为 Cell 是数组形式，在内存中是 <code>连续存储的</code> ，一个 Cell 为 <code>24 字节（16 字节的对象头和 8 字节的 value）</code>，因 此缓存行可以存下 2 个的 Cell 对象。这样问题来了： Core-0 要修改 Cell[0]，Core-1 要修改 Cell[1]</p><p>无论谁修改成功，都会导致<code>对方 Core 的缓存行失效</code>，比如 Core-0 中 Cell[0]=6000, Cell[1]=8000 要累加 Cell[0]=6001, Cell[1]=8000 ，这时会让 Core-1 的缓存行失效。</p><p><code>@sun.misc.Contended</code> 用来解决这个问题，它的原理是 <strong>在使用此注解的对象或字段的前后各增加 128 字节大小的padding，从而让 CPU 将对象预读至缓存时占用不同的缓存行，这样，不会造成对方缓存行的失效</strong> </p><p>让cell[0]和cell[1]处于不同缓存行。</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210503095203.png"></p><h6 id="add方法"><a href="#add方法" class="headerlink" title="add方法"></a>add方法</h6><p>再来看看LongAdder类的累加increment()方法中又主要调用下面的方法</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">long</span> x)</span> </span>&#123;        <span class="hljs-comment">// as 为累加单元数组</span>        <span class="hljs-comment">// b 为基础值</span>        <span class="hljs-comment">// x 为累加值</span>        Cell[] as; <span class="hljs-keyword">long</span> b, v; <span class="hljs-keyword">int</span> m; Cell a;        <span class="hljs-comment">// 进入 if 的两个条件</span>        <span class="hljs-comment">// 1. as 有值, 表示已经发生过竞争, 进入 if</span>        <span class="hljs-comment">// 2. cas 给 base 累加时失败了, 表示 base 发生了竞争, 进入 if</span>            <span class="hljs-comment">// cells数组是懒惰创建的，竞争发生才会创建</span>        <span class="hljs-keyword">if</span> ((as = cells) != <span class="hljs-keyword">null</span> || !casBase(b = base, b + x)) &#123;            <span class="hljs-comment">// uncontended 表示 cell 没有竞争</span>            <span class="hljs-keyword">boolean</span> uncontended = <span class="hljs-keyword">true</span>;            <span class="hljs-keyword">if</span> (                <span class="hljs-comment">// as 还没有创建</span>                    as == <span class="hljs-keyword">null</span> || (m = as.length - <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span> ||                            <span class="hljs-comment">// 当前线程对应的 cell 还没有被创建，a为当线程的cell</span>                            (a = as[getProbe() &amp; m]) == <span class="hljs-keyword">null</span> ||                                                <span class="hljs-comment">// 给当前线程的 cell 累加失败 uncontended=false ( a 为当前线程的 cell )</span>                            !(uncontended = a.cas(v = a.value, v + x))            ) &#123;                <span class="hljs-comment">// 进入 cell 数组创建、cell 创建的流程</span>                longAccumulate(x, <span class="hljs-keyword">null</span>, uncontended);            &#125;        &#125;    &#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210503095941.png"></p><h6 id="longAccumulate-方法"><a href="#longAccumulate-方法" class="headerlink" title="longAccumulate 方法"></a>longAccumulate 方法</h6><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">longAccumulate</span><span class="hljs-params">(<span class="hljs-keyword">long</span> x, LongBinaryOperator fn,</span></span><span class="hljs-function"><span class="hljs-params">                            <span class="hljs-keyword">boolean</span> wasUncontended)</span> </span>&#123;      <span class="hljs-keyword">int</span> h;      <span class="hljs-comment">// 当前线程还没有对应的 cell, 需要随机生成一个 h 值用来将当前线程绑定到 cell</span>      <span class="hljs-keyword">if</span> ((h = getProbe()) == <span class="hljs-number">0</span>) &#123;          <span class="hljs-comment">// 初始化 probe</span>          ThreadLocalRandom.current();          <span class="hljs-comment">// h 对应新的 probe 值, 用来对应 cell</span>          h = getProbe();          wasUncontended = <span class="hljs-keyword">true</span>;      &#125;      <span class="hljs-comment">// collide 为 true 表示需要扩容</span>      <span class="hljs-keyword">boolean</span> collide = <span class="hljs-keyword">false</span>;      <span class="hljs-keyword">for</span> (;;) &#123;          Cell[] as; Cell a; <span class="hljs-keyword">int</span> n; <span class="hljs-keyword">long</span> v;          <span class="hljs-comment">// 已经有了 cells</span>          <span class="hljs-keyword">if</span> ((as = cells) != <span class="hljs-keyword">null</span> &amp;&amp; (n = as.length) &gt; <span class="hljs-number">0</span>) &#123;              <span class="hljs-comment">// 但是还没有当前线程对应的 cell</span>              <span class="hljs-keyword">if</span> ((a = as[(n - <span class="hljs-number">1</span>) &amp; h]) == <span class="hljs-keyword">null</span>) &#123;                  <span class="hljs-comment">// 为 cellsBusy 加锁, 创建 cell, cell 的初始累加值为 x</span>                  <span class="hljs-comment">// 成功则 break, 否则继续 continue 循环</span>                  <span class="hljs-keyword">if</span> (cellsBusy == <span class="hljs-number">0</span>) &#123;       <span class="hljs-comment">// Try to attach new Cell</span>                      Cell r = <span class="hljs-keyword">new</span> Cell(x);   <span class="hljs-comment">// Optimistically create</span>                      <span class="hljs-keyword">if</span> (cellsBusy == <span class="hljs-number">0</span> &amp;&amp; casCellsBusy()) &#123;                          <span class="hljs-keyword">boolean</span> created = <span class="hljs-keyword">false</span>;                          <span class="hljs-keyword">try</span> &#123;               <span class="hljs-comment">// Recheck under lock</span>                              Cell[] rs; <span class="hljs-keyword">int</span> m, j;                              <span class="hljs-keyword">if</span> ((rs = cells) != <span class="hljs-keyword">null</span> &amp;&amp;                                  (m = rs.length) &gt; <span class="hljs-number">0</span> &amp;&amp;                                  <span class="hljs-comment">// 判断槽位确实是空的</span>                                  rs[j = (m - <span class="hljs-number">1</span>) &amp; h] == <span class="hljs-keyword">null</span>) &#123;                                  rs[j] = r;                                  created = <span class="hljs-keyword">true</span>;                              &#125;                          &#125; <span class="hljs-keyword">finally</span> &#123;                              cellsBusy = <span class="hljs-number">0</span>;                          &#125;                          <span class="hljs-keyword">if</span> (created)                              <span class="hljs-keyword">break</span>;                          <span class="hljs-keyword">continue</span>;           <span class="hljs-comment">// Slot is now non-empty</span>                      &#125;              &#125;              <span class="hljs-comment">// 有竞争, 改变线程对应的 cell 来重试 cas</span>              <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!wasUncontended)                  wasUncontended = <span class="hljs-keyword">true</span>;                  <span class="hljs-comment">// cas 尝试累加, fn 配合 LongAccumulator 不为 null, 配合 LongAdder 为 null</span>              <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a.cas(v = a.value, ((fn == <span class="hljs-keyword">null</span>) ? v + x : fn.applyAsLong(v, x))))                  <span class="hljs-keyword">break</span>;                  <span class="hljs-comment">// 如果 cells 长度已经超过了最大长度, 或者已经扩容, 改变线程对应的 cell 来重试 cas</span>              <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n &gt;= NCPU || cells != as)                  collide = <span class="hljs-keyword">false</span>;                  <span class="hljs-comment">// 确保 collide 为 false 进入此分支, 就不会进入下面的 else if 进行扩容了</span>              <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!collide)                  collide = <span class="hljs-keyword">true</span>;                  <span class="hljs-comment">// 加锁</span>              <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cellsBusy == <span class="hljs-number">0</span> &amp;&amp; casCellsBusy()) &#123;                  <span class="hljs-comment">// 加锁成功, 扩容</span>                  <span class="hljs-keyword">continue</span>;              &#125;              <span class="hljs-comment">// 改变线程对应的 cell</span>              h = advanceProbe(h);          &#125;          <span class="hljs-comment">// 还没有 cells, cells==as是指没有其它线程修改cells，as和cells引用相同的对象，使用casCellsBusy()尝试给 cellsBusy 加锁</span>          <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cellsBusy == <span class="hljs-number">0</span> &amp;&amp; cells == as &amp;&amp; casCellsBusy()) &#123;              <span class="hljs-comment">// 加锁成功, 初始化 cells, 最开始长度为 2, 并填充一个 cell</span>              <span class="hljs-comment">// 成功则 break;</span>              <span class="hljs-keyword">boolean</span> init = <span class="hljs-keyword">false</span>;              <span class="hljs-keyword">try</span> &#123;                           <span class="hljs-comment">// Initialize table</span>                  <span class="hljs-keyword">if</span> (cells == as) &#123;                      Cell[] rs = <span class="hljs-keyword">new</span> Cell[<span class="hljs-number">2</span>];                      rs[h &amp; <span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> Cell(x);                      cells = rs;                      init = <span class="hljs-keyword">true</span>;                  &#125;              &#125; <span class="hljs-keyword">finally</span> &#123;                  cellsBusy = <span class="hljs-number">0</span>;              &#125;              <span class="hljs-keyword">if</span> (init)                  <span class="hljs-keyword">break</span>;          &#125;          <span class="hljs-comment">// 上两种情况失败, 尝试给 base 使用casBase累加</span>          <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (casBase(v = base, ((fn == <span class="hljs-keyword">null</span>) ? v + x : fn.applyAsLong(v, x))))              <span class="hljs-keyword">break</span>;      &#125;  &#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210503100645.png"></p><p>上图中的第一个else if 中代码的逻辑，这是cells未创建时的处理逻辑。</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210503101033.png"></p><p>上图中的if 中代码的逻辑，里面包含线程对应的cell已经创建好和没创建好的两种情况。</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210503101506.png">线程对应的cell还没创建好，则执行的是第一个红框里的代码，逻辑如下</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210503101528.png"></p><p>线程对应的cell已经创建好，则执行的是第二个红框里的代码，逻辑如下</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210503101553.png"></p><h6 id="sum-方法"><a href="#sum-方法" class="headerlink" title="sum 方法"></a>sum 方法</h6><p>获取最终结果通过 sum 方法，将各个累加单元的值加起来就得到了总的结果。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">sum</span><span class="hljs-params">()</span> </span>&#123;    Cell[] as = cells; Cell a;    <span class="hljs-keyword">long</span> sum = base;    <span class="hljs-keyword">if</span> (as != <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; as.length; ++i) &#123;            <span class="hljs-keyword">if</span> ((a = as[i]) != <span class="hljs-keyword">null</span>)                sum += a.value;        &#125;    &#125;    <span class="hljs-keyword">return</span> sum;&#125;</code></pre><h3 id="5-4-Unsafe"><a href="#5-4-Unsafe" class="headerlink" title="5.4 Unsafe"></a>5.4 Unsafe</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>Unsafe 对象提供了非常底层的，操作内存、线程的方法，Unsafe 对象不能直接调用，<code>只能通过反射获得</code></p><p>LockSupport的park方法，cas相关的方法底层都是通过Unsafe类来实现的。</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210503102610.png"></p><h4 id="Unsafe-对象的获取"><a href="#Unsafe-对象的获取" class="headerlink" title="Unsafe 对象的获取"></a>Unsafe 对象的获取</h4><pre><code class="hljs java"><span class="hljs-keyword">static</span> Unsafe unsafe;<span class="hljs-keyword">static</span> &#123;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-comment">// Unsafe 使用了单例模式，unsafe对象是类中的一个私有的变量</span>        Field theUnsafe = Unsafe.class.getDeclaredField(<span class="hljs-string">&quot;theUnsafe&quot;</span>);        theUnsafe.setAccessible(<span class="hljs-keyword">true</span>);        unsafe = (Unsafe) theUnsafe.get(<span class="hljs-keyword">null</span>);    &#125; <span class="hljs-keyword">catch</span> (NoSuchFieldException | IllegalAccessException e) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(e);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">static</span> Unsafe <span class="hljs-title">getUnsafe</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> unsafe;&#125;</code></pre><h4 id="Unsafe-模拟实现-cas-操作"><a href="#Unsafe-模拟实现-cas-操作" class="headerlink" title="Unsafe 模拟实现 cas 操作"></a>Unsafe 模拟实现 cas 操作</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestUnsafe</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> NoSuchFieldException, IllegalAccessException </span>&#123;        Field theUnsafe = Unsafe.class.getDeclaredField(<span class="hljs-string">&quot;theUnsafe&quot;</span>);        theUnsafe.setAccessible(<span class="hljs-keyword">true</span>);        Unsafe unsafe = (Unsafe) theUnsafe.get(<span class="hljs-keyword">null</span>);        System.out.println(unsafe);        <span class="hljs-comment">// 1. 获取域的偏移地址</span>        <span class="hljs-keyword">long</span> idOffset = unsafe.objectFieldOffset(Teacher.class.getDeclaredField(<span class="hljs-string">&quot;id&quot;</span>));        <span class="hljs-keyword">long</span> nameOffset = unsafe.objectFieldOffset(Teacher.class.getDeclaredField(<span class="hljs-string">&quot;name&quot;</span>));        Teacher t = <span class="hljs-keyword">new</span> Teacher();        <span class="hljs-comment">// 2. 执行 cas 操作</span>        unsafe.compareAndSwapInt(t, idOffset, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);        unsafe.compareAndSwapObject(t, nameOffset, <span class="hljs-keyword">null</span>, <span class="hljs-string">&quot;张三&quot;</span>);        <span class="hljs-comment">// 3. 验证</span>        System.out.println(t);    &#125;&#125;<span class="hljs-meta">@Data</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Teacher</span> </span>&#123;    <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> id;    <span class="hljs-keyword">volatile</span> String name;&#125;</code></pre><pre><code class="hljs ruby">sun.misc.Unsafe<span class="hljs-variable">@2b193f</span>2dTeacher(id=<span class="hljs-number">1</span>, name=张三)</code></pre><h4 id="Unsafe-模拟实现原子整数"><a href="#Unsafe-模拟实现原子整数" class="headerlink" title="Unsafe 模拟实现原子整数"></a>Unsafe 模拟实现原子整数</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnsafeAccessor</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Unsafe unsafe;    <span class="hljs-keyword">static</span> &#123;        <span class="hljs-keyword">try</span> &#123;            Field theUnsafe = Unsafe.class.getDeclaredField(<span class="hljs-string">&quot;theUnsafe&quot;</span>);            theUnsafe.setAccessible(<span class="hljs-keyword">true</span>);            unsafe = (Unsafe) theUnsafe.get(<span class="hljs-keyword">null</span>);        &#125; <span class="hljs-keyword">catch</span> (NoSuchFieldException | IllegalAccessException e) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(e);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Unsafe <span class="hljs-title">getUnsafe</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> unsafe;    &#125;&#125;</code></pre><p>工具类</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyAtomicInteger</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Account</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> value;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> valueOffset;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Unsafe UNSAFE;    <span class="hljs-keyword">static</span> &#123;        UNSAFE = UnsafeAccessor.getUnsafe();        <span class="hljs-keyword">try</span> &#123;            valueOffset = UNSAFE.objectFieldOffset(MyAtomicInteger.class.getDeclaredField(<span class="hljs-string">&quot;value&quot;</span>));        &#125; <span class="hljs-keyword">catch</span> (NoSuchFieldException e) &#123;            e.printStackTrace();            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getValue</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> value;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decrement</span><span class="hljs-params">(<span class="hljs-keyword">int</span> amount)</span> </span>&#123;        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;            <span class="hljs-keyword">int</span> prev = <span class="hljs-keyword">this</span>.value;            <span class="hljs-keyword">int</span> next = prev - amount;            <span class="hljs-keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="hljs-keyword">this</span>, valueOffset, prev, next)) &#123;                <span class="hljs-keyword">break</span>;            &#125;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyAtomicInteger</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;        <span class="hljs-keyword">this</span>.value = value;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getBalance</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> getValue();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">withdraw</span><span class="hljs-params">(Integer amount)</span> </span>&#123;        decrement(amount);    &#125;&#125;</code></pre><pre><code class="hljs ruby"><span class="hljs-number">0</span> <span class="hljs-symbol">cost:</span> <span class="hljs-number">70</span> ms</code></pre><h2 id="6、共享模型之不可变"><a href="#6、共享模型之不可变" class="headerlink" title="6、共享模型之不可变"></a>6、共享模型之不可变</h2><ul><li>不可变类使用</li><li>不可变类设计</li><li>原理方面：final</li><li>模式方面<ul><li>享元模式-&gt; 设置线程池</li></ul></li></ul><h3 id="6-1-日期转换的问题"><a href="#6-1-日期转换的问题" class="headerlink" title="6.1 日期转换的问题"></a>6.1 日期转换的问题</h3><p>问题提出，下面的代码在运行时，由于 SimpleDateFormat 不是线程安全的，有很大几率出现 <code>java.lang.NumberFormatException</code> 或者出现不正确的日期解析结果。</p><pre><code class="hljs java">SimpleDateFormat sdf = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd&quot;</span>);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;    <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;        <span class="hljs-keyword">try</span> &#123;            log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, sdf.parse(<span class="hljs-string">&quot;1951-04-21&quot;</span>));        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            log.error(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, e);        &#125;    &#125;).start();&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210503104554.png"></p><h4 id="改进思路"><a href="#改进思路" class="headerlink" title="改进思路"></a>改进思路</h4><p>加锁：</p><pre><code class="hljs java">SimpleDateFormat sdf = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd&quot;</span>);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;    <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;        <span class="hljs-keyword">synchronized</span> (sdf) &#123;            <span class="hljs-keyword">try</span> &#123;                log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, sdf.parse(<span class="hljs-string">&quot;1951-04-21&quot;</span>));            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;                log.error(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, e);            &#125;        &#125;    &#125;).start();&#125;</code></pre><p>思路 - <code>不可变对象</code></p><p>如果一个对象在<code>不能够修改其内部状态（属性）</code>，那么它就是线程安全的，因为不存在并发修改啊！这样的对象在 Java 中有很多，例如在 Java 8 后，提供了一个新的日期格式化类DateTimeFormatter：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210503104829.png"></p><pre><code class="hljs java">DateTimeFormatter stf = DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyy-MM-dd&quot;</span>);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;    <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;        TemporalAccessor parse = stf.parse(<span class="hljs-string">&quot;1951-04-21&quot;</span>);        log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, parse);    &#125;).start();&#125;</code></pre><h3 id="6-2-不可变设计"><a href="#6-2-不可变设计" class="headerlink" title="6.2 不可变设计"></a>6.2 不可变设计</h3><blockquote><ol><li>更多不可变类的知识，可参考这<a href="https://www.cnblogs.com/dolphin0520/p/10693891.html">这里</a></li><li>final类的知识，参考<a href="https://www.cnblogs.com/xiaoxi/p/6392154.html">这里</a></li></ol></blockquote><p>另一个大家更为熟悉的 String 类也是不可变的，以它为例，说明一下不可变类 <strong>设计的要素</strong> </p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">String</span></span><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span>, <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">String</span>&gt;, <span class="hljs-title">CharSequence</span> </span>&#123;    <span class="hljs-comment">/** The value is used for character storage. */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">char</span> value[]; <span class="hljs-comment">// 只能构造赋值，以后无法改变</span>    <span class="hljs-comment">/** Cache the hash code for the string */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> hash; <span class="hljs-comment">// Default to 0 // 缓存字符串生成的hash码，首次调用hashcode()生成</span>    <span class="hljs-comment">// ...</span>&#125;</code></pre><h4 id="final-的使用"><a href="#final-的使用" class="headerlink" title="final 的使用"></a>final 的使用</h4><p>发现该类、类中所有属性都是 ﬁnal 的</p><ul><li>属性用 ﬁnal 修饰保证了该属性是 <code>只读的，不能修改</code></li><li>类用 ﬁnal 修饰保证了该类中的 <code>方法不能被覆盖</code> ，<code>防止子类无意间破坏不可变性</code></li></ul><p>final只保证数组引用不会发生改变，不能保证内容不改变，我们查看String构造方法：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210503105517.png"></p><h4 id="保护性拷贝"><a href="#保护性拷贝" class="headerlink" title="保护性拷贝"></a>保护性拷贝</h4><p>使用字符串时，也有一些跟修改相关的方法啊，比如 <code>substring</code> 等，那么下面就看一看这些方法是 如何实现的，就以 substring 为例：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">substring</span><span class="hljs-params">(<span class="hljs-keyword">int</span> beginIndex, <span class="hljs-keyword">int</span> endIndex)</span> </span>&#123;        <span class="hljs-comment">//......</span>        <span class="hljs-comment">// 上面是一些校验，下面才是真正的创建新的String对象</span>        <span class="hljs-keyword">return</span> ((beginIndex == <span class="hljs-number">0</span>) &amp;&amp; (endIndex == value.length)) ? <span class="hljs-keyword">this</span>                : <span class="hljs-keyword">new</span> String(value, beginIndex, subLen);    &#125;</code></pre><p>发现其内部是调用<code> String 的构造方法创建了一个新字符串</code>，再进入这个构造看看，是否对 final char[] value 做出 了修改：结果发现也没有，构造新字符串对象时，会<code>生成新的 char[] value，对内容进行复制</code>。这种通过创建副本对象来避免共享的手段称之为【保护性拷贝（defensive copy）】</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">String</span><span class="hljs-params">(<span class="hljs-keyword">char</span> value[], <span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">int</span> count)</span> </span>&#123;        <span class="hljs-comment">//....</span>        <span class="hljs-comment">// 上面是一些安全性的校验，下面是给String对象的value赋值，新创建了一个数组来保存String对象的值</span>        <span class="hljs-keyword">this</span>.value = Arrays.copyOfRange(value, offset, offset+count);    &#125;</code></pre><h3 id="6-3-享元模式"><a href="#6-3-享元模式" class="headerlink" title="6.3 享元模式"></a>6.3 享元模式</h3><ol><li>简介<br>定义 英文名称：Flyweight pattern. 当 <strong>需要重用数量有限的同一类对象时</strong> </li></ol><blockquote><p>wikipedia： A flyweight is an object that minimizes memory usage by sharing as much data as<br>possible with other similar objects<br>出自 “Gang of Four” design patterns<br>归类 Structual patterns</p></blockquote><ol start="2"><li><p>体现</p><ul><li>包装类<br>在JDK中 Boolean，Byte，Short，Integer，Long，Character 等包装类提供了 valueOf 方法，例如 Long 的valueOf 会缓存 -128~127 之间的 Long 对象，在这个范围之间会 <code>重用对象</code> ，大于这个范围，才会 <code>新建 Long 对象</code> ：</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Long <span class="hljs-title">valueOf</span><span class="hljs-params">(<span class="hljs-keyword">long</span> l)</span> </span>&#123; <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> offset = <span class="hljs-number">128</span>; <span class="hljs-keyword">if</span> (l &gt;= -<span class="hljs-number">128</span> &amp;&amp; l &lt;= <span class="hljs-number">127</span>) &#123; <span class="hljs-comment">// will cache</span> <span class="hljs-keyword">return</span> LongCache.cache[(<span class="hljs-keyword">int</span>)l + offset]; &#125; <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Long(l);&#125;</code></pre><blockquote><p>注意： Byte, Short, Long 缓存的范围都是 -128<del>127 Character 缓存的范围是 0</del>127 Integer的默认范围是 -128~127，</p><p>最小值不能变，</p><p>但最大值可以通过调整虚拟机参数 <code>&quot;-Djava.lang.Integer.IntegerCache.high</code> “来改变 Boolean 缓存了 TRUE 和 FALSE</p></blockquote><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210503110445.png"></p><ul><li>String 串池</li><li>BigDecimal BigInteger</li></ul></li></ol><h4 id="diy"><a href="#diy" class="headerlink" title="diy"></a>diy</h4><p>例如：一个线上商城应用，QPS 达到数千，如果每次都重新创建和关闭数据库连接，性能会受到极大影响。 这时预先创建好一批连接，放入连接池。一次请求到达后，从 <code>连接池获取连接</code>，使用完毕后再还回连接池，这样既节约了连接的创建和关闭时间，也实现了连接的重用，不至于让庞大的连接数压垮数据库。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test3</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Pool pool = <span class="hljs-keyword">new</span> Pool(<span class="hljs-number">2</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;            <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;                Connection conn = pool.borrow();                <span class="hljs-keyword">try</span> &#123;                    Thread.sleep(<span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">1000</span>));                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                &#125;                pool.free(conn);            &#125;).start();        &#125;    &#125;&#125;<span class="hljs-meta">@Slf4j(topic = &quot;c.Pool&quot;)</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pool</span> </span>&#123;    <span class="hljs-comment">// 1. 连接池大小</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> poolSize;    <span class="hljs-comment">// 2. 连接对象数组</span>    <span class="hljs-keyword">private</span> Connection[] connections;    <span class="hljs-comment">// 3. 连接状态数组 0 表示空闲， 1 表示繁忙</span>    <span class="hljs-keyword">private</span> AtomicIntegerArray states;    <span class="hljs-comment">// 4. 构造方法初始化</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Pool</span><span class="hljs-params">(<span class="hljs-keyword">int</span> poolSize)</span> </span>&#123;        <span class="hljs-keyword">this</span>.poolSize = poolSize;        <span class="hljs-keyword">this</span>.connections = <span class="hljs-keyword">new</span> Connection[poolSize];        <span class="hljs-keyword">this</span>.states = <span class="hljs-keyword">new</span> AtomicIntegerArray(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[poolSize]);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; poolSize; i++) &#123;            connections[i] = <span class="hljs-keyword">new</span> MockConnection(<span class="hljs-string">&quot;连接&quot;</span> + (i+<span class="hljs-number">1</span>));        &#125;    &#125;    <span class="hljs-comment">// 5. 借连接</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Connection <span class="hljs-title">borrow</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; poolSize; i++) &#123;                <span class="hljs-comment">// 获取空闲连接</span>                <span class="hljs-keyword">if</span>(states.get(i) == <span class="hljs-number">0</span>) &#123;                    <span class="hljs-keyword">if</span> (states.compareAndSet(i, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;                        log.debug(<span class="hljs-string">&quot;borrow &#123;&#125;&quot;</span>, connections[i]);                        <span class="hljs-keyword">return</span> connections[i];                    &#125;                &#125;            &#125;            <span class="hljs-comment">// 如果没有空闲连接，当前线程进入等待</span>            <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;                <span class="hljs-keyword">try</span> &#123;                    log.debug(<span class="hljs-string">&quot;wait...&quot;</span>);                    <span class="hljs-keyword">this</span>.wait();                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;    &#125;    <span class="hljs-comment">// 6. 归还连接</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">free</span><span class="hljs-params">(Connection conn)</span> </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; poolSize; i++) &#123;            <span class="hljs-keyword">if</span> (connections[i] == conn) &#123;                <span class="hljs-comment">// 归还连接线程一定是持有者，不需要cas</span>                states.set(i, <span class="hljs-number">0</span>);                <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;                    log.debug(<span class="hljs-string">&quot;free &#123;&#125;&quot;</span>, conn);                    <span class="hljs-keyword">this</span>.notifyAll();                &#125;                <span class="hljs-keyword">break</span>;            &#125;        &#125;    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MockConnection</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Connection</span> </span>&#123;<span class="hljs-comment">// ....</span>&#125;</code></pre><pre><code class="hljs ruby"><span class="hljs-number">11</span><span class="hljs-symbol">:</span><span class="hljs-number">31</span><span class="hljs-symbol">:</span><span class="hljs-number">24</span> [Thread-<span class="hljs-number">2</span>] c.Pool - wait...<span class="hljs-number">11</span><span class="hljs-symbol">:</span><span class="hljs-number">31</span><span class="hljs-symbol">:</span><span class="hljs-number">24</span> [Thread-<span class="hljs-number">1</span>] c.Pool - borrow MockConnection&#123;name=<span class="hljs-string">&#x27;连接2&#x27;</span>&#125;<span class="hljs-number">11</span><span class="hljs-symbol">:</span><span class="hljs-number">31</span><span class="hljs-symbol">:</span><span class="hljs-number">24</span> [Thread-<span class="hljs-number">3</span>] c.Pool - wait...<span class="hljs-number">11</span><span class="hljs-symbol">:</span><span class="hljs-number">31</span><span class="hljs-symbol">:</span><span class="hljs-number">24</span> [Thread-<span class="hljs-number">4</span>] c.Pool - wait...<span class="hljs-number">11</span><span class="hljs-symbol">:</span><span class="hljs-number">31</span><span class="hljs-symbol">:</span><span class="hljs-number">24</span> [Thread-<span class="hljs-number">0</span>] c.Pool - borrow MockConnection&#123;name=<span class="hljs-string">&#x27;连接1&#x27;</span>&#125;<span class="hljs-number">11</span><span class="hljs-symbol">:</span><span class="hljs-number">31</span><span class="hljs-symbol">:</span><span class="hljs-number">25</span> [Thread-<span class="hljs-number">1</span>] c.Pool - free MockConnection&#123;name=<span class="hljs-string">&#x27;连接2&#x27;</span>&#125;<span class="hljs-number">11</span><span class="hljs-symbol">:</span><span class="hljs-number">31</span><span class="hljs-symbol">:</span><span class="hljs-number">25</span> [Thread-<span class="hljs-number">4</span>] c.Pool - borrow MockConnection&#123;name=<span class="hljs-string">&#x27;连接2&#x27;</span>&#125;<span class="hljs-number">11</span><span class="hljs-symbol">:</span><span class="hljs-number">31</span><span class="hljs-symbol">:</span><span class="hljs-number">25</span> [Thread-<span class="hljs-number">3</span>] c.Pool - wait...<span class="hljs-number">11</span><span class="hljs-symbol">:</span><span class="hljs-number">31</span><span class="hljs-symbol">:</span><span class="hljs-number">25</span> [Thread-<span class="hljs-number">2</span>] c.Pool - wait...<span class="hljs-number">11</span><span class="hljs-symbol">:</span><span class="hljs-number">31</span><span class="hljs-symbol">:</span><span class="hljs-number">25</span> [Thread-<span class="hljs-number">0</span>] c.Pool - free MockConnection&#123;name=<span class="hljs-string">&#x27;连接1&#x27;</span>&#125;<span class="hljs-number">11</span><span class="hljs-symbol">:</span><span class="hljs-number">31</span><span class="hljs-symbol">:</span><span class="hljs-number">25</span> [Thread-<span class="hljs-number">3</span>] c.Pool - wait...<span class="hljs-number">11</span><span class="hljs-symbol">:</span><span class="hljs-number">31</span><span class="hljs-symbol">:</span><span class="hljs-number">25</span> [Thread-<span class="hljs-number">2</span>] c.Pool - borrow MockConnection&#123;name=<span class="hljs-string">&#x27;连接1&#x27;</span>&#125;<span class="hljs-number">11</span><span class="hljs-symbol">:</span><span class="hljs-number">31</span><span class="hljs-symbol">:</span><span class="hljs-number">25</span> [Thread-<span class="hljs-number">2</span>] c.Pool - free MockConnection&#123;name=<span class="hljs-string">&#x27;连接1&#x27;</span>&#125;<span class="hljs-number">11</span><span class="hljs-symbol">:</span><span class="hljs-number">31</span><span class="hljs-symbol">:</span><span class="hljs-number">25</span> [Thread-<span class="hljs-number">3</span>] c.Pool - borrow MockConnection&#123;name=<span class="hljs-string">&#x27;连接1&#x27;</span>&#125;<span class="hljs-number">11</span><span class="hljs-symbol">:</span><span class="hljs-number">31</span><span class="hljs-symbol">:</span><span class="hljs-number">25</span> [Thread-<span class="hljs-number">4</span>] c.Pool - free MockConnection&#123;name=<span class="hljs-string">&#x27;连接2&#x27;</span>&#125;<span class="hljs-number">11</span><span class="hljs-symbol">:</span><span class="hljs-number">31</span><span class="hljs-symbol">:</span><span class="hljs-number">25</span> [Thread-<span class="hljs-number">3</span>] c.Pool - free MockConnection&#123;name=<span class="hljs-string">&#x27;连接1&#x27;</span>&#125;</code></pre><p>以上实现没有考虑：</p><ul><li>连接的动态增长与收缩</li><li>连接保活（可用性检测）</li><li>等待超时处理</li><li>分布式 hash</li></ul><p>对于关系型数据库，有比较成熟的连接池的实现，例如 c3p0、druid 等<br>对于更通用的对象池，可以考虑用 apache commons pool，例如 redis 连接池可以参考 jedis 中关于连接池的实现。</p><h3 id="final的原理"><a href="#final的原理" class="headerlink" title="final的原理"></a>final的原理</h3><h5 id="1）设置-final-变量的原理"><a href="#1）设置-final-变量的原理" class="headerlink" title="1）设置 final 变量的原理"></a>1）设置 final 变量的原理</h5><p>理解了 volatile 原理，再对比 final 的实现就比较简单了</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestFinal</span> </span>&#123;    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> a = <span class="hljs-number">20</span>;&#125;</code></pre><p>字节码</p><pre><code class="hljs ruby"><span class="hljs-number">0</span>: aload_0<span class="hljs-number">1</span>: invokespecial <span class="hljs-comment">#1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><span class="hljs-number">4</span>: aload_0<span class="hljs-number">5</span>: bipush <span class="hljs-number">20</span><span class="hljs-number">7</span>: putfield <span class="hljs-comment">#2 // Field a:I</span> &lt;-- 写屏障<span class="hljs-number">10</span>: <span class="hljs-keyword">return</span></code></pre><p>final 变量的赋值操作都必须在 <strong>定义时或者构造器中进行初始化赋值</strong> ，并发现 final 变量的赋值也会通过 putfield 指令来完成，同样在这条指令之后也会加入 <code>写屏障</code> ，保证在其它线程读到它的值时不会出现为 0 的情况。</p><h5 id="2）获取-final-变量的原理"><a href="#2）获取-final-变量的原理" class="headerlink" title="2）获取 final 变量的原理"></a>2）获取 final 变量的原理</h5><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210503114705.png"></p><p>直接把A变量的值复制到当前使用的类中</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210503114847.png"></p><p>数字比较小，在 <code>栈内存中</code> BIPUSH</p><p>数字比较大，在 <code>常量池</code>中 LDC</p><p>不用final，在 <code>堆</code>中 GETSTATIC</p><h3 id="6-4-无状态"><a href="#6-4-无状态" class="headerlink" title="6.4 无状态"></a>6.4 无状态</h3><p>在 web 阶段学习时，设计 Servlet 时为了保证其线程安全，都会有这样的建议，不要为 Servlet 设置成员变量，这种 <code>没有任何成员变量的类是线程安全的</code><br>因为成员变量保存的数据也可以称为状态信息，因此没有成员变量就称之为【无状态】</p><h2 id="7、共享模型之工具"><a href="#7、共享模型之工具" class="headerlink" title="7、共享模型之工具"></a>7、共享模型之工具</h2><h3 id="7-1-线程池"><a href="#7-1-线程池" class="headerlink" title="7.1 线程池"></a>7.1 线程池</h3><blockquote><p>池化技术相比大家已经屡见不鲜了，线程池、数据库连接池、Http 连接池等等都是对这个思想的应用。池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。</p></blockquote><p>线程池提供了一种限制和管理资源（包括执行一个任务）。 每个线程池还维护一些基本统计信息，例如已完成任务的数量。</p><p>这里借用《Java 并发编程的艺术》提到的来说一下使用线程池的好处：</p><ul><li>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li>提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li><li>提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li></ul><h3 id="7-2-自定义线程池"><a href="#7-2-自定义线程池" class="headerlink" title="7.2 自定义线程池"></a>7.2 自定义线程池</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210503120543.png"></p><p>步骤1：自定义拒绝策略接口</p><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span> <span class="hljs-comment">// 拒绝策略</span><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">RejectPolicy</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reject</span><span class="hljs-params">(BlockingQueue&lt;T&gt; queue, T task)</span></span>;&#125;</code></pre><p>步骤2：自定义任务队列</p><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.BlockingQueue&quot;)</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BlockingQueue</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;    <span class="hljs-comment">// 1. 任务队列</span>    <span class="hljs-keyword">private</span> Deque&lt;T&gt; queue = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();    <span class="hljs-comment">// 2. 锁</span>    <span class="hljs-keyword">private</span> ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();    <span class="hljs-comment">// 3. 生产者条件变量</span>    <span class="hljs-keyword">private</span> Condition fullWaitSet = lock.newCondition();    <span class="hljs-comment">// 4. 消费者条件变量</span>    <span class="hljs-keyword">private</span> Condition emptyWaitSet = lock.newCondition();    <span class="hljs-comment">// 5. 容量</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> capcity;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BlockingQueue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capcity)</span> </span>&#123;        <span class="hljs-keyword">this</span>.capcity = capcity;    &#125;    <span class="hljs-comment">// 带超时阻塞获取(take)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">poll</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout, TimeUnit unit)</span> </span>&#123;        lock.lock();        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">// 将 timeout 统一转换为 纳秒</span>            <span class="hljs-keyword">long</span> nanos = unit.toNanos(timeout);            <span class="hljs-keyword">while</span> (queue.isEmpty()) &#123;                <span class="hljs-keyword">try</span> &#123;                    <span class="hljs-comment">// 返回值是剩余时间</span>                    <span class="hljs-keyword">if</span> (nanos &lt;= <span class="hljs-number">0</span>) &#123;                        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;                    &#125;                    <span class="hljs-comment">// 防止虚假唤醒 返回 等待 - 经过 = 剩余</span>                    nanos = emptyWaitSet.awaitNanos(nanos);                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;            T t = queue.removeFirst();            fullWaitSet.signal();            <span class="hljs-keyword">return</span> t;        &#125; <span class="hljs-keyword">finally</span> &#123;            lock.unlock();        &#125;    &#125;    <span class="hljs-comment">// 阻塞获取</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">take</span><span class="hljs-params">()</span> </span>&#123;        lock.lock();        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">while</span> (queue.isEmpty()) &#123;                <span class="hljs-keyword">try</span> &#123;                    emptyWaitSet.await();                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;            T t = queue.removeFirst();            fullWaitSet.signal();            <span class="hljs-keyword">return</span> t;        &#125; <span class="hljs-keyword">finally</span> &#123;            lock.unlock();        &#125;    &#125;    <span class="hljs-comment">// 阻塞添加</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(T task)</span> </span>&#123;        lock.lock();        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">while</span> (queue.size() == capcity) &#123;                <span class="hljs-keyword">try</span> &#123;                    log.debug(<span class="hljs-string">&quot;等待加入任务队列 &#123;&#125; ...&quot;</span>, task);                    fullWaitSet.await();                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;            log.debug(<span class="hljs-string">&quot;加入任务队列 &#123;&#125;&quot;</span>, task);            queue.addLast(task);            emptyWaitSet.signal();        &#125; <span class="hljs-keyword">finally</span> &#123;            lock.unlock();        &#125;    &#125;    <span class="hljs-comment">// 带超时时间阻塞添加</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">offer</span><span class="hljs-params">(T task, <span class="hljs-keyword">long</span> timeout, TimeUnit timeUnit)</span> </span>&#123;        lock.lock();        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">long</span> nanos = timeUnit.toNanos(timeout);            <span class="hljs-keyword">while</span> (queue.size() == capcity) &#123;                <span class="hljs-keyword">try</span> &#123;                    <span class="hljs-keyword">if</span>(nanos &lt;= <span class="hljs-number">0</span>) &#123;                        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;                    &#125;                    log.debug(<span class="hljs-string">&quot;等待加入任务队列 &#123;&#125; ...&quot;</span>, task);                    nanos = fullWaitSet.awaitNanos(nanos);                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;            log.debug(<span class="hljs-string">&quot;加入任务队列 &#123;&#125;&quot;</span>, task);            queue.addLast(task);            emptyWaitSet.signal();            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125; <span class="hljs-keyword">finally</span> &#123;            lock.unlock();        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;        lock.lock();        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">return</span> queue.size();        &#125; <span class="hljs-keyword">finally</span> &#123;            lock.unlock();        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">tryPut</span><span class="hljs-params">(RejectPolicy&lt;T&gt; rejectPolicy, T task)</span> </span>&#123;        lock.lock();        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">// 判断队列是否满</span>            <span class="hljs-keyword">if</span>(queue.size() == capcity) &#123;                rejectPolicy.reject(<span class="hljs-keyword">this</span>, task);            &#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// 有空闲</span>                log.debug(<span class="hljs-string">&quot;加入任务队列 &#123;&#125;&quot;</span>, task);                queue.addLast(task);                emptyWaitSet.signal();            &#125;        &#125; <span class="hljs-keyword">finally</span> &#123;            lock.unlock();        &#125;    &#125;&#125;</code></pre><p>步骤3：自定义线程池</p><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.ThreadPool&quot;)</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadPool</span> </span>&#123;    <span class="hljs-comment">// 任务队列</span>    <span class="hljs-keyword">private</span> BlockingQueue&lt;Runnable&gt; taskQueue;    <span class="hljs-comment">// 线程集合</span>    <span class="hljs-keyword">private</span> HashSet&lt;Worker&gt; workers = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();    <span class="hljs-comment">// 核心线程数</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> coreSize;    <span class="hljs-comment">// 获取任务时的超时时间</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> timeout;    <span class="hljs-keyword">private</span> TimeUnit timeUnit;    <span class="hljs-keyword">private</span> RejectPolicy&lt;Runnable&gt; rejectPolicy;    <span class="hljs-comment">// 执行任务</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Runnable task)</span> </span>&#123;        <span class="hljs-comment">// 当任务数没有超过 coreSize 时，直接交给 worker 对象执行</span>        <span class="hljs-comment">// 如果任务数超过 coreSize 时，加入任务队列暂存</span>        <span class="hljs-keyword">synchronized</span> (workers) &#123;            <span class="hljs-comment">// 又要size 又要add</span>            <span class="hljs-keyword">if</span>(workers.size() &lt; coreSize) &#123;                Worker worker = <span class="hljs-keyword">new</span> Worker(task);                log.debug(<span class="hljs-string">&quot;新增 worker&#123;&#125;, &#123;&#125;&quot;</span>, worker, task);                workers.add(worker);                worker.start();            &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//                taskQueue.put(task);</span>                <span class="hljs-comment">// 1) 死等</span>                <span class="hljs-comment">// 2) 带超时等待</span>                <span class="hljs-comment">// 3) 让调用者放弃任务执行</span>                <span class="hljs-comment">// 4) 让调用者抛出异常</span>                <span class="hljs-comment">// 5) 让调用者自己执行任务</span>                taskQueue.tryPut(rejectPolicy, task);            &#125;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadPool</span><span class="hljs-params">(<span class="hljs-keyword">int</span> coreSize, <span class="hljs-keyword">long</span> timeout, TimeUnit timeUnit, <span class="hljs-keyword">int</span> queueCapcity, RejectPolicy&lt;Runnable&gt; rejectPolicy)</span> </span>&#123;        <span class="hljs-keyword">this</span>.coreSize = coreSize;        <span class="hljs-keyword">this</span>.timeout = timeout;        <span class="hljs-keyword">this</span>.timeUnit = timeUnit;        <span class="hljs-keyword">this</span>.taskQueue = <span class="hljs-keyword">new</span> BlockingQueue&lt;&gt;(queueCapcity);        <span class="hljs-keyword">this</span>.rejectPolicy = rejectPolicy;    &#125;    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Worker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>&#123;        <span class="hljs-keyword">private</span> Runnable task;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Worker</span><span class="hljs-params">(Runnable task)</span> </span>&#123;            <span class="hljs-keyword">this</span>.task = task;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-comment">// 执行任务</span>            <span class="hljs-comment">// 1) 当 task 不为空，执行任务</span>            <span class="hljs-comment">// 2) 当 task 执行完毕，再接着从任务队列获取任务并执行</span><span class="hljs-comment">//            while(task != null || (task = taskQueue.take()) != null) &#123;</span>            <span class="hljs-keyword">while</span>(task != <span class="hljs-keyword">null</span> || (task = taskQueue.poll(timeout, timeUnit)) != <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-keyword">try</span> &#123;                    log.debug(<span class="hljs-string">&quot;正在执行...&#123;&#125;&quot;</span>, task);                    task.run();                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;                    e.printStackTrace();                &#125; <span class="hljs-keyword">finally</span> &#123;                    task = <span class="hljs-keyword">null</span>;                &#125;            &#125;            <span class="hljs-keyword">synchronized</span> (workers) &#123;                log.debug(<span class="hljs-string">&quot;worker 被移除&#123;&#125;&quot;</span>, <span class="hljs-keyword">this</span>);                workers.remove(<span class="hljs-keyword">this</span>);            &#125;        &#125;    &#125;&#125;</code></pre><p>步骤4：测试</p><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.TestPool&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestPool</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        ThreadPool threadPool = <span class="hljs-keyword">new</span> ThreadPool(<span class="hljs-number">2</span>,                <span class="hljs-number">1000</span>, TimeUnit.MILLISECONDS, <span class="hljs-number">2</span>, (queue, task)-&gt;&#123;            <span class="hljs-comment">// 1. 死等</span><span class="hljs-comment">//            queue.put(task);</span>            <span class="hljs-comment">// 2) 带超时等待</span><span class="hljs-comment">//            queue.offer(task, 1500, TimeUnit.MILLISECONDS);</span>            <span class="hljs-comment">// 3) 让调用者放弃任务执行</span><span class="hljs-comment">//            log.debug(&quot;放弃&#123;&#125;&quot;, task);</span>            <span class="hljs-comment">// 4) 让调用者抛出异常</span><span class="hljs-comment">//            throw new RuntimeException(&quot;任务执行失败 &quot; + task);</span>            <span class="hljs-comment">// 5) 让调用者自己执行任务</span>            task.run();        &#125;);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;            <span class="hljs-keyword">int</span> j = i;            <span class="hljs-comment">// 不能用i，i是变化的，不能被lambda表达式直接使用</span>            threadPool.execute(() -&gt; &#123;                <span class="hljs-keyword">try</span> &#123;                    Thread.sleep(<span class="hljs-number">1000L</span>);                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                &#125;                log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, j);            &#125;);        &#125;    &#125;&#125;</code></pre><pre><code class="hljs ruby"><span class="hljs-number">12</span><span class="hljs-symbol">:</span><span class="hljs-number">48</span><span class="hljs-symbol">:</span><span class="hljs-number">49</span> [main] c.ThreadPool - 新增 workerThread[Thread-<span class="hljs-number">0</span>,<span class="hljs-number">5</span>,main], com.qiuke.test7.TestPool<span class="hljs-variable">$$</span>Lambda<span class="hljs-variable">$2</span>/<span class="hljs-number">627185331</span><span class="hljs-variable">@19bb08</span>9b<span class="hljs-number">12</span><span class="hljs-symbol">:</span><span class="hljs-number">48</span><span class="hljs-symbol">:</span><span class="hljs-number">49</span> [main] c.ThreadPool - 新增 workerThread[Thread-<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,main], com.qiuke.test7.TestPool<span class="hljs-variable">$$</span>Lambda<span class="hljs-variable">$2</span>/<span class="hljs-number">627185331</span><span class="hljs-variable">@2ff4f0</span>0f<span class="hljs-number">12</span><span class="hljs-symbol">:</span><span class="hljs-number">48</span><span class="hljs-symbol">:</span><span class="hljs-number">49</span> [Thread-<span class="hljs-number">0</span>] c.ThreadPool - 正在执行...com.qiuke.test7.TestPool<span class="hljs-variable">$$</span>Lambda<span class="hljs-variable">$2</span>/<span class="hljs-number">627185331</span><span class="hljs-variable">@19bb08</span>9b<span class="hljs-number">12</span><span class="hljs-symbol">:</span><span class="hljs-number">48</span><span class="hljs-symbol">:</span><span class="hljs-number">49</span> [main] c.BlockingQueue - 加入任务队列 com.qiuke.test7.TestPool<span class="hljs-variable">$$</span>Lambda<span class="hljs-variable">$2</span>/<span class="hljs-number">627185331</span><span class="hljs-variable">@3f0ee</span>7cb<span class="hljs-number">12</span><span class="hljs-symbol">:</span><span class="hljs-number">48</span><span class="hljs-symbol">:</span><span class="hljs-number">49</span> [Thread-<span class="hljs-number">1</span>] c.ThreadPool - 正在执行...com.qiuke.test7.TestPool<span class="hljs-variable">$$</span>Lambda<span class="hljs-variable">$2</span>/<span class="hljs-number">627185331</span><span class="hljs-variable">@2ff4f0</span>0f<span class="hljs-number">12</span><span class="hljs-symbol">:</span><span class="hljs-number">48</span><span class="hljs-symbol">:</span><span class="hljs-number">49</span> [main] c.BlockingQueue - 加入任务队列 com.qiuke.test7.TestPool<span class="hljs-variable">$$</span>Lambda<span class="hljs-variable">$2</span>/<span class="hljs-number">627185331</span><span class="hljs-variable">@75bd924</span>7<span class="hljs-number">12</span><span class="hljs-symbol">:</span><span class="hljs-number">48</span><span class="hljs-symbol">:</span><span class="hljs-number">50</span> [Thread-<span class="hljs-number">0</span>] c.TestPool - <span class="hljs-number">0</span><span class="hljs-number">12</span><span class="hljs-symbol">:</span><span class="hljs-number">48</span><span class="hljs-symbol">:</span><span class="hljs-number">50</span> [Thread-<span class="hljs-number">1</span>] c.TestPool - <span class="hljs-number">1</span>[Thread[Thread-<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,main], Thread[Thread-<span class="hljs-number">0</span>,<span class="hljs-number">5</span>,main]][Thread[Thread-<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,main], Thread[Thread-<span class="hljs-number">0</span>,<span class="hljs-number">5</span>,main]]<span class="hljs-number">12</span><span class="hljs-symbol">:</span><span class="hljs-number">48</span><span class="hljs-symbol">:</span><span class="hljs-number">50</span> [Thread-<span class="hljs-number">0</span>] c.ThreadPool - 正在执行...com.qiuke.test7.TestPool<span class="hljs-variable">$$</span>Lambda<span class="hljs-variable">$2</span>/<span class="hljs-number">627185331</span><span class="hljs-variable">@75bd924</span>7<span class="hljs-number">12</span><span class="hljs-symbol">:</span><span class="hljs-number">48</span><span class="hljs-symbol">:</span><span class="hljs-number">50</span> [Thread-<span class="hljs-number">1</span>] c.ThreadPool - 正在执行...com.qiuke.test7.TestPool<span class="hljs-variable">$$</span>Lambda<span class="hljs-variable">$2</span>/<span class="hljs-number">627185331</span><span class="hljs-variable">@3f0ee</span>7cb<span class="hljs-number">12</span><span class="hljs-symbol">:</span><span class="hljs-number">48</span><span class="hljs-symbol">:</span><span class="hljs-number">51</span> [Thread-<span class="hljs-number">0</span>] c.TestPool - <span class="hljs-number">3</span><span class="hljs-number">12</span><span class="hljs-symbol">:</span><span class="hljs-number">48</span><span class="hljs-symbol">:</span><span class="hljs-number">51</span> [Thread-<span class="hljs-number">1</span>] c.TestPool - <span class="hljs-number">2</span>[Thread[Thread-<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,main], Thread[Thread-<span class="hljs-number">0</span>,<span class="hljs-number">5</span>,main]][Thread[Thread-<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,main], Thread[Thread-<span class="hljs-number">0</span>,<span class="hljs-number">5</span>,main]]<span class="hljs-number">12</span><span class="hljs-symbol">:</span><span class="hljs-number">48</span><span class="hljs-symbol">:</span><span class="hljs-number">52</span> [Thread-<span class="hljs-number">0</span>] c.ThreadPool - worker 被移除Thread[Thread-<span class="hljs-number">0</span>,<span class="hljs-number">5</span>,main]<span class="hljs-number">12</span><span class="hljs-symbol">:</span><span class="hljs-number">48</span><span class="hljs-symbol">:</span><span class="hljs-number">52</span> [Thread-<span class="hljs-number">1</span>] c.ThreadPool - worker 被移除Thread[Thread-<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,main]</code></pre><h4 id="注意点："><a href="#注意点：" class="headerlink" title="注意点："></a>注意点：</h4><ol><li><p>如果线程poll任务的时候，用的非超时时间</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210503125433.png"></p><p>当任务都执行完毕时，线程会一直等待</p></li><li><p>如果任务放入队列的时候，用的普通方法放入</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210503130136.png"></p><p>如果队列满了，<code>主线程</code>会卡住等待</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210503125705.png"></p><pre><code class="hljs ruby"><span class="hljs-number">1</span>) 死等<span class="hljs-number">2</span>) 带超时等待<span class="hljs-number">3</span>) 让调用者放弃任务执行<span class="hljs-number">4</span>) 让调用者抛出异常<span class="hljs-number">5</span>) 让调用者自己执行任务</code></pre><p>策略模式</p></li><li><p>拒绝策略</p><pre><code class="hljs java">ThreadPool threadPool = <span class="hljs-keyword">new</span> ThreadPool(<span class="hljs-number">2</span>,                <span class="hljs-number">1000</span>, TimeUnit.MILLISECONDS, <span class="hljs-number">2</span>, (queue, task)-&gt;&#123;            <span class="hljs-comment">// 1. 死等</span><span class="hljs-comment">//            queue.put(task);</span>            <span class="hljs-comment">// 2) 带超时等待</span><span class="hljs-comment">//            queue.offer(task, 1500, TimeUnit.MILLISECONDS);</span>            <span class="hljs-comment">// 3) 让调用者放弃任务执行</span><span class="hljs-comment">//            log.debug(&quot;放弃&#123;&#125;&quot;, task);</span>            <span class="hljs-comment">// 4) 让调用者抛出异常</span><span class="hljs-comment">//            throw new RuntimeException(&quot;任务执行失败 &quot; + task);</span>            <span class="hljs-comment">// 5) 让调用者自己执行任务</span>            task.run();        &#125;);</code></pre></li></ol><h3 id="7-3-ThreadPoolExecutor"><a href="#7-3-ThreadPoolExecutor" class="headerlink" title="7.3 ThreadPoolExecutor"></a>7.3 ThreadPoolExecutor</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210505091829.png"></p><p>Executor 框架结构(主要由三大部分组成</p><ol><li>任务(<code>Runnable</code> /<code>Callable</code>)</li></ol><p>执行任务需要实现的 Runnable 接口 或 Callable接口。Runnable 接口或 Callable 接口 实现类都可以被 ThreadPoolExecutor 或 ScheduledThreadPoolExecutor 执行。</p><ol start="2"><li>任务的执行(<code>Executor</code>)</li></ol><p>如上图所示，包括任务执行机制的核心接口 Executor ，以及继承自 <code>Executor</code> 接口的 ExecutorService 接口。ThreadPoolExecutor 和 ScheduledThreadPoolExecutor 这两个关键类实现了 ExecutorService 接口。</p><p>这里提了很多底层的类关系，但是，实际上我们需要更多关注的是 ThreadPoolExecutor 这个类，这个类在我们实际使用线程池的过程中，使用频率还是非常高的。</p><ol start="3"><li>异步计算的结果(<code>Future</code>)</li></ol><p>Future 接口以及 <code>Future</code> 接口的实现类 FutureTask 类都可以代表异步计算的结果。</p><p>当我们把 Runnable接口 或 Callable 接口 的实现类提交给 ThreadPoolExecutor 或 ScheduledThreadPoolExecutor 执行。（调用 <code>submit()</code> 方法时会返回一个 FutureTask 对象）</p><ol start="4"><li>Executor 框架的使用示意图</li></ol><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210505092022.png"></p><ol><li>主线程首先要创建实现 Runnable 或者 Callable 接口的任务对象。</li><li>把创建完成的实现 Runnable/Callable接口的 对象直接交给 ExecutorService 执行: <code>ExecutorService.execute（Runnable command）</code>）或者也可以把 <code>Runnable</code> 对象或<code>Callable</code> 对象提交给 <code>ExecutorService</code> 执行（<code>ExecutorService.submit（Runnable task）</code>或 <code>ExecutorService.submit（Callable &lt;T&gt; task）</code>）。</li><li>如果执行 ExecutorService.submit（…），ExecutorService 将返回一个实现Future接口的对象（我们刚刚也提到过了执行 <code>execute()</code>方法和 <code>submit()</code>方法的区别，<code>submit()</code>会返回一个 <code>FutureTask</code> 对象）。</li><li>最后，主线程可以执行 FutureTask.get()方法来等待任务执行完成。主线程也可以执行 FutureTask.cancel（boolean mayInterruptIfRunning）来取消此任务的执行</li></ol><h4 id="1-线程池状态"><a href="#1-线程池状态" class="headerlink" title="1) 线程池状态"></a>1) 线程池状态</h4><p>ThreadPoolExecutor 使用 int 的 <code>高 3 位</code>来表示<code>线程池状态</code>，<code>低 29 位</code>表示<code>线程数量</code></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210505092230.png"></p><p>从数字上比较(<code>第一位是符号位</code>)，TERMINATED &gt; TIDYING &gt; STOP &gt; SHUTDOWN &gt; RUNNING 这些信息存储在一个<code>原子变量 ctl 中</code>，目的是将线程池状态与线程个数合二为一，这样就可以用一次 cas 原子操作 进行赋值</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicInteger ctl = <span class="hljs-keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="hljs-number">0</span>));<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="hljs-number">3</span>;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CAPACITY   = (<span class="hljs-number">1</span> &lt;&lt; COUNT_BITS) - <span class="hljs-number">1</span>;<span class="hljs-comment">// runState is stored in the high-order bits</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> RUNNING    = -<span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SHUTDOWN   =  <span class="hljs-number">0</span> &lt;&lt; COUNT_BITS;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> STOP       =  <span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> TIDYING    =  <span class="hljs-number">2</span> &lt;&lt; COUNT_BITS;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> TERMINATED =  <span class="hljs-number">3</span> &lt;&lt; COUNT_BITS;</code></pre><p>保证状态信息和线程数量的<code>原子性</code>， 不进行两次cas，直接一次。</p><pre><code class="hljs java"><span class="hljs-comment">// c 为旧值， ctlOf 返回结果为新值</span>ctl.compareAndSet(c, ctlOf(targetState, workerCountOf(c))));<span class="hljs-comment">// rs 为高 3 位代表线程池状态， wc 为低 29 位代表线程个数，ctl 是合并它们</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">ctlOf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rs, <span class="hljs-keyword">int</span> wc)</span> </span>&#123; <span class="hljs-keyword">return</span> rs | wc; &#125;</code></pre><p>线程池属性：</p><pre><code class="hljs java"><span class="hljs-comment">// 工作线程，内部封装了Thread</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Worker</span></span><span class="hljs-class">        <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractQueuedSynchronizer</span></span><span class="hljs-class">        <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;    ...&#125;<span class="hljs-comment">// 阻塞队列，用于存放来不及被核心线程执行的任务</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;<span class="hljs-comment">// 锁</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">new</span> ReentrantLock();<span class="hljs-comment">//  用于存放核心线程的容器，只有当持有锁时才能够获取其中的元素（核心线程）</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="hljs-keyword">new</span> HashSet&lt;Worker&gt;();</code></pre><h4 id="2-构造方法"><a href="#2-构造方法" class="headerlink" title="2) 构造方法"></a>2) 构造方法</h4><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize,</span></span><span class="hljs-function"><span class="hljs-params">   <span class="hljs-keyword">int</span> maximumPoolSize,</span></span><span class="hljs-function"><span class="hljs-params">   <span class="hljs-keyword">long</span> keepAliveTime,</span></span><span class="hljs-function"><span class="hljs-params">   TimeUnit unit,</span></span><span class="hljs-function"><span class="hljs-params">   BlockingQueue&lt;Runnable&gt; workQueue,</span></span><span class="hljs-function"><span class="hljs-params">   ThreadFactory threadFactory,</span></span><span class="hljs-function"><span class="hljs-params">  RejectedExecutionHandler handler)</span></span>&#123;&#125;</code></pre><ol><li>corePoolSize 核心线程数目 (最多保留的线程数)</li><li>maximumPoolSize 最大线程数目(核心线程数加上救急线程数)</li><li>keepAliveTime 救急线程的生存时间(核心线程没有生存时间这个东西，核心线程会一直运行)</li><li>unit 时间单位 - 针对救急线程</li><li>workQueue 阻塞队列</li><li>threadFactory 线程工厂 - （可以为线程创建时起个好名字）</li><li>handler 拒绝策略</li></ol><p>工作方式：</p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210505093142.png" style="zoom:50%;" /><p>救急线程数 = 最大 - 核心</p><ol><li>线程池中刚开始没有线程，当一个任务提交给线程池后，线程池会 <strong>创建一个新线程来执行任务</strong>。</li><li>当线程数达到  <strong>corePoolSize</strong>  并没有线程空闲，这时再加入任务，新加的任务会被加入 <strong>workQueue</strong>  队列排 队，直到有空闲的线程。</li><li>如果队列选择了 <strong>有界队列</strong> ，那么任务超过了队列大小时，会创建  <strong>maximumPoolSize - corePoolSize</strong>  数目的线程来救急。 ( 标准 <strong>无界队列</strong> 不存在救急线程 )</li><li>如果线程到达 maximumPoolSize 仍然有新任务这时会执行 <strong>拒绝策略</strong> 。拒绝策略 jdk 提供了 下面的前4 种实现，其它著名框架也提供了实现<ol><li>ThreadPoolExecutor.AbortPolicy让调用者抛出 RejectedExecutionException 异常，这是默认策略</li><li>ThreadPoolExecutor.CallerRunsPolicy 让调用者运行任务</li><li>ThreadPoolExecutor.DiscardPolicy 放弃本次任务</li><li>ThreadPoolExecutor.DiscardOldestPolicy 放弃队列中最早的任务，本任务取而代之</li><li> <strong>Dubbo 的实现</strong> ，在抛出 RejectedExecutionException 异常之前会记录日志，并 dump 线程栈信息，方 便定位问题</li><li> <strong>Netty 的实现</strong> ，是创建一个新线程来执行任务</li><li> <strong>ActiveMQ 的实现</strong> ，带超时等待（60s）尝试放入队列，类似我们之前自定义的拒绝策略</li><li> <strong>PinPoint 的实现</strong> ，它使用了一个拒绝策略链，会逐一尝试策略链中每种拒绝策略</li></ol></li><li>当高峰过去后，超过corePoolSize 的救急线程如果一段时间没有任务做，需要结束节省资源，这个时间由 <strong>keepAliveTime 和 unit</strong>  来控制。</li></ol><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210505093519.png"></p><p>根据这个构造方法，JDK Executors 类中提供了众多工厂方法来创建各种用途的线程池</p><h4 id="3-newFixedThreadPool"><a href="#3-newFixedThreadPool" class="headerlink" title="3) newFixedThreadPool"></a>3) newFixedThreadPool</h4><p>这个是 <code>Executors 类</code> 提供的<code>静态的工厂方法</code>来创建线程池！Executors 是 Executor 框架的工具类，newFixedThreadPool 创建的是固定大小的线程池。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newFixedThreadPool</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nThreads)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,                                      <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,                                      <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());    &#125;</code></pre><p>通过源码可以看到 new ThreadPoolExecutor(xxx)方法其实是是调用了之前说的完整参数的构造方法，使用了默认的线程工厂和拒绝策略!</p><p>特点</p><ul><li><p>核心线程数 == 最大线程数（ <strong>没有救急线程被创建</strong> ），因此也无需超时时间</p></li><li><p>阻塞队列是 <strong>无界的</strong> ，可以放任意数量的任务</p></li><li><p>适用于 <strong>任务量已知，相对耗时的任务</strong> </p></li></ul><h4 id="4-newCachedThreadPool"><a href="#4-newCachedThreadPool" class="headerlink" title="4) newCachedThreadPool"></a>4) newCachedThreadPool</h4><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newCachedThreadPool</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">0</span>, Integer.MAX_VALUE, <span class="hljs-comment">// 只要不超过MAX，全都是救急线程</span> <span class="hljs-number">60L</span>, TimeUnit.SECONDS, <span class="hljs-keyword">new</span> SynchronousQueue&lt;Runnable&gt;()); <span class="hljs-comment">// 同步队列</span>&#125;</code></pre><p>特点</p><ol><li>核心线程数是 0， 最大线程数是 Integer.MAX_VALUE，救急线程的空闲生存时间是 60s，意味着<ol><li><code>全部都是救急线程（60s 后可以回收）</code></li><li><code>救急线程</code>可以<code>无限创建</code></li></ol></li><li>队列采用了 <code>SynchronousQueue</code> 实现特点是，它<code>没有容量</code>， <strong>没有线程来取是放不进去的（一手交钱、一手交货 ）</strong> </li><li>整个线程池表现为线程数会根据任务量不断增长，没有上限，当任务执行完毕，空闲 1分钟后释放线 程。 适合 <strong>任务数比较密集，但每个任务执行时间较短</strong> 的情况</li></ol><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.TestSynchronousQueue&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestSynchronousQueue</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SynchronousQueue&lt;Integer&gt; integers = <span class="hljs-keyword">new</span> SynchronousQueue&lt;&gt;();        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            <span class="hljs-keyword">try</span> &#123;                log.debug(<span class="hljs-string">&quot;putting &#123;&#125; &quot;</span>, <span class="hljs-number">1</span>);                integers.put(<span class="hljs-number">1</span>);                log.debug(<span class="hljs-string">&quot;&#123;&#125; putted...&quot;</span>, <span class="hljs-number">1</span>);                log.debug(<span class="hljs-string">&quot;putting...&#123;&#125; &quot;</span>, <span class="hljs-number">2</span>);                integers.put(<span class="hljs-number">2</span>);                log.debug(<span class="hljs-string">&quot;&#123;&#125; putted...&quot;</span>, <span class="hljs-number">2</span>);            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;,<span class="hljs-string">&quot;t1&quot;</span>).start();        sleep(<span class="hljs-number">1</span>);        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            <span class="hljs-keyword">try</span> &#123;                log.debug(<span class="hljs-string">&quot;taking &#123;&#125;&quot;</span>, <span class="hljs-number">1</span>);                integers.take();            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;,<span class="hljs-string">&quot;t2&quot;</span>).start();        sleep(<span class="hljs-number">1</span>);        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            <span class="hljs-keyword">try</span> &#123;                log.debug(<span class="hljs-string">&quot;taking &#123;&#125;&quot;</span>, <span class="hljs-number">2</span>);                integers.take();            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;,<span class="hljs-string">&quot;t3&quot;</span>).start();    &#125;&#125;</code></pre><pre><code class="hljs js"><span class="hljs-number">09</span>:<span class="hljs-number">55</span>:<span class="hljs-number">29</span> [t1] c.TestSynchronousQueue - putting <span class="hljs-number">1</span> <span class="hljs-number">09</span>:<span class="hljs-number">55</span>:<span class="hljs-number">30</span> [t2] c.TestSynchronousQueue - taking <span class="hljs-number">1</span><span class="hljs-number">09</span>:<span class="hljs-number">55</span>:<span class="hljs-number">30</span> [t1] c.TestSynchronousQueue - <span class="hljs-number">1</span> putted...<span class="hljs-number">09</span>:<span class="hljs-number">55</span>:<span class="hljs-number">30</span> [t1] c.TestSynchronousQueue - putting..<span class="hljs-number">.2</span> <span class="hljs-number">09</span>:<span class="hljs-number">55</span>:<span class="hljs-number">31</span> [t3] c.TestSynchronousQueue - taking <span class="hljs-number">2</span><span class="hljs-number">09</span>:<span class="hljs-number">55</span>:<span class="hljs-number">31</span> [t1] c.TestSynchronousQueue - <span class="hljs-number">2</span> putted...<span class="hljs-comment">// 必须有一个存进去，才能取出来</span></code></pre><h4 id="5）newSingleThreadExecutor"><a href="#5）newSingleThreadExecutor" class="headerlink" title="5）newSingleThreadExecutor"></a>5）newSingleThreadExecutor</h4><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newSingleThreadExecutor</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FinalizableDelegatedExecutorService (<span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>,<span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));&#125;</code></pre><p>使用场景：</p><ul><li><p>希望多个任务排队执行（ <strong>串行</strong> ）。线程数固定为 1，任务数多于 1 时，会放入 <strong>无界队列</strong> 排队。任务执行完毕，这唯一的线程也不会被释放。</p></li><li><p>区别：</p></li></ul><ol><li>和自己创建单线程执行任务的区别：自己创建一个单线程串行执行任务，如果任务执行失败而终止那么没有任何补救措施，而 <strong>线程池还会新建一个线程，保证池的正常工作</strong> </li><li>Executors.newSingleThreadExecutor() 线程个数始终为1，不能修改<ol><li>FinalizableDelegatedExecutorService 应用的是 <strong>装饰器模式</strong> ，<code>只对外暴露了 ExecutorService 接口</code>，因此不能调用 ThreadPoolExecutor 中特有的方法</li></ol></li><li>和Executors.newFixedThreadPool(1) 初始时为1时的区别：Executors.newFixedThreadPool(1) 初始时为1，以后还可以修改，<strong>对外暴露的是 ThreadPoolExecutor 对象</strong> ， <strong>可以强转后调用 setCorePoolSize</strong>  等方法进行修改</li></ol><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> </span>&#123;    ExecutorService pool = Executors.newSingleThreadExecutor();    pool.execute(() -&gt; &#123;        log.debug(<span class="hljs-string">&quot;1&quot;</span>);        <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span> / <span class="hljs-number">0</span>;    &#125;);    pool.execute(() -&gt; &#123;        log.debug(<span class="hljs-string">&quot;2&quot;</span>);    &#125;);    pool.execute(() -&gt; &#123;        log.debug(<span class="hljs-string">&quot;3&quot;</span>);    &#125;);&#125;</code></pre><pre><code class="hljs js"><span class="hljs-number">10</span>:<span class="hljs-number">00</span>:<span class="hljs-number">07</span> [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>] c.TestExecutors - <span class="hljs-number">1</span><span class="hljs-number">10</span>:<span class="hljs-number">00</span>:<span class="hljs-number">07</span> [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span>] c.TestExecutors - <span class="hljs-number">2</span>Exception <span class="hljs-keyword">in</span> thread <span class="hljs-string">&quot;pool-1-thread-1&quot;</span> <span class="hljs-number">10</span>:<span class="hljs-number">00</span>:<span class="hljs-number">07</span> [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span>] c.TestExecutors - <span class="hljs-number">3</span>java.lang.ArithmeticException: / by zero    at com.qiuke.test7.TestExecutors.lambda$test2$0(TestExecutors.java:<span class="hljs-number">20</span>)    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:<span class="hljs-number">1149</span>)    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:<span class="hljs-number">624</span>)    at java.lang.Thread.run(Thread.java:<span class="hljs-number">748</span>)<span class="hljs-comment">// 不会影响其他任务的执行</span></code></pre><blockquote><p>Executors 返回线程池对象的弊端如下：</p><ul><li>FixedThreadPool 和 SingleThreadExecutor ： 允许请求的 <strong>队列长度</strong> 为 Integer.MAX_VALUE,可能堆积大量的请求，从而导致 OOM。</li><li>CachedThreadPool 和 ScheduledThreadPool ： 允许创建的 <strong>线程数量</strong> 为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致 OOM。</li></ul></blockquote><p>说白了就是：使用有界队列，控制线程创建数量。</p><p>除了避免 OOM 的原因之外，不推荐使用 <code>Executors</code>提供的两种快捷的线程池的原因还有：</p><ol><li>实际使用中需要根据自己机器的性能、业务场景来手动配置线程池的参数比如核心线程数、使用的任务队列、饱和策略等等。</li><li>我们应该显示地给我们的线程池命名，这样有助于我们定位问题。</li></ol><h4 id="6-submit"><a href="#6-submit" class="headerlink" title="6) submit"></a>6) submit</h4><pre><code class="hljs java"><span class="hljs-comment">// 执行任务</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Runnable command)</span></span>;<span class="hljs-comment">// 提交任务 task，用返回值 Future 获得任务执行结果，Future的原理就是利用我们之前讲到的保护性暂停模式来接受返回结果的，主线程可以执行 FutureTask.get()方法来等待任务执行完成</span><span class="hljs-comment">// Callable比Runnable多返回结果</span>&lt;T&gt; <span class="hljs-function">Future&lt;T&gt; <span class="hljs-title">submit</span><span class="hljs-params">(Callable&lt;T&gt; task)</span></span>;<span class="hljs-comment">// 提交 tasks 中所有任务</span>&lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks) <span class="hljs-keyword">throws</span> InterruptedException;<span class="hljs-comment">// 提交 tasks 中所有任务，带超时时间</span>&lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, <span class="hljs-keyword">long</span> timeout, TimeUnit unit) <span class="hljs-keyword">throws</span> InterruptedException;<span class="hljs-comment">// 提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消</span>&lt;T&gt; <span class="hljs-function">T <span class="hljs-title">invokeAny</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span><span class="hljs-function"> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException</span>;<span class="hljs-comment">// 提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消，带超时时间</span>&lt;T&gt; <span class="hljs-function">T <span class="hljs-title">invokeAny</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span><span class="hljs-function"><span class="hljs-params"> <span class="hljs-keyword">long</span> timeout, TimeUnit unit)</span></span><span class="hljs-function"> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</code></pre><p>测试：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method3</span><span class="hljs-params">(ExecutorService pool)</span> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException </span>&#123;    String result = pool.invokeAny(Arrays.asList(            () -&gt; &#123;                log.debug(<span class="hljs-string">&quot;begin 1&quot;</span>);                Thread.sleep(<span class="hljs-number">1000</span>);                log.debug(<span class="hljs-string">&quot;end 1&quot;</span>);                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;1&quot;</span>;            &#125;,            () -&gt; &#123;                log.debug(<span class="hljs-string">&quot;begin 2&quot;</span>);                Thread.sleep(<span class="hljs-number">500</span>);                log.debug(<span class="hljs-string">&quot;end 2&quot;</span>);                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;2&quot;</span>;            &#125;,            () -&gt; &#123;                log.debug(<span class="hljs-string">&quot;begin 3&quot;</span>);                Thread.sleep(<span class="hljs-number">2000</span>);                log.debug(<span class="hljs-string">&quot;end 3&quot;</span>);                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;3&quot;</span>;            &#125;    ));    log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, result);&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">(ExecutorService pool)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;    List&lt;Future&lt;String&gt;&gt; futures = pool.invokeAll(Arrays.asList(            () -&gt; &#123;                log.debug(<span class="hljs-string">&quot;begin&quot;</span>);                Thread.sleep(<span class="hljs-number">1000</span>);                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;1&quot;</span>;            &#125;,            () -&gt; &#123;                log.debug(<span class="hljs-string">&quot;begin&quot;</span>);                Thread.sleep(<span class="hljs-number">500</span>);                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;2&quot;</span>;            &#125;,            () -&gt; &#123;                log.debug(<span class="hljs-string">&quot;begin&quot;</span>);                Thread.sleep(<span class="hljs-number">2000</span>);                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;3&quot;</span>;            &#125;    ));    futures.forEach( f -&gt;  &#123;        <span class="hljs-keyword">try</span> &#123;            log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, f.get());        &#125; <span class="hljs-keyword">catch</span> (InterruptedException | ExecutionException e) &#123;            e.printStackTrace();        &#125;    &#125;);&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">(ExecutorService pool)</span> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException </span>&#123;    Future&lt;String&gt; future = pool.submit(() -&gt; &#123;        log.debug(<span class="hljs-string">&quot;running&quot;</span>);        Thread.sleep(<span class="hljs-number">1000</span>);        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;ok&quot;</span>;    &#125;);    log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, future.get());&#125;</code></pre><pre><code class="hljs ruby"><span class="hljs-number">10</span><span class="hljs-symbol">:</span><span class="hljs-number">14</span><span class="hljs-symbol">:</span><span class="hljs-number">34</span> [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>] c.TestSubmit - running<span class="hljs-number">10</span><span class="hljs-symbol">:</span><span class="hljs-number">14</span><span class="hljs-symbol">:</span><span class="hljs-number">35</span> [main] c.TestSubmit - ok---------------------------<span class="hljs-number">10</span><span class="hljs-symbol">:</span><span class="hljs-number">14</span><span class="hljs-symbol">:</span><span class="hljs-number">35</span> [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>] c.TestSubmit - <span class="hljs-keyword">begin</span><span class="hljs-number">10</span><span class="hljs-symbol">:</span><span class="hljs-number">14</span><span class="hljs-symbol">:</span><span class="hljs-number">36</span> [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>] c.TestSubmit - <span class="hljs-keyword">begin</span><span class="hljs-number">10</span><span class="hljs-symbol">:</span><span class="hljs-number">14</span><span class="hljs-symbol">:</span><span class="hljs-number">37</span> [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>] c.TestSubmit - <span class="hljs-keyword">begin</span><span class="hljs-number">10</span><span class="hljs-symbol">:</span><span class="hljs-number">14</span><span class="hljs-symbol">:</span><span class="hljs-number">39</span> [main] c.TestSubmit - <span class="hljs-number">1</span><span class="hljs-number">10</span><span class="hljs-symbol">:</span><span class="hljs-number">14</span><span class="hljs-symbol">:</span><span class="hljs-number">39</span> [main] c.TestSubmit - <span class="hljs-number">2</span><span class="hljs-number">10</span><span class="hljs-symbol">:</span><span class="hljs-number">14</span><span class="hljs-symbol">:</span><span class="hljs-number">39</span> [main] c.TestSubmit - <span class="hljs-number">3</span>---------------------------<span class="hljs-number">10</span><span class="hljs-symbol">:</span><span class="hljs-number">14</span><span class="hljs-symbol">:</span><span class="hljs-number">39</span> [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>] c.TestSubmit - <span class="hljs-keyword">begin</span> <span class="hljs-number">1</span><span class="hljs-number">10</span><span class="hljs-symbol">:</span><span class="hljs-number">14</span><span class="hljs-symbol">:</span><span class="hljs-number">40</span> [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>] c.TestSubmit - <span class="hljs-keyword">end</span> <span class="hljs-number">1</span><span class="hljs-number">10</span><span class="hljs-symbol">:</span><span class="hljs-number">14</span><span class="hljs-symbol">:</span><span class="hljs-number">40</span> [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>] c.TestSubmit - <span class="hljs-keyword">begin</span> <span class="hljs-number">2</span><span class="hljs-number">10</span><span class="hljs-symbol">:</span><span class="hljs-number">14</span><span class="hljs-symbol">:</span><span class="hljs-number">40</span> [main] c.TestSubmit - <span class="hljs-number">1</span></code></pre><h4 id="7-关闭线程池"><a href="#7-关闭线程池" class="headerlink" title="7) 关闭线程池"></a>7) 关闭线程池</h4><ul><li>shutdown</li></ul><pre><code class="hljs Java"><span class="hljs-comment">/*</span><span class="hljs-comment">线程池状态变为 SHUTDOWN</span><span class="hljs-comment">- 不会接收新任务</span><span class="hljs-comment">- 但已提交任务会执行完，包括等待队列里面的</span><span class="hljs-comment">- 此方法不会阻塞调用线程的执行</span><span class="hljs-comment">*/</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">shutdown</span><span class="hljs-params">()</span></span>;</code></pre><p>不会阻塞调用线程的执行；</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shutdown</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;        mainLock.lock();        <span class="hljs-keyword">try</span> &#123;            checkShutdownAccess();            <span class="hljs-comment">// 修改线程池状态</span>            advanceRunState(SHUTDOWN);            <span class="hljs-comment">// 仅会打断空闲线程</span>            interruptIdleWorkers();            onShutdown(); <span class="hljs-comment">// 扩展点 ScheduledThreadPoolExecutor</span>        &#125; <span class="hljs-keyword">finally</span> &#123;            mainLock.unlock();        &#125;        <span class="hljs-comment">// 尝试终结(没有运行的线程可以立刻终结)</span>        tryTerminate();    &#125;</code></pre><ul><li>shutdownNow</li></ul><pre><code class="hljs java"><span class="hljs-comment">/*</span><span class="hljs-comment">线程池状态变为 STOP</span><span class="hljs-comment">- 不会接收新任务</span><span class="hljs-comment">- 会将队列中的任务返回</span><span class="hljs-comment">- 并用 interrupt 的方式中断正在执行的任务</span><span class="hljs-comment">*/</span><span class="hljs-function">List&lt;Runnable&gt; <span class="hljs-title">shutdownNow</span><span class="hljs-params">()</span></span>;</code></pre><p>用 interrupt 的方式中断正在执行的任务</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Runnable&gt; <span class="hljs-title">shutdownNow</span><span class="hljs-params">()</span> </span>&#123;        List&lt;Runnable&gt; tasks;        <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;        mainLock.lock();        <span class="hljs-keyword">try</span> &#123;            checkShutdownAccess();            <span class="hljs-comment">// 修改线程池状态</span>            advanceRunState(STOP);            <span class="hljs-comment">// 打断所有线程</span>            interruptWorkers();            <span class="hljs-comment">// 获取队列中剩余任务</span>            tasks = drainQueue();        &#125; <span class="hljs-keyword">finally</span> &#123;            mainLock.unlock();        &#125;        <span class="hljs-comment">// 尝试终结</span>        tryTerminate();        <span class="hljs-keyword">return</span> tasks;    &#125;</code></pre><ul><li>其他</li></ul><pre><code class="hljs java"><span class="hljs-comment">// 不在 RUNNING 状态的线程池，此方法就返回 true</span><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isShutdown</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">// 线程池状态是否是 TERMINATED</span><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isTerminated</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">// 调用 shutdown 后，由于调用使线程结束线程的方法是异步的并不会等待所有任务运行结束就返回，因此如果它想在线程池 TERMINATED 后做些其它事情，可以利用此方法等待</span><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">awaitTermination</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException</span>;</code></pre><h5 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h5><pre><code class="hljs java">ExecutorService pool = Executors.newFixedThreadPool(<span class="hljs-number">2</span>);Future&lt;Integer&gt; result1 = pool.submit(() -&gt; &#123;    log.debug(<span class="hljs-string">&quot;task 1 running...&quot;</span>);    Thread.sleep(<span class="hljs-number">1000</span>);    log.debug(<span class="hljs-string">&quot;task 1 finish...&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;);Future&lt;Integer&gt; result2 = pool.submit(() -&gt; &#123;    log.debug(<span class="hljs-string">&quot;task 2 running...&quot;</span>);    Thread.sleep(<span class="hljs-number">1000</span>);    log.debug(<span class="hljs-string">&quot;task 2 finish...&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;&#125;);Future&lt;Integer&gt; result3 = pool.submit(() -&gt; &#123;    log.debug(<span class="hljs-string">&quot;task 3 running...&quot;</span>);    Thread.sleep(<span class="hljs-number">1000</span>);    log.debug(<span class="hljs-string">&quot;task 3 finish...&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;&#125;);</code></pre><p> <strong>shutdown</strong> </p><pre><code class="hljs ruby"><span class="hljs-number">10</span><span class="hljs-symbol">:</span><span class="hljs-number">49</span><span class="hljs-symbol">:</span><span class="hljs-number">17</span> [main] c.TestShutDown - shutdown<span class="hljs-number">10</span><span class="hljs-symbol">:</span><span class="hljs-number">49</span><span class="hljs-symbol">:</span><span class="hljs-number">17</span> [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>] c.TestShutDown - task <span class="hljs-number">1</span> running...<span class="hljs-number">10</span><span class="hljs-symbol">:</span><span class="hljs-number">49</span><span class="hljs-symbol">:</span><span class="hljs-number">17</span> [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span>] c.TestShutDown - task <span class="hljs-number">2</span> running...<span class="hljs-number">10</span><span class="hljs-symbol">:</span><span class="hljs-number">49</span><span class="hljs-symbol">:</span><span class="hljs-number">19</span> [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span>] c.TestShutDown - task <span class="hljs-number">2</span> finish...<span class="hljs-number">10</span><span class="hljs-symbol">:</span><span class="hljs-number">49</span><span class="hljs-symbol">:</span><span class="hljs-number">19</span> [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>] c.TestShutDown - task <span class="hljs-number">1</span> finish...<span class="hljs-number">10</span><span class="hljs-symbol">:</span><span class="hljs-number">49</span><span class="hljs-symbol">:</span><span class="hljs-number">19</span> [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>] c.TestShutDown - task <span class="hljs-number">3</span> running...<span class="hljs-number">10</span><span class="hljs-symbol">:</span><span class="hljs-number">49</span><span class="hljs-symbol">:</span><span class="hljs-number">20</span> [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>] c.TestShutDown - task <span class="hljs-number">3</span> finish...</code></pre><p> 如果在shutdown之后又加一个任务：</p><pre><code class="hljs java">log.debug(<span class="hljs-string">&quot;shutdown&quot;</span>);pool.shutdown();Future&lt;Integer&gt; result4 = pool.submit(() -&gt; &#123;    log.debug(<span class="hljs-string">&quot;task 3 running...&quot;</span>);    Thread.sleep(<span class="hljs-number">1000</span>);    log.debug(<span class="hljs-string">&quot;task 3 finish...&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>;&#125;);</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210505105113.png"></p><p>调用完后也不会阻塞main线程执行：</p><pre><code class="hljs java">log.debug(<span class="hljs-string">&quot;shutdown&quot;</span>);pool.shutdown();log.debug(<span class="hljs-string">&quot;main...&quot;</span>);</code></pre><pre><code class="hljs java"><span class="hljs-number">10</span>:<span class="hljs-number">52</span>:<span class="hljs-number">22</span> [main] c.TestShutDown - shutdown<span class="hljs-number">10</span>:<span class="hljs-number">52</span>:<span class="hljs-number">22</span> [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span>] c.TestShutDown - task <span class="hljs-number">2</span> running...<span class="hljs-number">10</span>:<span class="hljs-number">52</span>:<span class="hljs-number">22</span> [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>] c.TestShutDown - task <span class="hljs-number">1</span> running...<span class="hljs-number">10</span>:<span class="hljs-number">52</span>:<span class="hljs-number">22</span> [main] c.TestShutDown - main...</code></pre><p>会立刻执行main</p><p>如果需要等怎么办？</p><p> <strong>awaitTermination</strong> </p><pre><code class="hljs java">log.debug(<span class="hljs-string">&quot;shutdown&quot;</span>);        <span class="hljs-comment">//pool.shutdown();</span>        pool.awaitTermination(<span class="hljs-number">3</span>, TimeUnit.SECONDS);        log.debug(<span class="hljs-string">&quot;main...&quot;</span>);</code></pre><pre><code class="hljs java"><span class="hljs-number">10</span>:<span class="hljs-number">53</span>:<span class="hljs-number">22</span> [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>] c.TestShutDown - task <span class="hljs-number">1</span> running...<span class="hljs-number">10</span>:<span class="hljs-number">53</span>:<span class="hljs-number">22</span> [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span>] c.TestShutDown - task <span class="hljs-number">2</span> running...<span class="hljs-number">10</span>:<span class="hljs-number">53</span>:<span class="hljs-number">22</span> [main] c.TestShutDown - shutdown<span class="hljs-number">10</span>:<span class="hljs-number">53</span>:<span class="hljs-number">23</span> [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>] c.TestShutDown - task <span class="hljs-number">1</span> finish...<span class="hljs-number">10</span>:<span class="hljs-number">53</span>:<span class="hljs-number">23</span> [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span>] c.TestShutDown - task <span class="hljs-number">2</span> finish...<span class="hljs-number">10</span>:<span class="hljs-number">53</span>:<span class="hljs-number">23</span> [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span>] c.TestShutDown - task <span class="hljs-number">3</span> running...<span class="hljs-number">10</span>:<span class="hljs-number">53</span>:<span class="hljs-number">24</span> [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span>] c.TestShutDown - task <span class="hljs-number">3</span> finish...<span class="hljs-number">10</span>:<span class="hljs-number">53</span>:<span class="hljs-number">25</span> [main] c.TestShutDown - main...</code></pre><p> **shutDownNow ** </p><pre><code class="hljs java">List&lt;Runnable&gt; runnables = pool.shutdownNow();log.debug(<span class="hljs-string">&quot;other.... &#123;&#125;&quot;</span> , runnables);</code></pre><pre><code class="hljs ruby"><span class="hljs-number">10</span><span class="hljs-symbol">:</span><span class="hljs-number">55</span><span class="hljs-symbol">:</span><span class="hljs-number">23</span> [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>] c.TestShutDown - task <span class="hljs-number">1</span> running...<span class="hljs-number">10</span><span class="hljs-symbol">:</span><span class="hljs-number">55</span><span class="hljs-symbol">:</span><span class="hljs-number">23</span> [main] c.TestShutDown - shutdown<span class="hljs-number">10</span><span class="hljs-symbol">:</span><span class="hljs-number">55</span><span class="hljs-symbol">:</span><span class="hljs-number">23</span> [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span>] c.TestShutDown - task <span class="hljs-number">2</span> running...<span class="hljs-number">10</span><span class="hljs-symbol">:</span><span class="hljs-number">55</span><span class="hljs-symbol">:</span><span class="hljs-number">23</span> [main] c.TestShutDown - other.... [java.util.concurrent.FutureTask<span class="hljs-variable">@23223dd8</span>]</code></pre><h4 id="8-异步模式之工作线程"><a href="#8-异步模式之工作线程" class="headerlink" title="8) 异步模式之工作线程"></a>8) 异步模式之工作线程</h4><h5 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h5><p>让有限的工作线程（ <code>Worker Thread</code> ）来 <code>轮流异步处理</code> 无限多的任务。也可以将其归类为 <code>分工模式</code>，它的典型实现就是线程池，也体现了经典设计模式中的享元模式。</p><p>例如，海底捞的服务员（线程），轮流处理每位客人的点餐（任务），如果为每位客人都配一名专属的服务员，那么成本就太高了（对比另一种多线程设计模式：Thread-Per-Message）<br>注意，不同任务类型应该使用不同的线程池，这样能够避免饥饿，并能提升效率例如，如果一个餐馆的工人既要招呼客人（任务类型A），又要到后厨做菜（任务类型B）显然效率不咋地，分成服务员（线程池A）与厨师（线程池B）更为合理，当然你能想到更细致的分工</p><h5 id="2-饥饿"><a href="#2-饥饿" class="headerlink" title="2. 饥饿"></a>2. 饥饿</h5><p>固定大小线程池会有饥饿现象</p><ul><li>两个工人是同一个线程池中的 <strong>两个线程</strong> </li><li>他们要做的事情是：为 <strong>客人点餐</strong> 和到 <strong>后厨做菜</strong> ，这是两个阶段的工作<ul><li>客人点餐：必须先点完餐，等菜做好，上菜，在此期间处理点餐的工人必须等待</li><li>后厨做菜：没啥说的，做就是了</li></ul></li><li>比如工人A 处理了点餐任务，接下来它要等着 工人B 把菜做好，然后上菜，他俩也配合的蛮好<br>但现在同时来了两个客人，这个时候工人A 和工人B 都去处理点餐了，这时没人做饭了，饥饿</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testStarvation</span><span class="hljs-params">(ExecutorService executorService)</span></span>&#123;    <span class="hljs-comment">//ExecutorService executorService = Executors.newFixedThreadPool(2);</span>    executorService.execute(() -&gt; &#123;        log.debug(<span class="hljs-string">&quot;处理点餐...&quot;</span>);        Future&lt;String&gt; f = executorService.submit(() -&gt; &#123;            log.debug(<span class="hljs-string">&quot;做菜&quot;</span>);            <span class="hljs-keyword">return</span> cooking();        &#125;);        <span class="hljs-keyword">try</span> &#123;            log.debug(<span class="hljs-string">&quot;上菜: &#123;&#125;&quot;</span>, f.get());        &#125; <span class="hljs-keyword">catch</span> (InterruptedException | ExecutionException e) &#123;            e.printStackTrace();        &#125;    &#125;);    executorService.execute(() -&gt; &#123;        log.debug(<span class="hljs-string">&quot;处理点餐...&quot;</span>);        Future&lt;String&gt; f = executorService.submit(() -&gt; &#123;            log.debug(<span class="hljs-string">&quot;做菜&quot;</span>);            <span class="hljs-keyword">return</span> cooking();        &#125;);        <span class="hljs-keyword">try</span> &#123;            log.debug(<span class="hljs-string">&quot;上菜: &#123;&#125;&quot;</span>, f.get());        &#125; <span class="hljs-keyword">catch</span> (InterruptedException | ExecutionException e) &#123;            e.printStackTrace();        &#125;    &#125;);&#125;</code></pre><pre><code class="hljs ruby"><span class="hljs-number">11</span><span class="hljs-symbol">:</span><span class="hljs-number">16</span><span class="hljs-symbol">:</span><span class="hljs-number">38</span> [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span>] c.TestDeadLock - 处理点餐...<span class="hljs-number">11</span><span class="hljs-symbol">:</span><span class="hljs-number">16</span><span class="hljs-symbol">:</span><span class="hljs-number">38</span> [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>] c.TestDeadLock - 处理点餐...</code></pre><p>如果只有一个客人，把一个execute删除掉：</p><pre><code class="hljs java"><span class="hljs-number">11</span>:<span class="hljs-number">18</span>:<span class="hljs-number">23</span> [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>] c.TestDeadLock - 处理点餐...<span class="hljs-number">11</span>:<span class="hljs-number">18</span>:<span class="hljs-number">23</span> [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span>] c.TestDeadLock - 做菜<span class="hljs-number">11</span>:<span class="hljs-number">18</span>:<span class="hljs-number">23</span> [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>] c.TestDeadLock - 上菜: 地三鲜  <span class="hljs-comment">// 配合很好</span></code></pre><p>饥饿现象不是死锁！</p><h5 id="3-解决饥饿"><a href="#3-解决饥饿" class="headerlink" title="3. 解决饥饿"></a>3. 解决饥饿</h5><p>解决方法可以增加线程池的大小，不过不是根本解决方案，还是前面提到的，不同的任务类型，采用不同的线程池；</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rightDemo</span><span class="hljs-params">()</span> </span>&#123;    ExecutorService waiterPool = Executors.newFixedThreadPool(<span class="hljs-number">1</span>);    ExecutorService cookPool = Executors.newFixedThreadPool(<span class="hljs-number">1</span>);    waiterPool.execute(() -&gt; &#123;        log.debug(<span class="hljs-string">&quot;处理点餐...&quot;</span>);        Future&lt;String&gt; f = cookPool.submit(() -&gt; &#123;            log.debug(<span class="hljs-string">&quot;做菜&quot;</span>);            <span class="hljs-keyword">return</span> cooking();        &#125;);        <span class="hljs-keyword">try</span> &#123;            log.debug(<span class="hljs-string">&quot;上菜: &#123;&#125;&quot;</span>, f.get());        &#125; <span class="hljs-keyword">catch</span> (InterruptedException | ExecutionException e) &#123;            e.printStackTrace();        &#125;    &#125;);    waiterPool.execute(() -&gt; &#123;        log.debug(<span class="hljs-string">&quot;处理点餐...&quot;</span>);        Future&lt;String&gt; f = cookPool.submit(() -&gt; &#123;            log.debug(<span class="hljs-string">&quot;做菜&quot;</span>);            <span class="hljs-keyword">return</span> cooking();        &#125;);        <span class="hljs-keyword">try</span> &#123;            log.debug(<span class="hljs-string">&quot;上菜: &#123;&#125;&quot;</span>, f.get());        &#125; <span class="hljs-keyword">catch</span> (InterruptedException | ExecutionException e) &#123;            e.printStackTrace();        &#125;    &#125;);&#125;</code></pre><pre><code class="hljs ruby"><span class="hljs-number">11</span><span class="hljs-symbol">:</span><span class="hljs-number">20</span><span class="hljs-symbol">:</span><span class="hljs-number">33</span> [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>] c.TestDeadLock - 处理点餐...<span class="hljs-number">11</span><span class="hljs-symbol">:</span><span class="hljs-number">20</span><span class="hljs-symbol">:</span><span class="hljs-number">33</span> [pool-<span class="hljs-number">2</span>-thread-<span class="hljs-number">1</span>] c.TestDeadLock - 做菜<span class="hljs-number">11</span><span class="hljs-symbol">:</span><span class="hljs-number">20</span><span class="hljs-symbol">:</span><span class="hljs-number">33</span> [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>] c.TestDeadLock - 上菜: 辣子鸡丁<span class="hljs-number">11</span><span class="hljs-symbol">:</span><span class="hljs-number">20</span><span class="hljs-symbol">:</span><span class="hljs-number">33</span> [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>] c.TestDeadLock - 处理点餐...<span class="hljs-number">11</span><span class="hljs-symbol">:</span><span class="hljs-number">20</span><span class="hljs-symbol">:</span><span class="hljs-number">33</span> [pool-<span class="hljs-number">2</span>-thread-<span class="hljs-number">1</span>] c.TestDeadLock - 做菜<span class="hljs-number">11</span><span class="hljs-symbol">:</span><span class="hljs-number">20</span><span class="hljs-symbol">:</span><span class="hljs-number">33</span> [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>] c.TestDeadLock - 上菜: 地三鲜</code></pre><h5 id="4-创建合适数量"><a href="#4-创建合适数量" class="headerlink" title="4. 创建合适数量"></a>4. 创建合适数量</h5><p>过小会导致程序不能充分地利用系统资源、容易导致饥饿，过大会导致更多的线程上下文切换，占用更多内存</p><ul><li><p> <code>CPU 密集型运算</code> 通常采用 cpu 核数 + 1 能够实现最优的 CPU 利用率，+1 是保证当线程由于 <strong>页缺失故障（操作系统）</strong> 或其它原因导致暂停时，额外的这个线程就能顶上去，保证 CPU 时钟周期不被浪费</p></li><li><p><code>I/O 密集型运算</code>  CPU 不总是处于繁忙状态，例如，当你执行业务计算时，这时候会使用 CPU 资源，但当你执行 I/O 操作时、远程RPC 调用时，包括进行数据库操作时，这时候 CPU 就闲下来了，你可以利用多线程提高它的利用率。</p><ul><li>经验公式如下：</li><li>线程数 = 核数 * 期望 CPU 利用率 * 总时间(CPU计算时间+等待时间) / CPU 计算时间 </li><li>例如 4 核 CPU 计算时间是 50% ，其它等待时间是 50%，期望 cpu 被 100% 利用，套用公式<ul><li> 4 * 100% * 100% / 50% = 8 </li></ul></li><li>例如 4 核 CPU 计算时间是 10% ，其它等待时间是 90%，期望 cpu 被 100% 利用，套用公式<ul><li> 4 * 100% * 100% / 10% = 40</li></ul></li></ul></li></ul><h4 id="9-任务调度线程池"><a href="#9-任务调度线程池" class="headerlink" title="9) 任务调度线程池"></a>9) 任务调度线程池</h4><p>在 <code>『任务调度线程池』</code>功能加入之前，可以使用 <code>java.util.Timer </code>来实现<code>定时功能</code>；</p><p>Timer 的 <strong>优点</strong> 在于简单易用，但 <strong>缺点</strong> 是由于所有任务都是由 <strong>同一个线程</strong> 来调度，因此所有任务都是 <strong>串行执行</strong> 的，同一时间只能有一个任务在执行，前一个任务的 <strong>延迟或异常都将会影响到之后的任务</strong> 。</p><h5 id="Timer基本使用"><a href="#Timer基本使用" class="headerlink" title="Timer基本使用"></a>Timer基本使用</h5><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span> </span>&#123;    Timer timer = <span class="hljs-keyword">new</span> Timer();    TimerTask task1 = <span class="hljs-keyword">new</span> TimerTask() &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;            log.debug(<span class="hljs-string">&quot;task 1&quot;</span>);            Sleeper.sleep(<span class="hljs-number">2</span>); <span class="hljs-comment">// 任务中出现延迟、异常，其他任务会受影响</span>        &#125;    &#125;;    TimerTask task2 = <span class="hljs-keyword">new</span> TimerTask() &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;            log.debug(<span class="hljs-string">&quot;task 2&quot;</span>);        &#125;    &#125;;    log.debug(<span class="hljs-string">&quot;start...&quot;</span>);    timer.schedule(task1, <span class="hljs-number">1000</span>);    timer.schedule(task2, <span class="hljs-number">2000</span>);&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210505114351.png"></p><h5 id="ScheduledExecutorService"><a href="#ScheduledExecutorService" class="headerlink" title="ScheduledExecutorService"></a>ScheduledExecutorService</h5><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">(ScheduledExecutorService pool)</span> </span>&#123;    pool.schedule(() -&gt; &#123;        log.debug(<span class="hljs-string">&quot;task1&quot;</span>);        <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span> / <span class="hljs-number">0</span>;    &#125;, <span class="hljs-number">1</span>, TimeUnit.SECONDS);    pool.schedule(() -&gt; &#123;        log.debug(<span class="hljs-string">&quot;task2&quot;</span>);    &#125;, <span class="hljs-number">1</span>, TimeUnit.SECONDS);&#125;</code></pre><pre><code class="hljs ruby"><span class="hljs-number">11</span><span class="hljs-symbol">:</span><span class="hljs-number">46</span><span class="hljs-symbol">:</span><span class="hljs-number">38</span> [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>] c.TestTimer - task1<span class="hljs-number">11</span><span class="hljs-symbol">:</span><span class="hljs-number">46</span><span class="hljs-symbol">:</span><span class="hljs-number">38</span> [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span>] c.TestTimer - task2/<span class="hljs-regexp">/ 一个任务异常，不会影响第二个的执行</span></code></pre><p>如果只设置一个线程池大小，也不会影响</p><h5 id="定时执行"><a href="#定时执行" class="headerlink" title="定时执行"></a>定时执行</h5><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method3</span><span class="hljs-params">()</span> </span>&#123;    ScheduledExecutorService pool = Executors.newScheduledThreadPool(<span class="hljs-number">1</span>);    log.debug(<span class="hljs-string">&quot;start...&quot;</span>);    pool.scheduleAtFixedRate(() -&gt; &#123;        log.debug(<span class="hljs-string">&quot;running...&quot;</span>);    &#125;, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, TimeUnit.SECONDS);&#125;</code></pre><pre><code class="hljs ruby"><span class="hljs-number">11</span><span class="hljs-symbol">:</span><span class="hljs-number">48</span><span class="hljs-symbol">:</span><span class="hljs-number">52</span> [main] c.TestTimer - start...<span class="hljs-number">11</span><span class="hljs-symbol">:</span><span class="hljs-number">48</span><span class="hljs-symbol">:</span><span class="hljs-number">53</span> [pool-<span class="hljs-number">2</span>-thread-<span class="hljs-number">1</span>] c.TestTimer - running...<span class="hljs-number">11</span><span class="hljs-symbol">:</span><span class="hljs-number">48</span><span class="hljs-symbol">:</span><span class="hljs-number">54</span> [pool-<span class="hljs-number">2</span>-thread-<span class="hljs-number">1</span>] c.TestTimer - running...<span class="hljs-number">11</span><span class="hljs-symbol">:</span><span class="hljs-number">48</span><span class="hljs-symbol">:</span><span class="hljs-number">55</span> [pool-<span class="hljs-number">2</span>-thread-<span class="hljs-number">1</span>] c.TestTimer - running...  /<span class="hljs-regexp">/....</span></code></pre><p>如果任务执行时间小于间隔时间，会等任务执行完毕，可以确保任务不重叠，第一遍才能第二遍….</p><p>ScheduledExecutorService 中scheduleAtFixedRate方法的使用</p><pre><code class="hljs java">ScheduledExecutorService pool = Executors.newScheduledThreadPool(<span class="hljs-number">1</span>);  log.debug(<span class="hljs-string">&quot;start...&quot;</span>);  pool.scheduleWithFixedDelay(()-&gt; &#123;  log.debug(<span class="hljs-string">&quot;running...&quot;</span>);  sleep(<span class="hljs-number">2</span>);&#125;, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, TimeUnit.SECONDS);</code></pre><p>输出分析：一开始，延时 1s，scheduleWithFixedDelay 的间隔是 <code>上一个任务结束 &lt;-&gt; 延时 &lt;-&gt; 下一个任务开始</code> 所以间隔都是 <code>3s</code></p><pre><code class="hljs ruby"><span class="hljs-number">21</span><span class="hljs-symbol">:</span><span class="hljs-number">40</span><span class="hljs-symbol">:</span><span class="hljs-number">55.078</span> c.TestTimer [main] - start... <span class="hljs-number">21</span><span class="hljs-symbol">:</span><span class="hljs-number">40</span><span class="hljs-symbol">:</span><span class="hljs-number">56.140</span> c.TestTimer [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>] - running... <span class="hljs-number">21</span><span class="hljs-symbol">:</span><span class="hljs-number">40</span><span class="hljs-symbol">:</span><span class="hljs-number">59.143</span> c.TestTimer [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>] - running... <span class="hljs-number">21</span><span class="hljs-symbol">:</span><span class="hljs-number">41</span><span class="hljs-symbol">:</span><span class="hljs-number">02</span>.<span class="hljs-number">145</span> c.TestTimer [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>] - running... <span class="hljs-number">21</span><span class="hljs-symbol">:</span><span class="hljs-number">41</span><span class="hljs-symbol">:</span><span class="hljs-number">05</span>.<span class="hljs-number">147</span> c.TestTimer [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>] - running...</code></pre><blockquote><p> <strong>评价</strong>  整个线程池表现为：线程数固定，任务数多于线程数时，会放入无界队列排队。任务执行完毕，这些线程也不会被释放。用来执行延迟或反复执行的任务</p></blockquote><h4 id="10-正确处理执行任务异常"><a href="#10-正确处理执行任务异常" class="headerlink" title="10) 正确处理执行任务异常"></a>10) 正确处理执行任务异常</h4><h5 id="1-主动扑捉异常"><a href="#1-主动扑捉异常" class="headerlink" title="1. 主动扑捉异常"></a>1. 主动扑捉异常</h5><pre><code class="hljs java">ExecutorService pool = Executors.newFixedThreadPool(<span class="hljs-number">1</span>);  pool.submit(() -&gt; &#123;    <span class="hljs-keyword">try</span> &#123;    log.debug(<span class="hljs-string">&quot;task1&quot;</span>);    <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span> / <span class="hljs-number">0</span>;    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;    log.error(<span class="hljs-string">&quot;error:&quot;</span>, e);    &#125;&#125;);</code></pre><pre><code class="hljs ruby"><span class="hljs-number">11</span><span class="hljs-symbol">:</span><span class="hljs-number">55</span><span class="hljs-symbol">:</span><span class="hljs-number">52</span> [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>] c.TestTimer - task1java.lang.<span class="hljs-symbol">ArithmeticException:</span> / by zero    .....<span class="hljs-number">11</span><span class="hljs-symbol">:</span><span class="hljs-number">55</span><span class="hljs-symbol">:</span><span class="hljs-number">52</span> [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>] c.TestTimer - task2</code></pre><h5 id="借助future对象"><a href="#借助future对象" class="headerlink" title="借助future对象"></a>借助future对象</h5><pre><code class="hljs java">ExecutorService pool = Executors.newFixedThreadPool(<span class="hljs-number">1</span>);  Future&lt;Boolean&gt; f = pool.submit(() -&gt; &#123;    log.debug(<span class="hljs-string">&quot;task1&quot;</span>);    <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span> / <span class="hljs-number">0</span>;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;);log.debug(<span class="hljs-string">&quot;result:&#123;&#125;&quot;</span>, f.get());<span class="hljs-comment">// 没问题返回结果，有问题返回异常信息</span></code></pre><pre><code class="hljs java"><span class="hljs-number">11</span>:<span class="hljs-number">57</span>:<span class="hljs-number">37</span> [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>] c.TestTimer - task1Exception in thread <span class="hljs-string">&quot;main&quot;</span> java.util.concurrent.ExecutionException: java.lang.ArithmeticException: / by zero</code></pre><h4 id="11-线程池应用"><a href="#11-线程池应用" class="headerlink" title="11) 线程池应用"></a>11) 线程池应用</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestSchedule</span> </span>&#123;    <span class="hljs-comment">// 如何让每周四 18:00:00 定时执行任务？</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">//  获取当前时间</span>        LocalDateTime now = LocalDateTime.now();        System.out.println(now);        <span class="hljs-comment">// 获取周四时间</span>        LocalDateTime time = now.withHour(<span class="hljs-number">18</span>).withMinute(<span class="hljs-number">0</span>).withSecond(<span class="hljs-number">0</span>).withNano(<span class="hljs-number">0</span>).with(DayOfWeek.THURSDAY);        <span class="hljs-comment">// 如果 当前时间 &gt; 本周周四，必须找到下周周四</span>        <span class="hljs-keyword">if</span>(now.compareTo(time) &gt; <span class="hljs-number">0</span>) &#123;            time = time.plusWeeks(<span class="hljs-number">1</span>);        &#125;        System.out.println(time);        <span class="hljs-comment">// initailDelay 代表当前时间和周四的时间差</span>        <span class="hljs-comment">// period 一周的间隔时间</span>        <span class="hljs-keyword">long</span> initailDelay = Duration.between(now, time).toMillis();        <span class="hljs-keyword">long</span> period = <span class="hljs-number">1000</span> * <span class="hljs-number">60</span> * <span class="hljs-number">60</span> * <span class="hljs-number">24</span> * <span class="hljs-number">7</span>;        ScheduledExecutorService pool = Executors.newScheduledThreadPool(<span class="hljs-number">1</span>);        pool.scheduleAtFixedRate(() -&gt; &#123;            System.out.println(<span class="hljs-string">&quot;running...&quot;</span>);        &#125;, initailDelay, period, TimeUnit.MILLISECONDS);    &#125;&#125;</code></pre><h4 id="12-Tomcat-线程池"><a href="#12-Tomcat-线程池" class="headerlink" title="12) Tomcat 线程池"></a>12) Tomcat 线程池</h4><p>Tomcat 在哪里用到了线程池呢</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210505122235.png"></p><p>tomcat分为连接器部分，容器部分，连接部分对外沟通，容器部分负责servlet规范，servlet组件；</p><p>上图为连接器部分组成；</p><ol><li>LimitLatch 用来 <code>限流，可以控制最大连接个数</code>，类似 J.U.C 中的 <code>Semaphore</code> 后面再讲</li><li>Acceptor 只负责<code>【接收新的 socket 连接】</code></li><li>Poller 只负责<code>监听</code> socket channel 是否有【可读的 I/O 事件】</li><li>一旦可读，封装一个任务对象（socketProcessor），提交给 Executor 线程池处理</li><li>Executor 线程池中的工作线程最终负责【处理请求】</li></ol><p>Tomcat 线程池扩展了 ThreadPoolExecutor，行为稍有不同</p><ul><li>如果总线程数达到 maximumPoolSize，这时 <strong>不会立刻抛 RejectedExecutionException 异常</strong> </li><li>而是 <strong>再次尝试将任务放入队列</strong> ，如果还失败，才抛出 RejectedExecutionException 异常</li></ul><p>源码 tomcat-7.0.42</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Runnable command, <span class="hljs-keyword">long</span> timeout, TimeUnit unit)</span> </span>&#123;        submittedCount.incrementAndGet();        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">super</span>.execute(command);        &#125; <span class="hljs-keyword">catch</span> (RejectedExecutionException rx) &#123;            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">super</span>.getQueue() <span class="hljs-keyword">instanceof</span> TaskQueue) &#123;                <span class="hljs-keyword">final</span> TaskQueue queue = (TaskQueue)<span class="hljs-keyword">super</span>.getQueue();                <span class="hljs-keyword">try</span> &#123;                    <span class="hljs-comment">// 使任务从新进入阻塞队列</span>                    <span class="hljs-keyword">if</span> (!queue.force(command, timeout, unit)) &#123;                        submittedCount.decrementAndGet();                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RejectedExecutionException(<span class="hljs-string">&quot;Queue capacity is full.&quot;</span>);                    &#125;                &#125; <span class="hljs-keyword">catch</span> (InterruptedException x) &#123;                    submittedCount.decrementAndGet();                    Thread.interrupted();                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RejectedExecutionException(x);                &#125;            &#125; <span class="hljs-keyword">else</span> &#123;                submittedCount.decrementAndGet();                <span class="hljs-keyword">throw</span> rx;            &#125;        &#125;    &#125;</code></pre><p>TaskQueue.java</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">force</span><span class="hljs-params">(Runnable o, <span class="hljs-keyword">long</span> timeout, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        <span class="hljs-keyword">if</span> ( parent.isShutdown() )            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RejectedExecutionException(                    <span class="hljs-string">&quot;Executor not running, can&#x27;t force a command into the queue&quot;</span>            );        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.offer(o,timeout,unit); <span class="hljs-comment">//forces the item onto the queue, to be used if the taskis rejected</span>    &#125;</code></pre><h5 id="tomcat-线程池相关配置"><a href="#tomcat-线程池相关配置" class="headerlink" title="tomcat 线程池相关配置"></a>tomcat 线程池相关配置</h5><p> <strong>Connector 配置如下：</strong> </p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210505123034.png"></p><p> <strong>Executor 线程池配置如下：</strong> </p><p>守护线程的意思就是线程会随着主线程的结束而结束</p><p>普通线程一般都是非守护，tomcat默认为守护线程</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210505123049.png"></p><p>可以看到该线程池实现的是一个无界的队列，所以说是不是执行任务的线程数大于了核心线程数，都会添加到阻塞队列中，那么救急线程是不是就不会用到呢，其实不是：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210505123454.png"></p><h3 id="7-4-forkjoin-线程池"><a href="#7-4-forkjoin-线程池" class="headerlink" title="7.4 forkjoin 线程池"></a>7.4 forkjoin 线程池</h3><h5 id="1-概念"><a href="#1-概念" class="headerlink" title="1) 概念"></a>1) 概念</h5><p>Fork/Join 是 JDK 1.7 加入的新的 <strong>线程池实现</strong> ，它体现的是一种 <strong>分治思想</strong> ，适用于能够进行 <strong>任务拆分的 cpu 密集型运算</strong><br>所谓的任务拆分，是将一个大任务拆分为算法上相同的小任务，直至不能拆分可以直接求解。跟递归相关的一些计算，如归并排序、斐波那契数列、都可以用分治思想进行求解<br>Fork/Join 在分治的基础上加入了多线程，可以把每个任务的分解和合并交给不同的线程来完成，进一步提升了运算效率<br>Fork/Join  <strong>默认</strong> 会创建 <strong>与 cpu 核心数大小相同</strong> 的线程池</p><h5 id="2-使用"><a href="#2-使用" class="headerlink" title="2) 使用"></a>2) 使用</h5><p>提交给 Fork/Join 线程池的任务需要继承 <strong>RecursiveTask（有返回值）或 RecursiveAction（没有返回值）</strong> ，例如下面定义了一个对  <strong>1~n 之间的整数求和</strong> 的任务</p><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.TestForkJoin2&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestForkJoin2</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        ForkJoinPool pool = <span class="hljs-keyword">new</span> ForkJoinPool(<span class="hljs-number">4</span>);        System.out.println(pool.invoke(<span class="hljs-keyword">new</span> MyTask(<span class="hljs-number">5</span>)));        <span class="hljs-comment">// new MyTask(5)  5+ new MyTask(4)  4 + new MyTask(3)  3 + new MyTask(2)  2 + new MyTask(1)</span>    &#125;&#125;<span class="hljs-comment">// 1~n 之间整数的和</span><span class="hljs-meta">@Slf4j(topic = &quot;c.MyTask&quot;)</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyTask</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RecursiveTask</span>&lt;<span class="hljs-title">Integer</span>&gt; </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> n;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyTask</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">this</span>.n = n;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&#123;&quot;</span> + n + <span class="hljs-string">&#x27;&#125;&#x27;</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> Integer <span class="hljs-title">compute</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 如果 n 已经为 1，可以求得结果了</span>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;            log.debug(<span class="hljs-string">&quot;join() &#123;&#125;&quot;</span>, n);            <span class="hljs-keyword">return</span> n;        &#125;        <span class="hljs-comment">// 将任务进行拆分(fork)</span>        AddTask1 t1 = <span class="hljs-keyword">new</span> AddTask1(n - <span class="hljs-number">1</span>);        t1.fork(); <span class="hljs-comment">// 让一个线程去执行任务</span>        log.debug(<span class="hljs-string">&quot;fork() &#123;&#125; + &#123;&#125;&quot;</span>, n, t1);        <span class="hljs-comment">// 合并(join)结果</span>        <span class="hljs-keyword">int</span> result = n + t1.join();        log.debug(<span class="hljs-string">&quot;join() &#123;&#125; + &#123;&#125; = &#123;&#125;&quot;</span>, n, t1, result);        <span class="hljs-keyword">return</span> result;    &#125;&#125;</code></pre><pre><code class="hljs ruby"><span class="hljs-number">13</span><span class="hljs-symbol">:</span><span class="hljs-number">26</span><span class="hljs-symbol">:</span><span class="hljs-number">04</span> [ForkJoinPool-<span class="hljs-number">1</span>-worker-<span class="hljs-number">1</span>] c.MyTask - fork() <span class="hljs-number">5</span> + &#123;<span class="hljs-number">4</span>&#125;<span class="hljs-number">13</span><span class="hljs-symbol">:</span><span class="hljs-number">26</span><span class="hljs-symbol">:</span><span class="hljs-number">04</span> [ForkJoinPool-<span class="hljs-number">1</span>-worker-<span class="hljs-number">0</span>] c.AddTask - fork() <span class="hljs-number">2</span> + &#123;<span class="hljs-number">1</span>&#125;<span class="hljs-number">13</span><span class="hljs-symbol">:</span><span class="hljs-number">26</span><span class="hljs-symbol">:</span><span class="hljs-number">04</span> [ForkJoinPool-<span class="hljs-number">1</span>-worker-<span class="hljs-number">3</span>] c.AddTask - fork() <span class="hljs-number">3</span> + &#123;<span class="hljs-number">2</span>&#125;<span class="hljs-number">13</span><span class="hljs-symbol">:</span><span class="hljs-number">26</span><span class="hljs-symbol">:</span><span class="hljs-number">04</span> [ForkJoinPool-<span class="hljs-number">1</span>-worker-<span class="hljs-number">0</span>] c.AddTask - join() <span class="hljs-number">1</span><span class="hljs-number">13</span><span class="hljs-symbol">:</span><span class="hljs-number">26</span><span class="hljs-symbol">:</span><span class="hljs-number">04</span> [ForkJoinPool-<span class="hljs-number">1</span>-worker-<span class="hljs-number">2</span>] c.AddTask - fork() <span class="hljs-number">4</span> + &#123;<span class="hljs-number">3</span>&#125;<span class="hljs-number">13</span><span class="hljs-symbol">:</span><span class="hljs-number">26</span><span class="hljs-symbol">:</span><span class="hljs-number">04</span> [ForkJoinPool-<span class="hljs-number">1</span>-worker-<span class="hljs-number">0</span>] c.AddTask - join() <span class="hljs-number">2</span> + &#123;<span class="hljs-number">1</span>&#125; = <span class="hljs-number">3</span><span class="hljs-number">13</span><span class="hljs-symbol">:</span><span class="hljs-number">26</span><span class="hljs-symbol">:</span><span class="hljs-number">04</span> [ForkJoinPool-<span class="hljs-number">1</span>-worker-<span class="hljs-number">3</span>] c.AddTask - join() <span class="hljs-number">3</span> + &#123;<span class="hljs-number">2</span>&#125; = <span class="hljs-number">6</span><span class="hljs-number">13</span><span class="hljs-symbol">:</span><span class="hljs-number">26</span><span class="hljs-symbol">:</span><span class="hljs-number">04</span> [ForkJoinPool-<span class="hljs-number">1</span>-worker-<span class="hljs-number">2</span>] c.AddTask - join() <span class="hljs-number">4</span> + &#123;<span class="hljs-number">3</span>&#125; = <span class="hljs-number">10</span><span class="hljs-number">13</span><span class="hljs-symbol">:</span><span class="hljs-number">26</span><span class="hljs-symbol">:</span><span class="hljs-number">04</span> [ForkJoinPool-<span class="hljs-number">1</span>-worker-<span class="hljs-number">1</span>] c.MyTask - join() <span class="hljs-number">5</span> + &#123;<span class="hljs-number">4</span>&#125; = <span class="hljs-number">15</span><span class="hljs-number">15</span></code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210505132957.png"></p><h5 id="3-改进"><a href="#3-改进" class="headerlink" title="3) 改进"></a>3) 改进</h5><p>上面的求法任务有相互依赖性</p><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.AddTask&quot;)</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AddTask3</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RecursiveTask</span>&lt;<span class="hljs-title">Integer</span>&gt; </span>&#123;    <span class="hljs-keyword">int</span> begin;    <span class="hljs-keyword">int</span> end;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AddTask3</span><span class="hljs-params">(<span class="hljs-keyword">int</span> begin, <span class="hljs-keyword">int</span> end)</span> </span>&#123;        <span class="hljs-keyword">this</span>.begin = begin;        <span class="hljs-keyword">this</span>.end = end;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&#123;&quot;</span> + begin + <span class="hljs-string">&quot;,&quot;</span> + end + <span class="hljs-string">&#x27;&#125;&#x27;</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> Integer <span class="hljs-title">compute</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (begin == end) &#123;            log.debug(<span class="hljs-string">&quot;join() &#123;&#125;&quot;</span>, begin);            <span class="hljs-keyword">return</span> begin;        &#125;        <span class="hljs-keyword">if</span> (end - begin == <span class="hljs-number">1</span>) &#123;            log.debug(<span class="hljs-string">&quot;join() &#123;&#125; + &#123;&#125; = &#123;&#125;&quot;</span>, begin, end, end + begin);            <span class="hljs-keyword">return</span> end + begin;        &#125;        <span class="hljs-keyword">int</span> mid = (end + begin) / <span class="hljs-number">2</span>;        AddTask3 t1 = <span class="hljs-keyword">new</span> AddTask3(begin, mid);        t1.fork();        AddTask3 t2 = <span class="hljs-keyword">new</span> AddTask3(mid + <span class="hljs-number">1</span>, end);        t2.fork();        log.debug(<span class="hljs-string">&quot;fork() &#123;&#125; + &#123;&#125; = ?&quot;</span>, t1, t2);        <span class="hljs-keyword">int</span> result = t1.join() + t2.join();        log.debug(<span class="hljs-string">&quot;join() &#123;&#125; + &#123;&#125; = &#123;&#125;&quot;</span>, t1, t2, result);        <span class="hljs-keyword">return</span> result;    &#125;&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210505133215.png"></p><pre><code class="hljs ruby"><span class="hljs-number">13</span><span class="hljs-symbol">:</span><span class="hljs-number">35</span><span class="hljs-symbol">:</span><span class="hljs-number">27</span> [ForkJoinPool-<span class="hljs-number">1</span>-worker-<span class="hljs-number">2</span>] c.AddTask - fork() &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125; + &#123;<span class="hljs-number">3</span>,<span class="hljs-number">3</span>&#125; = ?<span class="hljs-number">13</span><span class="hljs-symbol">:</span><span class="hljs-number">35</span><span class="hljs-symbol">:</span><span class="hljs-number">27</span> [ForkJoinPool-<span class="hljs-number">1</span>-worker-<span class="hljs-number">3</span>] c.AddTask - join() <span class="hljs-number">4</span> + <span class="hljs-number">5</span> = <span class="hljs-number">9</span><span class="hljs-number">13</span><span class="hljs-symbol">:</span><span class="hljs-number">35</span><span class="hljs-symbol">:</span><span class="hljs-number">27</span> [ForkJoinPool-<span class="hljs-number">1</span>-worker-<span class="hljs-number">1</span>] c.AddTask - fork() &#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>&#125; + &#123;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125; = ?<span class="hljs-number">13</span><span class="hljs-symbol">:</span><span class="hljs-number">35</span><span class="hljs-symbol">:</span><span class="hljs-number">27</span> [ForkJoinPool-<span class="hljs-number">1</span>-worker-<span class="hljs-number">0</span>] c.AddTask - join() <span class="hljs-number">1</span> + <span class="hljs-number">2</span> = <span class="hljs-number">3</span><span class="hljs-number">13</span><span class="hljs-symbol">:</span><span class="hljs-number">35</span><span class="hljs-symbol">:</span><span class="hljs-number">27</span> [ForkJoinPool-<span class="hljs-number">1</span>-worker-<span class="hljs-number">1</span>] c.AddTask - join() <span class="hljs-number">3</span><span class="hljs-number">13</span><span class="hljs-symbol">:</span><span class="hljs-number">35</span><span class="hljs-symbol">:</span><span class="hljs-number">27</span> [ForkJoinPool-<span class="hljs-number">1</span>-worker-<span class="hljs-number">2</span>] c.AddTask - join() &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125; + &#123;<span class="hljs-number">3</span>,<span class="hljs-number">3</span>&#125; = <span class="hljs-number">6</span><span class="hljs-number">13</span><span class="hljs-symbol">:</span><span class="hljs-number">35</span><span class="hljs-symbol">:</span><span class="hljs-number">27</span> [ForkJoinPool-<span class="hljs-number">1</span>-worker-<span class="hljs-number">1</span>] c.AddTask - join() &#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>&#125; + &#123;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125; = <span class="hljs-number">15</span><span class="hljs-number">15</span></code></pre><h3 id="7-5-AQS"><a href="#7-5-AQS" class="headerlink" title="7.5 AQS"></a>7.5 AQS</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1) 概述"></a>1) 概述</h4><ul><li>全称是 <code>AbstractQueuedSynchronizer</code>，是<code>阻塞式锁和相关的同步器工具</code>的框架</li><li>特点：<ul><li>用 <code>state 属性</code> 来表示资源的状态（分独占模式和共享模式），子类需要定义如何维护这个状态，控制如何获取锁和释放锁<ul><li>getState - 获取 state 状态</li><li>setState - 设置 state 状态</li><li>compareAndSetState - cas 机制设置 state 状态</li><li><code>独占模式</code>是只有一个线程能够访问资源，而共享模式可以允许多个线程访问资源</li></ul></li><li>提供了基于<code>FIFO 的等待队列</code>，类似于 Monitor 的 <code>EntryList</code></li><li><code>条件变量</code>来实现等待、唤醒机制，支持多个条件变量，类似于 Monitor 的 <code>WaitSet</code></li></ul></li><li>子类主要实现这样一些方法（默认抛出 UnsupportedOperationException）<ul><li>tryAcquire</li><li>tryRelease</li><li>tryAcquireShared</li><li>tryReleaseShared</li><li>isHeldExclusively</li></ul></li></ul><pre><code class="hljs java"><span class="hljs-comment">//获取锁的姿势</span><span class="hljs-keyword">if</span> (!tryAcquire(arg)) &#123; <span class="hljs-comment">// 入队, 可以选择阻塞当前线程 park unpark</span>&#125;<span class="hljs-comment">//释放锁的姿势</span><span class="hljs-keyword">if</span> (tryRelease(arg)) &#123; <span class="hljs-comment">// 让阻塞线程恢复运行</span>&#125;</code></pre><h5 id="2-自定义锁"><a href="#2-自定义锁" class="headerlink" title="2) 自定义锁"></a>2) 自定义锁</h5><pre><code class="hljs java"><span class="hljs-comment">// 自定义锁（不可重入锁）</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Lock</span> </span>&#123;    <span class="hljs-comment">// 独占锁  同步器类</span>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MySync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractQueuedSynchronizer</span> </span>&#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;            <span class="hljs-keyword">if</span>(compareAndSetState(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;                <span class="hljs-comment">// 加上了锁，并设置 owner 为当前线程</span>                setExclusiveOwnerThread(Thread.currentThread());                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            &#125;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryRelease</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;            setExclusiveOwnerThread(<span class="hljs-keyword">null</span>);            setState(<span class="hljs-number">0</span>);<span class="hljs-comment">// 把volatile的赋值放在后面，前面的修改对线程都可见</span>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;        <span class="hljs-meta">@Override</span> <span class="hljs-comment">// 是否持有独占锁</span>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isHeldExclusively</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> getState() == <span class="hljs-number">1</span>;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> Condition <span class="hljs-title">newCondition</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ConditionObject();        &#125;    &#125;    <span class="hljs-keyword">private</span> MySync sync = <span class="hljs-keyword">new</span> MySync();    <span class="hljs-meta">@Override</span> <span class="hljs-comment">// 加锁（不成功会进入等待队列）</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;        sync.acquire(<span class="hljs-number">1</span>);    &#125;    <span class="hljs-meta">@Override</span> <span class="hljs-comment">// 加锁，可打断</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lockInterruptibly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        sync.acquireInterruptibly(<span class="hljs-number">1</span>);    &#125;    <span class="hljs-meta">@Override</span> <span class="hljs-comment">// 尝试加锁（一次）</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> sync.tryAcquire(<span class="hljs-number">1</span>);    &#125;    <span class="hljs-meta">@Override</span> <span class="hljs-comment">// 尝试加锁，带超时</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">(<span class="hljs-keyword">long</span> time, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        <span class="hljs-keyword">return</span> sync.tryAcquireNanos(<span class="hljs-number">1</span>, unit.toNanos(time));    &#125;    <span class="hljs-meta">@Override</span> <span class="hljs-comment">// 解锁</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span> </span>&#123;        sync.release(<span class="hljs-number">1</span>);    &#125;    <span class="hljs-meta">@Override</span> <span class="hljs-comment">// 创建条件变量</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Condition <span class="hljs-title">newCondition</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> sync.newCondition();    &#125;&#125;</code></pre><h5 id="2-测试"><a href="#2-测试" class="headerlink" title="2) 测试"></a>2) 测试</h5><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    MyLock lock = <span class="hljs-keyword">new</span> MyLock();    <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;        lock.lock();        <span class="hljs-keyword">try</span> &#123;            log.debug(<span class="hljs-string">&quot;locking...&quot;</span>);            Sleeper.sleep(<span class="hljs-number">3</span>);        &#125; <span class="hljs-keyword">finally</span> &#123;            log.debug(<span class="hljs-string">&quot;unlocking...&quot;</span>);            lock.unlock();        &#125;    &#125;,<span class="hljs-string">&quot;t1&quot;</span>).start();    <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;        lock.lock();        <span class="hljs-keyword">try</span> &#123;            log.debug(<span class="hljs-string">&quot;locking...&quot;</span>);        &#125; <span class="hljs-keyword">finally</span> &#123;            log.debug(<span class="hljs-string">&quot;unlocking...&quot;</span>);            lock.unlock();        &#125;    &#125;,<span class="hljs-string">&quot;t2&quot;</span>).start();&#125;</code></pre><pre><code class="hljs JAVA"><span class="hljs-number">13</span>:<span class="hljs-number">52</span>:<span class="hljs-number">03</span> [t1] c.TestAqs - locking...<span class="hljs-number">13</span>:<span class="hljs-number">52</span>:<span class="hljs-number">06</span> [t1] c.TestAqs - unlocking...<span class="hljs-number">13</span>:<span class="hljs-number">52</span>:<span class="hljs-number">06</span> [t2] c.TestAqs - locking...<span class="hljs-number">13</span>:<span class="hljs-number">52</span>:<span class="hljs-number">06</span> [t2] c.TestAqs - unlocking...</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210505135832.png"></p><h3 id="7-6-Reentrantlock-原理"><a href="#7-6-Reentrantlock-原理" class="headerlink" title="7.6 Reentrantlock 原理"></a>7.6 Reentrantlock 原理</h3><p>可以看到ReentrantLock提供了两个同步器，实现公平锁和非公平锁，默认是非公平锁！</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210505135930.png"></p><h4 id="1-非公平锁实现原理"><a href="#1-非公平锁实现原理" class="headerlink" title="1. 非公平锁实现原理"></a>1. 非公平锁实现原理</h4><h5 id="加锁解锁流程"><a href="#加锁解锁流程" class="headerlink" title="加锁解锁流程"></a>加锁解锁流程</h5><p>加锁解锁流程，先从构造器开始看，默认为非公平锁实现</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ReentrantLock</span><span class="hljs-params">()</span> </span>&#123; sync = <span class="hljs-keyword">new</span> NonfairSync();&#125;</code></pre><p>lock()方法用的AQS</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210505140140.png"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210505140218.png"></p><p>NonfairSync继承自AQS</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210505140344.png"></p><ul><li><p>没有竞争时</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210505140422.png"></p></li><li><p>第一个竞争出现时，查看源码的NonfairSync的lock方法</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210505140526.png"></p><p>Thread-1 执行了</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>))        setExclusiveOwnerThread(Thread.currentThread());    <span class="hljs-keyword">else</span>        acquire(<span class="hljs-number">1</span>);&#125;</code></pre><ol><li><p>CAS 尝试将 state 由 0 改为 1，结果失败</p></li><li><p>进入 tryAcquire 逻辑，这时 state 已经是1，结果仍然失败</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;    <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp;        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))        selfInterrupt();&#125;</code></pre></li><li><p>接下来进入 <code>addWaiter 逻辑，构造 Node 队列</code></p></li></ol><ul><li>图中黄色三角表示该 Node 的 waitStatus 状态，其中 0 为默认正常状态</li><li>Node 的创建是懒惰的</li><li>其中第一个 Node 称为 Dummy（哑元）或哨兵，用来 <strong>占位</strong> ，并不关联线程</li></ul></li></ul><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210505140615.png"></p><p>当前线程进入 <code>acquireQueued 逻辑</code></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">acquireQueued</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node, <span class="hljs-keyword">int</span> arg)</span> </span>&#123;    <span class="hljs-keyword">boolean</span> failed = <span class="hljs-keyword">true</span>;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">boolean</span> interrupted = <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">for</span> (;;) &#123;            <span class="hljs-keyword">final</span> Node p = node.predecessor(); <span class="hljs-comment">// 前驱结点 找到占位结点</span>            <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123; <span class="hljs-comment">// 判断占位结点是否为头结点， 发现是，再次try</span>                setHead(node);                 p.next = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// help GC</span>                failed = <span class="hljs-keyword">false</span>;                <span class="hljs-keyword">return</span> interrupted;            &#125;            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;                parkAndCheckInterrupt())                interrupted = <span class="hljs-keyword">true</span>;        &#125;    &#125; <span class="hljs-keyword">finally</span> &#123;        <span class="hljs-keyword">if</span> (failed)            cancelAcquire(node);    &#125;&#125;</code></pre><ol><li>acquireQueued 会在一个死循环中不断尝试获得锁，失败后进入 park 阻塞</li><li>如果自己是紧邻着 head（排第二位），那么 <code>再次 tryAcquire</code> 尝试获取锁，当然这时 state 仍为 1，失败</li><li>进入 shouldParkAfterFailedAcquire 逻辑，将前驱 node，即 head 的 waitStatus 改为 -1，这次返回 <code>false</code></li></ol><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210505142733.png"></p><p>-1 表示有责任唤醒后继结点</p><ol start="4"><li>shouldParkAfterFailedAcquire 执行完毕回到 acquireQueued ，再次 tryAcquire 尝试获取锁，当然这时<br>state 仍为 1，失败</li><li>当再次进入 shouldParkAfterFailedAcquire 时，这时因为其前驱 node 的 waitStatus 已经是 -1，这次<code>返回 true</code></li><li>进入 parkAndCheckInterrupt， Thread-1 <code>park（灰色表示）</code></li></ol><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210505142850.png"></p><p>再次有多个线程经历上述过程竞争失败，变成这个样子</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210505142913.png"></p><p>Thread-0 释放锁，进入 tryRelease 流程，如果成功</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span> </span>&#123;    sync.release(<span class="hljs-number">1</span>);&#125; <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryRelease</span><span class="hljs-params">(<span class="hljs-keyword">int</span> releases)</span> </span>&#123;            <span class="hljs-keyword">int</span> c = getState() - releases;            <span class="hljs-keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalMonitorStateException();            <span class="hljs-keyword">boolean</span> free = <span class="hljs-keyword">false</span>;            <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;                free = <span class="hljs-keyword">true</span>;                setExclusiveOwnerThread(<span class="hljs-keyword">null</span>);            &#125;            setState(c);            <span class="hljs-keyword">return</span> free;        &#125;<span class="hljs-comment">// ReentrantLock类</span></code></pre><ul><li>设置 exclusiveOwnerThread 为 null</li><li>state = 0</li></ul><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210505143448.png"></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">release</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;    <span class="hljs-keyword">if</span> (tryRelease(arg)) &#123;        Node h = head;        <span class="hljs-keyword">if</span> (h != <span class="hljs-keyword">null</span> &amp;&amp; h.waitStatus != <span class="hljs-number">0</span>)            unparkSuccessor(h);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;&#125;<span class="hljs-comment">// AQS类</span></code></pre><p>当前队列不为 null，并且 head 的 waitStatus = -1，进入 <code>unparkSuccessor 流程</code><br>找到队列中离 head 最近的一个 Node（没取消的），unpark 恢复其运行，本例中即为 Thread-1<br><code>回到 Thread-1 的 acquireQueued 流程</code></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210505143711.png"></p><p>如果加锁成功（<code>没有竞争</code>），会设置</p><ul><li>exclusiveOwnerThread 为 Thread-1，state = 1</li><li>head 指向刚刚 Thread-1 所在的 Node，该 Node <code>清空 Thread</code></li><li>原本的 head 因为从链表断开，而可被垃圾回收</li></ul><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210505144045.png"></p><p>如果这时候有其它线程来竞争（非公平的体现），例如这时有 Thread-4 来了</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210505144156.png"></p><p>如果不巧又被 Thread-4 占了先</p><ol><li>Thread-4 被设置为 exclusiveOwnerThread，state = 1</li><li>Thread-1 再次进入 acquireQueued 流程，获取锁失败，重新进入 park 阻塞</li></ol><h5 id="加锁源码"><a href="#加锁源码" class="headerlink" title="加锁源码"></a>加锁源码</h5><p> <code>锁重入</code>的时候发现进行 <code>状态累加</code></p><p>重点在于nonfairTryAcquire</p><pre><code class="hljs java"><span class="hljs-comment">// Sync 继承自 AQS</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NonfairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sync</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">7316153563782823691L</span>;     <span class="hljs-comment">// 加锁实现</span>    <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 首先用 cas 尝试（仅尝试一次）将 state 从 0 改为 1, 如果成功表示获得了独占锁</span>        <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>))            setExclusiveOwnerThread(Thread.currentThread());        <span class="hljs-keyword">else</span>            <span class="hljs-comment">// 如果尝试失败，进入 ㈠</span>            acquire(<span class="hljs-number">1</span>);    &#125;    <span class="hljs-comment">// ㈠ AQS 继承过来的方法, 方便阅读, 放在此处</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;        <span class="hljs-comment">// ㈡ tryAcquire</span>        <span class="hljs-keyword">if</span> (                !tryAcquire(arg) &amp;&amp;                <span class="hljs-comment">// 当 tryAcquire 返回为 false 时, 先调用 addWaiter ㈣, 接着 acquireQueued ㈤</span>                 acquireQueued(addWaiter(Node.EXCLUSIVE), arg)        ) &#123;            selfInterrupt();        &#125;    &#125;    <span class="hljs-comment">// ㈡ 进入 ㈢</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> acquires)</span> </span>&#123;        <span class="hljs-keyword">return</span> nonfairTryAcquire(acquires);    &#125;    <span class="hljs-comment">// ㈢ Sync 继承过来的方法, 方便阅读, 放在此处</span>    <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">nonfairTryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> acquires)</span> </span>&#123;        <span class="hljs-keyword">final</span> Thread current = Thread.currentThread();        <span class="hljs-keyword">int</span> c = getState();        <span class="hljs-comment">// 如果还没有获得锁</span>        <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;            <span class="hljs-comment">// 尝试用 cas 获得, 这里体现了非公平性: 不去检查 AQS 队列</span>            <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;                setExclusiveOwnerThread(current);                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            &#125;        &#125;        <span class="hljs-comment">// 如果已经获得了锁, 线程还是当前线程, 表示发生了锁重入</span>        <span class="hljs-comment">// `锁重入`的时候发现进行 `状态累加`</span>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123;            <span class="hljs-comment">// state++</span>            <span class="hljs-keyword">int</span> nextc = c + acquires;            <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// overflow</span>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);            setState(nextc);            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;        <span class="hljs-comment">// 获取失败, 回到调用处</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-comment">// ㈣ AQS 继承过来的方法, 方便阅读, 放在此处</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">addWaiter</span><span class="hljs-params">(Node mode)</span> </span>&#123;<span class="hljs-comment">// 将当前线程关联到一个 Node 对象上, 模式为独占模式，新建的Node的waitstatus默认为0，因为waitstatus是成员变量，默认被初始化为0</span>        Node node = <span class="hljs-keyword">new</span> Node(Thread.currentThread(), mode);        <span class="hljs-comment">// 如果 tail 不为 null, cas 尝试将 Node 对象加入 AQS 队列尾部</span>        Node pred = tail;        <span class="hljs-keyword">if</span> (pred != <span class="hljs-keyword">null</span>) &#123;            node.prev = pred;            <span class="hljs-keyword">if</span> (compareAndSetTail(pred, node)) &#123;                <span class="hljs-comment">// 双向链表</span>                pred.next = node;                <span class="hljs-keyword">return</span> node;            &#125;        &#125;        <span class="hljs-comment">//如果tail为null，尝试将 Node 加入 AQS, 进入 ㈥</span>        enq(node);        <span class="hljs-keyword">return</span> node;    &#125;    <span class="hljs-comment">// ㈥ AQS 继承过来的方法, 方便阅读, 放在此处</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">enq</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node)</span> </span>&#123;        <span class="hljs-keyword">for</span> (;;) &#123;            Node t = tail;            <span class="hljs-keyword">if</span> (t == <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-comment">// 还没有, 设置 head 为哨兵节点（不对应线程，状态为 0）</span>                <span class="hljs-keyword">if</span> (compareAndSetHead(<span class="hljs-keyword">new</span> Node())) &#123;                    tail = head;                &#125;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">// cas 尝试将 Node 对象加入 AQS 队列尾部</span>                node.prev = t;                <span class="hljs-keyword">if</span> (compareAndSetTail(t, node)) &#123;                    t.next = node;                    <span class="hljs-keyword">return</span> t;                &#125;            &#125;        &#125;    &#125;    <span class="hljs-comment">// ㈤ AQS 继承过来的方法, 方便阅读, 放在此处</span>    <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">acquireQueued</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node, <span class="hljs-keyword">int</span> arg)</span> </span>&#123;        <span class="hljs-keyword">boolean</span> failed = <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">boolean</span> interrupted = <span class="hljs-keyword">false</span>;            <span class="hljs-keyword">for</span> (;;) &#123;                <span class="hljs-keyword">final</span> Node p = node.predecessor();                <span class="hljs-comment">// 上一个节点是 head, 表示轮到自己（当前线程对应的 node）了, 尝试获取</span>                <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;                    <span class="hljs-comment">// 获取成功, 设置自己（当前线程对应的 node）为 head</span>                    setHead(node);                    <span class="hljs-comment">// 上一个节点 help GC</span>                    p.next = <span class="hljs-keyword">null</span>;                    failed = <span class="hljs-keyword">false</span>;                    <span class="hljs-comment">// 返回中断标记 false</span>                    <span class="hljs-keyword">return</span> interrupted;                &#125;                <span class="hljs-keyword">if</span> (                    <span class="hljs-comment">// 判断是否应当 park, 进入 ㈦</span>                    shouldParkAfterFailedAcquire(p, node) &amp;&amp;                    <span class="hljs-comment">// park 等待, 此时 Node 的状态被置为 Node.SIGNAL ㈧</span>                    parkAndCheckInterrupt()                ) &#123;                    interrupted = <span class="hljs-keyword">true</span>;                &#125;            &#125;        &#125; <span class="hljs-keyword">finally</span> &#123;            <span class="hljs-keyword">if</span> (failed)                cancelAcquire(node);        &#125;    &#125;    <span class="hljs-comment">// ㈦ AQS 继承过来的方法, 方便阅读, 放在此处</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">shouldParkAfterFailedAcquire</span><span class="hljs-params">(Node pred, Node node)</span> </span>&#123;        <span class="hljs-comment">// 获取上一个节点的状态</span>        <span class="hljs-keyword">int</span> ws = pred.waitStatus;        <span class="hljs-keyword">if</span> (ws == Node.SIGNAL) &#123;            <span class="hljs-comment">// 上一个节点都在阻塞, 那么自己也阻塞好了</span>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;        <span class="hljs-comment">// &gt; 0 表示取消状态</span>        <span class="hljs-keyword">if</span> (ws &gt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-comment">// 上一个节点取消, 那么重构删除前面所有取消的节点, 返回到外层循环重试</span>            <span class="hljs-keyword">do</span> &#123;                node.prev = pred = pred.prev;            &#125; <span class="hljs-keyword">while</span> (pred.waitStatus &gt; <span class="hljs-number">0</span>);            pred.next = node;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// 这次还没有阻塞</span>            <span class="hljs-comment">// 但下次如果重试不成功, 则需要阻塞，这时需要设置上一个节点状态为 Node.SIGNAL</span>            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-comment">// ㈧ 阻塞当前线程</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">parkAndCheckInterrupt</span><span class="hljs-params">()</span> </span>&#123;        LockSupport.park(<span class="hljs-keyword">this</span>);        <span class="hljs-keyword">return</span> Thread.interrupted();    &#125;&#125;</code></pre><h5 id="解锁源码"><a href="#解锁源码" class="headerlink" title="解锁源码"></a>解锁源码</h5><p>重点在于tryRelease</p><pre><code class="hljs java"><span class="hljs-comment">// Sync 继承自 AQS</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NonfairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sync</span> </span>&#123;    <span class="hljs-comment">// 解锁实现</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span> </span>&#123;        sync.release(<span class="hljs-number">1</span>);    &#125;    <span class="hljs-comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">release</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;        <span class="hljs-comment">// 尝试释放锁, 进入 ㈠</span>        <span class="hljs-keyword">if</span> (tryRelease(arg)) &#123;            <span class="hljs-comment">// 队列头节点 unpark</span>            Node h = head;            <span class="hljs-keyword">if</span> (                <span class="hljs-comment">// 队列不为 null</span>                h != <span class="hljs-keyword">null</span> &amp;&amp;                <span class="hljs-comment">// waitStatus == Node.SIGNAL 才需要 unpark</span>                h.waitStatus != <span class="hljs-number">0</span>            ) &#123;                <span class="hljs-comment">// unpark AQS 中等待的线程, 进入 ㈡</span>                unparkSuccessor(h);            &#125;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-comment">// ㈠ Sync 继承过来的方法, 方便阅读, 放在此处</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryRelease</span><span class="hljs-params">(<span class="hljs-keyword">int</span> releases)</span> </span>&#123;        <span class="hljs-comment">// state--</span>        <span class="hljs-keyword">int</span> c = getState() - releases;        <span class="hljs-keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalMonitorStateException();        <span class="hljs-keyword">boolean</span> free = <span class="hljs-keyword">false</span>;        <span class="hljs-comment">// 支持锁重入, 只有 state 减为 0, 才释放成功</span>        <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;            free = <span class="hljs-keyword">true</span>;            setExclusiveOwnerThread(<span class="hljs-keyword">null</span>);        &#125;        setState(c);        <span class="hljs-keyword">return</span> free;    &#125;    <span class="hljs-comment">// ㈡ AQS 继承过来的方法, 方便阅读, 放在此处</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unparkSuccessor</span><span class="hljs-params">(Node node)</span> </span>&#123;        <span class="hljs-comment">// 如果状态为 Node.SIGNAL 尝试重置状态为 0, 如果线程获取到了锁那么后来头结点会被抛弃掉</span>        <span class="hljs-comment">// 不成功也可以</span>        <span class="hljs-keyword">int</span> ws = node.waitStatus;        <span class="hljs-keyword">if</span> (ws &lt; <span class="hljs-number">0</span>) &#123;            compareAndSetWaitStatus(node, ws, <span class="hljs-number">0</span>);        &#125;        <span class="hljs-comment">// 找到需要 unpark 的节点, 但本节点从 AQS 队列中脱离, 是由唤醒节点完成的</span>        Node s = node.next;        <span class="hljs-comment">// 不考虑已取消的节点, 从 AQS 队列从后至前找到队列最前面需要 unpark 的节点</span>        <span class="hljs-keyword">if</span> (s == <span class="hljs-keyword">null</span> || s.waitStatus &gt; <span class="hljs-number">0</span>) &#123;            s = <span class="hljs-keyword">null</span>;            <span class="hljs-keyword">for</span> (Node t = tail; t != <span class="hljs-keyword">null</span> &amp;&amp; t != node; t = t.prev)                <span class="hljs-keyword">if</span> (t.waitStatus &lt;= <span class="hljs-number">0</span>)                    s = t;        &#125;        <span class="hljs-keyword">if</span> (s != <span class="hljs-keyword">null</span>)            LockSupport.unpark(s.thread);    &#125;&#125;</code></pre><h4 id="2-可重入原理"><a href="#2-可重入原理" class="headerlink" title="2. 可重入原理"></a>2. 可重入原理</h4><p>可重入就是如上加锁的时候nonfairTryAcquire，给state++</p><p>解锁的时候tryRelease，给state–，只有state=0的时候，才设置setExclusiveOwnerThread(null);</p><h4 id="3-可打断原理"><a href="#3-可打断原理" class="headerlink" title="3. 可打断原理"></a>3. 可打断原理</h4><h5 id="不可打断模式"><a href="#不可打断模式" class="headerlink" title="不可打断模式"></a>不可打断模式</h5><p>进入park可以被其他线程调用interrupt唤醒，</p><p>在此模式下，即使它被打断，仍会驻留在 AQS 队列中（不会立刻作出响应），   <code>一直要等到获得锁后方能得知自己被打断了    </code></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210505145937.png"></p><p>获得到锁后，for循环内才会返回 <strong>打断标记</strong> </p><p>返回后执行到</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210505150657.png"></p><p>重新产生中断；</p><h5 id="可打断模式"><a href="#可打断模式" class="headerlink" title="可打断模式"></a>可打断模式</h5><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NonfairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sync</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquireInterruptibly</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        <span class="hljs-keyword">if</span> (Thread.interrupted())            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InterruptedException();        <span class="hljs-comment">// 如果没有获得到锁, 进入 ㈠</span>        <span class="hljs-keyword">if</span> (!tryAcquire(arg))            doAcquireInterruptibly(arg);    &#125;    <span class="hljs-comment">// ㈠ 可打断的获取锁流程</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doAcquireInterruptibly</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        <span class="hljs-keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);        <span class="hljs-keyword">boolean</span> failed = <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">for</span> (;;) &#123;                <span class="hljs-keyword">final</span> Node p = node.predecessor();                <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;                    setHead(node);                    p.next = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// help GC</span>                    failed = <span class="hljs-keyword">false</span>;                    <span class="hljs-keyword">return</span>;                &#125;                <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;                        parkAndCheckInterrupt()) &#123;                    <span class="hljs-comment">// 在 park 过程中如果被 interrupt 会进入此</span>                    <span class="hljs-comment">// 这时候抛出异常, 而不会再次进入 for (;;)</span>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InterruptedException();                &#125;            &#125;        &#125; <span class="hljs-keyword">finally</span> &#123;            <span class="hljs-keyword">if</span> (failed)                cancelAcquire(node);        &#125;    &#125;&#125;</code></pre><p>parkAndCheckInterrupt()因为打断返回了true，直接throw了</p><h4 id="4-公平锁实现原理"><a href="#4-公平锁实现原理" class="headerlink" title="4. 公平锁实现原理"></a>4. 公平锁实现原理</h4><p>先检查 AQS 队列中是否有前驱节点, 没有才去竞争</p><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sync</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = -<span class="hljs-number">3000897897090466540L</span>;    <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;        acquire(<span class="hljs-number">1</span>);    &#125;    <span class="hljs-comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;        <span class="hljs-keyword">if</span> (                !tryAcquire(arg) &amp;&amp;                        acquireQueued(addWaiter(Node.EXCLUSIVE), arg)        ) &#123;            selfInterrupt();        &#125;    &#125;    <span class="hljs-comment">// 与非公平锁主要区别在于 tryAcquire 方法的实现</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> acquires)</span> </span>&#123;        <span class="hljs-keyword">final</span> Thread current = Thread.currentThread();        <span class="hljs-keyword">int</span> c = getState();        <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;            <span class="hljs-comment">// 先检查 AQS 队列中是否有前驱节点, 没有才去竞争</span>            <span class="hljs-keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;                    compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;                setExclusiveOwnerThread(current);                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            &#125;        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123;            <span class="hljs-keyword">int</span> nextc = c + acquires;            <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>)                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);            setState(nextc);            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-comment">// ㈠ AQS 继承过来的方法, 方便阅读, 放在此处</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasQueuedPredecessors</span><span class="hljs-params">()</span> </span>&#123;        Node t = tail;        Node h = head;        Node s;        <span class="hljs-comment">// h != t 时表示队列中有 Node</span>        <span class="hljs-keyword">return</span> h != t &amp;&amp;                (                        <span class="hljs-comment">// (s = h.next) == null 表示队列中还有没有老二</span>                        (s = h.next) == <span class="hljs-keyword">null</span> || <span class="hljs-comment">// 或者队列中老二线程不是此线程</span>                                s.thread != Thread.currentThread()                );    &#125;&#125;</code></pre><h4 id="5-条件变量实现原理"><a href="#5-条件变量实现原理" class="headerlink" title="5. 条件变量实现原理"></a>5. 条件变量实现原理</h4><p>每个条件变量其实就对应着一个 <code>等待队列</code>，其实现类是 ConditionObject</p><pre><code class="hljs java"><span class="hljs-comment">//在AQS的ConditionObject类中</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;    <span class="hljs-keyword">if</span> (Thread.interrupted())        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InterruptedException();    Node node = addConditionWaiter();    <span class="hljs-keyword">int</span> savedState = fullyRelease(node);<span class="hljs-comment">// 把重入加了几次的state数量都拿到,再全部清零</span>    <span class="hljs-keyword">int</span> interruptMode = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (!isOnSyncQueue(node)) &#123;        LockSupport.park(<span class="hljs-keyword">this</span>);        <span class="hljs-keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="hljs-number">0</span>)            <span class="hljs-keyword">break</span>;    &#125;    <span class="hljs-keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)        interruptMode = REINTERRUPT;    <span class="hljs-keyword">if</span> (node.nextWaiter != <span class="hljs-keyword">null</span>) <span class="hljs-comment">// clean up if cancelled</span>        unlinkCancelledWaiters();    <span class="hljs-keyword">if</span> (interruptMode != <span class="hljs-number">0</span>)        reportInterruptAfterWait(interruptMode);&#125;</code></pre><h5 id="await-流程"><a href="#await-流程" class="headerlink" title="await 流程"></a>await 流程</h5><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210506180717.png"></p><p>await 流程 开始 Thread-0 持有锁，调用 await，进入 ConditionObject 的 <code>addConditionWaiter</code> 流程 创建新的 Node 状态为 -2（Node.CONDITION），关联 Thread-0，加入等待队列尾部</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">fullyRelease</span><span class="hljs-params">(Node node)</span> </span>&#123; <span class="hljs-comment">// 把Thread-0的state全部清零</span>    <span class="hljs-keyword">boolean</span> failed = <span class="hljs-keyword">true</span>;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">int</span> savedState = getState();        <span class="hljs-keyword">if</span> (release(savedState)) &#123;            failed = <span class="hljs-keyword">false</span>;            <span class="hljs-keyword">return</span> savedState;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalMonitorStateException();        &#125;    &#125; <span class="hljs-keyword">finally</span> &#123;        <span class="hljs-keyword">if</span> (failed)            node.waitStatus = Node.CANCELLED;    &#125;&#125;</code></pre><p>接下来进入 AQS 的 fullyRelease 流程，<code>释放同步器上的锁</code></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210506181102.png"></p><p><code>unpark AQS 队列中的下一个节点</code>，竞争锁，假设没有其他竞争线程，那么 Thread-1 竞争成功</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">release</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;    <span class="hljs-keyword">if</span> (tryRelease(arg)) &#123;        Node h = head;        <span class="hljs-keyword">if</span> (h != <span class="hljs-keyword">null</span> &amp;&amp; h.waitStatus != <span class="hljs-number">0</span>)            unparkSuccessor(h);<span class="hljs-comment">// unpark</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210506181123.png"></p><p>park 阻塞 Thread-0</p><p>右上面await代码中的循环可以得到park了this</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210506181546.png"></p><h5 id="signal-流程"><a href="#signal-流程" class="headerlink" title="signal 流程"></a>signal 流程</h5><p>假设 Thread-1 要来唤醒 Thread-0</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">signal</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">if</span> (!isHeldExclusively()) <span class="hljs-comment">// 检查是不是锁的持有者</span>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalMonitorStateException();    Node first = firstWaiter;    <span class="hljs-keyword">if</span> (first != <span class="hljs-keyword">null</span>) <span class="hljs-comment">// 可以得知总是去调队首的第一个结点</span>        doSignal(first);&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210506181624.png"></p><p>进入 ConditionObject 的 doSignal 流程，取得<code>等待队列中第一个 Node</code>，即 Thread-0 所在 Node</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doSignal</span><span class="hljs-params">(Node first)</span> </span>&#123;    <span class="hljs-keyword">do</span> &#123;        <span class="hljs-keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="hljs-keyword">null</span>)            lastWaiter = <span class="hljs-keyword">null</span>;        first.nextWaiter = <span class="hljs-keyword">null</span>;    &#125; <span class="hljs-keyword">while</span> (!transferForSignal(first) &amp;&amp; <span class="hljs-comment">// 把结点转移到竞争锁的等待队列中</span>             (first = firstWaiter) != <span class="hljs-keyword">null</span>);&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210506181835.png"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210506181917.png"></p><p>执行 <code>transferForSignal 流程</code>，将该 Node 加入 <code>AQS 队列尾部</code>，将 Thread-0 的 waitStatus 改为 0，Thread-3 的waitStatus 改为 -1</p><p>Thread-1 释放锁，进入 unlock 流程</p><h5 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h5><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConditionObject</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Condition</span>, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">1173984872572414699L</span>;    <span class="hljs-comment">// 第一个等待节点</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Node firstWaiter;    <span class="hljs-comment">// 最后一个等待节点</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Node lastWaiter;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ConditionObject</span><span class="hljs-params">()</span> </span>&#123; &#125;    <span class="hljs-comment">// ㈠ 添加一个 Node 至等待队列</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">addConditionWaiter</span><span class="hljs-params">()</span> </span>&#123;        Node t = lastWaiter;        <span class="hljs-comment">// 所有已取消的 Node 从队列链表删除, 见 ㈡</span>        <span class="hljs-keyword">if</span> (t != <span class="hljs-keyword">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;            unlinkCancelledWaiters();            t = lastWaiter;        &#125;        <span class="hljs-comment">// 创建一个关联当前线程的新 Node, 添加至队列尾部</span>        Node node = <span class="hljs-keyword">new</span> Node(Thread.currentThread(), Node.CONDITION);        <span class="hljs-keyword">if</span> (t == <span class="hljs-keyword">null</span>)            firstWaiter = node;        <span class="hljs-keyword">else</span>            t.nextWaiter = node;        lastWaiter = node;        <span class="hljs-keyword">return</span> node;    &#125;    <span class="hljs-comment">// 唤醒 - 将没取消的第一个节点转移至 AQS 队列</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doSignal</span><span class="hljs-params">(Node first)</span> </span>&#123;        <span class="hljs-keyword">do</span> &#123;            <span class="hljs-comment">// 已经是尾节点了</span>            <span class="hljs-keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="hljs-keyword">null</span>) &#123;                lastWaiter = <span class="hljs-keyword">null</span>;            &#125;            first.nextWaiter = <span class="hljs-keyword">null</span>;        &#125; <span class="hljs-keyword">while</span> (            <span class="hljs-comment">// 将等待队列中的 Node 转移至 AQS 队列, 不成功且还有节点则继续循环 ㈢</span>                !transferForSignal(first) &amp;&amp;                        <span class="hljs-comment">// 队列还有节点</span>                        (first = firstWaiter) != <span class="hljs-keyword">null</span>        );    &#125;    <span class="hljs-comment">// 外部类方法, 方便阅读, 放在此处</span>    <span class="hljs-comment">// ㈢ 如果节点状态是取消, 返回 false 表示转移失败, 否则转移成功</span>    <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">transferForSignal</span><span class="hljs-params">(Node node)</span> </span>&#123;        <span class="hljs-comment">// 设置当前node状态为0（因为处在队列末尾），如果状态已经不是 Node.CONDITION, 说明被取消了</span>        <span class="hljs-keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="hljs-number">0</span>))            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-comment">// 加入 AQS 队列尾部</span>        Node p = enq(node);        <span class="hljs-keyword">int</span> ws = p.waitStatus;        <span class="hljs-keyword">if</span> (            <span class="hljs-comment">// 插入节点的上一个节点被取消</span>                ws &gt; <span class="hljs-number">0</span> ||                        <span class="hljs-comment">// 插入节点的上一个节点不能设置状态为 Node.SIGNAL</span>                        !compareAndSetWaitStatus(p, ws, Node.SIGNAL)        ) &#123;            <span class="hljs-comment">// unpark 取消阻塞, 让线程重新同步状态</span>            LockSupport.unpark(node.thread);        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;<span class="hljs-comment">// 全部唤醒 - 等待队列的所有节点转移至 AQS 队列</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doSignalAll</span><span class="hljs-params">(Node first)</span> </span>&#123;    lastWaiter = firstWaiter = <span class="hljs-keyword">null</span>;    <span class="hljs-keyword">do</span> &#123;        Node next = first.nextWaiter;        first.nextWaiter = <span class="hljs-keyword">null</span>;        transferForSignal(first);        first = next;    &#125; <span class="hljs-keyword">while</span> (first != <span class="hljs-keyword">null</span>);&#125;    <span class="hljs-comment">// ㈡</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlinkCancelledWaiters</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// ...</span>    &#125;    <span class="hljs-comment">// 唤醒 - 必须持有锁才能唤醒, 因此 doSignal 内无需考虑加锁</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">signal</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 如果没有持有锁，会抛出异常</span>        <span class="hljs-keyword">if</span> (!isHeldExclusively())            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalMonitorStateException();        Node first = firstWaiter;        <span class="hljs-keyword">if</span> (first != <span class="hljs-keyword">null</span>)            doSignal(first);    &#125;    <span class="hljs-comment">// 全部唤醒 - 必须持有锁才能唤醒, 因此 doSignalAll 内无需考虑加锁</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">signalAll</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (!isHeldExclusively())            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalMonitorStateException();        Node first = firstWaiter;        <span class="hljs-keyword">if</span> (first != <span class="hljs-keyword">null</span>)            doSignalAll(first);    &#125;    <span class="hljs-comment">// 不可打断等待 - 直到被唤醒</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">awaitUninterruptibly</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 添加一个 Node 至等待队列, 见 ㈠</span>        Node node = addConditionWaiter();        <span class="hljs-comment">// 释放节点持有的锁, 见 ㈣</span>        <span class="hljs-keyword">int</span> savedState = fullyRelease(node);        <span class="hljs-keyword">boolean</span> interrupted = <span class="hljs-keyword">false</span>;        <span class="hljs-comment">// 如果该节点还没有转移至 AQS 队列, 阻塞</span>        <span class="hljs-keyword">while</span> (!isOnSyncQueue(node)) &#123;            <span class="hljs-comment">// park 阻塞</span>            LockSupport.park(<span class="hljs-keyword">this</span>);            <span class="hljs-comment">// 如果被打断, 仅设置打断状态</span>            <span class="hljs-keyword">if</span> (Thread.interrupted())                interrupted = <span class="hljs-keyword">true</span>;        &#125;        <span class="hljs-comment">// 唤醒后, 尝试竞争锁, 如果失败进入 AQS 队列</span>        <span class="hljs-keyword">if</span> (acquireQueued(node, savedState) || interrupted)            selfInterrupt();    &#125;    <span class="hljs-comment">// 外部类方法, 方便阅读, 放在此处</span>    <span class="hljs-comment">// ㈣ 因为某线程可能重入，需要将 state 全部释放，获取state，然后把它全部减掉，以全部释放</span>    <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">fullyRelease</span><span class="hljs-params">(Node node)</span> </span>&#123;        <span class="hljs-keyword">boolean</span> failed = <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">int</span> savedState = getState();            <span class="hljs-comment">// 唤醒等待队列队列中的下一个节点</span>            <span class="hljs-keyword">if</span> (release(savedState)) &#123;                failed = <span class="hljs-keyword">false</span>;                <span class="hljs-keyword">return</span> savedState;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalMonitorStateException();            &#125;        &#125; <span class="hljs-keyword">finally</span> &#123;            <span class="hljs-keyword">if</span> (failed)                node.waitStatus = Node.CANCELLED;        &#125;    &#125;    <span class="hljs-comment">// 打断模式 - 在退出等待时重新设置打断状态</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> REINTERRUPT = <span class="hljs-number">1</span>;    <span class="hljs-comment">// 打断模式 - 在退出等待时抛出异常</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> THROW_IE = -<span class="hljs-number">1</span>;    <span class="hljs-comment">// 判断打断模式</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">checkInterruptWhileWaiting</span><span class="hljs-params">(Node node)</span> </span>&#123;        <span class="hljs-keyword">return</span> Thread.interrupted() ?                (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :                <span class="hljs-number">0</span>;    &#125;    <span class="hljs-comment">// ㈤ 应用打断模式</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reportInterruptAfterWait</span><span class="hljs-params">(<span class="hljs-keyword">int</span> interruptMode)</span></span><span class="hljs-function">            <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        <span class="hljs-keyword">if</span> (interruptMode == THROW_IE)            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InterruptedException();        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (interruptMode == REINTERRUPT)            selfInterrupt();    &#125;    <span class="hljs-comment">// 等待 - 直到被唤醒或打断</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        <span class="hljs-keyword">if</span> (Thread.interrupted()) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InterruptedException();        &#125;        <span class="hljs-comment">// 添加一个 Node 至等待队列, 见 ㈠</span>        Node node = addConditionWaiter();        <span class="hljs-comment">// 释放节点持有的锁</span>        <span class="hljs-keyword">int</span> savedState = fullyRelease(node);        <span class="hljs-keyword">int</span> interruptMode = <span class="hljs-number">0</span>;        <span class="hljs-comment">// 如果该节点还没有转移至 AQS 队列, 阻塞</span>        <span class="hljs-keyword">while</span> (!isOnSyncQueue(node)) &#123;            <span class="hljs-comment">// park 阻塞              </span>            LockSupport.park(<span class="hljs-keyword">this</span>);            <span class="hljs-comment">// 如果被打断, 退出等待队列</span>            <span class="hljs-keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="hljs-number">0</span>)                <span class="hljs-keyword">break</span>;        &#125;        <span class="hljs-comment">// 退出等待队列后, 还需要获得 AQS 队列的锁</span>        <span class="hljs-keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)            interruptMode = REINTERRUPT;        <span class="hljs-comment">// 所有已取消的 Node 从队列链表删除, 见 ㈡</span>        <span class="hljs-keyword">if</span> (node.nextWaiter != <span class="hljs-keyword">null</span>)            unlinkCancelledWaiters();        <span class="hljs-comment">// 应用打断模式, 见 ㈤</span>        <span class="hljs-keyword">if</span> (interruptMode != <span class="hljs-number">0</span>)            reportInterruptAfterWait(interruptMode);    &#125;    <span class="hljs-comment">// 等待 - 直到被唤醒或打断或超时</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> <span class="hljs-title">awaitNanos</span><span class="hljs-params">(<span class="hljs-keyword">long</span> nanosTimeout)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        <span class="hljs-keyword">if</span> (Thread.interrupted()) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InterruptedException();        &#125;        <span class="hljs-comment">// 添加一个 Node 至等待队列, 见 ㈠</span>        Node node = addConditionWaiter();        <span class="hljs-comment">// 释放节点持有的锁</span>        <span class="hljs-keyword">int</span> savedState = fullyRelease(node);        <span class="hljs-comment">// 获得最后期限</span>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> deadline = System.nanoTime() + nanosTimeout;        <span class="hljs-keyword">int</span> interruptMode = <span class="hljs-number">0</span>;        <span class="hljs-comment">// 如果该节点还没有转移至 AQS 队列, 阻塞</span>        <span class="hljs-keyword">while</span> (!isOnSyncQueue(node)) &#123;            <span class="hljs-comment">// 已超时, 退出等待队列</span>            <span class="hljs-keyword">if</span> (nanosTimeout &lt;= <span class="hljs-number">0L</span>) &#123;                transferAfterCancelledWait(node);                <span class="hljs-keyword">break</span>;            &#125;            <span class="hljs-comment">// park 阻塞一定时间, spinForTimeoutThreshold 为 1000 ns</span>            <span class="hljs-keyword">if</span> (nanosTimeout &gt;= spinForTimeoutThreshold)                LockSupport.parkNanos(<span class="hljs-keyword">this</span>, nanosTimeout);            <span class="hljs-comment">// 如果被打断, 退出等待队列</span>            <span class="hljs-keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="hljs-number">0</span>)                <span class="hljs-keyword">break</span>;            nanosTimeout = deadline - System.nanoTime();        &#125;        <span class="hljs-comment">// 退出等待队列后, 还需要获得 AQS 队列的锁</span>        <span class="hljs-keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)            interruptMode = REINTERRUPT;        <span class="hljs-comment">// 所有已取消的 Node 从队列链表删除, 见 ㈡</span>        <span class="hljs-keyword">if</span> (node.nextWaiter != <span class="hljs-keyword">null</span>)            unlinkCancelledWaiters();        <span class="hljs-comment">// 应用打断模式, 见 ㈤</span>        <span class="hljs-keyword">if</span> (interruptMode != <span class="hljs-number">0</span>)            reportInterruptAfterWait(interruptMode);        <span class="hljs-keyword">return</span> deadline - System.nanoTime();    &#125;    <span class="hljs-comment">// 等待 - 直到被唤醒或打断或超时, 逻辑类似于 awaitNanos</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">awaitUntil</span><span class="hljs-params">(Date deadline)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        <span class="hljs-comment">// ...</span>    &#125;    <span class="hljs-comment">// 等待 - 直到被唤醒或打断或超时, 逻辑类似于 awaitNanos</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">await</span><span class="hljs-params">(<span class="hljs-keyword">long</span> time, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        <span class="hljs-comment">// ...</span>    &#125;    <span class="hljs-comment">// 工具方法 省略 ...</span>&#125;</code></pre><h3 id="7-7-读写锁"><a href="#7-7-读写锁" class="headerlink" title="7.7 读写锁"></a>7.7 读写锁</h3><h4 id="1-ReentrantReadWriteLock"><a href="#1-ReentrantReadWriteLock" class="headerlink" title="1. ReentrantReadWriteLock"></a>1. ReentrantReadWriteLock</h4><p>当读操作远远高于写操作时，这时候使用<code>读写锁</code>让<code>读-读</code>可以并发，提高性能。读-写，写-写都是相互互斥的！</p><p>类似于数据库中的 <code>select ...from ... lock in share mode</code></p><p>提供一个<code>数据容器类</code>内部分别使用读锁保护数据的read()方法，写锁保护数据的write()方法</p><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.DataContainer&quot;)</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DataContainer</span> </span>&#123;    <span class="hljs-keyword">private</span> Object data;    <span class="hljs-keyword">private</span> ReentrantReadWriteLock rw = <span class="hljs-keyword">new</span> ReentrantReadWriteLock();    <span class="hljs-keyword">private</span> ReentrantReadWriteLock.ReadLock r = rw.readLock();    <span class="hljs-keyword">private</span> ReentrantReadWriteLock.WriteLock w = rw.writeLock();    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;        log.debug(<span class="hljs-string">&quot;获取读锁...&quot;</span>);        r.lock();        <span class="hljs-keyword">try</span> &#123;            log.debug(<span class="hljs-string">&quot;读取&quot;</span>);            Sleeper.sleep(<span class="hljs-number">1</span>);            <span class="hljs-keyword">return</span> data;        &#125; <span class="hljs-keyword">finally</span> &#123;            log.debug(<span class="hljs-string">&quot;释放读锁...&quot;</span>);            r.unlock();        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">()</span> </span>&#123;        log.debug(<span class="hljs-string">&quot;获取写锁...&quot;</span>);        w.lock();        <span class="hljs-keyword">try</span> &#123;            log.debug(<span class="hljs-string">&quot;写入&quot;</span>);            Sleeper.sleep(<span class="hljs-number">1</span>);        &#125; <span class="hljs-keyword">finally</span> &#123;            log.debug(<span class="hljs-string">&quot;释放写锁...&quot;</span>);            w.unlock();        &#125;    &#125;&#125;</code></pre><p>如果两个都读：</p><pre><code class="hljs ruby"><span class="hljs-number">18</span><span class="hljs-symbol">:</span><span class="hljs-number">40</span><span class="hljs-symbol">:</span><span class="hljs-number">05</span> [t1] c.DataContainer - 获取读锁...<span class="hljs-number">18</span><span class="hljs-symbol">:</span><span class="hljs-number">40</span><span class="hljs-symbol">:</span><span class="hljs-number">05</span> [t2] c.DataContainer - 获取读锁...<span class="hljs-number">18</span><span class="hljs-symbol">:</span><span class="hljs-number">40</span><span class="hljs-symbol">:</span><span class="hljs-number">05</span> [t2] c.DataContainer - 读取<span class="hljs-number">18</span><span class="hljs-symbol">:</span><span class="hljs-number">40</span><span class="hljs-symbol">:</span><span class="hljs-number">05</span> [t1] c.DataContainer - 读取<span class="hljs-number">18</span><span class="hljs-symbol">:</span><span class="hljs-number">40</span><span class="hljs-symbol">:</span><span class="hljs-number">06</span> [t2] c.DataContainer - 释放读锁...<span class="hljs-number">18</span><span class="hljs-symbol">:</span><span class="hljs-number">40</span><span class="hljs-symbol">:</span><span class="hljs-number">06</span> [t1] c.DataContainer - 释放读锁...</code></pre><p>如果一读一写：</p><pre><code class="hljs ruby"><span class="hljs-number">18</span><span class="hljs-symbol">:</span><span class="hljs-number">40</span><span class="hljs-symbol">:</span><span class="hljs-number">50</span> [t2] c.DataContainer - 获取写锁...<span class="hljs-number">18</span><span class="hljs-symbol">:</span><span class="hljs-number">40</span><span class="hljs-symbol">:</span><span class="hljs-number">50</span> [t1] c.DataContainer - 获取读锁...<span class="hljs-number">18</span><span class="hljs-symbol">:</span><span class="hljs-number">40</span><span class="hljs-symbol">:</span><span class="hljs-number">50</span> [t2] c.DataContainer - 写入<span class="hljs-number">18</span><span class="hljs-symbol">:</span><span class="hljs-number">40</span><span class="hljs-symbol">:</span><span class="hljs-number">51</span> [t2] c.DataContainer - 释放写锁...<span class="hljs-number">18</span><span class="hljs-symbol">:</span><span class="hljs-number">40</span><span class="hljs-symbol">:</span><span class="hljs-number">51</span> [t1] c.DataContainer - 读取<span class="hljs-number">18</span><span class="hljs-symbol">:</span><span class="hljs-number">40</span><span class="hljs-symbol">:</span><span class="hljs-number">52</span> [t1] c.DataContainer - 释放读锁...</code></pre><p>注意事项</p><ol><li>读锁不支持条件变量</li><li>重入时<code>升级不支持</code>：<code>即持有读锁的情况下去获取写锁，会导致获取写锁永久等待</code></li></ol><pre><code class="hljs java">r.lock();<span class="hljs-keyword">try</span> &#123;<span class="hljs-comment">// ...</span>w.lock();<span class="hljs-keyword">try</span> &#123;<span class="hljs-comment">// ...</span>&#125; <span class="hljs-keyword">finally</span>&#123;w.unlock();&#125;&#125; <span class="hljs-keyword">finally</span>&#123;r.unlock();&#125;</code></pre><ol start="3"><li>重入时<code>降级支持</code>：<code>即持有写锁的情况下去获取读锁</code></li></ol><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CachedData</span> </span>&#123;    Object data;    <span class="hljs-comment">// 是否有效，如果失效，需要重新计算 data</span>    <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> cacheValid;    <span class="hljs-keyword">final</span> ReentrantReadWriteLock rwl = <span class="hljs-keyword">new</span> ReentrantReadWriteLock();    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">processCachedData</span><span class="hljs-params">()</span> </span>&#123;        rwl.readLock().lock();        <span class="hljs-keyword">if</span> (!cacheValid) &#123;<span class="hljs-comment">// 判断有没有失效</span>            <span class="hljs-comment">// 获取写锁前必须释放读锁</span>            rwl.readLock().unlock();            rwl.writeLock().lock();            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-comment">// 双重检查</span>                <span class="hljs-comment">// 判断是否有其它线程已经获取了写锁、更新了缓存, 避免重复更新</span>                <span class="hljs-keyword">if</span> (!cacheValid) &#123;                    data = ...                    cacheValid = <span class="hljs-keyword">true</span>;                &#125;                <span class="hljs-comment">// 写锁重入到读锁是可以的</span>                <span class="hljs-comment">// 降级为读锁, 释放写锁, 这样能够让其它线程读取缓存</span>                rwl.readLock().lock();            &#125; <span class="hljs-keyword">finally</span> &#123;                rwl.writeLock().unlock();            &#125;        &#125;        <span class="hljs-comment">// 自己用完数据, 释放读锁</span>        <span class="hljs-keyword">try</span> &#123;            use(data);        &#125; <span class="hljs-keyword">finally</span> &#123;            rwl.readLock().unlock();        &#125;    &#125;&#125;</code></pre><h4 id="应用之缓存"><a href="#应用之缓存" class="headerlink" title="* 应用之缓存"></a>* 应用之缓存</h4><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210506185050.png"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210506185937.png"></p><p>修改：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210506185759.png"></p><blockquote><p>如果多线程操作，上述是否会出现并发问题</p></blockquote><ol><li>Hashmap不安全</li><li> 有非原子操作（组合操作）</li><li>清空和更新操作先后顺序不一致会出现问题</li></ol><ul><li>更新缓存策略</li></ul><p>更新时，是先清缓存还是先更新数据库？先清缓存：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210506185257.png"></p><p><code>先更新数据库</code></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210506185306.png"></p><p>补充一种情况，假设查询线程 A 查询数据时恰好缓存数据由于时间到期失效，或是第一次查询：这种情况的出现几率非常小</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210506185510.png"></p><h4 id="读写锁实现一致性缓存"><a href="#读写锁实现一致性缓存" class="headerlink" title="* 读写锁实现一致性缓存"></a>* 读写锁实现一致性缓存</h4><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210506191542.png"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210506191408.png"></p><p>注意</p><ul><li>以上实现体现的是读写锁的应用，保证缓存和数据库的一致性，但有下面的问题没有考虑<ul><li>适合读多写少，如果写操作比较频繁，以上实现性能低</li><li>没有考虑缓存容量</li><li>没有考虑缓存过期</li><li>只适合单机</li><li>并发性还是低，目前只会用一把锁</li><li>更新方法太过简单粗暴，清空了所有 key（考虑按类型分区或重新设计 key）</li><li>乐观锁实现：用 CAS 去更新</li></ul></li></ul><h3 id="7-8-读写锁原理"><a href="#7-8-读写锁原理" class="headerlink" title="7.8 读写锁原理"></a>7.8 读写锁原理</h3><h4 id="1-图解流程"><a href="#1-图解流程" class="headerlink" title="1) 图解流程"></a>1) 图解流程</h4><p>读写锁用的是<code>同一个 Sycn 同步器</code>，因此<code>等待队列、state 等也是同一个</code></p><h4 id="2-t1-w-lock，t2-r-lock"><a href="#2-t1-w-lock，t2-r-lock" class="headerlink" title="2) t1 w.lock，t2 r.lock"></a>2) t1 w.lock，t2 r.lock</h4><ol><li><p>t1 成功上锁，流程与 ReentrantLock 加锁相比没有特殊之处，不同是写锁状态占了 state 的<code>低 16 位</code>，而读锁使用的是 state 的<code>高 16 位</code></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210506192312.png"></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;    sync.acquire(<span class="hljs-number">1</span>); <span class="hljs-comment">// 写锁的获取</span>&#125;<span class="hljs-comment">// ReentrantReadWriteLock中WriteLock的lock方法</span><span class="hljs-comment">// 就是AQS的acquire</span></code></pre><p><code>读写锁重写了tryAcquire方法</code></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210506192843.png"></p><p>c!= 0: <code>一种加了读锁；一种加了写锁</code></p><ol><li><p>w==0表示家了读锁，读写互斥return false；</p></li><li><p>加了写锁判断是不是自己加的，如果不是，false；</p></li></ol><p>再往下写锁 + 1超过16位最大范围，抛异常，几乎不会出现；</p><p>再下面计数加 1，加的是写锁的state</p></li><li><p>t2 执行 r.lock，这时进入读锁的 <code>sync.acquireShared(1)</code> （读锁的获取）流程，首先会进入 tryAcquireShared 流程。如果有写锁占据，那么 tryAcquireShared 返回 -1 表示失败</p><p><code>tryAcquireShared 返回值</code>表示</p><ol><li>-1 表示失败</li><li>0 表示成功，但后继节点不会继续唤醒</li><li>正数表示成功，而且数值是还有几个后继节点需要唤醒，我们这里的读写锁返回 1</li></ol><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210506193554.png"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210506194012.png"></p></li><li><p>这时会进入<code> sync.doAcquireShared(1)</code> 流程，首先也是调用 addWaiter 添加节点，不同之处在于节点被设置为<code>Node.SHARED 模式而非 Node.EXCLUSIVE 模式</code>，注意此时 <code>t2 仍处于活跃状态</code></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210506194212.png"></p></li><li><p>t2 会看看自己的节点是不是老二，如果是，还会再次调用 <code>tryAcquireShared(1) </code>来尝试获取锁</p></li><li><p>如果没有成功，在 doAcquireShared 内 for (;;) 循环一次，把前驱节点的 waitStatus 改为 -1，再 for (;;) 循环一次尝试 tryAcquireShared(1) 如果还不成功，那么在 <code>parkAndCheckInterrupt()</code> 处 park</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210506194317.png"></p></li></ol><h4 id="3-t3-r-lock，t4-w-lock"><a href="#3-t3-r-lock，t4-w-lock" class="headerlink" title="3) t3 r.lock，t4 w.lock"></a>3) t3 r.lock，t4 w.lock</h4><p>这种状态下，假设又有 t3 加读锁和 t4 加写锁，这期间 t1 仍然持有锁，就变成了下面的样子</p><p>T2\t3, shared 状态</p><p>T3, Ex状态</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210506194621.png"></p><h4 id="4-t1-w-unlock"><a href="#4-t1-w-unlock" class="headerlink" title="4) t1 w.unlock"></a>4) t1 w.unlock</h4><p>这时会走到写锁的 sync.release(1) 流程，调用 sync.tryRelease(1) 成功，变成下面的样子</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210506194735.png"></p><p>接下来执行唤醒流程 sync.unparkSuccessor，即让老二恢复运行，</p><p>这时 t2 在 <code>doAcquireShared 内parkAndCheckInterrupt()</code> 处恢复运行<br>这回再来一次 for (;;) 执行 <code>tryAcquireShared</code> 成功则让读锁计数加一</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">release</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123; <span class="hljs-comment">// 写锁的解锁</span>    <span class="hljs-keyword">if</span> (tryRelease(arg)) &#123;        Node h = head;        <span class="hljs-keyword">if</span> (h != <span class="hljs-keyword">null</span> &amp;&amp; h.waitStatus != <span class="hljs-number">0</span>)            unparkSuccessor(h);<span class="hljs-comment">// unpark会让下面读锁park继续向下运行，再次进入for循环</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;&#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquireShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;        <span class="hljs-keyword">if</span> (tryAcquireShared(arg) &lt; <span class="hljs-number">0</span>)            doAcquireShared(arg);<span class="hljs-comment">// 读锁的加锁</span>    &#125; <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doAcquireShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;        <span class="hljs-keyword">final</span> Node node = addWaiter(Node.SHARED);        <span class="hljs-keyword">boolean</span> failed = <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">boolean</span> interrupted = <span class="hljs-keyword">false</span>;            <span class="hljs-keyword">for</span> (;;) &#123;                <span class="hljs-keyword">final</span> Node p = node.predecessor();                <span class="hljs-keyword">if</span> (p == head) &#123;                    <span class="hljs-keyword">int</span> r = tryAcquireShared(arg);                    <span class="hljs-keyword">if</span> (r &gt;= <span class="hljs-number">0</span>) &#123;                        setHeadAndPropagate(node, r);<span class="hljs-comment">// 进入结点的设置</span>                        p.next = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// help GC</span>                        <span class="hljs-keyword">if</span> (interrupted)                            selfInterrupt();                        failed = <span class="hljs-keyword">false</span>;                        <span class="hljs-keyword">return</span>;                    &#125;                &#125;                <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;                    parkAndCheckInterrupt())<span class="hljs-comment">// 被上面写锁解锁unpark</span>                    interrupted = <span class="hljs-keyword">true</span>;            &#125;        &#125; <span class="hljs-keyword">finally</span> &#123;            <span class="hljs-keyword">if</span> (failed)                cancelAcquire(node);        &#125;    &#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210506200427.png"></p><p>这时 t2 已经恢复运行，接下来 t2 调用 <code>setHeadAndPropagate(node, 1)</code>，它原本所在节点被置为头节点</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210506200809.png"></p><p>事情还没完，在 <code>setHeadAndPropagate</code> 方法内还会检查下一个节点是否是 shared，如果是则调用<br><code>doReleaseShared() </code>将 head 的状态从 -1 改为 0 并唤醒老二，这时 <code>t3</code> 在 doAcquireShared 内<br><code>parkAndCheckInterrupt() </code>处恢复运行</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setHeadAndPropagate</span><span class="hljs-params">(Node node, <span class="hljs-keyword">int</span> propagate)</span> </span>&#123;    Node h = head; <span class="hljs-comment">// Record old head for check below</span>    setHead(node);<span class="hljs-comment">//  将 head 的状态从 -1 改为 0 并唤醒老二</span>    <span class="hljs-keyword">if</span> (propagate &gt; <span class="hljs-number">0</span> || h == <span class="hljs-keyword">null</span> || h.waitStatus &lt; <span class="hljs-number">0</span> ||        (h = head) == <span class="hljs-keyword">null</span> || h.waitStatus &lt; <span class="hljs-number">0</span>) &#123;        Node s = node.next;<span class="hljs-comment">// t3 结点</span>        <span class="hljs-keyword">if</span> (s == <span class="hljs-keyword">null</span> || s.isShared())            doReleaseShared();<span class="hljs-comment">// 查看是否为共享状态 是的话release</span>    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doReleaseShared</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">for</span> (;;) &#123;        Node h = head;        <span class="hljs-keyword">if</span> (h != <span class="hljs-keyword">null</span> &amp;&amp; h != tail) &#123;            <span class="hljs-keyword">int</span> ws = h.waitStatus;            <span class="hljs-keyword">if</span> (ws == Node.SIGNAL) &#123;                <span class="hljs-keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="hljs-number">0</span>))<span class="hljs-comment">// 把头改成0 否则下一个线程进来看见-1 又回重复唤醒</span>                    <span class="hljs-keyword">continue</span>;            <span class="hljs-comment">// loop to recheck cases</span>                unparkSuccessor(h);            &#125;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ws == <span class="hljs-number">0</span> &amp;&amp;                     !compareAndSetWaitStatus(h, <span class="hljs-number">0</span>, Node.PROPAGATE))                <span class="hljs-keyword">continue</span>;                <span class="hljs-comment">// loop on failed CAS</span>        &#125;        <span class="hljs-keyword">if</span> (h == head)                   <span class="hljs-comment">// loop if head changed</span>            <span class="hljs-keyword">break</span>;    &#125;&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210506201512.png"></p><p>这回再来一次 for (;;) 执行 <code>tryAcquireShared 成功则让读锁计数加一</code></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210506202951.png"></p><p>这时 t3 已经恢复运行，接下来<code> t3 调用 setHeadAndPropagate(node, 1)，它原本所在节点被置为头节点</code></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210506203012.png"></p><p>下一个节点不是 shared 了，因此不会继续唤醒 t4 所在节点</p><h4 id="5-t2-r-unlock，t3-r-unlock"><a href="#5-t2-r-unlock，t3-r-unlock" class="headerlink" title="5) t2 r.unlock，t3 r.unlock"></a>5) t2 r.unlock，t3 r.unlock</h4><p>t2 进入 sync.releaseShared(1) 中，调用 tryReleaseShared(1) 让计数减一，但由于计数还不为零</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210506203217.png"></p><p>t3 进入 <code>sync.releaseShared(1) </code>中，调用 tryReleaseShared(1) 让计数减一，这回计数为零了，进入<br><code>doReleaseShared()</code> 将头节点从 -1 改为 0 并唤醒老二，即</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210506203337.png"></p><p>之后 t4 在 acquireQueued 中 parkAndCheckInterrupt 处恢复运行，再次 for (;;) 这次自己是老二，并且没有其他<br>竞争，tryAcquire(1) 成功，修改头结点，流程结束</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210506203357.png"></p><h4 id="6-读写锁源码分析"><a href="#6-读写锁源码分析" class="headerlink" title="6) 读写锁源码分析"></a>6) 读写锁源码分析</h4><p>写锁上锁流程</p><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NonfairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sync</span> </span>&#123;    <span class="hljs-comment">// ... 省略无关代码</span>    <span class="hljs-comment">// 外部类 WriteLock 方法, 方便阅读, 放在此处</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;        sync.acquire(<span class="hljs-number">1</span>);    &#125;    <span class="hljs-comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;        <span class="hljs-keyword">if</span> (            <span class="hljs-comment">// 尝试获得写锁失败</span>                !tryAcquire(arg) &amp;&amp;                        <span class="hljs-comment">// 将当前线程关联到一个 Node 对象上, 模式为独占模式</span>                        <span class="hljs-comment">// 进入 AQS 队列阻塞</span>                        acquireQueued(addWaiter(Node.EXCLUSIVE), arg)        ) &#123;            selfInterrupt();        &#125;    &#125;    <span class="hljs-comment">// Sync 继承过来的方法, 方便阅读, 放在此处</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> acquires)</span> </span>&#123;        <span class="hljs-comment">// 获得低 16 位, 代表写锁的 state 计数</span>        Thread current = Thread.currentThread();        <span class="hljs-keyword">int</span> c = getState();        <span class="hljs-keyword">int</span> w = exclusiveCount(c);        <span class="hljs-keyword">if</span> (c != <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">if</span> (                <span class="hljs-comment">// c != 0 and w == 0 表示有读锁返回错误，读锁不支持锁升级, 或者</span>                    w == <span class="hljs-number">0</span> ||                            <span class="hljs-comment">// c != 0 and w == 0 表示有写，如果 exclusiveOwnerThread 不是自己</span>                            current != getExclusiveOwnerThread()            ) &#123;                <span class="hljs-comment">// 获得锁失败</span>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;            <span class="hljs-comment">// 写锁计数超过低 16 位, 报异常</span>            <span class="hljs-keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);            <span class="hljs-comment">// 写锁重入, 获得锁成功</span>            setState(c + acquires);            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;        <span class="hljs-keyword">if</span> (            <span class="hljs-comment">// 判断写锁是否该阻塞这里返回false, 或者</span>                writerShouldBlock() ||                        <span class="hljs-comment">// 尝试更改计数失败</span>                        !compareAndSetState(c, c + acquires)        ) &#123;            <span class="hljs-comment">// 获得锁失败</span>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-comment">// 获得锁成功</span>        setExclusiveOwnerThread(current);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-comment">// 非公平锁 writerShouldBlock 总是返回 false, 无需阻塞</span>    <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">writerShouldBlock</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;&#125;</code></pre><p>写锁释放流程</p><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NonfairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sync</span> </span>&#123;    <span class="hljs-comment">// ... 省略无关代码</span>    <span class="hljs-comment">// WriteLock 方法, 方便阅读, 放在此处</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span> </span>&#123;        sync.release(<span class="hljs-number">1</span>);    &#125;    <span class="hljs-comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">release</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;        <span class="hljs-comment">// 尝试释放写锁成功</span>        <span class="hljs-keyword">if</span> (tryRelease(arg)) &#123;            <span class="hljs-comment">// unpark AQS 中等待的线程</span>            Node h = head;            <span class="hljs-keyword">if</span> (h != <span class="hljs-keyword">null</span> &amp;&amp; h.waitStatus != <span class="hljs-number">0</span>)                unparkSuccessor(h);            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-comment">// Sync 继承过来的方法, 方便阅读, 放在此处</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryRelease</span><span class="hljs-params">(<span class="hljs-keyword">int</span> releases)</span> </span>&#123;        <span class="hljs-keyword">if</span> (!isHeldExclusively())            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalMonitorStateException();        <span class="hljs-keyword">int</span> nextc = getState() - releases;        <span class="hljs-comment">// 因为可重入的原因, 写锁计数为 0, 才算释放成功</span>        <span class="hljs-keyword">boolean</span> free = exclusiveCount(nextc) == <span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span> (free) &#123;            setExclusiveOwnerThread(<span class="hljs-keyword">null</span>);        &#125;        setState(nextc);        <span class="hljs-keyword">return</span> free;    &#125;&#125;</code></pre><p>读锁上锁流程</p><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NonfairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sync</span> </span>&#123;    <span class="hljs-comment">// ReadLock 方法, 方便阅读, 放在此处</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;        sync.acquireShared(<span class="hljs-number">1</span>);    &#125;    <span class="hljs-comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquireShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;        <span class="hljs-comment">// tryAcquireShared 返回负数, 表示获取读锁失败</span>        <span class="hljs-keyword">if</span> (tryAcquireShared(arg) &lt; <span class="hljs-number">0</span>) &#123;            doAcquireShared(arg);        &#125;    &#125;    <span class="hljs-comment">// Sync 继承过来的方法, 方便阅读, 放在此处</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">tryAcquireShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> unused)</span> </span>&#123;        Thread current = Thread.currentThread();        <span class="hljs-keyword">int</span> c = getState();        <span class="hljs-comment">// 如果是其它线程持有写锁, 获取读锁失败</span>        <span class="hljs-keyword">if</span> (                exclusiveCount(c) != <span class="hljs-number">0</span> &amp;&amp;                        getExclusiveOwnerThread() != current        ) &#123;            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">int</span> r = sharedCount(c);        <span class="hljs-keyword">if</span> (            <span class="hljs-comment">// 读锁不该阻塞(如果老二是写锁，读锁该阻塞), 并且</span>                !readerShouldBlock() &amp;&amp;                        <span class="hljs-comment">// 小于读锁计数, 并且</span>                        r &lt; MAX_COUNT &amp;&amp;                        <span class="hljs-comment">// 尝试增加计数成功</span>                        compareAndSetState(c, c + SHARED_UNIT)        ) &#123;            <span class="hljs-comment">// ... 省略不重要的代码</span>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">return</span> fullTryAcquireShared(current);    &#125;    <span class="hljs-comment">// 非公平锁 readerShouldBlock 看 AQS 队列中第一个节点是否是写锁</span>    <span class="hljs-comment">// true 则该阻塞, false 则不阻塞</span>    <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">readerShouldBlock</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> apparentlyFirstQueuedIsExclusive();    &#125;    <span class="hljs-comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span>    <span class="hljs-comment">// 与 tryAcquireShared 功能类似, 但会不断尝试 for (;;) 获取读锁, 执行过程中无阻塞</span>    <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">fullTryAcquireShared</span><span class="hljs-params">(Thread current)</span> </span>&#123;        HoldCounter rh = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">for</span> (;;) &#123;            <span class="hljs-keyword">int</span> c = getState();            <span class="hljs-keyword">if</span> (exclusiveCount(c) != <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">if</span> (getExclusiveOwnerThread() != current)                    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (readerShouldBlock()) &#123;                <span class="hljs-comment">// ... 省略不重要的代码</span>            &#125;            <span class="hljs-keyword">if</span> (sharedCount(c) == MAX_COUNT)                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);            <span class="hljs-keyword">if</span> (compareAndSetState(c, c + SHARED_UNIT)) &#123;                <span class="hljs-comment">// ... 省略不重要的代码</span>                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;            &#125;        &#125;    &#125;    <span class="hljs-comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doAcquireShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;        <span class="hljs-comment">// 将当前线程关联到一个 Node 对象上, 模式为共享模式</span>        <span class="hljs-keyword">final</span> Node node = addWaiter(Node.SHARED);        <span class="hljs-keyword">boolean</span> failed = <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">boolean</span> interrupted = <span class="hljs-keyword">false</span>;            <span class="hljs-keyword">for</span> (;;) &#123;                <span class="hljs-keyword">final</span> Node p = node.predecessor();                <span class="hljs-keyword">if</span> (p == head) &#123;                    <span class="hljs-comment">// 再一次尝试获取读锁</span>                    <span class="hljs-keyword">int</span> r = tryAcquireShared(arg);                    <span class="hljs-comment">// 成功</span>                    <span class="hljs-keyword">if</span> (r &gt;= <span class="hljs-number">0</span>) &#123;                        <span class="hljs-comment">// ㈠</span>                        <span class="hljs-comment">// r 表示可用资源数, 在这里总是 1 允许传播</span>                        <span class="hljs-comment">//（唤醒 AQS 中下一个 Share 节点）</span>                        setHeadAndPropagate(node, r);                        p.next = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// help GC</span>                        <span class="hljs-keyword">if</span> (interrupted)                            selfInterrupt();                        failed = <span class="hljs-keyword">false</span>;                        <span class="hljs-keyword">return</span>;                    &#125;                &#125;                <span class="hljs-keyword">if</span> (                    <span class="hljs-comment">// 是否在获取读锁失败时阻塞（前一个阶段 waitStatus == Node.SIGNAL）</span>                        shouldParkAfterFailedAcquire(p, node) &amp;&amp;                                <span class="hljs-comment">// park 当前线程</span>                                parkAndCheckInterrupt()                ) &#123;                    interrupted = <span class="hljs-keyword">true</span>;                &#125;            &#125;        &#125; <span class="hljs-keyword">finally</span> &#123;            <span class="hljs-keyword">if</span> (failed)                cancelAcquire(node);        &#125;    &#125;    <span class="hljs-comment">// ㈠ AQS 继承过来的方法, 方便阅读, 放在此处</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setHeadAndPropagate</span><span class="hljs-params">(Node node, <span class="hljs-keyword">int</span> propagate)</span> </span>&#123;        Node h = head; <span class="hljs-comment">// Record old head for check below</span>        <span class="hljs-comment">// 设置自己为 head</span>        setHead(node);        <span class="hljs-comment">// propagate 表示有共享资源（例如共享读锁或信号量）</span>        <span class="hljs-comment">// 原 head waitStatus == Node.SIGNAL 或 Node.PROPAGATE</span>        <span class="hljs-comment">// 现在 head waitStatus == Node.SIGNAL 或 Node.PROPAGATE</span>        <span class="hljs-keyword">if</span> (propagate &gt; <span class="hljs-number">0</span> || h == <span class="hljs-keyword">null</span> || h.waitStatus &lt; <span class="hljs-number">0</span> ||                (h = head) == <span class="hljs-keyword">null</span> || h.waitStatus &lt; <span class="hljs-number">0</span>) &#123;            Node s = node.next;            <span class="hljs-comment">// 如果是最后一个节点或者是等待共享读锁的节点</span>            <span class="hljs-keyword">if</span> (s == <span class="hljs-keyword">null</span> || s.isShared()) &#123;                <span class="hljs-comment">// 进入 ㈡</span>                doReleaseShared();            &#125;        &#125;    &#125;    <span class="hljs-comment">// ㈡ AQS 继承过来的方法, 方便阅读, 放在此处</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doReleaseShared</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 如果 head.waitStatus == Node.SIGNAL ==&gt; 0 成功, 下一个节点 unpark</span>        <span class="hljs-comment">// 如果 head.waitStatus == 0 ==&gt; Node.PROPAGATE, 为了解决 bug, 见后面分析，参考这里：http://www.tianxiaobo.com/2018/05/01/AbstractQueuedSynchronizer-%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90-%E7%8B%AC%E5%8D%A0-%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%BC%8F/#5propagate-%E7%8A%B6%E6%80%81%E5%AD%98%E5%9C%A8%E7%9A%84%E6%84%8F%E4%B9%89</span>        <span class="hljs-keyword">for</span> (;;) &#123;            Node h = head;            <span class="hljs-comment">// 队列还有节点</span>            <span class="hljs-keyword">if</span> (h != <span class="hljs-keyword">null</span> &amp;&amp; h != tail) &#123;                <span class="hljs-keyword">int</span> ws = h.waitStatus;                <span class="hljs-keyword">if</span> (ws == Node.SIGNAL) &#123;                    <span class="hljs-keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="hljs-number">0</span>))                        <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// loop to recheck cases</span>                    <span class="hljs-comment">// 下一个节点 unpark 如果成功获取读锁</span>                    <span class="hljs-comment">// 并且下下个节点还是 shared, 继续 doReleaseShared</span>                    unparkSuccessor(h);                &#125;                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ws == <span class="hljs-number">0</span> &amp;&amp;                        !compareAndSetWaitStatus(h, <span class="hljs-number">0</span>, Node.PROPAGATE))                    <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// loop on failed CAS</span>            &#125;            <span class="hljs-keyword">if</span> (h == head) <span class="hljs-comment">// loop if head changed</span>                <span class="hljs-keyword">break</span>;        &#125;    &#125;&#125;</code></pre><p>读锁释放流程</p><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NonfairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sync</span> </span>&#123;    <span class="hljs-comment">// ReadLock 方法, 方便阅读, 放在此处</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span> </span>&#123;        sync.releaseShared(<span class="hljs-number">1</span>);    &#125;    <span class="hljs-comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">releaseShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;        <span class="hljs-keyword">if</span> (tryReleaseShared(arg)) &#123;            doReleaseShared();            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-comment">// Sync 继承过来的方法, 方便阅读, 放在此处</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryReleaseShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> unused)</span> </span>&#123;        <span class="hljs-comment">// ... 省略不重要的代码</span>        <span class="hljs-keyword">for</span> (;;) &#123;            <span class="hljs-keyword">int</span> c = getState();            <span class="hljs-keyword">int</span> nextc = c - SHARED_UNIT;            <span class="hljs-keyword">if</span> (compareAndSetState(c, nextc)) &#123;                <span class="hljs-comment">// 读锁的计数不会影响其它获取读锁线程, 但会影响其它获取写锁线程</span>                <span class="hljs-comment">// 计数为 0 才是真正释放</span>                <span class="hljs-keyword">return</span> nextc == <span class="hljs-number">0</span>;            &#125;        &#125;    &#125;    <span class="hljs-comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doReleaseShared</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 如果 head.waitStatus == Node.SIGNAL ==&gt; 0 成功, 下一个节点 unpark</span>        <span class="hljs-comment">// 如果 head.waitStatus == 0 ==&gt; Node.PROPAGATE</span>        <span class="hljs-keyword">for</span> (;;) &#123;            Node h = head;            <span class="hljs-keyword">if</span> (h != <span class="hljs-keyword">null</span> &amp;&amp; h != tail) &#123;                <span class="hljs-keyword">int</span> ws = h.waitStatus;                <span class="hljs-comment">// 如果有其它线程也在释放读锁，那么需要将 waitStatus 先改为 0</span>                <span class="hljs-comment">// 防止 unparkSuccessor 被多次执行</span>                <span class="hljs-keyword">if</span> (ws == Node.SIGNAL) &#123;                    <span class="hljs-keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="hljs-number">0</span>))                        <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// loop to recheck cases</span>                    unparkSuccessor(h);                &#125;                <span class="hljs-comment">// 如果已经是 0 了，改为 -3，用来解决传播性，见后文信号量 bug 分析</span>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ws == <span class="hljs-number">0</span> &amp;&amp;                        !compareAndSetWaitStatus(h, <span class="hljs-number">0</span>, Node.PROPAGATE))                    <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// loop on failed CAS</span>            &#125;            <span class="hljs-keyword">if</span> (h == head) <span class="hljs-comment">// loop if head changed</span>                <span class="hljs-keyword">break</span>;        &#125;    &#125;&#125;</code></pre><h4 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h4><p>该类自 JDK 8 加入，是为了进一步<code>优化读性能</code>，它的特点是在使用读锁、写锁时都必须配合<code>【戳】</code>使用 加解读锁</p><pre><code class="hljs java"><span class="hljs-keyword">long</span> stamp = lock.readLock();lock.unlockRead(stamp);</code></pre><p>加解写锁</p><pre><code class="hljs java"><span class="hljs-keyword">long</span> stamp = lock.writeLock();lock.unlockWrite(stamp);</code></pre><p><code>乐观读</code>，StampedLock 支持 tryOptimisticRead() 方法（乐观读），读取完毕后需要做一次 <code>戳校验</code> 如果校验通过，表示这期间确实没有写操作，数据可以安全使用，如果校验没通过，需要重新获取读锁，保证数据安全。</p><pre><code class="hljs java"><span class="hljs-keyword">long</span> stamp = lock.tryOptimisticRead();<span class="hljs-comment">// 验戳</span><span class="hljs-keyword">if</span>(!lock.validate(stamp))&#123; <span class="hljs-comment">// 锁升级 验证失败</span>&#125;</code></pre><p>提供一个 数据容器类 内部分别使用读锁保护数据的 read() 方法，写锁保护数据的 write() 方法 </p><blockquote><p>StampedLock 不支持条件变量 StampedLock 不支持可重入</p></blockquote><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.DataContainerStamped&quot;)</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DataContainerStamped</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> data;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> StampedLock lock = <span class="hljs-keyword">new</span> StampedLock();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DataContainerStamped</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span> </span>&#123;        <span class="hljs-keyword">this</span>.data = data;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> readTime)</span> </span>&#123;        <span class="hljs-keyword">long</span> stamp = lock.tryOptimisticRead();        log.debug(<span class="hljs-string">&quot;optimistic read locking...&#123;&#125;&quot;</span>, stamp);        Sleeper.sleep(readTime);        <span class="hljs-keyword">if</span> (lock.validate(stamp)) &#123;            log.debug(<span class="hljs-string">&quot;read finish...&#123;&#125;, data:&#123;&#125;&quot;</span>, stamp, data);            <span class="hljs-keyword">return</span> data;        &#125;        <span class="hljs-comment">// 锁升级 - 读锁</span>        log.debug(<span class="hljs-string">&quot;updating to read lock... &#123;&#125;&quot;</span>, stamp);        <span class="hljs-keyword">try</span> &#123;            stamp = lock.readLock();            log.debug(<span class="hljs-string">&quot;read lock &#123;&#125;&quot;</span>, stamp);            Sleeper.sleep(readTime);            log.debug(<span class="hljs-string">&quot;read finish...&#123;&#125;, data:&#123;&#125;&quot;</span>, stamp, data);            <span class="hljs-keyword">return</span> data;        &#125; <span class="hljs-keyword">finally</span> &#123;            log.debug(<span class="hljs-string">&quot;read unlock &#123;&#125;&quot;</span>, stamp);            lock.unlockRead(stamp);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-keyword">int</span> newData)</span> </span>&#123;        <span class="hljs-keyword">long</span> stamp = lock.writeLock();        log.debug(<span class="hljs-string">&quot;write lock &#123;&#125;&quot;</span>, stamp);        <span class="hljs-keyword">try</span> &#123;            Sleeper.sleep(<span class="hljs-number">2</span>);            <span class="hljs-keyword">this</span>.data = newData;        &#125; <span class="hljs-keyword">finally</span> &#123;            log.debug(<span class="hljs-string">&quot;write unlock &#123;&#125;&quot;</span>, stamp);            lock.unlockWrite(stamp);        &#125;    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    DataContainerStamped dataContainer = <span class="hljs-keyword">new</span> DataContainerStamped(<span class="hljs-number">1</span>);    <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;        dataContainer.read(<span class="hljs-number">1</span>);    &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();    Sleeper.sleep(<span class="hljs-number">0.5</span>);    <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;        dataContainer.read(<span class="hljs-number">0</span>);    &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();&#125;</code></pre><p>双读：</p><pre><code class="hljs ruby"><span class="hljs-number">20</span><span class="hljs-symbol">:</span><span class="hljs-number">44</span><span class="hljs-symbol">:</span><span class="hljs-number">04</span> [t1] c.DataContainerStamped - optimistic read locking...<span class="hljs-number">256</span><span class="hljs-number">20</span><span class="hljs-symbol">:</span><span class="hljs-number">44</span><span class="hljs-symbol">:</span><span class="hljs-number">04</span> [t2] c.DataContainerStamped - optimistic read locking...<span class="hljs-number">256</span><span class="hljs-number">20</span><span class="hljs-symbol">:</span><span class="hljs-number">44</span><span class="hljs-symbol">:</span><span class="hljs-number">04</span> [t2] c.DataContainerStamped - read finish...<span class="hljs-number">256</span>, <span class="hljs-symbol">data:</span><span class="hljs-number">1</span><span class="hljs-number">20</span><span class="hljs-symbol">:</span><span class="hljs-number">44</span><span class="hljs-symbol">:</span><span class="hljs-number">05</span> [t1] c.DataContainerStamped - read finish...<span class="hljs-number">256</span>, <span class="hljs-symbol">data:</span><span class="hljs-number">1</span></code></pre><p>一读一写：</p><pre><code class="hljs ruby"><span class="hljs-number">20</span><span class="hljs-symbol">:</span><span class="hljs-number">45</span><span class="hljs-symbol">:</span><span class="hljs-number">58</span> [t1] c.DataContainerStamped - optimistic read locking...<span class="hljs-number">256</span><span class="hljs-number">20</span><span class="hljs-symbol">:</span><span class="hljs-number">45</span><span class="hljs-symbol">:</span><span class="hljs-number">59</span> [t2] c.DataContainerStamped - write lock <span class="hljs-number">384</span><span class="hljs-number">20</span><span class="hljs-symbol">:</span><span class="hljs-number">45</span><span class="hljs-symbol">:</span><span class="hljs-number">59</span> [t1] c.DataContainerStamped - updating to read lock... <span class="hljs-number">256</span><span class="hljs-number">20</span><span class="hljs-symbol">:</span><span class="hljs-number">46</span><span class="hljs-symbol">:</span><span class="hljs-number">01</span> [t2] c.DataContainerStamped - write unlock <span class="hljs-number">384</span><span class="hljs-number">20</span><span class="hljs-symbol">:</span><span class="hljs-number">46</span><span class="hljs-symbol">:</span><span class="hljs-number">01</span> [t1] c.DataContainerStamped - read lock <span class="hljs-number">513</span><span class="hljs-number">20</span><span class="hljs-symbol">:</span><span class="hljs-number">46</span><span class="hljs-symbol">:</span><span class="hljs-number">02</span> [t1] c.DataContainerStamped - read finish...<span class="hljs-number">513</span>, <span class="hljs-symbol">data:</span><span class="hljs-number">0</span><span class="hljs-number">20</span><span class="hljs-symbol">:</span><span class="hljs-number">46</span><span class="hljs-symbol">:</span><span class="hljs-number">02</span> [t1] c.DataContainerStamped - read unlock <span class="hljs-number">513</span></code></pre><blockquote><p>注意 缺点：<br>StampedLock 不支持条件变量<br>StampedLock 不支持可重入</p></blockquote><h3 id="7-9-Semaphore"><a href="#7-9-Semaphore" class="headerlink" title="7.9. Semaphore"></a>7.9. Semaphore</h3><h4 id="1-基本使用"><a href="#1-基本使用" class="headerlink" title="1) 基本使用"></a>1) 基本使用</h4><p>[ˈsɛməˌfɔr] 信号量，用来限制能同时访问共享资源的线程上限。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    <span class="hljs-comment">// 1. 创建 semaphore 对象</span>    Semaphore semaphore = <span class="hljs-keyword">new</span> Semaphore(<span class="hljs-number">3</span>);    <span class="hljs-comment">// 2. 10个线程同时运行</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            <span class="hljs-keyword">try</span> &#123;                semaphore.acquire();            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;            <span class="hljs-keyword">try</span> &#123;                log.debug(<span class="hljs-string">&quot;running...&quot;</span>);                Sleeper.sleep(<span class="hljs-number">1</span>);                log.debug(<span class="hljs-string">&quot;end...&quot;</span>);            &#125; <span class="hljs-keyword">finally</span> &#123;                semaphore.release();            &#125;        &#125;).start();    &#125;&#125;</code></pre><pre><code class="hljs ruby"><span class="hljs-number">20</span><span class="hljs-symbol">:</span><span class="hljs-number">50</span><span class="hljs-symbol">:</span><span class="hljs-number">48</span> [Thread-<span class="hljs-number">0</span>] c.TestSemaphore - running...<span class="hljs-number">20</span><span class="hljs-symbol">:</span><span class="hljs-number">50</span><span class="hljs-symbol">:</span><span class="hljs-number">48</span> [Thread-<span class="hljs-number">1</span>] c.TestSemaphore - running...<span class="hljs-number">20</span><span class="hljs-symbol">:</span><span class="hljs-number">50</span><span class="hljs-symbol">:</span><span class="hljs-number">48</span> [Thread-<span class="hljs-number">2</span>] c.TestSemaphore - running...<span class="hljs-number">20</span><span class="hljs-symbol">:</span><span class="hljs-number">50</span><span class="hljs-symbol">:</span><span class="hljs-number">49</span> [Thread-<span class="hljs-number">2</span>] c.TestSemaphore - <span class="hljs-keyword">end</span>...<span class="hljs-number">20</span><span class="hljs-symbol">:</span><span class="hljs-number">50</span><span class="hljs-symbol">:</span><span class="hljs-number">49</span> [Thread-<span class="hljs-number">1</span>] c.TestSemaphore - <span class="hljs-keyword">end</span>...<span class="hljs-number">20</span><span class="hljs-symbol">:</span><span class="hljs-number">50</span><span class="hljs-symbol">:</span><span class="hljs-number">49</span> [Thread-<span class="hljs-number">0</span>] c.TestSemaphore - <span class="hljs-keyword">end</span>...<span class="hljs-number">20</span><span class="hljs-symbol">:</span><span class="hljs-number">50</span><span class="hljs-symbol">:</span><span class="hljs-number">49</span> [Thread-<span class="hljs-number">3</span>] c.TestSemaphore - running...<span class="hljs-number">20</span><span class="hljs-symbol">:</span><span class="hljs-number">50</span><span class="hljs-symbol">:</span><span class="hljs-number">49</span> [Thread-<span class="hljs-number">4</span>] c.TestSemaphore - running...<span class="hljs-number">20</span><span class="hljs-symbol">:</span><span class="hljs-number">50</span><span class="hljs-symbol">:</span><span class="hljs-number">50</span> [Thread-<span class="hljs-number">4</span>] c.TestSemaphore - <span class="hljs-keyword">end</span>...<span class="hljs-number">20</span><span class="hljs-symbol">:</span><span class="hljs-number">50</span><span class="hljs-symbol">:</span><span class="hljs-number">50</span> [Thread-<span class="hljs-number">3</span>] c.TestSemaphore - <span class="hljs-keyword">end</span>...</code></pre><h4 id="2-应用"><a href="#2-应用" class="headerlink" title="2) 应用"></a>2) 应用</h4><ul><li>使用 Semaphore <code>限流</code>，在访问高峰期时，让请求线程阻塞，高峰期过去再释放许可，当然它<code>只适合限制单机线程数量</code>，并且<code>仅是限制线程数，而不是限制资源数</code>（例如连接数，请对比 Tomcat LimitLatch 的实现</li><li>用 Semaphore 实现简单连接池，对比『享元模式』下的实现（用wait notify），性能和可读性显然更好，<br>注意下面的实现中线程数和数据库连接数是相等的</li></ul><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210506210457.png"></p><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Pool&quot;)</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pool</span> </span>&#123;    <span class="hljs-comment">// 1. 连接池大小</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> poolSize;    <span class="hljs-comment">// 2. 连接对象数组</span>    <span class="hljs-keyword">private</span> Connection[] connections;    <span class="hljs-comment">// 3. 连接状态数组 0 表示空闲， 1 表示繁忙</span>    <span class="hljs-keyword">private</span> AtomicIntegerArray states;    <span class="hljs-keyword">private</span> Semaphore semaphore;    <span class="hljs-comment">// 4. 构造方法初始化</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Pool</span><span class="hljs-params">(<span class="hljs-keyword">int</span> poolSize)</span> </span>&#123;        <span class="hljs-keyword">this</span>.poolSize = poolSize;        <span class="hljs-comment">// 让许可数与资源数一致</span>        <span class="hljs-keyword">this</span>.semaphore = <span class="hljs-keyword">new</span> Semaphore(poolSize);        <span class="hljs-keyword">this</span>.connections = <span class="hljs-keyword">new</span> Connection[poolSize];        <span class="hljs-keyword">this</span>.states = <span class="hljs-keyword">new</span> AtomicIntegerArray(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[poolSize]);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; poolSize; i++) &#123;            connections[i] = <span class="hljs-keyword">new</span> MockConnection(<span class="hljs-string">&quot;连接&quot;</span> + (i+<span class="hljs-number">1</span>));        &#125;    &#125;    <span class="hljs-comment">// 5. 借连接</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Connection <span class="hljs-title">borrow</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">// t1, t2, t3</span>        <span class="hljs-comment">// 获取许可</span>        <span class="hljs-keyword">try</span> &#123;            semaphore.acquire(); <span class="hljs-comment">// 没有许可的线程，在此等待</span>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; poolSize; i++) &#123;            <span class="hljs-comment">// 获取空闲连接</span>            <span class="hljs-keyword">if</span>(states.get(i) == <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">if</span> (states.compareAndSet(i, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;                    log.debug(<span class="hljs-string">&quot;borrow &#123;&#125;&quot;</span>, connections[i]);                    <span class="hljs-keyword">return</span> connections[i];                &#125;            &#125;        &#125;        <span class="hljs-comment">// 不会执行到这里</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-comment">// 6. 归还连接</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">free</span><span class="hljs-params">(Connection conn)</span> </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; poolSize; i++) &#123;            <span class="hljs-keyword">if</span> (connections[i] == conn) &#123;                states.set(i, <span class="hljs-number">0</span>);                log.debug(<span class="hljs-string">&quot;free &#123;&#125;&quot;</span>, conn);                semaphore.release();                <span class="hljs-keyword">break</span>;            &#125;        &#125;    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MockConnection</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Connection</span> </span>&#123;<span class="hljs-comment">// .... </span>&#125;</code></pre><h4 id="3-原理"><a href="#3-原理" class="headerlink" title="3) 原理"></a>3) 原理</h4><h5 id="1-加锁解锁流程"><a href="#1-加锁解锁流程" class="headerlink" title="1. 加锁解锁流程"></a>1. 加锁解锁流程</h5><p>Semaphore 有点像一个停车场，permits 就好像停车位数量，当线程获得了 permits 就像是获得了停车位，然后停车场显示空余车位减一</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Semaphore</span><span class="hljs-params">(<span class="hljs-keyword">int</span> permits)</span> </span>&#123;    sync = <span class="hljs-keyword">new</span> NonfairSync(permits);<span class="hljs-comment">// 调用同步器类</span>&#125;</code></pre><p>刚开始，permits（state）为 3，这时 5 个线程来获取</p><p>最后还是AQS</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210506211218.png"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210506211041.png"></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquire</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;    sync.acquireSharedInterruptibly(<span class="hljs-number">1</span>);&#125;<span class="hljs-comment">// Semaphore类</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquireSharedInterruptibly</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span></span><span class="hljs-function">            <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        <span class="hljs-keyword">if</span> (Thread.interrupted())            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InterruptedException();        <span class="hljs-keyword">if</span> (tryAcquireShared(arg) &lt; <span class="hljs-number">0</span>)            doAcquireSharedInterruptibly(arg);    &#125; AQS类<span class="hljs-comment">// 往下找子类实现</span>        <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">nonfairTryAcquireShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> acquires)</span> </span>&#123;            <span class="hljs-keyword">for</span> (;;) &#123;                <span class="hljs-keyword">int</span> available = getState(); <span class="hljs-comment">// 信号数</span>                <span class="hljs-keyword">int</span> remaining = available - acquires;                <span class="hljs-keyword">if</span> (remaining &lt; <span class="hljs-number">0</span> ||                    compareAndSetState(available, remaining))                    <span class="hljs-keyword">return</span> remaining;<span class="hljs-comment">// 剩余资源数量</span>            &#125;        &#125;</code></pre><p>假设其中 Thread-1，Thread-2，Thread-4 cas 竞争成功，而 Thread-0 和 Thread-3 竞争失败，进入 AQS 队列<br>park 阻塞</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquireSharedInterruptibly</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span></span><span class="hljs-function">        <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;    <span class="hljs-keyword">if</span> (Thread.interrupted())        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InterruptedException();        <span class="hljs-comment">// 如果124都成功，信号剩余数量为0，try就会失败</span>    <span class="hljs-keyword">if</span> (tryAcquireShared(arg) &lt; <span class="hljs-number">0</span>)    <span class="hljs-comment">// 执行do</span>        doAcquireSharedInterruptibly(arg);&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210506211804.png"></p><p>和之前类似，一样park</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210506211837.png"></p><p>这时 Thread-4 释放了 permits，状态如下</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210506211955.png"></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">release</span><span class="hljs-params">()</span> </span>&#123;    sync.releaseShared(<span class="hljs-number">1</span>);&#125;<span class="hljs-comment">// Semaphore类</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">releaseShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;        <span class="hljs-keyword">if</span> (tryReleaseShared(arg)) &#123;            doReleaseShared();            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;<span class="hljs-comment">// AQS</span><span class="hljs-comment">// 依然先try</span>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryReleaseShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> releases)</span> </span>&#123;            <span class="hljs-keyword">for</span> (;;) &#123;                <span class="hljs-keyword">int</span> current = getState();                <span class="hljs-keyword">int</span> next = current + releases;                <span class="hljs-keyword">if</span> (next &lt; current) <span class="hljs-comment">// overflow</span>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(<span class="hljs-string">&quot;Maximum permit count exceeded&quot;</span>);                <span class="hljs-keyword">if</span> (compareAndSetState(current, next))                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            &#125;        &#125;<span class="hljs-comment">// Semaphore实现</span><span class="hljs-comment">//然后执行doRelease</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doReleaseShared</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">for</span> (;;) &#123;            Node h = head;            <span class="hljs-keyword">if</span> (h != <span class="hljs-keyword">null</span> &amp;&amp; h != tail) &#123;                <span class="hljs-keyword">int</span> ws = h.waitStatus;                <span class="hljs-keyword">if</span> (ws == Node.SIGNAL) &#123;                    <span class="hljs-keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="hljs-number">0</span>))                        <span class="hljs-keyword">continue</span>;            <span class="hljs-comment">// loop to recheck cases</span>                    unparkSuccessor(h);<span class="hljs-comment">// 解锁那些park的（）doAcquire上面的方法</span>                &#125;                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ws == <span class="hljs-number">0</span> &amp;&amp;                         !compareAndSetWaitStatus(h, <span class="hljs-number">0</span>, Node.PROPAGATE))                    <span class="hljs-keyword">continue</span>;                <span class="hljs-comment">// loop on failed CAS</span>            &#125;            <span class="hljs-keyword">if</span> (h == head)                   <span class="hljs-comment">// loop if head changed</span>                <span class="hljs-keyword">break</span>;        &#125;    &#125;</code></pre><p>这时 Thread-4 释放了 permits，状态如下</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210506212636.png"></p><p>接下来 Thread-0 竞争成功，permits 再次设置为 0，设置自己为 head 节点，断开原来的 head 节点，unpark 接下来的 Thread-3 节点，但由于 permits 是 0，因此 Thread-3 在尝试不成功后再次进入 park 状态</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210506212712.png"></p><h3 id="7-10-CountDownLatch"><a href="#7-10-CountDownLatch" class="headerlink" title="7.10 CountDownLatch"></a>7.10 CountDownLatch</h3><p>用来进行<code>线程同步协作，等待所有线程完成倒计时</code>。<br>其中构造参数用来初始化等待计数值，<code>await() </code>用来等待计数归零，<code>countDown() </code>用来让计数减一</p><p>内部也是AQS</p><p>CountDownLatch允许 count 个线程阻塞在一个地方，直至所有线程的任务都执行完毕。</p><p>CountDownLatch是共享锁的一种实现,它<code>默认构造 AQS 的 state 值为 count</code>。当线程使用countDown方法时,其实使用了<code>tryReleaseShared</code>方法以CAS的操作来<code>减少state</code>,直至state为0就代表所有的线程都调用了countDown方法。当调用await方法的时候，如果state不为0，就代表仍然有线程没有调用countDown方法，那么就把已经调用过countDown的线程都放入阻塞队列Park,并自旋CAS判断state == 0，直至最后一个线程调用了countDown，使得state == 0，于是阻塞的线程便判断成功，全部往下执行。</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractQueuedSynchronizer</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">4982264981922014374L</span>;    Sync(<span class="hljs-keyword">int</span> count) &#123;        setState(count);    &#125;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getCount</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> getState();    &#125;    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> <span class="hljs-title">tryAcquireShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> acquires)</span> </span>&#123;        <span class="hljs-keyword">return</span> (getState() == <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryReleaseShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> releases)</span> </span>&#123;        <span class="hljs-comment">// Decrement count; signal when transition to zero</span>        <span class="hljs-keyword">for</span> (;;) &#123;            <span class="hljs-keyword">int</span> c = getState();            <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>)                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            <span class="hljs-keyword">int</span> nextc = c-<span class="hljs-number">1</span>; <span class="hljs-comment">// 实现一个就减1</span>            <span class="hljs-keyword">if</span> (compareAndSetState(c, nextc))                <span class="hljs-keyword">return</span> nextc == <span class="hljs-number">0</span>;        &#125;    &#125;&#125;</code></pre><h5 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h5><p>用线程池</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test5</span><span class="hljs-params">()</span> </span>&#123;    CountDownLatch latch = <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">3</span>);    ExecutorService service = Executors.newFixedThreadPool(<span class="hljs-number">4</span>);    service.submit(() -&gt; &#123;        log.debug(<span class="hljs-string">&quot;begin...&quot;</span>);        sleep(<span class="hljs-number">1</span>);        latch.countDown();        log.debug(<span class="hljs-string">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());    &#125;);    service.submit(() -&gt; &#123;        log.debug(<span class="hljs-string">&quot;begin...&quot;</span>);        sleep(<span class="hljs-number">1.5</span>);        latch.countDown();        log.debug(<span class="hljs-string">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());    &#125;);    service.submit(() -&gt; &#123;        log.debug(<span class="hljs-string">&quot;begin...&quot;</span>);        sleep(<span class="hljs-number">2</span>);        latch.countDown();        log.debug(<span class="hljs-string">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());    &#125;);    service.submit(()-&gt;&#123;        <span class="hljs-keyword">try</span> &#123;            log.debug(<span class="hljs-string">&quot;waiting...&quot;</span>);            latch.await();            log.debug(<span class="hljs-string">&quot;wait end...&quot;</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;);&#125;</code></pre><h5 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h5><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;    AtomicInteger num = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">0</span>);    ExecutorService service = Executors.newFixedThreadPool(<span class="hljs-number">10</span>, (r) -&gt; &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Thread(r, <span class="hljs-string">&quot;t&quot;</span> + num.getAndIncrement());    &#125;);    CountDownLatch latch = <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">10</span>);    String[] all = <span class="hljs-keyword">new</span> String[<span class="hljs-number">10</span>];    Random r = <span class="hljs-keyword">new</span> Random();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10</span>; j++) &#123;        <span class="hljs-keyword">int</span> x = j;        service.submit(() -&gt; &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">100</span>; i++) &#123;                <span class="hljs-keyword">try</span> &#123;                    Thread.sleep(r.nextInt(<span class="hljs-number">100</span>));                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                &#125;                all[x] = Thread.currentThread().getName() + <span class="hljs-string">&quot;(&quot;</span> + (i + <span class="hljs-string">&quot;%&quot;</span>) + <span class="hljs-string">&quot;)&quot;</span>;                System.out.print(<span class="hljs-string">&quot;\r&quot;</span> + Arrays.toString(all));            &#125;            latch.countDown();        &#125;);    &#125;    latch.await();    System.out.println(<span class="hljs-string">&quot;\n游戏开始...&quot;</span>);    service.shutdown();&#125;</code></pre><pre><code class="hljs ruby">[t0(<span class="hljs-number">100</span>%), t1(<span class="hljs-number">100</span>%), t2(<span class="hljs-number">100</span>%), t3(<span class="hljs-number">100</span>%), t4(<span class="hljs-number">100</span>%), t5(<span class="hljs-number">100</span>%), t6(<span class="hljs-number">100</span>%), t7(<span class="hljs-number">100</span>%), t8(<span class="hljs-number">100</span>%), t9(<span class="hljs-number">100</span>%)]游戏开始...</code></pre><h5 id="future应用"><a href="#future应用" class="headerlink" title="future应用"></a>future应用</h5><pre><code class="hljs java">Future&lt;Map&lt;String, Object&gt;&gt; f2 = service.submit(() -&gt; &#123;  Map&lt;String, Object&gt; r =  restTemplate.getForObject(<span class="hljs-string">&quot;http://localhost:8080/product/&#123;1&#125;&quot;</span>, Map.class, <span class="hljs-number">1</span>);  <span class="hljs-keyword">return</span> r;&#125;);</code></pre><h3 id="7-11-CyclicBarrier"><a href="#7-11-CyclicBarrier" class="headerlink" title="7.11 CyclicBarrier"></a>7.11 CyclicBarrier</h3><p>[ˈsaɪklɪk ˈbæriɚ] 循环栅栏，用来进行线程协作，<code>等待线程满足某个计数</code>。构造时设置『计数个数』，每个线程执行到某个需要“同步”的时刻调用 await() 方法进行等待，当等待的线程数满足『计数个数』时，继续执行</p><pre><code class="hljs java">CyclicBarrier cb = <span class="hljs-keyword">new</span> CyclicBarrier(<span class="hljs-number">2</span>); <span class="hljs-comment">// 个数为2时才会继续执行</span><span class="hljs-keyword">new</span> Thread(()-&gt;&#123;System.out.println(<span class="hljs-string">&quot;线程1开始..&quot;</span>+<span class="hljs-keyword">new</span> Date());<span class="hljs-keyword">try</span> &#123;cb.await(); <span class="hljs-comment">// 当个数不足时，等待</span>&#125; <span class="hljs-keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;e.printStackTrace();&#125;System.out.println(<span class="hljs-string">&quot;线程1继续向下运行...&quot;</span>+<span class="hljs-keyword">new</span> Date());&#125;).start();<span class="hljs-keyword">new</span> Thread(()-&gt;&#123;System.out.println(<span class="hljs-string">&quot;线程2开始..&quot;</span>+<span class="hljs-keyword">new</span> Date());<span class="hljs-keyword">try</span> &#123; Thread.sleep(<span class="hljs-number">2000</span>); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; &#125;<span class="hljs-keyword">try</span> &#123;cb.await(); <span class="hljs-comment">// 2 秒后，线程个数够2，继续运行</span>&#125; <span class="hljs-keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;e.printStackTrace();&#125;System.out.println(<span class="hljs-string">&quot;线程2继续向下运行...&quot;</span>+<span class="hljs-keyword">new</span> Date());&#125;).start();</code></pre><blockquote><p>注意 CyclicBarrier 与 CountDownLatch 的主要区别在于 CyclicBarrier 是 <code>可以重用</code>的 CyclicBarrier 可以被比喻为『人满发车』</p></blockquote><h5 id="可重用"><a href="#可重用" class="headerlink" title="可重用"></a>可重用</h5><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    ExecutorService service = Executors.newFixedThreadPool(<span class="hljs-number">3</span>);    CyclicBarrier barrier = <span class="hljs-keyword">new</span> CyclicBarrier(<span class="hljs-number">2</span>, ()-&gt; &#123;        log.debug(<span class="hljs-string">&quot;task1, task2 finish...&quot;</span>);    &#125;);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123; <span class="hljs-comment">// task1  task2  task1</span>        service.submit(() -&gt; &#123;            log.debug(<span class="hljs-string">&quot;task1 begin...&quot;</span>);            Sleeper.sleep(<span class="hljs-number">1</span>);            <span class="hljs-keyword">try</span> &#123;                barrier.await(); <span class="hljs-comment">// 2-1=1</span>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;                e.printStackTrace();            &#125;        &#125;);        service.submit(() -&gt; &#123;            log.debug(<span class="hljs-string">&quot;task2 begin...&quot;</span>);            Sleeper.sleep(<span class="hljs-number">2</span>);            <span class="hljs-keyword">try</span> &#123;                barrier.await(); <span class="hljs-comment">// 1-1=0</span>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;                e.printStackTrace();            &#125;        &#125;);    &#125;    service.shutdown();&#125;</code></pre><pre><code class="hljs ruby"><span class="hljs-number">10</span><span class="hljs-symbol">:</span><span class="hljs-number">03</span><span class="hljs-symbol">:</span><span class="hljs-number">01</span> [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>] c.TestCyclicBarrier - task1 <span class="hljs-keyword">begin</span>...<span class="hljs-number">10</span><span class="hljs-symbol">:</span><span class="hljs-number">03</span><span class="hljs-symbol">:</span><span class="hljs-number">01</span> [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span>] c.TestCyclicBarrier - task2 <span class="hljs-keyword">begin</span>...<span class="hljs-number">10</span><span class="hljs-symbol">:</span><span class="hljs-number">03</span><span class="hljs-symbol">:</span><span class="hljs-number">01</span> [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">3</span>] c.TestCyclicBarrier - task1 <span class="hljs-keyword">begin</span>...<span class="hljs-number">10</span><span class="hljs-symbol">:</span><span class="hljs-number">03</span><span class="hljs-symbol">:</span><span class="hljs-number">02</span> [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">3</span>] c.TestCyclicBarrier - task1, task2 finish...<span class="hljs-number">10</span><span class="hljs-symbol">:</span><span class="hljs-number">03</span><span class="hljs-symbol">:</span><span class="hljs-number">02</span> [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>] c.TestCyclicBarrier - task2 <span class="hljs-keyword">begin</span>...<span class="hljs-number">10</span><span class="hljs-symbol">:</span><span class="hljs-number">03</span><span class="hljs-symbol">:</span><span class="hljs-number">02</span> [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">3</span>] c.TestCyclicBarrier - task1 <span class="hljs-keyword">begin</span>...<span class="hljs-number">10</span><span class="hljs-symbol">:</span><span class="hljs-number">03</span><span class="hljs-symbol">:</span><span class="hljs-number">03</span> [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">3</span>] c.TestCyclicBarrier - task1, task2 finish...<span class="hljs-number">10</span><span class="hljs-symbol">:</span><span class="hljs-number">03</span><span class="hljs-symbol">:</span><span class="hljs-number">03</span> [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">3</span>] c.TestCyclicBarrier - task2 <span class="hljs-keyword">begin</span>...<span class="hljs-number">10</span><span class="hljs-symbol">:</span><span class="hljs-number">03</span><span class="hljs-symbol">:</span><span class="hljs-number">05</span> [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">3</span>] c.TestCyclicBarrier - task1, task2 finish...</code></pre><p>CyclicBarrier中第二个lambda表达式，指达标后执行的任务；</p><h2 id="8、线程安全集合类概述"><a href="#8、线程安全集合类概述" class="headerlink" title="8、线程安全集合类概述"></a>8、线程安全集合类概述</h2><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210507101322.png"></p><p>hashtable为线程安全的map实现，vector是线程安全的list实现</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> V <span class="hljs-title">put</span><span class="hljs-params">(K key, V value)</span> </span>&#123;<span class="hljs-comment">//... hashtable的put</span>&#125;</code></pre><p>线程安全集合类可以分为三大类：</p><ul><li> <code>遗留的</code>线程安全集合如 Hashtable ， Vector</li><li>使用 <code>Collections 装饰的</code>线程安全集合，如：<ul><li>Collections.synchronizedCollection</li><li>Collections.synchronizedList</li><li>Collections.synchronizedMap</li><li>Collections.synchronizedSet</li><li>Collections.synchronizedNavigableMap</li><li>Collections.synchronizedNavigableSet</li><li>Collections.synchronizedSortedMap</li><li>Collections.synchronizedSortedSet</li><li><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210507101806.png"></li></ul></li><li>java.util.concurrent.*</li></ul><p>重点介绍 <code>java.util.concurrent.* </code>下的线程安全集合类，可以发现它们有规律，里面包含三类关键词：<code>Blocking、CopyOnWrite、Concurrent</code></p><ul><li><code>Blocking</code> 大部分实现基于锁，并提供用来阻塞的方法</li><li><code>CopyOnWrite</code> (修改时拷贝)之类容器 <strong>修改开销相对较重</strong> ，适用读多写少</li><li><code>Concurrent</code> 类型的容器<ul><li>内部很多操作使用  <strong>cas 优化</strong> ，（多把锁）一般可以提供较高吞吐量</li><li><strong>弱一致性</strong> <ul><li><strong>遍历时</strong> 弱一致性，例如，当利用迭代器遍历时，如果容器发生修改，迭代器仍然可以继续进行遍<br>历，这时内容是旧的</li><li> <strong>求大小</strong>  弱一致性，size 操作未必是 100% 准确</li><li> <strong>读取</strong> 弱一致性</li></ul></li></ul></li></ul><blockquote><p>遍历时如果发生了修改，对于非安全容器来讲，使用 <code>fail-fast 机制</code>也就是让遍历立刻失败，抛出<br>ConcurrentModificationException，不再继续遍历</p></blockquote><h3 id="1-ConcurrentHashMap"><a href="#1-ConcurrentHashMap" class="headerlink" title="1. ConcurrentHashMap"></a>1. ConcurrentHashMap</h3><h4 id="练习：单词计数"><a href="#练习：单词计数" class="headerlink" title="练习：单词计数"></a>练习：单词计数</h4><p>生成测试数据</p><p>生成每个字母200次，打乱，然后下发文件，最后统计</p><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String ALPHA = <span class="hljs-string">&quot;abcedfghijklmnopqrstuvwxyz&quot;</span>;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    <span class="hljs-keyword">int</span> length = ALPHA.length();    <span class="hljs-keyword">int</span> count = <span class="hljs-number">200</span>;    List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(length * count);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;      <span class="hljs-keyword">char</span> ch = ALPHA.charAt(i);      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; count; j++) &#123;        list.add(String.valueOf(ch));      &#125;    &#125;    Collections.shuffle(list);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++) &#123;      <span class="hljs-keyword">try</span> (PrintWriter out = <span class="hljs-keyword">new</span> PrintWriter(      <span class="hljs-keyword">new</span> OutputStreamWriter(      <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;tmp/&quot;</span> + (i+<span class="hljs-number">1</span>) + <span class="hljs-string">&quot;.txt&quot;</span>)))) &#123;      String collect = list.subList(i * count, (i + <span class="hljs-number">1</span>) * count).stream()      .collect(Collectors.joining(<span class="hljs-string">&quot;\n&quot;</span>));      out.print(collect);      &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;    &#125;  &#125;&#125;</code></pre><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210507103403.png" style="zoom:33%;" /><p>统计代码：</p><p>你要做的是实现两个参数</p><ul><li><p>一是提供一个 map 集合，用来存放每个单词的计数结果，key 为单词，value 为计数</p></li><li><p>二是提供一组操作，保证计数的安全性，会传递 map 集合以及 单词 List</p><p>正确结果输出应该是每个单词出现 200 次</p></li></ul><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;V&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">demo</span><span class="hljs-params">(Supplier&lt;Map&lt;String, V&gt;&gt; supplier, BiConsumer&lt;Map&lt;String, V&gt;, List&lt;String&gt;&gt; consumer)</span> </span>&#123;    Map&lt;String, V&gt; counterMap = supplier.get();    <span class="hljs-comment">// key value</span>    <span class="hljs-comment">// a   200</span>    <span class="hljs-comment">// b   200</span>    List&lt;Thread&gt; ts = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">26</span>; i++) &#123;        <span class="hljs-keyword">int</span> idx = i;        Thread thread = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            List&lt;String&gt; words = readFromFile(idx);            consumer.accept(counterMap, words);        &#125;);        ts.add(thread);    &#125;    ts.forEach(t -&gt; t.start());    ts.forEach(t -&gt; &#123;        <span class="hljs-keyword">try</span> &#123;            t.join();        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;);    System.out.println(counterMap);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;String&gt; <span class="hljs-title">readFromFile</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;    ArrayList&lt;String&gt; words = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">try</span> (BufferedReader in = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;tmp/&quot;</span> + i + <span class="hljs-string">&quot;.txt&quot;</span>)))) &#123;        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;            String word = in.readLine();            <span class="hljs-keyword">if</span> (word == <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-keyword">break</span>;            &#125;            words.add(word);        &#125;        <span class="hljs-keyword">return</span> words;    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);    &#125;&#125;</code></pre><h5 id="hashmap测试："><a href="#hashmap测试：" class="headerlink" title="hashmap测试："></a>hashmap测试：</h5><pre><code class="hljs java">demo(        <span class="hljs-comment">// 创建 map 集合</span>        () -&gt; <span class="hljs-keyword">new</span> HashMap&lt;String, Integer&gt;(),        (map, words) -&gt; &#123;            <span class="hljs-keyword">for</span> (String word : words) &#123;                <span class="hljs-comment">// 检查 key 有没有</span>                Integer counter = map.get(word);                <span class="hljs-keyword">int</span> newValue = counter == <span class="hljs-keyword">null</span> ? <span class="hljs-number">1</span> : counter + <span class="hljs-number">1</span>;                <span class="hljs-comment">// 没有 则 put</span>                map.put(word, newValue);            &#125;        &#125;);</code></pre><pre><code class="hljs ruby">&#123;a=<span class="hljs-number">136</span>, b=<span class="hljs-number">197</span>, c=<span class="hljs-number">197</span>, d=<span class="hljs-number">197</span>, e=<span class="hljs-number">193</span>, f=<span class="hljs-number">198</span>, g=<span class="hljs-number">194</span>, h=<span class="hljs-number">194</span>, i=<span class="hljs-number">193</span>, j=<span class="hljs-number">192</span>, k=<span class="hljs-number">191</span>, l=<span class="hljs-number">195</span>, m=<span class="hljs-number">198</span>, n=<span class="hljs-number">198</span>, o=<span class="hljs-number">196</span>, p=<span class="hljs-number">195</span>, q=<span class="hljs-number">195</span>, r=<span class="hljs-number">194</span>, s=<span class="hljs-number">195</span>, t=<span class="hljs-number">195</span>, u=<span class="hljs-number">197</span>, v=<span class="hljs-number">194</span>, w=<span class="hljs-number">199</span>, x=<span class="hljs-number">200</span>, y=<span class="hljs-number">197</span>, z=<span class="hljs-number">196</span>&#125;/<span class="hljs-regexp">/ 结果错误</span></code></pre><h5 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h5><pre><code class="hljs java">demo(        <span class="hljs-comment">// 创建 map 集合</span>        () -&gt; <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;String, Integer&gt;(),        (map, words) -&gt; &#123;            <span class="hljs-keyword">for</span> (String word : words) &#123;                <span class="hljs-comment">// 检查 key 有没有</span>                Integer counter = map.get(word);                <span class="hljs-keyword">int</span> newValue = counter == <span class="hljs-keyword">null</span> ? <span class="hljs-number">1</span> : counter + <span class="hljs-number">1</span>;                <span class="hljs-comment">// 没有 则 put</span>                map.put(word, newValue);            &#125;        &#125;);</code></pre><pre><code class="hljs ruby">&#123;a=<span class="hljs-number">200</span>, b=<span class="hljs-number">194</span>, c=<span class="hljs-number">195</span>, d=<span class="hljs-number">191</span>, e=<span class="hljs-number">194</span>, f=<span class="hljs-number">196</span>, g=<span class="hljs-number">196</span>, h=<span class="hljs-number">193</span>, i=<span class="hljs-number">197</span>, j=<span class="hljs-number">193</span>, k=<span class="hljs-number">194</span>, l=<span class="hljs-number">194</span>, m=<span class="hljs-number">197</span>, n=<span class="hljs-number">194</span>, o=<span class="hljs-number">189</span>, p=<span class="hljs-number">197</span>, q=<span class="hljs-number">193</span>, r=<span class="hljs-number">198</span>, s=<span class="hljs-number">193</span>, t=<span class="hljs-number">193</span>, u=<span class="hljs-number">192</span>, v=<span class="hljs-number">192</span>, w=<span class="hljs-number">193</span>, x=<span class="hljs-number">193</span>, y=<span class="hljs-number">194</span>, z=<span class="hljs-number">195</span>&#125;/<span class="hljs-regexp">/ 也不行</span></code></pre><p>为什么也不行？</p><p>就算是ConcurrentHashMap，方法中get put组合一起不是原子的</p><h5 id="正确使用"><a href="#正确使用" class="headerlink" title="正确使用"></a>正确使用</h5><h6 id="方法一：-锁"><a href="#方法一：-锁" class="headerlink" title="方法一： 锁"></a>方法一： 锁</h6><pre><code class="hljs java"><span class="hljs-comment">// 检查 key 有没有</span><span class="hljs-keyword">synchronized</span> (map)&#123;    Integer counter = map.get(word);    <span class="hljs-keyword">int</span> newValue = counter == <span class="hljs-keyword">null</span> ? <span class="hljs-number">1</span> : counter + <span class="hljs-number">1</span>;    <span class="hljs-comment">// 没有 则 put</span>    map.put(word, newValue);&#125;</code></pre><pre><code class="hljs ruby">&#123;a=<span class="hljs-number">200</span>, b=<span class="hljs-number">200</span>, c=<span class="hljs-number">200</span>, d=<span class="hljs-number">200</span>, e=<span class="hljs-number">200</span>, f=<span class="hljs-number">200</span>, g=<span class="hljs-number">200</span>, h=<span class="hljs-number">200</span>, i=<span class="hljs-number">200</span>, j=<span class="hljs-number">200</span>, k=<span class="hljs-number">200</span>, l=<span class="hljs-number">200</span>, m=<span class="hljs-number">200</span>, n=<span class="hljs-number">200</span>, o=<span class="hljs-number">200</span>, p=<span class="hljs-number">200</span>, q=<span class="hljs-number">200</span>, r=<span class="hljs-number">200</span>, s=<span class="hljs-number">200</span>, t=<span class="hljs-number">200</span>, u=<span class="hljs-number">200</span>, v=<span class="hljs-number">200</span>, w=<span class="hljs-number">200</span>, x=<span class="hljs-number">200</span>, y=<span class="hljs-number">200</span>, z=<span class="hljs-number">200</span>&#125;</code></pre><h6 id="方法二：computeIfAbsent"><a href="#方法二：computeIfAbsent" class="headerlink" title="方法二：computeIfAbsent"></a>方法二：computeIfAbsent</h6><p>如果缺少key，则生成value，然后把kv放入map</p><pre><code class="hljs java">demo(  () -&gt; <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;String, LongAdder&gt;(),    (map, words) -&gt; &#123;    <span class="hljs-keyword">for</span> (String word : words) &#123;        <span class="hljs-comment">// 注意不能使用 putIfAbsent，此方法返回的是上一次的 value，首次调用返回 null</span>        map.computeIfAbsent(word, (key) -&gt; <span class="hljs-keyword">new</span> LongAdder()).increment();    &#125;  &#125;);</code></pre><h6 id="方法三：-函数式编程"><a href="#方法三：-函数式编程" class="headerlink" title="方法三： 函数式编程"></a>方法三： 函数式编程</h6><pre><code class="hljs java">demo(  () -&gt; <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;String, Integer&gt;(),    (map, words) -&gt; &#123;    <span class="hljs-keyword">for</span> (String word : words) &#123;    <span class="hljs-comment">// 函数式编程，无需原子变量</span>    map.merge(word, <span class="hljs-number">1</span>, Integer::sum);    &#125;  &#125;);</code></pre><h4 id="ConcurrentHashMap-原理"><a href="#ConcurrentHashMap-原理" class="headerlink" title="* ConcurrentHashMap 原理"></a>* ConcurrentHashMap 原理</h4><p><a href="https://www.bilibili.com/video/BV16J411h7Rd?p=277&spm_id_from=pageDriver">视频</a></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210507105717.png"></p><p>jdk8后加入放<code>尾部</code></p><p>jdk7加入放<code>头部</code></p><h5 id="1-JDK-7-HashMap-并发死链"><a href="#1-JDK-7-HashMap-并发死链" class="headerlink" title="1) JDK 7 HashMap 并发死链"></a>1) JDK 7 HashMap 并发死链</h5><p>测试代码:要在 JDK 7 下运行，否则扩容机制和 hash 的计算方法都变了</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210507105920.png"></p><p>多线程扩容：并发死链</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestDeadLink</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">// 测试 java 7 中哪些数字的 hash 结果相等</span>        System.out.println(<span class="hljs-string">&quot;长度为16时，桶下标为1的key&quot;</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">64</span>; i++) &#123;            <span class="hljs-keyword">if</span> (hash(i) % <span class="hljs-number">16</span> == <span class="hljs-number">1</span>) &#123;                System.out.println(i);            &#125;        &#125;        System.out.println(<span class="hljs-string">&quot;长度为32时，桶下标为1的key&quot;</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">64</span>; i++) &#123;            <span class="hljs-keyword">if</span> (hash(i) % <span class="hljs-number">32</span> == <span class="hljs-number">1</span>) &#123;                System.out.println(i);            &#125;        &#125;        <span class="hljs-comment">// 1, 35, 16, 50 当大小为16时，它们在一个桶内</span>        <span class="hljs-keyword">final</span> HashMap&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;Integer, Integer&gt;();        <span class="hljs-comment">// 放 12 个元素</span>        map.put(<span class="hljs-number">2</span>, <span class="hljs-keyword">null</span>);        map.put(<span class="hljs-number">3</span>, <span class="hljs-keyword">null</span>);        map.put(<span class="hljs-number">4</span>, <span class="hljs-keyword">null</span>);        map.put(<span class="hljs-number">5</span>, <span class="hljs-keyword">null</span>);        map.put(<span class="hljs-number">6</span>, <span class="hljs-keyword">null</span>);        map.put(<span class="hljs-number">7</span>, <span class="hljs-keyword">null</span>);        map.put(<span class="hljs-number">8</span>, <span class="hljs-keyword">null</span>);        map.put(<span class="hljs-number">9</span>, <span class="hljs-keyword">null</span>);        map.put(<span class="hljs-number">10</span>, <span class="hljs-keyword">null</span>);        map.put(<span class="hljs-number">16</span>, <span class="hljs-keyword">null</span>);        map.put(<span class="hljs-number">35</span>, <span class="hljs-keyword">null</span>);        map.put(<span class="hljs-number">1</span>, <span class="hljs-keyword">null</span>);        System.out.println(<span class="hljs-string">&quot;扩容前大小[main]:&quot;</span>+map.size());        <span class="hljs-keyword">new</span> Thread() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                <span class="hljs-comment">// 放第 13 个元素, 发生扩容</span>                map.put(<span class="hljs-number">50</span>, <span class="hljs-keyword">null</span>);                System.out.println(<span class="hljs-string">&quot;扩容后大小[Thread-0]:&quot;</span>+map.size());            &#125;        &#125;.start();        <span class="hljs-keyword">new</span> Thread() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                <span class="hljs-comment">// 放第 13 个元素, 发生扩容</span>                map.put(<span class="hljs-number">50</span>, <span class="hljs-keyword">null</span>);                System.out.println(<span class="hljs-string">&quot;扩容后大小[Thread-1]:&quot;</span>+map.size());            &#125;        &#125;.start();    &#125;    <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(Object k)</span> </span>&#123;        <span class="hljs-keyword">int</span> h = <span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> != h &amp;&amp; k <span class="hljs-keyword">instanceof</span> String) &#123;            <span class="hljs-keyword">return</span> sun.misc.Hashing.stringHash32((String) k);        &#125;        h ^= k.hashCode();        h ^= (h &gt;&gt;&gt; <span class="hljs-number">20</span>) ^ (h &gt;&gt;&gt; <span class="hljs-number">12</span>);        <span class="hljs-keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="hljs-number">7</span>) ^ (h &gt;&gt;&gt; <span class="hljs-number">4</span>);    &#125;&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210507110147.png"></p><p>死链复现：</p><p>调试工具使用 idea<br>在 HashMap 源码 590 行加断点</p><pre><code class="hljs java"><span class="hljs-keyword">int</span> newCapacity = newTable.length;</code></pre><p>断点的条件如下，目的是让 HashMap 在扩容为 32 时，并且线程为 Thread-0 或 Thread-1 时停下来</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210507110903.png"></p><pre><code class="hljs java">newTable.length==<span class="hljs-number">32</span> &amp;&amp;(  Thread.currentThread().getName().equals(<span class="hljs-string">&quot;Thread-0&quot;</span>)||  Thread.currentThread().getName().equals(<span class="hljs-string">&quot;Thread-1&quot;</span>))</code></pre><p>断点暂停方式选择 Thread，否则在调试 Thread-0 时，Thread-1 无法恢复运行<br>运行代码，程序在预料的断点位置停了下来，输出</p><pre><code class="hljs ruby">长度为<span class="hljs-number">16</span>时，桶下标为<span class="hljs-number">1</span>的key <span class="hljs-number">1</span> <span class="hljs-number">16</span> <span class="hljs-number">35</span> <span class="hljs-number">50</span> 长度为<span class="hljs-number">32</span>时，桶下标为<span class="hljs-number">1</span>的key <span class="hljs-number">1</span> <span class="hljs-number">35</span> 扩容前大小[main]<span class="hljs-symbol">:</span><span class="hljs-number">12</span></code></pre><p>接下来进入扩容流程调试</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210507110953.png"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210507111128.png"></p><p>在 HashMap 源码 594 行加断点</p><pre><code class="hljs java">Entry&lt;K,V&gt; next = e.next; <span class="hljs-comment">// 593</span><span class="hljs-keyword">if</span> (rehash) <span class="hljs-comment">// 594</span><span class="hljs-comment">// ...</span></code></pre><p>这是为了观察 e 节点和 next 节点的状态，Thread-0 单步执行到 594 行，再 594 处再添加一个断点（条件<br>Thread.currentThread().getName().equals(“Thread-0”)）<br>这时可以在 Variables 面板观察到 e 和 next 变量，使用 <code>view as -&gt; Object</code> 查看节点状态</p><pre><code class="hljs ruby">e  /<span class="hljs-regexp">/ 正要去迁移的结点</span><span class="hljs-regexp">(1)-&gt;(35)-&gt;(16)-&gt;null  /</span><span class="hljs-regexp">/ 证明了后加入放链表头</span><span class="hljs-regexp">next  /</span><span class="hljs-regexp">/ e的下一个结点</span><span class="hljs-regexp">(35)-&gt;(16)-&gt;null</span></code></pre><p>在 Threads 面板选中 Thread-1 恢复运行，可以看到控制台输出新的内容如下，Thread-1 扩容已完成</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210507111526.png"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210507111741.png"></p><pre><code class="hljs ruby">newTable[<span class="hljs-number">1</span>] (<span class="hljs-number">35</span>)-&gt;(<span class="hljs-number">1</span>)-&gt;null</code></pre><pre><code class="hljs ruby">扩容后大小<span class="hljs-symbol">:</span><span class="hljs-number">13</span></code></pre><p>这时 Thread-0 还停在 594 处， Variables 面板变量的状态已经变化为</p><pre><code class="hljs ruby">e (<span class="hljs-number">1</span>)-&gt;null <span class="hljs-keyword">next</span> (<span class="hljs-number">35</span>)-&gt;(<span class="hljs-number">1</span>)-&gt;null</code></pre><p>为什么呢，因为 Thread-1 扩容时链表也是后加入的元素放入链表头，因此链表就倒过来了，但 Thread-1 虽然结果正确，但它结束后 <code>Thread-0 还要继续运行</code><br>接下来就可以单步调试（F8）观察死链的产生了<br>下一轮循环到 594，将 e 搬迁到 newTable 链表头</p><pre><code class="hljs ruby">newTable[<span class="hljs-number">1</span>] (<span class="hljs-number">1</span>)-&gt;null e (<span class="hljs-number">35</span>)-&gt;(<span class="hljs-number">1</span>)-&gt;null <span class="hljs-keyword">next</span> (<span class="hljs-number">1</span>)-&gt;null/<span class="hljs-regexp">/ 1 -&gt; 35 -&gt; 1 -&gt; 35</span></code></pre><p>下一轮循环到 594，将 e 搬迁到 newTable 链表头</p><pre><code class="hljs ruby">newTable[<span class="hljs-number">1</span>] (<span class="hljs-number">35</span>)-&gt;(<span class="hljs-number">1</span>)-&gt;null e (<span class="hljs-number">1</span>)-&gt;null <span class="hljs-keyword">next</span> null</code></pre><p>再看看源码</p><pre><code class="hljs java">e.next = newTable[<span class="hljs-number">1</span>];<span class="hljs-comment">// 这时 e (1,35)</span><span class="hljs-comment">// 而 newTable[1] (35,1)-&gt;(1,35) 因为是同一个对象</span>newTable[<span class="hljs-number">1</span>] = e; <span class="hljs-comment">// 再尝试将 e 作为链表头, 死链已成</span>e = next;<span class="hljs-comment">// 虽然 next 是 null, 会进入下一个链表的复制, 但死链已经形成了</span></code></pre><h5 id="2-源码分析"><a href="#2-源码分析" class="headerlink" title="2) 源码分析"></a>2) 源码分析</h5><p>HashMap 的并发死链发生在扩容时</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210507112320.png"></p><p>假设 map 中初始元素是</p><pre><code class="hljs ruby">原始链表，格式：[下标] (key,<span class="hljs-keyword">next</span>)[<span class="hljs-number">1</span>] (<span class="hljs-number">1</span>,<span class="hljs-number">35</span>)-&gt;(<span class="hljs-number">35</span>,<span class="hljs-number">16</span>)-&gt;(<span class="hljs-number">16</span>,null)线程 a 执行到 <span class="hljs-number">1</span> 处 ，此时局部变量 e 为 (<span class="hljs-number">1</span>,<span class="hljs-number">35</span>)，而局部变量 <span class="hljs-keyword">next</span> 为 (<span class="hljs-number">35</span>,<span class="hljs-number">16</span>) 线程 a 挂起线程 b 开始执行第一次循环[<span class="hljs-number">1</span>] (<span class="hljs-number">1</span>,null)第二次循环[<span class="hljs-number">1</span>] (<span class="hljs-number">35</span>,<span class="hljs-number">1</span>)-&gt;(<span class="hljs-number">1</span>,null)第三次循环[<span class="hljs-number">1</span>] (<span class="hljs-number">35</span>,<span class="hljs-number">1</span>)-&gt;(<span class="hljs-number">1</span>,null)[<span class="hljs-number">17</span>] (<span class="hljs-number">16</span>,null)切换回线程 a，此时局部变量 e 和 <span class="hljs-keyword">next</span> 被恢复，引用没变但内容变了：e 的内容被改为 (<span class="hljs-number">1</span>,null)，而 <span class="hljs-keyword">next</span> 的内容被改为 (<span class="hljs-number">35</span>,<span class="hljs-number">1</span>) 并链向 (<span class="hljs-number">1</span>,null)第一次循环[<span class="hljs-number">1</span>] (<span class="hljs-number">1</span>,null)第二次循环，注意这时 e 是 (<span class="hljs-number">35</span>,<span class="hljs-number">1</span>) 并链向 (<span class="hljs-number">1</span>,null) 所以 <span class="hljs-keyword">next</span> 又是 (<span class="hljs-number">1</span>,null)[<span class="hljs-number">1</span>] (<span class="hljs-number">35</span>,<span class="hljs-number">1</span>)-&gt;(<span class="hljs-number">1</span>,null)第三次循环，e 是 (<span class="hljs-number">1</span>,null)，而 <span class="hljs-keyword">next</span> 是 null，但 e 被放入链表头，这样 e.<span class="hljs-keyword">next</span> 变成了 <span class="hljs-number">35</span> （<span class="hljs-number">2</span> 处）[<span class="hljs-number">1</span>] (<span class="hljs-number">1</span>,<span class="hljs-number">35</span>)-&gt;(<span class="hljs-number">35</span>,<span class="hljs-number">1</span>)-&gt;(<span class="hljs-number">1</span>,<span class="hljs-number">35</span>)已经是死链了</code></pre><h5 id="3-小结"><a href="#3-小结" class="headerlink" title="3) 小结"></a>3) 小结</h5><ul><li>究其原因，是因为在多线程环境下使用了非线程安全的 map 集合</li><li>JDK 8 虽然将扩容算法做了调整，不再将元素加入链表头（而是保持与扩容前一样的顺序），但仍不意味着能够在多线程环境下能够安全扩容，还会出现其它问题（如扩容丢数据）</li></ul><h5 id="4-JDK-8-ConcurrentHashMap"><a href="#4-JDK-8-ConcurrentHashMap" class="headerlink" title="4) JDK 8 ConcurrentHashMap"></a>4) JDK 8 ConcurrentHashMap</h5><h6 id="重要属性和内部类"><a href="#重要属性和内部类" class="headerlink" title="重要属性和内部类"></a>重要属性和内部类</h6><pre><code class="hljs java"><span class="hljs-comment">// 默认为 0</span><span class="hljs-comment">// 当初始化时, 为 -1</span><span class="hljs-comment">// 当扩容时, 为 -(1 + 扩容线程数)</span><span class="hljs-comment">// 当初始化或扩容完成后，为 下一次的扩容的阈值大小</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> sizeCtl;<span class="hljs-comment">// 整个 ConcurrentHashMap 就是一个 Node[]</span><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Map</span>.<span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>&#123;&#125;<span class="hljs-comment">// hash 表</span><span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node&lt;K,V&gt;[] table;<span class="hljs-comment">// 扩容时的 新 hash 表</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;<span class="hljs-comment">// 扩容时如果某个 bin 迁移完毕, 用 ForwardingNode 作为旧 table bin 的头结点</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ForwardingNode</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>&#123;&#125;<span class="hljs-comment">// 用在 compute 以及 computeIfAbsent 时, 用来占位, 计算完成后替换为普通 Node</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReservationNode</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>&#123;&#125;<span class="hljs-comment">// 作为 treebin 的头节点, 存储 root 和 first 有关红黑树</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeBin</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>&#123;&#125;<span class="hljs-comment">// 作为 treebin 的节点, 存储 parent, left, right 有关红黑树</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>&#123;&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210507113046.png"></p><p>从后往前一个一个处理</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210507113140.png"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210507113153.png"></p><p>其他线程来到fnode发现已经处理完毕，不会处理；</p><p>其他线程想要get，发现是fnode，会从新的表中取</p><h6 id="重要方法"><a href="#重要方法" class="headerlink" title="重要方法"></a>重要方法</h6><pre><code class="hljs java"><span class="hljs-comment">// 获取 Node[] 中第 i 个 Node</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> &lt;K,V&gt; <span class="hljs-function">Node&lt;K,V&gt; <span class="hljs-title">tabAt</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab, <span class="hljs-keyword">int</span> i)</span></span><span class="hljs-function"><span class="hljs-comment">// cas 修改 Node[] 中第 i 个 Node 的值, c 为旧值, v 为新值</span></span><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> &lt;K,V&gt; <span class="hljs-keyword">boolean</span> <span class="hljs-title">casTabAt</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab, <span class="hljs-keyword">int</span> i, Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)</span></span><span class="hljs-function"><span class="hljs-comment">// 直接修改 Node[] 中第 i 个 Node 的值, v 为新值</span></span><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> &lt;K,V&gt; <span class="hljs-keyword">void</span> <span class="hljs-title">setTabAt</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab, <span class="hljs-keyword">int</span> i, Node&lt;K,V&gt; v)</span></span></code></pre><h6 id="构造器分析"><a href="#构造器分析" class="headerlink" title="构造器分析"></a>构造器分析</h6><p>可以看到实现了懒惰初始化，在构造方法中仅仅计算了 table 的大小，以后在第一次使用时才会真正创建</p><pre><code class="hljs java"><span class="hljs-comment">// 初始容量、负载因子 0.75 、并发度    </span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ConcurrentHashMap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity,</span></span><span class="hljs-function"><span class="hljs-params">                             <span class="hljs-keyword">float</span> loadFactor, <span class="hljs-keyword">int</span> concurrencyLevel)</span> </span>&#123;        <span class="hljs-keyword">if</span> (!(loadFactor &gt; <span class="hljs-number">0.0f</span>) || initialCapacity &lt; <span class="hljs-number">0</span> || concurrencyLevel &lt;= <span class="hljs-number">0</span>)            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException();        <span class="hljs-keyword">if</span> (initialCapacity &lt; concurrencyLevel)   <span class="hljs-comment">// Use at least as many bins</span>            initialCapacity = concurrencyLevel;   <span class="hljs-comment">// as estimated threads</span>        <span class="hljs-keyword">long</span> size = (<span class="hljs-keyword">long</span>)(<span class="hljs-number">1.0</span> + (<span class="hljs-keyword">long</span>)initialCapacity / loadFactor);        <span class="hljs-keyword">int</span> cap = (size &gt;= (<span class="hljs-keyword">long</span>)MAXIMUM_CAPACITY) ?            MAXIMUM_CAPACITY : tableSizeFor((<span class="hljs-keyword">int</span>)size);        <span class="hljs-keyword">this</span>.sizeCtl = cap;    &#125;</code></pre><h6 id="get-流程"><a href="#get-流程" class="headerlink" title="get 流程"></a>get 流程</h6><pre><code class="hljs JAVA"><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">get</span><span class="hljs-params">(Object key)</span> </span>&#123;    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="hljs-keyword">int</span> n, eh; K ek;  <span class="hljs-comment">// spread 方法能确保返回结果是正数</span>    <span class="hljs-keyword">int</span> h = spread(key.hashCode());    <span class="hljs-keyword">if</span> ((tab = table) != <span class="hljs-keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-comment">// 有元素</span>        (e = tabAt(tab, (n - <span class="hljs-number">1</span>) &amp; h)) != <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">// 桶下标找链表</span>       <span class="hljs-comment">// 判断头结点是不是已经是要查找的key</span>        <span class="hljs-keyword">if</span> ((eh = e.hash) == h) &#123;            <span class="hljs-keyword">if</span> ((ek = e.key) == key || (ek != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(ek)))                <span class="hljs-keyword">return</span> e.val;        &#125;      <span class="hljs-comment">// hash为负数表示该bin在扩容中或者是treebin，find来查找</span>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (eh &lt; <span class="hljs-number">0</span>)            <span class="hljs-keyword">return</span> (p = e.find(h, key)) != <span class="hljs-keyword">null</span> ? p.val : <span class="hljs-keyword">null</span>;      <span class="hljs-comment">// 正常遍历链表</span>        <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">if</span> (e.hash == h &amp;&amp;                ((ek = e.key) == key || (ek != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(ek))))                <span class="hljs-keyword">return</span> e.val;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;</code></pre><h6 id="put流程"><a href="#put流程" class="headerlink" title="put流程"></a>put流程</h6><p>以下数组简称（table），链表简称（bin）</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210507135748.png"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210507140008.png"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210507140206.png"></p><h6 id="initable流程"><a href="#initable流程" class="headerlink" title="initable流程"></a>initable流程</h6><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210507140454.png"></p><p>sizeCtl的值 -1 表示表在创建</p><h6 id="addCount流程"><a href="#addCount流程" class="headerlink" title="addCount流程"></a>addCount流程</h6><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210507140927.png"></p><p>sizeCtl扩容阈值</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210507141249.png"></p><h6 id="size计算"><a href="#size计算" class="headerlink" title="size计算"></a>size计算</h6><p>size 计算实际发生在 put，remove 改变集合元素的操作之中</p><ul><li>没有竞争发生，向 baseCount 累加计数</li><li>有竞争发生，新建 counterCells，向其中的一个 cell 累加计数<ul><li>counterCells 初始有两个 cell</li><li>如果计数竞争比较激烈，会创建新的 cell 来累加计数</li></ul></li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">long</span> n = sumCount();    <span class="hljs-keyword">return</span> ((n &lt; <span class="hljs-number">0L</span>) ? <span class="hljs-number">0</span> :            (n &gt; (<span class="hljs-keyword">long</span>)Integer.MAX_VALUE) ? Integer.MAX_VALUE :            (<span class="hljs-keyword">int</span>)n);&#125;    <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> <span class="hljs-title">sumCount</span><span class="hljs-params">()</span> </span>&#123;        CounterCell[] as = counterCells; CounterCell a;        <span class="hljs-keyword">long</span> sum = baseCount;        <span class="hljs-keyword">if</span> (as != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; as.length; ++i) &#123;                <span class="hljs-keyword">if</span> ((a = as[i]) != <span class="hljs-keyword">null</span>)                    sum += a.value;            &#125;        &#125;        <span class="hljs-keyword">return</span> sum;    &#125;<span class="hljs-comment">// 不是精确值</span></code></pre><h6 id="transfer"><a href="#transfer" class="headerlink" title="transfer"></a>transfer</h6><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210507142035.png"></p><p>Java 8 <code>数组（Node</code>） +<code>（ 链表 Node | 红黑树 TreeNode ）</code> 以下数组简称（table），链表简称（bin）</p><ul><li>初始化，使用 cas 来保证并发安全，<code>懒惰初始化 table</code></li><li>树化，当 table.length &lt; 64 时，先尝试扩容，超过 64 时，并且 bin.length &gt; 8 时，会将链表树化，树化过程会用 <code>synchronized 锁住链表头</code></li><li>put，如果该 bin 尚未创建，只需要使用 cas 创建 bin；如果已经有了，锁住链表头进行后续 put 操作，元素添加至 bin 的尾部</li><li>get，无锁操作仅需要保证可见性，扩容过程中 get 操作拿到的是 <code>ForwardingNode</code> 它会让 get 操作在新table 进行搜索</li><li>扩容，扩容时以 bin 为单位进行，需要对 bin 进行 synchronized，但这时妙的是其它竞争线程也不是无事可做，它们会<code>帮助把其它 bin 进行扩容</code>，扩容时平均只有 1/6 的节点会把复制到新 table 中</li><li>size，元素个数保存在 baseCount 中，并发时的个数变动保存在 CounterCell[] 当中。最后统计数量时累加<br>即可</li></ul><p>源码分析 <a href="http://www.importnew.com/28263.html">http://www.importnew.com/28263.html</a><br>其它实现 Cliff Click’s high scale lib</p><h4 id="5-JDK-7-ConcurrentHashMap"><a href="#5-JDK-7-ConcurrentHashMap" class="headerlink" title="5) JDK 7 ConcurrentHashMap"></a>5) JDK 7 ConcurrentHashMap</h4><p>它维护了一个 segment 数组，每个 segment 对应一把锁</p><ul><li>优点：如果多个线程访问不同的 segment，实际是没有冲突的，这与 jdk8 中是类似的（8 synchronized链表头）</li><li>缺点：Segments 数组默认大小为16，这个容量初始化指定后就不能改变了，并且不是懒惰初始化</li></ul><h6 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h6><pre><code class="hljs java">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ConcurrentHashMap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity, <span class="hljs-keyword">float</span> loadFactor, <span class="hljs-keyword">int</span> concurrencyLevel)</span> </span>&#123;        <span class="hljs-keyword">if</span> (!(loadFactor &gt; <span class="hljs-number">0</span>) || initialCapacity &lt; <span class="hljs-number">0</span> || concurrencyLevel &lt;= <span class="hljs-number">0</span>)            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException();        <span class="hljs-keyword">if</span> (concurrencyLevel &gt; MAX_SEGMENTS)            concurrencyLevel = MAX_SEGMENTS;<span class="hljs-comment">// ssize 必须是 2^n, 即 2, 4, 8, 16 ... 表示了 segments 数组的大小</span>        <span class="hljs-keyword">int</span> sshift = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> ssize = <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (ssize &lt; concurrencyLevel) &#123;            ++sshift;            ssize &lt;&lt;= <span class="hljs-number">1</span>;        &#125;<span class="hljs-comment">// segmentShift 默认是 32 - 4 = 28 (segments大小为16的时候)</span>        <span class="hljs-keyword">this</span>.segmentShift = <span class="hljs-number">32</span> - sshift;<span class="hljs-comment">// segmentMask 默认是 15 即 0000 0000 0000 1111</span>        <span class="hljs-keyword">this</span>.segmentMask = ssize - <span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)            initialCapacity = MAXIMUM_CAPACITY;        <span class="hljs-keyword">int</span> c = initialCapacity / ssize;        <span class="hljs-keyword">if</span> (c * ssize &lt; initialCapacity)            ++c;        <span class="hljs-keyword">int</span> cap = MIN_SEGMENT_TABLE_CAPACITY;        <span class="hljs-keyword">while</span> (cap &lt; c)            cap &lt;&lt;= <span class="hljs-number">1</span>;<span class="hljs-comment">// 创建 segments and segments[0]</span>        Segment&lt;K,V&gt; s0 =                <span class="hljs-keyword">new</span> Segment&lt;K,V&gt;(loadFactor, (<span class="hljs-keyword">int</span>)(cap * loadFactor),                        (HashEntry&lt;K,V&gt;[])<span class="hljs-keyword">new</span> HashEntry[cap]);        Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])<span class="hljs-keyword">new</span> Segment[ssize];        UNSAFE.putOrderedObject(ss, SBASE, s0); <span class="hljs-comment">// ordered write of segments[0]</span>        <span class="hljs-keyword">this</span>.segments = ss;    &#125;</code></pre><p>segments即分段锁，每一segment对应一个小的hash表，hashentry才是真正的hash表</p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210507142957.png" style="zoom:50%;" /><p>每个hashentry都是一个数组 + 链表</p><p>可以看到 ConcurrentHashMap 没有实现懒惰初始化，空间占用不友好<br>其中 this.segmentShift 和 this.segmentMask 的作用是 <code>决定将 key 的 hash 结果匹配到哪个 segment</code><br>例如，根据某一 hash 值求 segment 位置，先将高位向低位移动 this.segmentShift 位</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210507143533.png"></p><h6 id="put"><a href="#put" class="headerlink" title="put"></a>put</h6><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210507143835.png"></p><p>segment 继承了可重入锁（ReentrantLock），它的 put 方法为</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210507144010.png"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210507144026.png"></p><h6 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h6><p>rehash不需要考虑线程安全，扩容之前是在segment调用方法内，已经获取锁了才会执行</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210507145029.png"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210507145128.png"></p><h6 id="get"><a href="#get" class="headerlink" title="get"></a>get</h6><p>get 时并未加锁，用了 <code>UNSAFE 方法</code>保证了可见性，扩容过程中，get 先发生就从旧表取内容，get 后发生就从新<br>表取内容</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210507145408.png"></p><h6 id="size"><a href="#size" class="headerlink" title="size"></a>size</h6><ul><li>计算元素个数前，先不加锁计算两次，如果前后两次结果如一样，认为个数正确返回</li><li>如果不一样，进行重试，重试次数超过 3，将所有 segment 锁住，重新计算个数返回</li></ul><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210507145912.png"></p><h3 id="2-LinkedBlockingQueue-原理"><a href="#2-LinkedBlockingQueue-原理" class="headerlink" title="2. LinkedBlockingQueue 原理"></a>2. LinkedBlockingQueue 原理</h3><h4 id="1-基本入队出队"><a href="#1-基本入队出队" class="headerlink" title="1)  基本入队出队"></a>1)  基本入队出队</h4><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210507150055.png"></p><p>初始化链表 <code>last = head = new Node&lt;E&gt;(null)</code>; </p><p>Dummy 节点用来占位，item 为 null</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210507150148.png"></p><p>当一个节点入队 <code>last = last.next = node</code>;</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210507150217.png"></p><p>再来一个节点入队 last = last.next = node;</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210507150237.png"></p><p>出队</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210507150416.png"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210507150452.png"></p><h4 id="2-加锁分析"><a href="#2-加锁分析" class="headerlink" title="2) 加锁分析"></a>2) 加锁分析</h4><p> <strong>高明之处</strong> 在于用了<code>两把锁和 dummy 节点</code></p><ul><li>用一把锁，同一时刻，最多只允许有一个线程（生产者或消费者，二选一）执行</li><li>用两把锁，同一时刻，可以允许两个线程同时（一个生产者与一个消费者）执行<ul><li>消费者与消费者线程仍然串行</li><li>生产者与生产者线程仍然串行</li></ul></li></ul><p><code>线程安全分析</code></p><ul><li>当节点总数大于 2 时（包括 dummy 节点），putLock 保证的是 last 节点的线程安全，takeLock 保证的是<br>head 节点的线程安全。两把锁保证了入队和出队没有竞争</li><li>当节点总数等于 2 时（即一个 dummy 节点，一个正常节点）这时候，仍然是两把锁锁两个对象，不会竞争</li><li>当节点总数等于 1 时（就一个 dummy 节点）这时 <code>take 线程会被 notEmpty 条件阻塞，有竞争，会阻塞</code></li></ul><pre><code class="hljs java"><span class="hljs-comment">/** Lock held by take, poll, etc */</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ReentrantLock takeLock = <span class="hljs-keyword">new</span> ReentrantLock();<span class="hljs-comment">/** Wait queue for waiting takes */</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Condition notEmpty = takeLock.newCondition();<span class="hljs-comment">/** Lock held by put, offer, etc */</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ReentrantLock putLock = <span class="hljs-keyword">new</span> ReentrantLock();<span class="hljs-comment">/** Wait queue for waiting puts */</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Condition notFull = putLock.newCondition();</code></pre><h4 id="3-put"><a href="#3-put" class="headerlink" title="3) put"></a>3) put</h4><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210507151035.png"></p><blockquote><p>由 put 唤醒 put 是为了避免信号不足</p></blockquote><h4 id="4-take"><a href="#4-take" class="headerlink" title="4) take"></a>4) take</h4><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210507151143.png"></p><h4 id="5-性能比较"><a href="#5-性能比较" class="headerlink" title="5) 性能比较"></a>5) 性能比较</h4><p>主要列举 LinkedBlockingQueue 与 ArrayBlockingQueue 的性能比较</p><ul><li>Linked 支持有界，Array 强制有界</li><li>Linked 实现是链表，Array 实现是数组</li><li>Linked 是懒惰的，而 Array 需要提前初始化 Node 数组</li><li>Linked 每次入队会生成新 Node，而 Array 的 Node 是提前创建好的</li><li>Linked 两把锁，Array 一把锁</li></ul><h3 id="3-ConcurrentLinkedQueue"><a href="#3-ConcurrentLinkedQueue" class="headerlink" title="3. ConcurrentLinkedQueue"></a>3. ConcurrentLinkedQueue</h3><p>ConcurrentLinkedQueue 的设计与 LinkedBlockingQueue 非常像，也是</p><ul><li><code>两把【锁】</code>，同一时刻，可以允许两个线程同时（一个生产者与一个消费者）执行</li><li><code>dummy 节点</code>的引入让两把【锁】将来锁住的是不同对象，避免竞争</li><li>只是这【锁】使用了 <code>cas 来实现</code></li></ul><p>事实上，ConcurrentLinkedQueue 应用还是非常广泛的<br>例如之前讲的 Tomcat 的 Connector 结构时，Acceptor 作为生产者向 Poller 消费者传递事件信息时，正是采用了<br>ConcurrentLinkedQueue 将 SocketChannel 给 Poller 使用</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210507151939.png"></p><h3 id="4-CopyOnWriteArrayList"><a href="#4-CopyOnWriteArrayList" class="headerlink" title="4. CopyOnWriteArrayList"></a>4. CopyOnWriteArrayList</h3><p><code>CopyOnWriteArraySet</code> 是它的马甲 底层实现采用了 <code>写入时拷贝</code> 的思想，增删改操作会将底层数组拷贝一份，更改操作在新数组上执行，这时不影响其它线程的并发读，读写分离。 以新增为例：</p><pre><code class="hljs java">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;        <span class="hljs-keyword">synchronized</span> (lock) &#123;                        <span class="hljs-comment">// 获取旧的数组</span>            Object[] es = getArray();            <span class="hljs-keyword">int</span> len = es.length;<span class="hljs-comment">// 拷贝新的数组（这里是比较耗时的操作，但不影响其它读线程）</span>            es = Arrays.copyOf(es, len + <span class="hljs-number">1</span>);<span class="hljs-comment">// 添加新元素</span>            es[len] = e;<span class="hljs-comment">// 替换旧的数组</span>            setArray(es);            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;    &#125;</code></pre><blockquote><p>这里的源码版本是 Java 11，在 Java 1.8 中使用的是可重入锁而不是 synchronized</p></blockquote><p>其它读操作并未加锁，例如：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">forEach</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-keyword">super</span> E&gt; action)</span> </span>&#123;    Objects.requireNonNull(action);    <span class="hljs-keyword">for</span> (Object x : getArray()) &#123;        <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span> E e = (E) x;        action.accept(e);    &#125;&#125;</code></pre><p>适合『读多写少』的应用场景</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210507164325.png"></p><blockquote><p>不要觉得弱一致性就不好</p><ul><li>数据库的 MVCC 都是弱一致性的表现</li><li>并发高和一致性是矛盾的，需要权衡</li></ul></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构与算法基础回顾笔记</title>
    <link href="/2020/11/25/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/"/>
    <url>/2020/11/25/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>跟左神重学！</p></blockquote><h1 id="认识复杂度、对数器、二分法与异或运算"><a href="#认识复杂度、对数器、二分法与异或运算" class="headerlink" title="认识复杂度、对数器、二分法与异或运算"></a>认识复杂度、对数器、二分法与异或运算</h1><h2 id="认识复杂度"><a href="#认识复杂度" class="headerlink" title="认识复杂度"></a>认识复杂度</h2><blockquote><p>评估算法优劣的核心指标是什么？</p></blockquote><ul><li><p>时间复杂度（流程决定）</p></li><li><p>额外空间复杂度（流程决定）</p></li><li><p>常数项时间（实现细节决定）</p></li></ul><h3 id="1、什么是时间复杂度？时间复杂度怎么估算？"><a href="#1、什么是时间复杂度？时间复杂度怎么估算？" class="headerlink" title="1、什么是时间复杂度？时间复杂度怎么估算？"></a>1、什么是时间复杂度？时间复杂度怎么估算？</h3><ul><li>常数时间的操作</li><li>确定算法流程的总操作数量与样本数量之间的表达式关系</li><li>只看表达式最高阶项的部分</li></ul><h3 id="2、何为常数时间的操作？"><a href="#2、何为常数时间的操作？" class="headerlink" title="2、何为常数时间的操作？"></a>2、何为常数时间的操作？</h3><blockquote><p>如果一个操作的执行时间不以具体样本量为转移，每次执行时间都是固定时间。称这样的操作为常数时间的操作。如取Array[0]与取Array[1000000]花费时间一致， 不以数据量转移。</p></blockquote><p><strong>常见的常数时间的操作</strong></p><ul><li>常见的算术运算（+、-、*、/、% 等）</li><li>常见的位运算（&gt;&gt;(带符号右移)、&gt;&gt;&gt;(不带符号右移)、&lt;&lt;、|、&amp;、^等）</li><li>赋值、比较、自增、自减操作等</li><li>数组寻址操作</li></ul><p>总之，执行时间固定的操作都是常数时间的操作。<br>反之，执行时间不固定的操作，都不是常数时间的操作。</p><p><strong>如何确定算法流程的总操作数量与样本数量之间的表达式关系？</strong></p><p>​    1，想象该算法流程所处理的数据状况，要按照 <strong><em>最差</em></strong>情况来。</p><p>​    2，把整个流程彻底拆分为一个个 <strong><em>基本动作</em></strong>，保证每个动作都是 <strong><em>常数时间</em></strong>的操作。</p><p>​    3，如果数据量为N，看看基本动作的数量和N是什么关系。</p><h3 id="3、如何确定算法流程的时间复杂度？"><a href="#3、如何确定算法流程的时间复杂度？" class="headerlink" title="3、如何确定算法流程的时间复杂度？"></a>3、如何确定算法流程的时间复杂度？</h3><blockquote><p>当完成了表达式的建立，只要把最高阶项留下即可。低阶项都去掉，高阶项的系数也去掉。<br>记为：<strong>O(忽略掉系数的高阶项)</strong></p></blockquote><p>通过三个具体的例子，来实践一把时间复杂度的估算</p><h4 id="a、选择排序"><a href="#a、选择排序" class="headerlink" title="a、选择排序"></a>a、选择排序</h4><p>过程：<br>arr[0～N-1]范围上，找到最小值所在的位置，然后把最小值交换到0位置。<br>arr[1～N-1]范围上，找到最小值所在的位置，然后把最小值交换到1位置。<br>arr[2～N-1]范围上，找到最小值所在的位置，然后把最小值交换到2位置。<br>…<br>arr[N-1～N-1]范围上，找到最小值位置，然后把最小值交换到N-1位置。</p><p>估算：<br>很明显，如果arr长度为N，每一步常数操作的数量，如等差数列一般<br>所以，总的常数操作数量 = a*(N^2) + b*N + c (a、b、c都是常数)</p><p>所以选择排序的时间复杂度为 **O(N^2)**。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">selectionSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;   <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length &lt; <span class="hljs-number">2</span>) &#123;      <span class="hljs-keyword">return</span>;   &#125;   <span class="hljs-comment">// 0～n-1</span>   <span class="hljs-comment">// 1～n-1</span>   <span class="hljs-comment">// 2～n-1</span>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length - <span class="hljs-number">1</span>; i++) &#123; <span class="hljs-comment">// i ~ N-1</span>      <span class="hljs-comment">// 最小值在哪个位置上  i～n-1</span>      <span class="hljs-keyword">int</span> minIndex = i;      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; arr.length; j++) &#123; <span class="hljs-comment">// i ~ N-1 上找最小值的下标 </span>         minIndex = arr[j] &lt; arr[minIndex] ? j : minIndex;      &#125;      swap(arr, i, minIndex);   &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;   <span class="hljs-keyword">int</span> tmp = arr[i];   arr[i] = arr[j];   arr[j] = tmp;&#125;</code></pre><h4 id="b、冒泡排序"><a href="#b、冒泡排序" class="headerlink" title="b、冒泡排序"></a>b、冒泡排序</h4><p>过程：<br>在arr[0～N-1]范围上：<br>arr[0]和arr[1]，谁大谁来到1位置；arr[1]和arr[2]，谁大谁来到2位置…arr[N-2]和arr[N-1]，谁大谁来到N-1位置</p><p>在arr[0～N-2]范围上，重复上面的过程，但最后一步是arr[N-3]和arr[N-2]，谁大谁来到N-2位置<br>在arr[0～N-3]范围上，重复上面的过程，但最后一步是arr[N-4]和arr[N-3]，谁大谁来到N-3位置<br>…<br>最后在arr[0～1]范围上，重复上面的过程，但最后一步是arr[0]和arr[1]，谁大谁来到1位置</p><p>估算：<br>很明显，如果arr长度为N，每一步常数操作的数量，依然如等差数列一般<br>所以，总的常数操作数量 = a*(N^2) + b*N + c (a、b、c都是常数)</p><p>所以冒泡排序的时间复杂度为O(N^2)。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bubbleSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span></span>&#123;        <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length &lt; <span class="hljs-number">2</span>)&#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = arr.length - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--)&#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++)&#123;                <span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>])&#123;                    swap(arr, j, j+<span class="hljs-number">1</span>);                &#125;            &#125;        &#125;    &#125;    <span class="hljs-comment">// 交换arr的i和j位置上的值</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;        arr[i] = arr[i] ^ arr[j];        arr[j] = arr[i] ^ arr[j];        arr[i] = arr[i] ^ arr[j];    &#125;</code></pre><h4 id="c、插入排序"><a href="#c、插入排序" class="headerlink" title="c、插入排序"></a>c、插入排序</h4><p>过程：<br>想让arr[0<del>0]上有序，这个范围只有一个数，当然是有序的。<br>想让arr[0</del>1]上有序，所以从arr[1]开始往前看，如果arr[1]&lt;arr[0]，就交换。否则什么也不做。<br>想让arr[0<del>i]上有序，所以从arr[i]开始往前看，arr[i]这个数不停向左移动，一直移动到左边的数字不再比自己大，停止移动。<br>最后一步，想让arr[0</del>N-1]上有序， arr[N-1]这个数不停向左移动，一直移动到左边的数字不再比自己大，停止移动。</p><p>估算时发现这个算法流程的复杂程度，会因为数据状况的不同而不同。</p><pre><code class="hljs mathematica">如果某个算法流程的复杂程度会根据数据状况的不同而不同，那么你必须要按照最差情况来估计。很明显，在最差情况下，如果<span class="hljs-variable">arr</span>长度为<span class="hljs-built_in">N</span>，插入排序的每一步常数操作的数量，还是如等差数列一般所以，总的常数操作数量 <span class="hljs-operator">=</span> <span class="hljs-variable">a</span><span class="hljs-operator">*</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-operator">^</span><span class="hljs-number">2</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">+</span> <span class="hljs-variable">b</span><span class="hljs-operator">*</span><span class="hljs-built_in">N</span> <span class="hljs-operator">+</span> <span class="hljs-variable">c</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">a</span>、<span class="hljs-variable">b</span>、<span class="hljs-variable">c</span>都是常数<span class="hljs-punctuation">)</span>所以插入排序排序的时间复杂度为<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-operator">^</span><span class="hljs-number">2</span><span class="hljs-punctuation">)</span>。</code></pre><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertionSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;   <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length &lt; <span class="hljs-number">2</span>) &#123;      <span class="hljs-keyword">return</span>;   &#125;   <span class="hljs-comment">// 0~0 有序的</span>   <span class="hljs-comment">// 0~i 想有序</span>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; arr.length; i++) &#123; <span class="hljs-comment">// 0 ~ i 做到有序</span>            <span class="hljs-comment">// arr[i]往前看，一直交换到合适的位置停止</span>      <span class="hljs-comment">// ...(&lt;=)  ?       &lt;- i</span>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[j] &gt; arr[j + <span class="hljs-number">1</span>]; j--) &#123;         swap(arr, j, j + <span class="hljs-number">1</span>);      &#125;   &#125;&#125;<span class="hljs-comment">// i和j是一个位置的话，会出错</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;   arr[i] = arr[i] ^ arr[j];   arr[j] = arr[i] ^ arr[j];   arr[i] = arr[i] ^ arr[j];&#125;</code></pre><blockquote><p>注意</p></blockquote><ul><li><p>算法的过程，和具体的语言是无关的。</p></li><li><p>想分析一个算法流程的时间复杂度的前提，是对该流程非常熟悉</p></li><li><p>一定要确保在拆分算法流程时，拆分出来的所有行为都是常数时间的操作。这意味着你写算法时，对自己的用过的每一个系统api，都非常的熟悉。否则会影响你对时间复杂度的估算。</p><hr><pre><code class="hljs mathematica">排名从好到差：<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-number">1</span><span class="hljs-punctuation">)</span>   <span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-variable">logN</span><span class="hljs-punctuation">)</span>   <span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-punctuation">)</span>   <span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-operator">*</span><span class="hljs-variable">logN</span><span class="hljs-punctuation">)</span>   <span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-operator">^</span><span class="hljs-number">2</span><span class="hljs-punctuation">)</span>   <span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-operator">^</span><span class="hljs-number">3</span><span class="hljs-punctuation">)</span>   …   <span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-operator">^</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-number">2</span><span class="hljs-operator">^</span><span class="hljs-built_in">N</span><span class="hljs-punctuation">)</span>   <span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-number">3</span><span class="hljs-operator">^</span><span class="hljs-built_in">N</span><span class="hljs-punctuation">)</span>   …   <span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">K</span><span class="hljs-operator">^</span><span class="hljs-built_in">N</span><span class="hljs-punctuation">)</span><span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-operator">!</span><span class="hljs-punctuation">)</span></code></pre></li></ul><h3 id="4、时间复杂度的意义"><a href="#4、时间复杂度的意义" class="headerlink" title="4、时间复杂度的意义"></a>4、时间复杂度的意义</h3><p>抹掉了好多东西，只剩下了一个 <strong><em>最高阶项</em></strong>啊…</p><p>那这个东西有什么意义呢？</p><p>时间复杂度的意义在于：</p><p>当我们要处理的样本量很大很大时，我们会发现*<strong>低阶项是什么不是最重要的 **<em>；每一项的系数是什么，不是最重要的。</em></strong>真正重要的就是最高阶项是什么***。</p><p>这就是时间复杂度的意义，它是衡量算法流程的复杂程度的一种指标，该指标只与 <strong><em>数据量</em></strong>有关，与 <strong><em>过程之外的优化</em></strong>无关。</p><h3 id="5、额外空间复杂度"><a href="#5、额外空间复杂度" class="headerlink" title="5、额外空间复杂度"></a>5、额外空间复杂度</h3><p>你要实现一个算法流程，在实现算法流程的过程中，你需要开辟一些空间来支持你的算法流程。</p><p>作为 <strong><em>输入参数</em></strong>的空间，不算额外空间。<br>作为 <strong><em>输出结果</em></strong>的空间，也不算额外空间。</p><p>因为这些都是必要的、和现实目标有关的。所以都不算。<br>但除此之外，你的流程如果还需要开辟空间才能让你的流程继续下去。这部分空间就是额外空间。<br>如果你的流程只需要开辟有限几个变量，额外空间复杂度就是O(1)。</p><h3 id="6、算法流程的常数项"><a href="#6、算法流程的常数项" class="headerlink" title="6、算法流程的常数项"></a>6、算法流程的常数项</h3><p>我们会发现，时间复杂度这个指标，是忽略低阶项和所有常数系数的。<br>难道同样时间复杂度的流程，在实际运行时候就一样的好吗？<br>当然不是。</p><p>时间复杂度只是一个很重要的指标而已。如果两个时间复杂度一样的算法，你还要去在时间上拼优劣，就进入到拼常数时间的阶段，简称 <strong><em>拼常数项</em></strong>。</p><blockquote><p>算法流程的常数项的比拼方式</p></blockquote><p> <strong><em>放弃理论分析，生成随机数据直接测</em></strong>。</p><p>为什么不去理论分析？<br>不是不能纯分析，而是没必要。因为不同常数时间的操作，虽然都是固定时间，但还是有快慢之分的。</p><p>比如，位运算的常数时间原小于算术运算的常数时间，这两个运算的常数时间又远小于数组寻址的时间。<br>所以如果纯理论分析，往往会需要非常多的分析过程。都已经到了具体细节的程度，莫不如交给实验数据好了。</p><h3 id="7、面试、比赛、刷题中，一个问题的最优解是什么意思？"><a href="#7、面试、比赛、刷题中，一个问题的最优解是什么意思？" class="headerlink" title="7、面试、比赛、刷题中，一个问题的最优解是什么意思？"></a>7、面试、比赛、刷题中，一个问题的最优解是什么意思？</h3><p>一般情况下，认为解决一个问题的算法流程，在 <strong><em>时间复杂度</em></strong>的指标上，一定要尽可能的 <strong><em>低</em></strong>，先满足了时间复杂度最低这个指标之后，使用最少的 <strong><em>空间</em></strong>的算法流程，叫这个问题的最优解。</p><p>一般说起最优解都是 <strong><em>忽略掉常数项</em></strong>这个因素的，因为这个因素只决定了实现层次的优化和考虑，而和怎么解决整个问题的思想无关。</p><h2 id="对数器"><a href="#对数器" class="headerlink" title="对数器"></a>对数器</h2><h3 id="1、什么是对数器"><a href="#1、什么是对数器" class="headerlink" title="1、什么是对数器"></a>1、什么是对数器</h3><blockquote><p>认识对数器</p></blockquote><p>1，你想要测的方法a<br>2，实现复杂度不好但是容易实现的方法b<br>3，实现一个随机样本产生器<br>4，把方法a和方法b跑相同的随机样本，看看得到的结果是否一样<br>5，如果有一个随机样本使得比对结果不一致，打印样本进行人工干预，改对方法a和方法b<br>6，当样本数量很多时比对测试依然正确，可以确定方法a已经正确。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] generateRandomArray(<span class="hljs-keyword">int</span> maxSize, <span class="hljs-keyword">int</span> maxValue) &#123;   <span class="hljs-comment">// Math.random() -&gt;  [0,1) 所有的小数，等概率返回一个</span>   <span class="hljs-comment">// Math.random() * N -&gt; [0,N) 所有小数，等概率返回一个</span>   <span class="hljs-comment">// (int)(Math.random() * N) -&gt; [0,N-1] 所有的整数，等概率返回一个</span>   <span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[(<span class="hljs-keyword">int</span>) ((maxSize + <span class="hljs-number">1</span>) * Math.random())]; <span class="hljs-comment">// 长度随机 </span>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;      <span class="hljs-comment">// [-?,+?]</span>      arr[i] = (<span class="hljs-keyword">int</span>) ((maxValue + <span class="hljs-number">1</span>) * Math.random())             - (<span class="hljs-keyword">int</span>) (maxValue * Math.random());   &#125;   <span class="hljs-keyword">return</span> arr;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">comparator</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;Arrays.sort(arr);&#125;<span class="hljs-comment">// for copy</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] copyArray(<span class="hljs-keyword">int</span>[] arr) &#123;<span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;<span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[arr.length];<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;res[i] = arr[i];&#125;<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-comment">// for compare</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEqual</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr1, <span class="hljs-keyword">int</span>[] arr2)</span> </span>&#123;<span class="hljs-keyword">if</span> ((arr1 == <span class="hljs-keyword">null</span> &amp;&amp; arr2 != <span class="hljs-keyword">null</span>) || (arr1 != <span class="hljs-keyword">null</span> &amp;&amp; arr2 == <span class="hljs-keyword">null</span>)) &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;&#125;<span class="hljs-keyword">if</span> (arr1 == <span class="hljs-keyword">null</span> &amp;&amp; arr2 == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;&#125;<span class="hljs-keyword">if</span> (arr1.length != arr2.length) &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr1.length; i++) &#123;<span class="hljs-keyword">if</span> (arr1[i] != arr2[i]) &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-comment">// for test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;   <span class="hljs-keyword">int</span> testTime = <span class="hljs-number">500000</span>;   <span class="hljs-keyword">int</span> maxSize = <span class="hljs-number">100</span>; <span class="hljs-comment">// 随机数组的长度0～100</span>   <span class="hljs-keyword">int</span> maxValue = <span class="hljs-number">100</span>;<span class="hljs-comment">// 值：-100～100</span>   <span class="hljs-keyword">boolean</span> succeed = <span class="hljs-keyword">true</span>;   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; testTime; i++) &#123;      <span class="hljs-keyword">int</span>[] arr1 = generateRandomArray(maxSize, maxValue);      <span class="hljs-keyword">int</span>[] arr2 = copyArray(arr1);      insertionSort(arr1);      comparator(arr2);      <span class="hljs-keyword">if</span> (!isEqual(arr1, arr2)) &#123;         <span class="hljs-comment">// 打印arr1</span>         <span class="hljs-comment">// 打印arr2</span>         succeed = <span class="hljs-keyword">false</span>;         <span class="hljs-keyword">break</span>;      &#125;   &#125;   System.out.println(succeed ? <span class="hljs-string">&quot;Nice!&quot;</span> : <span class="hljs-string">&quot;Fucking fucked!&quot;</span>);   <span class="hljs-keyword">int</span>[] arr = generateRandomArray(maxSize, maxValue);   printArray(arr);   insertionSort(arr);   printArray(arr);&#125;</code></pre><h2 id="认识二分法"><a href="#认识二分法" class="headerlink" title="认识二分法"></a>认识二分法</h2><blockquote><p> 经常见到的类型是在一个有序数组上，开展二分搜索，但有序真的是所有问题求解时使用二分的必要条件吗？<br>不！<br>只要能正确构建左右两侧的淘汰逻辑，你就可以二分。</p></blockquote><h3 id="1、在一个有序数组中，找某个数是否存在"><a href="#1、在一个有序数组中，找某个数是否存在" class="headerlink" title="1、在一个有序数组中，找某个数是否存在"></a>1、在一个有序数组中，找某个数是否存在</h3><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">exist</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] sortedArr, <span class="hljs-keyword">int</span> num)</span> </span>&#123;   <span class="hljs-keyword">if</span> (sortedArr == <span class="hljs-keyword">null</span> || sortedArr.length == <span class="hljs-number">0</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;   &#125;   <span class="hljs-keyword">int</span> L = <span class="hljs-number">0</span>;   <span class="hljs-keyword">int</span> R = sortedArr.length - <span class="hljs-number">1</span>;   <span class="hljs-keyword">int</span> mid = <span class="hljs-number">0</span>;   <span class="hljs-comment">// L..R</span>   <span class="hljs-keyword">while</span> (L &lt; R) &#123;      <span class="hljs-comment">// 防L R 因数值过大 相加后溢出</span>      mid = L + ((R - L) &gt;&gt; <span class="hljs-number">1</span>); <span class="hljs-comment">// mid = (L + R) / 2</span>      <span class="hljs-keyword">if</span> (sortedArr[mid] == num) &#123;         <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sortedArr[mid] &gt; num) &#123;         R = mid - <span class="hljs-number">1</span>;      &#125; <span class="hljs-keyword">else</span> &#123;         L = mid + <span class="hljs-number">1</span>;      &#125;   &#125;   <span class="hljs-keyword">return</span> sortedArr[L] == num;&#125;</code></pre><h3 id="2、在一个有序数组中，找-gt-某个数最左侧的位置"><a href="#2、在一个有序数组中，找-gt-某个数最左侧的位置" class="headerlink" title="2、在一个有序数组中，找&gt;=某个数最左侧的位置"></a>2、在一个有序数组中，找&gt;=某个数最左侧的位置</h3><pre><code class="hljs java"><span class="hljs-comment">// 在arr上，找满足&gt;=value的最左位置</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">nearestIndex</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> value)</span></span>&#123;    <span class="hljs-keyword">int</span> L = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> R = arr.length - <span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> index = -<span class="hljs-number">1</span>; <span class="hljs-comment">// 记录最左的对号</span>    <span class="hljs-keyword">while</span> (L &lt;= R)&#123;        <span class="hljs-keyword">int</span> mid = L + ((R - L) &gt;&gt; <span class="hljs-number">1</span>);        <span class="hljs-keyword">if</span> (arr[mid] &gt;= value) &#123;            index = mid;            R = mid - <span class="hljs-number">1</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            L = mid + <span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> index;&#125;</code></pre><h3 id="3、-在一个有序数组中，找-lt-某个数最右侧的位置"><a href="#3、-在一个有序数组中，找-lt-某个数最右侧的位置" class="headerlink" title="3、 在一个有序数组中，找&lt;=某个数最右侧的位置"></a>3、 在一个有序数组中，找&lt;=某个数最右侧的位置</h3><pre><code class="hljs java"><span class="hljs-comment">// 在arr上，找满足&lt;=value的最右位置</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">nearestIndex</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> value)</span> </span>&#123;    <span class="hljs-keyword">int</span> L = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> R = arr.length - <span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> index = -<span class="hljs-number">1</span>; <span class="hljs-comment">// 记录最右的对号</span>    <span class="hljs-keyword">while</span> (L &lt;= R) &#123;        <span class="hljs-keyword">int</span> mid = L + ((R - L) &gt;&gt; <span class="hljs-number">1</span>);        <span class="hljs-keyword">if</span> (arr[mid] &lt;= value) &#123;            index = mid;            L = mid + <span class="hljs-number">1</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            R = mid - <span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> index;&#125;</code></pre><h3 id="4、-局部最小值问题"><a href="#4、-局部最小值问题" class="headerlink" title="4、 局部最小值问题"></a>4、 局部最小值问题</h3><blockquote><ol><li>arr[0]&lt;arr[1]</li><li>Arr[len-1]&lt;Arr[len-2]</li><li>arr[i-1]&lt;arr[i]&lt;arr[i+1]</li></ol></blockquote><p>arr无序, 任意两个相邻数不相等, 只需返回一个局部最小位置:</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getLessIndex</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;   <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length == <span class="hljs-number">0</span>) &#123;      <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">// no exist</span>   &#125;   <span class="hljs-keyword">if</span> (arr.length == <span class="hljs-number">1</span> || arr[<span class="hljs-number">0</span>] &lt; arr[<span class="hljs-number">1</span>]) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;   &#125;   <span class="hljs-keyword">if</span> (arr[arr.length - <span class="hljs-number">1</span>] &lt; arr[arr.length - <span class="hljs-number">2</span>]) &#123;      <span class="hljs-keyword">return</span> arr.length - <span class="hljs-number">1</span>;   &#125;   <span class="hljs-keyword">int</span> left = <span class="hljs-number">1</span>;   <span class="hljs-keyword">int</span> right = arr.length - <span class="hljs-number">2</span>;   <span class="hljs-keyword">int</span> mid = <span class="hljs-number">0</span>;   <span class="hljs-keyword">while</span> (left &lt; right) &#123;      mid = (left + right) / <span class="hljs-number">2</span>;      <span class="hljs-keyword">if</span> (arr[mid] &gt; arr[mid - <span class="hljs-number">1</span>]) &#123;         right = mid - <span class="hljs-number">1</span>;      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[mid] &gt; arr[mid + <span class="hljs-number">1</span>]) &#123;         left = mid + <span class="hljs-number">1</span>;      &#125; <span class="hljs-keyword">else</span> &#123;         <span class="hljs-keyword">return</span> mid;      &#125;   &#125;   <span class="hljs-keyword">return</span> left;&#125;</code></pre><h2 id="认识异或运算"><a href="#认识异或运算" class="headerlink" title="认识异或运算"></a>认识异或运算</h2><h3 id="1、如何记住"><a href="#1、如何记住" class="headerlink" title="1、如何记住"></a>1、如何记住</h3><p>异或运算：相同为0，不同为1<br>同或运算：相同以1，不同为0</p><blockquote><p>能长时间记住的概率接近0%</p><p>所以，异或运算就记成无进位相加！ </p></blockquote><h3 id="2、异或运算的性质"><a href="#2、异或运算的性质" class="headerlink" title="2、异或运算的性质"></a>2、异或运算的性质</h3><p>0^N == N      N^N == 0<br>异或运算满足交换律和结合率</p><p>上面的两个性质用无进位相加来理解就非常的容易</p><h3 id="3、如何不用额外变量交换两个数"><a href="#3、如何不用额外变量交换两个数" class="headerlink" title="3、如何不用额外变量交换两个数"></a>3、如何不用额外变量交换两个数</h3><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;    arr[i] = arr[i] ^ arr[j];    arr[j] = arr[i] ^ arr[j];    arr[i] = arr[i] ^ arr[j];&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201125212731.png" alt="结构"></p><blockquote><p>注意:     i和j是一个位置的话，会出错，指向的内存要求是不一样的，各自独立的。</p></blockquote><h3 id="4、一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这种数"><a href="#4、一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这种数" class="headerlink" title="4、一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这种数"></a>4、一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这种数</h3><pre><code class="hljs java"><span class="hljs-comment">// arr中，只有一种数，出现奇数次</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printOddTimesNum1</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;   <span class="hljs-keyword">int</span> eor = <span class="hljs-number">0</span>;   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;      eor ^= arr[i];   &#125;   System.out.println(eor);&#125;</code></pre><h3 id="5、怎么把一个int类型的数，提取出最右侧的1来"><a href="#5、怎么把一个int类型的数，提取出最右侧的1来" class="headerlink" title="5、怎么把一个int类型的数，提取出最右侧的1来"></a>5、怎么把一个int类型的数，提取出最右侧的1来</h3><p>N &amp; ((~N)+1)</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img9SF_F0USXR87N%TE$HW3L80.png" alt="1"></p><h3 id="6、一个数组中有两种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这两种数"><a href="#6、一个数组中有两种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这两种数" class="headerlink" title="6、一个数组中有两种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这两种数"></a>6、一个数组中有两种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这两种数</h3><pre><code class="hljs java"><span class="hljs-comment">// arr中，有两种数，出现奇数次</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printOddTimesNum2</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;   <span class="hljs-keyword">int</span> eor = <span class="hljs-number">0</span>;   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;      eor ^= arr[i];   &#125;   <span class="hljs-comment">// eor = a ^ b</span>   <span class="hljs-comment">// eor != 0</span>   <span class="hljs-comment">// eor必然有一个位置上是1</span>   <span class="hljs-keyword">int</span> rightOne = eor &amp; (~eor + <span class="hljs-number">1</span>); <span class="hljs-comment">// 提取出最右的1</span>   <span class="hljs-keyword">int</span> onlyOne = <span class="hljs-number">0</span>; <span class="hljs-comment">// eor&#x27;</span>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; arr.length;i++) &#123;      <span class="hljs-keyword">if</span> ((arr[i] &amp; rightOne) != <span class="hljs-number">0</span>) &#123;         onlyOne ^= arr[i];      &#125;   &#125;   System.out.println(onlyOne + <span class="hljs-string">&quot; &quot;</span> + (eor ^ onlyOne));&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201125220723.png" alt="图解"></p><h1 id="链表结构、栈、队列、递归行为、哈希表"><a href="#链表结构、栈、队列、递归行为、哈希表" class="headerlink" title="链表结构、栈、队列、递归行为、哈希表"></a>链表结构、栈、队列、递归行为、哈希表</h1><h2 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h2><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> value;    <span class="hljs-keyword">public</span> Node next;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span> </span>&#123;        <span class="hljs-keyword">this</span>.value = data;    &#125;&#125;</code></pre><h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DoubleNode</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> value;    <span class="hljs-keyword">public</span> DoubleNode last;    <span class="hljs-keyword">public</span> DoubleNode next;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DoubleNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span> </span>&#123;        <span class="hljs-keyword">this</span>.value = data;    &#125;&#125;</code></pre><h2 id="单向链表和双向链表最简单的练习"><a href="#单向链表和双向链表最简单的练习" class="headerlink" title="单向链表和双向链表最简单的练习"></a>单向链表和双向链表最简单的练习</h2><blockquote><p> 链表相关的问题几乎都是coding问题</p></blockquote><ul><li><p>单链表和双链表如何反转</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">reverseLinkedList</span><span class="hljs-params">(Node head)</span> </span>&#123;   Node pre = <span class="hljs-keyword">null</span>;   Node next = <span class="hljs-keyword">null</span>;   <span class="hljs-keyword">while</span> (head != <span class="hljs-keyword">null</span>) &#123;      next = head.next; <span class="hljs-comment">// 记录head下一个</span>      head.next = pre; <span class="hljs-comment">// 让head指向pre</span>      pre = head; <span class="hljs-comment">// 记录初始head</span>      head = next;<span class="hljs-comment">// head跳到下一个</span>   &#125;   <span class="hljs-keyword">return</span> pre;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> DoubleNode <span class="hljs-title">reverseDoubleList</span><span class="hljs-params">(DoubleNode head)</span></span>&#123;    DoubleNode pre = <span class="hljs-keyword">null</span>;    DoubleNode next = <span class="hljs-keyword">null</span>;    <span class="hljs-keyword">while</span> (head != <span class="hljs-keyword">null</span>)&#123;        next = head.next;        head.next = pre;        head.last = next;        pre = head;        head = next;    &#125;    <span class="hljs-keyword">return</span> pre;&#125;</code></pre></li><li><p>把给定值都删除</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">removeValue</span><span class="hljs-params">(Node head, <span class="hljs-keyword">int</span> num)</span></span>&#123;    <span class="hljs-comment">// 先找到值不是value的结点，作为头结点</span>    <span class="hljs-keyword">while</span> (head != <span class="hljs-keyword">null</span>)&#123;        <span class="hljs-keyword">if</span> (head.value != num)&#123;            <span class="hljs-keyword">break</span>;        &#125;        head = head.next;    &#125;    <span class="hljs-comment">// 找到后, 删除后面的</span>    Node pre = head; <span class="hljs-comment">// 记录上一个不等于num的位置</span>    Node cur = head; <span class="hljs-comment">// cur作为条件, 每次跳一次, 遍历链表</span>    <span class="hljs-keyword">while</span> (cur != <span class="hljs-keyword">null</span>)&#123;        <span class="hljs-keyword">if</span> (cur.value == num)&#123;            pre.next = cur.next;        &#125;<span class="hljs-keyword">else</span> &#123;            pre = cur;        &#125;        cur = cur.next;    &#125;    <span class="hljs-keyword">return</span> head;&#125;</code></pre></li></ul><p>这里就是熟悉结构。链表还有哪些常见面试题，后续有专门系统学习。</p><h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h2><blockquote><p>逻辑概念<br>栈：数据先进后出，犹如弹匣<br>队列：数据先进先出，好似排队</p></blockquote><h2 id="栈和队列的实际实现"><a href="#栈和队列的实际实现" class="headerlink" title="栈和队列的实际实现"></a>栈和队列的实际实现</h2><ul><li><p>双向链表实现</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;    <span class="hljs-keyword">public</span> T value;    <span class="hljs-keyword">public</span> Node&lt;T&gt; last;    <span class="hljs-keyword">public</span> Node&lt;T&gt; next;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(T data)</span> </span>&#123;        <span class="hljs-keyword">this</span>.value = data;    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DoubleEndsQueue</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;    <span class="hljs-keyword">public</span> Node&lt;T&gt; head;    <span class="hljs-keyword">public</span> Node&lt;T&gt; tail;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addFromHead</span><span class="hljs-params">(T value)</span> </span>&#123;        Node&lt;T&gt; cur = <span class="hljs-keyword">new</span> Node&lt;&gt;(value);        <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>)&#123;            head = cur;            tail = cur;        &#125;<span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// 改变结点</span>            cur.next =  head;            head.last = cur;            <span class="hljs-comment">// 变更新的头结点</span>            head = cur;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addFromBottom</span><span class="hljs-params">(T value)</span> </span>&#123;        Node&lt;T&gt; cur = <span class="hljs-keyword">new</span> Node&lt;&gt;(value);        <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>)&#123;            head = cur;            tail = cur;        &#125;<span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// 改变结点</span>            cur.last = tail;            tail.next = cur;            tail = cur;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">popFromHead</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        Node&lt;T&gt; cur = head;        <span class="hljs-keyword">if</span> (head == tail)&#123;            head = <span class="hljs-keyword">null</span>;            tail = <span class="hljs-keyword">null</span>;        &#125;<span class="hljs-keyword">else</span> &#123;            head = head.next;            cur.next = <span class="hljs-keyword">null</span>;            head.last = <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-keyword">return</span> cur.value;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">popFromBottom</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        Node&lt;T&gt; cur = tail;        <span class="hljs-keyword">if</span> (head == tail)&#123;            head = <span class="hljs-keyword">null</span>;            tail = <span class="hljs-keyword">null</span>;        &#125;<span class="hljs-keyword">else</span> &#123;            tail = tail.last;            tail.next = <span class="hljs-keyword">null</span>;            cur.last = <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-keyword">return</span> cur.value;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> head == <span class="hljs-keyword">null</span>;    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyStack</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;    <span class="hljs-keyword">private</span> DoubleEndsQueue&lt;T&gt; queue;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyStack</span><span class="hljs-params">()</span> </span>&#123;        queue = <span class="hljs-keyword">new</span> DoubleEndsQueue&lt;&gt;();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(T value)</span></span>&#123;        queue.addFromHead(value);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> queue.popFromHead();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> queue.isEmpty();    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyQueue</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;    <span class="hljs-keyword">private</span> DoubleEndsQueue&lt;T&gt; queue;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyQueue</span><span class="hljs-params">()</span> </span>&#123;        queue = <span class="hljs-keyword">new</span> DoubleEndsQueue&lt;&gt;();    &#125;    <span class="hljs-comment">// 出push</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(T value)</span></span>&#123;        queue.addFromHead(value);    &#125;    <span class="hljs-comment">// 进poll</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">poll</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> queue.popFromBottom();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> queue.isEmpty();    &#125;&#125;</code></pre></li><li><p>数组实现</p><blockquote><p>数组实现栈</p></blockquote></li></ul><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayStack</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span>[] a;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size;<span class="hljs-comment">//栈数组的大小</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> top;<span class="hljs-comment">//栈顶</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayStack</span><span class="hljs-params">(<span class="hljs-keyword">int</span> maxSize)</span> </span>&#123;        <span class="hljs-keyword">this</span>.size = maxSize;        <span class="hljs-keyword">this</span>.a = <span class="hljs-keyword">new</span> <span class="hljs-keyword">long</span>[size];        <span class="hljs-keyword">this</span>.top = -<span class="hljs-number">1</span>;<span class="hljs-comment">//表示空栈</span>    &#125;    <span class="hljs-comment">//入栈</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">long</span> value)</span></span>&#123;        <span class="hljs-keyword">if</span>(isFull())&#123;            System.out.println(<span class="hljs-string">&quot;栈已经满！&quot;</span>);            <span class="hljs-keyword">return</span>;        &#125;        a[++top] = value;    &#125;    <span class="hljs-comment">//返回栈顶内容，但是不删除</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">peek</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">if</span>(isEmpty())&#123;            System.out.println(<span class="hljs-string">&quot;栈中没有数据！&quot;</span>);        &#125;        System.out.println(a[top]);    &#125;    <span class="hljs-comment">//弹出栈顶内容，删除</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">if</span>(isEmpty())&#123;            System.out.println(<span class="hljs-string">&quot;栈中没有数据！&quot;</span>);            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">return</span> a[top--];    &#125;    <span class="hljs-comment">//size栈的大小</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> top + <span class="hljs-number">1</span>;    &#125;    <span class="hljs-comment">//是否为空</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> (top == -<span class="hljs-number">1</span>);    &#125;    <span class="hljs-comment">//是否满了</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isFull</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> (top == size - <span class="hljs-number">1</span>);    &#125;    <span class="hljs-comment">//显示</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span></span>&#123;        System.out.print(<span class="hljs-string">&quot;[&quot;</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = top; i &gt;=<span class="hljs-number">0</span> ; i--) &#123;            System.out.print(a[i]);            <span class="hljs-keyword">if</span>(i!=<span class="hljs-number">0</span>)&#123;                System.out.print(<span class="hljs-string">&quot;,&quot;</span>);            &#125;        &#125;        System.out.println(<span class="hljs-string">&quot;]&quot;</span>);    &#125;&#125;</code></pre><blockquote><p>数组实现队列</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyQueue</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] arr;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> pushi;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> polli;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> limit;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyQueue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> limit)</span> </span>&#123;        <span class="hljs-keyword">this</span>.arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[limit];        <span class="hljs-keyword">this</span>.pushi = <span class="hljs-number">0</span>;        <span class="hljs-keyword">this</span>.polli = <span class="hljs-number">0</span>;        <span class="hljs-keyword">this</span>.size = <span class="hljs-number">0</span>;        <span class="hljs-keyword">this</span>.limit = limit;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;        <span class="hljs-keyword">if</span> (size == limit)&#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;栈满了，不能再加了&quot;</span>);        &#125;        size++;        arr[pushi] = value;        pushi = nextIndex(pushi);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">poll</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (size == <span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;栈空了，不能再拿了&quot;</span>);        &#125;        size--;        <span class="hljs-keyword">int</span> ans = arr[polli];        polli = nextIndex(polli);        <span class="hljs-keyword">return</span> ans;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> size == <span class="hljs-number">0</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">nextIndex</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>&#123;        <span class="hljs-keyword">return</span> i &lt; limit - <span class="hljs-number">1</span> ? i + <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;    &#125;&#125;</code></pre><h2 id="栈和队列的常见面试题"><a href="#栈和队列的常见面试题" class="headerlink" title="栈和队列的常见面试题"></a>栈和队列的常见面试题</h2><h3 id="1、实现一个特殊的栈，在基本功能的基础上，再实现返回栈中最小元素的功能"><a href="#1、实现一个特殊的栈，在基本功能的基础上，再实现返回栈中最小元素的功能" class="headerlink" title="1、实现一个特殊的栈，在基本功能的基础上，再实现返回栈中最小元素的功能"></a>1、实现一个特殊的栈，在基本功能的基础上，再实现返回栈中最小元素的功能</h3><blockquote><p>1）pop、push、getMin操作的时间复杂度都是 O(1)。 </p><p>2）设计的栈类型可以使用现成的栈结构。</p></blockquote><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201128160516.png" alt="实现"></p><p> <strong>当前数和最小栈栈顶做比较, 谁小加谁</strong>,  弹出一起弹出 —–&gt; MyStack2</p><p> <strong>当前数和最小栈栈顶做比较, 只有小于最小栈栈顶才压入</strong>,弹出如果Data Peek = Min Peek, 一起弹出 —–&gt; MyStack1</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 想要压入的数比最小栈大 不压入, 小于等于压入</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyStack1</span> </span>&#123;    <span class="hljs-keyword">private</span> Stack&lt;Integer&gt; stackData;    <span class="hljs-keyword">private</span> Stack&lt;Integer&gt; stackMin;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyStack1</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">this</span>.stackData = <span class="hljs-keyword">new</span> Stack&lt;Integer&gt;();        <span class="hljs-keyword">this</span>.stackMin = <span class="hljs-keyword">new</span> Stack&lt;Integer&gt;();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> newNum)</span> </span>&#123;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.stackMin.isEmpty()) &#123;            <span class="hljs-keyword">this</span>.stackMin.push(newNum);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (newNum &lt;= <span class="hljs-keyword">this</span>.getmin()) &#123;            <span class="hljs-keyword">this</span>.stackMin.push(newNum);        &#125;        <span class="hljs-keyword">this</span>.stackData.push(newNum);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 弹出如果Data栈弹出的数等于最小栈栈顶则弹出</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.stackData.isEmpty()) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;Your stack is empty.&quot;</span>);        &#125;        <span class="hljs-keyword">int</span> value = <span class="hljs-keyword">this</span>.stackData.pop();        <span class="hljs-keyword">if</span> (value == <span class="hljs-keyword">this</span>.getmin()) &#123;            <span class="hljs-keyword">this</span>.stackMin.pop();        &#125;        <span class="hljs-keyword">return</span> value;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getmin</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.stackMin.isEmpty()) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;Your stack is empty.&quot;</span>);        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.stackMin.peek();    &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 想要压入的数比最小栈大 重复压入最小栈栈顶</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyStack2</span> </span>&#123;    <span class="hljs-keyword">private</span> Stack&lt;Integer&gt; stackData;    <span class="hljs-keyword">private</span> Stack&lt;Integer&gt; stackMin;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyStack2</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">this</span>.stackData = <span class="hljs-keyword">new</span> Stack&lt;Integer&gt;();        <span class="hljs-keyword">this</span>.stackMin = <span class="hljs-keyword">new</span> Stack&lt;Integer&gt;();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> newNum)</span></span>&#123;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.stackMin.isEmpty())&#123;            <span class="hljs-comment">// 如果最小栈没有元素 直接压入</span>            <span class="hljs-keyword">this</span>.stackMin.push(newNum);        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (newNum &lt; <span class="hljs-keyword">this</span>.getMin())&#123;            <span class="hljs-comment">// 如果最小栈栈顶小于newNum</span>            <span class="hljs-keyword">this</span>.stackMin.push(newNum);        &#125;<span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// 如果最小栈栈顶大于newNum, 重复压入栈顶元素</span>            <span class="hljs-keyword">int</span> minNum = <span class="hljs-keyword">this</span>.getMin();            <span class="hljs-keyword">this</span>.stackMin.push(minNum);        &#125;        <span class="hljs-keyword">this</span>.stackData.push(newNum);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.stackData.isEmpty()) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;Your stack is empty.&quot;</span>);        &#125;        <span class="hljs-keyword">this</span>.stackMin.pop();        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.stackData.pop();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMin</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.stackMin.isEmpty())&#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;Your stack is empty.&quot;</span>);        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.stackMin.peek();    &#125;&#125;</code></pre><h3 id="2、栈与队列互相实现"><a href="#2、栈与队列互相实现" class="headerlink" title="2、栈与队列互相实现"></a>2、栈与队列互相实现</h3><blockquote><p>1）如何用栈结构实现队列结构</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TwoStacksQueue</span> </span>&#123;        <span class="hljs-keyword">public</span> Stack&lt;Integer&gt; stackPush;        <span class="hljs-keyword">public</span> Stack&lt;Integer&gt; stackPop;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TwoStacksQueue</span><span class="hljs-params">()</span> </span>&#123;            stackPush = <span class="hljs-keyword">new</span> Stack&lt;Integer&gt;();            stackPop = <span class="hljs-keyword">new</span> Stack&lt;Integer&gt;();        &#125;        <span class="hljs-comment">// push栈向pop栈倒入数据</span>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pushToPop</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">if</span> (stackPop.empty())&#123;                <span class="hljs-keyword">while</span> (!stackPush.empty())&#123;                    stackPop.push(stackPush.pop());                &#125;            &#125;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pushInt)</span></span>&#123;            stackPush.push(pushInt);<span class="hljs-comment">//            pushToPop();</span>        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">poll</span><span class="hljs-params">()</span></span>&#123;            <span class="hljs-keyword">if</span> (stackPop.empty() &amp;&amp; stackPush.empty()) &#123;                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;Queue is empty!&quot;</span>);            &#125;            pushToPop();            <span class="hljs-keyword">return</span> stackPop.pop();        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">peek</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">if</span> (stackPop.empty() &amp;&amp; stackPush.empty()) &#123;                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;Queue is empty!&quot;</span>);            &#125;            pushToPop();            <span class="hljs-keyword">return</span> stackPop.peek();        &#125;    &#125;</code></pre><blockquote><p>2）如何用队列结构实现栈结构</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TwoQueueStack</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;    <span class="hljs-keyword">public</span> Queue&lt;T&gt; queue;    <span class="hljs-keyword">public</span> Queue&lt;T&gt; help;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TwoQueueStack</span><span class="hljs-params">()</span> </span>&#123;        queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        help = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(T value)</span></span>&#123; queue.offer(value);&#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">poll</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">while</span> (queue.size() &gt; <span class="hljs-number">1</span>)&#123;            help.offer(queue.poll());        &#125;        T ans = queue.poll();        Queue&lt;T&gt; temp = queue;        queue = help;        help = temp;        <span class="hljs-keyword">return</span> ans;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">peek</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">while</span> (queue.size() &gt; <span class="hljs-number">1</span>)&#123;            help.offer(queue.poll());        &#125;        T ans = queue.peek();        Queue&lt;T&gt; temp = queue;        queue = help;        help = temp;        queue.offer(ans);        <span class="hljs-keyword">return</span> ans;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> queue.isEmpty();    &#125;&#125;</code></pre><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><blockquote><p>怎么从思想上理解递归</p></blockquote><p>求数组arr[L..R]中的最大值，怎么用递归方法实现。</p><p>1）将[L..R]范围分成左右两半。左：[L..Mid]  右[Mid+1..R]<br>2）左部分求最大值，右部分求最大值<br>3） [L..R]范围上的最大值，是max{左部分最大值，右部分最大值}</p><p>注意：2）是个递归过程，当范围上只有一个数，就可以不用再递归了</p><pre><code class="hljs java"><span class="hljs-comment">// 求arr中的最大值</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMax</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;    <span class="hljs-keyword">return</span> process(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>);&#125;<span class="hljs-comment">// arr[L..R]范围上求最大值  L ... R   N</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">process</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R)</span> </span>&#123;    <span class="hljs-keyword">if</span> (L == R) &#123; <span class="hljs-comment">// arr[L..R]范围上只有一个数，直接返回，base case</span>        <span class="hljs-keyword">return</span> arr[L];    &#125;    <span class="hljs-keyword">int</span> mid = L + ((R - L) &gt;&gt; <span class="hljs-number">1</span>); <span class="hljs-comment">// 中点    1</span>    <span class="hljs-keyword">int</span> leftMax = process(arr, L, mid);    <span class="hljs-keyword">int</span> rightMax = process(arr, mid + <span class="hljs-number">1</span>, R);    <span class="hljs-keyword">return</span> Math.max(leftMax, rightMax);&#125;</code></pre><h3 id="递归的脑图和实际实现"><a href="#递归的脑图和实际实现" class="headerlink" title="递归的脑图和实际实现"></a>递归的脑图和实际实现</h3><p>对于新手来说，把调用的过程画出结构图是必须的，这有利于分析递归</p><p>递归并不是玄学，递归底层是利用系统栈来实现的</p><p>任何递归函数都一定可以改成非递归</p><h3 id="Master公式"><a href="#Master公式" class="headerlink" title="Master公式"></a>Master公式</h3><blockquote><p>形如T(N) = a * T(N/b) + O(N^d)(其中的a、b、d都是常数)的递归函数，可以直接通过Master公式来确定时间复杂度, a次子问题规模(总问题是子问题的b倍规模)</p></blockquote><p>以b为底, logb(a)</p><p>如果 log(b,a) &lt; d，复杂度为O(N^d)<br>如果 log(b,a) &gt; d，复杂度为O(N^log(b,a))<br>如果 log(b,a) == d，复杂度为O(N^d  * logN)</p><p>上述算法中, 把数组分成两份, 每份1/2, 其他时间复杂度为O(1)</p><p>T(N) = 2 * T(N/2) + O(N^0) 即O(N), 与从左往右遍历一遍是一样的</p><p>如果左边2/3, 右边也2/3, 也是两份, 其他再打印一次, 时间复杂度为O(n)</p><p>T(N) = 2 * T(N/(3/2)) + O(N^1)</p><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>1)哈希表在使用层面上可以理解为一种集合结构<br>2)如果只有key，没有伴随数据value，可以使用 <strong><em>HashSet</em></strong>结构<br>3)如果既有key，又有伴随数据value，可以使用 <strong><em>HashMap</em></strong>结构<br>4) <strong><em>有无伴随数据，是HashMap和HashSet唯一的区别，实际结构是一回事</em></strong><br>5)使用哈希表增(put)、删(remove)、改(put)和查(get)的操作，可以认为时间复杂度为 O(1)，但是 <strong><em>常数时间</em></strong>比较大<br>6)放入哈希表的东西，如果是基础类型， <strong><em>内部按值传递</em></strong>，内存占用是这个东西的大小 </p><pre><code class="hljs java"><span class="hljs-keyword">int</span> a = <span class="hljs-number">100000</span>;<span class="hljs-keyword">int</span> b = <span class="hljs-number">100000</span>;<span class="hljs-comment">// 不关心内存区域, 只关心对应的值</span>System.out.println(a == b);Integer c = <span class="hljs-number">100000</span>;Integer d = <span class="hljs-number">100000</span>;<span class="hljs-comment">// 关心内存区域</span>System.out.println(c.equals(d));Integer e = <span class="hljs-number">127</span>;  <span class="hljs-comment">//  - 128  ~  127 true, 按值传递</span>Integer f = <span class="hljs-number">127</span>;System.out.println(e == f);<span class="hljs-comment">// 但是在哈希表中, 基础类型, 内部都按值传递</span></code></pre><p>7)放入哈希表的东西，如果不是基础类型， <strong><em>内部按引用传递</em></strong>，内存占用是8字节</p><pre><code class="hljs java">HashMap&lt;Node, String&gt; map2 = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();Node node1 = <span class="hljs-keyword">new</span> Node(<span class="hljs-number">1</span>);Node node2 = node1;map2.put(node1, <span class="hljs-string">&quot;我是node1&quot;</span>);map2.put(node2, <span class="hljs-string">&quot;我是node1&quot;</span>);System.out.println(map2.size());<span class="hljs-comment">// 结果为 1</span></code></pre><pre><code class="hljs java">HashMap&lt;Node, String&gt; map2 = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();Node node1 = <span class="hljs-keyword">new</span> Node(<span class="hljs-number">1</span>);Node node2 = <span class="hljs-keyword">new</span> Node(<span class="hljs-number">2</span>);map2.put(node1, <span class="hljs-string">&quot;我是node1&quot;</span>);map2.put(node2, <span class="hljs-string">&quot;我是node1&quot;</span>);System.out.println(map2.size());<span class="hljs-comment">// 结果为 2</span></code></pre><pre><code class="hljs processing">即如果<span class="hljs-keyword">HashMap</span>&lt;<span class="hljs-keyword">String</span>, <span class="hljs-keyword">String</span>&gt; <span class="hljs-built_in">map</span> = <span class="hljs-keyword">new</span> <span class="hljs-keyword">HashMap</span>&lt;&gt;();<span class="hljs-built_in">key</span>和value都传<span class="hljs-number">100</span>位数据, 最终数据占用为 <span class="hljs-number">4</span> * <span class="hljs-number">100</span> * <span class="hljs-number">2</span>但如果<span class="hljs-keyword">HashMap</span>&lt;Node, Node&gt; map2 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">HashMap</span>&lt;&gt;();<span class="hljs-built_in">key</span>和value都传<span class="hljs-number">20</span>g数据, <span class="hljs-built_in">map</span>中只存内存地址<span class="hljs-number">8</span>字节, <span class="hljs-number">4</span> * <span class="hljs-number">8</span> * <span class="hljs-number">2</span>字节大小完成操作</code></pre><h2 id="有序表-TreeMap-O-logN"><a href="#有序表-TreeMap-O-logN" class="headerlink" title="有序表(TreeMap) O(logN)"></a>有序表(TreeMap) O(logN)</h2><p>1)有序表在使用层面上可以理解为一种集合结构<br>2)如果只有key，没有伴随数据value，可以使用TreeSet结构<br>3)如果既有key，又有伴随数据value，可以使用TreeMap结构<br>4)有无伴随数据，是TreeSet和TreeMap唯一的区别，底层的实际结构是一回事<br>5) <strong><em>有序表把key按照顺序组织起来，而哈希表完全不组织</em></strong></p><pre><code class="hljs java">System.out.println(treeMap.firstKey());System.out.println(treeMap.lastKey());<span class="hljs-comment">// &lt;= 4</span>System.out.println(treeMap.floorKey(<span class="hljs-number">4</span>));<span class="hljs-comment">// &gt;= 4</span>System.out.println(treeMap.ceilingKey(<span class="hljs-number">4</span>));</code></pre><ol start="6"><li><strong><em>红黑树</em></strong>、 <strong><em>AVL树</em></strong>、 <strong><em>size-balance-tree</em></strong>和 <strong><em>跳表</em></strong>等都属于 <strong><em>有序表</em></strong>结构，只是底层具体实现不同</li><li>放入如果是基础类型，内部按值传递，内存占用就是这个东西的大小</li><li>放入如果不是基础类型，内部按引用传递，内存占用是8字节</li><li>不管是什么底层具体实现，只要是有序表，都有以下固定的基本功能和固定的时间复杂度 </li></ol><blockquote><p>Api</p></blockquote><p>1)void put(K key, V value)<br>将一个(key，value)记录加入到表中，或者将key的记录 更新成value。<br>2)V get(K key)<br>根据给定的key，查询value并返回。<br>3)void remove(K key)<br>移除key的记录。<br>4)boolean containsKey(K key)<br>询问是否有关于key的记录。</p><p>5)K firstKey()<br>返回所有键值的排序结果中，最小的那个。6)K lastKey()<br>返回所有键值的排序结果中，最大的那个。7)K floorKey(K key)<br>返回&lt;= key 离key最近的那个<br>8)K ceilingKey(K key）<br>返回&gt;= key 离key最近的那个</p><blockquote><p>哈希表在使用时，增删改查时间复杂度都是O(1)<br>有序表在使用时，比哈希表功能多，时间复杂度都是O(logN)</p></blockquote><h1 id="归并排序与随机快排"><a href="#归并排序与随机快排" class="headerlink" title="归并排序与随机快排"></a>归并排序与随机快排</h1><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><blockquote><p>1）整体是递归，左边排好序+右边排好序+merge让整体有序</p></blockquote><p>例子: [3, 1, 2, 4]</p><p>主函数: f(0, 3) </p><p>运行后process(0,1) 再 process(2, 3) 再merge</p><p>而运行process(0,1) 需要process(0,0)再process(1,1)再merge</p><p>运行process(2, 3)需要process(2, 2)再process(3, 3)再merge</p><h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><pre><code class="hljs java"><span class="hljs-comment">// 递归方法实现</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mergeSort1</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span></span>&#123;    <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length &lt; <span class="hljs-number">2</span>) &#123;        <span class="hljs-keyword">return</span>;    &#125;    process(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>);&#125;<span class="hljs-comment">// 让arr L - R范围变成有序</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R)</span></span>&#123;    <span class="hljs-keyword">if</span> (L == R)&#123; <span class="hljs-comment">// base case</span>        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">int</span> mid = L + (( R - L ) &gt;&gt; <span class="hljs-number">2</span>);    process(arr, L, mid);    process(arr, mid + <span class="hljs-number">1</span>, R);    merge(arr, L, mid, R);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span>  <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> M, <span class="hljs-keyword">int</span> R)</span></span>&#123;    <span class="hljs-keyword">int</span>[] help = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[R - L + <span class="hljs-number">1</span>];    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; <span class="hljs-comment">// help数组的指针</span>    <span class="hljs-keyword">int</span> p1 = L; <span class="hljs-comment">// 左部分指针</span>    <span class="hljs-keyword">int</span> p2 = M + <span class="hljs-number">1</span>; <span class="hljs-comment">// 又部分指针</span>    <span class="hljs-keyword">while</span> (p1 &lt;= M &amp;&amp; p2 &lt;= R)&#123;        help[i++] = arr[p1] &lt;= arr[p2] ? arr[p1++] : arr[p2++];    &#125;    <span class="hljs-comment">// 要么p1越界, 要么p2越界</span>    <span class="hljs-keyword">while</span> (p1 &lt;= M)&#123;        help[i++] = arr[p1++];    &#125;    <span class="hljs-keyword">while</span> (p2 &lt;= R)&#123;        help[i++] = arr[p2++];    &#125;    <span class="hljs-comment">// 把help的值赋值回去</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; help.length ; j++) &#123;        arr[L + i] = help[i];    &#125;&#125;</code></pre><h3 id="非递归实现"><a href="#非递归实现" class="headerlink" title="非递归实现"></a>非递归实现</h3><p>例子[2, 3, 1, 4, 5, 6]</p><p>初始k = 1, 每个最小原子单元, 即每个数自我有序,</p><p>K &lt;&lt; 2, 每两个一组进行merge, 变成[2, 3, 1, 4, 5, 6]</p><p>K &lt;&lt; 2, 每四个一组进行merge, 不够则凑一组[1, 2, 3, 4, 5, 6]</p><p>直到k &gt;= N</p><pre><code class="hljs java"><span class="hljs-comment">// 非递归方法实现</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mergeSort2</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;   <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length &lt; <span class="hljs-number">2</span>) &#123;      <span class="hljs-keyword">return</span>;   &#125;   <span class="hljs-keyword">int</span> N = arr.length;   <span class="hljs-keyword">int</span> mergeSize = <span class="hljs-number">1</span>;<span class="hljs-comment">// 一组是两倍的mergeSize, 当前有序的左组长度</span>   <span class="hljs-keyword">while</span> (mergeSize &lt; N) &#123;      <span class="hljs-keyword">int</span> L = <span class="hljs-number">0</span>;      <span class="hljs-keyword">while</span> (L &lt; N) &#123;         <span class="hljs-comment">// L...M 左组(mergeSize大小)</span>         <span class="hljs-comment">// 求中间</span>         <span class="hljs-keyword">int</span> M = L + mergeSize - <span class="hljs-number">1</span>;         <span class="hljs-keyword">if</span> (M &gt;= N) &#123;            <span class="hljs-keyword">break</span>;         &#125;         <span class="hljs-comment">// L...M   M+1...R</span>         <span class="hljs-comment">// 右组可能凑不齐mergeSize个</span>         <span class="hljs-comment">// 求右边</span>         <span class="hljs-keyword">int</span> R = Math.min(M + mergeSize, N - <span class="hljs-number">1</span>);         merge(arr, L, M, R);         <span class="hljs-comment">// 算下一次左边</span>         L = R + <span class="hljs-number">1</span>;      &#125;            <span class="hljs-comment">// 防止溢出</span>      <span class="hljs-keyword">if</span> (mergeSize &gt; N / <span class="hljs-number">2</span>) &#123;         <span class="hljs-keyword">break</span>;      &#125;      mergeSize &lt;&lt;= <span class="hljs-number">1</span>;   &#125;&#125;</code></pre><h3 id="利用master公式来求解时间复杂度"><a href="#利用master公式来求解时间复杂度" class="headerlink" title="利用master公式来求解时间复杂度"></a>利用master公式来求解时间复杂度</h3><pre><code class="hljs mathematica"><span class="hljs-variable">T</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span><span class="hljs-operator">*</span><span class="hljs-variable">T</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-operator">/</span><span class="hljs-number">2</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">+</span> <span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-operator">^</span><span class="hljs-number">1</span><span class="hljs-punctuation">)</span>根据<span class="hljs-variable">master</span>可知时间复杂度为<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-operator">*</span><span class="hljs-variable">logN</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">(</span>非递归分析<span class="hljs-operator">:</span>每次<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span> <span class="hljs-number">2</span><span class="hljs-operator">,</span> <span class="hljs-number">4</span><span class="hljs-operator">,</span> <span class="hljs-number">8</span><span class="hljs-operator">,</span> <span class="hljs-number">16</span> <span class="hljs-operator">....</span> <span class="hljs-built_in">N</span> <span class="hljs-operator">,</span> <span class="hljs-built_in">Log</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-punctuation">)</span>次<span class="hljs-operator">,</span> 所以<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-operator">*</span><span class="hljs-variable">logN</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">)</span><span class="hljs-variable">merge</span>过程需要辅助数组，所以额外空间复杂度为<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-punctuation">)</span>归并排序的实质是把比较行为变成了有序信息并传递，比<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-operator">^</span><span class="hljs-number">2</span><span class="hljs-punctuation">)</span>的排序快<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-operator">^</span><span class="hljs-number">2</span><span class="hljs-punctuation">)</span>在无限浪费比较行为<span class="hljs-operator">,</span> 例如选择排序<span class="hljs-operator">,</span> 每次都与后面比较大小</code></pre><h3 id="用常见面试题再深入理解一下归并排序的精髓"><a href="#用常见面试题再深入理解一下归并排序的精髓" class="headerlink" title="用常见面试题再深入理解一下归并排序的精髓"></a>用常见面试题再深入理解一下归并排序的精髓</h3><blockquote><p> 在一个数组中，一个数左边比它小的数的总和，叫数的小和，所有数的小和累加起来，叫数组小和。求数组小和。</p></blockquote><p>例子： [1,3,4,2,5]<br>1左边比1小的数：没有<br>3左边比3小的数：1<br>4左边比4小的数：1、3<br>2左边比2小的数：1<br>5左边比5小的数：1、3、4、 2<br>所以数组的小和为1+1+3+1+1+3+4+2=16 </p><p>每次merge时, 两个指针对应的数比较大小, 如果小, 则计算另外一个指针包括当前位置以后的有多少个比对方大的数字.</p><pre><code class="hljs css">例子:<span class="hljs-selector-attr">[1,3,4,2,5]</span> 分为<span class="hljs-selector-attr">[1,3]</span>和<span class="hljs-selector-attr">[4,2,5]</span><span class="hljs-selector-attr">[1]</span> <span class="hljs-selector-attr">[3]</span><span class="hljs-selector-tag">merge</span>时, 1比3小, 1个1<span class="hljs-selector-attr">[4,2,5]</span>分为<span class="hljs-selector-attr">[4]</span>,<span class="hljs-selector-attr">[2, 5]</span><span class="hljs-selector-attr">[4]</span><span class="hljs-selector-tag">merge</span>, <span class="hljs-selector-tag">return</span> 0<span class="hljs-selector-attr">[2, 5]</span><span class="hljs-selector-tag">merge</span>时候, 2比5小, 1个2<span class="hljs-selector-attr">[4]</span>与<span class="hljs-selector-attr">[2,5]</span><span class="hljs-selector-tag">merge</span>时候, 左指针初始4, 右指针初始2, 4 &gt; 2, <span class="hljs-selector-tag">help</span>数组放入2, 右指针右移4 &lt; 5, 1个4,<span class="hljs-selector-tag">help</span>数组放入4,越界,放入5<span class="hljs-selector-attr">[1,3]</span>和<span class="hljs-selector-attr">[2,4,5]</span><span class="hljs-selector-tag">merge</span>, 1&lt;2, 3个1, 3&lt;4, 2个3结束4个1, 1个2, 2个3, 1个4,</code></pre><blockquote><p>其实就是在左指针与右指针对比时, 加上右指针开始个大于左指针数(利用右边有序)的左指针当前数</p><p>result += arr[p1] &lt; arr[p2] ? arr[p1] * (R - p2 + 1) : 0;</p><p>也可以解决降序对的问题</p><p>只要纠结右边有多少个数比左边大这类的问题，都可以用归并</p></blockquote><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">smallNum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[])</span></span>&#123;    <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length &lt; <span class="hljs-number">2</span>)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">return</span> process(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">process</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R)</span></span>&#123;    <span class="hljs-keyword">if</span> (L == R)&#123;        <span class="hljs-comment">// 只有一个数, 右组都没有</span>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">int</span> mid = L + ((R - L) &gt;&gt; <span class="hljs-number">2</span>);    <span class="hljs-keyword">return</span> process(arr, L, mid) + process(arr, mid + <span class="hljs-number">1</span>, R) + merge(arr, L, mid, R);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> mid, <span class="hljs-keyword">int</span> R)</span></span>&#123;    <span class="hljs-keyword">int</span> help[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[R - L + <span class="hljs-number">1</span>];    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> p1 = L;    <span class="hljs-keyword">int</span> p2 = mid + <span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> result = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (p1 &lt;= mid &amp;&amp; p2 &lt;= R)&#123;        result += arr[p1] &lt; arr[p2] ? arr[p1] * (R - p2 + <span class="hljs-number">1</span>) : <span class="hljs-number">0</span>;        help[i++] = arr[p1] &lt; arr[p2] ? arr[p1++] : arr[p2++];    &#125;    <span class="hljs-keyword">while</span> (p1 &lt;= mid)&#123;        help[i++] = arr[p1++];    &#125;    <span class="hljs-keyword">while</span> (p2 &lt;= R)&#123;        help[i++] = arr[p2++];    &#125;    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; help.length; i++) &#123;        arr[L + i] = help[i];    &#125;    <span class="hljs-keyword">return</span> result;&#125;</code></pre><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="Partition过程"><a href="#Partition过程" class="headerlink" title="Partition过程"></a>Partition过程</h3><blockquote><p>给定一个数组arr，和一个整数num。请把小于等于num的数放在数组的左边，大于num的数放在数组的右边。<br>要求额外空间复杂度O(1)，时间复杂度O(N) </p></blockquote><p>设置一个 <strong><em>小于等于区</em></strong>, 设初始位置 -1, </p><ol><li><p>[i]&lt;=num,当前数和小于等于区下一个位置交换, 小于等于区右扩, i++</p></li><li><p>[i]&gt;num, i++</p></li></ol><p>例子: [5, 3, 7, 2] num = 3</p><p>一开始小于等于区位置 -1, i=0, i[0]=5 &gt; 3, i++, 跳到3, 3&lt;=num, 与小于等于区下一个数即i[0]交换</p><p>变成[3, 5, 7, 2]小于等于区右扩, 初始位置为0, 逐步下去</p><pre><code class="hljs java"><span class="hljs-comment">// 以arr[R]做划分值</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R)</span> </span>&#123;   <span class="hljs-keyword">if</span> (L &gt; R) &#123;      <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;   &#125;   <span class="hljs-keyword">if</span> (L == R) &#123;      <span class="hljs-keyword">return</span> L;   &#125;   <span class="hljs-keyword">int</span> lessEqual = L - <span class="hljs-number">1</span>;   <span class="hljs-keyword">int</span> index = L;   <span class="hljs-keyword">while</span> (index &lt; R) &#123;      <span class="hljs-keyword">if</span> (arr[index] &lt;= arr[R]) &#123;         swap(arr, index, ++lessEqual);      &#125;      index++;   &#125;   swap(arr, ++lessEqual, R);   <span class="hljs-keyword">return</span> lessEqual;&#125;</code></pre><h3 id="荷兰国旗问题"><a href="#荷兰国旗问题" class="headerlink" title="荷兰国旗问题"></a>荷兰国旗问题</h3><blockquote><p>给定一个数组arr，和一个整数num。请把小于num的数放在数组的左边，等于num的数放在中间，大于num的数放在数组的右边。</p><p>要求额外空间复杂度O(1)，时间复杂度O(N)  </p></blockquote><p>设置一个 <strong><em>小于区</em></strong>,设初始位置 -1 ;  设置一个 <strong><em>大于区</em></strong>,设初始位置 length -1</p><ol><li><p>[i] == num, i++</p></li><li><p>[i] &lt; num, [i] 与小于区下一个交换, 小于区右扩, i++</p></li><li><p>[i] &gt; num, [i] 与大于区左一个交换, 大于区左扩, i <strong><em>停在原地</em></strong></p></li></ol><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201129162221.png" alt="流程图"></p><p>i与大于区边界撞上的时候停</p><pre><code class="hljs java"><span class="hljs-comment">// arr[L...R] 玩荷兰国旗问题的划分，以arr[R]做划分值</span><span class="hljs-comment">//  &lt;arr[R]  ==arr[R]  &gt; arr[R]</span><span class="hljs-comment">// 返回等于区域范围</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] netherlandsFlag(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R) &#123;   <span class="hljs-keyword">if</span> (L &gt; R) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123; -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span> &#125;;   &#125;   <span class="hljs-keyword">if</span> (L == R) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123; L, R &#125;;   &#125;   <span class="hljs-keyword">int</span> less = L - <span class="hljs-number">1</span>; <span class="hljs-comment">// &lt; 区 右边界</span>   <span class="hljs-keyword">int</span> more = R;     <span class="hljs-comment">// &gt; 区 左边界</span>   <span class="hljs-keyword">int</span> index = L;   <span class="hljs-keyword">while</span> (index &lt; more) &#123;      <span class="hljs-keyword">if</span> (arr[index] == arr[R]) &#123;         index++;      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[index] &lt; arr[R]) &#123;         swap(arr, index++, ++less);      &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// &gt;</span>         swap(arr, index, --more);      &#125;   &#125;   <span class="hljs-comment">// L...Less 小于区 less+1...more-1 等于区 more...R-1 大于区  R没动过</span>   <span class="hljs-comment">// 交换后</span>   <span class="hljs-comment">// L...Less 小于区 less+1.....more 等于区 more+1...R 大于区</span>   swap(arr, more, R);   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123; less + <span class="hljs-number">1</span>, more &#125;;&#125;</code></pre><h2 id="快速排序1-0"><a href="#快速排序1-0" class="headerlink" title="快速排序1.0"></a>快速排序1.0</h2><p>在arr[L..R]范围上，进行快速排序的过程：<br>1）用arr[R]对该范围做partition，&lt;= arr[R]的数在左部分并且保证arr[R]最后来到左部分小于区的最后一个位置，记为M； &lt;= arr[R]的数在右部分（arr[M+1..R]）,此时X就已经排好序了<br>2）对arr[L..M-1]进行快速排序(递归)<br>3）对arr[M+1..R]进行快速排序(递归)<br>因为每一次partition都会搞定一个数的位置且不会再变动，所以排序能完成</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quickSort1</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;   <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length &lt; <span class="hljs-number">2</span>) &#123;      <span class="hljs-keyword">return</span>;   &#125;   process1(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process1</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R)</span> </span>&#123;   <span class="hljs-keyword">if</span> (L &gt;= R) &#123;      <span class="hljs-keyword">return</span>;   &#125;   <span class="hljs-comment">// L..R partition arr[R]  [   &lt;=arr[R]   arr[R]    &gt;arr[R]  ]</span>   <span class="hljs-keyword">int</span> M = partition(arr, L, R);   process1(arr, L, M - <span class="hljs-number">1</span>);   process1(arr, M + <span class="hljs-number">1</span>, R);&#125;</code></pre><h2 id="快速排序2-0"><a href="#快速排序2-0" class="headerlink" title="快速排序2.0"></a>快速排序2.0</h2><p>在arr[L..R]范围上，进行快速排序的过程：<br>1）用arr[R]对该范围做partition，&lt; arr[R]的数在左部分，== arr[R]的数中间，&gt;arr[R]的数在右部分。假设== arr[R]的数所在范围是[a,b]<br>2）对arr[L..a-1]进行快速排序(递归)<br>3）对arr[b+1..R]进行快速排序(递归)<br>因为每一次partition都会搞定一批数的位置且不会再变动，所以排序能完成</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quickSort2</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;   <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length &lt; <span class="hljs-number">2</span>) &#123;      <span class="hljs-keyword">return</span>;   &#125;   process2(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process2</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R)</span> </span>&#123;   <span class="hljs-keyword">if</span> (L &gt;= R) &#123;      <span class="hljs-keyword">return</span>;   &#125;   <span class="hljs-keyword">int</span>[] equalArea = netherlandsFlag(arr, L, R);   process2(arr, L, equalArea[<span class="hljs-number">0</span>] - <span class="hljs-number">1</span>);   process2(arr, equalArea[<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>, R);&#125;</code></pre><h2 id="快速排序1-0和2-0的时间复杂度分析"><a href="#快速排序1-0和2-0的时间复杂度分析" class="headerlink" title="快速排序1.0和2.0的时间复杂度分析"></a>快速排序1.0和2.0的时间复杂度分析</h2><blockquote><p>数组已经有序的时候就是复杂度最高的时候<br>时间复杂度O(N^2)</p></blockquote><h2 id="快速排序3-0-随机快排-荷兰国旗技巧优化"><a href="#快速排序3-0-随机快排-荷兰国旗技巧优化" class="headerlink" title="快速排序3.0(随机快排+荷兰国旗技巧优化)"></a>快速排序3.0(随机快排+荷兰国旗技巧优化)</h2><p>在arr[L..R]范围上，进行快速排序的过程：<br>1）在这个范围上，随机选一个数记为num，<br>1）用num对该范围做partition，&lt; num的数在左部分，== num的数中间，&gt;num的数在右部分。假设== num的数所在范围是[a,b]<br>2）对arr[L..a-1]进行快速排序(递归)<br>3）对arr[b+1..R]进行快速排序(递归)<br>因为每一次partition都会搞定一批数的位置且不会再变动，所以排序能完成</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quickSort3</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;   <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length &lt; <span class="hljs-number">2</span>) &#123;      <span class="hljs-keyword">return</span>;   &#125;   process3(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process3</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R)</span> </span>&#123;   <span class="hljs-keyword">if</span> (L &gt;= R) &#123;      <span class="hljs-keyword">return</span>;   &#125;   <span class="hljs-comment">// 1、2拿arr[R]做划分值</span>   <span class="hljs-comment">// 3 随机选一个i, 人为放到arr[R], 再以arr[R]做划分值</span>   swap(arr, L + (<span class="hljs-keyword">int</span>) (Math.random() * (R - L + <span class="hljs-number">1</span>)), R);   <span class="hljs-keyword">int</span>[] equalArea = netherlandsFlag(arr, L, R);   process3(arr, L, equalArea[<span class="hljs-number">0</span>] - <span class="hljs-number">1</span>);   process3(arr, equalArea[<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>, R);&#125;</code></pre><pre><code class="hljs apache"><span class="hljs-attribute">1</span>）通过分析知道，划分值越靠近中间，性能越好；越靠近两边，性能越差<span class="hljs-attribute">2</span>）随机选一个数进行划分的目的就是让好情况和差情况都变成概率事件<span class="hljs-attribute">3</span>）把每一种情况都列出来，会有每种情况下的时间复杂度，但概率都是<span class="hljs-number">1</span>/N<span class="hljs-attribute">4</span>）那么所有情况都考虑，时间复杂度就是这种概率模型下的长期期望！</code></pre><p> *<strong>时间复杂度O(N<em>logN)，额外空间复杂度O(logN)都是这么来的。</em></strong></p><h1 id="比较器与堆"><a href="#比较器与堆" class="headerlink" title="比较器与堆"></a>比较器与堆</h1><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><h3 id="堆的实现"><a href="#堆的实现" class="headerlink" title="堆的实现"></a>堆的实现</h3><p>堆结构</p><p>1）堆结构就是用数组实现的完全二叉树结构</p><blockquote><p>完全二叉树是什么</p></blockquote><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201201131244.png" alt="完全二叉树"></p><blockquote><p>结点从左至右变满, 一个结点也是, 两个结点, 第二个结点在左边也是</p></blockquote><p>堆可以从数组arr[0]开始, 也可以从arr[1]开始, 为什么会出现从arr[1]开始的情况？</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201201131532.png" alt="arr[1]开始的堆"></p><p><strong>如图所示, 如果堆从arr[1]开始增加, 子结点以及父节点的运算都可以用位运算, 位运算就是快！</strong></p><p>2）完全二叉树中如果每棵子树的最大值都在顶部就是大根堆</p><blockquote><p>头结点为头的树, 最大值为头结点</p></blockquote><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201201131811.png" alt="大根堆"></p><p>3）完全二叉树中如果每棵子树的最小值都在顶部就是小根堆</p><blockquote><p>头结点为头的树, 最小值为头结点</p></blockquote><p>4）堆结构的heapInsert与heapify操作</p><blockquote><p>heapInsert: 数放入数组后, 与父节点比较, 如果数更大, 交换, 直到换到根结点</p></blockquote><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span></span>&#123;    <span class="hljs-keyword">if</span> (heapSize &gt; limit)&#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;heap is full!&quot;</span>);    &#125;    heap[heapSize] = value;    heapInsert(heap, heapSize++);&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 把默认最后加进来的数往上提</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> arr</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> index</span><span class="hljs-comment"> * arr[index] &gt; arr[(index - 1) / 2]已经包含两个条件</span><span class="hljs-comment"> * 1)arr[index] 不比arr[index父]大, 停</span><span class="hljs-comment"> * 2)index = 0, 停</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">heapInsert</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> index)</span></span>&#123;    <span class="hljs-keyword">while</span> (arr[index] &gt; arr[(index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>])&#123;        swap(arr, index, (index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>);        index = (index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;    &#125;&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201201133318.png" alt="heapInsert"></p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 删除堆的最大值并返回, 重组堆</span><span class="hljs-comment"> * 用最后的值去顶替arr[0]</span><span class="hljs-comment"> * 再往下交换, 找到左孩子与右孩子之间更大的数, 如果更小, 则交换</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> ans = heap[<span class="hljs-number">0</span>];    <span class="hljs-comment">// -- heapSize, 之后的数据进入无效区</span>    swap(heap, <span class="hljs-number">0</span>, -- heapSize);    heapify(heap, <span class="hljs-number">0</span>, heapSize);    <span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-comment">// 从index的位置往下看, 不断的下沉</span><span class="hljs-comment">// 1) 孩子都不比我大 停; 2) 已经没孩子了, 停</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">heapify</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> heapSize)</span></span>&#123;    <span class="hljs-keyword">int</span> left = index * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;    <span class="hljs-comment">// 左孩子不越界就肯定有孩子</span>    <span class="hljs-keyword">while</span> (left &lt; heapSize)&#123;        <span class="hljs-comment">// 再判断有没有右孩子</span>        <span class="hljs-comment">// 右孩子更大的条件是: 有右孩子 &amp;&amp; 右孩子大于左孩子</span>        <span class="hljs-keyword">int</span> largest = left + <span class="hljs-number">1</span> &lt; heapSize &amp;&amp; arr[left + <span class="hljs-number">1</span>] &gt; arr[left] ? left + <span class="hljs-number">1</span> : left;        largest = arr[largest] &gt; arr[index] ? largest : index;        <span class="hljs-comment">// 如果index更大, 则不用下坠</span>        <span class="hljs-keyword">if</span> (largest == index)&#123;            <span class="hljs-keyword">break</span>;        &#125;        swap(arr, index, largest);        index = largest;        left = index * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;    &#125;&#125;</code></pre><p>5）堆结构的增大和减少<br>6）优先级队列结构，就是堆结构(小根堆)</p><pre><code class="hljs java">PriorityQueue&lt;Integer&gt; heap = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;(<span class="hljs-keyword">new</span> MyComp());</code></pre><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><blockquote><p>先把数组数据变为大根堆结构, 再每次arr[0]与堆最后一个结点互换, 必定会把Max丢到最后, 再heapify</p></blockquote><pre><code class="hljs java"><span class="hljs-comment">// 堆排序额外空间复杂度O(1)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">heapSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;        <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length &lt; <span class="hljs-number">2</span>) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">// O(N*logN)</span><span class="hljs-comment">//    for (int i = 0; i &lt; arr.length; i++) &#123; // O(N)</span><span class="hljs-comment">//       heapInsert(arr, i); // O(logN)</span><span class="hljs-comment">//    &#125;</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = arr.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;            heapify(arr, i, arr.length);        &#125;        <span class="hljs-keyword">int</span> heapSize = arr.length;        swap(arr, <span class="hljs-number">0</span>, --heapSize);        <span class="hljs-comment">// O(N*logN)</span>        <span class="hljs-keyword">while</span> (heapSize &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// O(N)</span>            heapify(arr, <span class="hljs-number">0</span>, heapSize); <span class="hljs-comment">// O(logN)</span>            swap(arr, <span class="hljs-number">0</span>, --heapSize); <span class="hljs-comment">// O(1)</span>        &#125;    &#125;    <span class="hljs-comment">// arr[index]刚来的数，往上</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">heapInsert</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> index)</span> </span>&#123;        <span class="hljs-keyword">while</span> (arr[index] &gt; arr[(index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>]) &#123;            swap(arr, index, (index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>);            index = (index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;        &#125;    &#125;    <span class="hljs-comment">// arr[index]位置的数，能否往下移动</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">heapify</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> heapSize)</span> </span>&#123;        <span class="hljs-keyword">int</span> left = index * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>; <span class="hljs-comment">// 左孩子的下标</span>        <span class="hljs-keyword">while</span> (left &lt; heapSize) &#123; <span class="hljs-comment">// 下方还有孩子的时候</span>            <span class="hljs-comment">// 两个孩子中，谁的值大，把下标给largest</span>            <span class="hljs-comment">// 1）只有左孩子，left -&gt; largest</span>            <span class="hljs-comment">// 2) 同时有左孩子和右孩子，右孩子的值&lt;= 左孩子的值，left -&gt; largest</span>            <span class="hljs-comment">// 3) 同时有左孩子和右孩子并且右孩子的值&gt; 左孩子的值， right -&gt; largest</span>            <span class="hljs-keyword">int</span> largest = left + <span class="hljs-number">1</span> &lt; heapSize &amp;&amp; arr[left + <span class="hljs-number">1</span>] &gt; arr[left] ? left + <span class="hljs-number">1</span> : left;            <span class="hljs-comment">// 父和较大的孩子之间，谁的值大，把下标给largest</span>            largest = arr[largest] &gt; arr[index] ? largest : index;            <span class="hljs-keyword">if</span> (largest == index) &#123;                <span class="hljs-keyword">break</span>;            &#125;            swap(arr, largest, index);            index = largest;            left = index * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;        &#125;    &#125;</code></pre><pre><code class="hljs mathematica"><span class="hljs-number">1</span>，先让整个数组都变成大根堆结构，建立堆的过程<span class="hljs-operator">:</span>     <span class="hljs-number">1</span><span class="hljs-punctuation">)</span>从上到下的方法，时间复杂度为<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-operator">*</span><span class="hljs-variable">logN</span><span class="hljs-punctuation">)</span>     <span class="hljs-number">2</span><span class="hljs-punctuation">)</span>从下到上的方法，时间复杂度为<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-punctuation">)</span> <span class="hljs-number">2</span>，把堆的最大值和堆末尾的值交换，然后减少堆的大小之后，再去调整堆，一直周而复始，时间复杂度为<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-operator">*</span><span class="hljs-variable">logN</span><span class="hljs-punctuation">)</span> <span class="hljs-number">3</span>，堆的大小减小成<span class="hljs-number">0</span>之后，排序完成</code></pre><blockquote><p>堆排序优化</p></blockquote><pre><code class="hljs java"><span class="hljs-comment">// O(N*logN)</span><span class="hljs-comment">// 给定数据的数组,一个一个插入都可以</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123; <span class="hljs-comment">// O(N)</span>   heapInsert(arr, i); <span class="hljs-comment">// O(logN)</span>&#125;      <span class="hljs-comment">// O(N)</span><span class="hljs-comment">// 一定要给定数据数组, 一个一个插入无法使用</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = arr.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;   heapify(arr, i, arr.length);&#125;</code></pre><p>一个O(N*logN), 一个O(N)</p><p>怎么证明?</p><p>对于从数组最后开始heapify来说, 一颗N结点的树, 最后一层结点应该为N/2, 往上依次为N/4, N/8</p><p>最后一层只有”看”的操作, 倒数第二层有”看”和至多一次”换”的操作, 倒数第三层有”看”和至多两次”换”的操作</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201201135242.png" alt="堆排序优化"></p><h2 id="堆问题"><a href="#堆问题" class="headerlink" title="堆问题"></a>堆问题</h2><blockquote><p>已知一个几乎有序的数组。几乎有序是指，如果把数组排好顺序的话，每个元素移动的距离一定不超过k，并且k相对于数组长度来说是比较小的。<br>请选择一个合适的排序策略，对这个数组进行排序。</p></blockquote><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201207140824.png" alt="流程"></p><p>把前k+1个数放入小根堆, 例如0,1,2,3,4,5位置数放入小根堆, 0～5的数才可能来到0位置, 每排好一次序, 把最小值弹出放到0位置, 再把6位置放入小根堆, 再弹最小值…</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sortedArrDistanceLessK</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> k)</span> </span>&#123;   <span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span>) &#123;      <span class="hljs-keyword">return</span>;   &#125;   <span class="hljs-comment">// 默认小根堆</span>   PriorityQueue&lt;Integer&gt; heap = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;();   <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;   <span class="hljs-comment">// 0...K-1</span>   <span class="hljs-keyword">for</span> (; index &lt;= Math.min(arr.length - <span class="hljs-number">1</span>, k - <span class="hljs-number">1</span>); index++) &#123;      heap.add(arr[index]);   &#125;   <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;   <span class="hljs-comment">// 先加后弹</span>   <span class="hljs-keyword">for</span> (; index &lt; arr.length; i++, index++) &#123;      heap.add(arr[index]);      arr[i] = heap.poll();   &#125;   <span class="hljs-comment">// 没有数可以加了 只弹</span>   <span class="hljs-keyword">while</span> (!heap.isEmpty()) &#123;      arr[i++] = heap.poll();   &#125;&#125;</code></pre><p>O(N*logK), 前提是k小于数组长度, 每次加减logk, N次则乘</p><h2 id="比较器"><a href="#比较器" class="headerlink" title="比较器"></a>比较器</h2><blockquote><p>目前都是基于 <strong>比较</strong> 的排序, 只要告诉两个样本如何比较大小就足够</p></blockquote><p>1)比较器的实质就是 **重载比较运算符 **</p><p>2)比较器可以很好的应用在 <strong>特殊标准的排序</strong>上 </p><p>3)比较器可以很好的应用在 <strong>根据特殊标准排序的结构</strong>上</p><p>4)写代码变得异常容易，还用于 <strong>范型编程</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;   <span class="hljs-keyword">public</span> String name;   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> id;   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> age;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> id, <span class="hljs-keyword">int</span> age)</span> </span>&#123;      <span class="hljs-keyword">this</span>.name = name;      <span class="hljs-keyword">this</span>.id = id;      <span class="hljs-keyword">this</span>.age = age;   &#125;&#125;</code></pre><blockquote><p>comp(T o1, T o2) 返回负数o1放前, 正数o2放前</p></blockquote><pre><code class="hljs java">Student student1 = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-number">2</span>, <span class="hljs-number">20</span>);Student student2 = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-number">3</span>, <span class="hljs-number">21</span>);Student student3 = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">22</span>);Student[] students = <span class="hljs-keyword">new</span> Student[] &#123; student1, student2, student3 &#125;;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IdAscendingComparator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparator</span>&lt;<span class="hljs-title">Student</span>&gt; </span>&#123;   <span class="hljs-comment">// 返回负数的时候，第一个参数排在前面</span>   <span class="hljs-comment">// 返回正数的时候，第二个参数排在前面</span>   <span class="hljs-comment">// 返回0的时候，谁在前面无所谓</span>   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Student o1, Student o2)</span> </span>&#123;      <span class="hljs-keyword">return</span> o1.id - o2.id;   &#125;&#125;Arrays.sort(students, <span class="hljs-keyword">new</span> IdAscendingComparator());<span class="hljs-comment">// id升序</span></code></pre><pre><code class="hljs java"><span class="hljs-comment">// 先按照id排序，id小的，放前面；</span><span class="hljs-comment">// id一样，age大的，前面；</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IdInAgeDe</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparator</span>&lt;<span class="hljs-title">Student</span>&gt; </span>&#123;   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Student o1, Student o2)</span> </span>&#123;      <span class="hljs-keyword">return</span> o1.id != o2.id ? o1.id - o2.id  : (  o2.age - o1.age  );   &#125;<span class="hljs-comment">// 更复杂的比较器</span>&#125;</code></pre><h3 id="应用在根据特殊标准排序的结构上"><a href="#应用在根据特殊标准排序的结构上" class="headerlink" title="应用在根据特殊标准排序的结构上"></a>应用在根据特殊标准排序的结构上</h3><pre><code class="hljs java">PriorityQueue&lt;Student&gt; minHeapBasedId        = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;(<span class="hljs-keyword">new</span> AgeAscendingComparator());minHeapBasedId.add(student1);minHeapBasedId.add(student2);minHeapBasedId.add(student3);<span class="hljs-keyword">while</span> (!minHeapBasedId.isEmpty()) &#123;    Student student = minHeapBasedId.poll();    System.out.println(<span class="hljs-string">&quot;Name : &quot;</span> + student.name + <span class="hljs-string">&quot;, Id : &quot;</span> + student.id + <span class="hljs-string">&quot;, Age : &quot;</span> + student.age);&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AgeAscendingComparator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparator</span>&lt;<span class="hljs-title">Student</span>&gt; </span>&#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Student o1, Student o2)</span> </span>&#123;            <span class="hljs-keyword">return</span> o1.age - o2.age;        &#125;&#125;</code></pre><p>结果:</p><pre><code class="hljs asciidoc">===========================Name : A, Id : 2, Age : 20Name : B, Id : 3, Age : 21Name : C, Id : 1, Age : 22===========================</code></pre><h2 id="语言提供的堆结构-vs-手写的堆结构"><a href="#语言提供的堆结构-vs-手写的堆结构" class="headerlink" title="语言提供的堆结构 vs 手写的堆结构"></a>语言提供的堆结构 vs 手写的堆结构</h2><p>取决于，你有没有动态改信息的需求！</p><p>语言提供的堆结构，如果你动态改数据，不保证依然有序</p><p>手写堆结构，因为增加了对象的位置表，所以能够满足动态改信息的需求</p><blockquote><p>例子</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> classNo;   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> age;   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> id;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(<span class="hljs-keyword">int</span> c, <span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> i)</span> </span>&#123;      classNo = c;      age = a;      id = i;   &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StudentComparator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparator</span>&lt;<span class="hljs-title">Student</span>&gt; </span>&#123;   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Student o1, Student o2)</span> </span>&#123;      <span class="hljs-keyword">return</span> o1.age - o2.age;   &#125;&#125;</code></pre><pre><code class="hljs java">PriorityQueue&lt;Student&gt; heap = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;(<span class="hljs-keyword">new</span> StudentComparator());heap.add(s1);heap.add(s2);heap.add(s3);heap.add(s4);heap.add(s5);heap.add(s6);<span class="hljs-keyword">while</span> (!heap.isEmpty()) &#123;   Student cur = heap.poll();   System.out.println(cur.classNo + <span class="hljs-string">&quot;,&quot;</span> + cur.age + <span class="hljs-string">&quot;,&quot;</span> + cur.id);&#125;System.out.println(<span class="hljs-string">&quot;===============&quot;</span>);</code></pre><pre><code class="hljs asciidoc">6,10,333331,14,666663,20,444442,50,111111,60,222227,72,55555===============</code></pre><pre><code class="hljs java">s1 = <span class="hljs-keyword">new</span> Student(<span class="hljs-number">2</span>, <span class="hljs-number">50</span>, <span class="hljs-number">11111</span>);s2 = <span class="hljs-keyword">new</span> Student(<span class="hljs-number">1</span>, <span class="hljs-number">60</span>, <span class="hljs-number">22222</span>);s3 = <span class="hljs-keyword">new</span> Student(<span class="hljs-number">6</span>, <span class="hljs-number">10</span>, <span class="hljs-number">33333</span>);s4 = <span class="hljs-keyword">new</span> Student(<span class="hljs-number">3</span>, <span class="hljs-number">20</span>, <span class="hljs-number">44444</span>);s5 = <span class="hljs-keyword">new</span> Student(<span class="hljs-number">7</span>, <span class="hljs-number">72</span>, <span class="hljs-number">55555</span>);s6 = <span class="hljs-keyword">new</span> Student(<span class="hljs-number">1</span>, <span class="hljs-number">14</span>, <span class="hljs-number">66666</span>);heap = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;(<span class="hljs-keyword">new</span> StudentComparator());heap.add(s1);heap.add(s2);heap.add(s3);heap.add(s4);heap.add(s5);heap.add(s6);<span class="hljs-comment">// 加进去后 动态改已经加入堆里面的东西</span>s2.age = <span class="hljs-number">6</span>;s4.age = <span class="hljs-number">12</span>;s5.age = <span class="hljs-number">10</span>;s6.age = <span class="hljs-number">84</span>;<span class="hljs-keyword">while</span> (!heap.isEmpty()) &#123;    Student cur = heap.poll();    System.out.println(cur.classNo + <span class="hljs-string">&quot;,&quot;</span> + cur.age + <span class="hljs-string">&quot;,&quot;</span> + cur.id);&#125;</code></pre><pre><code class="hljs asciidoc">6,10,333333,12,444441,6,222227,10,555552,50,111111,84,66666===============</code></pre><blockquote><p>自己设计某一个值会发生变化的堆</p></blockquote><pre><code class="hljs java"><span class="hljs-comment">// 堆</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyHeap</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;    <span class="hljs-comment">// 没有 T[], 动态数组实现</span>    <span class="hljs-keyword">private</span> ArrayList&lt;T&gt; heap;    <span class="hljs-comment">// 记录在堆上的位置</span>    <span class="hljs-keyword">private</span> HashMap&lt;T, Integer&gt; indexMap;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> heapSize;    <span class="hljs-keyword">private</span> Comparator&lt;? <span class="hljs-keyword">super</span> T&gt; comparator;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyHeap</span><span class="hljs-params">(Comparator&lt;? <span class="hljs-keyword">super</span> T&gt; com)</span> </span>&#123;        heap = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        indexMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        heapSize = <span class="hljs-number">0</span>;        comparator = com;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> heapSize == <span class="hljs-number">0</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> heapSize;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">contains</span><span class="hljs-params">(T key)</span> </span>&#123;        <span class="hljs-keyword">return</span> indexMap.containsKey(key);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(T value)</span> </span>&#123;        heap.add(value);        indexMap.put(value, heapSize);        heapInsert(heapSize++);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;        T ans = heap.get(<span class="hljs-number">0</span>);        <span class="hljs-keyword">int</span> end = heapSize - <span class="hljs-number">1</span>;        swap(<span class="hljs-number">0</span>, end);        heap.remove(end);        indexMap.remove(ans);        heapify(<span class="hljs-number">0</span>, --heapSize);        <span class="hljs-keyword">return</span> ans;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">resign</span><span class="hljs-params">(T value)</span> </span>&#123;        <span class="hljs-keyword">int</span> valueIndex = indexMap.get(value);        <span class="hljs-comment">// 只会中一个逻辑</span>        heapInsert(valueIndex);        heapify(valueIndex, heapSize);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">heapInsert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;        <span class="hljs-keyword">while</span> (comparator.compare(heap.get(index), heap.get((index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>)) &lt; <span class="hljs-number">0</span>) &#123;            swap(index, (index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>);            index = (index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">heapify</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> heapSize)</span> </span>&#123;        <span class="hljs-keyword">int</span> left = index * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (left &lt; heapSize) &#123;            <span class="hljs-keyword">int</span> largest = left + <span class="hljs-number">1</span> &lt; heapSize &amp;&amp; (comparator.compare(heap.get(left + <span class="hljs-number">1</span>), heap.get(left)) &lt; <span class="hljs-number">0</span>)                    ? left + <span class="hljs-number">1</span>                    : left;            largest = comparator.compare(heap.get(largest), heap.get(index)) &lt; <span class="hljs-number">0</span> ? largest : index;            <span class="hljs-keyword">if</span> (largest == index) &#123;                <span class="hljs-keyword">break</span>;            &#125;            swap(largest, index);            index = largest;            left = index * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;        T o1 = heap.get(i);        T o2 = heap.get(j);        heap.set(i, o2);        heap.set(j, o1);        indexMap.put(o1, j);        indexMap.put(o2, i);    &#125;&#125;</code></pre><h1 id="trie、桶排序、排序总结"><a href="#trie、桶排序、排序总结" class="headerlink" title="trie、桶排序、排序总结"></a>trie、桶排序、排序总结</h1><h2 id="前缀树"><a href="#前缀树" class="headerlink" title="前缀树"></a>前缀树</h2><p>1）单个字符串中，字符从前到后的加到一棵多叉树上<br>2）字符放在路上，节点上有专属的数据项（常见的是pass和end值）<br>3）所有样本都这样添加，如果没有路就新建，如有路就复用<br>4）沿途节点的pass值增加1，每个字符串结束时来到的节点end值增加1</p><p>可以完成前缀相关的查询</p><blockquote><p>例子</p></blockquote><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201207154038.png" alt="test1"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201207154211.png" alt="test2"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201207154255.png" alt="test3"></p><p>所有字符串字符数量为 <strong>N</strong>, </p><p>新建树代价为 <strong>O(N)</strong>, </p><p>可以找”ab”插入多少次(找ab顺下去b的e值)  <strong>O(N)</strong>, </p><p>或者以”a”为前缀的有多少个字符串(找a的p值)  <strong>O(N)</strong></p><blockquote><p>代码(方式一) <strong>固定数组实现</strong></p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node1</span> </span>&#123;   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> pass;   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> end;   <span class="hljs-keyword">public</span> Node1[] nexts;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node1</span><span class="hljs-params">()</span> </span>&#123;      pass = <span class="hljs-number">0</span>;      end = <span class="hljs-number">0</span>;      <span class="hljs-comment">// 如何标记存在与否</span>      <span class="hljs-comment">// nexts[0] -&gt; a</span>      <span class="hljs-comment">// nexts[1] -&gt; b</span>      <span class="hljs-comment">// ..     -&gt; ..</span>      <span class="hljs-comment">// nexts[25]-&gt; z</span>      <span class="hljs-comment">// nexts[i]== null, i方向的路不存在</span>      <span class="hljs-comment">// nexts[i]!= null, i方向的路存在</span>      nexts = <span class="hljs-keyword">new</span> Node1[<span class="hljs-number">26</span>];<span class="hljs-comment">// a — z</span>   &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Trie1</span> </span>&#123;   <span class="hljs-keyword">private</span> Node1 root;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Trie1</span><span class="hljs-params">()</span> </span>&#123;      root = <span class="hljs-keyword">new</span> Node1();   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(String word)</span> </span>&#123;      <span class="hljs-keyword">if</span> (word == <span class="hljs-keyword">null</span>) &#123;         <span class="hljs-keyword">return</span>;      &#125;      <span class="hljs-keyword">char</span>[] chs = word.toCharArray();      Node1 node = root;      node.pass++;      <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;<span class="hljs-comment">// 路</span>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; chs.length; i++) &#123; <span class="hljs-comment">// 从左往右遍历字符</span>         index = chs[i] - <span class="hljs-string">&#x27;a&#x27;</span>; <span class="hljs-comment">// 由字符，对应成走向哪条路</span>         <span class="hljs-keyword">if</span> (node.nexts[index] == <span class="hljs-keyword">null</span>) &#123;            node.nexts[index] = <span class="hljs-keyword">new</span> Node1();         &#125;         node = node.nexts[index];         node.pass++;      &#125;      node.end++;   &#125;   <span class="hljs-comment">// 沿途p--, 最后e--</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delete</span><span class="hljs-params">(String word)</span> </span>&#123;      <span class="hljs-keyword">if</span> (search(word) != <span class="hljs-number">0</span>) &#123;         <span class="hljs-keyword">char</span>[] chs = word.toCharArray();         Node1 node = root;         node.pass--;         <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;         <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; chs.length; i++) &#123;            index = chs[i] - <span class="hljs-string">&#x27;a&#x27;</span>;            <span class="hljs-comment">// 只要有p变成0，以后肯定都不会经过了</span>            <span class="hljs-keyword">if</span> (--node.nexts[index].pass == <span class="hljs-number">0</span>) &#123;               node.nexts[index] = <span class="hljs-keyword">null</span>;               <span class="hljs-comment">// 直接让jvm释放</span>               <span class="hljs-comment">// c++需要遍历后续手动释放</span>               <span class="hljs-keyword">return</span>;            &#125;            node = node.nexts[index];         &#125;         node.end--;      &#125;   &#125;   <span class="hljs-comment">// word这个单词之前加入过几次</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(String word)</span> </span>&#123;      <span class="hljs-keyword">if</span> (word == <span class="hljs-keyword">null</span>) &#123;         <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;      &#125;      <span class="hljs-keyword">char</span>[] chs = word.toCharArray();      Node1 node = root;      <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; chs.length; i++) &#123;         index = chs[i] - <span class="hljs-string">&#x27;a&#x27;</span>;         <span class="hljs-keyword">if</span> (node.nexts[index] == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;         &#125;         node = node.nexts[index];      &#125;      <span class="hljs-keyword">return</span> node.end;   &#125;   <span class="hljs-comment">// 所有加入的字符串中，有几个是以pre这个字符串作为前缀的</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">prefixNumber</span><span class="hljs-params">(String pre)</span> </span>&#123;      <span class="hljs-keyword">if</span> (pre == <span class="hljs-keyword">null</span>) &#123;         <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;      &#125;      <span class="hljs-keyword">char</span>[] chs = pre.toCharArray();      Node1 node = root;      <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; chs.length; i++) &#123;         index = chs[i] - <span class="hljs-string">&#x27;a&#x27;</span>;         <span class="hljs-keyword">if</span> (node.nexts[index] == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;         &#125;         node = node.nexts[index];      &#125;      <span class="hljs-keyword">return</span> node.pass;   &#125;&#125;</code></pre><blockquote><p>代码(方式二)  <strong>哈希表实现</strong>:字符种类变多!</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node2</span> </span>&#123;   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> pass;   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> end;   <span class="hljs-comment">// ASCII码值, 下一个结点</span>   <span class="hljs-keyword">public</span> HashMap&lt;Integer, Node2&gt; nexts;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node2</span><span class="hljs-params">()</span> </span>&#123;      pass = <span class="hljs-number">0</span>;      end = <span class="hljs-number">0</span>;      nexts = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();   &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Trie2</span> </span>&#123;   <span class="hljs-keyword">private</span> Node2 root;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Trie2</span><span class="hljs-params">()</span> </span>&#123;      root = <span class="hljs-keyword">new</span> Node2();   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(String word)</span> </span>&#123;      <span class="hljs-keyword">if</span> (word == <span class="hljs-keyword">null</span>) &#123;         <span class="hljs-keyword">return</span>;      &#125;      <span class="hljs-keyword">char</span>[] chs = word.toCharArray();      Node2 node = root;      node.pass++;      <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; chs.length; i++) &#123;         index = (<span class="hljs-keyword">int</span>) chs[i];         <span class="hljs-keyword">if</span> (!node.nexts.containsKey(index)) &#123;            node.nexts.put(index, <span class="hljs-keyword">new</span> Node2());         &#125;         node = node.nexts.get(index);         node.pass++;      &#125;      node.end++;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delete</span><span class="hljs-params">(String word)</span> </span>&#123;      <span class="hljs-keyword">if</span> (search(word) != <span class="hljs-number">0</span>) &#123;         <span class="hljs-keyword">char</span>[] chs = word.toCharArray();         Node2 node = root;         node.pass--;         <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;         <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; chs.length; i++) &#123;            index = (<span class="hljs-keyword">int</span>) chs[i];            <span class="hljs-keyword">if</span> (--node.nexts.get(index).pass == <span class="hljs-number">0</span>) &#123;               node.nexts.remove(index);               <span class="hljs-keyword">return</span>;            &#125;            node = node.nexts.get(index);         &#125;         node.end--;      &#125;   &#125;   <span class="hljs-comment">// word这个单词之前加入过几次</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(String word)</span> </span>&#123;      <span class="hljs-keyword">if</span> (word == <span class="hljs-keyword">null</span>) &#123;         <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;      &#125;      <span class="hljs-keyword">char</span>[] chs = word.toCharArray();      Node2 node = root;      <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; chs.length; i++) &#123;         index = (<span class="hljs-keyword">int</span>) chs[i];         <span class="hljs-keyword">if</span> (!node.nexts.containsKey(index)) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;         &#125;         node = node.nexts.get(index);      &#125;      <span class="hljs-keyword">return</span> node.end;   &#125;   <span class="hljs-comment">// 所有加入的字符串中，有几个是以pre这个字符串作为前缀的</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">prefixNumber</span><span class="hljs-params">(String pre)</span> </span>&#123;      <span class="hljs-keyword">if</span> (pre == <span class="hljs-keyword">null</span>) &#123;         <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;      &#125;      <span class="hljs-keyword">char</span>[] chs = pre.toCharArray();      Node2 node = root;      <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; chs.length; i++) &#123;         index = (<span class="hljs-keyword">int</span>) chs[i];         <span class="hljs-keyword">if</span> (!node.nexts.containsKey(index)) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;         &#125;         node = node.nexts.get(index);      &#125;      <span class="hljs-keyword">return</span> node.pass;   &#125;&#125;</code></pre><h2 id="不基于比较的排序"><a href="#不基于比较的排序" class="headerlink" title="不基于比较的排序"></a>不基于比较的排序</h2><p>桶排序思想下的排序：**计数排序 &amp; 基数排序 **</p><p>1)桶排序思想下的排序都是 <strong>不基于比较的排序</strong></p><ol start="2"><li><strong>时间复杂度为O(N)，额外空间负载度O(M)</strong>:无法确定</li></ol><p>3)应用范围有限， <strong>需要样本的数据状况</strong> 满足桶的划分,  <strong>强相关</strong></p><blockquote><p>区别</p></blockquote><p>1）一般来讲，计数排序要求，样本是 <strong>整数</strong>，且 <strong>范围比较窄</strong></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201207164502.png" alt="计数排序"></p><p>例子:[]里数据为年龄, 年龄不会超过200, 准备一个[0-200]的桶, 记录arr的数, 有就加一, 再遍历桶</p><p>2）一般来讲，基数排序要求，样本是 <strong>10进制的正整数</strong></p><p>例子:</p><p>[100,17,29,13,5,27]</p><p>找到最大值100, 补齐位数变成[100,017,029,013,005,027]</p><p>准备一个桶 0,1,2,3,4,5,6,7,8,9, 每一个桶 <strong>队列</strong>, 先进先出</p><p>[100,017,029,013,005,027]根据个位数入桶, 再倒出来, 由于队列, 先进先出</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201207165238.png" alt="第一次排序后"></p><p>再根据十位数字入桶, 再倒出来, 由于队列, 先进先出</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201207165457.png" alt="第二次后"></p><p>再根据百位数字入桶, 再倒出来, 由于队列, 先进先出</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201207165615.png" alt="第三次排序后"></p><p> <strong>一旦要求稍有升级，改写代价增加是显而易见的！</strong></p><h3 id="计数排序代码"><a href="#计数排序代码" class="headerlink" title="计数排序代码"></a>计数排序代码</h3><pre><code class="hljs JAVA"><span class="hljs-comment">// only for 0~200 value</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">countSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;   <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length &lt; <span class="hljs-number">2</span>) &#123;      <span class="hljs-keyword">return</span>;   &#125;   <span class="hljs-keyword">int</span> max = Integer.MIN_VALUE;   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;      max = Math.max(max, arr[i]);   &#125;   <span class="hljs-keyword">int</span>[] bucket = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[max + <span class="hljs-number">1</span>];   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;      bucket[arr[i]]++;   &#125;   <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; bucket.length; j++) &#123;      <span class="hljs-keyword">while</span> (bucket[j]-- &gt; <span class="hljs-number">0</span>) &#123;         arr[i++] = j;      &#125;   &#125;&#125;</code></pre><h3 id="基数排序代码-O-N-log10为底max"><a href="#基数排序代码-O-N-log10为底max" class="headerlink" title="基数排序代码 O(N*log10为底max)"></a>基数排序代码 O(N*log10为底max)</h3><pre><code class="hljs Java"><span class="hljs-comment">// only for no-negative value</span><span class="hljs-comment">// 非负</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">radixSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;   <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length &lt; <span class="hljs-number">2</span>) &#123;      <span class="hljs-keyword">return</span>;   &#125;   radixSort(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>, maxbits(arr));&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxbits</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;   <span class="hljs-keyword">int</span> max = Integer.MIN_VALUE;   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;      max = Math.max(max, arr[i]);   &#125;   <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;   <span class="hljs-keyword">while</span> (max != <span class="hljs-number">0</span>) &#123;      res++;      max /= <span class="hljs-number">10</span>;   &#125;   <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-comment">// arr[l..r]排序  ,  digit(最大值位数)</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">radixSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R, <span class="hljs-keyword">int</span> digit)</span> </span>&#123;   <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> radix = <span class="hljs-number">10</span>; <span class="hljs-comment">// 以十为基底</span>   <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;   <span class="hljs-comment">// 有多少个数准备多少个辅助空间</span>   <span class="hljs-keyword">int</span>[] help = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[R - L + <span class="hljs-number">1</span>];   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> d = <span class="hljs-number">1</span>; d &lt;= digit; d++) &#123; <span class="hljs-comment">// 有多少位就进出几次</span>      <span class="hljs-comment">// 10个空间</span>       <span class="hljs-comment">// count[0] 当前位(d位)是0的数字有多少个</span>      <span class="hljs-comment">// count[1] 当前位(d位)是(0和1)的数字有多少个</span>      <span class="hljs-comment">// count[2] 当前位(d位)是(0、1和2)的数字有多少个</span>      <span class="hljs-comment">// count[i] 当前位(d位)是(0~i)的数字有多少个</span>      <span class="hljs-keyword">int</span>[] count = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[radix]; <span class="hljs-comment">// count[0..9]</span>      <span class="hljs-keyword">for</span> (i = L; i &lt;= R; i++) &#123;         <span class="hljs-comment">// 取出Digit位数上的数 </span>         <span class="hljs-comment">// 103 1 3</span>         <span class="hljs-comment">// 202 1 2</span>         j = getDigit(arr[i], d);         count[j]++;      &#125;      <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; radix; i++) &#123;         <span class="hljs-comment">// count自己变成count&#x27;</span>         count[i] = count[i] + count[i - <span class="hljs-number">1</span>];      &#125;      <span class="hljs-keyword">for</span> (i = R; i &gt;= L; i--) &#123;         j = getDigit(arr[i], d);         help[count[j] - <span class="hljs-number">1</span>] = arr[i];         count[j]--;      &#125;      <span class="hljs-keyword">for</span> (i = L, j = <span class="hljs-number">0</span>; i &lt;= R; i++, j++) &#123;         arr[i] = help[j];      &#125;   &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getDigit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> d)</span> </span>&#123;   <span class="hljs-keyword">return</span> ((x / ((<span class="hljs-keyword">int</span>) Math.pow(<span class="hljs-number">10</span>, d - <span class="hljs-number">1</span>))) % <span class="hljs-number">10</span>);&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201207172931.png" alt="基数排序解析"></p><p>准备count数组为10长度，下标0 - 9</p><p>先对比个位数大小，分别放入对应count数组，count转化为count’词频数组，代表小于等于索引i的数有多少个</p><p>再从 <strong>右往左遍历</strong>数组（正常来说从左往右时302应该在队列末尾最后出队），开辟最大个数（小于等于9的数字有五个）的help数组，从右往左遍历时候302个位下标为2，小于等于2的有四个，所以可能放在第0 - 第3个数字，但因为从右往左遍历，302应该在2号桶最后倒出来， 所以302放help[3]，count’的词频减1，41应该在1号桶最后倒出来，个位数小于等于1有两个，所以放help[1]，202放剩下的2最后，小于等于2变成三个，所以help[2]….</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201207173538.png" alt="只用数组模拟入桶出桶行为"></p><h1 id="排序算法的稳定性及总结"><a href="#排序算法的稳定性及总结" class="headerlink" title="排序算法的稳定性及总结"></a>排序算法的稳定性及总结</h1><h2 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h2><p>稳定性是指同样大小的样本再 <strong>排序之后不会改变相对次序</strong></p><ul><li>第一个1还在第一个, 第二个2还在第二个</li></ul><p>对 <strong>基础类型</strong> 来说，稳定性毫无意义</p><ul><li>不用区分是第几个1</li></ul><p>对 <strong>非基础类型</strong> (引用)来说，稳定性有重要意义</p><ul><li>班级号、年龄的学生类，第一回按照所有学生年龄从小到大排序，基于此再按照班级号从小到大排序</li><li>如果 <strong>具有稳定性</strong> : [一班年纪小, 一班年纪大, 二班年纪小, 三班年纪大…]</li><li>即可选择 价格最低和好评最高 -&gt; 物美价廉</li></ul><p>有些排序算法可以实现成稳定的，而有些排序算法无论如何都实现不成稳定的</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​             时间复杂度 额外空间复杂度   稳定性<br>选择排序    O(N^2)          O(1)            无<br>冒泡排序    O(N^2)          O(1)            有<br>插入排序    O(N^2)          O(1)            有<br>归并排序    O(NlogN)         O(N)           有<br>随机快排    O(NlogN)         O(logN)        无<br>堆排序      O(NlogN)        O(1)           无<br>= = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =<br>计数排序    O(N)      O(M)    有<br>基数排序    O(N)      O(N)    有</p><ul><li><p><strong>选择排序</strong> 问题</p><p>[5,5,5,5,1,5,5,5,5] 直接第一个5位置放到1位置交换，5位置被破坏</p></li><li><p><strong>冒泡排序</strong> </p><p>相等时候不交换，稳定性就不会被破坏</p></li><li><p><strong>插入排序</strong> </p><p>面对相等时，不替换，稳定性也不会被破坏</p></li><li><p><strong>归并排序</strong></p><p>面对相等时，先拷贝左边的，稳定性也不会被破坏</p><p>但如果解决逆序对等问题先拷贝右边则会出现问题</p></li><li><p><strong>随机快排</strong></p><p>Partition过程无法做稳定</p><p>小于等于区下一个数交换，交换的会是等于区的数字，数字的位置就会被破坏</p></li><li><p><strong>堆排序</strong></p><p>变成大根堆的时候, 3，3，3，3遇到4后有很多个3的位置会改变</p></li></ul><blockquote><p>总结</p></blockquote><pre><code class="hljs mathematica"><span class="hljs-number">1</span>）不基于比较的排序，对样本数据有严格要求，不易改写<span class="hljs-number">2</span>）基于比较的排序，只要规定好两个样本怎么比大小就可以直接复用<span class="hljs-number">3</span>）基于比较的排序，时间复杂度的极限是<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-operator">*</span><span class="hljs-variable">logN</span><span class="hljs-punctuation">)</span><span class="hljs-number">4</span>）时间复杂度<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-operator">*</span><span class="hljs-variable">logN</span><span class="hljs-punctuation">)</span>、额外空间复杂度低于<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-punctuation">)</span>、且稳定的基于比较的排序是不存在的。<span class="hljs-number">5</span>）为了绝对的速度选快排（常数时间最少）、为了省空间选堆排、为了稳定性选归并</code></pre><h2 id="常见的坑"><a href="#常见的坑" class="headerlink" title="常见的坑"></a>常见的坑</h2><ul><li>归并排序的额外空间复杂度可以变成O(1)，“ <strong>归并排序 内部缓存法</strong> ”，但是将变得 <strong>不再稳定</strong>。</li><li>“ <strong>原地归并排序</strong> “ 是垃圾贴，会让时间复杂度变成O(N^2) </li><li>快速排序稳定性改进，“01 stable sort”，但是会对 <strong>样本数据要求更多</strong>。</li></ul><ul><li><p>在整型数组中，请把奇数放在数组左边，偶数放在数组右边，要求所有奇数之间原始的相对次序不变，所有偶数之间原始相对次序不变。</p><p>要求：时间复杂度做到O(N)，额外空间复杂度做到O(1)</p><p>**这是一个 0,1标准的Partition **(原始小于等于和大于分界，此问题奇数偶数分界), 而Partition过程无法做到稳定性</p></li></ul><p>系统函数：先反射，判定是引用传递还是值传递，引用归并，值传递快排</p><h1 id="链表问题"><a href="#链表问题" class="headerlink" title="链表问题"></a>链表问题</h1><blockquote><p> 面试时链表解题的 <strong>方法论</strong></p></blockquote><p>1)对于笔试，不用太在乎空间复杂度，一切为了时间复杂度</p><p>2)对于面试，时间复杂度依然放在第一位，但是一定要找到空间最省的方法</p><h2 id="链表面试题常用数据结构和技巧"><a href="#链表面试题常用数据结构和技巧" class="headerlink" title="链表面试题常用数据结构和技巧"></a>链表面试题常用数据结构和技巧</h2><p>1）使用容器(哈希表、数组等)</p><p>2）快慢指针 </p><h2 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h2><p>1）输入链表头节点，奇数长度返回中点，偶数长度返回上中点</p><p>1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt;5 找到3, 1 -&gt; 2 -&gt; 3 -&gt; 4  找到2</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">midOrUpMidNode</span><span class="hljs-params">(Node head)</span> </span>&#123;   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span> || head.next == <span class="hljs-keyword">null</span> || head.next.next == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span> head;   &#125;   <span class="hljs-comment">// 链表 &gt;= 三个结点</span>   Node slow = head.next;   Node fast = head.next.next;   <span class="hljs-keyword">while</span> (fast.next != <span class="hljs-keyword">null</span> &amp;&amp; fast.next.next != <span class="hljs-keyword">null</span>) &#123;      slow = slow.next;      fast = fast.next.next;   &#125;   <span class="hljs-keyword">return</span> slow;&#125;</code></pre><p>2）输入链表头节点，奇数长度返回中点，偶数长度返回下中点</p><p>1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt;5 找到3,  1 -&gt; 2 -&gt; 3 -&gt; 4  找到3</p><p>3）输入链表头节点，奇数长度返回中点前一个，偶数长度返回上中点前一个</p><p>4）输入链表头节点，奇数长度返回中点前一个，偶数长度返回下中点前一个</p><h2 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h2><h3 id="给定一个单链表的头节点head，请判断该链表是否为回文结构。"><a href="#给定一个单链表的头节点head，请判断该链表是否为回文结构。" class="headerlink" title="给定一个单链表的头节点head，请判断该链表是否为回文结构。"></a>给定一个单链表的头节点head，请判断该链表是否为回文结构。</h3><p>1）栈方法特别简单（笔试用）</p><ul><li><p><strong>栈实现</strong></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201208150841.png" alt="栈"></p><p>把链表value全放栈中，再弹出一个一个对比。</p><p>Code:</p><pre><code class="hljs java"><span class="hljs-comment">// need n extra space</span><span class="hljs-comment">// stack</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPalindrome1</span><span class="hljs-params">(Node head)</span> </span>&#123;   Stack&lt;Node&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;Node&gt;();   Node cur = head;   <span class="hljs-keyword">while</span> (cur != <span class="hljs-keyword">null</span>) &#123;      stack.push(cur);      cur = cur.next;   &#125;   <span class="hljs-keyword">while</span> (head != <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">if</span> (head.value != stack.pop().value) &#123;         <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;      &#125;      head = head.next;   &#125;   <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;&#125;</code></pre></li><li><p><strong>栈实现2</strong></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201208151246.png" alt="快慢指针定位"></p><p>快慢指针定位到中点的位置, 奇数唯一中点偶数上中点, 把右半部分加到栈中, 弹出与head一一对比</p><pre><code class="hljs java"><span class="hljs-comment">// need n/2 extra space</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPalindrome2</span><span class="hljs-params">(Node head)</span> </span>&#123;   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span> || head.next == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;   &#125;   Node right = head.next;   Node cur = head;   <span class="hljs-keyword">while</span> (cur.next != <span class="hljs-keyword">null</span> &amp;&amp; cur.next.next != <span class="hljs-keyword">null</span>) &#123;      right = right.next;      cur = cur.next.next;   &#125;   Stack&lt;Node&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;Node&gt;();   <span class="hljs-keyword">while</span> (right != <span class="hljs-keyword">null</span>) &#123;      stack.push(right);      right = right.next;   &#125;   <span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;      <span class="hljs-keyword">if</span> (head.value != stack.pop().value) &#123;         <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;      &#125;      head = head.next;   &#125;   <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;&#125;</code></pre></li></ul><p>2）改原链表的方法就需要注意边界了（面试用）</p><p>​ <img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201208151959.png" alt="原链表"></p><p>变化为-&gt;</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201208152030.png" alt="变化后"></p><p>再L与R对比, 直到比到S, 最后再变回链表位置即可。</p><p>这样的 <strong>额外空间复杂度为 O(1);</strong></p><p>code:</p><pre><code class="hljs java"><span class="hljs-comment">// need O(1) extra space</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPalindrome3</span><span class="hljs-params">(Node head)</span> </span>&#123;   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span> || head.next == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;   &#125;   Node n1 = head; <span class="hljs-comment">// slow</span>   Node n2 = head; <span class="hljs-comment">// fast</span>   <span class="hljs-keyword">while</span> (n2.next != <span class="hljs-keyword">null</span> &amp;&amp; n2.next.next != <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// find mid node</span>      n1 = n1.next; <span class="hljs-comment">// n1 -&gt; mid</span>      n2 = n2.next.next; <span class="hljs-comment">// n2 -&gt; end</span>   &#125;   n2 = n1.next; <span class="hljs-comment">// n2 -&gt; right part first node</span>   n1.next = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// mid.next -&gt; null</span>   Node n3 = <span class="hljs-keyword">null</span>;   <span class="hljs-keyword">while</span> (n2 != <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// right part convert</span>      n3 = n2.next; <span class="hljs-comment">// n3 -&gt; save next node</span>      n2.next = n1; <span class="hljs-comment">// next of right node convert</span>      n1 = n2; <span class="hljs-comment">// n1 move</span>      n2 = n3; <span class="hljs-comment">// n2 move</span>   &#125;   n3 = n1; <span class="hljs-comment">// n3 -&gt; save last node</span>   n2 = head;<span class="hljs-comment">// n2 -&gt; left first node</span>   <span class="hljs-keyword">boolean</span> res = <span class="hljs-keyword">true</span>;   <span class="hljs-keyword">while</span> (n1 != <span class="hljs-keyword">null</span> &amp;&amp; n2 != <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// check palindrome</span>      <span class="hljs-keyword">if</span> (n1.value != n2.value) &#123;         res = <span class="hljs-keyword">false</span>;         <span class="hljs-keyword">break</span>;      &#125;      n1 = n1.next; <span class="hljs-comment">// left to mid</span>      n2 = n2.next; <span class="hljs-comment">// right to mid</span>   &#125;   n1 = n3.next;   n3.next = <span class="hljs-keyword">null</span>;   <span class="hljs-keyword">while</span> (n1 != <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// recover list</span>      n2 = n1.next;      n1.next = n3;      n3 = n1;      n1 = n2;   &#125;   <span class="hljs-keyword">return</span> res;&#125;</code></pre><h3 id="将单向链表按某值划分成左边小、中间相等、右边大的形式"><a href="#将单向链表按某值划分成左边小、中间相等、右边大的形式" class="headerlink" title="将单向链表按某值划分成左边小、中间相等、右边大的形式"></a>将单向链表按某值划分成左边小、中间相等、右边大的形式</h3><p>1）把链表放入数组里，在数组上做partition（笔试用）( <strong>不稳定</strong> )</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">listPartition1</span><span class="hljs-params">(Node head, <span class="hljs-keyword">int</span> pivot)</span> </span>&#123;   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span> head;   &#125;   Node cur = head;   <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;   <span class="hljs-keyword">while</span> (cur != <span class="hljs-keyword">null</span>) &#123;      i++;      cur = cur.next;   &#125;   Node[] nodeArr = <span class="hljs-keyword">new</span> Node[i];   i = <span class="hljs-number">0</span>;   cur = head;   <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i != nodeArr.length; i++) &#123;      nodeArr[i] = cur;      cur = cur.next;   &#125;   arrPartition(nodeArr, pivot);   <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i != nodeArr.length; i++) &#123;      nodeArr[i - <span class="hljs-number">1</span>].next = nodeArr[i];   &#125;   nodeArr[i - <span class="hljs-number">1</span>].next = <span class="hljs-keyword">null</span>;   <span class="hljs-keyword">return</span> nodeArr[<span class="hljs-number">0</span>];&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">arrPartition</span><span class="hljs-params">(Node[] nodeArr, <span class="hljs-keyword">int</span> pivot)</span> </span>&#123;   <span class="hljs-keyword">int</span> small = -<span class="hljs-number">1</span>;   <span class="hljs-keyword">int</span> big = nodeArr.length;   <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;   <span class="hljs-keyword">while</span> (index != big) &#123;      <span class="hljs-keyword">if</span> (nodeArr[index].value &lt; pivot) &#123;         swap(nodeArr, ++small, index++);      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nodeArr[index].value == pivot) &#123;         index++;      &#125; <span class="hljs-keyword">else</span> &#123;         swap(nodeArr, --big, index);      &#125;   &#125;&#125;</code></pre><p>2）分成小、中、大三部分，再把各个部分之间串起来（面试用）</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201208161643.png" alt="六个变量"></p><p>设置六个变量，分别为小于区头尾结点，大于区头尾结点，等于区头尾结点。</p><p>依次遍历，例如遍历4结点，bH、bT = 4，4结点断开。2也是，发至sH和sT=2，3发至eH和eT=3。</p><p>来到5时，要发到大于区，5串到4下面，bH=4，让bT指向5但5变成bT。</p><p>来到6时，bT指向6并让bT找到6的位置。</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201208162538.png" alt="流程"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201208162652.png" alt="流程2"></p><p>每一步O(1),整体O(N); 且是 <strong>稳定的</strong></p><p>code:</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">listPartition2</span><span class="hljs-params">(Node head, <span class="hljs-keyword">int</span> pivot)</span> </span>&#123;   Node sH = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// small head</span>   Node sT = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// small tail</span>   Node eH = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// equal head</span>   Node eT = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// equal tail</span>   Node mH = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// big head</span>   Node mT = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// big tail</span>   Node next = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// save next node</span>   <span class="hljs-comment">// every node distributed to three lists</span>   <span class="hljs-keyword">while</span> (head != <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-comment">// 记录head.next 后面结点next是要销毁的</span>      next = head.next;      head.next = <span class="hljs-keyword">null</span>;      <span class="hljs-keyword">if</span> (head.value &lt; pivot) &#123;         <span class="hljs-keyword">if</span> (sH == <span class="hljs-keyword">null</span>) &#123;            sH = head;            sT = head;         &#125; <span class="hljs-keyword">else</span> &#123;            sT.next = head;            sT = head;         &#125;      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (head.value == pivot) &#123;         <span class="hljs-keyword">if</span> (eH == <span class="hljs-keyword">null</span>) &#123;            eH = head;            eT = head;         &#125; <span class="hljs-keyword">else</span> &#123;            eT.next = head;            eT = head;         &#125;      &#125; <span class="hljs-keyword">else</span> &#123;         <span class="hljs-keyword">if</span> (mH == <span class="hljs-keyword">null</span>) &#123;            mH = head;            mT = head;         &#125; <span class="hljs-keyword">else</span> &#123;            mT.next = head;            mT = head;         &#125;      &#125;      head = next;   &#125;   <span class="hljs-comment">// small and equal reconnect</span>   <span class="hljs-keyword">if</span> (sT != <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// 如果有小于区域</span>      sT.next = eH;      eT = eT == <span class="hljs-keyword">null</span> ? sT : eT; <span class="hljs-comment">// 下一步，谁去连大于区域的头，谁就变成eT</span>   &#125;   <span class="hljs-comment">// 上面的if，不管跑了没有，et</span>   <span class="hljs-comment">// all reconnect</span>   <span class="hljs-keyword">if</span> (eT != <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// 如果小于区域和等于区域，不是都没有</span>      eT.next = mH;   &#125;   <span class="hljs-keyword">return</span> sH != <span class="hljs-keyword">null</span> ? sH : (eH != <span class="hljs-keyword">null</span> ? eH : mH);&#125;</code></pre><h3 id="一种特殊的单链表节点类-random"><a href="#一种特殊的单链表节点类-random" class="headerlink" title="一种特殊的单链表节点类 random"></a>一种特殊的单链表节点类 random</h3><blockquote><p> 一种特殊的单链表节点类描述如下</p></blockquote><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123; <span class="hljs-keyword">int</span> value; Node next; Node rand; Node(<span class="hljs-keyword">int</span> val) &#123; value = val; &#125; &#125;</code></pre><p>rand指针是单链表节点结构中新增的指针，rand可能指向链表中的任意一个节点，也可能指向null。<br>给定一个由Node节点类型组成的无环单链表的头节点 head，请实现一个函数完成这个链表的复制，并返回复制的新链表的头节点。<br> <strong>【要求】</strong><br> **时间复杂度O(N)，额外空间复杂度O(1) **</p><ul><li><p>哈希表</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">copyListWithRand1</span><span class="hljs-params">(Node head)</span> </span>&#123;   HashMap&lt;Node, Node&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;Node, Node&gt;();   Node cur = head;   <span class="hljs-keyword">while</span> (cur != <span class="hljs-keyword">null</span>) &#123;      map.put(cur, <span class="hljs-keyword">new</span> Node(cur.value));      cur = cur.next;   &#125;   cur = head;   <span class="hljs-keyword">while</span> (cur != <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-comment">// cur 老          (key)</span>      <span class="hljs-comment">// map.get(cur) 新 (value)</span>      map.get(cur).next = map.get(cur.next);      map.get(cur).rand = map.get(cur.rand);      cur = cur.next;   &#125;   <span class="hljs-keyword">return</span> map.get(head);&#125;</code></pre></li></ul><ul><li><p>不用哈希表</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201208175756.png" alt="克隆, 放置后面"></p><p>一次拿出一对:</p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201208175936.png" alt="如何克隆？" style="zoom:50%;" /></li></ul><p>  我们通过1找到1的random 3，又因为3’就在3后面，所以可以直接3.next找到并与1’连接</p><p>  最后分离</p><p>  code:</p>  <pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">copyListWithRand2</span><span class="hljs-params">(Node head)</span> </span>&#123;   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;   &#125;   Node cur = head;   Node next = <span class="hljs-keyword">null</span>;   <span class="hljs-comment">// copy node and link to every node</span>   <span class="hljs-comment">// 1 -&gt; 2</span>   <span class="hljs-comment">// 1 -&gt; 1&#x27; -&gt; 2</span>   <span class="hljs-keyword">while</span> (cur != <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-comment">// cur 老</span>      <span class="hljs-comment">// next表示 老 的下一个</span>      next = cur.next;      cur.next = <span class="hljs-keyword">new</span> Node(cur.value);      cur.next.next = next;      cur = next;   &#125;   cur = head;   Node curCopy = <span class="hljs-keyword">null</span>;   <span class="hljs-comment">// set copy node rand</span>   <span class="hljs-comment">// 1 -&gt; 1&#x27; -&gt; 2 -&gt; 2&#x27;</span>   <span class="hljs-keyword">while</span> (cur != <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-comment">// cur 老</span>      <span class="hljs-comment">// cur.next  新 copy</span>      next = cur.next.next;      curCopy = cur.next;      <span class="hljs-comment">// 老的rand的下一个(插入进来的)</span>      curCopy.rand = cur.rand != <span class="hljs-keyword">null</span> ? cur.rand.next : <span class="hljs-keyword">null</span>;      cur = next;   &#125;   Node res = head.next;   cur = head;   <span class="hljs-comment">// split</span>   <span class="hljs-keyword">while</span> (cur != <span class="hljs-keyword">null</span>) &#123;      next = cur.next.next;      curCopy = cur.next;      cur.next = next;      curCopy.next = next != <span class="hljs-keyword">null</span> ? next.next : <span class="hljs-keyword">null</span>;      cur = next;   &#125;   <span class="hljs-keyword">return</span> res;&#125;</code></pre><p>  不能边设置边断链： <strong>如果后面指向前面，前面已经和自己的 ‘ 断连了，.next已经没有用</strong></p><h3 id="与约瑟夫环问题相同的噩梦（相交）"><a href="#与约瑟夫环问题相同的噩梦（相交）" class="headerlink" title="与约瑟夫环问题相同的噩梦（相交）"></a>与约瑟夫环问题相同的噩梦（相交）</h3><p>给定两个可能有环也可能无环的单链表，头节点head1和head2。请实现一个函数，如果两个链表相交，请返回相交的 第一个节点。如果不相交，返回null </p><p>相交就是地址共用相同部分！</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201208182234.png" alt="相交"></p><p>【要求】<br> <strong>如果两个链表长度之和为N，时间复杂度请达到O(N)，额外空间复杂度 请达到O(1)。</strong></p><blockquote><p>先设计 Node f(head) 返回 <strong>入环第一个结点</strong></p></blockquote><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201208182419.png" alt="入环结点" style="zoom:50%;" /><p>如果整个是环，就是head</p><p> <strong>一个链表只有一个next指针，进了环，是不能出来的。</strong></p><p>可以用set<Node> 先查有没有在set里，查到第一个在的就是入环结点，没有环一定走到空上。</p><ul><li><p>不用set:</p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201208183357.png" alt="流程" style="zoom:50%;" /><p>一开始slow和fast指针从head开始出发，slow走一步，fast走两步；</p><p>一直这样走下去，slow和fast一定会在同一个地方，当到达同一个地方时： <strong>证明一定有环</strong></p><p>slow不变位置，fast回到开头，fast变成一次走一步，slow也继续一次走一步，</p><p>当slow和fast再次相交时，这个点就是 <strong>第一个入环点</strong>。</p><p>code：</p><pre><code class="hljs java"><span class="hljs-comment">// 找到链表第一个入环节点，如果无环，返回null</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">getLoopNode</span><span class="hljs-params">(Node head)</span> </span>&#123;   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span> || head.next == <span class="hljs-keyword">null</span> || head.next.next == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;   &#125;   <span class="hljs-comment">// n1 慢  n2 快</span>   Node n1 = head.next; <span class="hljs-comment">// n1 -&gt; slow</span>   Node n2 = head.next.next; <span class="hljs-comment">// n2 -&gt; fast</span>   <span class="hljs-keyword">while</span> (n1 != n2) &#123;      <span class="hljs-keyword">if</span> (n2.next == <span class="hljs-keyword">null</span> || n2.next.next == <span class="hljs-keyword">null</span>) &#123;         <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;      &#125;      n2 = n2.next.next;      n1 = n1.next;   &#125;   n2 = head; <span class="hljs-comment">// n2 -&gt; walk again from head</span>   <span class="hljs-keyword">while</span> (n1 != n2) &#123;      n1 = n1.next;      n2 = n2.next;   &#125;   <span class="hljs-keyword">return</span> n1;&#125;</code></pre></li></ul><blockquote><p>问题解决</p></blockquote><ol><li>如果 <strong>两个无环链表相交</strong>，相交后为全部相交部分。</li></ol><ul><li><p>用set</p><p>把一个链表全部注册进去，对第二个链表逐步遍历直到找到第一个相交。</p></li><li><p>不用set</p><p>假设第一个链表100个，第二个链表80个，两个都找到其最后一个结点（即下一个结点为null的结点），分别为end1和end2。</p><ul><li>判断 end1 是否等于 end2 ，如果不等于， 不相交。</li><li>如果 end1 等于 end2， 链表1走（100-80）= 20步，从这里开始链表二也开始走，两个链表肯定会走到第一个相遇的地方。</li></ul><p>Code:</p><pre><code class="hljs java"><span class="hljs-comment">// 如果两个链表都无环，返回第一个相交节点，如果不想交，返回null</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">noLoop</span><span class="hljs-params">(Node head1, Node head2)</span> </span>&#123;   <span class="hljs-keyword">if</span> (head1 == <span class="hljs-keyword">null</span> || head2 == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;   &#125;   Node cur1 = head1;   Node cur2 = head2;   <span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>;   <span class="hljs-keyword">while</span> (cur1.next != <span class="hljs-keyword">null</span>) &#123;      n++;      cur1 = cur1.next;   &#125;   <span class="hljs-keyword">while</span> (cur2.next != <span class="hljs-keyword">null</span>) &#123;      n--;      cur2 = cur2.next;   &#125;   <span class="hljs-comment">// n = cur1.len - cur2.len</span>   <span class="hljs-keyword">if</span> (cur1 != cur2) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;   &#125;   <span class="hljs-comment">// n  :  链表1长度减去链表2长度的值</span>   cur1 = n &gt; <span class="hljs-number">0</span> ? head1 : head2; <span class="hljs-comment">// 谁长，谁的头变成cur1</span>   cur2 = cur1 == head1 ? head2 : head1; <span class="hljs-comment">// 谁短，谁的头变成cur2</span>   n = Math.abs(n);   <span class="hljs-comment">// 长链表先走</span>   <span class="hljs-keyword">while</span> (n != <span class="hljs-number">0</span>) &#123;      n--;      cur1 = cur1.next;   &#125;   <span class="hljs-comment">// 一起走 走到相交点</span>   <span class="hljs-keyword">while</span> (cur1 != cur2) &#123;      cur1 = cur1.next;      cur2 = cur2.next;   &#125;   <span class="hljs-keyword">return</span> cur1;&#125;</code></pre></li></ul><ol start="2"><li>如果 <strong>两个有环链表相交</strong>，一定是 <strong>共用这个环的</strong></li></ol><p>​ <img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201208190644.png" alt="三种情况"></p><ul><li>没有相交部分<ul><li>让loop1往下走，如果在 <strong>遇见自己之前一直没碰到loop2</strong>。</li></ul></li><li>入环结点相同<ul><li>loop1和loop2不等于空且相同</li><li>不用再看环，把入环点作为尾结点，就变成了两个无环单链表相交问题</li></ul></li><li>入环结点不同<ul><li> 让loop1往下走，如果在 <strong>遇见自己之前一直碰到了loop2</strong>。</li></ul></li></ul><ol start="3"><li>如果 <strong>一个有环一个无环</strong>， <strong>不可能相交</strong>。</li></ol><p>​ 因为是单链表。</p><pre><code class="hljs java"><span class="hljs-comment">// 两个有环链表，返回第一个相交节点，如果不想交返回null</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">bothLoop</span><span class="hljs-params">(Node head1, Node loop1, Node head2, Node loop2)</span> </span>&#123;   Node cur1 = <span class="hljs-keyword">null</span>;   Node cur2 = <span class="hljs-keyword">null</span>;   <span class="hljs-keyword">if</span> (loop1 == loop2) &#123;      <span class="hljs-comment">// 解决无环问题，只不过end变为loop</span>      cur1 = head1;      cur2 = head2;      <span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>;      <span class="hljs-keyword">while</span> (cur1 != loop1) &#123;         n++;         cur1 = cur1.next;      &#125;      <span class="hljs-keyword">while</span> (cur2 != loop2) &#123;         n--;         cur2 = cur2.next;      &#125;      cur1 = n &gt; <span class="hljs-number">0</span> ? head1 : head2;      cur2 = cur1 == head1 ? head2 : head1;      n = Math.abs(n);      <span class="hljs-keyword">while</span> (n != <span class="hljs-number">0</span>) &#123;         n--;         cur1 = cur1.next;      &#125;      <span class="hljs-keyword">while</span> (cur1 != cur2) &#123;         cur1 = cur1.next;         cur2 = cur2.next;      &#125;      <span class="hljs-keyword">return</span> cur1;   &#125; <span class="hljs-keyword">else</span> &#123;      cur1 = loop1.next;      <span class="hljs-keyword">while</span> (cur1 != loop1) &#123;         <span class="hljs-keyword">if</span> (cur1 == loop2) &#123;            <span class="hljs-keyword">return</span> loop1;         &#125;         cur1 = cur1.next;      &#125;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;   &#125;&#125;</code></pre><p>最后总结：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">getIntersectNode</span><span class="hljs-params">(Node head1, Node head2)</span> </span>&#123;   <span class="hljs-keyword">if</span> (head1 == <span class="hljs-keyword">null</span> || head2 == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;   &#125;   Node loop1 = getLoopNode(head1);   Node loop2 = getLoopNode(head2);   <span class="hljs-keyword">if</span> (loop1 == <span class="hljs-keyword">null</span> &amp;&amp; loop2 == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span> noLoop(head1, head2);   &#125;   <span class="hljs-keyword">if</span> (loop1 != <span class="hljs-keyword">null</span> &amp;&amp; loop2 != <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span> bothLoop(head1, loop1, head2, loop2);   &#125;   <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;</code></pre><h3 id="能不能不给单链表的头节点，只给想要删除的节点，就能做到在链表上把这个点删掉？"><a href="#能不能不给单链表的头节点，只给想要删除的节点，就能做到在链表上把这个点删掉？" class="headerlink" title="能不能不给单链表的头节点，只给想要删除的节点，就能做到在链表上把这个点删掉？"></a>能不能不给单链表的头节点，只给想要删除的节点，就能做到在链表上把这个点删掉？</h3><p>把下一个值赋给当前结点，当前结点跳到下下个。</p><p>1）但 <strong>实际上没有删除 “自己”，只是替代了内容！</strong></p><p>2）如果不再是简单的结点问题，而是服务器问题， <strong>拷贝</strong>会变成一件很困难的事情！</p><p>3） <strong>绝对无法删除链表最后一个结点的！</strong>没有办法改前一个结点的走向。NULL是一个特定系统区域，去调析构函数是没有用的！</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201208192831.png" alt="test代码"></p><blockquote><p>为什么不行？</p></blockquote><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201208192918.png" alt="原因"></p><p>c = null;只是让c没有指向Node(3), 但Node(2)还是指向Node(3)了！</p><h1 id="二叉树的基本算法"><a href="#二叉树的基本算法" class="headerlink" title="二叉树的基本算法"></a>二叉树的基本算法</h1><blockquote><p>结构描述：</p></blockquote><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;  V value;  Node left;  Node right;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> value;   <span class="hljs-keyword">public</span> Node left;   <span class="hljs-keyword">public</span> Node right;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v)</span> </span>&#123;      value = v;   &#125;&#125;</code></pre><h2 id="二叉树的先序、中序、后序遍历"><a href="#二叉树的先序、中序、后序遍历" class="headerlink" title="二叉树的先序、中序、后序遍历"></a>二叉树的先序、中序、后序遍历</h2><p>​ <img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201209164047.png" alt="如图"></p><ul><li><p>先序：任何子树的处理顺序都是，先头节点、再左子树、然后右子树</p><pre><code class="hljs java"><span class="hljs-comment">// 先序打印所有结点</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pre</span><span class="hljs-params">(Node head)</span> </span>&#123;   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span>;   &#125;   System.out.println(head.value);   pre(head.left);   pre(head.right);&#125;</code></pre><p>​ </p></li><li><p>中序：任何子树的处理顺序都是，先左子树、再头节点、然后右子树</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">in</span><span class="hljs-params">(Node head)</span> </span>&#123;   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span>;   &#125;   in(head.left);   System.out.println(head.value);   in(head.right);&#125;</code></pre></li></ul><ul><li><p>后序：任何子树的处理顺序都是，先左子树、再右子树、然后头节点</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pos</span><span class="hljs-params">(Node head)</span> </span>&#123;   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span>;   &#125;   pos(head.left);   pos(head.right);   System.out.println(head.value);&#125;</code></pre></li></ul><h3 id="递归的本质是-递归序"><a href="#递归的本质是-递归序" class="headerlink" title="递归的本质是  递归序"></a>递归的本质是  <strong>递归序</strong></h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201209170646.png" alt="流程"></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(Node head)</span> </span>&#123;   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span>;   &#125;   <span class="hljs-comment">// 先序</span>   f(head.left);   <span class="hljs-comment">// 中序</span>   f(head.right);   <span class="hljs-comment">// 后序</span>&#125;</code></pre><p>对于这样的代码，一定会 <strong>访问(返回)</strong> 三次：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201209170852.png" alt="每一个结点都会到达三次"></p><p>先序就是每一次第一次到达了就打印：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201209171028.png" alt="第一次到达打印就是先序"></p><p>先序，中序，后序只是 <strong>递归序的结果</strong>。</p><p>所以在树上做动态规划的前提就是 <strong>每一个结点都会到此，走左边再回来，走右边再回来。</strong></p><p>让一个东西来到 <strong>此地三次！</strong></p><ul><li>理解递归序</li><li>先序、中序、后序都可以在递归序的基础上加工出来</li><li>第一次到达一个节点就打印就是先序、第二次打印即中序、第三次即后序</li></ul><h3 id="非递归方式实现二叉树的先序、中序、后序遍历"><a href="#非递归方式实现二叉树的先序、中序、后序遍历" class="headerlink" title="非递归方式实现二叉树的先序、中序、后序遍历"></a>非递归方式实现二叉树的先序、中序、后序遍历</h3><ul><li><p>任何递归函数都可以改成非递归</p></li><li><p>非递归实现先序遍历</p><pre><code class="hljs java"><span class="hljs-comment">// 先序遍历</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pre</span><span class="hljs-params">(Node head)</span> </span>&#123;   System.out.print(<span class="hljs-string">&quot;pre-order: &quot;</span>);   <span class="hljs-keyword">if</span> (head != <span class="hljs-keyword">null</span>) &#123;      Stack&lt;Node&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;Node&gt;();      stack.add(head);      <span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;         head = stack.pop();         System.out.print(head.value + <span class="hljs-string">&quot; &quot;</span>);         <span class="hljs-keyword">if</span> (head.right != <span class="hljs-keyword">null</span>) &#123;            stack.push(head.right);         &#125;         <span class="hljs-keyword">if</span> (head.left != <span class="hljs-keyword">null</span>) &#123;            stack.push(head.left);         &#125;      &#125;   &#125;   System.out.println();&#125;</code></pre><ul><li><p>先放头结点，弹出就打印</p></li><li><p>弹出打印后，如果有右孩子，先压入右孩子</p></li><li><p>如果有左孩子，再压入右孩子</p></li><li><p>例如对上面的树，先压入1，弹出1，压入3、2，弹出2，压入5、4，弹出4，弹出5，弹出3，压入7、6，弹出6、7</p></li></ul></li></ul><ul><li><p>非递归实现后序遍历</p><ul><li><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201209172717.png" alt="流程与先序相反"></p></li><li><p> 如果上述，先压左再压入右， 头左右就会变成头右左，正好是后序的相反。</p></li></ul><p>Code:</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pos1</span><span class="hljs-params">(Node head)</span> </span>&#123;   System.out.print(<span class="hljs-string">&quot;pos-order: &quot;</span>);   <span class="hljs-keyword">if</span> (head != <span class="hljs-keyword">null</span>) &#123;      Stack&lt;Node&gt; s1 = <span class="hljs-keyword">new</span> Stack&lt;Node&gt;();      Stack&lt;Node&gt; s2 = <span class="hljs-keyword">new</span> Stack&lt;Node&gt;();      s1.push(head);      <span class="hljs-keyword">while</span> (!s1.isEmpty()) &#123;         head = s1.pop();         <span class="hljs-comment">// 转移到s2里面，先序这里是直接打印</span>         s2.push(head);         <span class="hljs-comment">// 先压左</span>         <span class="hljs-keyword">if</span> (head.left != <span class="hljs-keyword">null</span>) &#123;            s1.push(head.left);         &#125;         <span class="hljs-keyword">if</span> (head.right != <span class="hljs-keyword">null</span>) &#123;            s1.push(head.right);         &#125;      &#125;      <span class="hljs-keyword">while</span> (!s2.isEmpty()) &#123;         System.out.print(s2.pop().value + <span class="hljs-string">&quot; &quot;</span>);      &#125;   &#125;   System.out.println();&#125;</code></pre></li><li><p>非递归实现后序遍历（方法二）</p><ul><li><p>死亡代码</p></li><li><p>左边到最底下，弹出一个往上管右边，右边再找左边最底下，直到把左边处理完再处理右边再处理自己。</p></li></ul></li></ul>  <pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pos2</span><span class="hljs-params">(Node h)</span> </span>&#123;   System.out.print(<span class="hljs-string">&quot;pos-order: &quot;</span>);   <span class="hljs-keyword">if</span> (h != <span class="hljs-keyword">null</span>) &#123;      Stack&lt;Node&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;Node&gt;();      stack.push(h);      Node c = <span class="hljs-keyword">null</span>;      <span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;         c = stack.peek();         <span class="hljs-comment">// 左树没处理先处理左树</span>         <span class="hljs-keyword">if</span> (c.left != <span class="hljs-keyword">null</span> &amp;&amp; h != c.left &amp;&amp; h != c.right) &#123;            stack.push(c.left);         <span class="hljs-comment">// 右树没处理先处理右树</span>         &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c.right != <span class="hljs-keyword">null</span> &amp;&amp; h != c.right) &#123;            stack.push(c.right);         <span class="hljs-comment">// 该处理自己了</span>         &#125; <span class="hljs-keyword">else</span> &#123;            System.out.print(stack.pop().value + <span class="hljs-string">&quot; &quot;</span>);            <span class="hljs-comment">// h跟踪上次打印的结点</span>            h = c;         &#125;      &#125;   &#125;   System.out.println();&#125;</code></pre><ul><li><p>非递归实现中序遍历</p><ul><li><p>整条左边界依次入栈</p></li><li><p>第一条逻辑无法再命中，就弹出结点并打印，然后来到弹出结点的右树上继续执行条件一</p></li><li><p>如上面的树，左边界全入栈，栈顶 - &gt; 栈底以此为 4,2,1，不能再命中了，弹出4，来到4的右孩子且为Null，弹出2，来到2的右孩子且为5，压入5，弹出5，来到5的右孩子且为Null，弹出1，来到1的右孩子3，3、6依此入栈，弹出6，来到6的右孩子且为Null，弹出3，来到3的右孩子且为7，弹出7。</p><pre><code class="hljs java"><span class="hljs-comment">// 左头无限分解</span><span class="hljs-comment">// 左边左头分解，右边也左头分解</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">in</span><span class="hljs-params">(Node head)</span> </span>&#123;    System.out.print(<span class="hljs-string">&quot;in-order: &quot;</span>);    <span class="hljs-keyword">if</span> (head != <span class="hljs-keyword">null</span>) &#123;      Stack&lt;Node&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;Node&gt;();      <span class="hljs-keyword">while</span> (!stack.isEmpty() || head != <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-comment">// 把左边全压入</span>        <span class="hljs-keyword">if</span> (head != <span class="hljs-keyword">null</span>) &#123;          stack.push(head);          head = head.left;        &#125; <span class="hljs-keyword">else</span> &#123;          head = stack.pop();          System.out.print(head.value + <span class="hljs-string">&quot; &quot;</span>);          head = head.right;        &#125;      &#125;    &#125;    System.out.println();  &#125;</code></pre></li></ul></li></ul><h2 id="实现二叉树的按层遍历"><a href="#实现二叉树的按层遍历" class="headerlink" title="实现二叉树的按层遍历"></a>实现二叉树的按层遍历</h2><ul><li><p>其实就是 <strong>宽度优先遍历</strong> ，用 <strong>队列</strong></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">level</span><span class="hljs-params">(Node head)</span> </span>&#123;   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span>;   &#125;   Queue&lt;Node&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();   queue.add(head);   <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;      Node cur = queue.poll();      System.out.println(cur.value);      <span class="hljs-keyword">if</span> (cur.left != <span class="hljs-keyword">null</span>) &#123;         queue.add(cur.left);      &#125;      <span class="hljs-keyword">if</span> (cur.right != <span class="hljs-keyword">null</span>) &#123;         queue.add(cur.right);      &#125;   &#125;&#125;</code></pre><ul><li><p>先把头结点加入</p></li><li><p>开始循环，弹出打印，先加左再加右</p></li><li><p>1弹出，2、3进，2弹出，4、5进，3弹出，6、7进…..</p></li></ul></li></ul><h3 id="二叉树最大宽度"><a href="#二叉树最大宽度" class="headerlink" title="二叉树最大宽度"></a>二叉树最大宽度</h3><ul><li><p>可以通过设置 <strong>flag变量</strong> 的方式，来发现某一层的 <strong>结束</strong>（看题目）</p><p>如：找到二叉树最宽的一层，建议一个发现机制就行，发现结束就意味着开始。</p><pre><code class="hljs java"><span class="hljs-comment">// 寻找到二叉树最大宽度</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxWidthUseMap</span><span class="hljs-params">(Node head)</span> </span>&#123;   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;   &#125;   Queue&lt;Node&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();   queue.add(head);   <span class="hljs-comment">// key在哪一层</span>   HashMap&lt;Node, Integer&gt; levelMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();   levelMap.put(head, <span class="hljs-number">1</span>);   <span class="hljs-comment">// 当前正在统计哪一层的宽度</span>   <span class="hljs-keyword">int</span> curLevel = <span class="hljs-number">1</span>;   <span class="hljs-comment">// 当前正在统计层的宽度是多少</span>   <span class="hljs-keyword">int</span> curLevelNodes = <span class="hljs-number">0</span>; <span class="hljs-comment">// 一律规定出来的时候加，初始为0</span>   <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;   <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;      Node cur = queue.poll();      <span class="hljs-comment">// 当前层级别</span>      <span class="hljs-keyword">int</span> curNodeLevel = levelMap.get(cur);      <span class="hljs-keyword">if</span> (cur.left != <span class="hljs-keyword">null</span>) &#123;         levelMap.put(cur.left, curNodeLevel + <span class="hljs-number">1</span>);         queue.add(cur.left);      &#125;      <span class="hljs-keyword">if</span> (cur.right != <span class="hljs-keyword">null</span>) &#123;         levelMap.put(cur.right, curNodeLevel + <span class="hljs-number">1</span>);         queue.add(cur.right);      &#125;      <span class="hljs-keyword">if</span> (curNodeLevel == curLevel) &#123;         curLevelNodes++;      &#125; <span class="hljs-keyword">else</span> &#123;         max = Math.max(max, curLevelNodes);         curLevel++;         curLevelNodes = <span class="hljs-number">1</span>;      &#125;   &#125;   <span class="hljs-comment">// 最后一层没有出发max机制</span>   max = Math.max(max, curLevelNodes);   <span class="hljs-keyword">return</span> max;&#125;</code></pre><p>用map记录结点位置（每一个新层到来结算上一层的老层）</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201210083532.png" alt="流程"></p></li></ul><ul><li><p>不用map寻找最大宽度机制：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxWidthNoMap</span><span class="hljs-params">(Node head)</span> </span>&#123;   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;   &#125;   Queue&lt;Node&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();   queue.add(head);   <span class="hljs-comment">// 当前层最右结点是谁</span>   Node curEnd = head;   <span class="hljs-comment">// 如果有下一层，下一层最右结点是谁</span>   Node nextEnd = <span class="hljs-keyword">null</span>;   <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;   <span class="hljs-keyword">int</span> curLevelNodes = <span class="hljs-number">0</span>; <span class="hljs-comment">// 当前层结点数</span>   <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;      Node cur = queue.poll();      <span class="hljs-keyword">if</span> (cur.left != <span class="hljs-keyword">null</span>) &#123;         queue.add(cur.left);         nextEnd = cur.left;      &#125;      <span class="hljs-keyword">if</span> (cur.right != <span class="hljs-keyword">null</span>) &#123;         queue.add(cur.right);         nextEnd = cur.right;      &#125;      curLevelNodes++;      <span class="hljs-comment">// 当前层结点是否为当前层最右结点</span>      <span class="hljs-keyword">if</span> (cur == curEnd) &#123;         max = Math.max(max, curLevelNodes);         curLevelNodes = <span class="hljs-number">0</span>;         curEnd = nextEnd;      &#125;   &#125;</code></pre></li></ul><h2 id="二叉树的序列化和反序列化"><a href="#二叉树的序列化和反序列化" class="headerlink" title="二叉树的序列化和反序列化"></a>二叉树的序列化和反序列化</h2><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201210085559.png" alt="序列化"></p><h3 id="先序序列化"><a href="#先序序列化" class="headerlink" title="先序序列化"></a>先序序列化</h3><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Queue&lt;String&gt; <span class="hljs-title">preSerial</span><span class="hljs-params">(Node head)</span> </span>&#123;   Queue&lt;String&gt; ans = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();   pres(head, ans);   <span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pres</span><span class="hljs-params">(Node head, Queue&lt;String&gt; ans)</span> </span>&#123;   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;      ans.add(<span class="hljs-keyword">null</span>);   &#125; <span class="hljs-keyword">else</span> &#123;      ans.add(String.valueOf(head.value));      pres(head.left, ans);      pres(head.right, ans);   &#125;&#125;</code></pre><h3 id="已知序列化好的队列，还原树"><a href="#已知序列化好的队列，还原树" class="headerlink" title="已知序列化好的队列，还原树"></a>已知序列化好的队列，还原树</h3><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">buildByPreQueue</span><span class="hljs-params">(Queue&lt;String&gt; prelist)</span> </span>&#123;   <span class="hljs-keyword">if</span> (prelist == <span class="hljs-keyword">null</span> || prelist.size() == <span class="hljs-number">0</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;   &#125;   <span class="hljs-keyword">return</span> preb(prelist);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">preb</span><span class="hljs-params">(Queue&lt;String&gt; prelist)</span> </span>&#123;   String value = prelist.poll();   <span class="hljs-keyword">if</span> (value == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;   &#125;   Node head = <span class="hljs-keyword">new</span> Node(Integer.valueOf(value));   head.left = preb(prelist);   head.right = preb(prelist);   <span class="hljs-keyword">return</span> head;&#125;</code></pre><blockquote><p>中序、后序只需要改一下顺序就可以了</p></blockquote><h3 id="按层序列化"><a href="#按层序列化" class="headerlink" title="按层序列化"></a>按层序列化</h3><p>整体上就是 <strong>宽度优先遍历</strong></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Queue&lt;String&gt; <span class="hljs-title">levelSerial</span><span class="hljs-params">(Node head)</span> </span>&#123;   <span class="hljs-comment">// 序列化结果</span>   Queue&lt;String&gt; ans = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;      ans.add(<span class="hljs-keyword">null</span>);   &#125; <span class="hljs-keyword">else</span> &#123;      ans.add(String.valueOf(head.value));      Queue&lt;Node&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;Node&gt;();      queue.add(head);      <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;         head = queue.poll();         <span class="hljs-keyword">if</span> (head.left != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-comment">// 即序列化 也加队列</span>            ans.add(String.valueOf(head.left.value));            queue.add(head.left);         &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// 只序列化</span>            ans.add(<span class="hljs-keyword">null</span>);         &#125;         <span class="hljs-keyword">if</span> (head.right != <span class="hljs-keyword">null</span>) &#123;            ans.add(String.valueOf(head.right.value));            queue.add(head.right);         &#125; <span class="hljs-keyword">else</span> &#123;            ans.add(<span class="hljs-keyword">null</span>);         &#125;      &#125;   &#125;   <span class="hljs-keyword">return</span> ans;&#125;</code></pre><p>其实就是多了一个ans队列，把空补齐。层序遍历的时候只有一个queue，queue里面放的一定不为null，再弹出判断。序列化只是ans可以放null，自己另外准备的queue不放null进行层序遍历而已。</p><h3 id="按层反序列化"><a href="#按层反序列化" class="headerlink" title="按层反序列化"></a>按层反序列化</h3><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">buildByLevelQueue</span><span class="hljs-params">(Queue&lt;String&gt; levelList)</span> </span>&#123;   <span class="hljs-keyword">if</span> (levelList == <span class="hljs-keyword">null</span> || levelList.size() == <span class="hljs-number">0</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;   &#125;   Node head = generateNode(levelList.poll());   Queue&lt;Node&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;Node&gt;();   <span class="hljs-keyword">if</span> (head != <span class="hljs-keyword">null</span>) &#123;      queue.add(head);   &#125;   Node node = <span class="hljs-keyword">null</span>;   <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;      node = queue.poll();      node.left = generateNode(levelList.poll());      node.right = generateNode(levelList.poll());      <span class="hljs-keyword">if</span> (node.left != <span class="hljs-keyword">null</span>) &#123;         queue.add(node.left);      &#125;      <span class="hljs-keyword">if</span> (node.right != <span class="hljs-keyword">null</span>) &#123;         queue.add(node.right);      &#125;   &#125;   <span class="hljs-keyword">return</span> head;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">generateNode</span><span class="hljs-params">(String val)</span> </span>&#123;   <span class="hljs-keyword">if</span> (val == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;   &#125;   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Node(Integer.valueOf(val));&#125;</code></pre><h2 id="设计一种打印树的方式"><a href="#设计一种打印树的方式" class="headerlink" title="设计一种打印树的方式"></a>设计一种打印树的方式</h2><blockquote><p>如何设计一个打印整棵树的打印函数?</p></blockquote><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201211094340.png" alt="打印出来的效果"></p><p>Code:</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printTree</span><span class="hljs-params">(Node head)</span> </span>&#123;   System.out.println(<span class="hljs-string">&quot;Binary Tree:&quot;</span>);   printInOrder(head, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;H&quot;</span>, <span class="hljs-number">17</span>);   System.out.println();&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printInOrder</span><span class="hljs-params">(Node head, <span class="hljs-keyword">int</span> height, String to, <span class="hljs-keyword">int</span> len)</span> </span>&#123;   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span>;   &#125;   printInOrder(head.right, height + <span class="hljs-number">1</span>, <span class="hljs-string">&quot;v&quot;</span>, len);   String val = to + head.value + to;   <span class="hljs-keyword">int</span> lenM = val.length();   <span class="hljs-keyword">int</span> lenL = (len - lenM) / <span class="hljs-number">2</span>;   <span class="hljs-keyword">int</span> lenR = len - lenM - lenL;   val = getSpace(lenL) + val + getSpace(lenR);   System.out.println(getSpace(height * len) + val);   printInOrder(head.left, height + <span class="hljs-number">1</span>, <span class="hljs-string">&quot;^&quot;</span>, len);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getSpace</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;   String space = <span class="hljs-string">&quot; &quot;</span>;   StringBuffer buf = <span class="hljs-keyword">new</span> StringBuffer(<span class="hljs-string">&quot;&quot;</span>);   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; num; i++) &#123;      buf.append(space);   &#125;   <span class="hljs-keyword">return</span> buf.toString();&#125;</code></pre><p>思路：</p><p>要打印上面的树，实际上就是按照 <strong>右头左</strong> 的顺序打印。</p><p> <strong>printInOrder</strong> 函数就是先打印右边，再头，再左边。</p><p>对于每个要打印的当前头部：height表示高度，to标识二叉树左右子树分支关系或头结点关系，len表示当前数字占用的距离。中间的打印头过程其实就是对当前头结点“渲染”了一下而已。</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201211095016.png" alt="例子"></p><p>前面的空格数由层数决定，每个数字占17位，前后补气空格</p><h2 id="特殊二叉树返回该节点的后继节点"><a href="#特殊二叉树返回该节点的后继节点" class="headerlink" title="特殊二叉树返回该节点的后继节点"></a>特殊二叉树返回该节点的后继节点</h2><p>二叉树结构如下定义：</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;  V value;  Node left;  Node right;  Node parent;&#125;</code></pre><blockquote><p>后继结点定义</p></blockquote><p>后继结点是：<strong>中序遍历</strong> 中一个结点的下一个结点。 </p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201211095339.png" alt="后继结点"></p><ul><li><p>思路一</p><p>因为有parent结点，所以可以一直往上找，找到头结点。再根据头结点 <strong>中序遍历</strong> ，最后根据 <strong>中序遍历</strong> 的结果找后继结点。 <strong>时间复杂度为 O(N)</strong></p></li></ul><ul><li><p>思路二</p><ul><li><p>假设当前结点距离后继结点距离为k，此方法 <strong>时间复杂度为O(K)</strong></p></li><li><p>对于 <strong>有右子树</strong> 的结点，其 <strong>后继结点就是右子树最左结点</strong> 。</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201211095756.png" alt="有右树的情况"></p></li><li><p>对于 <strong>没有右子树</strong> 的结点，如果 <strong>我是我的父节点的右孩子</strong>  ，<strong>就一直往上找</strong> ，直到到达的结点为当前结点 <strong>父节点的左孩子</strong>，这个父节点就是后继结点。</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201211100108.png" alt="后继"></p></li><li><p>由此可以定义: 如果 <strong>结点a左子树上的最右结点(最后打印的结点)为b</strong> ，则a为b的后继结点。</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201211100308.png" alt="结论"></p></li><li><p>整棵树的最右结点的后继结点为空</p></li></ul><p>code:</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">getSuccessorNode</span><span class="hljs-params">(Node node)</span> </span>&#123;   <span class="hljs-keyword">if</span> (node == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span> node;   &#125;   <span class="hljs-keyword">if</span> (node.right != <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span> getLeftMost(node.right);   &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 无右子树</span>      Node parent = node.parent;      <span class="hljs-keyword">while</span> (parent != <span class="hljs-keyword">null</span> &amp;&amp; parent.left != node) &#123; <span class="hljs-comment">// 当前节点是其父亲节点右孩子</span>         node = parent;         parent = node.parent;      &#125;      <span class="hljs-keyword">return</span> parent;   &#125;&#125;<span class="hljs-comment">// 找最左边</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">getLeftMost</span><span class="hljs-params">(Node node)</span> </span>&#123;   <span class="hljs-keyword">if</span> (node == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span> node;   &#125;   <span class="hljs-keyword">while</span> (node.left != <span class="hljs-keyword">null</span>) &#123;      node = node.left;   &#125;   <span class="hljs-keyword">return</span> node;&#125;</code></pre></li></ul><h3 id="前驱结点"><a href="#前驱结点" class="headerlink" title="前驱结点"></a>前驱结点</h3><p>正好相反，先找有无左子树，如果有，找左子树最右结点。</p><p>如果没有左子树，如果当前结点为父节点的左孩子，一直往上直到当前结点为父节点的右孩子。</p><h2 id="折痕问题"><a href="#折痕问题" class="headerlink" title="折痕问题"></a>折痕问题</h2><p>请把一段纸条竖着放在桌子上，然后从纸条的下边向上方对折1次，压出折痕后展开。此时折痕是凹下去的，即折痕突起的方向指向纸条的背面。 如果从纸条的下边向上方连续对折2次，压出折痕后展开，此时有三条折痕，从上到下依次是下折痕、下折痕和上折痕。 </p><p>给定一个输入参数N，代表纸条都从下边向上方连续对折N次。 请从上到下打印所有折痕的方向。<br>例如:N=1时，打印: down N=2时，打印: down down up </p><ul><li>实际对折，会发现：每次对折都会在当前折痕前面加一个down，后面加一个up。</li></ul><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201211101348.png" alt="图解"></p><ul><li><p>所以实际上就是中序遍历</p><ul><li>如果用数组实现，N次折产生2的n次方-1个折痕，浪费空间。</li><li>新code:</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printAllFolds</span><span class="hljs-params">(<span class="hljs-keyword">int</span> N)</span> </span>&#123;   printProcess(<span class="hljs-number">1</span>, N, <span class="hljs-keyword">true</span>);&#125;<span class="hljs-comment">// 递归过程，来到了某一个节点，</span><span class="hljs-comment">// i是节点的层数，N一共的层数，down == true  凹    down == false 凸</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printProcess</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> N, <span class="hljs-keyword">boolean</span> down)</span> </span>&#123;   <span class="hljs-keyword">if</span> (i &gt; N) &#123;      <span class="hljs-keyword">return</span>;   &#125;   printProcess(i + <span class="hljs-number">1</span>, N, <span class="hljs-keyword">true</span>);   System.out.println(down ? <span class="hljs-string">&quot;凹 &quot;</span> : <span class="hljs-string">&quot;凸 &quot;</span>);   printProcess(i + <span class="hljs-number">1</span>, N, <span class="hljs-keyword">false</span>);&#125;</code></pre><ul><li>空间复杂度 O(N) 创建了N个i</li></ul><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201211101703.png" alt="流程"></p></li></ul><h1 id="二叉树的递归套路"><a href="#二叉树的递归套路" class="headerlink" title="二叉树的递归套路"></a>二叉树的递归套路</h1><blockquote><p>本质是利用递归遍历二叉树的 <strong>便利性</strong> (会到每个结点 <strong>3次</strong> )</p></blockquote><p>潜意识：任何结点x为头的树，可以得到 <strong>左右子树信息</strong> ，并利用此信息求解过程。</p><p>1）假设以X节点为头，假设可以向X左树和X右树要任何信息</p><p>2）在上一步的假设下，讨论以X为头节点的树，得到答案的可能性（最重要）</p><p>3）列出所有可能性后，确定到底需要向左树和右树要什么样的信息</p><p>3）列出所有可能性后，确定到底需要向左树和右树要什么样的信息</p><p>4）把左树信息和右树信息求全集，就是任何一棵子树都需要返回的信息S</p><p>5）递归函数都返回S，每一棵子树都这么要求</p><p>6）写代码，在代码中考虑如何把左树的信息和右树信息整合出整棵树的信</p><h2 id="给定一棵二叉树的头节点head，返回这颗二叉树是不是平衡二叉树"><a href="#给定一棵二叉树的头节点head，返回这颗二叉树是不是平衡二叉树" class="headerlink" title="给定一棵二叉树的头节点head，返回这颗二叉树是不是平衡二叉树"></a>给定一棵二叉树的头节点head，返回这颗二叉树是不是平衡二叉树</h2><p>二叉树中每一颗子树，左数的 <strong>高度差</strong> 与右树的高度差不超过 1。</p><ol><li>左树平衡 2) 右树平衡 3) 左右树高度差不大于一            <strong>|左高 - 右高| &lt; 2</strong></li></ol><p>在能确定获取子树信息情况下列出可能性：要的信息： <strong>是否平衡， 高度多少</strong></p><p>求解过程就变成如何返回信息的过程：</p><p>平衡树info：</p><pre><code class="hljs java"><span class="hljs-comment">// 左树和右树要求一样的</span><span class="hljs-comment">// 信息返回的结构体</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Info</span> </span>&#123;   <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> isBalaced;   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> height;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Info</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> b, <span class="hljs-keyword">int</span> h)</span> </span>&#123;      isBalaced = b;      height = h;   &#125;&#125;</code></pre><p>code:</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isBalanced2</span><span class="hljs-params">(Node head)</span> </span>&#123;   <span class="hljs-keyword">return</span> process2(head).isBalaced;&#125;<span class="hljs-comment">// 左树和右树要求一样的</span><span class="hljs-comment">// 信息返回的结构体</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Info</span> </span>&#123;   <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> isBalaced;   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> height;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Info</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> b, <span class="hljs-keyword">int</span> h)</span> </span>&#123;      isBalaced = b;      height = h;   &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Info <span class="hljs-title">process2</span><span class="hljs-params">(Node head)</span> </span>&#123;   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Info(<span class="hljs-keyword">true</span>, <span class="hljs-number">0</span>);   &#125;   Info leftInfo = process2(head.left);   Info rightInfo = process2(head.right);   <span class="hljs-keyword">int</span> height = Math.max(leftInfo.height, rightInfo.height) + <span class="hljs-number">1</span>;   <span class="hljs-keyword">boolean</span> isBalanced = <span class="hljs-keyword">true</span>;   <span class="hljs-keyword">if</span> (!leftInfo.isBalaced || !rightInfo.isBalaced || Math.abs(leftInfo.height - rightInfo.height) &gt; <span class="hljs-number">1</span>) &#123;      isBalanced = <span class="hljs-keyword">false</span>;   &#125;   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Info(isBalanced, height);&#125;</code></pre><h2 id="给定一棵二叉树的头节点head，任何两个节点之间都存在距离，返回整棵二叉树的最大距离"><a href="#给定一棵二叉树的头节点head，任何两个节点之间都存在距离，返回整棵二叉树的最大距离" class="headerlink" title="给定一棵二叉树的头节点head，任何两个节点之间都存在距离，返回整棵二叉树的最大距离"></a>给定一棵二叉树的头节点head，任何两个节点之间都存在距离，返回整棵二叉树的最大距离</h2><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201211104832.png" alt="距离"></p><p>最大距离不是最左到最后！</p><ul><li>与x无关时，不跨过x，要么是左树最大距离，要么是右树最大距离。</li></ul><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201211105433.png" alt="最大距离与x无关"></p><ul><li><p>与x有关时，最大距离会通过x，x左树上离他最远的点走到右树上离他最远的点，也就是左边高度，加自己一步，加右边高度。</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201211105622.png" alt="有关"></p></li></ul><blockquote><p>所以info就需要包含 <strong>最大距离 和 高度</strong></p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Info</span> </span>&#123;   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> maxDistance;   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> height;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Info</span><span class="hljs-params">(<span class="hljs-keyword">int</span> dis, <span class="hljs-keyword">int</span> h)</span> </span>&#123;      maxDistance = dis;      height = h;   &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Info <span class="hljs-title">process</span><span class="hljs-params">(Node head)</span> </span>&#123;   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Info(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);   &#125;   Info leftInfo = process(head.left);   Info rightInfo = process(head.right);   <span class="hljs-keyword">int</span> height = Math.max(leftInfo.height, rightInfo.height) + <span class="hljs-number">1</span>;   <span class="hljs-comment">// 返回的 (左子树和右子树最大距离)和(左子树高加上右子树高)的最大值</span>   <span class="hljs-comment">// 距离只可能为左子树最大距离或者右子树最大距离或者左子树高度加上右子树高度</span>   <span class="hljs-keyword">int</span> maxDistance = Math.max(Math.max(leftInfo.maxDistance, rightInfo.maxDistance),         leftInfo.height + rightInfo.height + <span class="hljs-number">1</span>);   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Info(maxDistance, height);&#125;</code></pre><h2 id="给定一棵二叉树的头节点head，返回这颗二叉树中最大的二叉搜索子树的大小（结点的个数）"><a href="#给定一棵二叉树的头节点head，返回这颗二叉树中最大的二叉搜索子树的大小（结点的个数）" class="headerlink" title="给定一棵二叉树的头节点head，返回这颗二叉树中最大的二叉搜索子树的大小（结点的个数）"></a>给定一棵二叉树的头节点head，返回这颗二叉树中最大的二叉搜索子树的大小（结点的个数）</h2><p>搜索二叉树：整个树上没有重复值，左树值都小于父，右树值都大于父</p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201211112015.png" alt="搜索二叉" style="zoom:50%;" /><ul><li><p>与x无关，就可能为左边子树或者右边子树</p></li><li><p>与x有关，三个条件，左树整体是搜索二叉树，右树整体是搜索二叉树，左树最大值小于x，右树最大值大于x</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201211113138.png" alt="条件"></p></li></ul><ul><li>左树信息就变成<ul><li>左边最大子搜索树大小</li><li>是否为最大子搜索树</li><li>左树最大值</li></ul></li><li>右树信息就变成<ul><li>右边最大子搜索树大小</li><li>是否为最大子搜索树</li><li>右树最小值</li></ul></li></ul><blockquote><p>就要用到合并左右树信息</p></blockquote><pre><code class="hljs java"><span class="hljs-comment">// 对于任何子树都返回四个信息</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Info</span> </span>&#123;   <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> isBST;   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> maxSubBSTSize;   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> min;   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> max;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Info</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> is, <span class="hljs-keyword">int</span> size, <span class="hljs-keyword">int</span> mi, <span class="hljs-keyword">int</span> ma)</span> </span>&#123;      isBST = is;      maxSubBSTSize = size;      min = mi;      max = ma;   &#125;&#125;</code></pre><p>算法code：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Info <span class="hljs-title">process</span><span class="hljs-params">(Node head)</span> </span>&#123;   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;   &#125;   Info leftInfo = process(head.left);   Info rightInfo = process(head.right);   <span class="hljs-keyword">int</span> min = head.value;   <span class="hljs-keyword">int</span> max = head.value;   <span class="hljs-keyword">int</span> maxSubBSTSize = <span class="hljs-number">0</span>;   <span class="hljs-keyword">if</span> (leftInfo != <span class="hljs-keyword">null</span>) &#123;      min = Math.min(min, leftInfo.min);      max = Math.max(max, leftInfo.max);      maxSubBSTSize = Math.max(maxSubBSTSize, leftInfo.maxSubBSTSize);   &#125;   <span class="hljs-keyword">if</span> (rightInfo != <span class="hljs-keyword">null</span>) &#123;      min = Math.min(min, rightInfo.min);      max = Math.max(max, rightInfo.max);      maxSubBSTSize = Math.max(maxSubBSTSize, rightInfo.maxSubBSTSize);   &#125;   <span class="hljs-keyword">boolean</span> isBST = <span class="hljs-keyword">false</span>;   <span class="hljs-comment">// 左树是搜索二叉树</span>   <span class="hljs-comment">// 右树也是搜索二叉树</span>   <span class="hljs-comment">// 左边max小于x，右边min大于x</span>   <span class="hljs-keyword">if</span> ((leftInfo == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">true</span> : (leftInfo.isBST &amp;&amp; leftInfo.max &lt; head.value))         &amp;&amp; (rightInfo == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">true</span> : (rightInfo.isBST &amp;&amp; rightInfo.min &gt; head.value))) &#123;      isBST = <span class="hljs-keyword">true</span>;      maxSubBSTSize = (leftInfo == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : leftInfo.maxSubBSTSize)            + (rightInfo == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : rightInfo.maxSubBSTSize) + <span class="hljs-number">1</span>;   &#125;   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Info(isBST, maxSubBSTSize, min, max);&#125;</code></pre><p>代码等价：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201213132931.png" alt="code"></p><h2 id="派对的最大快乐值"><a href="#派对的最大快乐值" class="headerlink" title="派对的最大快乐值"></a>派对的最大快乐值</h2><p>员工信息的定义如下:</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> happy; <span class="hljs-comment">// 这名员工可以带来的快乐值</span>    List&lt;Employee&gt; subordinates; <span class="hljs-comment">// 这名员工有哪些直接下级</span>&#125;</code></pre><p>多叉树！</p><p>​   公司的每个员工都符合 Employee 类的描述。整个公司的人员结构可以看作是一棵标准的、 没有环的多叉树。树的头节点是公司唯一的老板。除老板之外的每个员工都有唯一的直接上级。 叶节点是没有任何下属的基层员工(subordinates列表为空)，除基层员工外，每个员工都有一个或多个直接下级。</p><p>这个公司现在要办party，你可以决定哪些员工来，哪些员工不来，规则：</p><ul><li>如果某个员工来了，那么这个 员工的所有直接下级都不能来</li><li>派对的整体快乐值是所有到场员工快乐值的累加</li><li>你的目标是让派对的整体快乐值尽量大</li><li>给定一棵多叉树的头节点boss，请返回派对的最大快乐值。</li></ul><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201213134214.png" alt="情况分类"></p><ol><li><p>如果x来，则x的happy，a不来情况下整棵树的最大值，b不来情况下整棵树的最大值，c不来情况下整棵树的最大值</p></li><li><p>如果x不来，a、b、c不一定会发，应该求Max(a来情况下整棵树最大值，a不来情况下整棵树最大值)</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201213134923.png" alt="x不来情况"></p></li><li><p>比较第一种和第二种情况</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Info</span> </span>&#123;   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> yes; <span class="hljs-comment">// 头结点来情况下整棵树最大值</span>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> no; <span class="hljs-comment">// 头结点不来情况下整棵树最大值</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Info</span><span class="hljs-params">(<span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> n)</span> </span>&#123;      yes = y;      no = n;   &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Info <span class="hljs-title">process2</span><span class="hljs-params">(Employee x)</span> </span>&#123;   <span class="hljs-keyword">if</span> (x.nexts.isEmpty()) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Info(x.happy, <span class="hljs-number">0</span>);   &#125;   <span class="hljs-keyword">int</span> yes = x.happy;   <span class="hljs-keyword">int</span> no = <span class="hljs-number">0</span>;   <span class="hljs-keyword">for</span> (Employee next : x.nexts) &#123;     <span class="hljs-comment">// 遍历孩子</span>      Info nextInfo = process2(next);     <span class="hljs-comment">// 父亲来的值加上子不来</span>      yes += nextInfo.no;     <span class="hljs-comment">// 父亲不来值加上子来或不来最大值</span>      no += Math.max(nextInfo.yes, nextInfo.no);   &#125;   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Info(yes, no);&#125;</code></pre></li></ol><h2 id="给定一棵二叉树的头节点head，返回这颗二叉树是不是满二叉树"><a href="#给定一棵二叉树的头节点head，返回这颗二叉树是不是满二叉树" class="headerlink" title="给定一棵二叉树的头节点head，返回这颗二叉树是不是满二叉树"></a>给定一棵二叉树的头节点head，返回这颗二叉树是不是满二叉树</h2><blockquote><p>2^L - 1 = N</p></blockquote><p>找出一棵树的高度和结点个数，组成info。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Info</span> </span>&#123;   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> height; <span class="hljs-comment">// L</span>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> nodes; <span class="hljs-comment">// N</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Info</span><span class="hljs-params">(<span class="hljs-keyword">int</span> h, <span class="hljs-keyword">int</span> n)</span> </span>&#123;      height = h;      nodes = n;   &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Info <span class="hljs-title">process</span><span class="hljs-params">(Node head)</span> </span>&#123;   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Info(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);   &#125;   Info leftInfo = process(head.left);   Info rightInfo = process(head.right);   <span class="hljs-keyword">int</span> height = Math.max(leftInfo.height, rightInfo.height) + <span class="hljs-number">1</span>;   <span class="hljs-keyword">int</span> nodes = leftInfo.nodes + rightInfo.nodes + <span class="hljs-number">1</span>;   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Info(height, nodes);&#125;</code></pre><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isFull2</span><span class="hljs-params">(Node head)</span> </span>&#123;   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;   &#125;   Info all = process(head);   <span class="hljs-keyword">return</span> (<span class="hljs-number">1</span> &lt;&lt; all.height) - <span class="hljs-number">1</span> == all.nodes;&#125;</code></pre><h2 id="给定一棵二叉树的头节点head，返回这颗二叉树是不是搜索二叉树"><a href="#给定一棵二叉树的头节点head，返回这颗二叉树是不是搜索二叉树" class="headerlink" title="给定一棵二叉树的头节点head，返回这颗二叉树是不是搜索二叉树"></a>给定一棵二叉树的头节点head，返回这颗二叉树是不是搜索二叉树</h2><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Info</span> </span>&#123;   <span class="hljs-keyword">boolean</span> isBST;   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> min;   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> max;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Info</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> is, <span class="hljs-keyword">int</span> mi, <span class="hljs-keyword">int</span> ma)</span> </span>&#123;      isBST = is;      min = mi;      max = ma;   &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Info <span class="hljs-title">process</span><span class="hljs-params">(Node head)</span> </span>&#123;   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;   &#125;   Info leftInfo = process(head.left);   Info rightInfo = process(head.right);   <span class="hljs-keyword">int</span> min = head.value;   <span class="hljs-keyword">int</span> max = head.value;   <span class="hljs-keyword">if</span> (leftInfo != <span class="hljs-keyword">null</span>) &#123;      min = Math.min(min, leftInfo.min);      max = Math.max(max, leftInfo.max);   &#125;   <span class="hljs-keyword">if</span> (rightInfo != <span class="hljs-keyword">null</span>) &#123;      min = Math.min(min, rightInfo.min);      max = Math.max(max, rightInfo.max);   &#125;   <span class="hljs-keyword">boolean</span> isBST = <span class="hljs-keyword">false</span>;   <span class="hljs-keyword">if</span> (      (leftInfo == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">true</span> : (leftInfo.isBST &amp;&amp; leftInfo.max &lt; head.value))      &amp;&amp;       (rightInfo == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">true</span> : (rightInfo.isBST &amp;&amp; rightInfo.min &gt; head.value))             ) &#123;      isBST = <span class="hljs-keyword">true</span>;   &#125;   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Info(isBST, min, max);&#125;</code></pre><h2 id="给定一棵二叉树的头节点head，返回这颗二叉树中最大的二叉搜索子树的头节点"><a href="#给定一棵二叉树的头节点head，返回这颗二叉树中最大的二叉搜索子树的头节点" class="headerlink" title="给定一棵二叉树的头节点head，返回这颗二叉树中最大的二叉搜索子树的头节点"></a>给定一棵二叉树的头节点head，返回这颗二叉树中最大的二叉搜索子树的头节点</h2><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Info</span> </span>&#123;  <span class="hljs-comment">// 最大二叉搜索子树的头结点</span>   <span class="hljs-keyword">public</span> Node maxSubBSTHead;   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> maxSubBSTSize;   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> min;   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> max;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Info</span><span class="hljs-params">(Node h, <span class="hljs-keyword">int</span> size, <span class="hljs-keyword">int</span> mi, <span class="hljs-keyword">int</span> ma)</span> </span>&#123;      maxSubBSTHead = h;      maxSubBSTSize = size;      min = mi;      max = ma;   &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Info <span class="hljs-title">process</span><span class="hljs-params">(Node head)</span> </span>&#123;   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;   &#125;   Info leftInfo = process(head.left);   Info rightInfo = process(head.right);   <span class="hljs-keyword">int</span> min = head.value;   <span class="hljs-keyword">int</span> max = head.value;   Node maxSubBSTHead = <span class="hljs-keyword">null</span>;   <span class="hljs-keyword">int</span> maxSubBSTSize = <span class="hljs-number">0</span>;   <span class="hljs-keyword">if</span> (leftInfo != <span class="hljs-keyword">null</span>) &#123;      min = Math.min(min, leftInfo.min);      max = Math.max(max, leftInfo.max);      maxSubBSTHead = leftInfo.maxSubBSTHead;      maxSubBSTSize = leftInfo.maxSubBSTSize;   &#125;   <span class="hljs-keyword">if</span> (rightInfo != <span class="hljs-keyword">null</span>) &#123;      min = Math.min(min, rightInfo.min);      max = Math.max(max, rightInfo.max);      <span class="hljs-keyword">if</span> (rightInfo.maxSubBSTSize &gt; maxSubBSTSize) &#123;         maxSubBSTHead = rightInfo.maxSubBSTHead;         maxSubBSTSize = rightInfo.maxSubBSTSize;      &#125;   &#125;   <span class="hljs-keyword">if</span> ((leftInfo == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">true</span> : (leftInfo.maxSubBSTHead == head.left &amp;&amp; leftInfo.max &lt; head.value))         &amp;&amp; (rightInfo == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">true</span> : (rightInfo.maxSubBSTHead == head.right &amp;&amp; rightInfo.min &gt; head.value))) &#123;      maxSubBSTHead = head;      maxSubBSTSize = (leftInfo == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : leftInfo.maxSubBSTSize)            + (rightInfo == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : rightInfo.maxSubBSTSize) + <span class="hljs-number">1</span>;   &#125;   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Info(maxSubBSTHead, maxSubBSTSize, min, max);&#125;</code></pre><h2 id="给定一棵二叉树的头节点head，返回这颗二叉树中是不是完全二叉树"><a href="#给定一棵二叉树的头节点head，返回这颗二叉树中是不是完全二叉树" class="headerlink" title="给定一棵二叉树的头节点head，返回这颗二叉树中是不是完全二叉树"></a>给定一棵二叉树的头节点head，返回这颗二叉树中是不是完全二叉树</h2><p>要么满，要么从左到右依次变慢。</p><p>基本解法：宽度优先遍历</p><p>Code1:</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isCBT1</span><span class="hljs-params">(Node head)</span> </span>&#123;   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;   &#125;   LinkedList&lt;Node&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();   <span class="hljs-comment">// 是否遇到过左右两个孩子不双全的节点</span>   <span class="hljs-keyword">boolean</span> leaf = <span class="hljs-keyword">false</span>;   Node l = <span class="hljs-keyword">null</span>;   Node r = <span class="hljs-keyword">null</span>;   queue.add(head);   <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;      head = queue.poll();      l = head.left;      r = head.right;      <span class="hljs-keyword">if</span> (      <span class="hljs-comment">// 如果遇到了不双全的节点之后，又发现当前节点不是叶节点</span>      (leaf &amp;&amp; !(l == <span class="hljs-keyword">null</span> &amp;&amp; r == <span class="hljs-keyword">null</span>)) || (l == <span class="hljs-keyword">null</span> &amp;&amp; r != <span class="hljs-keyword">null</span>)) &#123;         <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;      &#125;      <span class="hljs-keyword">if</span> (l != <span class="hljs-keyword">null</span>) &#123;         queue.add(l);      &#125;      <span class="hljs-keyword">if</span> (r != <span class="hljs-keyword">null</span>) &#123;         queue.add(r);      &#125;      <span class="hljs-keyword">if</span> (l == <span class="hljs-keyword">null</span> || r == <span class="hljs-keyword">null</span>) &#123;         leaf = <span class="hljs-keyword">true</span>;      &#125;   &#125;   <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;&#125;</code></pre><ol><li><p>任何结点有右无左，肯定不是。</p></li><li><p>否则继续，遇到第一个左右孩子不双全的结点，后续遇到的左右结点都必须是叶结点。</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201213164434.png" alt="流程"></p><p>条件2找到缺口，以下必须为叶子结点。</p></li></ol><p>Code2:</p><p>根据最后一个结点到哪了进行分类：</p><ol><li><p>满二叉树，无缺口 （左树满，右树满，高度一样）</p></li><li><p>有缺口，第一种缺口停左树 ，最后左边有（左完全二叉，右树满，左树高 - 右树高 = 1）</p></li><li><p>有缺口，左树填满，缺口还没到右边 （左树满，右树满，左树高度 - 右树高度 = 1）</p></li><li><p>有缺口，左树填满，右树最后左边有，（左树满，右树完全二叉， 左树高度 = 右树高度）</p></li></ol><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Info</span> </span>&#123;   <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> isFull;   <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> isCBT;   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> height;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Info</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> full, <span class="hljs-keyword">boolean</span> cbt, <span class="hljs-keyword">int</span> h)</span> </span>&#123;      isFull = full;      isCBT = cbt;      height = h;   &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Info <span class="hljs-title">process</span><span class="hljs-params">(Node head)</span> </span>&#123;   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Info(<span class="hljs-keyword">true</span>, <span class="hljs-keyword">true</span>, <span class="hljs-number">0</span>);   &#125;   Info leftInfo = process(head.left);   Info rightInfo = process(head.right);   <span class="hljs-keyword">int</span> height = Math.max(leftInfo.height, rightInfo.height) + <span class="hljs-number">1</span>;   <span class="hljs-keyword">boolean</span> isFull = leftInfo.isFull &amp;&amp; rightInfo.isFull &amp;&amp; leftInfo.height == rightInfo.height;   <span class="hljs-keyword">boolean</span> isCBT = <span class="hljs-keyword">false</span>;   <span class="hljs-keyword">if</span> (isFull) &#123;      isCBT = <span class="hljs-keyword">true</span>;   &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-keyword">if</span> (leftInfo.isCBT &amp;&amp; rightInfo.isCBT) &#123;         <span class="hljs-keyword">if</span> (leftInfo.isCBT &amp;&amp; rightInfo.isFull &amp;&amp; leftInfo.height == rightInfo.height + <span class="hljs-number">1</span>) &#123;            isCBT = <span class="hljs-keyword">true</span>;         &#125;         <span class="hljs-keyword">if</span> (leftInfo.isFull &amp;&amp; rightInfo.isFull &amp;&amp; leftInfo.height == rightInfo.height + <span class="hljs-number">1</span>) &#123;            isCBT = <span class="hljs-keyword">true</span>;         &#125;         <span class="hljs-keyword">if</span> (leftInfo.isFull &amp;&amp; rightInfo.isCBT &amp;&amp; leftInfo.height == rightInfo.height) &#123;            isCBT = <span class="hljs-keyword">true</span>;         &#125;      &#125;   &#125;   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Info(isFull, isCBT, height);&#125;</code></pre><h2 id="给定一棵二叉树的头节点head，和另外两个节点a和b。返回a和b的最低公共祖先"><a href="#给定一棵二叉树的头节点head，和另外两个节点a和b。返回a和b的最低公共祖先" class="headerlink" title="给定一棵二叉树的头节点head，和另外两个节点a和b。返回a和b的最低公共祖先"></a>给定一棵二叉树的头节点head，和另外两个节点a和b。返回a和b的最低公共祖先</h2><p>不用套路：整棵树遍历过程中 <strong>生成一张表</strong>，记录父节点。</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201213171301.png" alt="让Y往上找"></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">lowestAncestor1</span><span class="hljs-params">(Node head, Node o1, Node o2)</span> </span>&#123;   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;   &#125;   HashMap&lt;Node, Node&gt; parentMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();   parentMap.put(head, <span class="hljs-keyword">null</span>);   fillParentMap(head, parentMap);   HashSet&lt;Node&gt; o1Set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();   Node cur = o1;   o1Set.add(cur);   <span class="hljs-keyword">while</span> (parentMap.get(cur) != <span class="hljs-keyword">null</span>) &#123;      cur = parentMap.get(cur);      o1Set.add(cur);   &#125;   cur = o2;   <span class="hljs-keyword">while</span> (!o1Set.contains(cur)) &#123;      cur = parentMap.get(cur);   &#125;   <span class="hljs-keyword">return</span> cur;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fillParentMap</span><span class="hljs-params">(Node head, HashMap&lt;Node, Node&gt; parentMap)</span> </span>&#123;   <span class="hljs-keyword">if</span> (head.left != <span class="hljs-keyword">null</span>) &#123;      parentMap.put(head.left, head);      fillParentMap(head.left, parentMap);   &#125;   <span class="hljs-keyword">if</span> (head.right != <span class="hljs-keyword">null</span>) &#123;      parentMap.put(head.right, head);      fillParentMap(head.right, parentMap);   &#125;&#125;</code></pre><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201213171603.png" alt="流程" style="zoom:50%;" /><p>记录e以上都有谁，f网上找，第一个找到的就是。</p><p>套路：</p><ol><li><p>01, 02没有在x上</p></li><li><p>01, 02只有一个在x上</p></li><li><p>01, 02都在x为头的树上 A:左树右树各一个，B:左树或者右树包含全</p></li><li><p>01, 02有一个为x</p></li></ol><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Info</span> </span>&#123;   <span class="hljs-comment">// o1,o2最初交汇点</span>   <span class="hljs-keyword">public</span> Node ans;   <span class="hljs-comment">// 有无发现过o1</span>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> findO1;   <span class="hljs-comment">// 有无发现过o2</span>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> findO2;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Info</span><span class="hljs-params">(Node a, <span class="hljs-keyword">boolean</span> f1, <span class="hljs-keyword">boolean</span> f2)</span> </span>&#123;      ans = a;      findO1 = f1;      findO2 = f2;   &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Info <span class="hljs-title">process</span><span class="hljs-params">(Node head, Node o1, Node o2)</span> </span>&#123;   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Info(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>);   &#125;   Info leftInfo = process(head.left, o1, o2);   Info rightInfo = process(head.right, o1, o2);   <span class="hljs-keyword">boolean</span> findO1 = head == o1 || leftInfo.findO1 || rightInfo.findO1;   <span class="hljs-keyword">boolean</span> findO2 = head == o2 || leftInfo.findO2 || rightInfo.findO2;  <span class="hljs-comment">// 找交汇点</span>   Node ans = <span class="hljs-keyword">null</span>;  <span class="hljs-comment">// 左树提前交汇了</span>   <span class="hljs-keyword">if</span> (leftInfo.ans != <span class="hljs-keyword">null</span>) &#123;      ans = leftInfo.ans;   &#125;  <span class="hljs-comment">// 右树提前交汇了</span>   <span class="hljs-keyword">if</span> (rightInfo.ans != <span class="hljs-keyword">null</span>) &#123;      ans = rightInfo.ans;   &#125;  <span class="hljs-comment">// head为交汇点</span>   <span class="hljs-keyword">if</span> (ans == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">if</span> (findO1 &amp;&amp; findO2) &#123;         ans = head;      &#125;   &#125;   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Info(ans, findO1, findO2);&#125;</code></pre><h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><p>1）最 <strong>自然智慧</strong> 的算法</p><p>2）用一种局部最功利的标准，总是做出 <strong>在当前看来</strong> 是最好的选择</p><p>3）难点在于 <strong>证明局部最功利的标准可以得到全局最优解</strong></p><p>4）对于贪心算法的学习主要以增加阅历和经验为主</p><p> <strong>能得到最优解</strong> 的例子：一个数组中N个数，全是正数，第m个数 * arr[i] 得到分数，求分数最大最小。</p><p>​       排序后相乘就行了。</p><p> <strong>无法得到最优解</strong> 的例子：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201214075537.png" alt="例子"></p><p>贪心求解，每次拿最多数量的 1:</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201214075629.png" alt="错误解"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201214075705.png" alt="正确解"></p><h2 id="经典问题"><a href="#经典问题" class="headerlink" title="经典问题"></a>经典问题</h2><p>给定一个由字符串组成的 <strong>数组strs</strong> ，<br>必须把所有的字符串 <strong>拼接</strong> 起来，<br>返回所有可能的拼接结果中， <strong>字典序最小</strong>的结果</p><h3 id="字典序"><a href="#字典序" class="headerlink" title="字典序"></a>字典序</h3><blockquote><p>字典序</p></blockquote><ul><li>字符串长度一样认为字符串就是a-z的正数，即abc小于abk</li><li>字符串长度不一样时，短的补长，ac与b就是ac与b0，ac小于b</li></ul><p>java中compareTo方法就是比较字典序</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201214080633.png" alt="按照字符串本身字典序排序"></p><p>再由字典序小的拼接到大的，并不是对的。</p><p> <strong>错误例子</strong> :</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201214080809.png" alt="错误例子"></p><p>正确策略：</p><p>x拼接上y，对比y拼接上x的字典序</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201214081014.png" alt="正确策略"></p><p> <strong>例如[b, ba] bab &lt; bba 所以ba放前</strong></p><h3 id="排序的传递性"><a href="#排序的传递性" class="headerlink" title="排序的传递性"></a>排序的传递性</h3><blockquote><p>排序的传递序，定义的排序是否一定会具有传递性？</p></blockquote><p>不一定！</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201214081443.png" alt="没有传递性的例子"></p><p>这就如同 <strong>石头剪刀布</strong> 一样，甲乙对比，甲在前；….</p><p>如何证明刚才的排序是有传递性的？</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201214081633.png" alt="传递性"></p><p>a.b &lt;= b.a a前，排好序后，在数组中，任何一个位置前.后都 &lt;= 后.前</p><blockquote><p>证明</p></blockquote><p>假设认为字符为26位进制，拼接这件事就可以变为数学移位并相加的运算。</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201214082243.png" alt="移位并相加"></p><p>先认为字符串进位为函数m(b) 代表的意义为 K^b次方，b为字符串长度</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201214083309.png" alt="证明"></p><p>中间部分共同含有ac，减掉，再共同除以b，再移动减法位置得到：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201214083535.png" alt="结果"></p><p>所以这个排序策略是有传递性的。</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201214084002.png" alt="数学归纳法"></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyComparator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparator</span>&lt;<span class="hljs-title">String</span>&gt; </span>&#123;   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(String a, String b)</span> </span>&#123;      <span class="hljs-keyword">return</span> (a + b).compareTo(b + a);   &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">lowestString2</span><span class="hljs-params">(String[] strs)</span> </span>&#123;   <span class="hljs-keyword">if</span> (strs == <span class="hljs-keyword">null</span> || strs.length == <span class="hljs-number">0</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;   &#125;   Arrays.sort(strs, <span class="hljs-keyword">new</span> MyComparator());   String res = <span class="hljs-string">&quot;&quot;</span>;   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; strs.length; i++) &#123;      res += strs[i];   &#125;   <span class="hljs-keyword">return</span> res;&#125;</code></pre><h2 id="贪心算法求解的标准过程"><a href="#贪心算法求解的标准过程" class="headerlink" title="贪心算法求解的标准过程"></a>贪心算法求解的标准过程</h2><p>1，分析业务</p><p>2，根据业务逻辑找到 <strong>不同的贪心策略</strong></p><p>3，对于能 <strong>举出反例</strong> 的策略直接跳过，不能举出反例的策略要证明有效性</p><p>这往往是特别困难的，要求数学能力很高且不具有统一的技巧性</p><h2 id="贪心算法的解题套路"><a href="#贪心算法的解题套路" class="headerlink" title="贪心算法的解题套路"></a>贪心算法的解题套路</h2><p>1，实现一个不依靠贪心策略的解法X，可以用最暴力的尝试</p><p>2，脑补出贪心策略A、贪心策略B、贪心策略C…</p><p>3，用解法X和对数器，用实验的方式得知哪个贪心策略正确 </p><p>4， **不要去纠结贪心策略的证明 **</p><h2 id="贪心算法的解题套路实战"><a href="#贪心算法的解题套路实战" class="headerlink" title="贪心算法的解题套路实战"></a>贪心算法的解题套路实战</h2><h3 id="会议室题"><a href="#会议室题" class="headerlink" title="会议室题"></a>会议室题</h3><p>一些项目要占用一个会议室宣讲，会议室不能同时容纳两个项目的宣讲。<br>给你每一个项目 <strong>开始的时间和结束的时间</strong><br>你来安排宣讲的日程，要求会议室进行的宣讲的场次最多。<br>返回最多的宣讲场次。 </p><p> <strong>按会议结束时间早来贪，安排一个，把不能安排的打X，安排其他的</strong></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">bestArrange2</span><span class="hljs-params">(Program[] programs)</span> </span>&#123;   Arrays.sort(programs, <span class="hljs-keyword">new</span> ProgramComparator());   <span class="hljs-keyword">int</span> timeLine = <span class="hljs-number">0</span>;   <span class="hljs-keyword">int</span> result = <span class="hljs-number">0</span>;   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; programs.length; i++) &#123;      <span class="hljs-keyword">if</span> (timeLine &lt;= programs[i].start) &#123;         result++;         timeLine = programs[i].end;      &#125;   &#125;   <span class="hljs-keyword">return</span> result;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProgramComparator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparator</span>&lt;<span class="hljs-title">Program</span>&gt; </span>&#123;   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Program o1, Program o2)</span> </span>&#123;      <span class="hljs-keyword">return</span> o1.end - o2.end;   &#125;&#125;</code></pre><h3 id="点灯问题"><a href="#点灯问题" class="headerlink" title="点灯问题"></a>点灯问题</h3><p>给定一个字符串str，只由‘X’和‘.’两种字符构成。<br> <strong>‘X’表示墙，不能放灯，也不需要点亮</strong><br> <strong>‘.’表示居民点，可以放灯，需要点亮</strong><br>如果灯放在i位置，可以让i-1，i和i+1三个位置被点亮<br>返回如果点亮str中所有需要点亮的位置，至少需要几盏灯</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201214143040.png" alt="贪心"></p><ul><li>i位置为x，跳下一个</li><li>i位置为点<ul><li>如果i+1为x，必须放，跳i+2</li><li>如果i+1为点，i+2为x，放一个，跳i+3</li><li>如果i+1为点，i+2为点，i+1放一个，跳i+3</li></ul></li></ul><p>总是在当前步做 <strong>最优决定</strong>。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minLight2</span><span class="hljs-params">(String road)</span> </span>&#123;   <span class="hljs-keyword">char</span>[] str = road.toCharArray();   <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;   <span class="hljs-keyword">int</span> light = <span class="hljs-number">0</span>;   <span class="hljs-keyword">while</span> (index &lt; str.length) &#123;      <span class="hljs-keyword">if</span> (str[index] == <span class="hljs-string">&#x27;X&#x27;</span>) &#123;         index++;      &#125; <span class="hljs-keyword">else</span> &#123;         light++;         <span class="hljs-keyword">if</span> (index + <span class="hljs-number">1</span> == str.length) &#123;            <span class="hljs-keyword">break</span>;         &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">if</span> (str[index + <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;X&#x27;</span>) &#123;               index = index + <span class="hljs-number">2</span>;            &#125; <span class="hljs-keyword">else</span> &#123;               index = index + <span class="hljs-number">3</span>;            &#125;         &#125;      &#125;   &#125;   <span class="hljs-keyword">return</span> light;&#125;</code></pre><h3 id="金块分割问题"><a href="#金块分割问题" class="headerlink" title="金块分割问题"></a>金块分割问题</h3><p>一块金条切成两半，是需要花费和长度数值一样的铜板的。<br>比如长度为20的金条，不管怎么切，都要花费20个铜板。 一群人想整分整块金条，怎么分最省铜板? </p><p>例如,给定数组{10,20,30}，代表一共三个人，整块金条长度为60，金条要分成10，20，30三个部分。</p><p>如果先把长度60的金条分成10和50，花费60; 再把长度50的金条分成20和30，花费50;一共花费110铜板。<br>但如果先把长度60的金条分成30和30，花费60;再把长度30金条分成10和20， 花费30;一共花费90铜板。<br>输入一个数组，返回分割的最小代价。 </p><blockquote><p>哈夫曼树</p></blockquote><p>堆和排序是贪心最常用手段</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201214145441.png" alt="堆 哈夫曼树"></p><p>合成哈夫曼树就是从小根堆里面取两个合并再加入小根堆再合并….</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lessMoney2</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;   PriorityQueue&lt;Integer&gt; pQ = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;();   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;      pQ.add(arr[i]);   &#125;   <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;   <span class="hljs-keyword">int</span> cur = <span class="hljs-number">0</span>;   <span class="hljs-keyword">while</span> (pQ.size() &gt; <span class="hljs-number">1</span>) &#123;      cur = pQ.poll() + pQ.poll();      sum += cur;      pQ.add(cur);   &#125;   <span class="hljs-keyword">return</span> sum;&#125;</code></pre><h3 id="项目利益问题"><a href="#项目利益问题" class="headerlink" title="项目利益问题"></a>项目利益问题</h3><p>输入: 正数数组costs、正数数组profits、正数K、正数M<br>costs[i]表示i号项目的 <strong>花费</strong><br>profits[i]表示i号项目在扣除花费之后还能 <strong>挣到的钱(利润)</strong><br>K表示你只能串行的最多做k个项目<br>M表示你初始的资金<br>说明: 每做完一个项目，马上获得的收益，可以支持你去做下一个项目。不能并行的做项目。<br>输出：你最后获得的最大钱数。 </p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201214150806.png" alt="解法"></p><ul><li>设置一个小根堆，按照花费排序，称为此时 <strong>被锁住的项目</strong></li><li>设置一个大根堆，按照利润排序，称为此事 <strong>被解锁的项目</strong></li><li>从小根堆里 <strong>弹出所有能被初始资金满足</strong> 的项目到大根堆，因为按照利润组织，挑选大根堆堆顶做。初始资金变为4。拿初始资金继续寻找小根堆里能满足的放入大根堆，挑选大根堆堆顶，改变资金…. </li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findMaximizedCapital</span><span class="hljs-params">(<span class="hljs-keyword">int</span> K, <span class="hljs-keyword">int</span> W, <span class="hljs-keyword">int</span>[] Profits, <span class="hljs-keyword">int</span>[] Capital)</span> </span>&#123;   PriorityQueue&lt;Program&gt; minCostQ = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;(<span class="hljs-keyword">new</span> MinCostComparator());   PriorityQueue&lt;Program&gt; maxProfitQ = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;(<span class="hljs-keyword">new</span> MaxProfitComparator());   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; Profits.length; i++) &#123;      minCostQ.add(<span class="hljs-keyword">new</span> Program(Profits[i], Capital[i]));   &#125;   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; K; i++) &#123;      <span class="hljs-keyword">while</span> (!minCostQ.isEmpty() &amp;&amp; minCostQ.peek().c &lt;= W) &#123;         maxProfitQ.add(minCostQ.poll());      &#125;      <span class="hljs-keyword">if</span> (maxProfitQ.isEmpty()) &#123;         <span class="hljs-keyword">return</span> W;      &#125;      W += maxProfitQ.poll().p;   &#125;   <span class="hljs-keyword">return</span> W;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span> </span>&#123;   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> p;   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> c;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Program</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> c)</span> </span>&#123;      <span class="hljs-keyword">this</span>.p = p;      <span class="hljs-keyword">this</span>.c = c;   &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MinCostComparator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparator</span>&lt;<span class="hljs-title">Program</span>&gt; </span>&#123;   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Program o1, Program o2)</span> </span>&#123;      <span class="hljs-keyword">return</span> o1.c - o2.c;   &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MaxProfitComparator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparator</span>&lt;<span class="hljs-title">Program</span>&gt; </span>&#123;   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Program o1, Program o2)</span> </span>&#123;      <span class="hljs-keyword">return</span> o2.p - o1.p;   &#125;&#125;</code></pre><p> <strong>暴力解贪心真的很折磨</strong> </p><h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><h2 id="并查集code"><a href="#并查集code" class="headerlink" title="并查集code"></a>并查集code</h2><ol><li>有若干个样本a、b、c、d…类型假设是V</li><li>在并查集中一开始认为每个样本都在 <strong>单独的集合</strong> 里用户可以在任何时候调用如下两个方法：<pre><code>    **boolean isSameSet(V x, V y)** : 查询样本x和样本y是否属于一个集合    **void union(V x, V y)** : 把x和y各自所在集合的所有样本合并成一个集合</code></pre></li><li> isSameSet和union方法的代价越低越好, 最好O(1)</li></ol><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201214153822.png" alt="代表点"></p><p>结果若干union后，代表点不一样，就不是一个集合</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201214153934.png" alt="union后"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201214154334.png" alt="union操作"></p><p> <strong>小数量挂大数量，数量相等无所谓</strong> </p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201214154455.png" alt="union操作完毕"></p><p>1）每个节点都有一条往上指的指针<br>2）节点a往上找到的头节点，叫做a所在集合的代表节点<br>3）查询x和y是否属于同一个集合，就是看看找到的代表节点是不是一个<br>4）把x和y各自所在集合的所有点合并成一个集合，只需要小集合的代表点挂在大集合的代表点的下方即可</p><p>code:</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">V</span>&gt; </span>&#123;   V value;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(V v)</span> </span>&#123;      value = v;   &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnionSet</span>&lt;<span class="hljs-title">V</span>&gt; </span>&#123;   <span class="hljs-comment">// V -&gt; 结点 一一对应，建好后不会改动，记录对应关系</span>   <span class="hljs-keyword">public</span> HashMap&lt;V, Node&lt;V&gt;&gt; nodes;   <span class="hljs-keyword">public</span> HashMap&lt;Node&lt;V&gt;, Node&lt;V&gt;&gt; parents;   <span class="hljs-comment">// 代表点才会有记录</span>   <span class="hljs-keyword">public</span> HashMap&lt;Node&lt;V&gt;, Integer&gt; sizeMap;   <span class="hljs-comment">// 初始化过程</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UnionSet</span><span class="hljs-params">(List&lt;V&gt; values)</span> </span>&#123;      <span class="hljs-keyword">for</span> (V value : values) &#123;         Node&lt;V&gt; node = <span class="hljs-keyword">new</span> Node&lt;&gt;(value);         nodes.put(value, node);         <span class="hljs-comment">// 一开始每个点都为代表点 指向自己</span>         parents.put(node, node);         sizeMap.put(node, <span class="hljs-number">1</span>);      &#125;   &#125;   <span class="hljs-comment">// 从cur开始找，找到不能再往上找的代表点并返回</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> Node&lt;V&gt; <span class="hljs-title">findFather</span><span class="hljs-params">(Node&lt;V&gt; cur)</span> </span>&#123;      Stack&lt;Node&lt;V&gt;&gt; path = <span class="hljs-keyword">new</span> Stack&lt;&gt;();      <span class="hljs-keyword">while</span> (cur != parents.get(cur)) &#123;         path.push(cur);         cur = parents.get(cur);      &#125;      <span class="hljs-comment">// cur头节点</span>      <span class="hljs-keyword">while</span> (!path.isEmpty()) &#123;         parents.put(path.pop(), cur);      &#125;      <span class="hljs-keyword">return</span> cur;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSameSet</span><span class="hljs-params">(V a, V b)</span> </span>&#123;      <span class="hljs-keyword">if</span> (!nodes.containsKey(a) || !nodes.containsKey(b)) &#123;         <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;      &#125;      <span class="hljs-keyword">return</span> findFather(nodes.get(a)) == findFather(nodes.get(b));   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">union</span><span class="hljs-params">(V a, V b)</span> </span>&#123;      <span class="hljs-keyword">if</span> (!nodes.containsKey(a) || !nodes.containsKey(b)) &#123;         <span class="hljs-keyword">return</span>;      &#125;      Node&lt;V&gt; aHead = findFather(nodes.get(a));      Node&lt;V&gt; bHead = findFather(nodes.get(b));      <span class="hljs-keyword">if</span> (aHead != bHead) &#123;         <span class="hljs-keyword">int</span> aSetSize = sizeMap.get(aHead);         <span class="hljs-keyword">int</span> bSetSize = sizeMap.get(bHead);         <span class="hljs-keyword">if</span> (aSetSize &gt;= bSetSize) &#123;            parents.put(bHead, aHead);            sizeMap.put(aHead, aSetSize + bSetSize);            sizeMap.remove(bHead);         &#125; <span class="hljs-keyword">else</span> &#123;            parents.put(aHead, bHead);            sizeMap.put(bHead, aSetSize + bSetSize);            sizeMap.remove(aHead);         &#125;      &#125;   &#125;&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201214155250.png" alt="parent表和size表"></p><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>1）节点往上找代表点的过程，把沿途的链变成扁平的</p><p>2）小集合挂在大集合的下面</p><p>3）如果方法调用很频繁，那么单次调用的代价为O(1)，两个方法都如此</p><p>findFather()方法的优化:</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201214160644.png" alt="打扁平"></p><p>将原来串联起来，改变成father全指向代表点</p><p>往上找的过程是该算法的瓶颈，让找的方法变为O(1)即可。</p><p>解释了为什么 <strong>小挂大</strong> ，也减少了 <strong>遍历链的高度</strong> </p><h2 id="复杂度计算"><a href="#复杂度计算" class="headerlink" title="复杂度计算"></a>复杂度计算</h2><p>N个结点 -&gt; N个集合</p><p>find <strong>方法越频繁，代价越低</strong>。</p><p>当调用次数到达 O(n)或超过，单次调用的代价为O(1)。</p><h2 id="题"><a href="#题" class="headerlink" title="题"></a>题</h2><p>学生类有三个String属性，身份证，b站id，githubid，任何一个属性有一组一样就算一个人。</p><p>一大堆实例中有几个独立出来的人。</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201214162132.png" alt="例子"></p><p>所有实例进并查集，准备三张表，记录三个字段拥有者</p><p>当表中key相同时，并查集合并这两个实例。</p><p>最后看sizeMap的数。</p><p> <strong>解决连通性的利器</strong> </p><h2 id="并查集的应用"><a href="#并查集的应用" class="headerlink" title="并查集的应用"></a>并查集的应用</h2><p>解决两大块区域的合并问题</p><p>常用在图等领域中</p><h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><blockquote><p>不难在算法，难在结构</p></blockquote><p>1）由点的集合和边的集合构成</p><p>2）虽然存在有向图和无向图的概念，但实际上都可以用有向图来表达，无向图可以想象两条有向边</p><p>3）边上可能带有权值</p><h2 id="图结构的表达"><a href="#图结构的表达" class="headerlink" title="图结构的表达"></a>图结构的表达</h2><p>1）邻接表法</p><p>2）邻接矩阵法</p><p>3）除此之外还有其他众多的方式</p><p>邻接表法：记录能直接到达的点</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201215085231.png" alt="邻接表法"></p><p>邻接矩阵法：abcd列行填格子</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201215085523.png" alt="邻接矩阵"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201215085839.png" alt="另外的表达"></p><h2 id="图的面试题如何搞定"><a href="#图的面试题如何搞定" class="headerlink" title="图的面试题如何搞定"></a>图的面试题如何搞定</h2><p>图的算法都不算难，只不过coding的代价比较高</p><p>1）先用 <strong>自己最熟练的方式</strong> ，实现图结构的表达</p><p>2）在自己熟悉的结构上， <strong>实现所有常用的图算法作为模板</strong></p><p>3）把面试题 <strong>提供的图结构转化为自己熟悉的图结构</strong> ，再调用模板或改写即可</p><pre><code class="hljs java"><span class="hljs-comment">// 点结构描述</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;   <span class="hljs-comment">// 编号</span>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> value;   <span class="hljs-comment">// 入度 多少个点直接连向</span>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> in;   <span class="hljs-comment">// 出度 多少个点直接出向</span>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> out;   <span class="hljs-comment">// 直接邻居</span>   <span class="hljs-keyword">public</span> ArrayList&lt;Node&gt; nexts;   <span class="hljs-comment">// 边</span>   <span class="hljs-keyword">public</span> ArrayList&lt;Edge&gt; edges;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;      <span class="hljs-keyword">this</span>.value = value;      in = <span class="hljs-number">0</span>;      out = <span class="hljs-number">0</span>;      nexts = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();      edges = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();   &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-comment">// 边描述 无向图只是from to相同</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Edge</span> </span>&#123;   <span class="hljs-comment">// 权重</span>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> weight;   <span class="hljs-keyword">public</span> Node from;   <span class="hljs-keyword">public</span> Node to;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Edge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> weight, Node from, Node to)</span> </span>&#123;      <span class="hljs-keyword">this</span>.weight = weight;      <span class="hljs-keyword">this</span>.from = from;      <span class="hljs-keyword">this</span>.to = to;   &#125;&#125;</code></pre><p>图结构就出来了：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Graph</span> </span>&#123;   <span class="hljs-comment">// Integer表示Node里面的value编号</span>   <span class="hljs-keyword">public</span> HashMap&lt;Integer, Node&gt; nodes;   <span class="hljs-keyword">public</span> HashSet&lt;Edge&gt; edges;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Graph</span><span class="hljs-params">()</span> </span>&#123;      nodes = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();      edges = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();   &#125;&#125;</code></pre><blockquote><p>结构转化为上述第三图中矩阵N*3的图结构</p></blockquote><pre><code class="hljs java"><span class="hljs-comment">// matrix 所有的边</span><span class="hljs-comment">// N*3 的矩阵</span><span class="hljs-comment">// [weight, from节点上面的值，to节点上面的值]</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Graph <span class="hljs-title">createGraph</span><span class="hljs-params">(Integer[][] matrix)</span> </span>&#123;   Graph graph = <span class="hljs-keyword">new</span> Graph();   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; matrix.length; i++) &#123; <span class="hljs-comment">// matrix[0][0], matrix[0][1]  matrix[0][2]</span>      Integer from = matrix[i][<span class="hljs-number">0</span>];      Integer to = matrix[i][<span class="hljs-number">1</span>];      Integer weight = matrix[i][<span class="hljs-number">2</span>];      <span class="hljs-keyword">if</span> (!graph.nodes.containsKey(from)) &#123;         graph.nodes.put(from, <span class="hljs-keyword">new</span> Node(from));      &#125;      <span class="hljs-keyword">if</span> (!graph.nodes.containsKey(to)) &#123;         graph.nodes.put(to, <span class="hljs-keyword">new</span> Node(to));      &#125;      Node fromNode = graph.nodes.get(from);      Node toNode = graph.nodes.get(to);      Edge newEdge = <span class="hljs-keyword">new</span> Edge(weight, fromNode, toNode);      fromNode.nexts.add(toNode);      fromNode.out++;      toNode.in++;      fromNode.edges.add(newEdge);      graph.edges.add(newEdge);   &#125;   <span class="hljs-keyword">return</span> graph;&#125;</code></pre><h2 id="图的宽度优先-amp-深度优先遍历"><a href="#图的宽度优先-amp-深度优先遍历" class="headerlink" title="图的宽度优先&amp;深度优先遍历"></a>图的宽度优先&amp;深度优先遍历</h2><p>宽度优先遍历 (同一层内部的顺序可以无所谓)<br>1，利用 <strong>队列</strong> 实现<br>2，从源节点开始依次按照宽度进队列，然后弹出<br>3，每弹出一个点，把该节点 <strong>所有没有进过队列的邻接点放入队列</strong><br>4，直到队列变空</p><pre><code class="hljs java"><span class="hljs-comment">// 从node出发，进行宽度优先遍历</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(Node node)</span> </span>&#123;   <span class="hljs-keyword">if</span> (node == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span>;   &#125;   Queue&lt;Node&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();   <span class="hljs-comment">// 图会有环的问题，二叉树没有</span>   HashSet&lt;Node&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();   queue.add(node);   set.add(node);   <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;      Node cur = queue.poll();      <span class="hljs-comment">// 出打印</span>      System.out.println(cur.value);      <span class="hljs-keyword">for</span> (Node next : cur.nexts) &#123;         <span class="hljs-keyword">if</span> (!set.contains(next)) &#123;            set.add(next);            queue.add(next);         &#125;      &#125;   &#125;&#125;</code></pre><p>深度优先遍历<br>1，利用 <strong>栈</strong> 实现<br>2，从源节点开始把节点按照深度放入栈，然后弹出<br>3，每弹出一个点，把该节点 <strong>下一个没有进过栈的邻接点放入栈</strong><br>4，直到栈变空 </p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(Node node)</span> </span>&#123;   <span class="hljs-keyword">if</span> (node == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span>;   &#125;   <span class="hljs-comment">// 记录从头结点走到的路径</span>   Stack&lt;Node&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();   HashSet&lt;Node&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();   stack.add(node);   set.add(node);   System.out.println(node.value);   <span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;      Node cur = stack.pop();      <span class="hljs-keyword">for</span> (Node next : cur.nexts) &#123;         <span class="hljs-keyword">if</span> (!set.contains(next)) &#123;            <span class="hljs-comment">// 一条路走到不能再走直接返回</span>            stack.push(cur);            stack.push(next);            set.add(next);            <span class="hljs-comment">// 进去的时候打印</span>            System.out.println(next.value);            <span class="hljs-keyword">break</span>;         &#125;      &#125;   &#125;&#125;</code></pre><h2 id="图的拓扑排序算法-有向无环图"><a href="#图的拓扑排序算法-有向无环图" class="headerlink" title="图的拓扑排序算法(有向无环图)"></a>图的拓扑排序算法(有向无环图)</h2><p>1）在图中找到 <strong>所有入度为0</strong> 的点输出<br>2）把所有入度为0的点在图中 <strong>删掉</strong> ，继续找入度为0的点输出，周而复始<br>3）图的所有点都被删除后，依次输出的顺序就是拓扑排序</p><p>要求： <strong>有向图且其中没有环</strong><br>应用： <strong>事件安排</strong> 、 <strong>编译顺序</strong></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201215103658.png" alt="拓扑"></p><p>a、b、c、e、f、t</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201215104648.png" alt="循环依赖与图关系"></p><p>ABC各有各自的config，最终会变成有向无环图，如果有环，就形成了循环依赖。</p><p>拓扑排序从最底层包往上编译，最终编译出来。</p><pre><code class="hljs java"><span class="hljs-comment">// directed graph and no loop</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Node&gt; <span class="hljs-title">sortedTopology</span><span class="hljs-params">(Graph graph)</span> </span>&#123;   <span class="hljs-comment">// key：某一个node</span>   <span class="hljs-comment">// value：剩余的入度</span>   HashMap&lt;Node, Integer&gt; inMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();   <span class="hljs-comment">// 入度为0的点，才能进这个队列</span>   Queue&lt;Node&gt; zeroInQueue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();   <span class="hljs-keyword">for</span> (Node node : graph.nodes.values()) &#123;      inMap.put(node, node.in);      <span class="hljs-comment">// 有向无环图，一定会有入度为0的点</span>      <span class="hljs-keyword">if</span> (node.in == <span class="hljs-number">0</span>) &#123;         zeroInQueue.add(node);      &#125;   &#125;   <span class="hljs-comment">// 拓扑排序的结果，依次加入result</span>   List&lt;Node&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();   <span class="hljs-keyword">while</span> (!zeroInQueue.isEmpty()) &#123;      Node cur = zeroInQueue.poll();      result.add(cur);      <span class="hljs-keyword">for</span> (Node next : cur.nexts) &#123;         inMap.put(next, inMap.get(next) - <span class="hljs-number">1</span>);         <span class="hljs-keyword">if</span> (inMap.get(next) == <span class="hljs-number">0</span>) &#123;            zeroInQueue.add(next);         &#125;      &#125;   &#125;   <span class="hljs-keyword">return</span> result;&#125;</code></pre><h2 id="最小生成树算法之Kruskal"><a href="#最小生成树算法之Kruskal" class="headerlink" title="最小生成树算法之Kruskal"></a>最小生成树算法之Kruskal</h2><p>1）总是从 <strong>权值最小的边</strong> 开始考虑，依次考察权值依次变大的边<br>2）当前的边要么进入最小生成树的集合，要么丢弃<br>3）如果当前的边进入最小生成树的集合中不会形成环，就要当前边<br>4）如果当前的边进入最小生成树的集合中会形成环，就不要当前边<br>5）考察完所有边之后，最小生成树的集合也得到了</p><p>最小权值连通所有的点</p><p>流程：</p><p>所有的 <strong>边</strong> 根据 <strong>权值由小到大排序</strong> ，对边遍历，如果左右两头没有在同一个集合，union，如果在一个集合，淘汰。</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201215110718.png" alt="流程"></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Set&lt;Edge&gt; <span class="hljs-title">kruskalMST</span><span class="hljs-params">(Graph graph)</span> </span>&#123;   UnionFind unionFind = <span class="hljs-keyword">new</span> UnionFind();   unionFind.makeSets(graph.nodes.values());   PriorityQueue&lt;Edge&gt; priorityQueue = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;(<span class="hljs-keyword">new</span> EdgeComparator());   <span class="hljs-keyword">for</span> (Edge edge : graph.edges) &#123; <span class="hljs-comment">// M 条边</span>      priorityQueue.add(edge);  <span class="hljs-comment">// O(logM)</span>   &#125;   Set&lt;Edge&gt; result = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();   <span class="hljs-keyword">while</span> (!priorityQueue.isEmpty()) &#123; <span class="hljs-comment">// M 条边</span>      Edge edge = priorityQueue.poll(); <span class="hljs-comment">// O(logM)</span>      <span class="hljs-keyword">if</span> (!unionFind.isSameSet(edge.from, edge.to)) &#123; <span class="hljs-comment">// O(1)</span>         result.add(edge);         unionFind.union(edge.from, edge.to);      &#125;   &#125;   <span class="hljs-keyword">return</span> result;&#125;</code></pre><p>有向图有效，如果是 <strong>无向图，会少一半边</strong> ：</p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201215111956.png" alt="少一半边" style="zoom:50%;" /><p>每次只会union一次，下次不会再union</p><h2 id="最小生成树算法之Prim"><a href="#最小生成树算法之Prim" class="headerlink" title="最小生成树算法之Prim"></a>最小生成树算法之Prim</h2><p>1）可以从 <strong>任意节点</strong> 出发来寻找最小生成树<br>2）某个点加入到被选取的点中后，解锁这个点出发的所有新的边<br>3）在所有解锁的边中选最小的边，然后看看这个边会不会形成环<br>4）如果会，不要当前边，继续考察剩下解锁的边中最小的边，重复3）<br>5）如果不会，要当前边，将该边的指向点加入到被选取的点中，重复2）<br>6）当所有点都被选取，最小生成树就得到了</p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201215113103.png" alt="例子" style="zoom:33%;" /><p>a点被解锁，直接边被解锁，在可以被看到的边里选一个最小的边，看看边两侧有没有新结点，解锁，没有新结点抛弃。c被解锁，已经选过的边不被重复解锁，b被解锁，边被解锁，找到所有解锁的边最小继续解锁…一直到所有点被解锁</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201215113614.png" alt="结果"></p><p>总是一个一个点进，而不是一大片结合，所以一个set即可。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Set&lt;Edge&gt; <span class="hljs-title">primMST</span><span class="hljs-params">(Graph graph)</span> </span>&#123;   <span class="hljs-comment">// 解锁的边进入小根堆</span>   PriorityQueue&lt;Edge&gt; priorityQueue = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;(         <span class="hljs-keyword">new</span> EdgeComparator());   HashSet&lt;Node&gt; nodeSet = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();   <span class="hljs-comment">// 防止边重复</span>   HashSet&lt;Edge&gt; edgeSet = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();   Set&lt;Edge&gt; result = <span class="hljs-keyword">new</span> HashSet&lt;&gt;(); <span class="hljs-comment">// 依次挑选的的边在result里</span>   <span class="hljs-keyword">for</span> (Node node : graph.nodes.values()) &#123; <span class="hljs-comment">// 随便挑了一个点</span>   <span class="hljs-comment">// for循环防森林</span>      <span class="hljs-comment">// node 是开始点</span>      <span class="hljs-keyword">if</span> (!set.contains(node)) &#123;         set.add(node);         <span class="hljs-keyword">for</span> (Edge edge : node.edges) &#123; <span class="hljs-comment">// 由一个点，解锁所有相连的边</span>            <span class="hljs-keyword">if</span> (!edgeSet.contains(edge))&#123;               edgeSet.add(edge);               priorityQueue.add(edge);            &#125;         &#125;         <span class="hljs-keyword">while</span> (!priorityQueue.isEmpty()) &#123;            Edge edge = priorityQueue.poll(); <span class="hljs-comment">// 弹出解锁的边中，最小的边</span>            Node toNode = edge.to; <span class="hljs-comment">// 可能的一个新的点</span>            <span class="hljs-keyword">if</span> (!set.contains(toNode)) &#123; <span class="hljs-comment">// 不含有的时候，就是新的点</span>               set.add(toNode);               result.add(edge);               <span class="hljs-keyword">for</span> (Edge nextEdge : toNode.edges) &#123;                  <span class="hljs-keyword">if</span> (!edgeSet.contains(nextEdge))&#123;                     edgeSet.add(nextEdge);                     priorityQueue.add(nextEdge);                  &#125;               &#125;            &#125;         &#125;      &#125;      <span class="hljs-comment">//break;</span>   &#125;   <span class="hljs-keyword">return</span> result;&#125;</code></pre><h2 id="Dijkstra算法-是一种贪心"><a href="#Dijkstra算法-是一种贪心" class="headerlink" title="Dijkstra算法(是一种贪心)"></a>Dijkstra算法(是一种贪心)</h2><p>1）Dijkstra算法必须指定一个源点<br>2）生成一个源点到各个点的最小距离表，一开始只有一条记录，即原点到自己的最小距离为0，源点到其他所有点的最小距离都为正无穷大</p><p>​ <img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201216085732.png" alt="初始表" style="zoom:50%;" /></p><p>3）从距离表中拿出没拿过记录里的最小记录，通过这个点发出的边，更新源点到各个点的最小距离表，不断重复这一步</p><p>​ <img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201216085957.png" alt="更新一次" style="zoom:50%;" /></p><p>​ 选B再更新…. 注： <strong>使用完的记录，要锁住</strong></p><p>4）源点到所有的点记录如果都被拿过一遍，过程停止，最小距离表得到了</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201216085032.png" alt="最小距离表"></p><p> <strong>权值为正数，如果出现负数，环问题可能没有解</strong></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> HashMap&lt;Node, Integer&gt; <span class="hljs-title">dijkstra1</span><span class="hljs-params">(Node from)</span> </span>&#123;   <span class="hljs-comment">// 从from出发到所有点的最小距离</span>   <span class="hljs-comment">// key : 从head出发到达key</span>   <span class="hljs-comment">// value : 从head出发到达key的最小距离</span>   <span class="hljs-comment">// 如果在表中，没有T的记录，含义是从head出发到T这个点的距离为正无穷</span>   HashMap&lt;Node, Integer&gt; distanceMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();   distanceMap.put(from, <span class="hljs-number">0</span>);   <span class="hljs-comment">// 已经求过距离的节点，存在selectedNodes中，以后再也不碰</span>   HashSet&lt;Node&gt; selectedNodes = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();   <span class="hljs-comment">// 选择最小距离且没有被锁住的点</span>   Node minNode = getMinDistanceAndUnselectedNode(distanceMap, selectedNodes);   <span class="hljs-keyword">while</span> (minNode != <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">int</span> distance = distanceMap.get(minNode);      <span class="hljs-keyword">for</span> (Edge edge : minNode.edges) &#123;         Node toNode = edge.to;         <span class="hljs-keyword">if</span> (!distanceMap.containsKey(toNode)) &#123;            distanceMap.put(toNode, distance + edge.weight);         &#125; <span class="hljs-keyword">else</span> &#123;            distanceMap.put(edge.to, Math.min(distanceMap.get(toNode), distance + edge.weight));         &#125;      &#125;      selectedNodes.add(minNode);      minNode = getMinDistanceAndUnselectedNode(distanceMap, selectedNodes);   &#125;   <span class="hljs-keyword">return</span> distanceMap;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">getMinDistanceAndUnselectedNode</span><span class="hljs-params">(HashMap&lt;Node, Integer&gt; distanceMap, HashSet&lt;Node&gt; touchedNodes)</span> </span>&#123;   <span class="hljs-comment">// touchedNodes为selectedNodes</span>   <span class="hljs-comment">// 找到最小且未被锁住的点</span>   Node minNode = <span class="hljs-keyword">null</span>;   <span class="hljs-keyword">int</span> minDistance = Integer.MAX_VALUE;   <span class="hljs-keyword">for</span> (Entry&lt;Node, Integer&gt; entry : distanceMap.entrySet()) &#123;      Node node = entry.getKey();      <span class="hljs-keyword">int</span> distance = entry.getValue();      <span class="hljs-keyword">if</span> (!touchedNodes.contains(node) &amp;&amp; distance &lt; minDistance) &#123;         minNode = node;         minDistance = distance;      &#125;   &#125;   <span class="hljs-keyword">return</span> minNode;&#125;</code></pre><h3 id="小根堆优化"><a href="#小根堆优化" class="headerlink" title="小根堆优化"></a>小根堆优化</h3><p>上述的算法中，for (Entry&lt;Node, Integer&gt; entry : distanceMap.entrySet())这段代码需要对当前取出的结点的下面所有点进行 <strong>遍历</strong>，可以使用一个小根堆，每次取出的就是最小。</p><p>原来是遍历哈希表 O(N) 现在是小根堆 O(logN)</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NodeRecord</span> </span>&#123;   <span class="hljs-keyword">public</span> Node node;   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> distance;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NodeRecord</span><span class="hljs-params">(Node node, <span class="hljs-keyword">int</span> distance)</span> </span>&#123;      <span class="hljs-keyword">this</span>.node = node;      <span class="hljs-keyword">this</span>.distance = distance;   &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NodeHeap</span> </span>&#123;   <span class="hljs-keyword">private</span> Node[] nodes; <span class="hljs-comment">// 实际的堆结构</span>   <span class="hljs-comment">// key 某一个node， value 上面数组中的位置  -1表示曾经进来过</span>   <span class="hljs-keyword">private</span> HashMap&lt;Node, Integer&gt; heapIndexMap;   <span class="hljs-comment">// key 某一个节点， value 从源节点出发到该节点的目前最小距离</span>   <span class="hljs-keyword">private</span> HashMap&lt;Node, Integer&gt; distanceMap;   <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size; <span class="hljs-comment">// 堆上有多少个点</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NodeHeap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> size)</span> </span>&#123;      nodes = <span class="hljs-keyword">new</span> Node[size];      heapIndexMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();      distanceMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();      size = <span class="hljs-number">0</span>;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> size == <span class="hljs-number">0</span>;   &#125;   <span class="hljs-comment">// 有一个点叫node，现在发现了一个从源节点出发到达node的距离为distance</span>   <span class="hljs-comment">// 判断要不要更新，如果需要的话，就更新</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addOrUpdateOrIgnore</span><span class="hljs-params">(Node node, <span class="hljs-keyword">int</span> distance)</span> </span>&#123;      <span class="hljs-keyword">if</span> (inHeap(node)) &#123;         distanceMap.put(node, Math.min(distanceMap.get(node), distance));         insertHeapify(node, heapIndexMap.get(node));      &#125;      <span class="hljs-keyword">if</span> (!isEntered(node)) &#123;         nodes[size] = node;         heapIndexMap.put(node, size);         distanceMap.put(node, distance);         insertHeapify(node, size++);      &#125;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> NodeRecord <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;      NodeRecord nodeRecord = <span class="hljs-keyword">new</span> NodeRecord(nodes[<span class="hljs-number">0</span>], distanceMap.get(nodes[<span class="hljs-number">0</span>]));      swap(<span class="hljs-number">0</span>, size - <span class="hljs-number">1</span>);      heapIndexMap.put(nodes[size - <span class="hljs-number">1</span>], -<span class="hljs-number">1</span>);      distanceMap.remove(nodes[size - <span class="hljs-number">1</span>]);      <span class="hljs-comment">// free C++同学还要把原本堆顶节点析构，对java同学不必</span>      nodes[size - <span class="hljs-number">1</span>] = <span class="hljs-keyword">null</span>;      heapify(<span class="hljs-number">0</span>, --size);      <span class="hljs-keyword">return</span> nodeRecord;   &#125;   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertHeapify</span><span class="hljs-params">(Node node, <span class="hljs-keyword">int</span> index)</span> </span>&#123;      <span class="hljs-keyword">while</span> (distanceMap.get(nodes[index]) &lt; distanceMap.get(nodes[(index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>])) &#123;         swap(index, (index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>);         index = (index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;      &#125;   &#125;   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">heapify</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> size)</span> </span>&#123;      <span class="hljs-keyword">int</span> left = index * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;      <span class="hljs-keyword">while</span> (left &lt; size) &#123;         <span class="hljs-keyword">int</span> smallest = left + <span class="hljs-number">1</span> &lt; size &amp;&amp; distanceMap.get(nodes[left + <span class="hljs-number">1</span>]) &lt; distanceMap.get(nodes[left])               ? left + <span class="hljs-number">1</span>               : left;         smallest = distanceMap.get(nodes[smallest]) &lt; distanceMap.get(nodes[index]) ? smallest : index;         <span class="hljs-keyword">if</span> (smallest == index) &#123;            <span class="hljs-keyword">break</span>;         &#125;         swap(smallest, index);         index = smallest;         left = index * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;      &#125;   &#125;   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEntered</span><span class="hljs-params">(Node node)</span> </span>&#123;      <span class="hljs-keyword">return</span> heapIndexMap.containsKey(node);   &#125;   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">inHeap</span><span class="hljs-params">(Node node)</span> </span>&#123;      <span class="hljs-keyword">return</span> isEntered(node) &amp;&amp; heapIndexMap.get(node) != -<span class="hljs-number">1</span>;   &#125;   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index1, <span class="hljs-keyword">int</span> index2)</span> </span>&#123;      heapIndexMap.put(nodes[index1], index2);      heapIndexMap.put(nodes[index2], index1);      Node tmp = nodes[index1];      nodes[index1] = nodes[index2];      nodes[index2] = tmp;   &#125;&#125;<span class="hljs-comment">// 改进后的dijkstra算法</span><span class="hljs-comment">// 从head出发，所有head能到达的节点，生成到达每个节点的最小路径记录并返回</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> HashMap&lt;Node, Integer&gt; <span class="hljs-title">dijkstra2</span><span class="hljs-params">(Node head, <span class="hljs-keyword">int</span> size)</span> </span>&#123;   NodeHeap nodeHeap = <span class="hljs-keyword">new</span> NodeHeap(size);   nodeHeap.addOrUpdateOrIgnore(head, <span class="hljs-number">0</span>);   HashMap&lt;Node, Integer&gt; result = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();   <span class="hljs-keyword">while</span> (!nodeHeap.isEmpty()) &#123;      NodeRecord record = nodeHeap.pop();      Node cur = record.node;      <span class="hljs-keyword">int</span> distance = record.distance;      <span class="hljs-keyword">for</span> (Edge edge : cur.edges) &#123;         nodeHeap.addOrUpdateOrIgnore(edge.to, edge.weight + distance);      &#125;      result.put(cur, distance);   &#125;   <span class="hljs-keyword">return</span> result;&#125;</code></pre><h1 id="暴力递归"><a href="#暴力递归" class="headerlink" title="暴力递归"></a>暴力递归</h1><blockquote><p> 暴力递归就是尝试 </p></blockquote><p>1，把问题转化为规模缩小了的同类问题的子问题<br>2，有明确的不需要继续进行递归的条件(base case)<br>3，有当得到了子问题的结果之后的决策过程<br>4， <strong>不记录</strong>每一个子问题的解，记录就是 <strong>动态规划</strong> </p><h2 id="熟悉什么叫尝试？"><a href="#熟悉什么叫尝试？" class="headerlink" title="熟悉什么叫尝试？"></a>熟悉什么叫尝试？</h2><ul><li><p>打印n层汉诺塔从最左边移动到最右边的全部过程（2^n -1 步）</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201216104132.png" alt="汉诺塔"></p></li></ul><p>​ 思路：1 - N-1个挪到中间，第N个挪到最右边，1 - N-1挪到最右边</p><blockquote><p>细化递归过程的代码:</p></blockquote><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hanoi1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;   leftToRight(n);&#125;<span class="hljs-comment">// 把 1 - N层圆盘从左移动到右</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">leftToRight</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;   <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;      System.out.println(<span class="hljs-string">&quot;Move 1 from left to right&quot;</span>);      <span class="hljs-keyword">return</span>;   &#125;   leftToMid(n - <span class="hljs-number">1</span>);   System.out.println(<span class="hljs-string">&quot;Move &quot;</span> + n + <span class="hljs-string">&quot; from left to right&quot;</span>);   midToRight(n - <span class="hljs-number">1</span>);&#125;<span class="hljs-comment">// 腾出空间</span><span class="hljs-comment">// 移动最底</span><span class="hljs-comment">// 移动其他</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">leftToMid</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;   <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;      System.out.println(<span class="hljs-string">&quot;Move 1 from left to mid&quot;</span>);      <span class="hljs-keyword">return</span>;   &#125;   leftToRight(n - <span class="hljs-number">1</span>);   System.out.println(<span class="hljs-string">&quot;Move &quot;</span> + n + <span class="hljs-string">&quot; from left to mid&quot;</span>);   rightToMid(n - <span class="hljs-number">1</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rightToMid</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;   <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;      System.out.println(<span class="hljs-string">&quot;Move 1 from right to mid&quot;</span>);      <span class="hljs-keyword">return</span>;   &#125;   rightToLeft(n - <span class="hljs-number">1</span>);   System.out.println(<span class="hljs-string">&quot;Move &quot;</span> + n + <span class="hljs-string">&quot; from right to mid&quot;</span>);   leftToMid(n - <span class="hljs-number">1</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">midToRight</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;   <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;      System.out.println(<span class="hljs-string">&quot;Move 1 from mid to right&quot;</span>);      <span class="hljs-keyword">return</span>;   &#125;   midToLeft(n - <span class="hljs-number">1</span>);   System.out.println(<span class="hljs-string">&quot;Move &quot;</span> + n + <span class="hljs-string">&quot; from mid to right&quot;</span>);   leftToRight(n - <span class="hljs-number">1</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">midToLeft</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;   <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;      System.out.println(<span class="hljs-string">&quot;Move 1 from mid to left&quot;</span>);      <span class="hljs-keyword">return</span>;   &#125;   midToRight(n - <span class="hljs-number">1</span>);   System.out.println(<span class="hljs-string">&quot;Move &quot;</span> + n + <span class="hljs-string">&quot; from mid to left&quot;</span>);   rightToLeft(n - <span class="hljs-number">1</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rightToLeft</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;   <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;      System.out.println(<span class="hljs-string">&quot;Move 1 from right to left&quot;</span>);      <span class="hljs-keyword">return</span>;   &#125;   rightToMid(n - <span class="hljs-number">1</span>);   System.out.println(<span class="hljs-string">&quot;Move &quot;</span> + n + <span class="hljs-string">&quot; from right to left&quot;</span>);   midToLeft(n - <span class="hljs-number">1</span>);&#125;</code></pre><p>为每个移动过程都描述过程。</p><blockquote><p>如果忽略左中右，直接from to other代替全部</p></blockquote><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hanoi2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;   <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">0</span>) &#123;      func(n, <span class="hljs-string">&quot;left&quot;</span>, <span class="hljs-string">&quot;right&quot;</span>, <span class="hljs-string">&quot;mid&quot;</span>);   &#125;&#125;<span class="hljs-comment">// 1~i 圆盘 目标是from -&gt; to， other是另外一个</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span> N, String from, String to, String other)</span> </span>&#123;   <span class="hljs-keyword">if</span> (N == <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// base</span>      System.out.println(<span class="hljs-string">&quot;Move 1 from &quot;</span> + from + <span class="hljs-string">&quot; to &quot;</span> + to);   &#125; <span class="hljs-keyword">else</span> &#123;      func(N - <span class="hljs-number">1</span>, from, other, to);      System.out.println(<span class="hljs-string">&quot;Move &quot;</span> + N + <span class="hljs-string">&quot; from &quot;</span> + from + <span class="hljs-string">&quot; to &quot;</span> + to);      func(N - <span class="hljs-number">1</span>, other, to, from);   &#125;&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201216111446.png" alt="过程"></p><pre><code class="hljs livecodeserver">打印过程：Move <span class="hljs-number">1</span> <span class="hljs-built_in">from</span> left <span class="hljs-built_in">to</span> <span class="hljs-literal">right</span>Move <span class="hljs-number">2</span> <span class="hljs-built_in">from</span> left <span class="hljs-built_in">to</span> <span class="hljs-keyword">mid</span>Move <span class="hljs-number">1</span> <span class="hljs-built_in">from</span> <span class="hljs-literal">right</span> <span class="hljs-built_in">to</span> <span class="hljs-keyword">mid</span>Move <span class="hljs-number">3</span> <span class="hljs-built_in">from</span> left <span class="hljs-built_in">to</span> <span class="hljs-literal">right</span>Move <span class="hljs-number">1</span> <span class="hljs-built_in">from</span> <span class="hljs-keyword">mid</span> <span class="hljs-built_in">to</span> leftMove <span class="hljs-number">2</span> <span class="hljs-built_in">from</span> <span class="hljs-keyword">mid</span> <span class="hljs-built_in">to</span> <span class="hljs-literal">right</span>Move <span class="hljs-number">1</span> <span class="hljs-built_in">from</span> left <span class="hljs-built_in">to</span> <span class="hljs-literal">right</span></code></pre><ul><li><p>打印一个字符串的全部子序列</p><p> <strong>子串</strong> 必须连续。子序列不需要连续，但相对次序不能乱。</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201217083355.png" alt="子串"></p></li></ul><p>  <img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201217083652.png" alt="子序列每个都可以选择要或不要"></p>  <pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;String&gt; <span class="hljs-title">subs</span><span class="hljs-params">(String s)</span> </span>&#123;   <span class="hljs-keyword">char</span>[] str = s.toCharArray();   String path = <span class="hljs-string">&quot;&quot;</span>;   List&lt;String&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();   process1(str, <span class="hljs-number">0</span>, ans, path);   <span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-comment">// str为原始字符串</span><span class="hljs-comment">// index此时来到的位置</span><span class="hljs-comment">// 如果index来到终止位置 路径所形成的答案放到ans中</span><span class="hljs-comment">// 之前做出的选择，就是path</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process1</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] str, <span class="hljs-keyword">int</span> index, List&lt;String&gt; ans, String path)</span> </span>&#123;   <span class="hljs-keyword">if</span> (index == str.length) &#123;      ans.add(path);      <span class="hljs-keyword">return</span>;   &#125;   String no = path;   process1(str, index + <span class="hljs-number">1</span>, ans, no);   String yes = path + String.valueOf(str[index]);   process1(str, index + <span class="hljs-number">1</span>, ans, yes);&#125;</code></pre><ul><li><p>打印一个字符串的全部子序列，要求不要出现重复字面值的子序列</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process2</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] str, <span class="hljs-keyword">int</span> index, HashSet&lt;String&gt; set, String path)</span> </span>&#123;   <span class="hljs-keyword">if</span> (index == str.length) &#123;      set.add(path);      <span class="hljs-keyword">return</span>;   &#125;   String no = path;   process2(str, index + <span class="hljs-number">1</span>, set, no);   String yes = path + String.valueOf(str[index]);   process2(str, index + <span class="hljs-number">1</span>, set, yes);&#125;</code></pre></li></ul><ul><li><p>打印一个字符串的全部排列</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201217085722.png" alt="不用额外空间尝试"></p><p>只需要一个数组，让index所到位置后面所有字符都到该位置一次</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ArrayList&lt;String&gt; <span class="hljs-title">permutation</span><span class="hljs-params">(String str)</span> </span>&#123;   ArrayList&lt;String&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();   <span class="hljs-keyword">if</span> (str == <span class="hljs-keyword">null</span> || str.length() == <span class="hljs-number">0</span>) &#123;      <span class="hljs-keyword">return</span> res;   &#125;   <span class="hljs-keyword">char</span>[] chs = str.toCharArray();   process(chs, <span class="hljs-number">0</span>, res);   <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-comment">// str[0..i-1]已经做好决定</span><span class="hljs-comment">// str[i...]后的都有机会来到i位置</span><span class="hljs-comment">// i来到终止位置，全部做好决定，已经排列好</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] str, <span class="hljs-keyword">int</span> i, ArrayList&lt;String&gt; res)</span> </span>&#123;   <span class="hljs-keyword">if</span> (i == str.length) &#123;      res.add(String.valueOf(str));   &#125;  <span class="hljs-comment">// i没有到终止位置，i往后所有位置来到i位置</span>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i; j &lt; str.length; j++) &#123;      swap(str, i, j);      process(str, i + <span class="hljs-number">1</span>, res);     <span class="hljs-comment">// 恢复现场</span>      swap(str, i, j);   &#125;&#125;</code></pre></li></ul><ul><li><p>打印一个字符串的全部排列，要求不要出现重复的排列</p><p>直接在上面代码改为set，是暴力递归 ➕ 过滤</p><p>但如果使用分支限界方法不一样，在执行过程前杀死支路。</p><pre><code class="hljs java"><span class="hljs-comment">// 分支限界方法</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ArrayList&lt;String&gt; <span class="hljs-title">permutationNoRepeat</span><span class="hljs-params">(String str)</span> </span>&#123;   ArrayList&lt;String&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();   <span class="hljs-keyword">if</span> (str == <span class="hljs-keyword">null</span> || str.length() == <span class="hljs-number">0</span>) &#123;      <span class="hljs-keyword">return</span> res;   &#125;   <span class="hljs-keyword">char</span>[] chs = str.toCharArray();   process2(chs, <span class="hljs-number">0</span>, res);   <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process2</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] str, <span class="hljs-keyword">int</span> i, ArrayList&lt;String&gt; res)</span> </span>&#123;   <span class="hljs-keyword">if</span> (i == str.length) &#123;      res.add(String.valueOf(str));   &#125;     <span class="hljs-comment">// x位置有没有使用过</span>   <span class="hljs-keyword">boolean</span>[] visit = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[<span class="hljs-number">26</span>]; <span class="hljs-comment">// visit[0 1 .. 25]</span>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i; j &lt; str.length; j++) &#123;      <span class="hljs-keyword">if</span> (!visit[str[j] - <span class="hljs-string">&#x27;a&#x27;</span>]) &#123;         visit[str[j] - <span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-keyword">true</span>;         swap(str, i, j);         process2(str, i + <span class="hljs-number">1</span>, res);         swap(str, i, j);      &#125;   &#125;&#125;</code></pre></li></ul><h2 id="仰望好的尝试？"><a href="#仰望好的尝试？" class="headerlink" title="仰望好的尝试？"></a>仰望好的尝试？</h2><p>给你一个栈，请你 <strong>逆序</strong> 这个栈，<br>不能申请额外的数据结构，<br>只能使用递归函数。 如何实现? </p><p>f函数功能: 把栈底元素抽离</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201216114416.png" alt="流程"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201216114856.png" alt="reverse流程"></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reverse</span><span class="hljs-params">(Stack&lt;Integer&gt; stack)</span> </span>&#123;   <span class="hljs-keyword">if</span> (stack.isEmpty()) &#123;      <span class="hljs-keyword">return</span>;   &#125;   <span class="hljs-keyword">int</span> i = f(stack);   reverse(stack);   stack.push(i);&#125;<span class="hljs-comment">// 功能： 莫名其妙把栈底元素搞没了 还返回了</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">(Stack&lt;Integer&gt; stack)</span> </span>&#123;   <span class="hljs-keyword">int</span> result = stack.pop();   <span class="hljs-keyword">if</span> (stack.isEmpty()) &#123;      <span class="hljs-keyword">return</span> result;   &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-keyword">int</span> last = f(stack);      stack.push(result);      <span class="hljs-keyword">return</span> last;   &#125;&#125;</code></pre><h2 id="从左往右的尝试模型1"><a href="#从左往右的尝试模型1" class="headerlink" title="从左往右的尝试模型1"></a>从左往右的尝试模型1</h2><h2 id="从左往右的尝试模型2"><a href="#从左往右的尝试模型2" class="headerlink" title="从左往右的尝试模型2"></a>从左往右的尝试模型2</h2><h2 id="范围上尝试的模型"><a href="#范围上尝试的模型" class="headerlink" title="范围上尝试的模型"></a>范围上尝试的模型</h2><h2 id="人过河问题"><a href="#人过河问题" class="headerlink" title="人过河问题"></a>人过河问题</h2><p>假设河里有鳄鱼，吃人后非常虚弱，虚弱后同时也会被其他鳄鱼吃，考虑人是否应该过河。假设鱼都绝顶聪明。</p><p>当鱼 <strong>偶数</strong> 时，可以过河；</p><p>鱼为 <strong>奇数</strong> 时，不能过河；</p><h2 id="海盗分硬币问题思考"><a href="#海盗分硬币问题思考" class="headerlink" title="海盗分硬币问题思考"></a>海盗分硬币问题思考</h2><p>假设有 100 个硬币， ABCDE五人分并依次提议，当赞成数大于等于一半时，提议成功，否则会被杀死。</p><p>思考：</p><p>如果只有 <strong>E一个人</strong> ，一百个硬币全部归 E；</p><p>如果只有 <strong>DE</strong> 两个人，只要E投反对票，D就会被杀死，所以100硬币全部归E；</p><p>如果只有 <strong>CDE三个人</strong>， 只要C被投死，D也一定死，所以D为了存活只能投C，C获得100硬币；</p><p>如果只有 <strong>BCDE四个人</strong>， B知道D、E没有硬币，所以给D、E各一个，自己98个，就能拉到票；</p><p>当 <strong>ABCDE</strong> 时，A知道C没有，给c一个，知道D、E只有一个，只需要给一个人两个硬币就行，所以自己97个；</p><h2 id="欧拉信封问题"><a href="#欧拉信封问题" class="headerlink" title="欧拉信封问题"></a>欧拉信封问题</h2><p>一个村子有N个人，每个人能寄出一封信，也能收到一封信，但不能是自己，问有多少种方法寄收。</p><p>当只有 1 个人时，寄收方法为0；</p><p>当有 2 个人时，寄收方法为1；</p><p>当有 3 个人时，ABC，如果A寄给B，B只能寄给C，一种；A寄给C，C只能寄给B，一种；一共 2 种方法；</p><p>当有 5 个人时，ABCDE，假设是B寄给E，如果E寄给B，剩下三个人玩欧拉信封问题，就有f(3)；假设E不寄给B，EB就可以看为一个整体，一条出度，一条入度，变成四个人玩欧拉信封问题，就有f(4)；</p><p>B一共能寄给4种，所以 4 * ( f(3) + f(4) )</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201218104738.png" alt="N = 5"></p><p>结果为 f(n) = (n - 1) * ( f(n - 2) + f(n - 1) )</p><h2 id="N皇后"><a href="#N皇后" class="headerlink" title="N皇后"></a>N皇后</h2><p>N皇后问题是指在 *<em>N</em>N的棋盘上** 要 <strong>摆N个</strong> 皇后，<br>要求任何两个皇后不同行、不同列， 也不在同一条斜线上<br>给定一个整数n，返回n皇后的摆法有多少种。n=1，返回1<br>n=2或3，2皇后和3皇后问题无论怎么摆都不行，返回0<br>n=8，返回92</p><p> <strong>每行放一个，不会存在行上攻击问题</strong> ，</p><p> <strong>判断下一行与其它行斜线是否合法</strong>： 如果点分别为(a, b) (c, d) 判断 <strong>|a-c| == |b-d|</strong> </p><p>Code1:</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">num1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;   <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">1</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;   &#125;   <span class="hljs-comment">// record[0] ?  record[1]  ?  record[2]</span>   <span class="hljs-keyword">int</span>[] record = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n]; <span class="hljs-comment">// record[i] -&gt; i行的皇后，放在了第几列</span>   <span class="hljs-keyword">return</span> process1(<span class="hljs-number">0</span>, record, n);&#125;<span class="hljs-comment">// 潜台词：record[0..i-1]的皇后，任何两个皇后一定都不共行、不共列，不共斜线</span><span class="hljs-comment">// 目前来到了第i行</span><span class="hljs-comment">// record[0..i-1]表示之前的行，放了的皇后位置，index可以描述行数，value为列树</span><span class="hljs-comment">// n代表整体一共有多少行</span><span class="hljs-comment">// 返回值是，摆完所有的皇后，合理的摆法有多少种</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">process1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span>[] record, <span class="hljs-keyword">int</span> n)</span> </span>&#123;   <span class="hljs-keyword">if</span> (i == n) &#123; <span class="hljs-comment">// 终止行，行数从0开始算</span>      <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;   &#125;   <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;   <span class="hljs-comment">// j为列</span>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123; <span class="hljs-comment">// 当前行在i行，尝试i行所有的列  -&gt; j</span>      <span class="hljs-comment">// 判断当前i行的皇后，放在j列，会不会和之前(0..i-1)的皇后，不共行共列或者共斜线，</span>      <span class="hljs-comment">// 如果是，认为有效</span>      <span class="hljs-comment">// 如果不是，认为无效</span>      <span class="hljs-keyword">if</span> (isValid(record, i, j)) &#123;         <span class="hljs-comment">// record不用还原，数组可以直接覆盖</span>         record[i] = j;         res += process1(i + <span class="hljs-number">1</span>, record, n);      &#125;   &#125;   <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-comment">// record[0..i-1]你需要看，record[i...]不需要看</span><span class="hljs-comment">// 返回i行皇后，放在了j列，是否有效</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValid</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] record, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; i; k++) &#123; <span class="hljs-comment">// 之前的某个k行的皇后</span>      <span class="hljs-comment">// (k, record[k])  现在的 (i, j)</span>      <span class="hljs-keyword">if</span> (j == record[k] || Math.abs(record[k] - j) == Math.abs(i - k)) &#123;         <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;      &#125;   &#125;   <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;&#125;</code></pre><blockquote><p>可以进行 <strong>常数项</strong> 优化</p></blockquote><p>初始变量:</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201218113922.png" alt="初始变量"></p><p>如果放第一个：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201218114358.png" alt="放第一个到0位置"></p><p>如果放第一个到4位置：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201218114723.png" alt="放4位置"></p><p> <strong>把三个limit 或运算，就是下一行能够放的位置</strong> </p><p> 如果第一行放4位置，第二行放1位置，限制变成</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201218135309.png" alt="放第二个到1位置"></p><p>左limit对比第一次，就是先在第一个位置放皇后，01010000后，左移一位，变成10100000</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201218135531.png" alt="放第二个后的右限制"></p><p>右limit对比第一次，就是先在第一个位置放皇后，01000100后，右移一位，变成00100010；</p><p>下次皇后位置，就为三个limit或起来：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201218135851.png" alt="下次可放位置"></p><p>Code2:</p><pre><code class="hljs java"><span class="hljs-comment">// 请不要超过32皇后问题</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">num2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;   <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">1</span> || n &gt; <span class="hljs-number">32</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;   &#125;   <span class="hljs-comment">// n皇后问题，limit后面有多少个1</span>   <span class="hljs-comment">// 比如8皇后问题，1左移8位 8个0， 减1后 8个1</span>   <span class="hljs-keyword">int</span> limit = n == <span class="hljs-number">32</span> ? -<span class="hljs-number">1</span> : (<span class="hljs-number">1</span> &lt;&lt; n) - <span class="hljs-number">1</span>;   <span class="hljs-keyword">return</span> process2(limit, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);&#125;<span class="hljs-comment">// limit划定问题规模 永远不变</span><span class="hljs-comment">// colLim 列的限制，1的位置不能放皇后，0的位置可以</span><span class="hljs-comment">// leftDiaLim 左斜线的限制，1的位置不能放皇后，0的位置可以</span><span class="hljs-comment">// rightDiaLim 右斜线的限制，1的位置不能放皇后，0的位置可以</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">process2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> limit, </span></span><span class="hljs-function"><span class="hljs-params">      <span class="hljs-keyword">int</span> colLim, </span></span><span class="hljs-function"><span class="hljs-params">      <span class="hljs-keyword">int</span> leftDiaLim,</span></span><span class="hljs-function"><span class="hljs-params">      <span class="hljs-keyword">int</span> rightDiaLim)</span> </span>&#123;   <span class="hljs-keyword">if</span> (colLim == limit) &#123; <span class="hljs-comment">// base case</span>      <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;   &#125;   <span class="hljs-comment">// 所有候选皇后的位置，都在pos上</span>   <span class="hljs-comment">// colLim | leftDiaLim | rightDiaLim -&gt; 总限制</span>   <span class="hljs-comment">// ~(colLim | leftDiaLim | rightDiaLim)右边为1可摆，但前面都是1</span>   <span class="hljs-comment">// limit &amp; 让左侧变为0，也可以让左移超边界的1限制变0，防止干扰</span>   <span class="hljs-keyword">int</span> pos = limit &amp; (~(colLim | leftDiaLim | rightDiaLim));   <span class="hljs-keyword">int</span> mostRightOne = <span class="hljs-number">0</span>;   <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;   <span class="hljs-comment">// pos为0 表示没有位置放了</span>   <span class="hljs-keyword">while</span> (pos != <span class="hljs-number">0</span>) &#123;      <span class="hljs-comment">// 找最右边的1</span>      mostRightOne = pos &amp; (~pos + <span class="hljs-number">1</span>);      pos = pos - mostRightOne;      res += process2(limit,             colLim | mostRightOne,            (leftDiaLim | mostRightOne) &lt;&lt; <span class="hljs-number">1</span>,            (rightDiaLim | mostRightOne) &gt;&gt;&gt; <span class="hljs-number">1</span>);   &#125;   <span class="hljs-keyword">return</span> res;&#125;</code></pre><p>![如何找到能放皇后的位置，且代表1] (<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201218140919.png" alt="image-20201218140916545">)</p><h3 id="如果要输出怎么办？"><a href="#如果要输出怎么办？" class="headerlink" title="如果要输出怎么办？"></a>如果要输出怎么办？</h3><p>leetcode原题：</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;List&lt;String&gt;&gt; solveNQueens(<span class="hljs-keyword">int</span> n) &#123;        <span class="hljs-keyword">char</span>[][] chess = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[n][n];        <span class="hljs-comment">//初始化数组</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)                chess[i][j] = <span class="hljs-string">&#x27;.&#x27;</span>;        List&lt;List&lt;String&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        solve(res, chess, <span class="hljs-number">0</span>);        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(List&lt;List&lt;String&gt;&gt; res, <span class="hljs-keyword">char</span>[][] chess, <span class="hljs-keyword">int</span> row)</span> </span>&#123;        <span class="hljs-keyword">if</span> (row == chess.length) &#123;            System.out.println(chess.length);            res.add(construct(chess));            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> col = <span class="hljs-number">0</span>; col &lt; chess.length; col++) &#123;            <span class="hljs-keyword">if</span> (valid(chess, row, col)) &#123;                chess[row][col] = <span class="hljs-string">&#x27;Q&#x27;</span>;                solve(res, chess, row + <span class="hljs-number">1</span>);                chess[row][col] = <span class="hljs-string">&#x27;.&#x27;</span>;            &#125;        &#125;    &#125;    <span class="hljs-comment">//row表示第几行，col表示第几列</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">valid</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] chess, <span class="hljs-keyword">int</span> row, <span class="hljs-keyword">int</span> col)</span> </span>&#123;        <span class="hljs-comment">//判断当前列有没有皇后,因为他是一行一行往下走的，</span>        <span class="hljs-comment">//我们只需要检查走过的行数即可，通俗一点就是判断当前</span>        <span class="hljs-comment">//坐标位置的上面有没有皇后</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; row; i++) &#123;            <span class="hljs-keyword">if</span> (chess[i][col] == <span class="hljs-string">&#x27;Q&#x27;</span>) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;        &#125;        <span class="hljs-comment">//判断当前坐标的右上角有没有皇后</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = row - <span class="hljs-number">1</span>, j = col + <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &lt; chess.length; i--, j++) &#123;            <span class="hljs-keyword">if</span> (chess[i][j] == <span class="hljs-string">&#x27;Q&#x27;</span>) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;        &#125;        <span class="hljs-comment">//判断当前坐标的左上角有没有皇后</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = row - <span class="hljs-number">1</span>, j = col - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span>; i--, j--) &#123;            <span class="hljs-keyword">if</span> (chess[i][j] == <span class="hljs-string">&#x27;Q&#x27;</span>) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-comment">//把数组转为list</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List&lt;String&gt; <span class="hljs-title">construct</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] chess)</span> </span>&#123;        List&lt;String&gt; path = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; chess.length; i++) &#123;            path.add(<span class="hljs-keyword">new</span> String(chess[i]));        &#125;        <span class="hljs-keyword">return</span> path;    &#125;&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201218151905.png" alt="暴力递归存在的问题"></p><p>有很多重复过程</p><p>你可以用一个数组，记录数列前几项，类似于 <strong>缓存</strong> 。</p><h2 id="暴力到动态规划-题目一"><a href="#暴力到动态规划-题目一" class="headerlink" title="暴力到动态规划(题目一)"></a>暴力到动态规划(题目一)</h2><p>假设有排成一行的N个位置，记为1<del>N，N 一定大于或等于 2<br>开始时机器人在其中的M位置上(M 一定是 1</del>N 中的一个)<br>如果机器人来到1位置，那么下一步只能往右来到2位置；<br>如果机器人来到N位置，那么下一步只能往左来到 N-1 位置；<br>如果机器人来到中间位置，那么下一步可以往左走或者往右走；<br>规定机器人必须走 K 步，最终能来到P位置(P也是1~N中的一个)的方法有多少种<br>给定四个参数 N、M、K、P，返回方法数。</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201219132935.png" alt="流程"></p><blockquote><p>暴力代码</p></blockquote><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">ways1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> N, <span class="hljs-keyword">int</span> M, <span class="hljs-keyword">int</span> K, <span class="hljs-keyword">int</span> P)</span> </span>&#123;   <span class="hljs-comment">// 参数无效直接返回0</span>   <span class="hljs-keyword">if</span> (N &lt; <span class="hljs-number">2</span> || K &lt; <span class="hljs-number">1</span> || M &lt; <span class="hljs-number">1</span> || M &gt; N || P &lt; <span class="hljs-number">1</span> || P &gt; N) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;   &#125;   <span class="hljs-comment">// 总共N个位置，从M点出发，还剩K步，返回最终能达到P的方法数</span>   <span class="hljs-keyword">return</span> walk(N, M, K, P);&#125;<span class="hljs-comment">// N : 位置为1 ~ N，固定参数</span><span class="hljs-comment">// cur : 当前在cur位置，可变参数</span><span class="hljs-comment">// rest : 还剩res步没有走，可变参数</span><span class="hljs-comment">// P : 最终目标位置是P，固定参数</span><span class="hljs-comment">// 该函数的含义：只能在1~N这些位置上移动，当前在cur位置，走完rest步之后，停在P位置的方法数作为返回值返回</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">walk</span><span class="hljs-params">(<span class="hljs-keyword">int</span> N, <span class="hljs-keyword">int</span> cur, <span class="hljs-keyword">int</span> rest, <span class="hljs-keyword">int</span> P)</span> </span>&#123;   <span class="hljs-comment">// 如果没有剩余步数了，当前的cur位置就是最后的位置</span>   <span class="hljs-comment">// 如果最后的位置停在P上，那么之前做的移动是有效的</span>   <span class="hljs-comment">// 如果最后的位置没在P上，那么之前做的移动是无效的</span>   <span class="hljs-keyword">if</span> (rest == <span class="hljs-number">0</span>) &#123;      <span class="hljs-keyword">return</span> cur == P ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;   &#125;   <span class="hljs-comment">// 如果还有rest步要走，而当前的cur位置在1位置上，那么当前这步只能从1走向2</span>   <span class="hljs-comment">// 后续的过程就是，来到2位置上，还剩rest-1步要走</span>   <span class="hljs-keyword">if</span> (cur == <span class="hljs-number">1</span>) &#123;      <span class="hljs-keyword">return</span> walk(N, <span class="hljs-number">2</span>, rest - <span class="hljs-number">1</span>, P);   &#125;   <span class="hljs-comment">// 如果还有rest步要走，而当前的cur位置在N位置上，那么当前这步只能从N走向N-1</span>   <span class="hljs-comment">// 后续的过程就是，来到N-1位置上，还剩rest-1步要走</span>   <span class="hljs-keyword">if</span> (cur == N) &#123;      <span class="hljs-keyword">return</span> walk(N, N - <span class="hljs-number">1</span>, rest - <span class="hljs-number">1</span>, P);   &#125;   <span class="hljs-comment">// 如果还有rest步要走，而当前的cur位置在中间位置上，那么当前这步可以走向左，也可以走向右</span>   <span class="hljs-comment">// 走向左之后，后续的过程就是，来到cur-1位置上，还剩rest-1步要走</span>   <span class="hljs-comment">// 走向右之后，后续的过程就是，来到cur+1位置上，还剩rest-1步要走</span>   <span class="hljs-comment">// 走向左、走向右是截然不同的方法，所以总方法数要都算上</span>   <span class="hljs-keyword">return</span> walk(N, cur + <span class="hljs-number">1</span>, rest - <span class="hljs-number">1</span>, P) + walk(N, cur - <span class="hljs-number">1</span>, rest - <span class="hljs-number">1</span>, P);&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201219150216.png" alt="有重复过程"></p><blockquote><p>缓存式(记忆化搜索) 动态规划代码</p></blockquote><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">waysCache</span><span class="hljs-params">(<span class="hljs-keyword">int</span> N, <span class="hljs-keyword">int</span> M, <span class="hljs-keyword">int</span> K, <span class="hljs-keyword">int</span> P)</span> </span>&#123;   <span class="hljs-keyword">if</span> (N &lt; <span class="hljs-number">2</span> || K &lt; <span class="hljs-number">1</span> || M &lt; <span class="hljs-number">1</span> || M &gt; N || P &lt; <span class="hljs-number">1</span> || P &gt; N) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;   &#125;   <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[N + <span class="hljs-number">1</span>][K + <span class="hljs-number">1</span>];   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> row = <span class="hljs-number">0</span>; row &lt;= N; row++)&#123;      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> col = <span class="hljs-number">0</span>; col &lt;= N; col++)&#123;         dp[row][col] = -<span class="hljs-number">1</span>;      &#125;   &#125;   <span class="hljs-keyword">return</span> walkCache(N, M, K, P, dp);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">walkCache</span><span class="hljs-params">(<span class="hljs-keyword">int</span> N, <span class="hljs-keyword">int</span> cur, <span class="hljs-keyword">int</span> rest, <span class="hljs-keyword">int</span> P, <span class="hljs-keyword">int</span>[][] dp)</span> </span>&#123;   <span class="hljs-keyword">if</span> (dp[cur][rest] != -<span class="hljs-number">1</span>)&#123;      <span class="hljs-keyword">return</span> d[cur][rest];   &#125;      <span class="hljs-keyword">if</span> (rest == <span class="hljs-number">0</span>) &#123;      dp[cur][rest] = cur == P ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;      <span class="hljs-keyword">return</span> dp[cur][rest];   &#125;   <span class="hljs-keyword">if</span> (cur == <span class="hljs-number">1</span>) &#123;      dp[cur][rest] = walkCache(N, <span class="hljs-number">2</span>, rest - <span class="hljs-number">1</span>, P, dp);      <span class="hljs-keyword">return</span> dp[cur][rest];   &#125;   <span class="hljs-keyword">if</span> (cur == N) &#123;      dp[cur][rest] = walkCache(N, N - <span class="hljs-number">1</span>, rest - <span class="hljs-number">1</span>, P, dp);      <span class="hljs-keyword">return</span> dp[cur][rest]   &#125;   dp[cur][rest] =  walkCache(N, cur + <span class="hljs-number">1</span>, rest - <span class="hljs-number">1</span>, P, dp) + walkCache(N, cur - <span class="hljs-number">1</span>, rest - <span class="hljs-number">1</span>, P, dp);   <span class="hljs-keyword">return</span> dp[cur][rest];&#125;</code></pre><blockquote><p>依赖关系猜想</p></blockquote><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201219152445.png" alt="依赖过程"></p><p>可见每个普通位置都依赖左上和左下，由下方暴力代码猜想而来：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201219152543.png" alt="暴力代码依赖性"></p><p>最后直接靠 <strong>依赖</strong> 就能得到结果：</p><p>![依赖]（<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201219152752.png" alt="image-20201219152743937"></p><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><blockquote><p>暴力递归中有重复运算过程，才建议改为动态规划</p></blockquote><h2 id="什么暴力递归可以继续优化？"><a href="#什么暴力递归可以继续优化？" class="headerlink" title="什么暴力递归可以继续优化？"></a>什么暴力递归可以继续优化？</h2><p>有重复调用同一个子问题的解，这种递归可以优化<br>如果每一个子问题都是不同的解，无法优化也不用优化</p><h2 id="暴力递归和动态规划的关系"><a href="#暴力递归和动态规划的关系" class="headerlink" title="暴力递归和动态规划的关系"></a>暴力递归和动态规划的关系</h2><p>某一个暴力递归，有解的重复调用，就可以把这个暴力递归优化成动态规划</p><p>任何动态规划问题，都一定对应着某一个有解的重复调用的暴力递归</p><p>但不是所有的暴力递归，都一定对应着动态规划</p><h2 id="面试题和动态规划的关系"><a href="#面试题和动态规划的关系" class="headerlink" title="面试题和动态规划的关系"></a>面试题和动态规划的关系</h2><p>解决一个问题，可能有很多尝试方法</p><p>可能在很多尝试方法中，又有若干个尝试方法有动态规划的方式</p><p>一个问题   可能有   若干种动态规划的解法</p><h2 id="如何找到某个问题的动态规划方式？"><a href="#如何找到某个问题的动态规划方式？" class="headerlink" title="如何找到某个问题的动态规划方式？"></a>如何找到某个问题的动态规划方式？</h2><p>1）设计暴力递归：重要原则+4种常见尝试模型！重点！</p><p>2）分析有没有重复解：套路解决</p><p>3）用记忆化搜索 -&gt; 用严格表结构实现动态规划：套路解决</p><p>4）看看能否继续优化：套路解决</p><h2 id="面试中设计暴力递归过程的原则"><a href="#面试中设计暴力递归过程的原则" class="headerlink" title="面试中设计暴力递归过程的原则"></a>面试中设计暴力递归过程的原则</h2><p>1）每一个可变参数的类型，一定不要比int类型更加复杂</p><p>​   一个int可变参数，dp一维表；</p><p>​   两个int可变参数，dp二维表；</p><p>​   ……</p><p>2）原则1）可以违反，让类型突破到一维线性结构，那必须是单一可变参数（如贴纸拼接问题用到字符串）</p><p>3）如果发现原则1）被违反，但不违反原则2），只需要做到记忆化搜索即可（如贴纸拼接问题不写dp）</p><p>4）可变参数的个数，能少则少</p><h2 id="常见的4种尝试模型"><a href="#常见的4种尝试模型" class="headerlink" title="常见的4种尝试模型"></a>常见的4种尝试模型</h2><p>1）从左往右的尝试模型</p><p>2）范围上的尝试模型</p><p>3）多样本位置全对应的尝试模型</p><p>4）寻找业务限制的尝试模型</p><h2 id="暴力递归到动态规划的套路"><a href="#暴力递归到动态规划的套路" class="headerlink" title="暴力递归到动态规划的套路"></a>暴力递归到动态规划的套路</h2><p>1）你已经有了一个不违反原则的暴力递归，而且的确存在解的重复调用<br>2）找到哪些参数的变化会影响返回值，对每一个列出变化范围<br>3）参数间的所有的组合数量，意味着表大小<br>4）记忆化搜索的方法就是傻缓存，非常容易得到<br>5）规定好严格表的大小，分析位置的依赖顺序，然后从基础填写到最终解<br>6）对于有枚举行为的决策过程，进一步优化</p><h2 id="知道了面试中设计暴力递归过程的原则，然后呢？"><a href="#知道了面试中设计暴力递归过程的原则，然后呢？" class="headerlink" title="知道了面试中设计暴力递归过程的原则，然后呢？"></a>知道了面试中设计暴力递归过程的原则，然后呢？</h2><p>一定要逼自己找到不违反原则情况下的暴力尝试！</p><p>如果你找到的暴力尝试，不符合原则，马上舍弃！找新的！</p><p>如果某个题目突破了设计原则，一定极难极难，面试中出现概率低于5%！</p><h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201220141419.png" alt="暴力代码"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201220141827.png" alt="例子"></p><p>选1,2不选3和选3不选1,2最后都会再算一遍f(3, 17)</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201220142425.png" alt="初始位置"></p><p>函数调用(0, bag) 即(0, restMax)</p><p>由暴力递归得 rest&lt;0,无效；index == w.len, 为0</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201220143712.png" alt="更改过程"></p><p>code:</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">dpWay</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] w, <span class="hljs-keyword">int</span>[] v, <span class="hljs-keyword">int</span> bag)</span> </span>&#123;   <span class="hljs-keyword">int</span> N = w.length;   <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[N + <span class="hljs-number">1</span>][bag + <span class="hljs-number">1</span>];   <span class="hljs-comment">// dp[N][...] = 0,本来初始化就为0</span>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> index = N - <span class="hljs-number">1</span>; index &gt;= <span class="hljs-number">0</span>; index--) &#123;      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> rest = <span class="hljs-number">1</span>; rest &lt;= bag; rest++) &#123;         dp[index][rest] = dp[index + <span class="hljs-number">1</span>][rest];         <span class="hljs-keyword">if</span> (rest &gt;= w[index]) &#123;            dp[index][rest] = Math.max(dp[index][rest], v[index] + dp[index + <span class="hljs-number">1</span>][rest - w[index]]);         &#125;      &#125;   &#125;   <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][bag];&#125;</code></pre><h2 id="数字转化字符串问题"><a href="#数字转化字符串问题" class="headerlink" title="数字转化字符串问题"></a>数字转化字符串问题</h2><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201220145024.png" alt="原code"></p><p>搭框架</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201220145312.png" alt="框架"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201220145223.png" alt="return"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201220145438.png" alt="填"></p><p>code:</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">dpWays</span><span class="hljs-params">(String s)</span> </span>&#123;   <span class="hljs-keyword">if</span> (s == <span class="hljs-keyword">null</span> || s.length() == <span class="hljs-number">0</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;   &#125;   <span class="hljs-keyword">char</span>[] str = s.toCharArray();   <span class="hljs-keyword">int</span> N = str.length;   <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[N + <span class="hljs-number">1</span>];   dp[N] = <span class="hljs-number">1</span>;   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = N - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;      <span class="hljs-keyword">if</span> (str[i] == <span class="hljs-string">&#x27;0&#x27;</span>) &#123;         dp[i] = <span class="hljs-number">0</span>;      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (str[i] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;         dp[i] = dp[i + <span class="hljs-number">1</span>];         <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span> &lt; N) &#123;            dp[i] += dp[i + <span class="hljs-number">2</span>];         &#125;      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (str[i] == <span class="hljs-string">&#x27;2&#x27;</span>) &#123;         dp[i] = dp[i + <span class="hljs-number">1</span>];          <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span> &lt; str.length &amp;&amp; (str[i + <span class="hljs-number">1</span>] &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; str[i + <span class="hljs-number">1</span>] &lt;= <span class="hljs-string">&#x27;6&#x27;</span>)) &#123;            dp[i] += dp[i + <span class="hljs-number">2</span>];         &#125;      &#125; <span class="hljs-keyword">else</span> &#123;         dp[i] = dp[i + <span class="hljs-number">1</span>];      &#125;   &#125;   <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>];&#125;</code></pre><h2 id="AB取卡牌问题"><a href="#AB取卡牌问题" class="headerlink" title="AB取卡牌问题"></a>AB取卡牌问题</h2><p>原code:</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201220150438.png" alt="image-20201220150436084"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201220151842.png" alt="由暴力递归得"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201220152133.png" alt="由暴力递归得到关系图"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201220152246.png" alt="依赖推出"></p><p>code:</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">windp</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;   <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length == <span class="hljs-number">0</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;   &#125;   <span class="hljs-keyword">int</span> N = arr.length;   <span class="hljs-keyword">int</span>[][] f = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[N][N];   <span class="hljs-keyword">int</span>[][] s = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[N][N];   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;      f[i][i] = arr[i];   &#125;   <span class="hljs-comment">// 0,0 右下方移动</span>   <span class="hljs-comment">// 0,1</span>   <span class="hljs-comment">// 0,2</span>   <span class="hljs-comment">// 0,N-1</span>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> col = <span class="hljs-number">1</span>; col &lt; N; col++) &#123;      <span class="hljs-comment">// 对角线出发位置(0,col)</span>      <span class="hljs-keyword">int</span> L = <span class="hljs-number">0</span>;      <span class="hljs-keyword">int</span> R = col;      <span class="hljs-keyword">while</span> (L &lt; N &amp;&amp; R &lt; N) &#123;         f[L][R] = Math.max(arr[L] + s[L + <span class="hljs-number">1</span>][R], arr[R] + s[L][R - <span class="hljs-number">1</span>]);         s[L][R] = Math.min(f[L + <span class="hljs-number">1</span>][R], f[L][R - <span class="hljs-number">1</span>]);         L++;         R++;      &#125;   &#125;   <span class="hljs-keyword">return</span> Math.max(f[<span class="hljs-number">0</span>][N - <span class="hljs-number">1</span>], s[<span class="hljs-number">0</span>][N - <span class="hljs-number">1</span>]);&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201220153643.png" alt="动态规划"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201220154023.png" alt="动态规划时间复杂度"></p><blockquote><p>对于记忆化搜索：</p></blockquote><p>如果一个问题依赖的子状态是有限个，不用枚举，时间复杂度和经典动态规划是一致的。</p><p>如果有枚举问题，应该改为经典动态规划。</p><h2 id="货币数组问题"><a href="#货币数组问题" class="headerlink" title="货币数组问题"></a>货币数组问题</h2><p>一个arr中都是正数，无重复值，arr中对应货币面值，给你一个num，用arr中组成num的方法数。</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201220154742.png" alt="问题"></p><p>递归定义：f(i, rest) 表示arr[i]之后的面值随意使用，搞定rest</p><pre><code class="hljs java"><span class="hljs-comment">// arr中都是正数且无重复值，返回组成aim的方法数</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">ways</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> aim)</span> </span>&#123;   <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length == <span class="hljs-number">0</span> || aim &lt; <span class="hljs-number">0</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;   &#125;   <span class="hljs-keyword">return</span> process(arr, <span class="hljs-number">0</span>, aim);&#125;<span class="hljs-comment">// 如果自由使用arr[index...]的面值，组成rest这么多钱，返回方法数 （1 , 6）</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">process</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> rest)</span> </span>&#123;   <span class="hljs-comment">// 下面的if在process中保证了rest不会小于0</span>     <span class="hljs-comment">//if (rest &lt;0)&#123;</span>   <span class="hljs-comment">//   return 0;</span>   <span class="hljs-comment">//&#125;</span>   <span class="hljs-keyword">if</span> (index == arr.length) &#123; <span class="hljs-comment">// 无面值的时候</span>      <span class="hljs-keyword">return</span> rest == <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;   &#125;   <span class="hljs-comment">// 有面值的时候</span>   <span class="hljs-keyword">int</span> ways = <span class="hljs-number">0</span>;   <span class="hljs-comment">// arr[index] 当钱面值</span>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> zhang = <span class="hljs-number">0</span>; zhang * arr[index] &lt;= rest; zhang++) &#123;      ways += process(arr, index + <span class="hljs-number">1</span>, rest - zhang * arr[index]);   &#125;   <span class="hljs-keyword">return</span> ways;&#125;</code></pre><blockquote><p>记忆划搜索</p></blockquote><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201220164211.png" alt="code"></p><blockquote><p>经典动态规划</p></blockquote><p>普通由记忆化搜索改的动态规划：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201220172428.png" alt="普通方法"></p><p> <strong>有枚举行为</strong> </p><p>再次查看依赖关系：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201220173132.png" alt="依赖关系"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201220173312.png" alt="依赖"></p><p>星号值依赖b、c…. </p><p>问号值依赖a、b、c…..</p><p>但求问好值，要先求星号值，优化后就是当前 = 左边 加 下面</p><p>优化的dp：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">waysdp</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> aim)</span> </span>&#123;   <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length == <span class="hljs-number">0</span> || aim &lt; <span class="hljs-number">0</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;   &#125;   <span class="hljs-keyword">int</span> N = arr.length;   <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[N + <span class="hljs-number">1</span>][aim + <span class="hljs-number">1</span>];   dp[N][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = N - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123; <span class="hljs-comment">// 大顺序 从下往上</span>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> rest = <span class="hljs-number">0</span>; rest &lt;= aim; rest++) &#123;         dp[i][rest] = dp[i + <span class="hljs-number">1</span>][rest];         <span class="hljs-keyword">if</span> (rest - arr[i] &gt;= <span class="hljs-number">0</span>) &#123;            <span class="hljs-comment">// 加左 加下</span>            dp[i][rest] += dp[i][rest - arr[i]];         &#125;      &#125;   &#125;   <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][aim];&#125;</code></pre><p>如果所有钞票都是百位数，建议记忆化搜索，因为dp是细粒度的记录（比如上述rest循环中，rest &lt;= aim 对每个都遍历）。</p><h2 id="贴纸字符串问题-题目二"><a href="#贴纸字符串问题-题目二" class="headerlink" title="贴纸字符串问题(题目二)"></a>贴纸字符串问题(题目二)</h2><p>给定一个字符串str，给定一个字符串类型的数组arr。<br>arr里的每一个字符串，代表一张贴纸，你可以把单个字符剪开使用，目的是拼出str来。<br>返回需要至少多少张贴纸可以完成这个任务。<br>例子：str= “babac”，arr = {“ba”,”c”,”abcd”}<br>至少需要两张贴纸”ba”和”abcd”，因为使用这两张贴纸，把每一个字符单独剪开，含有2个a、2个b、1个c。是可以拼出str的。所以返回2。</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201221085330.png" alt="暴力枚举"></p><blockquote><p>解题思路一</p></blockquote><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201221085853.png" alt="暴力法"></p><p>还需要 <strong>过滤</strong> 判断字符是否全在arr，也要 <strong>过滤</strong> 没有出现在rest中的字符，被arr选中，无限递归。</p><p>用二维数组存储贴纸</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201221090644.png" alt="存储格式"></p><p>“baabk”代表第一个贴纸，则arr[0]表示完整字符串，index0表示a出现的次数。</p><p>Code1:</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minStickers1</span><span class="hljs-params">(String[] stickers, String target)</span> </span>&#123;   <span class="hljs-keyword">int</span> n = stickers.length;   <span class="hljs-keyword">int</span>[][] map = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n][<span class="hljs-number">26</span>];   <span class="hljs-comment">// 傻缓存</span>   HashMap&lt;String, Integer&gt; dp = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();   <span class="hljs-comment">// 生成每张贴纸的词频统计</span>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;      <span class="hljs-keyword">char</span>[] str = stickers[i].toCharArray();      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : str) &#123;         map[i][c - <span class="hljs-string">&#x27;a&#x27;</span>]++;      &#125;   &#125;   dp.put(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-number">0</span>);   <span class="hljs-keyword">return</span> process1(dp, map, target);&#125;<span class="hljs-comment">// dp 傻缓存，如果t已经算过了，直接返回dp中的值</span><span class="hljs-comment">// t 剩余的目标</span><span class="hljs-comment">// 0..N每一个字符串所含字符的词频统计</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">process1</span><span class="hljs-params">(HashMap&lt;String, Integer&gt; dp, <span class="hljs-keyword">int</span>[][] map, String rest)</span> </span>&#123;   <span class="hljs-keyword">if</span> (dp.containsKey(rest)) &#123;      <span class="hljs-keyword">return</span> dp.get(rest);   &#125;   <span class="hljs-keyword">int</span> ans = Integer.MAX_VALUE; <span class="hljs-comment">// 使用贴纸数</span>   <span class="hljs-keyword">int</span> n = map.length; <span class="hljs-comment">// n种贴纸</span>   <span class="hljs-comment">// rest词频统计</span>   <span class="hljs-keyword">int</span>[] tmap = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">26</span>];   <span class="hljs-keyword">char</span>[] target = rest.toCharArray();   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : target) &#123;      tmap[c - <span class="hljs-string">&#x27;a&#x27;</span>]++;   &#125;   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;      <span class="hljs-comment">// 找到第一个共同字符词频</span>      <span class="hljs-keyword">if</span> (map[i][target[<span class="hljs-number">0</span>] - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-number">0</span>) &#123;         <span class="hljs-keyword">continue</span>;      &#125;      StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();      <span class="hljs-comment">// 来到第i个贴纸，j枚举从贴纸里面的变化</span>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">26</span>; j++) &#123;         <span class="hljs-comment">// 关于j这个字符，target词频数目大于0</span>         <span class="hljs-keyword">if</span> (tmap[j] &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// j这个字符是target需要的</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; Math.max(<span class="hljs-number">0</span>, tmap[j] - map[i][j]); k++) &#123;               <span class="hljs-comment">// 剪掉贴纸该字符的词频，还剩余多少，存到StringBuilder里面</span>               sb.append((<span class="hljs-keyword">char</span>) (<span class="hljs-string">&#x27;a&#x27;</span> + j));            &#125;         &#125;      &#125;      String s = sb.toString();      <span class="hljs-keyword">int</span> tmp = process1(dp, map, s);      <span class="hljs-keyword">if</span> (tmp != -<span class="hljs-number">1</span>) &#123;         ans = Math.min(ans, <span class="hljs-number">1</span> + tmp);      &#125;   &#125;   dp.put(rest, ans == Integer.MAX_VALUE ? -<span class="hljs-number">1</span> : ans);   <span class="hljs-keyword">return</span> dp.get(rest);&#125;</code></pre><blockquote><p>解题思路二</p></blockquote><p>每次选择不选择全部，先把第一个贴纸用N张，再第二张….类似于货币数组问题</p><p> <strong>不推荐</strong> 可变参数多，可变参数少的， <strong>缓存</strong> 命中率高。</p><h2 id="两个字符串的最长公共子序列问题（第三种模型）"><a href="#两个字符串的最长公共子序列问题（第三种模型）" class="headerlink" title="两个字符串的最长公共子序列问题（第三种模型）"></a>两个字符串的最长公共子序列问题（第三种模型）</h2><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201221121850.png" alt="猜想"></p><p>我们首先认为 dp[i] [j]为str1[0 ~ i]和str2[0 ~ j]的最长公共子序列</p><p>最后求 <strong>右下角</strong></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201221123945.png" alt="求解过程"></p><p>取str1的第一个和后面依次对比</p><p>更改测试用例str2为 12dea3f</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201221124306.png" alt="结果"></p><p>因为str1只拿出一个字符，只要出现了a，后面全是 1</p><p>再改第一列</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201221124459.png" alt="第一列"></p><blockquote><p>第一种情况</p></blockquote><p>既不以str1[i]结尾也不以str2[j]结尾，与i，j无关</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201221124659.png" alt="可能1"></p><p>就是str[i-1] [j-1], 来自于左上角。</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201221125134.png" alt="对应"></p><p> <strong>dp[i - 1] [j - 1]</strong> </p><blockquote><p>第二种情况</p></blockquote><p>以str1[i]结尾但不以str2[j]结尾</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201221125249.png" alt="例子"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201221125350.png" alt="结果"></p><p> <strong>dp[i] [j - 1]</strong></p><blockquote><p>第三种情况</p></blockquote><p>不以str1[i]结尾但以str2[j]结尾</p><p> <strong>dp[i - 1] [j ]</strong></p><blockquote><p>第四种情况</p></blockquote><p>以str1[i]结尾又以str2[j]结尾</p><p>可能条件只有 str1[i] == str2[j]</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201221125724.png" alt="结果"></p><p> <strong>1 + dp[i - 1] [j - 1]</strong></p><p>code:</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lcse</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] str1, <span class="hljs-keyword">char</span>[] str2)</span> </span>&#123;   <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[str1.length][str2.length];   <span class="hljs-comment">// 第一个字符是否相等</span>   dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = str1[<span class="hljs-number">0</span>] == str2[<span class="hljs-number">0</span>] ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;   <span class="hljs-comment">// 做第0列</span>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; str1.length; i++) &#123;      dp[i][<span class="hljs-number">0</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], str1[i] == str2[<span class="hljs-number">0</span>] ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>);   &#125;   <span class="hljs-comment">// 做第0行</span>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; str2.length; j++) &#123;      dp[<span class="hljs-number">0</span>][j] = Math.max(dp[<span class="hljs-number">0</span>][j - <span class="hljs-number">1</span>], str1[<span class="hljs-number">0</span>] == str2[j] ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>);   &#125;   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; str1.length; i++) &#123;      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; str2.length; j++) &#123;         dp[i][j] = Math.max(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]);         <span class="hljs-comment">// 最后在i也在j</span>         <span class="hljs-keyword">if</span> (str1[i] == str2[j]) &#123;            dp[i][j] = Math.max(dp[i][j], dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>);            <span class="hljs-comment">// 既不在i也不在j</span>         &#125;<span class="hljs-keyword">else</span> &#123;            dp[i][j] = Math.max(dp[i][j], dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]);         &#125;      &#125;   &#125;   <span class="hljs-keyword">return</span> dp[str1.length - <span class="hljs-number">1</span>][str2.length - <span class="hljs-number">1</span>];&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201221130629.png" alt="结果"></p><p>可能性2一定比1大，所以else是可以取出的</p><h2 id="咖啡刷杯子问题（第四种模型）"><a href="#咖啡刷杯子问题（第四种模型）" class="headerlink" title="咖啡刷杯子问题（第四种模型）"></a>咖啡刷杯子问题（第四种模型）</h2><p>给定一个数组，代表每个人喝完咖啡准备刷杯子的时间<br>只有一台咖啡机，一次只能洗一个杯子，时间耗费a，洗完才能洗下一杯<br>每个咖啡杯也可以自己挥发干净，时间耗费b，咖啡杯可以并行挥发<br>返回让所有咖啡杯变干净的最早完成时间<br>三个参数：int[] arr、int a、int b</p><pre><code class="hljs java"><span class="hljs-comment">// a 洗咖啡机所需时间</span><span class="hljs-comment">// b 自然挥发时间</span><span class="hljs-comment">// drinks每一个员工喝完咖啡时间</span><span class="hljs-comment">// drinks[0...index - 1] 已经洗完</span><span class="hljs-comment">// washLine机器什么时候可用</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">process</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] drinks, <span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> washLine)</span> </span>&#123;   <span class="hljs-keyword">if</span> (index == drinks.length - <span class="hljs-number">1</span>) &#123;      <span class="hljs-keyword">return</span> Math.min(            <span class="hljs-comment">// （咖啡机有空时间点 和 我喝完时间点） 的最大值 + 机器洗完</span>            Math.max(washLine, drinks[index]) + a,            <span class="hljs-comment">// 喝完时间点 + 挥发完时间</span>            drinks[index] + b);   &#125;   <span class="hljs-comment">// wash是我当前的咖啡杯，洗完的时间</span>   <span class="hljs-keyword">int</span> wash = Math.max(washLine, drinks[index]) + a;   <span class="hljs-comment">// 让index + 1以及后面所有咖啡杯变干净的最早时间</span>   <span class="hljs-keyword">int</span> next1 = process(drinks, a, b, index + <span class="hljs-number">1</span>, wash);   <span class="hljs-comment">// 既要自己洗完 也要其他都洗完 才能整体都完</span>   <span class="hljs-keyword">int</span> p1 = Math.max(wash, next1);   <span class="hljs-comment">// 去挥发</span>   <span class="hljs-keyword">int</span> dry = drinks[index] + b;   <span class="hljs-keyword">int</span> next2 = process(drinks, a, b, index + <span class="hljs-number">1</span>, washLine);   <span class="hljs-keyword">int</span> p2 = Math.max(dry, next2);   <span class="hljs-keyword">return</span> Math.min(p1, p2);&#125;</code></pre><p>改为动态规划：</p><p>int washLine寻求最夸张的值（全洗）</p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201221144225.png" alt="初始化dp" style="zoom:50%;" /><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201221144423.png" alt="定数"></p>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring Cloud 学习笔记</title>
    <link href="/2020/11/18/Spring%20Cloud%20%E5%AD%A6%E4%B9%A0/"/>
    <url>/2020/11/18/Spring%20Cloud%20%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Spring-Cloud-初识"><a href="#Spring-Cloud-初识" class="headerlink" title="Spring Cloud 初识"></a>Spring Cloud 初识</h1><h2 id="谈谈微服务"><a href="#谈谈微服务" class="headerlink" title="谈谈微服务"></a>谈谈微服务</h2><blockquote><p>微服务是什么？</p></blockquote><h3 id="1、单体阶段"><a href="#1、单体阶段" class="headerlink" title="1、单体阶段"></a>1、单体阶段</h3><blockquote><p>下列开篇引用自 <a href="https://www.jianshu.com/p/7293b148028f">简书</a></p></blockquote><p>​    相对的，要理解什么是<strong>微服务</strong>，那么可以先理解什么是<strong>单体应用</strong>，在没有提出微服务的概念的“远古”年代，一个软件应用，往往会将应用所有功能都开发和打包在一起，那时候的一个B/S应用架构往往是这样的：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/imgimage-20201119161928480.png" alt="B/S"></p><p>但是，当用户访问量变大导致一台服务器无法支撑时怎么办呢？加服务器加负载均衡，架构就变成这样了：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/imgimage-20201119161940457.png" alt="B/S+负载均衡"></p><p>后面发现把静态文件独立出来，通过CDN等手段进行加速，可以提升应用的整体相应，单体应用的架构就变成：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/imgimage-20201119161950668.png" alt="B/S+前后端分离"></p><p>上面3中架构都还是单体应用，只是在<strong>部署方面</strong>进行了优化，所以避免不了单体应用的根本的缺点：</p><ul><li><p>代码<strong>臃肿</strong>，应用启动时间长；（代码超过1G的项目都有！）</p></li><li><p>回归<strong>测试周期长</strong>，修复一个小小bug可能都需要对所有关键业务进行回归测试。</p></li><li><p>应用<strong>容错性差</strong>，某个小小功能的程序错误可能导致整个系统宕机；</p></li><li><p>伸缩困难，单体应用扩展性能时只能整个应用进行扩展，造成计算资源浪费。</p></li><li><p>开发协作困难，一个大型应用系统，可能几十个甚至上百个开发人员，大家都在维护一套代码的话，代码merge复杂度急剧增加。</p></li></ul><h3 id="2、微服务阶段"><a href="#2、微服务阶段" class="headerlink" title="2、微服务阶段"></a>2、微服务阶段</h3><blockquote><p>微服务的出现就是因为原来单体应用架构已经无法满足当前互联网产品的技术需求。</p></blockquote><p>什么样的服务才算微服务呢？</p><ul><li><p><strong>单一职责的</strong>。一个微服务应该都是单一职责的，这才是“微”的体现，一个微服务解决一个业务问题（注意是一个业务问题而不是一个接口）。</p></li><li><p><strong>面向服务的</strong>。将自己的业务能力封装并对外提供服务，这是继承SOA的核心思想，一个微服务本身也可能使用到其它微服务的能力。<br> <strong>我觉得满足以上两点就可以认为典型的微服务。</strong></p></li></ul><h3 id="3、微服务典型架构"><a href="#3、微服务典型架构" class="headerlink" title="3、微服务典型架构"></a>3、微服务典型架构</h3><blockquote><p>微服务架构，核心是为了解决应用微服务化之后的服务治理问题。</p></blockquote><p>​    应用微服务化之后，首先遇到的第一个问题就是<strong>服务发现问题</strong>，一个微服务如何发现其他微服务呢？最简单的方式就是每个微服务里面配置其他微服务的地址，但是当微服务数量众多的时候，这样做明显不现实。所以需要使用到微服务架构中的一个最重要的组件：<strong>服务注册中心</strong>，所有服务都注册到<strong>服务注册中心</strong>，同时也可以从服务注册中心获取当前可用的服务清单：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/imgimage-20201119161902129.png" alt="服务注册中心"></p><p>​    解决服务发现问题后，接着需要解决微服务分布式部署带来的第二个问题：<strong>服务配置管理的问题</strong>。当服务数量超过一定程度之后，如果需要在每个服务里面分别维护每一个服务的配置文件，运维人员估计要哭了。那么，就需要用到微服务架构里面第二个重要的组件：<strong>配置中心</strong>，微服务架构就变成下面这样了：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/imgimage-20201119162034804.png" alt="配置中心"></p><p>​    以上应用内部的服务治理，当<strong>客户端或外部应用调用服务</strong>的时候怎么处理呢？服务A可能有多个节点，服务A、服务B和服务C的服务地址都不同，服务授权验证在哪里做？这时，就需要使用到<strong>服务网关</strong>提供统一的服务入口，最终形成典型微服务架构：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/imgimage-20201119162157483.png" alt="典型微服务架构"></p><p>​    上面是一个典型的微服务架构，当然微服务的服务治理还涉及很多内容，比如：</p><ul><li>通过熔断、限流等机制保证高可用；</li><li>微服务之间调用的负载均衡；</li><li>分布式事务（2PC、3PC、TCC、LCN等）；</li><li>服务调用链跟踪等等。</li></ul><h2 id="Spring-Cloud-gt-微服务框架"><a href="#Spring-Cloud-gt-微服务框架" class="headerlink" title="Spring Cloud -&gt; 微服务框架"></a>Spring Cloud -&gt; 微服务框架</h2><blockquote><p>由此，Spring Cloud=分布式微服务架构的一站式解决方案，是多种微服务架构落地技术的集合体，俗称微服务全家桶。</p></blockquote><p><strong>“COORDINATE ANYTHING:DISTRIBUTED SYSTEMS SIMPLIFIED”</strong></p><pre><code> `Spring Cloud` 就是微服务系统架构的一站式解决方案，在平时我们构建微服务的过程中需要做如 **服务发现注册** 、**配置中心** 、**消息总线** 、**负载均衡** 、**断路器** 、**数据监控** 等操作，而 Spring Cloud 为我们提供了一套简易的编程模型，使我们能在 Spring Boot 的基础上轻松地实现微服务项目的构建。</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/imgimage-20201119163743535.png" alt="spring cloud 蕴含技术栈"></p><h3 id="1、Spring-Cloud版本选型"><a href="#1、Spring-Cloud版本选型" class="headerlink" title="1、Spring Cloud版本选型"></a>1、Spring Cloud版本选型</h3><blockquote><p>SpringCloud采用了英国伦敦地铁站的名称来命名, 并由地铁站名称字母A-Z依次类推的形式来发布迭代版本。</p></blockquote><p>​    SpringCloud是一个由许多子项目组成的综合项目, 各子项目有不同的发布节奏, 为了管理SpringCloud与各个子项目的版本依赖关系, 发布了一个清单, 其中包括了某个SpringCloud版本对应的子项目版本. 为了避免SpringCloud版本号与子项目版本号混淆, <strong>SpringCloud版本采用了名称而非版本号的命名, 这些版本的名字采用了伦敦地铁站的名字, 根据字母表的顺序来对应版本时间顺序</strong>. 例如Angel是第一个版本, Brixton是第二个版本. 当SpringCloud的发布内容积累到临界点或者一个重大BUG被解决后, 会发布一个”service releases”版本, 简称SRX版本, 比如Greenwich.SR2就是SpringCloud发布的Greenwich版本的第二个SRX版本.</p><table><thead><tr><th align="left">Release Train</th><th align="left">Boot Version</th></tr></thead><tbody><tr><td align="left">2020.0.x aka Ilford</td><td align="left">2.4.x</td></tr><tr><td align="left"><a href="https://github.com/spring-projects/spring-cloud/wiki/Spring-Cloud-Hoxton-Release-Notes">Hoxton</a></td><td align="left">2.2.x, 2.3.x (Starting with SR5)</td></tr><tr><td align="left"><a href="https://github.com/spring-projects/spring-cloud/wiki/Spring-Cloud-Greenwich-Release-Notes">Greenwich</a></td><td align="left">2.1.x</td></tr><tr><td align="left"><a href="https://github.com/spring-projects/spring-cloud/wiki/Spring-Cloud-Finchley-Release-Notes">Finchley</a></td><td align="left">2.0.x</td></tr><tr><td align="left"><a href="https://github.com/spring-projects/spring-cloud/wiki/Spring-Cloud-Edgware-Release-Notes">Edgware</a></td><td align="left">1.5.x</td></tr><tr><td align="left"><a href="https://github.com/spring-projects/spring-cloud/wiki/Spring-Cloud-Dalston-Release-Notes">Dalston</a></td><td align="left">1.5.x</td></tr></tbody></table><blockquote><p> [spring官网][<a href="https://spring.io/projects/spring-cloud]%E6%9F%A5%E7%9C%8B%E7%89%88%E6%9C%AC%E9%80%89%E5%9E%8B[json][https://start.spring.io/actuator/info]">https://spring.io/projects/spring-cloud]查看版本选型[json][https://start.spring.io/actuator/info]</a></p></blockquote><h3 id="2、学习技术选型"><a href="#2、学习技术选型" class="headerlink" title="2、学习技术选型"></a>2、学习技术选型</h3><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/imgimage-20201119170031804.png" alt="技术版本选择" style="zoom:33%;" /><h3 id="3、Spring-Cloud组件停更升级以及替换"><a href="#3、Spring-Cloud组件停更升级以及替换" class="headerlink" title="3、Spring Cloud组件停更升级以及替换"></a>3、Spring Cloud组件停更升级以及替换</h3><p>​    1,服务注册中心,Eureka停用,zookeeper, Consul, Cloud Alibaba Nacos</p><p>​    2,服务调用,Ribbon准备停更,代替为LoadBalance</p><p>​    3,服务调用2,Feign改为OpenFeign</p><p>​    4,服务降级,Hystrix停更,改为resilence4j,Cloud Alibaba sentienl</p><p>​    5.服务网关,Zuul改为gateway    </p><p>​    6,服务配置Config改为Cloud Alibaba Nacos</p><p>​    7,服务总线Bus改为Cloud Alibaba Nacos</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/imgimage-20201119172251583.png" alt="cloud 技术更新情况"></p><h3 id="4、学习文档"><a href="#4、学习文档" class="headerlink" title="4、学习文档"></a>4、学习文档</h3><blockquote><p><a href="https://cloud.spring.io/spring-cloud-static/Hoxton.SR1/reference/htmlsingle/">spring cloud</a>        <a href="https://www.bookstack.cn/read/spring-cloud-docs/docs-index.md">中文</a> HSR1.</p><p><a href="https://docs.spring.io/spring-boot/docs/2.2.2.RELEASE/reference/htmlsingle/">spring boot</a>        2.2.2.</p></blockquote><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="1、关于dependencyManagement"><a href="#1、关于dependencyManagement" class="headerlink" title="1、关于dependencyManagement"></a>1、关于dependencyManagement</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/imgimage-20201119183455723.png" alt="dependencyManagement详解"></p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/imgimage-20201119183718866.png" alt="maven跳过单元测试" style="zoom:67%;" /><h3 id="2、构建cloud-provider-payment8001工程实现微服务提供者"><a href="#2、构建cloud-provider-payment8001工程实现微服务提供者" class="headerlink" title="2、构建cloud-provider-payment8001工程实现微服务提供者"></a>2、构建cloud-provider-payment8001工程实现微服务提供者</h3><p>由于cloud学习, 对于Spring Boot操作不过多阐述.该Module中主要提供create和get方法操作</p><pre><code class="hljs java"><span class="hljs-meta">@NoArgsConstructor</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Payment</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;    <span class="hljs-keyword">private</span> Long id;    <span class="hljs-keyword">private</span> String serial;&#125;</code></pre><p>相应dao、service层不过多阐述.</p><p>controller层业务代码:</p><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-meta">@Slf4j</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PaymentController</span> </span>&#123;    <span class="hljs-meta">@Resource</span>    <span class="hljs-keyword">private</span> PaymentService paymentService;    <span class="hljs-meta">@PostMapping(value = &quot;/payment/create&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> CommonResult <span class="hljs-title">create</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> Payment payment)</span> </span>&#123;        <span class="hljs-keyword">int</span> resultRows = paymentService.create(payment);        log.info(<span class="hljs-string">&quot;******插入结果:&quot;</span> + resultRows);        <span class="hljs-keyword">if</span> (resultRows &gt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CommonResult(<span class="hljs-number">200</span>, <span class="hljs-string">&quot;插入数据库成功&quot;</span>, resultRows);        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CommonResult(<span class="hljs-number">444</span>, <span class="hljs-string">&quot;插入数据库失败&quot;</span>);        &#125;    &#125;    <span class="hljs-meta">@GetMapping(value = &quot;/payment/get/&#123;id&#125;&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> CommonResult <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Long id)</span> </span>&#123;        Payment payment = paymentService.getPaymentById(id);        log.info(<span class="hljs-string">&quot;******查询结果:&quot;</span> + payment);        <span class="hljs-keyword">if</span> (payment != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CommonResult(<span class="hljs-number">200</span>, <span class="hljs-string">&quot;查询数据库成功&quot;</span>, payment);        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CommonResult(<span class="hljs-number">444</span>, <span class="hljs-string">&quot;查询数据库失败&quot;</span> + id);        &#125;    &#125;&#125;</code></pre><h3 id="3、构建cloud-consumer-order80工程实现客户端消费者"><a href="#3、构建cloud-consumer-order80工程实现客户端消费者" class="headerlink" title="3、构建cloud-consumer-order80工程实现客户端消费者"></a>3、构建cloud-consumer-order80工程实现客户端消费者</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201121174959.png" alt="项目结构"></p><p>​    因为这里是消费者类, 主要是消费, 那么就没有service和dao, 需要调用pay模块的方法, 并且这里还没有微服务的远程调用, 那么如果要调用另外一个模块, 则需要使用基本的api调用.这里我们使用RestTemplate使得微服务消费者80调用微服务提供者8001.</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201121175514.png" alt="RestTemplate功能和使用"></p><p>对应注入:</p><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApplicationContextConfig</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> RestTemplate <span class="hljs-title">getRestTemplate</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RestTemplate();    &#125;&#125;</code></pre><p>controller层业务代码:</p><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-meta">@Slf4j</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderController</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String PAYMENT_URL = <span class="hljs-string">&quot;http://localhost:8001&quot;</span>;    <span class="hljs-meta">@Resource</span>    <span class="hljs-keyword">private</span> RestTemplate restTemplate;    <span class="hljs-meta">@GetMapping(&quot;/consumer/payment/create&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> CommonResult&lt;Payment&gt; <span class="hljs-title">create</span><span class="hljs-params">(Payment payment)</span></span>&#123;        <span class="hljs-keyword">return</span> restTemplate.postForObject(PAYMENT_URL + <span class="hljs-string">&quot;/payment/create&quot;</span>, payment, CommonResult.class);    &#125;    <span class="hljs-meta">@GetMapping(&quot;/consumer/payment/get/&#123;id&#125;&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> CommonResult&lt;Payment&gt; <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Long id)</span></span>&#123;        <span class="hljs-keyword">return</span> restTemplate.getForObject(PAYMENT_URL + <span class="hljs-string">&quot;/payment/get/&quot;</span> + id, CommonResult.class);    &#125;&#125;</code></pre><h3 id="4、entity实体类放入cloud-api-commons中"><a href="#4、entity实体类放入cloud-api-commons中" class="headerlink" title="4、entity实体类放入cloud-api-commons中"></a>4、entity实体类放入cloud-api-commons中</h3><p>其他工程加入即可</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.study.springcloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>cloud-api-commons<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;project.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><h1 id="服务注册与发现"><a href="#服务注册与发现" class="headerlink" title="服务注册与发现"></a>服务注册与发现</h1><h2 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h2><h3 id="1、Eureka基础知识"><a href="#1、Eureka基础知识" class="headerlink" title="1、Eureka基础知识"></a>1、Eureka基础知识</h3><p>​    前面我们没有服务注册中心, 也可以服务间调用,为什么还要服务注册?</p><p>​    当服务很多时, 单靠代码手动管理是很麻烦的, 需要一个公共组件, 统一管理多服务, 包括服务是否正常运行等.Eureka用于<strong>服务注册</strong>, 目前官网<strong>已经停止更新</strong>.</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201121194357.png" alt="什么是服务治理?"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201121194553.png" alt="什么是服务注册与发现"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201121195221.png" alt="Eureka两个组件"></p><h3 id="2、单机版Eureka构建"><a href="#2、单机版Eureka构建" class="headerlink" title="2、单机版Eureka构建"></a>2、单机版Eureka构建</h3><pre><code>#### a、 POM依赖</code></pre><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- eureka-server --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><h4 id="b、yaml配置"><a href="#b、yaml配置" class="headerlink" title="b、yaml配置"></a>b、yaml配置</h4><pre><code class="hljs yaml"><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">7001</span><span class="hljs-attr">eureka:</span>  <span class="hljs-attr">instance:</span>    <span class="hljs-attr">hostname:</span> <span class="hljs-string">localhost</span> <span class="hljs-comment">#eureka服务端的实例名称</span>  <span class="hljs-attr">client:</span>    <span class="hljs-comment">#false表示不向注册中心注册自己。</span>    <span class="hljs-attr">register-with-eureka:</span> <span class="hljs-literal">false</span>    <span class="hljs-comment">#false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务</span>    <span class="hljs-attr">fetch-registry:</span> <span class="hljs-literal">false</span>    <span class="hljs-attr">service-url:</span>      <span class="hljs-comment">#设置与Eureka Server交互的地址查询服务和注册服务都需要依赖这个地址。</span>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/</span></code></pre><h4 id="c、主启动类"><a href="#c、主启动类" class="headerlink" title="c、主启动类"></a>c、主启动类</h4><pre><code class="hljs java"><span class="hljs-meta">@EnableEurekaServer</span></code></pre><p>启动访问<a href="http://localhost:7001/">http://localhost:7001/</a></p><h4 id="d、服务入驻"><a href="#d、服务入驻" class="headerlink" title="d、服务入驻"></a>d、服务入驻</h4><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--eureka client--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>​    添加至cloud-provider-payment8001</p><p>修改yaml配置文件</p><pre><code class="hljs yaml"><span class="hljs-attr">eureka:</span>  <span class="hljs-attr">client:</span>    <span class="hljs-comment">#表示是否将自己注册进EurekaServer 默认为true</span>    <span class="hljs-attr">register-with-eureka:</span> <span class="hljs-literal">true</span>    <span class="hljs-comment">#是否从EurekaServer抓取已有的注册信息，默认为true。单节点无所谓，集群必须true才能配合ribbon负载均衡</span>    <span class="hljs-attr">fetch-registry:</span> <span class="hljs-literal">true</span>    <span class="hljs-attr">service-url:</span>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://localhost:7001/eureka</span></code></pre><p>主启动类添加</p><pre><code class="hljs java"><span class="hljs-meta">@EnableEurekaClient</span></code></pre><p>对于cloud-consumer-order80工程一样处理</p><h4 id="e、测试"><a href="#e、测试" class="headerlink" title="e、测试"></a>e、测试</h4><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201121202144.png" alt="测试"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201121202649.png" alt="测试"></p><blockquote><p>好家伙 我直接好家伙 已经开始卡了</p></blockquote><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201121203224.png" alt="内存占用"></p><h3 id="番外-“-eureka”到底是什么"><a href="#番外-“-eureka”到底是什么" class="headerlink" title="番外: “/eureka”到底是什么?"></a>番外: “/eureka”到底是什么?</h3><blockquote><p> 部署eureka集群时defaultZone中为什么必须包含路径/eureka？<a href="https://www.cnblogs.com/StarkBrothers/archive/2004/01/13/11974026.html">引用</a></p></blockquote><p>​    待深入了解中…..</p><h3 id="3、集群版Eureka构建"><a href="#3、集群版Eureka构建" class="headerlink" title="3、集群版Eureka构建"></a>3、集群版Eureka构建</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201121205728.png" alt="集群Eureka"></p><p>1,就是pay模块启动时,注册自己,并且自身信息也放入eureka<br>2.order模块,首先也注册自己,放入信息,当要调用pay时,先从eureka拿到pay的调用地址<br>3.通过HttpClient调用并且还会缓存一份到本地,每30秒更新一次 </p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201121210043.png" alt="题"></p><h4 id="A、注册原理"><a href="#A、注册原理" class="headerlink" title="A、注册原理"></a>A、注册原理</h4><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201121210334.png" alt="互相注册, 相互守望" style="zoom:67%;" /><h5 id="a、创建"><a href="#a、创建" class="headerlink" title="a、创建"></a>a、创建</h5><h5 id="b、POM引入-写YML"><a href="#b、POM引入-写YML" class="headerlink" title="b、POM引入 写YML"></a>b、POM引入 写YML</h5><p>7001改yaml:</p><pre><code class="hljs yaml"><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">7001</span><span class="hljs-attr">eureka:</span>  <span class="hljs-attr">instance:</span>    <span class="hljs-attr">hostname:</span> <span class="hljs-string">eureka7001.com</span> <span class="hljs-comment">#eureka服务端的实例名称</span>  <span class="hljs-attr">client:</span>    <span class="hljs-comment">#false表示不向注册中心注册自己。</span>    <span class="hljs-attr">register-with-eureka:</span> <span class="hljs-literal">false</span>    <span class="hljs-comment">#false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务</span>    <span class="hljs-attr">fetch-registry:</span> <span class="hljs-literal">false</span>    <span class="hljs-attr">service-url:</span>      <span class="hljs-comment">#设置与Eureka Server交互的地址查询服务和注册服务都需要依赖这个地址。</span>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://eureka7002.com:7002/eureka/</span></code></pre><p>7002:改yaml</p><pre><code class="hljs yaml"><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">7002</span><span class="hljs-attr">eureka:</span>  <span class="hljs-attr">instance:</span>    <span class="hljs-attr">hostname:</span> <span class="hljs-string">eureka7002.com</span> <span class="hljs-comment">#eureka服务端的实例名称</span>  <span class="hljs-attr">client:</span>    <span class="hljs-comment">#false表示不向注册中心注册自己。</span>    <span class="hljs-attr">register-with-eureka:</span> <span class="hljs-literal">false</span>    <span class="hljs-comment">#false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务</span>    <span class="hljs-attr">fetch-registry:</span> <span class="hljs-literal">false</span>    <span class="hljs-attr">service-url:</span>      <span class="hljs-comment">#设置与Eureka Server交互的地址查询服务和注册服务都需要依赖这个地址。</span>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://eureka7001.com:7001/eureka/</span></code></pre><h5 id="c、修改Hosts配置文件模拟集群"><a href="#c、修改Hosts配置文件模拟集群" class="headerlink" title="c、修改Hosts配置文件模拟集群"></a>c、修改Hosts配置文件模拟集群</h5><p>sudo vim /etc/hosts</p><p>#eureka<br>127.0.0.1       eureka7001.com<br>127.0.0.1       eureka7002.com</p><h5 id="d、写主启动类"><a href="#d、写主启动类" class="headerlink" title="d、写主启动类"></a>d、写主启动类</h5><h5 id="e、测试-1"><a href="#e、测试-1" class="headerlink" title="e、测试"></a>e、测试</h5><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201121212034.png" alt="测试成功" style="zoom: 50%;" /><h4 id="B、订单支付微服务入驻Eureka集群"><a href="#B、订单支付微服务入驻Eureka集群" class="headerlink" title="B、订单支付微服务入驻Eureka集群"></a>B、订单支付微服务入驻Eureka集群</h4><pre><code class="hljs yaml"><span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka</span> <span class="hljs-comment">#集群版</span></code></pre><p>修改yaml文件即可, 测试:</p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201121212825.png" alt="test" style="zoom: 33%;" /><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201121212948.png" alt="服务无影响" style="zoom:33%;" /><h3 id="4、将支付微服务集群配置"><a href="#4、将支付微服务集群配置" class="headerlink" title="4、将支付微服务集群配置"></a>4、将支付微服务集群配置</h3><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201121220116.png" alt="集群图" style="zoom: 25%;" /><h4 id="a、复制粘贴8001，改端口"><a href="#a、复制粘贴8001，改端口" class="headerlink" title="a、复制粘贴8001，改端口"></a>a、复制粘贴8001，改端口</h4><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201121214455.png" alt="eureka显示"></p><h4 id="b、修改80消费者controller调用时候的url"><a href="#b、修改80消费者controller调用时候的url" class="headerlink" title="b、修改80消费者controller调用时候的url"></a>b、修改80消费者controller调用时候的url</h4><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-meta">@Slf4j</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderController</span> </span>&#123;    <span class="hljs-comment">// private static final String PAYMENT_URL = &quot;http://localhost:8001&quot;;</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String PAYMENT_URL = <span class="hljs-string">&quot;http://CLOUD-PAYMENT-SERVICE&quot;</span>;    <span class="hljs-meta">@Resource</span>    <span class="hljs-keyword">private</span> RestTemplate restTemplate;    <span class="hljs-meta">@GetMapping(&quot;/consumer/payment/create&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> CommonResult&lt;Payment&gt; <span class="hljs-title">create</span><span class="hljs-params">(Payment payment)</span></span>&#123;        <span class="hljs-keyword">return</span> restTemplate.postForObject(PAYMENT_URL + <span class="hljs-string">&quot;/payment/create&quot;</span>, payment, CommonResult.class);    &#125;    <span class="hljs-meta">@GetMapping(&quot;/consumer/payment/get/&#123;id&#125;&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> CommonResult&lt;Payment&gt; <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Long id)</span></span>&#123;        <span class="hljs-keyword">return</span> restTemplate.getForObject(PAYMENT_URL + <span class="hljs-string">&quot;/payment/get/&quot;</span> + id, CommonResult.class);    &#125;&#125;</code></pre><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201121214634.png" alt="8001与8002服务均启动" style="zoom:50%;" /><h4 id="c、开启负载均衡注解"><a href="#c、开启负载均衡注解" class="headerlink" title="c、开启负载均衡注解"></a>c、开启负载均衡注解</h4><p>需要让RestTemplate开启负载均衡注解, 还可以指定负载均衡算法, 默认<strong>轮询</strong>, 各自一次</p><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApplicationContextConfig</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-meta">@LoadBalanced</span> <span class="hljs-comment">// 负载均衡</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> RestTemplate <span class="hljs-title">getRestTemplate</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RestTemplate();    &#125;&#125;</code></pre><h4 id="d、修改服务主机名和ip在eureka的web上显示"><a href="#d、修改服务主机名和ip在eureka的web上显示" class="headerlink" title="d、修改服务主机名和ip在eureka的web上显示"></a>d、修改服务主机名和ip在eureka的web上显示</h4><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201121221649.png" alt="yaml"></p><h3 id="5、服务发现Discovery"><a href="#5、服务发现Discovery" class="headerlink" title="5、服务发现Discovery"></a>5、服务发现Discovery</h3><p>对于注册进Eureka里的微服务, 可以通过服务发现来获得该服务的信息</p><p>以Payment8001为模版:</p><h4 id="a、修改cloud-provider-payment8001的Controller"><a href="#a、修改cloud-provider-payment8001的Controller" class="headerlink" title="a、修改cloud-provider-payment8001的Controller"></a>a、修改cloud-provider-payment8001的Controller</h4><pre><code class="hljs java"><span class="hljs-meta">@Resource</span><span class="hljs-keyword">private</span> DiscoveryClient discoveryClient;</code></pre><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(value = &quot;/payment/discovery&quot;)</span><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">discovery</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// 得到服务信息</span>    List&lt;String&gt; services = discoveryClient.getServices();    <span class="hljs-keyword">for</span> (String service : services) &#123;        log.info(<span class="hljs-string">&quot;*****element:&quot;</span>+service);    &#125;    List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances(<span class="hljs-string">&quot;cloud-payment-service&quot;</span>);    <span class="hljs-keyword">for</span> (ServiceInstance instance : instances) &#123;        log.info(<span class="hljs-string">&quot;*****id:&quot;</span>+instance.getServiceId());        log.info(<span class="hljs-string">&quot;*****host:&quot;</span>+instance.getHost());        log.info(<span class="hljs-string">&quot;*****port:&quot;</span>+instance.getPort());        log.info(<span class="hljs-string">&quot;*****uri:&quot;</span>+instance.getUri());    &#125;        <span class="hljs-keyword">return</span> discoveryClient;</code></pre><h4 id="b、-修改主启动类"><a href="#b、-修改主启动类" class="headerlink" title="b、 修改主启动类"></a>b、 修改主启动类</h4><pre><code class="hljs java"><span class="hljs-meta">@EnableDiscoveryClient</span></code></pre><h4 id="c、测试"><a href="#c、测试" class="headerlink" title="c、测试"></a>c、测试</h4><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201121222843.png" alt="test" style="zoom: 50%;" /><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201121223049.png" alt="log" style="zoom: 50%;" /><h3 id="6、Eureka自我保护"><a href="#6、Eureka自我保护" class="headerlink" title="6、Eureka自我保护"></a>6、Eureka自我保护</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201121223452.png" alt="eureka提示"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201121224343.png" alt="保护概念"></p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201123140710.png" alt="心跳包" style="zoom:67%;" /><h3 id="7、Eureka自我保护关闭"><a href="#7、Eureka自我保护关闭" class="headerlink" title="7、Eureka自我保护关闭"></a>7、Eureka自我保护关闭</h3><blockquote><p>一般生产环境中不会禁止自我保护</p></blockquote><pre><code class="hljs yaml"><span class="hljs-comment"># 服务端配置</span><span class="hljs-attr">eureka:</span>   <span class="hljs-attr">server:</span>    <span class="hljs-comment"># 关闭自我保护 </span>    <span class="hljs-attr">enable-self-preservation:</span> <span class="hljs-literal">false</span>    <span class="hljs-comment"># 接受心跳包时间间隔</span>    <span class="hljs-attr">eviction-interval-timer-in-ms:</span> <span class="hljs-number">2000</span></code></pre><pre><code class="hljs yaml"><span class="hljs-comment"># 客户端配置</span><span class="hljs-comment"># 心跳检测和续约时间</span><span class="hljs-attr">instance:</span>  <span class="hljs-comment"># Eureka客户端向服务端发送心跳的时间间隔, 单位为秒(默认30s)</span>  <span class="hljs-attr">lease-renewal-interval-in-seconds:</span> <span class="hljs-number">30</span>  <span class="hljs-comment"># Eureka服务端收到最后一次心跳等待服务时间上限, 默认90s, 超时则剔除服务</span>  <span class="hljs-attr">lease-expiration-duration-in-seconds:</span> <span class="hljs-number">90</span></code></pre><h3 id="8、Eureka停更"><a href="#8、Eureka停更" class="headerlink" title="8、Eureka停更"></a>8、Eureka停更</h3><blockquote><p><a href="https://github.com/Netflix/eureka/wiki">官网</a></p></blockquote><h2 id="Zookeeper-替换Eureka-服务注册与发现"><a href="#Zookeeper-替换Eureka-服务注册与发现" class="headerlink" title="Zookeeper(替换Eureka) 服务注册与发现"></a>Zookeeper(替换Eureka) 服务注册与发现</h2><blockquote><p>zookeeper是一个分布式协调工具，可以实现注册中心功能</p></blockquote><h3 id="1、-安装zookeeper-cloud-provider-payment8004入驻"><a href="#1、-安装zookeeper-cloud-provider-payment8004入驻" class="headerlink" title="1、 安装zookeeper(cloud-provider-payment8004入驻)"></a>1、 安装zookeeper(cloud-provider-payment8004入驻)</h3><h4 id="a、在aliyun服务器安装zookeeper并关闭防火墙（aliyun开了kafka-2181被kafka自己的zookeeper占用-改用自己mac开启zookeeper）"><a href="#a、在aliyun服务器安装zookeeper并关闭防火墙（aliyun开了kafka-2181被kafka自己的zookeeper占用-改用自己mac开启zookeeper）" class="headerlink" title="a、在aliyun服务器安装zookeeper并关闭防火墙（aliyun开了kafka 2181被kafka自己的zookeeper占用 改用自己mac开启zookeeper）"></a>a、在aliyun服务器安装zookeeper并关闭防火墙（aliyun开了kafka 2181被kafka自己的zookeeper占用 改用自己mac开启zookeeper）</h4><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201123143814.png" alt="服务器" style="zoom:50%;" /><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201123152949.png" alt="mymac" style="zoom:50%;" /><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201123153358.png" alt="进入zkCli" style="zoom:50%;" /><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201123153134.png" alt="防火墙关闭" style="zoom:50%;" /><blockquote><p>ifconfig | grep “inet “ | grep -v 127.0.0.1 mac查看自己ip </p></blockquote><h4 id="b、构建cloud-provider-payment8004工程"><a href="#b、构建cloud-provider-payment8004工程" class="headerlink" title="b、构建cloud-provider-payment8004工程"></a>b、构建cloud-provider-payment8004工程</h4><p>POM.xml:</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-zookeeper-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>yaml:</p><pre><code class="hljs yaml"><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">8004</span><span class="hljs-attr">spring:</span>  <span class="hljs-attr">application:</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">cloud-payment-service</span>  <span class="hljs-attr">cloud:</span>    <span class="hljs-attr">zookeeper:</span>      <span class="hljs-attr">connect-string:</span> <span class="hljs-number">101.37</span><span class="hljs-number">.162</span><span class="hljs-number">.1</span><span class="hljs-string">:2181</span></code></pre><p>主启动类:</p><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-meta">@EnableDiscoveryClient</span> <span class="hljs-comment">// 该注解用于向consul或者zookeeper作为注册中心时注册服务</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PaymentMain8004</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(PaymentMain8004.class, args);    &#125;&#125;</code></pre><p>Controller:</p><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-meta">@Slf4j</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PaymentController</span> </span>&#123;    <span class="hljs-meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span>    <span class="hljs-keyword">private</span> String serverPort;    <span class="hljs-meta">@RequestMapping(value = &quot;/payment/zk&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">zk</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;zookeeper:&quot;</span> + serverPort + UUID.randomUUID().toString();    &#125;&#125;</code></pre><p>修改pom:</p><blockquote><p>解决jar包不一致问题</p></blockquote><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--SpringBoot整合Zookeeper客户端--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-zookeeper-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span>        <span class="hljs-comment">&lt;!--先排除自带的zookeeper3.5.3--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.zookeeper<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>zookeeper<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!--添加zookeeper3.4.14版本--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.zookeeper<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>zookeeper<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.4.14<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201123153935.png" alt="测试结果"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201123154156.png" alt="zookeeper前后变化"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201123154124.png" alt="客户端访问结果"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201123154249.png" alt="结果"></p><h3 id="2、思考"><a href="#2、思考" class="headerlink" title="2、思考"></a>2、思考</h3><p>我们把Zookeeper ls到底并get</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201123154610.png" alt="疑问"></p><p>得到一份json字符串并解析:</p><pre><code class="hljs json">&#123;  <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;cloud-payment-service&quot;</span>,  <span class="hljs-attr">&quot;id&quot;</span>: <span class="hljs-string">&quot;ccf0aff6-d8d8-4730-acca-b035c7b424a4&quot;</span>,  <span class="hljs-attr">&quot;address&quot;</span>: <span class="hljs-string">&quot;10.240.8.173&quot;</span>,  <span class="hljs-attr">&quot;port&quot;</span>: <span class="hljs-number">8004</span>,  <span class="hljs-attr">&quot;sslPort&quot;</span>: <span class="hljs-literal">null</span>,  <span class="hljs-attr">&quot;payload&quot;</span>: &#123;    <span class="hljs-attr">&quot;@class&quot;</span>: <span class="hljs-string">&quot;org.springframework.cloud.zookeeper.discovery.ZookeeperInstance&quot;</span>,    <span class="hljs-attr">&quot;id&quot;</span>: <span class="hljs-string">&quot;application-1&quot;</span>,    <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;cloud-payment-service&quot;</span>,    <span class="hljs-attr">&quot;metadata&quot;</span>: &#123;&#125;  &#125;,  <span class="hljs-attr">&quot;registrationTimeUTC&quot;</span>: <span class="hljs-number">1606116992809</span>,  <span class="hljs-attr">&quot;serviceType&quot;</span>: <span class="hljs-string">&quot;DYNAMIC&quot;</span>,  <span class="hljs-attr">&quot;uriSpec&quot;</span>: &#123;    <span class="hljs-attr">&quot;parts&quot;</span>: [      &#123;        <span class="hljs-attr">&quot;value&quot;</span>: <span class="hljs-string">&quot;scheme&quot;</span>,        <span class="hljs-attr">&quot;variable&quot;</span>: <span class="hljs-literal">true</span>      &#125;,      &#123;        <span class="hljs-attr">&quot;value&quot;</span>: <span class="hljs-string">&quot;://&quot;</span>,        <span class="hljs-attr">&quot;variable&quot;</span>: <span class="hljs-literal">false</span>      &#125;,      &#123;        <span class="hljs-attr">&quot;value&quot;</span>: <span class="hljs-string">&quot;address&quot;</span>,        <span class="hljs-attr">&quot;variable&quot;</span>: <span class="hljs-literal">true</span>      &#125;,      &#123;        <span class="hljs-attr">&quot;value&quot;</span>: <span class="hljs-string">&quot;:&quot;</span>,        <span class="hljs-attr">&quot;variable&quot;</span>: <span class="hljs-literal">false</span>      &#125;,      &#123;        <span class="hljs-attr">&quot;value&quot;</span>: <span class="hljs-string">&quot;port&quot;</span>,        <span class="hljs-attr">&quot;variable&quot;</span>: <span class="hljs-literal">true</span>      &#125;    ]  &#125;&#125;</code></pre><h4 id="a、是临时节点还是持久节点"><a href="#a、是临时节点还是持久节点" class="headerlink" title="a、是临时节点还是持久节点?"></a>a、是临时节点还是持久节点?</h4><blockquote><p>我们在zk上注册的node是临时节点, 当我们的服务一定时间内没有发送心跳, 那么zk就会将这个服务的node删除(只需停掉8004 再查看zk结点)</p></blockquote><h3 id="3、cloud-consumerzk-order80-入驻-zookeeper"><a href="#3、cloud-consumerzk-order80-入驻-zookeeper" class="headerlink" title="3、cloud-consumerzk-order80 入驻 zookeeper"></a>3、cloud-consumerzk-order80 入驻 zookeeper</h3><h4 id="a、构建cloud-consumerzk-order80工程"><a href="#a、构建cloud-consumerzk-order80工程" class="headerlink" title="a、构建cloud-consumerzk-order80工程"></a>a、构建cloud-consumerzk-order80工程</h4><p>POM.xml:如cloud-provider-payment8004一致</p><p>yaml:</p><pre><code class="hljs yaml"><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">80</span><span class="hljs-attr">spring:</span>  <span class="hljs-attr">application:</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">cloud-orderzk-service</span>  <span class="hljs-attr">cloud:</span>    <span class="hljs-attr">zookeeper:</span>      <span class="hljs-attr">connect-string:</span> <span class="hljs-number">10.240</span><span class="hljs-number">.8</span><span class="hljs-number">.173</span><span class="hljs-string">:2181</span></code></pre><p>controller:</p><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderController</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String PAYMENT_URL = <span class="hljs-string">&quot;http://cloud-payment-service&quot;</span>;    <span class="hljs-meta">@Resource</span>    <span class="hljs-keyword">private</span> RestTemplate restTemplate;    <span class="hljs-meta">@GetMapping(&quot;/consumer/payment/zk&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">zk</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> restTemplate.getForObject(PAYMENT_URL + <span class="hljs-string">&quot;/payment/zk&quot;</span>, String.class);    &#125;&#125;</code></pre><h4 id="b、测试"><a href="#b、测试" class="headerlink" title="b、测试"></a>b、测试</h4><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201123161555.png" alt="成功"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201123161638.png" alt="zk"></p><h2 id="Consul"><a href="#Consul" class="headerlink" title="Consul"></a>Consul</h2><blockquote><p>Go语言开发 <a href="https://www.consul.io/intro/index.html">官网</a></p></blockquote><h3 id="1、Consul简介"><a href="#1、Consul简介" class="headerlink" title="1、Consul简介:"></a>1、Consul简介:</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201123162351.png" alt="简介"></p><blockquote><p>Consul能干嘛? <a href="https://www.consul.io/downloads.html">去哪下</a> <a href="https://www.springcloud.cc/spring-cloud-consul.html">怎么玩</a></p></blockquote><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201123162747.png" alt="用途"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201123162632.png" alt="用途"></p><h3 id="2、安装运行"><a href="#2、安装运行" class="headerlink" title="2、安装运行"></a>2、安装运行</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201123171136.png" alt="consul"></p><p>把consul文件复制到/usr/local/bin目录下.</p><blockquote><p>consul agent -dev启用 / Ctrl-C（中断信号）正常停止代理</p></blockquote><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201123171658.png" alt="8500端口"></p><h3 id="3、新建Module支付服务cloud-providerconsul-payment8006"><a href="#3、新建Module支付服务cloud-providerconsul-payment8006" class="headerlink" title="3、新建Module支付服务cloud-providerconsul-payment8006"></a>3、新建Module支付服务cloud-providerconsul-payment8006</h3><p>Pom.xml:</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--SpringCloud consul-server--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-consul-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>yaml:</p><pre><code class="hljs yaml"><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">8006</span><span class="hljs-attr">spring:</span>  <span class="hljs-attr">application:</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">cloud-payment-service</span>  <span class="hljs-attr">cloud:</span>    <span class="hljs-attr">consul:</span>      <span class="hljs-attr">host:</span> <span class="hljs-string">localhost</span>      <span class="hljs-attr">port:</span> <span class="hljs-number">8500</span>      <span class="hljs-attr">discovery:</span>        <span class="hljs-comment">#hostname: 127.0.0.1</span>        <span class="hljs-attr">service-name:</span> <span class="hljs-string">$&#123;spring.application.name&#125;</span></code></pre><p>Controller:</p><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-meta">@Slf4j</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PaymentController</span> </span>&#123;    <span class="hljs-meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span>    <span class="hljs-keyword">private</span> String serverPort;    <span class="hljs-meta">@RequestMapping(value = &quot;/payment/consul&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">consul</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;consul:&quot;</span> + serverPort + UUID.randomUUID().toString();    &#125;&#125;</code></pre><p>测试:</p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201123191757.png" alt="测试" style="zoom:50%;" /><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201123192023.png" alt="test"></p><h3 id="4、新建Module消费服务cloud-consumerconsul-order80"><a href="#4、新建Module消费服务cloud-consumerconsul-order80" class="headerlink" title="4、新建Module消费服务cloud-consumerconsul-order80"></a>4、新建Module消费服务cloud-consumerconsul-order80</h3><p>​   pom与8006一致</p><p>​   yml:</p><pre><code class="hljs yaml"><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">80</span><span class="hljs-attr">spring:</span>  <span class="hljs-attr">application:</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">cloud-order-service</span>  <span class="hljs-attr">cloud:</span>    <span class="hljs-attr">consul:</span>      <span class="hljs-attr">host:</span> <span class="hljs-string">localhost</span>      <span class="hljs-attr">port:</span> <span class="hljs-number">8500</span>      <span class="hljs-attr">discovery:</span>        <span class="hljs-comment">#hostname: 127.0.0.1</span>        <span class="hljs-attr">service-name:</span> <span class="hljs-string">$&#123;spring.application.name&#125;</span></code></pre><p>Controller:</p><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderController</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String PAYMENT_URL = <span class="hljs-string">&quot;http://cloud-payment-service&quot;</span>;    <span class="hljs-meta">@Resource</span>    <span class="hljs-keyword">private</span> RestTemplate restTemplate;    <span class="hljs-meta">@GetMapping(&quot;/consumer/payment/consul&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">consul</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> restTemplate.getForObject(PAYMENT_URL + <span class="hljs-string">&quot;/payment/consul&quot;</span>, String.class);    &#125;&#125;</code></pre><p>测试:</p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201123192730.png" alt="test" style="zoom: 50%;" /><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201123192817.png" alt="consul test"></p><h2 id="三个注册中心异同点"><a href="#三个注册中心异同点" class="headerlink" title="三个注册中心异同点"></a>三个注册中心异同点</h2><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201123193015.png" alt="异同点"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201123193225.png" alt="CAP"></p><blockquote><p>AP:</p></blockquote><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201123194018.png" alt="AP"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201123194054.png" alt="CP"></p><h1 id="服务调用"><a href="#服务调用" class="headerlink" title="服务调用"></a>服务调用</h1><h2 id="Ribbon-负载均衡"><a href="#Ribbon-负载均衡" class="headerlink" title="Ribbon 负载均衡"></a>Ribbon 负载均衡</h2><blockquote><p>ribbon是什么？<a href="https://github.com/Netflix/ribbon/wiki/Getting-Started">官网</a></p></blockquote><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201123195235.png" alt="ribbon概述"></p><blockquote><p>Ribbon也已经进入维护, 几乎不更新了, 但Spring推出的LoadBalance暂未能替代ribbon</p></blockquote><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201123195707.png" alt="负载均衡?"></p><h3 id="1、LB（负载均衡）区别"><a href="#1、LB（负载均衡）区别" class="headerlink" title="1、LB（负载均衡）区别"></a>1、LB（负载均衡）区别</h3><h4 id="a、集中式LB"><a href="#a、集中式LB" class="headerlink" title="a、集中式LB"></a>a、集中式LB</h4><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201123195916.png" alt="集中式LB"></p><h4 id="、进程内LB"><a href="#、进程内LB" class="headerlink" title="、进程内LB"></a>、进程内LB</h4><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201123195958.png" alt="进程内LB"></p><blockquote><p>前面我们使用了80通过轮询负载访问8001/8002, 一句话:负载均衡+RestTemplate调用</p></blockquote><h3 id="2、调用演示"><a href="#2、调用演示" class="headerlink" title="2、调用演示"></a>2、调用演示</h3><blockquote><p>Ribbon其实就是一个软负载均衡的客户端组件，他可以和其他所需请求的客户端结合使用，和eureka结合只是其中的一个实例。</p></blockquote><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201123201157.png" alt="ribbon工作"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201123201226.png" alt="策略"></p><h4 id="a、Eureka自动引入"><a href="#a、Eureka自动引入" class="headerlink" title="a、Eureka自动引入"></a>a、Eureka自动引入</h4><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p><strong>Eureka新版本继承了Ribbon</strong></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201123201540.png" alt="pom依赖"></p><h4 id="b、手动加入"><a href="#b、手动加入" class="headerlink" title="b、手动加入"></a>b、手动加入</h4><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201123201718.png" alt="手动"></p><h4 id="c、二说RestTemplate的使用"><a href="#c、二说RestTemplate的使用" class="headerlink" title="c、二说RestTemplate的使用"></a>c、二说RestTemplate的使用</h4><blockquote><p>ForObject与ForEntity区别     <a href="https://docs.spring.io/spring-framework/docs/5.2.2.RELEASE/javadoc-api/org/springframework/web/client/RestTemplate.html">官网</a> </p></blockquote><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/consumer/payment/get/&#123;id&#125;&quot;)</span><span class="hljs-function"><span class="hljs-keyword">public</span> CommonResult&lt;Payment&gt; <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Long id)</span></span>&#123;    <span class="hljs-comment">// 返回对象为响应体中数据转化成的对象，基本上可以理解为Json</span>    <span class="hljs-keyword">return</span> restTemplate.getForObject(PAYMENT_URL + <span class="hljs-string">&quot;/payment/get/&quot;</span> + id, CommonResult.class);&#125;<span class="hljs-meta">@GetMapping(&quot;/consumer/payment/getForEntity/&#123;id&#125;&quot;)</span><span class="hljs-function"><span class="hljs-keyword">public</span> CommonResult&lt;Payment&gt; <span class="hljs-title">getForEntity</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Long id)</span></span>&#123;    <span class="hljs-comment">// 返回对象为ResponseEntity对象，包含了响应中的一些重要信息，比如响应头、状态码、响应体等</span>    ResponseEntity&lt;CommonResult&gt; entity = restTemplate.getForEntity(PAYMENT_URL + <span class="hljs-string">&quot;/payment/get/&quot;</span> + id, CommonResult.class);    <span class="hljs-keyword">if</span> (entity.getStatusCode().is2xxSuccessful())&#123;        <span class="hljs-keyword">return</span> entity.getBody();    &#125;<span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CommonResult&lt;&gt;(<span class="hljs-number">444</span>, <span class="hljs-string">&quot;失败&quot;</span>);    &#125;&#125;</code></pre><pre><code class="hljs java">RestTemplate的:        xxxForObject()方法,返回的是响应体中的数据    xxxForEntity()方法.返回的是entity对象,这个对象不仅仅包含响应体数据,还包含响应体信息(状态码等)</code></pre><h3 id="3、Ribbon核心组件IRule"><a href="#3、Ribbon核心组件IRule" class="headerlink" title="3、Ribbon核心组件IRule"></a>3、Ribbon核心组件IRule</h3><blockquote><p>IRule:根据特定算法从服务列表中选取一个要访问的服务</p></blockquote><h4 id="a、IRule接口关系"><a href="#a、IRule接口关系" class="headerlink" title="a、IRule接口关系"></a>a、IRule接口关系</h4><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201123203451.png" alt="接口"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201123203612.png" alt="各个算法"></p><h4 id="b、如何替换？"><a href="#b、如何替换？" class="headerlink" title="b、如何替换？"></a>b、如何替换？</h4><p>修改cloud-consumer-order80:</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201125101402.png" alt="说明"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201125101630.png" alt="说明"></p><p>在myrule下添加MySelfRule类</p><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MySelfRule</span> </span>&#123;        <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> IRule <span class="hljs-title">myRule</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RandomRule();    &#125;&#125;</code></pre><p>主启动类添加:</p><pre><code class="hljs java"><span class="hljs-meta">@RibbonClient</span></code></pre><pre><code class="hljs java"><span class="hljs-meta">@RibbonClient(name = &quot;CLOUD-PAYMENT-SERVICE&quot;, configuration = MySelfRule.class)</span></code></pre><h3 id="4、负载均衡算法"><a href="#4、负载均衡算法" class="headerlink" title="4、负载均衡算法"></a>4、负载均衡算法</h3><h4 id="a、轮询原理"><a href="#a、轮询原理" class="headerlink" title="a、轮询原理"></a>a、轮询原理</h4><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201125103222.png" alt="原理"></p><h4 id="b、轮询源码分析"><a href="#b、轮询源码分析" class="headerlink" title="b、轮询源码分析"></a>b、轮询源码分析</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RoundRobinRule</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractLoadBalancerRule</span> </span>&#123;    <span class="hljs-comment">// ... 省略</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RoundRobinRule</span><span class="hljs-params">()</span> </span>&#123;        nextServerCyclicCounter = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">0</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Server <span class="hljs-title">choose</span><span class="hljs-params">(ILoadBalancer lb, Object key)</span> </span>&#123;        <span class="hljs-keyword">if</span> (lb == <span class="hljs-keyword">null</span>) &#123;            log.warn(<span class="hljs-string">&quot;no load balancer&quot;</span>);            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        Server server = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (server == <span class="hljs-keyword">null</span> &amp;&amp; count++ &lt; <span class="hljs-number">10</span>) &#123;            <span class="hljs-comment">// Reachable, 获得状态为UP的Server</span>            List&lt;Server&gt; reachableServers = lb.getReachableServers();            List&lt;Server&gt; allServers = lb.getAllServers();            <span class="hljs-keyword">int</span> upCount = reachableServers.size();            <span class="hljs-comment">// 获取Server数</span>            <span class="hljs-keyword">int</span> serverCount = allServers.size();            <span class="hljs-keyword">if</span> ((upCount == <span class="hljs-number">0</span>) || (serverCount == <span class="hljs-number">0</span>)) &#123;                log.warn(<span class="hljs-string">&quot;No up servers available from load balancer: &quot;</span> + lb);                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;            &#125;            <span class="hljs-keyword">int</span> nextServerIndex = incrementAndGetModulo(serverCount);            server = allServers.get(nextServerIndex);            <span class="hljs-keyword">if</span> (server == <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-comment">/* Transient. */</span>                Thread.yield();                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-keyword">if</span> (server.isAlive() &amp;&amp; (server.isReadyToServe())) &#123;                <span class="hljs-keyword">return</span> (server);            &#125;            <span class="hljs-comment">// Next.</span>            server = <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-keyword">if</span> (count &gt;= <span class="hljs-number">10</span>) &#123;            log.warn(<span class="hljs-string">&quot;No available alive servers after 10 tries from load balancer: &quot;</span>                    + lb);        &#125;        <span class="hljs-keyword">return</span> server;    &#125;        <span class="hljs-comment">// 自旋锁 </span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">incrementAndGetModulo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> modulo)</span> </span>&#123;        <span class="hljs-keyword">for</span> (;;) &#123;            <span class="hljs-keyword">int</span> current = nextServerCyclicCounter.get();            <span class="hljs-comment">// 开始 0 + 1</span>            <span class="hljs-keyword">int</span> next = (current + <span class="hljs-number">1</span>) % modulo;            <span class="hljs-comment">// CAS 比较并交换</span>            <span class="hljs-keyword">if</span> (nextServerCyclicCounter.compareAndSet(current, next))                <span class="hljs-keyword">return</span> next;        &#125;    &#125;&#125;</code></pre><h4 id="d、手写轮询算法"><a href="#d、手写轮询算法" class="headerlink" title="d、手写轮询算法"></a>d、手写轮询算法</h4><blockquote><p>学完JUC再续…</p></blockquote><p>// TODO</p><h2 id="OpenFeign服务接口调用"><a href="#OpenFeign服务接口调用" class="headerlink" title="OpenFeign服务接口调用"></a>OpenFeign服务接口调用</h2><h3 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h3><blockquote><p>Feign是一个声明式的web服务客户端，让编写web服务客户端变得非常容易，只需创建一个接口并在接口上添加注解即可 <a href="https://github.com/spring-cloud/spring-cloud-openfeign">官网</a></p></blockquote><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201125111325.png" alt="概念"></p><blockquote><p>能干什么？</p></blockquote><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201125111350.png" alt="用途"></p><blockquote><p>就是A要调用B,Feign就是在A中创建一个一模一样的B对外提供服务的的接口,我们调用这个接口,就可以服务到B</p></blockquote><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201125112301.png" alt="区别"></p><h3 id="2、使用"><a href="#2、使用" class="headerlink" title="2、使用"></a>2、使用</h3><blockquote><p>之前的服务间调用, 我们使用的是ribbon+RestTemplate, 现在改为使用Feign, 继承了Ribbon, 默认仍是轮询</p></blockquote><h4 id="a、创建cloud-consumer-feign-order80工程"><a href="#a、创建cloud-consumer-feign-order80工程" class="headerlink" title="a、创建cloud-consumer-feign-order80工程"></a>a、创建cloud-consumer-feign-order80工程</h4><p>Pom:</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- openfeign --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>yaml:</p><pre><code class="hljs yaml"><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">80</span><span class="hljs-attr">eureka:</span>  <span class="hljs-attr">client:</span>    <span class="hljs-attr">register-with-eureka:</span> <span class="hljs-literal">false</span>    <span class="hljs-attr">service-url:</span>      <span class="hljs-comment">#defaultZone: http://localhost:7001/eureka</span>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka</span></code></pre><p>主启动类:</p><pre><code class="hljs java"><span class="hljs-meta">@EnableFeignClients</span> <span class="hljs-comment">// 使用Feign, 激活并开启</span></code></pre><h4 id="b、新建PaymentFeignService接口并新增注解-FeignClient"><a href="#b、新建PaymentFeignService接口并新增注解-FeignClient" class="headerlink" title="b、新建PaymentFeignService接口并新增注解@FeignClient:"></a>b、新建PaymentFeignService接口并新增注解@FeignClient:</h4><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-meta">@FeignClient(name = &quot;CLOUD-PAYMENT-SERVICE&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">PaymentFeignService</span> </span>&#123;        <span class="hljs-meta">@GetMapping(&quot;/payment/get/&#123;id&#125;&quot;)</span>    <span class="hljs-function">CommonResult&lt;Payment&gt; <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(value = &quot;id&quot;)</span> Long id)</span></span>;    &#125;</code></pre><h4 id="c、写controller"><a href="#c、写controller" class="headerlink" title="c、写controller"></a>c、写controller</h4><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-meta">@Slf4j</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderController</span> </span>&#123;        <span class="hljs-meta">@Resource</span>    <span class="hljs-keyword">private</span> PaymentFeignService paymentFeignService;        <span class="hljs-meta">@GetMapping(&quot;/consumer/payment/get/&#123;id&#125;&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> CommonResult&lt;Payment&gt; <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(value = &quot;id&quot;)</span> Long id)</span></span>&#123;        <span class="hljs-keyword">return</span> paymentFeignService.get(id);    &#125;&#125;</code></pre><blockquote><p>注: <a href="https://www.cnblogs.com/huhuixin/p/7797850.html">Feign PathVariable annotation was empty on param 0.</a>报错, 需要在@PathVariable中添加Value = “”</p></blockquote><blockquote><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span>  <span class="hljs-attr">application:</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">CLOUD-PAYMENT-SERVICE</span><span class="hljs-comment"># name与用到的地方务必统一大小写 c + shift + u</span></code></pre></blockquote><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201125140748.png" alt="总览"></p><h3 id="3、OpenFeign超时控制"><a href="#3、OpenFeign超时控制" class="headerlink" title="3、OpenFeign超时控制"></a>3、OpenFeign超时控制</h3><blockquote><p>消费调用服务, 一定会存在一种<strong>超时现象</strong>, OpenFeign默认等待一秒钟, 超过后报错</p></blockquote><h4 id="a、在PaymentController中添加timeout接口"><a href="#a、在PaymentController中添加timeout接口" class="headerlink" title="a、在PaymentController中添加timeout接口"></a>a、在PaymentController中添加timeout接口</h4><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-meta">@Slf4j</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PaymentController</span> </span>&#123;    <span class="hljs-meta">@GetMapping(&quot;/payment/timeout&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">timeout</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">try</span> &#123;            TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        <span class="hljs-keyword">return</span> serverPort;    &#125;&#125;</code></pre><h4 id="b、在PaymentFeignService添加"><a href="#b、在PaymentFeignService添加" class="headerlink" title="b、在PaymentFeignService添加"></a>b、在PaymentFeignService添加</h4><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-meta">@FeignClient(value = &quot;cloud-payment-service&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">PaymentFeignService</span> </span>&#123;    <span class="hljs-meta">@GetMapping(&quot;/payment/timeout&quot;)</span>    <span class="hljs-function">String <span class="hljs-title">timeout</span><span class="hljs-params">()</span></span>;&#125;</code></pre><h4 id="c、OrderController中添加"><a href="#c、OrderController中添加" class="headerlink" title="c、OrderController中添加"></a>c、OrderController中添加</h4><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-meta">@Slf4j</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderController</span> </span>&#123;    <span class="hljs-meta">@GetMapping(&quot;/consumer/payment/timeout&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">timeout</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> paymentFeignService.timeout();    &#125;&#125;</code></pre><p>​           <img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201125142929.png" alt="测试结果"></p><h4 id="d、超时控制"><a href="#d、超时控制" class="headerlink" title="d、超时控制"></a>d、超时控制</h4><pre><code class="hljs yaml"><span class="hljs-attr">ribbon:</span>  <span class="hljs-comment"># 建立连接时间</span>  <span class="hljs-attr">ReadTimeout:</span> <span class="hljs-number">5000</span>  <span class="hljs-comment"># 连接后从服务器读取到可用资源时间</span>  <span class="hljs-attr">ConnectTimeout:</span> <span class="hljs-number">5000</span></code></pre><p>​       <img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201125143321.png" alt="测试结果"></p><h3 id="4、日志增强"><a href="#4、日志增强" class="headerlink" title="4、日志增强"></a>4、日志增强</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201125143432.png" alt="openfeign日志"></p><p>写config:</p><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FeignConfig</span> </span>&#123;        <span class="hljs-meta">@Bean</span>    Logger.<span class="hljs-function">Level <span class="hljs-title">feignLoggerLevel</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> Logger.Level.FULL;    &#125;&#125;</code></pre><p>yaml开启:</p><pre><code class="hljs yaml"><span class="hljs-attr">logging:</span>  <span class="hljs-attr">level:</span>     <span class="hljs-attr">com.qiuke.springcloud.service.PaymentFeignService:</span> <span class="hljs-string">debug</span></code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201125144229.png" alt="日志"></p><h1 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a>服务降级</h1><h2 id="Hystrix-断路器"><a href="#Hystrix-断路器" class="headerlink" title="Hystrix 断路器"></a>Hystrix 断路器</h2><h3 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h3><h4 id="a、分布式面临的问题"><a href="#a、分布式面临的问题" class="headerlink" title="a、分布式面临的问题"></a>a、分布式面临的问题</h4><blockquote><p>复杂分布式体系结构中的应用程序有数十个依赖关系, 每个依赖关系在某个时候将不可避免的失败</p></blockquote><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201125144953.png" alt="问题"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201125145028.png" alt="服务雪崩"></p><h4 id="b、Hystrix是什么？"><a href="#b、Hystrix是什么？" class="headerlink" title="b、Hystrix是什么？"></a>b、Hystrix是什么？</h4><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201125145348.png" alt="概念"></p><blockquote><p>功能: 服务降级、服务熔断、接近实时的监控   <a href="https://github.com/Netflix/Hystrix/wiki/How-To-Use">官网</a>   <a href="https://github.com/Netflix/Hystrix">停更进维</a></p></blockquote><h4 id="c、名词概念"><a href="#c、名词概念" class="headerlink" title="c、名词概念"></a>c、名词概念</h4><blockquote><p>服务降级 (fallback)</p></blockquote><p><strong>服务器忙，请稍候再试，不让客户端等待并立刻返回一个友好提示，fallback</strong></p><p>哪些情况会触发降级？</p><ul><li>程序运行异常</li><li>超时</li><li>服务熔断触发服务降级</li><li>线程池/信号量打满也会导致服务降级</li></ul><blockquote><p>服务熔断 (break)</p></blockquote><blockquote><p>服务限流 (flowlimit)</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>Spring Cloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
