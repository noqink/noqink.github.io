<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>高频面试题</title>
    <link href="/2021/04/11/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9A%84%E5%89%AF%E6%9C%AC/"/>
    <url>/2021/04/11/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9A%84%E5%89%AF%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li>JUC（java.util.concurrent）<ul><li><strong>进程和线程</strong> <ul><li>进程：后台运行的程序（我们打开的一个软件，就是进程）</li><li>线程：轻量级的进程，并且一个进程包含多个线程（同在一个软件内，同时运行窗口，就是线程）</li></ul></li><li>并发和并行<ul><li>并发：同时访问某个东西，就是并发</li><li>并行：一起做某些事情，就是并行</li></ul></li></ul></li><li>JUC下的三个包<ul><li>java.util.concurrent<ul><li>java.util.concurrent.atomic</li><li>java.util.concurrent.locks</li></ul></li></ul></li></ul><h1 id="谈谈Volatile"><a href="#谈谈Volatile" class="headerlink" title="谈谈Volatile"></a>谈谈Volatile</h1><h2 id="Volatile-理解"><a href="#Volatile-理解" class="headerlink" title="Volatile 理解"></a>Volatile 理解</h2><blockquote><p>volatile是JVM提供的轻量级的同步机制</p></blockquote><ol><li>保证可见性</li><li>不保证原子性</li><li>禁止 <strong>指令重排</strong> （保证有序性）</li></ol><h2 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h2><p>JMM是Java内存模型，也就是Java Memory Model，简称JMM，本身是一种抽象的概念，实际上 <strong>并不存在</strong> ，它描述的是一组 <strong>规则或规范</strong> ，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式</p><p>JMM关于同步的规定：</p><ul><li>线程 <strong>解锁</strong> 前，必须把共享变量的值 <strong>刷新回主内存</strong> </li><li>线程 <strong>加锁</strong> 前，必须读取主内存的最新值，到自己的 <strong>工作内存</strong> </li><li>加锁和解锁是 <strong>同一把锁</strong> </li></ul><p>由于JVM运行程序的实体是线程，而 <strong>每个线程</strong> 创建时 <strong>JVM</strong> 都会为其创建一个 <strong>工作内存</strong> （有些地方称为栈空间），工作内存是每个线程的 <strong>私有数据区域</strong> ，而Java内存模型中规定所有变量都存储在 <strong>主内存</strong> ，主内存是 <strong>共享内存区域</strong> ，所有线程都可以访问，<code>但线程对变量的操作（读取赋值等）必须在工作内存中进行，首先要将变量从主内存拷贝到自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写会主内存</code>，不能直接操作主内存中的变量，各个线程中的工作内存中存储着主内存中的 <strong>变量副本拷贝</strong> ，因此不同的线程间无法访问对方的工作内存，线程间的通信（传值）必须通过主内存来完成，其简要访问过程：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210406170735.png"></p><p>数据传输速率：硬盘 &lt; 内存 &lt; &lt; cache &lt; CPU</p><p>上面提到了两个概念：主内存 和 工作内存</p><ul><li>主内存：就是计算机的内存，也就是经常提到的8G内存，16G内存</li><li>工作内存：但我们实例化 new student，那么 age = 25 也是存储在主内存中<ul><li>当同时有三个线程同时访问 student中的age变量时，那么每个线程都会拷贝一份，到各自的工作内存，从而实现了 <strong>变量的拷贝</strong> </li></ul></li></ul><h3 id="JMM内存模型的可见性"><a href="#JMM内存模型的可见性" class="headerlink" title="JMM内存模型的可见性"></a>JMM内存模型的可见性</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210406171943.png"></p><p>即： <strong>JMM内存模型的可见性</strong> ，指的是当主内存区域中的值被某个线程写入更改后，其它线程会马上知晓更改后的值，并重新得到更改后的值。</p><h3 id="JMM的三大特性"><a href="#JMM的三大特性" class="headerlink" title="JMM的三大特性"></a>JMM的三大特性</h3><p>JMM的三大特性，volatile只保证了两个，即可见性和有序性，不满足原子性，</p><ul><li>可见性</li><li>原子性</li><li>有序性</li></ul><h3 id="JMM可见性code"><a href="#JMM可见性code" class="headerlink" title="JMM可见性code"></a>JMM可见性code</h3><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 假设是主物理内存</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyData</span> </span>&#123;    <span class="hljs-keyword">int</span> number = <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addTo60</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">this</span>.number = <span class="hljs-number">60</span>;    &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 验证volatile的可见性</span><span class="hljs-comment"> * 1. 假设int number = 0， number变量之前没有添加volatile关键字修饰</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Code1_volatile</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args [])</span> </span>&#123;        <span class="hljs-comment">// 资源类</span>        MyData myData = <span class="hljs-keyword">new</span> MyData();        <span class="hljs-comment">// AAA线程 实现了Runnable接口的，lambda表达式</span>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t come in&quot;</span>);            <span class="hljs-comment">// 线程睡眠3秒，假设在进行运算</span>            <span class="hljs-keyword">try</span> &#123;                TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>);            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;            <span class="hljs-comment">// 修改number的值</span>            myData.addTo60();            <span class="hljs-comment">// 输出修改后的值</span>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t update number value:&quot;</span> + myData.number);        &#125;, <span class="hljs-string">&quot;AAA&quot;</span>).start();        <span class="hljs-keyword">while</span>(myData.number == <span class="hljs-number">0</span>) &#123;            <span class="hljs-comment">// main线程就一直在这里等待循环，直到number的值不等于零</span>        &#125;        <span class="hljs-comment">// 按道理这个值是不可能打印出来的，因为主线程运行的时候，number的值为0，所以一直在循环</span>        <span class="hljs-comment">// 如果能输出这句话，说明AAA线程在睡眠3秒后，更新的number的值，重新写入到主内存，并被main线程感知到了</span>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t mission is over&quot;</span>);        <span class="hljs-comment">/**</span><span class="hljs-comment">         * 最后输出结果：</span><span class="hljs-comment">         * AAA  come in</span><span class="hljs-comment">         * AAA  update number value:60</span><span class="hljs-comment">         * 最后线程没有停止，并行没有输出  mission is over 这句话，说明没有用volatile修饰的变量，是没有可见性</span><span class="hljs-comment">         */</span>    &#125;&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210407185933.png"></p><p>main线程没有得知number变成了60；</p><p>如果加上volatile关键字：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210407190056.png"></p><p>volatile 修饰的关键字，是为了增加 主线程和线程之间的可见性，只要有一个线程修改了内存中的值，其它线程也能马上感知。</p><p><a href="https://mp.weixin.qq.com/s/Oa3tcfAFO9IgsbE22C5TEg">拓展区域</a></p><h2 id="Volatile不保证原子性"><a href="#Volatile不保证原子性" class="headerlink" title="Volatile不保证原子性"></a>Volatile不保证原子性</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>通过前面对JMM的介绍，我们知道，各个线程对主内存中共享变量的操作都是各个线程各自拷贝到自己的工作内存进行操作后在写回到主内存中的。</p><p>这就可能存在一个 <strong>线程AAA</strong> 修改了共享变量X的值，但是还未写入主内存时，另外一个 <strong>线程BBB</strong> 又对主内存中同一共享变量X进行操作，但此时 <strong>A线程工作内存中共享变量X对线程B来说是不可见</strong> ，这种工作内存与主内存同步延迟现象就造成了 <strong>可见性问题</strong> 。</p><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>不可分割，完整性，也就是说某个线程正在做某个具体业务时，中间 <strong>不可以被加塞或者被分割</strong> ，需要具体完成，要么 <strong>同时成功，要么同时失败</strong> 。</p><p>数据库也经常提到事务具备原子性 </p><h3 id="原子性代码测试"><a href="#原子性代码测试" class="headerlink" title="原子性代码测试"></a>原子性代码测试</h3><p>首先给MyDate资源类添加方法</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">   * 注意，此时number 前面是加了volatile修饰</span><span class="hljs-comment">   */</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addPlusPlus</span><span class="hljs-params">()</span> </span>&#123;      number ++;  &#125;</code></pre><p>为了测试volatile是否保证原子性，我们创建了20个线程，然后每个线程分别循环1000次，来调用number++的方法</p><p>最后通过 Thread.activeCount()，来感知20个线程是否执行完毕，这里判断线程数是否大于2；</p><p> <strong>为什么是2？因为默认是有两个线程的，一个main线程，一个gc线程</strong> </p><pre><code class="hljs java">MyData myData = <span class="hljs-keyword">new</span> MyData();<span class="hljs-comment">// 创建10个线程，线程里面进行1000次循环</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;    <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;        <span class="hljs-comment">// 里面</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">1000</span>; j++) &#123;            myData.addPlusPlus();        &#125;    &#125;, String.valueOf(i)).start();&#125;<span class="hljs-comment">// 需要等待上面20个线程都计算完成后，在用main线程取得最终的结果值</span><span class="hljs-keyword">while</span>(Thread.activeCount() &gt; <span class="hljs-number">2</span>) &#123;    <span class="hljs-comment">// yield表示不执行</span>    Thread.yield();&#125;<span class="hljs-comment">// 查看最终的值</span><span class="hljs-comment">// 假设volatile保证原子性，那么输出的值应该为：  20 * 1000 = 20000</span>System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t finally number value: &quot;</span> + myData.number);</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210407192017.png"></p><h3 id="为什么不能保证原子性"><a href="#为什么不能保证原子性" class="headerlink" title="为什么不能保证原子性"></a>为什么不能保证原子性</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210407193224.png"></p><p>各自线程在写入主内存的时候，出现了数据的丢失，而引起的数值缺失的问题</p><p>下面我们将一个简单的number++操作，转换为字节码文件一探究竟</p><p>.java -&gt; .class -&gt; JVM字节码</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210407193959.png"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210407194057.png"></p><p>我们能够发现 n++这条命令，被拆分成了 <strong>3个指令</strong> </p><ul><li>执行<code>getfield</code> 从主内存拿到原始n</li><li>执行<code>iadd</code> 进行加1操作</li><li>执行<code>putfileld</code> 把累加后的值写回主内存</li></ul><p>假设我们没有加 <code>synchronized</code>那么第一步就可能存在着， <strong>三个线程同时通过getfield命令</strong> ，拿到主存中的 n值，然后三个线程，各自在自己的工作内存中进行加1操作，但他们并发进行 <code>iadd</code> 命令的时候，因为只能一个进行写，所以其它操作会被 <strong>挂起</strong> ，假设1线程，先进行了写操作，在写完后，volatile的可见性，应该需要告诉其它两个线程，主内存的值已经被修改了，但是 <strong>因为太快了</strong> ， <strong>没有来得及获取最新值</strong> ，其它两个线程，陆续执行 <code>iadd</code>命令，进行写入操作，这就造成了其他线程没有接受到主内存n的改变，从而覆盖了原来的值，出现写丢失，这样也就让最终的结果少于20000</p><p> <strong>写覆盖问题</strong> ；</p><h3 id="如何解决？"><a href="#如何解决？" class="headerlink" title="如何解决？"></a>如何解决？</h3><p>因此这也说明，在 <strong>多线程环境</strong> 下 number ++ 在多线程环境下是 <strong>非线程安全</strong> 的，解决的方法有哪些呢？</p><ul><li><p>在方法上加入 synchronized</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addPlusPlus</span><span class="hljs-params">()</span> </span>&#123;        number ++;    &#125;</code></pre><p>引入synchronized关键字后， 保证了该方法 <strong>每次只能够一个线程</strong> 进行访问和操作，最终输出的结果也就为20000</p></li></ul><p>上面的方法引入synchronized，虽然能够保证原子性，但是为了解决number++，而引入 <strong>重量级</strong> 的同步机制，有种  <strong>杀鸡焉用牛刀</strong> </p><ul><li><p>可以使用JUC下面的 <strong>原子包装类</strong> ，即刚刚的int类型的number，可以使用AtomicInteger来代替，最小单位不可分割</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">    *  创建一个原子Integer包装类，默认为0</span><span class="hljs-comment">     */</span>   AtomicInteger atomicInteger = <span class="hljs-keyword">new</span> AtomicInteger();     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addAtomic</span><span class="hljs-params">()</span> </span>&#123;       <span class="hljs-comment">// 相当于 atomicInter ++</span>       atomicInteger.getAndIncrement();   &#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210407195719.png"></p></li></ul><h3 id="字节码表"><a href="#字节码表" class="headerlink" title="字节码表"></a>字节码表</h3><p><a href="https://segmentfault.com/a/1190000008722128">表</a></p><h2 id="Volatile禁止指令重排"><a href="#Volatile禁止指令重排" class="headerlink" title="Volatile禁止指令重排"></a>Volatile禁止指令重排</h2><p>计算机在执行程序时，为了提高性能， <strong>编译器和处理器</strong> 常常会对 <strong>指令重排</strong> ，一般分为以下三种：</p><pre><code class="hljs clean">源代码 -&gt; 编译器优化的重排 -&gt; 指令并行的重排 -&gt; 内存系统的重排 -&gt; 最终执行指令</code></pre><ul><li> <strong>单线程环境</strong> 里面确保最终执行结果和代码顺序的结果一致</li><li>处理器在进行重排序时，必须要考虑指令之间的<code>数据依赖性</code></li><li> <strong>多线程环境</strong> 中线程交替执行，由于编译器优化重排的存在，两个线程中使用的变量能否保证一致性是无法确定的， <strong>结果无法预测</strong> 。</li></ul><h3 id="指令重排-example-1"><a href="#指令重排-example-1" class="headerlink" title="指令重排 - example 1"></a>指令重排 - example 1</h3><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mySort</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> x = <span class="hljs-number">11</span>;<span class="hljs-keyword">int</span> y = <span class="hljs-number">12</span>;x = x + <span class="hljs-number">5</span>;y = x * x;&#125;</code></pre><ul><li><p>按照正常 <strong>单线程环境</strong> ，执行顺序是 1 2 3 4 </p></li><li><p>但是在 <strong>多线程环境</strong> 下，可能出现以下的顺序： </p><ul><li>2 1 3 4</li><li>1 3 2 4</li></ul></li></ul><p>上述的过程就可以当做是 <strong>指令的重排</strong> ，即内部执行顺序，和我们的代码顺序不一样</p><p>但是指令重排也是有 <strong>限制</strong> 的，即不会出现下面的顺序</p><ul><li>4 3 2 1</li></ul><p>因为处理器在进行重排时候，必须考虑到指令之间的<code>数据依赖性</code></p><p>因为步骤 4：需要依赖于 y的申明，以及x的申明，故因为存在数据依赖，无法首先执行</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p> <strong>int a,b,x,y = 0</strong> </p><table><thead><tr><th>线程1</th><th>线程2</th></tr></thead><tbody><tr><td>x = a;</td><td>y = b;</td></tr><tr><td>b = 1;</td><td>a = 2;</td></tr><tr><td></td><td></td></tr><tr><td>x = 0; y = 0</td><td></td></tr></tbody></table><p>因为上面的代码，不存在数据的依赖性，因此编译器可能对数据进行重排</p><table><thead><tr><th>线程1</th><th>线程2</th></tr></thead><tbody><tr><td>b = 1;</td><td>a = 2;</td></tr><tr><td>x = a;</td><td>y = b;</td></tr><tr><td></td><td></td></tr><tr><td>x = 2; y = 1</td><td></td></tr></tbody></table><p>这样造成的结果，和最开始的就不一致了，这就是导致重排后，结果和最开始的不一样，因此为了防止这种结果出现， <strong>volatile就规定禁止指令重排</strong> ，为了 <strong>保证数据的一致性</strong> </p><h3 id="指令重排-example-2"><a href="#指令重排-example-2" class="headerlink" title="指令重排 - example 2"></a>指令重排 - example 2</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ResortSeqDemo</span> </span>&#123;    <span class="hljs-keyword">int</span> a= <span class="hljs-number">0</span>;    <span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">false</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method01</span><span class="hljs-params">()</span> </span>&#123;        a = <span class="hljs-number">1</span>;        flag = <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method02</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span>(flag) &#123;            a = a + <span class="hljs-number">5</span>;            System.out.println(<span class="hljs-string">&quot;reValue:&quot;</span> + a);        &#125;    &#125;&#125;</code></pre><p>我们按照正常的顺序，分别调用method01() 和 method02() 那么，最终输出就是 a = 6</p><p>但是如果在多线程环境下，因为方法1 和 方法2，他们之间不能存在数据依赖的问题，因此原先的顺序可能是</p><pre><code class="hljs java">a = <span class="hljs-number">1</span>;flag = <span class="hljs-keyword">true</span>;a = a + <span class="hljs-number">5</span>;System.out.println(<span class="hljs-string">&quot;reValue:&quot;</span> + a);</code></pre><p>但是在经过编译器，指令，或者内存的重排后，可能会出现这样的情况</p><pre><code class="hljs java">flag = <span class="hljs-keyword">true</span>;a = a + <span class="hljs-number">5</span>;System.out.println(<span class="hljs-string">&quot;reValue:&quot;</span> + a);a = <span class="hljs-number">1</span>;</code></pre><p>也就是先执行 flag = true后，另外一个线程马上调用方法2，满足 flag的判断，最终让a + 5，结果为5，这样同样出现了数据不一致的问题</p><p>为什么会出现这个结果：多线程环境中线程交替执行，由于编译器优化重排的存在，两个线程中使用的变量能否保证一致性是无法确定的，结果无法预测。</p><p>这样就需要通过 <strong>volatile来修饰</strong> ，来保证线程安全性</p><h3 id="Volatile针对指令重排做了啥"><a href="#Volatile针对指令重排做了啥" class="headerlink" title="Volatile针对指令重排做了啥"></a>Volatile针对指令重排做了啥</h3><p>Volatile实现 <strong>禁止指令重排优化</strong> ，从而避免了多线程环境下程序出现乱序执行的现象</p><p>首先了解一个概念， <strong>内存屏障</strong> （Memory Barrier）又称 <strong>内存栅栏</strong> ，是一个 <strong>CPU指令</strong> ，它的作用有两个：</p><ul><li><p>保证特定操作的顺序</p></li><li><p>保证某些变量的内存可见性（利用该特性 <strong>实现volatile的内存可见性</strong> ）</p><p>由于编译器和处理器都能执行指令重排的优化，如果在指令间插入一条Memory Barrier则会告诉编译器和CPU，不管什么指令都不能和这条Memory Barrier指令重排序，也就是说 <code>通过插入内存屏障禁止在内存屏障前后的指令执行重排序优化</code>。 内存屏障另外一个作用是 <strong>刷新出各种CPU的缓存数据</strong> ，因此任何CPU上的线程都能读取到这些数据的最新版本。</p></li></ul><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210407202835.png"></p><p>也就是在Volatile的写 和 读的时候，加入屏障，防止出现指令重排的</p><h3 id="线程安全获得保证"><a href="#线程安全获得保证" class="headerlink" title="线程安全获得保证"></a>线程安全获得保证</h3><p>工作内存与主内存同步延迟现象导致的 <strong>可见性问题</strong> </p><ul><li>可通过synchronized或volatile关键字解决，他们都可以使一个线程修改后的变量立即对其它线程可见</li></ul><p>对于 <strong>指令重排导致的可见性问题和有序性问题</strong> </p><ul><li>可以使用volatile关键字解决，因为volatile关键字的另一个作用就是禁止重排序优化</li></ul><h2 id="Volatile的应用"><a href="#Volatile的应用" class="headerlink" title="Volatile的应用"></a>Volatile的应用</h2><h3 id="单例模式DCL代码"><a href="#单例模式DCL代码" class="headerlink" title="单例模式DCL代码"></a>单例模式DCL代码</h3><pre><code class="hljs java"><span class="hljs-comment">// 单例模式DCL代码</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Code2_SingletonDemo</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Code2_SingletonDemo instance = <span class="hljs-keyword">null</span>;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Code2_SingletonDemo</span><span class="hljs-params">()</span></span>&#123;        System.out.println(<span class="hljs-string">&quot;构造方法&quot;</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Code2_SingletonDemo <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>)&#123;            instance = <span class="hljs-keyword">new</span> Code2_SingletonDemo();        &#125;        <span class="hljs-keyword">return</span> instance;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">// 单线程(main 线程操作)</span>        System.out.println(Code2_SingletonDemo.getInstance() == Code2_SingletonDemo.getInstance());        System.out.println(Code2_SingletonDemo.getInstance() == Code2_SingletonDemo.getInstance());        System.out.println(Code2_SingletonDemo.getInstance() == Code2_SingletonDemo.getInstance());    &#125;&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210408185446.png"></p><p>改变后</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    <span class="hljs-comment">// 并发后 情况有所改变</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            Code2_SingletonDemo.getInstance();        &#125;, String.valueOf(i)).start();    &#125;&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210408185546.png"></p><p>从上面的结果我们可以看出，我们通过SingletonDemo.getInstance() 获取到的对象，并不是同一个，而是被下面几个线程都进行了创建，那么在多线程环境下， <strong>单例模式如何保证呢</strong> ？</p><h4 id="解决方法1"><a href="#解决方法1" class="headerlink" title="解决方法1"></a>解决方法1</h4><ul><li><p>引入synchronized关键字</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> SingletonDemo <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span>(instance == <span class="hljs-keyword">null</span>) &#123;            instance = <span class="hljs-keyword">new</span> SingletonDemo();        &#125;        <span class="hljs-keyword">return</span> instance;    &#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210408185857.png"></p></li></ul><p>我们能够发现，通过引入Synchronized关键字，能够 <strong>解决高并发环境下的单例模式问题</strong> </p><p>但是synchronized属于 <strong>重量级</strong> 的同步机制，它只允许一个线程同时访问获取实例的方法，但是为了保证数据一致性，而 <strong>减低了并发性</strong> ，因此采用的比较少</p><h4 id="解决方法2"><a href="#解决方法2" class="headerlink" title="解决方法2"></a>解决方法2</h4><ul><li><p>通过引入 <strong>DCL</strong>  Double Check Lock 双端检锁机制</p><p>就是在进来和出去的时候，进行检测</p></li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingletonDemo <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">if</span>(instance == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-comment">// 同步代码段的时候，进行检测</span>        <span class="hljs-keyword">synchronized</span> (SingletonDemo.class) &#123;            <span class="hljs-keyword">if</span>(instance == <span class="hljs-keyword">null</span>) &#123;                instance = <span class="hljs-keyword">new</span> SingletonDemo();            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> instance;&#125;</code></pre><p>​        </p><p>从输出结果来看，确实能够保证单例模式的正确性，但是上面的方法还是 <strong>存在问题的</strong> </p><p>DCL（双端检锁）机制不一定是线程安全的，原因是有 <strong>指令重排</strong> 的存在，加入volatile可以禁止指令重排</p><p>原因是在某一个线程执行到第一次检测的时候，读取到 instance 不为null，instance的引用对象 <strong>可能没有完成实例化</strong> 。</p><p>因为 instance = new SingletonDemo()；可以分为以下 <strong>三步</strong> 进行完成：</p><ul><li>memory = allocate(); // 1、分配对象内存空间</li><li>instance(memory); // 2、初始化对象</li><li>instance = memory; // 3、设置instance指向刚刚分配的内存地址，此时instance != null</li></ul><p>步骤2、步骤3 <strong>不存在数据依赖关系</strong> ，重排前和重排后对单线程模式下的程序运行没有结果改变，所以这种重排优化是被允许的。</p><ul><li>memory = allocate(); // 1、分配对象内存空间</li><li>instance = memory; // 3、设置instance指向刚刚分配的内存地址，此时instance != null， <strong>但是对象还没有初始化完成</strong> </li><li>instance(memory); // 2、初始化对象</li></ul><p>这样就会造成什么问题呢？</p><p>也就是当我们执行到重排后的步骤2，试图获取instance的时候，会得到null，因为对象的初始化还没有完成，而是在重排后的步骤3才完成，因此执行单例模式的代码时候，就会 <strong>重新</strong> 创建一个instance实例</p><p><code>指令重排只会保证串行语义的执行一致性（单线程），但并不会关系多线程间的语义一致性</code></p><p>所以当一条线程访问instance不为null时， <strong>由于instance实例未必已初始化完成</strong> ，这就造成了 <strong>线程安全</strong> 的问题</p><p>所以需要引入volatile，来保证出现指令重排的问题，从而保证单例模式的线程安全性</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> SingletonDemo instance = <span class="hljs-keyword">null</span>;</code></pre><h4 id="最终代码"><a href="#最终代码" class="headerlink" title="最终代码"></a>最终代码</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonDemo</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> SingletonDemo instance = <span class="hljs-keyword">null</span>;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">SingletonDemo</span> <span class="hljs-params">()</span> </span>&#123;        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 我是构造方法SingletonDemo&quot;</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingletonDemo <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span>(instance == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-comment">// a 双重检查加锁多线程情况下会出现某个线程虽然这里已经为空，但是另外一个线程已经执行到d处</span>            <span class="hljs-keyword">synchronized</span> (SingletonDemo.class) <span class="hljs-comment">//b</span>            &#123;            <span class="hljs-comment">//c不加volitale关键字的话有可能会出现尚未完全初始化就获取到的情况。原因是内存模型允许无序写入</span>                <span class="hljs-keyword">if</span>(instance == <span class="hljs-keyword">null</span>) &#123;                 <span class="hljs-comment">// d 此时才开始初始化</span>                    instance = <span class="hljs-keyword">new</span> SingletonDemo();                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> instance;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;            <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;                SingletonDemo.getInstance();            &#125;, String.valueOf(i)).start();        &#125;    &#125;&#125;</code></pre><h1 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p> 比较并交换；</p><p>CAS的全称是 <strong>Compare-And-Swap</strong> ，它是 <strong>CPU并发原语</strong> </p><p>它的功能是 <strong>判断内存某个位置的值是否为预期值</strong> ，如果是则更改为新的值，这个过程是 <strong>原子的</strong> </p><p>CAS并发原语体现在Java语言中就是 <strong>sun.misc.Unsafe类</strong> 的各个方法。调用UnSafe类中的 <strong>CAS方法</strong> ， <strong>JVM</strong> 会帮我们实现出 <strong>CAS汇编指令</strong> ，这是一种完全依赖于 <strong>硬件</strong> 的功能，通过它实现了原子操作，再次强调，由于CAS是一种系统原语，原语属于操作系统用于范畴，是由若干条指令组成，用于完成某个功能的一个过程，并且原语的执行必须是连续的，在执行过程中不允许被中断，也就是说 <strong>CAS是一条CPU的原子指令</strong> ，不会造成所谓的数据不一致的问题，也就是说 <strong>CAS是线程安全的</strong> 。</p><h2 id="代码使用"><a href="#代码使用" class="headerlink" title="代码使用"></a>代码使用</h2><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    <span class="hljs-comment">// 创建一个原子类</span>    AtomicInteger atomicInteger = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">5</span>);    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 一个是期望值，一个是更新值，但期望值和原来的值相同时，才能够更改</span><span class="hljs-comment">     * 假设三秒前，我拿的是5，也就是expect为5，然后我需要更新成 2019</span><span class="hljs-comment">     */</span>    System.out.println(atomicInteger.compareAndSet(<span class="hljs-number">5</span>, <span class="hljs-number">2019</span>) + <span class="hljs-string">&quot;\t current data: &quot;</span> + atomicInteger.get());    System.out.println(atomicInteger.compareAndSet(<span class="hljs-number">5</span>, <span class="hljs-number">1024</span>) + <span class="hljs-string">&quot;\t current data: &quot;</span> + atomicInteger.get());&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210408195319.png"></p><p>这是因为我们执行第一个的时候，期望值和原本值是满足的，因此修改成功，</p><p>但是第二次后，主内存的值已经修改成了2019， <strong>不满足期望值</strong> ，因此返回了false，本次写入失败。</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210408195413.png"></p><p>这个就类似于 <strong>SVN或者Git的版本号</strong> ，如果没有人更改过，就能够正常提交，否者需要先将代码pull下来，合并代码后，然后提交</p><h2 id="CAS底层原理"><a href="#CAS底层原理" class="headerlink" title="CAS底层原理"></a>CAS底层原理</h2><h3 id="atomicInteger源码"><a href="#atomicInteger源码" class="headerlink" title="atomicInteger源码"></a>atomicInteger源码</h3><p>首先我们先看看 atomicInteger.getAndIncrement()方法的源码</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210408201048.png"></p><p>从这里能够看到，底层又调用了一个unsafe类的getAndAddInt方法</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210408201332.png"></p><h3 id="unsafe类源码"><a href="#unsafe类源码" class="headerlink" title="unsafe类源码"></a>unsafe类源码</h3><p>继续深挖</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210408201458.png"></p><p>进入sun.misc.Unsafe；</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210408201631.png" alt="JDK"></p><p>JDK自带的native方法</p><p>先回到aotomicInteger</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210408201930.png"></p><p>objectFieldOffset得到对象偏移量</p><p>Unsafe是CAS的 <strong>核心类</strong> ，CAS靠的是Unsafe的原子性，由于Java方法无法直接访问底层系统，需要通过本地（Native）方法来访问，Unsafe相当于一个 <strong>后门</strong> ，基于该类可以直接操作特定的内存数据。Unsafe类存在sun.misc包中，其内部方法操作可以像C的指针一样直接操作内存，因为Java中的 <strong>CAS操作的执行依赖于Unsafe类的方法</strong> 。</p><pre><code class="hljs oxygene">注意<span class="hljs-keyword">Unsafe</span>类的所有方法都是native修饰的，也就是说<span class="hljs-keyword">unsafe</span>类中的方法都直接调用操作系统底层资源执行相应的任务</code></pre><p>为什么Atomic修饰的包装类，能够保证原子性，依靠的就是底层的unsafe类</p><h3 id="变量valueOffset"><a href="#变量valueOffset" class="headerlink" title="变量valueOffset"></a>变量valueOffset</h3><p>表示该变量值在 <strong>内存中的偏移地址</strong> ，因为Unsafe就是根据内存偏移地址获取数据的。</p><p>从这里我们能够看到，通过valueOffset，直接通过内存地址，获取到值，然后进行加1的操作</p><h3 id="变量value"><a href="#变量value" class="headerlink" title="变量value"></a>变量value</h3><p>用 <strong>volatile</strong> 修饰</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210408202836.png"></p><p>var5：就是我们从主内存中拷贝到 <strong>工作内存中的值</strong>  (每次都要从主内存拿到 <strong>最新的值</strong> 到自己的本地内存，然后执行compareAndSwapInt()再和主内存的值进行比较。因为线程不可以直接越过高速缓存，直接操作主内存，所以执行上述方法需要比较一次，在执行加1操作)</p><p>那么操作的时候，需要比较 <strong>工作内存中的值</strong> ，和 <strong>主内存中的值</strong> 进行比较</p><p>假设执行 compareAndSwapInt返回false，那么就一直执行 while方法，直到期望的值和真实值一样</p><ul><li>val1：AtomicInteger对象本身</li><li>var2：该对象值的 <strong>引用地址</strong> （内存偏移量）</li><li>var4：需要变动的数量</li><li>var5：用var1和var2找到的内存中的真实值<ul><li>用该对象当前的值与var5比较</li><li>如果相同，更新var5 + var4 并返回true</li><li>如果不同，继续取值（取得 <strong>最新的值</strong> ）然后再比较，直到更新完成</li></ul></li></ul><p>这里没有用synchronized，而用CAS，这样 <strong>提高了并发性</strong> ，也能够 <strong>实现一致性</strong> ，是因为每个线程进来后，进入的do while循环，然后不断的获取内存中的值，判断是否为最新，然后在进行更新操作。</p><p>假设 <strong>线程A和线程B</strong> 同时执行getAndInt操作（分别跑在不同的CPU上）</p><ol><li><p>AtomicInteger里面的value原始值为3，即主内存中AtomicInteger的 value 为3，根据JMM模型，线程A和线程B各自持有一份价值为3的副本，分别存储在各自的工作内存</p></li><li><p>线程A通过getIntVolatile(var1 , var2) 拿到value值3，这是 <strong>线程A被挂起</strong> （该线程失去CPU执行权）</p></li><li><p>线程B也通过getIntVolatile(var1, var2)方法获取到value值也是3，此时刚好线程B <strong>没有被挂起</strong> ，并执行了compareAndSwapInt方法，比较内存的值也是3，成功修改内存值为4，线程B打完收工，一切OK</p></li><li><p>这是线程A恢复，执行CAS方法，比较发现自己手里的数字3和主内存中的数字4 <strong>不一致</strong> ，说明该值已经被其它线程抢先一步修改过了，那么A线程本次修改失败，只能够 <strong>重新读取</strong> 后在来一遍了，也就是在执行do while</p></li><li><p>线程A重新获取value值， <strong>因为变量value被volatile修饰</strong> ，（unsafe.getAndAddInt(this, valueOffset, 1)传入的this是当前atomicInteger对象，修改的是里面的value字段 ）所以其它线程对它的修改，线程A总能够看到，线程A继续执行compareAndSwapInt进行比较替换，直到成功。</p></li></ol><p>Unsafe类 + CAS思想： 也就是 <strong>自旋</strong> ，自我旋转</p><h2 id="底层汇编"><a href="#底层汇编" class="headerlink" title="底层汇编"></a>底层汇编</h2><p>Unsafe类中的compareAndSwapInt是一个 <strong>本地方法</strong> ，该方法的实现位于 <strong>unsafe.cpp</strong> 中</p><ul><li>先想办法拿到变量value在内存中的地址</li><li>通过Atomic::cmpxchg(x, addr, e) 实现比较替换，其中参数X是即将更新的值，参数e是原内存的值</li></ul><h2 id="CAS缺点"><a href="#CAS缺点" class="headerlink" title="CAS缺点"></a>CAS缺点</h2><p>CAS <strong>不加锁</strong> ，保证一次性，但是 <strong>需要多次比较</strong> </p><ul><li>循环时间长，开销大（因为执行的是do while，如果比较不成功一直在循环，最差的情况，就是某个线程一直取到的值和预期值都不一样，这样就会 <strong>无限循环</strong> ）</li><li>只能 <strong>保证一个共享变量的原子操作</strong> <ul><li>当对一个共享变量执行操作时，我们可以通过循环CAS的方式来保证原子操作</li><li>但是对于多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候 <strong>只能用锁</strong> 来保证原子性</li></ul></li><li>引出来ABA问题？</li></ul><h1 id="原子类AtomicInteger的ABA问题"><a href="#原子类AtomicInteger的ABA问题" class="headerlink" title="原子类AtomicInteger的ABA问题"></a>原子类AtomicInteger的ABA问题</h1><h2 id="前提引入"><a href="#前提引入" class="headerlink" title="前提引入"></a>前提引入</h2><p>从AtomicInteger引出下面的问题</p><p>CAS -&gt; Unsafe -&gt; CAS底层思想 -&gt; ABA -&gt; 原子引用更新 -&gt; 如何规避ABA问题</p><h2 id="ABA问题是什么"><a href="#ABA问题是什么" class="headerlink" title="ABA问题是什么"></a>ABA问题是什么</h2><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210408232736.png"></p><p>假设现在有两个线程，分别是T1 和 T2，然后T1执行某个操作的时间为 <strong>10秒</strong> ，T2执行某个时间的操作是 <strong>2秒</strong> ，最开始AB两个线程，分别从主内存中获取A值，但是因为B的执行速度更快，他先把A的值改成B，然后在修改成A，然后执行完毕，T1线程在10秒后，执行完毕，判断内存中的值为A，并且和自己预期的值一样，它就认为没有人更改了主内存中的值，就快乐的修改成B，但是实际上 可能中间经历了 ABCDEFA 这个变换，也就是中间的值经历了 <strong>狸猫换太子</strong> 。</p><p>所以ABA问题就是，在进行获取主内存值的时候，该内存值在我们写入主内存的时候， <strong>已经被修改了N次</strong> ，但是最终又改成原来的值了</p><h2 id="CAS导致ABA问题"><a href="#CAS导致ABA问题" class="headerlink" title="CAS导致ABA问题"></a>CAS导致ABA问题</h2><p>CAS算法实现了一个重要的前提，需要取出内存中某时刻的数据，并在当下时刻比较并替换，那么这个时间差会导致数据的变化。</p><p>比如说一个线程one从内存位置V中取出A，这时候另外一个线程two也从内存中取出A，并且线程two进行了一些操作将值变成了B，然后线程two又将V位置的数据变成A，这时候线程one进行CAS操作发现内存中仍然是A，然后线程one操作成功</p><p><code>尽管线程one的CAS操作成功，但是不代表这个过程就是没有问题的</code></p><p>CAS只管开头和结尾，也就是头和尾是一样，那就修改成功， <strong>中间的这个过程，可能会被人修改过</strong> </p><h2 id="AtomicReference原子引用"><a href="#AtomicReference原子引用" class="headerlink" title="AtomicReference原子引用"></a>AtomicReference原子引用</h2><p> <strong>原子引用</strong> 其实和 <strong>原子包装类</strong> 是差不多的概念，就是将一个java类， <strong>用原子引用类进行包装起来</strong> ，那么这个类就具备了 <strong>原子性</strong> </p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;    String userName;    <span class="hljs-keyword">int</span> age;    ....&#125;</code></pre><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    User z3 = <span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;zhangsan&quot;</span>, <span class="hljs-number">22</span>);    User l4 = <span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;lisi&quot;</span>, <span class="hljs-number">25</span>);    <span class="hljs-comment">// 创建原子引用包装类</span>    AtomicReference&lt;User&gt; atomicReference = <span class="hljs-keyword">new</span> AtomicReference&lt;&gt;();    <span class="hljs-comment">// 现在主物理内存的共享变量，为z3</span>    atomicReference.set(z3);    <span class="hljs-comment">// 比较并交换，如果现在主物理内存的值为z3，那么交换成l4</span>    System.out.println(atomicReference.compareAndSet(z3, l4) + <span class="hljs-string">&quot;\t &quot;</span> + atomicReference.get().toString());    <span class="hljs-comment">// 比较并交换，现在主物理内存的值是l4了，但是预期为z3，因此交换失败</span>    System.out.println(atomicReference.compareAndSet(z3, l4) + <span class="hljs-string">&quot;\t &quot;</span> + atomicReference.get().toString());&#125;</code></pre><h2 id="基于原子引用的ABA问题"><a href="#基于原子引用的ABA问题" class="headerlink" title="基于原子引用的ABA问题"></a>基于原子引用的ABA问题</h2><pre><code class="hljs java"><span class="hljs-comment">// 测试ABA问题</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Code5_ABADemo</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 普通的原子引用包装类</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">static</span> AtomicReference&lt;Integer&gt; atomicReference = <span class="hljs-keyword">new</span> AtomicReference&lt;&gt;(<span class="hljs-number">100</span>);    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            <span class="hljs-comment">// 把100 改成 101 然后在改成100，也就是ABA</span>            atomicReference.compareAndSet(<span class="hljs-number">100</span>, <span class="hljs-number">101</span>);            atomicReference.compareAndSet(<span class="hljs-number">101</span>, <span class="hljs-number">100</span>);        &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-comment">// 睡眠一秒，保证t1线程，完成了ABA操作</span>                TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;            <span class="hljs-comment">// 把100 改成 101 然后在改成100，也就是ABA</span>            System.out.println(atomicReference.compareAndSet(<span class="hljs-number">100</span>, <span class="hljs-number">2019</span>) + <span class="hljs-string">&quot;\t&quot;</span> + atomicReference.get());        &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();    &#125;&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210408235035.png"></p><p>创建两个线程，然后T1线程，执行一次ABA的操作，T2线程在一秒后修改主内存的值</p><h2 id="解决ABA问题"><a href="#解决ABA问题" class="headerlink" title="解决ABA问题"></a>解决ABA问题</h2><p>新增一种机制，也就是 <strong>修改版本号</strong> ，类似于 <strong>时间戳</strong> 的概念</p><p>T1： 100 1                 （拿到100改成2019） 2</p><p>T2： 100 1     101 2     100 3</p><p>如果T1修改的时候，版本号为2， <strong>落后于</strong> 现在的版本号3，所以要重新获取最新值，这里就提出了一个使用时间戳版本号，来解决ABA问题的思路</p><h2 id="AtomicStampedReference"><a href="#AtomicStampedReference" class="headerlink" title="AtomicStampedReference"></a>AtomicStampedReference</h2><p> <strong>时间戳原子引用</strong> ，来这里应用于版本号的更新，也就是每次更新的时候，需要比较期望值和当前值，以及 <strong>期望版本号和当前版本号</strong> </p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210409000130.png"></p><pre><code class="hljs java"><span class="hljs-comment">// ABA问题的解决</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Code6_ABASolution</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 普通的原子引用包装类</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">static</span> AtomicReference&lt;Integer&gt; atomicReference = <span class="hljs-keyword">new</span> AtomicReference&lt;&gt;(<span class="hljs-number">100</span>);    <span class="hljs-comment">// 传递两个值，一个是初始值，一个是初始版本号</span>    <span class="hljs-keyword">static</span> AtomicStampedReference&lt;Integer&gt; atomicStampedReference = <span class="hljs-keyword">new</span> AtomicStampedReference&lt;&gt;(<span class="hljs-number">100</span>, <span class="hljs-number">1</span>);    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;============以下是ABA问题的产生==========&quot;</span>);        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            <span class="hljs-comment">// 把100 改成 101 然后在改成100，也就是ABA</span>            atomicReference.compareAndSet(<span class="hljs-number">100</span>, <span class="hljs-number">101</span>);            atomicReference.compareAndSet(<span class="hljs-number">101</span>, <span class="hljs-number">100</span>);        &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-comment">// 睡眠一秒，保证t1线程，完成了ABA操作</span>                TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;            <span class="hljs-comment">// 把100 改成 101 然后在改成100，也就是ABA</span>            System.out.println(atomicReference.compareAndSet(<span class="hljs-number">100</span>, <span class="hljs-number">2019</span>) + <span class="hljs-string">&quot;\t&quot;</span> + atomicReference.get());        &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();        System.out.println(<span class="hljs-string">&quot;============以下是ABA问题的解决==========&quot;</span>);        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            <span class="hljs-comment">// 获取版本号</span>            <span class="hljs-keyword">int</span> stamp = atomicStampedReference.getStamp();            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 第一次版本号&quot;</span> + stamp);            <span class="hljs-comment">// 暂停t3一秒钟</span>            <span class="hljs-keyword">try</span> &#123;                TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;            <span class="hljs-comment">// 传入4个值，期望值，更新值，期望版本号，更新版本号</span>            atomicStampedReference.compareAndSet(<span class="hljs-number">100</span>, <span class="hljs-number">101</span>, atomicStampedReference.getStamp(), atomicStampedReference.getStamp()+<span class="hljs-number">1</span>);            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 第二次版本号&quot;</span> + atomicStampedReference.getStamp());            atomicStampedReference.compareAndSet(<span class="hljs-number">101</span>, <span class="hljs-number">100</span>, atomicStampedReference.getStamp(), atomicStampedReference.getStamp()+<span class="hljs-number">1</span>);            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 第三次版本号&quot;</span> + atomicStampedReference.getStamp());        &#125;, <span class="hljs-string">&quot;t3&quot;</span>).start();        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            <span class="hljs-comment">// 获取版本号</span>            <span class="hljs-keyword">int</span> stamp = atomicStampedReference.getStamp();            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 第一次版本号&quot;</span> + stamp);            <span class="hljs-comment">// 暂停t4 3秒钟，保证t3线程也进行一次ABA问题</span>            <span class="hljs-keyword">try</span> &#123;                TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>);            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;            <span class="hljs-keyword">boolean</span> result = atomicStampedReference.compareAndSet(<span class="hljs-number">100</span>, <span class="hljs-number">2019</span>, stamp, stamp+<span class="hljs-number">1</span>);            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 修改成功否：&quot;</span> + result + <span class="hljs-string">&quot;\t 当前最新实际版本号：&quot;</span> + atomicStampedReference.getStamp());            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 当前实际最新值&quot;</span> + atomicStampedReference.getReference());        &#125;, <span class="hljs-string">&quot;t4&quot;</span>).start();    &#125;&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210409000627.png"></p><p>我们能够发现，线程t3，在进行ABA操作后，版本号变更成了3，而线程t4在进行操作的时候，就出现操作失败了，因为版本号和当初拿到的不一样， <strong>无法修改</strong> 。</p><h2 id="CAS拓展优化"><a href="#CAS拓展优化" class="headerlink" title="CAS拓展优化"></a>CAS拓展优化</h2><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://blog.csdn.net/eluanshi12/article/details/84871879">AtomicLong与LongAdder（CAS机制的优化）</a></p><p><a href="https://mp.weixin.qq.com/s/KFsqsCVgyiiTDXMR-Hu1-Q">大白话聊聊Java并发面试问题之Java 8如何优化CAS性能？</a></p><p><a href="https://blog.csdn.net/wolf_love666/article/details/87693771">https://blog.csdn.net/wolf_love666/article/details/87693771</a></p><h1 id="集合类不安全问题"><a href="#集合类不安全问题" class="headerlink" title="集合类不安全问题"></a>集合类不安全问题</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>当我们执行下面语句的时候，底层进行了什么操作</li></ul><pre><code class="hljs java"><span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();</code></pre><p>底层创建了一个空的数组，伴随着初始值为10</p><ul><li>当执行add方法后，如果超过了10，那么会进行扩容，扩容的大小为原值的一半，也就是5个，使用下列方法扩容</li></ul><pre><code class="hljs java">Arrays.copyOf(elementData, netCapacity);</code></pre><h2 id="ArrayList单线程环境下"><a href="#ArrayList单线程环境下" class="headerlink" title="ArrayList单线程环境下"></a>ArrayList单线程环境下</h2><p>单线程环境的ArrayList是不会有问题的</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayListNotSafeDemo</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        list.add(<span class="hljs-string">&quot;a&quot;</span>);        list.add(<span class="hljs-string">&quot;b&quot;</span>);        list.add(<span class="hljs-string">&quot;c&quot;</span>);        <span class="hljs-keyword">for</span>(String element : list) &#123;            System.out.println(element);        &#125;    &#125;&#125;</code></pre><h2 id="多线程环境"><a href="#多线程环境" class="headerlink" title="多线程环境"></a>多线程环境</h2><p>为什么ArrayList是 <strong>线程不安全</strong> 的？因为在进行写操作的时候，方法上为了保证并发性，是 <strong>没有添加synchronized修饰</strong> ，所以并发写的时候，就会出现问题</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210412170344.png"></p><p>当我们同时启动30个线程去操作List的时候</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayListNotSafeDemo</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">30</span>; i++) &#123;            <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;                list.add(UUID.randomUUID().toString().substring(<span class="hljs-number">0</span>, <span class="hljs-number">8</span>));                System.out.println(list);            &#125;, String.valueOf(i)).start();        &#125;    &#125;&#125;</code></pre><p>这个时候出现了错误，也就是java.util.ConcurrentModificationException</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210412170505.png"></p><p>这个异常是  <strong>并发修改的异常</strong> </p><h2 id="ArrayList解决方案"><a href="#ArrayList解决方案" class="headerlink" title="ArrayList解决方案"></a>ArrayList解决方案</h2><h3 id="方案一：Vector"><a href="#方案一：Vector" class="headerlink" title="方案一：Vector"></a>方案一：Vector</h3><p>第一种方法，就是不用ArrayList这种不安全的List实现类，而 <strong>采用Vector</strong> ，线程安全的</p><p>关于Vector如何实现线程安全的，而是在方法上加了锁，即synchronized</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210412171057.png"></p><p>这样就每次只能够一个线程进行操作，所以不会出现线程不安全的问题，但是因为加锁了，导致 <strong>并发性下降</strong> </p><h3 id="方案二：Collections-synchronized"><a href="#方案二：Collections-synchronized" class="headerlink" title="方案二：Collections.synchronized()"></a>方案二：Collections.synchronized()</h3><pre><code class="hljs java">List&lt;String&gt; list = Collections.synchronizedList(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;());</code></pre><p>采用Collections集合工具类，在ArrayList外面包装一层 同步 机制</p><h3 id="方案三：采用JUC里面的方法"><a href="#方案三：采用JUC里面的方法" class="headerlink" title="方案三：采用JUC里面的方法"></a>方案三：采用JUC里面的方法</h3><p>CopyOnWriteArrayList：写时复制，主要是一种 <strong>读写分离</strong> 的思想</p><p>写时复制，CopyOnWrite容器即写时复制的容器，往一个容器中添加元素的时候，不直接往 <strong>当前容器</strong> Object[]添加，而是先将Object[]进行copy， <strong>复制出一个新的容器</strong> object[] newElements，然后新的容器Object[] newElements里添加原始，添加元素完后，在将原容器的引用 <strong>指向新的容器</strong>  setArray(newElements)；这样做的好处是可以对copyOnWrite容器进行并发的度，而不需要加锁，因为当前容器不需要添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器</p><p>就是写的时候，把ArrayList扩容一个出来，然后把值填写上去，在通知其他的线程，ArrayList的引用指向扩容后的</p><p>查看底层add方法源码</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210412172516.png"></p><p>首先需要加锁</p><pre><code class="hljs java"><span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">this</span>.lock;lock.lock();</code></pre><p>然后在末尾扩容一个单位</p><pre><code class="hljs java">Object[] elements = getArray();<span class="hljs-keyword">int</span> len = elements.length;Object[] newElements = Arrays.copyOf(elements, len + <span class="hljs-number">1</span>);</code></pre><p>然后在把扩容后的空间，填写上需要add的内容</p><pre><code class="hljs java">newElements[len] = e;</code></pre><p>最后把内容set到Array中</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210412172718.png"></p><h2 id="HashSet线程不安全"><a href="#HashSet线程不安全" class="headerlink" title="HashSet线程不安全"></a>HashSet线程不安全</h2><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210412174134.png"></p><p>原因也是没有同步机制</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210412174244.png"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210412174310.png"></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="CopyOnWriteArraySet"><a href="#CopyOnWriteArraySet" class="headerlink" title="CopyOnWriteArraySet"></a>CopyOnWriteArraySet</h4><p>底层还是使用CopyOnWriteArrayList进行实例化</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210412174358.png"></p><h4 id="Collections-synchronizedSet"><a href="#Collections-synchronizedSet" class="headerlink" title="Collections.synchronizedSet"></a>Collections.synchronizedSet</h4><h3 id="HashSet底层结构"><a href="#HashSet底层结构" class="headerlink" title="HashSet底层结构"></a>HashSet底层结构</h3><p>HashSet的底层结构就是HashMap</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210412174705.png"></p><p>但是为什么我调用 HashSet.add()的方法，只需要传递一个元素，而HashMap是需要 <strong>传递key-value键值对</strong> ？</p><p>首先我们查看hashSet的 <strong>add方法</strong> </p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;    <span class="hljs-keyword">return</span> map.put(e, PRESENT)==<span class="hljs-keyword">null</span>;&#125;</code></pre><p>我们能发现但我们调用add的时候，存储一个值进入map中，只是作为 <strong>key</strong> 进行存储，而 <strong>value</strong> 存储的是一个Object类型的常量，也就是说HashSet只关心key，而不关心value</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210412174839.png"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210412174858.png"></p><h2 id="HashMap线程不安全"><a href="#HashMap线程不安全" class="headerlink" title="HashMap线程不安全"></a>HashMap线程不安全</h2><p>同理HashMap在多线程环境下，也是不安全的</p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>1、使用Collections.synchronizedMap(new HashMap&lt;&gt;());</p><p>2、使用 ConcurrentHashMap</p><pre><code class="hljs java">Map&lt;String, String&gt; map = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;&gt;();</code></pre><h1 id="TransferValue是什么"><a href="#TransferValue是什么" class="headerlink" title="TransferValue是什么"></a><strong>TransferValue是什么</strong></h1><h2 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h2><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;    <span class="hljs-keyword">private</span> Integer id;    <span class="hljs-keyword">private</span> String personName;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(String personName)</span> </span>&#123;        <span class="hljs-keyword">this</span>.personName = personName;    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TransferValueDemo</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">changeValue1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;        age = <span class="hljs-number">30</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">changeValue2</span><span class="hljs-params">(Person person)</span> </span>&#123;        person.setPersonName(<span class="hljs-string">&quot;XXXX&quot;</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">changeValue3</span><span class="hljs-params">(String str)</span> </span>&#123;        str = <span class="hljs-string">&quot;XXX&quot;</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        TransferValueDemo test = <span class="hljs-keyword">new</span> TransferValueDemo();        <span class="hljs-comment">// 定义基本数据类型</span>        <span class="hljs-keyword">int</span> age = <span class="hljs-number">20</span>;        test.changeValue1(age);        System.out.println(<span class="hljs-string">&quot;age ----&quot;</span> + age);        <span class="hljs-comment">// 实例化person类</span>        Person person = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;abc&quot;</span>);        test.changeValue2(person);        System.out.println(<span class="hljs-string">&quot;personName-----&quot;</span> + person.getPersonName());        <span class="hljs-comment">// String</span>        String str = <span class="hljs-string">&quot;abc&quot;</span>;        test.changeValue3(str);        System.out.println(<span class="hljs-string">&quot;string-----&quot;</span> + str);    &#125;&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210412175818.png"></p><h2 id="changeValue1的执行过程"><a href="#changeValue1的执行过程" class="headerlink" title="changeValue1的执行过程"></a>changeValue1的执行过程</h2><p>八种基本数据类型，在栈里面分配内存，属于 <strong>值传递</strong> </p><pre><code class="hljs plain">栈管运行，堆管存储</code></pre><p>当们执行 changeValue1的时候，因为int是基本数据类型，所以传递的是int = 20这个值，相当于传递的是一个 <strong>副本</strong> ，main方法里面的age并没有改变，因此输出的结果 age还是20，属于值传递</p><p>打印的age一直都是main方法的，传入函数的age是一个副本；</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210412180107.png"></p><h2 id="changeValue2的执行过程"><a href="#changeValue2的执行过程" class="headerlink" title="changeValue2的执行过程"></a>changeValue2的执行过程</h2><p>因为Person是属于对象， <strong>传递的是内存地址</strong> ，当执行changeValue2的时候，会改变内存中的Person的值，属于 <strong>引用传递</strong> ，两个指针都是指向同一个地址</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210412180148.png"></p><h2 id="changeValue3的执行过程"><a href="#changeValue3的执行过程" class="headerlink" title="changeValue3的执行过程"></a>changeValue3的执行过程</h2><p>String不属于基本数据类型，但是为什么执行完成后，还是abc呢？</p><p>这是因为String的特殊性，当我们执行String str = “abc”的时候，它会把 <code>abc</code> 放入常量池中</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210412180300.png"></p><p>当我们执行changeValue3的时候，会重新 <strong>新建一个xxx</strong> ，并 <strong>没有销毁abc</strong> ，然后指向xxx，然后最后我们输出的是   <strong>main中的引用</strong> ，还是指向的abc，因此最后输出结果还是abc</p><h1 id="Java的锁"><a href="#Java的锁" class="headerlink" title="Java的锁"></a><strong>Java的锁</strong></h1><h2 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h2><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><h3 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h3><p>是指多个线程按照 <strong>申请锁的顺序</strong> 来获取锁，类似于排队买饭，先来后到，先来先服务，就是公平的，也就是 <strong>队列</strong> </p><h3 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a>非公平锁</h3><p>是指多个线程获取锁的顺序，并不是按照申请锁的顺序，有可能申请的线程比先申请的线程优先获取锁，在高并发环境下，有可能造成 <strong>优先级翻转</strong> ，或者 <strong>饥饿</strong> 的线程（也就是某个线程一直得不到锁）</p><h2 id="如何创建"><a href="#如何创建" class="headerlink" title="如何创建"></a>如何创建</h2><p>并发包中 <strong>ReentrantLock</strong> 的创建可以指定 <strong>析构函数</strong> 的boolean类型来得到公平锁或者非公平锁，默认是非公平锁</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">* 创建一个可重入锁，true 表示公平锁，false 表示非公平锁。默认非公平锁</span><span class="hljs-comment">*/</span>Lock lock = <span class="hljs-keyword">new</span> ReentrantLock(<span class="hljs-keyword">true</span>);</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210412192606.png"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210412192713.png"></p><h3 id="两者区别"><a href="#两者区别" class="headerlink" title="两者区别"></a>两者区别</h3><p><strong>公平锁</strong>：就是很公平，在并发环境中，每个线程在获取锁时会先查看此锁维护的等待队列，如果为空，或者当前线程是等待队列中的第一个，就占用锁，否者就会加入到等待队列中，以后按照 <strong>FIFO</strong> 的规则从队列中取到自己</p><p><strong>非公平锁：</strong> 非公平锁比较粗鲁，上来就直接尝试占有锁，如果尝试失败，就 <strong>再采用类似公平锁</strong> 那种方式。</p><h3 id="题外"><a href="#题外" class="headerlink" title="题外"></a>题外</h3><p>Java ReenttrantLock通过构造函数指定该锁是否公平，默认是非公平锁，因为非公平锁的优点在于 <strong>吞吐量</strong> 比公平锁大；</p><p><code>对于synchronized而言，也是一种非公平锁</code></p><h2 id="可重入锁-递归锁"><a href="#可重入锁-递归锁" class="headerlink" title="可重入锁(递归锁)"></a>可重入锁(递归锁)</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><p>可重入锁就是 <strong>递归锁</strong> </p><p>指的是同一线程外层函数获得锁之后，内层递归函数仍然能获取到该锁的代码，在同一线程在外层方法获取锁的时候，在进入内层方法会自动获取锁</p><p>也就是说：<code>线程可以进入任何一个它已经拥有的锁所同步的代码块</code></p><p> <strong>ReentrantLock / Synchronized</strong> 就是一个典型的可重入锁</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>可重入锁就是，在一个method1方法中加入一把锁，方法2也加锁了，那么他们拥有的是 <strong>同一把锁</strong> </p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">// 大门锁</span>  method2();<span class="hljs-comment">// 大门锁和小门锁变成一把锁</span>&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">// 小门锁</span>  &#125;</code></pre><p>也就是说我们只需要进入method1后，那么它也能直接进入method2方法，因为他们所拥有的锁，是同一把。</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>可重入锁的最大作用就是 <strong>避免死锁</strong> </p><h3 id="可重入锁验证"><a href="#可重入锁验证" class="headerlink" title="可重入锁验证"></a>可重入锁验证</h3><h4 id="证明Synchronized"><a href="#证明Synchronized" class="headerlink" title="证明Synchronized"></a>证明Synchronized</h4><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 资源类</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Phone</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 发送短信</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendSMS</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t invoked sendSMS()&quot;</span>);        <span class="hljs-comment">// 在同步方法中，调用另外一个同步方法</span>        sendEmail();    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 发邮件</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendEmail</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;        System.out.println(Thread.currentThread().getId() + <span class="hljs-string">&quot;\t invoked sendEmail()&quot;</span>);    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReenterLockDemo</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Phone phone = <span class="hljs-keyword">new</span> Phone();        <span class="hljs-comment">// 两个线程操作资源列</span>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            <span class="hljs-keyword">try</span> &#123;                phone.sendSMS();            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            <span class="hljs-keyword">try</span> &#123;                phone.sendSMS();            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();    &#125;&#125;</code></pre><p>在这里，我们编写了一个资源类phone，拥有两个加了synchronized的同步方法，分别是sendSMS 和 sendEmail，我们在sendSMS方法中，调用sendEmail。最后在主线程同时开启了两个线程进行测试，最后得到的结果为：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210413105219.png"></p><p>这就说明当 t1 线程进入sendSMS的时候，拥有了一把锁，同时t2线程无法进入，直到t1线程拿着锁，执行了sendEmail 方法后，才释放锁，这样t2才能够进入</p><pre><code class="hljs javascript">t1   invoked sendSMS()      t1线程在外层方法获取锁的时候t1   invoked sendEmail()    t1在进入内层方法会自动获取锁t2   invoked sendSMS()      t2线程在外层方法获取锁的时候t2   invoked sendEmail()    t2在进入内层方法会自动获取锁</code></pre><h4 id="证明ReentrantLock"><a href="#证明ReentrantLock" class="headerlink" title="证明ReentrantLock"></a>证明ReentrantLock</h4><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 资源类</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Phone</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;    Lock lock = <span class="hljs-keyword">new</span> ReentrantLock();    <span class="hljs-comment">/**</span><span class="hljs-comment">     * set进去的时候，就加锁，调用set方法的时候，能否访问另外一个加锁的set方法</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getLock</span><span class="hljs-params">()</span> </span>&#123;        lock.lock();        <span class="hljs-keyword">try</span> &#123;            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t get Lock&quot;</span>);            setLock();        &#125; <span class="hljs-keyword">finally</span> &#123;            lock.unlock();        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLock</span><span class="hljs-params">()</span> </span>&#123;        lock.lock();        <span class="hljs-keyword">try</span> &#123;            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t set Lock&quot;</span>);        &#125; <span class="hljs-keyword">finally</span> &#123;            lock.unlock();        &#125;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        getLock();    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReenterLockDemo</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Phone phone = <span class="hljs-keyword">new</span> Phone();        <span class="hljs-comment">/**</span><span class="hljs-comment">         * 因为Phone实现了Runnable接口</span><span class="hljs-comment">         */</span>        Thread t3 = <span class="hljs-keyword">new</span> Thread(phone, <span class="hljs-string">&quot;t3&quot;</span>);        Thread t4 = <span class="hljs-keyword">new</span> Thread(phone, <span class="hljs-string">&quot;t4&quot;</span>);        t3.start();        t4.start();    &#125;&#125;</code></pre><p>我们使用ReentrantLock进行验证，首先资源类实现了Runnable接口，重写Run方法，里面调用get方法，get方法在进入的时候，就加了锁</p><p>然后在方法里面，又调用另外一个加了锁的setLock方法</p><p>最后输出结果我们能发现，结果和加synchronized方法是一致的，都是在 <strong>外层的方法获取锁之后，线程能够直接进入里层</strong> </p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210413105930.png"></p><blockquote><p>如果加两把锁</p></blockquote><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210414075812.png"></p><p>Lock, unlock只要配对就行了；</p><p>最后得到的结果也是一样的，因为里面不管有几把锁，其它他们都是同一把锁，也就是说用同一个钥匙都能够打开</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210414075933.png"></p><blockquote><p>如果缺一个unlock</p></blockquote><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210414080126.png"></p><p>也就是说程序直接卡死，线程不能出来，也就说明我们申请几把锁，最后需要解除几把锁</p><p> <strong>当我们只加一把锁，但是用两把锁来解锁的时候，又会出现什么情况呢？</strong> </p><p>这个时候，运行程序会直接报错</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210414080330.png"></p><h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><p>自旋锁：spinlock，是指尝试获取锁的线程不会立即阻塞，而是采用 <strong>循环</strong> 的方式去尝试 <strong>获取锁</strong> ，这样的好处是 <strong>减少线程上下文切换的消耗</strong> ，缺点是 <strong>循环会消耗CPU</strong> </p><p>原来提到的CAS，底层使用的就是自旋，自旋就是多次尝试，多次访问， <strong>不会阻塞</strong> 的状态就是自旋。</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210414081207.png"></p><h3 id="手写自旋锁"><a href="#手写自旋锁" class="headerlink" title="手写自旋锁"></a>手写自旋锁</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Code10_SpinLockDemo</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpinLockDemo lock = <span class="hljs-keyword">new</span> SpinLockDemo();        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            lock.myLock();            <span class="hljs-comment">// t1等待5s</span>            <span class="hljs-keyword">try</span> &#123;                TimeUnit.SECONDS.sleep(<span class="hljs-number">5</span>);            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;            lock.unLock();        &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();        <span class="hljs-keyword">try</span> &#123;            TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            lock.myLock();            lock.unLock();        &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpinLockDemo</span></span>&#123;    <span class="hljs-comment">// 持有锁的线程，null表示锁未被线程持有</span>    AtomicReference&lt;Thread&gt; atomicReference = <span class="hljs-keyword">new</span> AtomicReference&lt;&gt;();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">myLock</span><span class="hljs-params">()</span></span>&#123;        Thread thread = Thread.currentThread();        System.out.println(thread.getName() + <span class="hljs-string">&quot;: come in!&quot;</span>);        <span class="hljs-keyword">while</span> (!atomicReference.compareAndSet(<span class="hljs-keyword">null</span>, thread))&#123;            <span class="hljs-comment">//当atomicReference为null的时候compareAndSet返回true，反之为false</span>            <span class="hljs-comment">//通过循环不断的自旋判断锁是否被其他线程持有</span>            System.out.println(thread.getName() + <span class="hljs-string">&quot; 自旋....&quot;</span>);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unLock</span><span class="hljs-params">()</span></span>&#123;        Thread thread = Thread.currentThread();        <span class="hljs-comment">// 解锁可以追加判断是否为当前线程 单CAS可以预判断期待值</span>        atomicReference.compareAndSet(thread, <span class="hljs-keyword">null</span>);        System.out.println(thread.getName() + <span class="hljs-string">&quot;: destory!&quot;</span>);    &#125;&#125;</code></pre><p>输出结果：</p><p>一开始：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210414084139.png"></p><p>t1进去占用线程，t2也进去，但循环判断，开始自旋</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210414084243.png"></p><p>然后1秒后，t2线程启动，发现锁被t1占有，所有不断的执行 compareAndSet方法，来进行比较，直到t1释放锁后，也就是5秒后，t2成功获取到锁，然后释放</p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：循环比较获取直到成功为止， <strong>没有</strong> 类似于wait的 <strong>阻塞</strong> </p><p>缺点：当不断自旋的线程越来越多的时候，会因为执行while循环不断的消耗CPU资源</p><h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><h3 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h3><p> <strong>独占锁</strong> ：指该锁一次只能被 <strong>一个线程</strong> 所持有。对ReentrantLock和Synchronized而言都是独占锁</p><p> <strong>共享锁</strong> ：指该锁可以被 <strong>多个线程锁持有</strong> </p><p>对ReentrantReadWriteLock其 <strong>读锁</strong> 是共享，其 <strong>写锁</strong> 是独占</p><p>写的时候只能一个人写，但是读的时候，可以多个人同时读</p><h3 id="为什么会有写锁和读锁"><a href="#为什么会有写锁和读锁" class="headerlink" title="为什么会有写锁和读锁"></a>为什么会有写锁和读锁</h3><p>原来我们使用ReentrantLock创建锁的时候，是独占锁，也就是说一次只能一个线程访问，但是有一个读写分离场景，读的时候想同时进行，因此原来独占锁的并发性就没这么好了，因为 <strong>读锁并不会造成数据不一致</strong> 的问题，因此可以多个人 <strong>共享读</strong> </p><pre><code class="hljs plain">多个线程 同时读一个资源类没有任何问题，所以为了满足并发量，读取共享资源应该可以同时进行，但是如果一个线程想去写共享资源，就不应该再有其它线程可以对该资源进行读或写</code></pre><p>读-读：能共存</p><p>读-写：不能共存</p><p>写-写：不能共存</p><h3 id="手写代码"><a href="#手写代码" class="headerlink" title="手写代码"></a>手写代码</h3><p>实现一个 <strong>读写缓存的操作</strong> ，假设开始 <strong>没有加锁</strong> 的时候，会出现什么情况</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 读写锁</span><span class="hljs-comment"> * 多个线程 同时读一个资源类没有任何问题，所以为了满足并发量，读取共享资源应该可以同时进行</span><span class="hljs-comment"> * 但是，如果一个线程想去写共享资源，就不应该再有其它线程可以对该资源进行读或写</span><span class="hljs-comment"> *</span><span class="hljs-comment"> */</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * 资源类</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCache</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    <span class="hljs-comment">// private Lock lock = null;</span>    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 定义写操作</span><span class="hljs-comment">     * 满足：原子 + 独占</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(String key, Object value)</span> </span>&#123;        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 正在写入：&quot;</span> + key);        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">// 模拟网络拥堵，延迟0.3秒</span>            TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">300</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        map.put(key, value);        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 写入完成&quot;</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">get</span><span class="hljs-params">(String key)</span> </span>&#123;        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 正在读取:&quot;</span>);        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">// 模拟网络拥堵，延迟0.3秒</span>            TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">300</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        Object value = map.get(key);        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 读取完成：&quot;</span> + value);    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Code11_ReadWriteLockDemo</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        MyCache myCache = <span class="hljs-keyword">new</span> MyCache();        <span class="hljs-comment">// 线程操作资源类，5个线程写</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;            <span class="hljs-comment">// lambda表达式内部必须是final</span>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> tempInt = i;            <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;                myCache.put(tempInt + <span class="hljs-string">&quot;&quot;</span>, tempInt +  <span class="hljs-string">&quot;&quot;</span>);            &#125;, String.valueOf(i)).start();        &#125;        <span class="hljs-comment">// 线程操作资源类， 5个线程读</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;            <span class="hljs-comment">// lambda表达式内部必须是final</span>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> tempInt = i;            <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;                myCache.get(tempInt + <span class="hljs-string">&quot;&quot;</span>);            &#125;, String.valueOf(i)).start();        &#125;    &#125;&#125;</code></pre><p>没有加锁的情况下：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210414160436.png"></p><p>在写入的时候，写操作都没完成，其它线程就打断了，这就造成了，还没写完，其它线程又开始读，这样就造成数据不一致</p><h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><p>上面的代码是 <strong>没有加锁</strong> 的，这样就会造成线程在进行写入操作的时候，被其它线程频繁打断，从而不具备原子性，这个时候，我们就需要用到 <strong>读写锁</strong> 来解决了</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 资源类</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyNewCache</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 缓存中的东西，必须保持可见性，因此使用volatile修饰</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 创建一个读写锁</span><span class="hljs-comment">     * 它是一个读写融为一体的锁，在使用的时候，需要转换</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> ReentrantReadWriteLock rwLock = <span class="hljs-keyword">new</span> ReentrantReadWriteLock();    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 定义写操作</span><span class="hljs-comment">     * 满足：原子 + 独占</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(String key, Object value)</span> </span>&#123;        <span class="hljs-comment">// 创建一个写锁</span>        rwLock.writeLock().lock();        <span class="hljs-keyword">try</span> &#123;            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 正在写入：&quot;</span> + key);            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-comment">// 模拟网络拥堵，延迟0.3秒</span>                TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">300</span>);            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;            map.put(key, value);            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 写入完成&quot;</span>);        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">finally</span> &#123;            <span class="hljs-comment">// 写锁 释放</span>            rwLock.writeLock().unlock();        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 获取</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">get</span><span class="hljs-params">(String key)</span> </span>&#123;        <span class="hljs-comment">// 读锁</span>        rwLock.readLock().lock();        <span class="hljs-keyword">try</span> &#123;            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 正在读取:&quot;</span>);            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-comment">// 模拟网络拥堵，延迟0.3秒</span>                TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">300</span>);            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;            Object value = map.get(key);            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 读取完成：&quot;</span> + value);        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">finally</span> &#123;            <span class="hljs-comment">// 读锁释放</span>            rwLock.readLock().unlock();        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 清空缓存</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clean</span><span class="hljs-params">()</span> </span>&#123;        map.clear();    &#125;    &#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210414160844.png"></p><p>从运行结果我们可以看出，写入操作是 <strong>一个一个线程</strong> 进行执行的，并且中间不会被打断，而读操作的时候，是 <strong>同时5个线程进入</strong> ，然后 <strong>并发读</strong> 取操作</p><h1 id="JUC一些包"><a href="#JUC一些包" class="headerlink" title="JUC一些包"></a>JUC一些包</h1><h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><h3 id="概念-4"><a href="#概念-4" class="headerlink" title="概念"></a>概念</h3><p>让一些 <strong>线程阻塞</strong> 直到另一些线程完成一系列操作才被 <strong>唤醒</strong> </p><p>CountDownLatch主要有 <strong>两个方法</strong> ，当一个或多个线程调用await方法时，调用线程就会被阻塞。其它线程调用CountDown方法会将计数器减1（调用CountDown方法的线程不会被阻塞），当计数器的值变成零时，因调用await方法被阻塞的线程会被唤醒，继续执行</p><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>现在有这样一个场景，假设一个自习室里有7个人，其中有一个是班长，班长的主要职责就是在其它6个同学走了后，关灯，锁教室门，然后走人，因此班长是需要最后一个走的，那么有什么方法能够控制班长这个线程是最后一个执行，而其它线程是随机执行的</p><h3 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h3><p>这个时候就用到了CountDownLatch，计数器了。我们一共创建 <strong>6个线程</strong> ，然后 <strong>计数器</strong> 的值也设置成6</p><p>然后每次学生线程执行完，就让计数器的值减1</p><p>最后我们需要通过CountDownLatch的await方法来控制班长主线程的执行，这里 countDownLatch.await()可以想成是一道墙，只有当计数器的值为0的时候，墙才会消失，主线程才能继续往下执行</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;    <span class="hljs-comment">// 计数器</span>    CountDownLatch countDownLatch = <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">6</span>);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">6</span>; i++) &#123;        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 上完自习，离开教室&quot;</span>);            countDownLatch.countDown();        &#125;, String.valueOf(i)).start();    &#125;    countDownLatch.await();    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 班长最后关门&quot;</span>);&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210414164311.png"></p><p>引入CountDownLatch后的执行结果，我们能够控制住main方法的执行，这样能够保证前提任务的执行</p><h3 id="枚举优化拓展"><a href="#枚举优化拓展" class="headerlink" title="枚举优化拓展"></a>枚举优化拓展</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210414165748.png"></p><h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><h3 id="概念-5"><a href="#概念-5" class="headerlink" title="概念"></a>概念</h3><p>和CountDownLatch相反，需要集齐七颗龙珠，召唤神龙。也就是 <strong>做加法</strong> ，开始是0，加到某个值的时候就执行</p><p>CyclicBarrier的字面意思就是可循环（cyclic）使用的屏障（Barrier）。它要求做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活，线程进入屏障通过CyclicBarrier的await方法</p><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>集齐7个龙珠，召唤神龙的Demo，我们需要首先创建CyclicBarrier（ <strong>第二个参数为被阻塞的线程</strong> ）</p><p>然后同时编写七个线程，进行龙珠收集，但一个线程收集到了的时候，我们需要让他执行await方法，等待到7个线程全部执行完毕后，我们就执行原来定义好的方法</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 定义一个循环屏障，参数1：需要累加的值，参数2 需要执行的方法</span><span class="hljs-comment">     */</span>    CyclicBarrier cyclicBarrier = <span class="hljs-keyword">new</span> CyclicBarrier(<span class="hljs-number">7</span>, () -&gt; &#123;        System.out.println(<span class="hljs-string">&quot;召唤神龙&quot;</span>);    &#125;);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">7</span>; i++) &#123;        <span class="hljs-keyword">final</span> Integer tempInt = i;        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 收集到 第&quot;</span> + tempInt + <span class="hljs-string">&quot;颗龙珠&quot;</span>);            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-comment">// 先到的被阻塞，等全部线程完成后，才能执行方法</span>                cyclicBarrier.await();            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125; <span class="hljs-keyword">catch</span> (BrokenBarrierException e) &#123;                e.printStackTrace();            &#125;        &#125;, String.valueOf(i)).start();    &#125;&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210414165944.png"></p><h2 id="Semaphore：信号量"><a href="#Semaphore：信号量" class="headerlink" title="Semaphore：信号量"></a>Semaphore：信号量</h2><h3 id="概念-6"><a href="#概念-6" class="headerlink" title="概念"></a>概念</h3><p>信号量主要用于两个目的</p><ul><li>一个是用于 <strong>共享资源</strong> 的 <strong>互斥</strong> 使用</li><li>另一个用于 <strong>并发线程数</strong> 的控制</li></ul><h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><p>我们模拟一个抢车位的场景，假设一共有 <strong>6个车，3个停车位</strong> </p><p>那么我们首先需要定义信号量为3，也就是3个停车位</p><p>然后我们模拟6辆车同时并发抢占停车位，但第一个车辆抢占到停车位后， <strong>信号量需要减1</strong> </p><p>同时车辆假设需要等待3秒后， <strong>释放信号量</strong> </p><p>最后车辆离开，释放信号量</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 初始化一个信号量为3，默认是false 非公平锁， 模拟3个停车位</span><span class="hljs-comment">     */</span>    Semaphore semaphore = <span class="hljs-keyword">new</span> Semaphore(<span class="hljs-number">3</span>, <span class="hljs-keyword">false</span>);    <span class="hljs-comment">// 模拟6部车</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; i++) &#123;        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-comment">// 代表一辆车，已经占用了该车位</span>                semaphore.acquire(); <span class="hljs-comment">// 抢占</span>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 抢到车位&quot;</span>);                <span class="hljs-comment">// 每个车停3秒</span>                <span class="hljs-keyword">try</span> &#123;                    TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>);                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                &#125;                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 离开车位&quot;</span>);            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125; <span class="hljs-keyword">finally</span> &#123;                <span class="hljs-comment">// 释放停车位</span>                semaphore.release();            &#125;        &#125;, String.valueOf(i)).start();    &#125;&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210414170931.png"></p><h1 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h1><h2 id="概念-7"><a href="#概念-7" class="headerlink" title="概念"></a>概念</h2><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>队列就可以想成是一个数组，从一头进入，一头出去，排队买饭</p><h3 id="阻塞队列-1"><a href="#阻塞队列-1" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><p>BlockingQueue 阻塞队列，排队拥堵，首先它是一个队列，而一个阻塞队列在数据结构中所起的作用大致如下图所示：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210414171141.png"></p><p>线程1往阻塞队列中 <strong>添加元素</strong> ，而线程2从阻塞队列中 <strong>移除元素</strong> </p><ul><li><code>当阻塞队列是空时，从队列中获取元素的操作将会被阻塞</code><ul><li>当蛋糕店的柜子空的时候， <strong>无法</strong> 从柜子里面获取蛋糕</li></ul></li><li><code>当阻塞队列是满时，从队列中添加元素的操作将会被阻塞</code><ul><li>当蛋糕店的柜子满的时候， <strong>无法</strong> 继续向柜子里面添加蛋糕了</li></ul></li></ul><p>也就是说 试图从空的阻塞队列中获取元素的线程将会被阻塞，直到其它线程往空的队列插入新的元素</p><p>同理，试图往已经满的阻塞队列中添加新元素的线程，直到其它线程往满的队列中移除一个或多个元素，或者完全清空队列后，使队列重新变得空闲起来，并后续新增</p><h2 id="为什么要用？"><a href="#为什么要用？" class="headerlink" title="为什么要用？"></a>为什么要用？</h2><p>去海底捞吃饭，大厅满了，需要进候厅等待，但是这些等待的客户能够对商家带来利润，因此我们非常欢迎他们阻塞</p><p>在多线程领域：所谓的阻塞，在某些清空下会 <strong>挂起线程（即阻塞）</strong> ，一旦条件满足，被挂起的线程又会 <strong>自动唤醒</strong> </p><h3 id="为什么需要BlockingQueue"><a href="#为什么需要BlockingQueue" class="headerlink" title="为什么需要BlockingQueue"></a>为什么需要BlockingQueue</h3><p>好处是我们 <strong>不需要关心什么时候</strong> 需要阻塞线程，什么时候需要唤醒线程，因为这一切BlockingQueue都帮你一手包办了</p><p>在concurrent包发布以前，在多线程环境下，我们每个程序员都必须自己取控制这些细节，尤其还要兼顾效率和线程安全，而这会给我们的程序带来不小的复杂度。</p><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>BlockingQueue阻塞队列是属于一个 <strong>接口</strong> ，底下有 <strong>七个实现类</strong> </p><ul><li> <strong>ArrayBlockQueue</strong> ：由数组结构组成的有界阻塞队列</li><li><strong>LinkedBlockingQueue</strong> ：由链表结构组成的有界（但是默认大小 Integer.MAX_VALUE）的阻塞队列<ul><li>有界，但是界限非常大，相当于无界，可以当成无界</li></ul></li><li>PriorityBlockQueue：支持优先级排序的无界阻塞队列</li><li>DelayQueue：使用优先级队列实现的延迟无界阻塞队列</li><li><strong>SynchronousQueue</strong> ：不存储元素的阻塞队列，也即单个元素的队列<ul><li>生产一个，消费一个，不存储元素，不消费不生产</li></ul></li><li>LinkedTransferQueue：由链表结构组成的无界阻塞队列</li><li>LinkedBlockingDeque：由链表结构组成的双向阻塞队列</li></ul><p>这里需要掌握的是：ArrayBlockQueue、LinkedBlockingQueue、SynchronousQueue</p>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法进阶</title>
    <link href="/2021/01/11/%E2%80%9C%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6%E2%80%9D%E7%9A%84%E5%89%AF%E6%9C%AC%202/"/>
    <url>/2021/01/11/%E2%80%9C%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6%E2%80%9D%E7%9A%84%E5%89%AF%E6%9C%AC%202/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="单调栈和滑动窗口"><a href="#单调栈和滑动窗口" class="headerlink" title="单调栈和滑动窗口"></a>单调栈和滑动窗口</h1><h2 id="滑动窗口是什么？"><a href="#滑动窗口是什么？" class="headerlink" title="滑动窗口是什么？"></a>滑动窗口是什么？</h2><p>滑动窗口是一种想象出来的 <strong>数据结构</strong> ：</p><p>滑动窗口有 <strong>左边界L和右边界R</strong> </p><p>在数组或者字符串或者一个序列上，记为S，窗口就是S[L..R]这一部分</p><p>L往右滑意味着一个样本出了窗口，R往右滑意味着一个样本进了窗口</p><p>L和R都只能往右滑</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210119143320.png" alt="滑动窗口"></p><p>注意：任何时候 L &lt;= R，且必须往右动不回退</p><h2 id="滑动窗口能做什么？"><a href="#滑动窗口能做什么？" class="headerlink" title="滑动窗口能做什么？"></a>滑动窗口能做什么？</h2><p>滑动窗口、首尾指针等技巧，说白了是一种求解问题的流程设计。</p><h2 id="滑动内最大值和最小值的更新结构"><a href="#滑动内最大值和最小值的更新结构" class="headerlink" title="滑动内最大值和最小值的更新结构"></a>滑动内最大值和最小值的更新结构</h2><p>窗口不管L还是R滑动之后，都会让窗口呈现新状况，</p><p>如何能够更快的得到窗口当前状况下的最大值和最小值？</p><p>最好平均下来复杂度能做到O(1)</p><p>利用 <strong>单调双端队列！</strong> </p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210119144456.png" alt="双端队列"></p><p>1⃣️ R右移加数：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210119144535.png" alt="Max"></p><p>双端队列 <strong>从大到小</strong> ，如果新的数能落就落，落不下就弹出直至能落下（相等也要弹出）</p><p>2⃣️ L右移减数：</p><p>如果当时情况为：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210119144839.png" alt="当时情况"></p><p>L右移时：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210119145056.png" alt="移动"></p><p>L右移，发现0位置不在，从双端队列 <strong>队首</strong> 开时寻找，没有0，不动；</p><p>L如果再次右移，发现1位置不在，从双端队列 <strong>队首</strong> 开时寻找，1为过期下标，1位置5从头部弹出；</p><p> <strong>双端队列头部</strong> 的数就是此时 <strong>窗口状况</strong> 的 <strong>最大值</strong> </p><p>双端队列的含义：</p><p>已经形成的窗口状况，不让R右移，只让L右移，哪些数会依次成为 <strong>最大值的优先级</strong>；</p><p>复杂度分析：</p><p>一个数最多：入一次，出一次。遍历一次O(N)， <strong>平均</strong> 下来单次代价O(1)</p><h2 id="题一-滑动窗口最大值"><a href="#题一-滑动窗口最大值" class="headerlink" title="题一 滑动窗口最大值"></a>题一 滑动窗口最大值</h2><p>假设一个固定大小为W的窗口，依次划过arr，<br>返回每一次滑出状况的最大值<br>例如，arr = [4,3,5,4,3,3,6,7], W = 3<br>返回：[5,5,5,4,6,7]</p><p class="note note-primary">对应lc239和剑指 59-1</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] getMaxWindow(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> w) &#123;   <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || w &lt; <span class="hljs-number">1</span> || arr.length &lt; w) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;   &#125;   <span class="hljs-comment">// LinkedList双端队列</span>   <span class="hljs-comment">// 其中放的是位置，arr[位置]</span>   LinkedList&lt;Integer&gt; qmax = <span class="hljs-keyword">new</span> LinkedList&lt;Integer&gt;();   <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[arr.length - w + <span class="hljs-number">1</span>];   <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;   <span class="hljs-comment">// [L...R] i 表示 R 进窗口；</span>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123; <span class="hljs-comment">// 当前让 i -&gt; [i] 进窗口 ， i 就是 r</span>      <span class="hljs-comment">// R位置值放到双端队列比他大的数字后面，或者空后</span>      <span class="hljs-keyword">while</span> (!qmax.isEmpty() &amp;&amp; arr[qmax.peekLast()] &lt;= arr[i]) &#123;         qmax.pollLast();      &#125;      qmax.addLast(i);      <span class="hljs-comment">// 数进来了</span>      <span class="hljs-comment">// 如果窗口没有形成w的长度 不会弹出数字</span>      <span class="hljs-comment">// 形成了w的长度 弹出也是弹i - w的位置的数</span>      <span class="hljs-keyword">if</span> (qmax.peekFirst() == i - w) &#123;         qmax.pollFirst();      &#125;      <span class="hljs-comment">// 窗口每一次形成w的长度，收集一次答案</span>      <span class="hljs-keyword">if</span> (i &gt;= w - <span class="hljs-number">1</span>) &#123;         res[index++] = arr[qmax.peekFirst()];      &#125;   &#125;   <span class="hljs-keyword">return</span> res;&#125;</code></pre><h2 id="题二-达标子数组"><a href="#题二-达标子数组" class="headerlink" title="题二 达标子数组"></a>题二 达标子数组</h2><p>给定一个整型数组arr，和一个整数num<br>某个arr中的子数组sub，如果想达标，必须满足：<br>sub中最大值 – sub中最小值 &lt;= num，<br>返回arr中达标子数组的数量</p><p class="note note-primary">对应lc1438</p><p>如果 <strong>子数组arr[L…R]达标</strong> ，内部任何 <strong>子数组</strong> 都达标</p><p>如果 <strong>子数组arr[L…R]不达标</strong> ，L往左或者R往右扩出来的范围也不会达标， 最大值只可能更大，最小值只可能最小</p><p>每一次成长到不达标位置，L右移再求到不达标位置</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210119155530.png" alt="流程"></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getNum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> num)</span> </span>&#123;   <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length == <span class="hljs-number">0</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;   &#125;   LinkedList&lt;Integer&gt; qmin = <span class="hljs-keyword">new</span> LinkedList&lt;Integer&gt;();   LinkedList&lt;Integer&gt; qmax = <span class="hljs-keyword">new</span> LinkedList&lt;Integer&gt;();   <span class="hljs-keyword">int</span> L = <span class="hljs-number">0</span>;   <span class="hljs-keyword">int</span> R = <span class="hljs-number">0</span>;   <span class="hljs-comment">// [L...R) -&gt; [0, 0)一个数没有 [0, 1) -&gt; [0, 0] R表示不达标的第一个位置</span>   <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;   <span class="hljs-keyword">while</span> (L &lt; arr.length) &#123; <span class="hljs-comment">// L是开头位置，尝试每一个开头</span>      <span class="hljs-comment">// 如果此时窗口的开头是L,下面的while工作:R向右扩到违规为止</span>      <span class="hljs-keyword">while</span> (R &lt; arr.length) &#123; <span class="hljs-comment">// R是最后一个达标位置的再下一个</span>         <span class="hljs-keyword">while</span> (!qmin.isEmpty() &amp;&amp; arr[qmin.peekLast()] &gt;= arr[R]) &#123;            qmin.pollLast();         &#125;         qmin.addLast(R);         <span class="hljs-comment">// R -&gt; arr[R],</span>         <span class="hljs-keyword">while</span> (!qmax.isEmpty() &amp;&amp; arr[qmax.peekLast()] &lt;= arr[R]) &#123;            qmax.pollLast();         &#125;         qmax.addLast(R);         <span class="hljs-keyword">if</span> (arr[qmax.getFirst()] - arr[qmin.getFirst()] &gt; num) &#123;            <span class="hljs-keyword">break</span>;         &#125;         R++;      &#125;      <span class="hljs-comment">// R是最后一个达标位置的再下一个，第一个违规的位置</span>      res += R - L;      <span class="hljs-keyword">if</span> (qmin.peekFirst() == L) &#123;         qmin.pollFirst();      &#125;      <span class="hljs-keyword">if</span> (qmax.peekFirst() == L) &#123;         qmax.pollFirst();      &#125;      L++;   &#125;   <span class="hljs-keyword">return</span> res;&#125;</code></pre><p>方法论：</p><p>优化题的方向：</p><ol><li><p>数据状况方向，上题本身就是一个窗口，达标内部就达标，不达标再扩充也不达标，建立了单调性</p></li><li><p>问题本身求的是什么 方向</p></li></ol><h2 id="单调栈是什么？"><a href="#单调栈是什么？" class="headerlink" title="单调栈是什么？"></a>单调栈是什么？</h2><p>一种特别设计的栈结构，为了解决如下的问题：</p><p>给定一个可能含有重复值的数组arr，i位置的数一定存在如下两个信息<br>1）arr[i]的左侧离i最近并且小于(或者大于)arr[i]的数在哪？<br>2）arr[i]的右侧离i最近并且小于(或者大于)arr[i]的数在哪？<br>如果想得到arr中所有位置的 <strong>两个信息</strong> ，怎么能让得到信息的过程尽量快。</p><p>那么到底怎么设计呢？</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210119162030.png" alt="单调栈"></p><p>求每一个数左边和右边比它本身小的表，O(n)</p><blockquote><p>先假设数组中 <strong>没有重复值</strong> </p></blockquote><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210119162432.png" alt="结构"></p><p>轮到 2位置的2想进去时，从栈中开始 <strong>弹出</strong> 生成 <strong>记录</strong> ；</p><p>1位置的4弹出，谁让它弹出，谁就是右边比他小的最近的（2位置的2）；</p><p>1位置的4栈下面压的数（0位置的3）就是左边比他小的最近的；</p><p>接着0位置3弹出生成 <strong>记录</strong> ，</p><p>2位置的2是右边比他小的，下面没有压数据，左边无；</p><p>栈空了，2压入；</p><p>遍历完后，单独处理栈还剩下的东西；</p><p>6位置1被迫弹出，右边无数据，左边为5位置的0；</p><p>5位置的0也被迫弹出，右边无数据，没压数，左边也无；</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[][] getNearLessNoRepeat(<span class="hljs-keyword">int</span>[] arr) &#123;   <span class="hljs-keyword">int</span>[][] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[arr.length][<span class="hljs-number">2</span>];   Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;      <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; arr[stack.peek()] &gt; arr[i]) &#123;         <span class="hljs-keyword">int</span> popIndex = stack.pop();         <span class="hljs-keyword">int</span> leftLessIndex = stack.isEmpty() ? -<span class="hljs-number">1</span> : stack.peek();         res[popIndex][<span class="hljs-number">0</span>] = leftLessIndex;         res[popIndex][<span class="hljs-number">1</span>] = i;      &#125;      stack.push(i);   &#125;   <span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;      <span class="hljs-keyword">int</span> popIndex = stack.pop();      <span class="hljs-keyword">int</span> leftLessIndex = stack.isEmpty() ? -<span class="hljs-number">1</span> : stack.peek();      res[popIndex][<span class="hljs-number">0</span>] = leftLessIndex;      res[popIndex][<span class="hljs-number">1</span>] = -<span class="hljs-number">1</span>;   &#125;   <span class="hljs-keyword">return</span> res;&#125;</code></pre><blockquote><p>假设数组中 有重复值情况</p></blockquote><p class="note note-danger">下面流程有误，第一个3、2搞错了</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210119164743.png" alt="情况"></p><p>生成 <strong>list</strong> ，轮到2位置的3：</p><p>1位置的2 右边最近比他小的就是迫使它弹出的2位置的3；</p><p>1位置的2 左边最新比他小的就是下面list的末尾位置的值（0位置的3）；</p><p>相等把2位置的下标扔进list里面：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210119164943.png" alt="压缩"></p><p>直到：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210119165006.png" alt="情况"></p><p>3位置的4右边就是迫使他弹出的数，即为5位置的3；</p><p>3位置的4左边就是压着的list的末尾，即为2位置的3；</p><p>4位置的4右边还是5位置的3；</p><p>4位置的3右边还是压着的list的末尾；</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210119165159.png" alt="遍历结束"></p><p>6位置的1压入，0，2，5位置的3记录，6右边无左边也无，结束；</p><p>相邻原因：</p><p>1）本身在一起 3445</p><p>2）中间的数都比其大 344553</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[][] getNearLess(<span class="hljs-keyword">int</span>[] arr) &#123;   <span class="hljs-keyword">int</span>[][] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[arr.length][<span class="hljs-number">2</span>];   <span class="hljs-comment">// List&lt;Integer&gt; -&gt; 放的是位置，同样值的东西，位置压在一起</span>   Stack&lt;List&lt;Integer&gt;&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123; <span class="hljs-comment">// i -&gt; arr[i] 进栈</span>      <span class="hljs-comment">// 底 -&gt; 顶， 小 -&gt; 大</span>      <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; arr[stack.peek().get(<span class="hljs-number">0</span>)] &gt; arr[i]) &#123;         List&lt;Integer&gt; popIs = stack.pop();         <span class="hljs-comment">// 取位于下面位置的列表中，最晚加入的那个</span>         <span class="hljs-keyword">int</span> leftLessIndex = stack.isEmpty() ? -<span class="hljs-number">1</span> : stack.peek().get(stack.peek().size() - <span class="hljs-number">1</span>);         <span class="hljs-keyword">for</span> (Integer popi : popIs) &#123;            res[popi][<span class="hljs-number">0</span>] = leftLessIndex;            res[popi][<span class="hljs-number">1</span>] = i;         &#125;      &#125;      <span class="hljs-comment">// 相等的、比你小的</span>      <span class="hljs-keyword">if</span> (!stack.isEmpty() &amp;&amp; arr[stack.peek().get(<span class="hljs-number">0</span>)] == arr[i]) &#123;         stack.peek().add(Integer.valueOf(i));      &#125; <span class="hljs-keyword">else</span> &#123;         ArrayList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();         list.add(i);         stack.push(list);      &#125;   &#125;   <span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;      List&lt;Integer&gt; popIs = stack.pop();      <span class="hljs-comment">// 取位于下面位置的列表中，最晚加入的那个</span>      <span class="hljs-keyword">int</span> leftLessIndex = stack.isEmpty() ? -<span class="hljs-number">1</span> : stack.peek().get(stack.peek().size() - <span class="hljs-number">1</span>);      <span class="hljs-keyword">for</span> (Integer popi : popIs) &#123;         res[popi][<span class="hljs-number">0</span>] = leftLessIndex;         res[popi][<span class="hljs-number">1</span>] = -<span class="hljs-number">1</span>;      &#125;   &#125;   <span class="hljs-keyword">return</span> res;&#125;</code></pre><h2 id="题目三"><a href="#题目三" class="headerlink" title="题目三"></a>题目三</h2><p>给定一个只包含正数的数组arr，arr中任何一个子数组sub，<br>一定都可以算出(sub累加和 )* (sub中的最小值)是什么，<br>那么所有子数组中，这个值最大是多少？</p><p>sub累加和可以用 <strong>前缀和数组</strong> 储存；sum[i]</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210119172219.png" alt="前缀和数组"></p><p>arr[L … R] = arr[0, R] - arr[0, L-1];</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210119172558.png" alt="sub最小值"></p><p>找到以3作最小值的最大子数组；</p><p>再找以4作最小值的最大子数组；</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210119172705.png" alt="重复"></p><p>就是用单调栈：</p><p>求当前数左右比其小的数的位置就是范围：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">max2</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;   <span class="hljs-keyword">int</span> size = arr.length;   <span class="hljs-keyword">int</span>[] sums = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[size];   sums[<span class="hljs-number">0</span>] = arr[<span class="hljs-number">0</span>];   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; size; i++) &#123;      sums[i] = sums[i - <span class="hljs-number">1</span>] + arr[i];   &#125;   <span class="hljs-keyword">int</span> max = Integer.MIN_VALUE;   Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;Integer&gt;();   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;      <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; arr[stack.peek()] &gt;= arr[i]) &#123;         <span class="hljs-keyword">int</span> j = stack.pop();         max = Math.max(max, (stack.isEmpty() ? sums[i - <span class="hljs-number">1</span>] : (sums[i - <span class="hljs-number">1</span>] - sums[stack.peek()])) * arr[j]);      &#125;      stack.push(i);   &#125;   <span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;      <span class="hljs-keyword">int</span> j = stack.pop();      max = Math.max(max, (stack.isEmpty() ? sums[size - <span class="hljs-number">1</span>] : (sums[size - <span class="hljs-number">1</span>] - sums[stack.peek()])) * arr[j]);   &#125;   <span class="hljs-keyword">return</span> max;&#125;</code></pre><h2 id="为什么要求题三？"><a href="#为什么要求题三？" class="headerlink" title="为什么要求题三？"></a>为什么要求题三？</h2><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210119173110.png" alt="求面积"></p><p class="note note-primary">对应lc85</p><h2 id="动态规划-马跳象棋"><a href="#动态规划-马跳象棋" class="headerlink" title="动态规划 马跳象棋"></a>动态规划 马跳象棋</h2><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210119181235.png" alt="暴力"></p><blockquote><p>9、10为棋盘的宽高</p></blockquote><p>改dp：</p><p>k == 0时，x = 0，y = 0才为 1，其他都为0</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210119181921.png" alt="0,0,0"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210119182602.png" alt="dp"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210119182639.png" alt="dp"></p><h1 id="类似斐波那契数列"><a href="#类似斐波那契数列" class="headerlink" title="类似斐波那契数列"></a>类似斐波那契数列</h1><h2 id="优化原理"><a href="#优化原理" class="headerlink" title="优化原理"></a>优化原理</h2><ul><li><p>可以优化为 O(Log(N))的解法：快速幂</p><ul><li><p>斐波那契数列的线性求解（O(N)）的方式非常好理解</p></li><li><p>同时利用线性代数，也可以改写出另一种表示</p><p> | F(N) , F(N-1) | = | F(2), F(1) |  *  某个二阶矩阵的N-2次方</p><p>求出这个二阶矩阵，进而最快求出这个二阶矩阵的N-2次方</p></li></ul></li></ul><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210316145619.png" alt="行列式"></p><p>第三项和第二项组成的行列式 等于 第二项和第一项的行列式乘以一个abcd的矩阵</p><p>第四项和第三项组成的行列式 等于 第三项和第二项的行列式乘以一个同样是abcd的矩阵</p><p>后面跟着的二阶矩阵是 <strong>同一个</strong> </p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210318095005.png" alt="关系"></p><p>再根据下一组数据得到a=b=c=1,d=0</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210318095506.png" alt="最终结论"></p><p>F2和F1分别为1，1；所以后面的矩阵算得快慢等于算法算得快慢</p><blockquote><p>先解决一个数字的次方怎么算得快？</p></blockquote><p>例如10^75次方，75拆成2进制形式，75 = 1001011</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210318100134.png" alt="方法"></p><p>结果为res，先取1相乘，取t等于10^1，每次t与自己相乘，75二进制有1，乘到res里面，</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210318100333.png" alt="进入res的数"></p><p>Log2(75)</p><blockquote><p>反思矩阵</p></blockquote><p>res开始为单位矩阵，对角线为1，其他全为0，</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210318100618.png" alt="方法"></p><pre><code class="hljs java"><span class="hljs-comment">// 矩阵乘法</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">f3</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;   <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">1</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;   &#125;   <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span> || n == <span class="hljs-number">2</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;   &#125;   <span class="hljs-comment">// [ 1 ,1 ]</span>   <span class="hljs-comment">// [ 1, 0 ]</span>   <span class="hljs-keyword">int</span>[][] base = &#123;         &#123; <span class="hljs-number">1</span>, <span class="hljs-number">1</span> &#125;,         &#123; <span class="hljs-number">1</span>, <span class="hljs-number">0</span> &#125;         &#125;;   <span class="hljs-comment">// 求矩阵n-2次方</span>   <span class="hljs-keyword">int</span>[][] res = matrixPower(base, n - <span class="hljs-number">2</span>);   <span class="hljs-keyword">return</span> res[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] + res[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>];&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[][] matrixPower(<span class="hljs-keyword">int</span>[][] m, <span class="hljs-keyword">int</span> p) &#123;   <span class="hljs-keyword">int</span>[][] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m.length][m[<span class="hljs-number">0</span>].length];   <span class="hljs-comment">// res初始为单位矩阵</span>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; res.length; i++) &#123;      res[i][i] = <span class="hljs-number">1</span>;   &#125;   <span class="hljs-comment">// res = 矩阵中的1</span>   <span class="hljs-keyword">int</span>[][] tmp = m;<span class="hljs-comment">// 矩阵1次方 t^1</span>   <span class="hljs-comment">// 次方每次右移一位，直到为0</span>   <span class="hljs-keyword">for</span> (; p != <span class="hljs-number">0</span>; p &gt;&gt;= <span class="hljs-number">1</span>) &#123;      <span class="hljs-comment">// 1为 00000000000001</span>      <span class="hljs-keyword">if</span> ((p &amp; <span class="hljs-number">1</span>) != <span class="hljs-number">0</span>) &#123;         res = muliMatrix(res, tmp);      &#125;      <span class="hljs-comment">// t*t</span>      tmp = muliMatrix(tmp, tmp);   &#125;   <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-comment">// 两个矩阵相乘结果返回</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[][] muliMatrix(<span class="hljs-keyword">int</span>[][] m1, <span class="hljs-keyword">int</span>[][] m2) &#123;   <span class="hljs-keyword">int</span>[][] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m1.length][m2[<span class="hljs-number">0</span>].length];   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m1.length; i++) &#123;      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; m2[<span class="hljs-number">0</span>].length; j++) &#123;         <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; m2.length; k++) &#123;            res[i][j] += m1[i][k] * m2[k][j];         &#125;      &#125;   &#125;   <span class="hljs-keyword">return</span> res;&#125;</code></pre><h2 id="推广"><a href="#推广" class="headerlink" title="推广"></a>推广</h2><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210318102323.png" alt="递推式"></p><p>C1,c2,c3…cz只要是常数，都有logn的解</p><p>如果某个递归，除了初始项之外，具有如下的形式</p><ul><li>F(N) = C1 * F(N) + C2 * F(N-1) + … + Ck * F(N-k) ( C1…Ck 和k都是常数)</li><li>并且这个递归的表达式是 <strong>严格的、不随条件转移的</strong> </li><li>那么都存在类似斐波那契数列的优化，时间复杂度都能优化成O(logN)</li></ul><h2 id="奶牛问题"><a href="#奶牛问题" class="headerlink" title="奶牛问题"></a>奶牛问题</h2><p>第一年农场有1只成熟的母牛A，往后的每年：</p><p>1）每一只成熟的母牛都会生一只母牛</p><p>2）每一只新出生的母牛都在出生后的第三年成熟</p><p>3）每一只母牛永远不会死</p><p>返回N年后牛的数量</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210318103032.png" alt="牛"></p><p>f（n-1）为去年牛数量，f（n-3）为三年前新出生的牛</p><p>很明显是一个三阶问题：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210318103243.png" alt="三阶"></p><p>三阶问题求解方式：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210318103309.png" alt="求解"></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">c1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;   <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">1</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;   &#125;   <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span> || n == <span class="hljs-number">2</span> || n == <span class="hljs-number">3</span>) &#123;      <span class="hljs-keyword">return</span> n;   &#125;   <span class="hljs-keyword">return</span> c1(n - <span class="hljs-number">1</span>) + c1(n - <span class="hljs-number">3</span>);&#125;<span class="hljs-comment">// 矩阵方法</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">c3</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;   <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">1</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;   &#125;   <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span> || n == <span class="hljs-number">2</span> || n == <span class="hljs-number">3</span>) &#123;      <span class="hljs-keyword">return</span> n;   &#125;   <span class="hljs-keyword">int</span>[][] base = &#123; &#123; <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span> &#125;, &#123; <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span> &#125;, &#123; <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span> &#125; &#125;;   <span class="hljs-keyword">int</span>[][] res = matrixPower(base, n - <span class="hljs-number">3</span>);   <span class="hljs-keyword">return</span> <span class="hljs-number">3</span> * res[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] + <span class="hljs-number">2</span> * res[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + res[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>];&#125;</code></pre><blockquote><p>如果母牛十年后会死呢？</p></blockquote><p>递推式减去f(n-10)</p><h2 id="迈楼梯问题"><a href="#迈楼梯问题" class="headerlink" title="迈楼梯问题"></a>迈楼梯问题</h2><p>一个人可以一次往上迈1个台阶，也可以迈2个台阶</p><p>返回这个人迈上N级台阶的方法数</p><p>迈一层方法数为1，迈两层方法数为2，迈三层为f(1)+f(2);迈n层为f(n-1)+f(n-2)</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">s1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;   <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">1</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;   &#125;   <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span> || n == <span class="hljs-number">2</span>) &#123;      <span class="hljs-keyword">return</span> n;   &#125;   <span class="hljs-keyword">return</span> s1(n - <span class="hljs-number">1</span>) + s1(n - <span class="hljs-number">2</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">s3</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;   <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">1</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;   &#125;   <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span> || n == <span class="hljs-number">2</span>) &#123;      <span class="hljs-keyword">return</span> n;   &#125;   <span class="hljs-keyword">int</span>[][] base = &#123; &#123; <span class="hljs-number">1</span>, <span class="hljs-number">1</span> &#125;, &#123; <span class="hljs-number">1</span>, <span class="hljs-number">0</span> &#125; &#125;;   <span class="hljs-keyword">int</span>[][] res = matrixPower(base, n - <span class="hljs-number">2</span>);   <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * res[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] + res[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>];&#125;</code></pre><p>其他：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210318104617.png" alt="迈五步"></p><h2 id="01字符串"><a href="#01字符串" class="headerlink" title="01字符串"></a>01字符串</h2><p>给定一个数N，想象只由0和1两种字符，组成的所有长度为N的字符串</p><p>如果某个字符串,任何0字符的左边都有1紧挨着,认为这个字符串达标</p><p>返回有多少达标的字符串</p><p>定义一个递归 f(i): <strong>表示字符串为i长度，规定其i长度外左边必有一个1，求f(i)可以达标数</strong> </p><p>N = 8时候，求f（7）即可</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210318110045.png" alt="解法"></p><p>f（i） = f（i-1） + f（i-2）</p><h2 id="铺瓷砖问题"><a href="#铺瓷砖问题" class="headerlink" title="铺瓷砖问题"></a>铺瓷砖问题</h2><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210318110254.png" alt="填满方法"></p><p>就看左上角瓷砖怎么摆</p><p>定义函数f(n)如果还有n列没有填满，返回方法数</p><p>如果一开始就竖着摆放：f(n-1)种</p><p>如果一开始就横着摆:只能再用一个瓷砖填满 ;</p><p>所以：f(n) = f(n-1) + f(n-2)</p><h1 id="bfprt算法与蓄水池算法"><a href="#bfprt算法与蓄水池算法" class="headerlink" title="bfprt算法与蓄水池算法"></a>bfprt算法与蓄水池算法</h1><h2 id="bfprt"><a href="#bfprt" class="headerlink" title="bfprt"></a>bfprt</h2><h2 id="笔试推荐-改写快排"><a href="#笔试推荐-改写快排" class="headerlink" title="笔试推荐 改写快排"></a>笔试推荐 改写快排</h2><p>注：bfprt笔试不用，已经有更好的替代。</p><p>解答问题：在一个无序数组中，怎么求第 k 小的数？ O(N)拿下</p><p>可以用 <strong>快排</strong> 的思想解决</p><p>随机选一个m，找命中k的一侧，快排两侧都要排</p><p>为什么是O(N)?</p><p>如果m打的非常正，在中间，下一次只需要划分一半，所以 T(n) = T(n/2) + O(n) 用公式求收敛于O(n)</p><p>如果m打的非常不正，在最边上，T(n) = T (n - 1) + O(n) 是O(n^2)的</p><p>因为随机，所以的概率事件，用表达式收敛，还是收敛于O(n)</p><p>笔试code:</p><pre><code class="hljs java"><span class="hljs-comment">// 改写快排，时间复杂度O(N)</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minKth2</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] array, <span class="hljs-keyword">int</span> k)</span> </span>&#123;   <span class="hljs-keyword">int</span>[] arr = copyArray(array);   <span class="hljs-keyword">return</span> process2(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>, k - <span class="hljs-number">1</span>);&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] copyArray(<span class="hljs-keyword">int</span>[] arr) &#123;   <span class="hljs-keyword">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[arr.length];   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i != ans.length; i++) &#123;      ans[i] = arr[i];   &#125;   <span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-comment">// 在arr[L..R]范围上，如果排序的话，找位于index位置的数</span><span class="hljs-comment">// index一定在[L...R]上</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">process2</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R, <span class="hljs-keyword">int</span> index)</span> </span>&#123;   <span class="hljs-keyword">if</span> (L == R) &#123;      <span class="hljs-keyword">return</span> arr[L];   &#125;   <span class="hljs-comment">// 等概率随机选一个值作划分</span>   <span class="hljs-keyword">int</span> pivot = arr[L + (<span class="hljs-keyword">int</span>) (Math.random() * (R - L + <span class="hljs-number">1</span>))];   <span class="hljs-comment">// range[0] range[1]</span>   <span class="hljs-comment">// L...R pivot在范围上的左边界和右边界</span>   <span class="hljs-keyword">int</span>[] range = partition(arr, L, R, pivot);   <span class="hljs-keyword">if</span> (index &gt;= range[<span class="hljs-number">0</span>] &amp;&amp; index &lt;= range[<span class="hljs-number">1</span>]) &#123;      <span class="hljs-keyword">return</span> arr[index];   &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (index &lt; range[<span class="hljs-number">0</span>]) &#123;      <span class="hljs-keyword">return</span> process2(arr, L, range[<span class="hljs-number">0</span>] - <span class="hljs-number">1</span>, index);   &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-keyword">return</span> process2(arr, range[<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>, R, index);   &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] partition(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R, <span class="hljs-keyword">int</span> pivot) &#123;   <span class="hljs-keyword">int</span> less = L - <span class="hljs-number">1</span>;   <span class="hljs-keyword">int</span> more = R + <span class="hljs-number">1</span>;   <span class="hljs-keyword">int</span> cur = L;   <span class="hljs-keyword">while</span> (cur &lt; more) &#123;      <span class="hljs-keyword">if</span> (arr[cur] &lt; pivot) &#123;         swap(arr, ++less, cur++);      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[cur] &gt; pivot) &#123;         swap(arr, cur, --more);      &#125; <span class="hljs-keyword">else</span> &#123;         cur++;      &#125;   &#125;   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123; less + <span class="hljs-number">1</span>, more - <span class="hljs-number">1</span> &#125;;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> i1, <span class="hljs-keyword">int</span> i2)</span> </span>&#123;   <span class="hljs-keyword">int</span> tmp = arr[i1];   arr[i1] = arr[i2];   arr[i2] = tmp;&#125;</code></pre><h2 id="bfprt是什么？"><a href="#bfprt是什么？" class="headerlink" title="bfprt是什么？"></a>bfprt是什么？</h2><p>不用概率计算，严格流程收敛于O(N)；</p><p>bfprt怎么选这个随机数，是很讲究的。</p><p>第一步：每五个数分成一组，0～4，5～9，最后不足五个凑一组</p><p>第二步：每组自己排序</p><p>第三步：每组中位数拿出来 m0，m1，m2….，最后不足就拿上中位数或下中位数，组成m数组</p><p>第四步：递归调用bfprt把m数组传入，找到m数组的中位数，这个数就是“天选”</p><p>就是把随机选择数，变成分组排序后的中位数数组取中位数</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210320144759.png" alt="求m数组过程"></p><p>假设得到的c是中位数数组的中位数，一定有两个中位数大于等于c，如果整个数字个数为N，一共有N/5个中位数，一共有N/10 + (n/10) * 2 即一共  <strong>3/10倍的N</strong>  的数大于等于c</p><p>所以比c小的数有 7/10的N 的数，数不管在左侧还是右侧，问题只是变成至多大于等于还是小于等于m的数字有多少，反向思考至少小于或者大于的m，一定可以甩掉 3/10倍的N 的规模。</p><p>T(N)=O(n) + T(n/5) + T(7n/10) 数学证明为O（N）</p><pre><code class="hljs java"><span class="hljs-comment">// 利用bfprt算法，时间复杂度O(N)</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minKth3</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] array, <span class="hljs-keyword">int</span> k)</span> </span>&#123;   <span class="hljs-keyword">int</span>[] arr = copyArray(array);   <span class="hljs-keyword">return</span> bfprt(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>, k - <span class="hljs-number">1</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">bfprt</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R, <span class="hljs-keyword">int</span> index)</span> </span>&#123;   <span class="hljs-keyword">if</span> (L == R) &#123;      <span class="hljs-keyword">return</span> arr[L];   &#125;   <span class="hljs-keyword">int</span> pivot = medianOfMedians(arr, L, R);   <span class="hljs-keyword">int</span>[] range = partition(arr, L, R, pivot);   <span class="hljs-keyword">if</span> (index &gt;= range[<span class="hljs-number">0</span>] &amp;&amp; index &lt;= range[<span class="hljs-number">1</span>]) &#123;      <span class="hljs-keyword">return</span> arr[index];   &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (index &lt; range[<span class="hljs-number">0</span>]) &#123;      <span class="hljs-keyword">return</span> bfprt(arr, L, range[<span class="hljs-number">0</span>] - <span class="hljs-number">1</span>, index);   &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-keyword">return</span> bfprt(arr, range[<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>, R, index);   &#125;&#125;<span class="hljs-comment">// arr[L...R]五个一组 内部排序 得到中位数数组，求其中位数</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">medianOfMedians</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R)</span> </span>&#123;   <span class="hljs-keyword">int</span> size = R - L + <span class="hljs-number">1</span>;   <span class="hljs-comment">// offset表示要不要补最后一组</span>   <span class="hljs-keyword">int</span> offset = size % <span class="hljs-number">5</span> == <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>;   <span class="hljs-keyword">int</span>[] mArr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[size / <span class="hljs-number">5</span> + offset];   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> team = <span class="hljs-number">0</span>; team &lt; mArr.length; team++) &#123;      <span class="hljs-keyword">int</span> teamFirst = L + team * <span class="hljs-number">5</span>;      mArr[team] = getMedian(arr, teamFirst, Math.min(R, teamFirst + <span class="hljs-number">4</span>));   &#125;  <span class="hljs-comment">// 调用bfprt找到中位数数组的中位数</span>   <span class="hljs-keyword">return</span> bfprt(mArr, <span class="hljs-number">0</span>, mArr.length - <span class="hljs-number">1</span>, mArr.length / <span class="hljs-number">2</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMedian</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R)</span> </span>&#123;   insertionSort(arr, L, R);   <span class="hljs-keyword">return</span> arr[(L + R) / <span class="hljs-number">2</span>];&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertionSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R)</span> </span>&#123;   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = L + <span class="hljs-number">1</span>; i &lt;= R; i++) &#123;      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i - <span class="hljs-number">1</span>; j &gt;= L &amp;&amp; arr[j] &gt; arr[j + <span class="hljs-number">1</span>]; j--) &#123;         swap(arr, j, j + <span class="hljs-number">1</span>);      &#125;   &#125;&#125;</code></pre><h3 id="bfprt应用"><a href="#bfprt应用" class="headerlink" title="bfprt应用"></a>bfprt应用</h3><p>拿一个数组前十小的数，先找第十小的数，再遍历数组</p><h2 id="蓄水池算法"><a href="#蓄水池算法" class="headerlink" title="蓄水池算法"></a>蓄水池算法</h2><p>一个流蓄水池，在不断吐出有编号的球，有一个只能装十个球的袋子，丢的球不能再找回，</p><p>要求到n号球吐出，所有球被接住的概率均等</p><p>流程：</p><p>1～10全接住，往后的每一个球出来的时候，以10/k的概率决定是否要，如果不要则丢；如果要，则等概率丢弃袋子中一个</p><p>例子：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210318111942.png" alt="例子"></p><p>4~10号球时，3号球在袋子里面的概率是1，当11号球到来时，以10/11的概率决定11是否入袋，并且以1/10的概率决定是否抛弃3号球，所以11号球到来后，3号球还在袋子中的概率为 1*(1-10/11乘1/10) 即为10/11</p><p>现在12号球到来，则为 10/11 乘 （1 * （1 - 10/12乘1/10））即为 10/12</p><p>所以等到17号球到来，3号球在袋子中的概率为10/17</p><p>怎么求当17号球到来时，13号球在袋子里的概率：</p><p>13号被选中为 10/13，14被选中且恰好13被踢出去为 10/14 * 1/10 </p><p>所以14到来，13还在的概率为 10/13 * (1 - 1/14) 即为 10/14</p><p>…..</p><p>当17号球到来时，13号球在袋子里为10/17</p><h3 id="蓄水池举例"><a href="#蓄水池举例" class="headerlink" title="蓄水池举例"></a>蓄水池举例</h3><p>如果有一个游戏公司，上10亿个用户，抽取100个当天登录的幸运儿：</p><p>传统方式：当天登录记录，去重，抽取100个；</p><p>蓄水池方式：取一个能装载100个用户的服务器，当当天每个用户登录时，先判断是否为第一次登录，再写一个方法，确定今天第几个登录的用户，概率就是 100/第几个登录，再利用蓄水池算法剔除，最后公布100人</p><h3 id="1～10概率问题"><a href="#1～10概率问题" class="headerlink" title="1～10概率问题"></a>1～10概率问题</h3><p>已知有一个黑盒，能返回1～7等概率，要求加工，使1～10也能等概率：</p><p>1～7如果roll到7，剔除，认为1～3为roll到0，4～6位roll到1；</p><p>用二进制位表示数，黑盒roll四次能保证0～15等概率；剔除10～15，重做。</p><p>roll出0～9就等于roll出1～10</p><h3 id="01概率问题"><a href="#01概率问题" class="headerlink" title="01概率问题"></a>01概率问题</h3><p>假设roll 0的概率为p，roll 1的概率为 1 - p</p><p>怎么roll 0，1等概率？</p><p>roll两次，出00和11淘汰，出01和10分别代表一个</p><h1 id="KMP算法及其扩展"><a href="#KMP算法及其扩展" class="headerlink" title="KMP算法及其扩展"></a>KMP算法及其扩展</h1><blockquote><p>思考</p></blockquote><p>假设字符串str长度为N，字符串match长度为M，M &lt;= N</p><p>想确定str中是否有某个 <strong>子串是等于match的</strong> 。</p><p>时间复杂度 <strong>O(N)</strong> </p><p>int f(str, match) 返回包含的开始位置</p><p> <strong>子串</strong> 一定是要求连续的</p><p>KMP算法思路仍是试每一个位置，只不过有加速。每一个位置有一个 <strong>指标</strong> ，讨论的是之前的字符串中，前缀跟后缀的 <strong>最长匹配长度</strong> 。</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210319141309.png" alt="匹配"></p><p>还需要长度为4、5，不取到整体，求 <strong>相等的最大长度值为指标值</strong> 。</p><p>设立一个 <strong>next数组</strong> ，保存match的信息。</p><p>0位置信息规定为-1，1位置信息规定为0；</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210319142245.png" alt="信息"></p><p>接下来用next数组加速匹配：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210319142745.png" alt="传统"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210319143217.png" alt="KMP"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210319143950.png" alt="例子"></p><blockquote><p>为什么最长前后缀之前不能配出match？</p></blockquote><p>假设可以，会得出match最后不等字符之前的最长相等前后缀长度值与得到的实际值不一致的矛盾。</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210319150718.png" alt="流程"></p><h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>先对while循环进行分析，只需要分析进去while循环多少次</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210320105747.png" alt="while"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210320105701.png" alt="分析"></p><p>我们设立两个参数，第一个参数就是while中的x，最大能达到N；第二个参数为x - y，最大也只能达到n；</p><p>当命中第一条分支时，x上升，x - y不变；</p><p>以此类推，两个量最大只能达到 2N</p><h2 id="next数组生成"><a href="#next数组生成" class="headerlink" title="next数组生成"></a>next数组生成</h2><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210320111351.png" alt="第一步"></p><p>如果相等就直接等于next[i - 1] + 1了</p><p>如果不等于：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210320111604.png" alt="不等"></p><p>上图打错，是 s位置的值加一</p><h2 id="总体算法"><a href="#总体算法" class="headerlink" title="总体算法"></a>总体算法</h2><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getIndexOf</span><span class="hljs-params">(String s, String m)</span> </span>&#123;   <span class="hljs-keyword">if</span> (s == <span class="hljs-keyword">null</span> || m == <span class="hljs-keyword">null</span> || m.length() &lt; <span class="hljs-number">1</span> || s.length() &lt; m.length()) &#123;      <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;   &#125;   <span class="hljs-keyword">char</span>[] str = s.toCharArray();   <span class="hljs-keyword">char</span>[] match = m.toCharArray();   <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;<span class="hljs-comment">// str中比对到的位置</span>   <span class="hljs-keyword">int</span> y = <span class="hljs-number">0</span>;<span class="hljs-comment">// match中比对到的位置</span>   <span class="hljs-keyword">int</span>[] next = getNextArray(match);   <span class="hljs-keyword">while</span> (x &lt; str.length &amp;&amp; y &lt; match.length) &#123;      <span class="hljs-keyword">if</span> (str[x] == match[y]) &#123;         x++;         y++;      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (next[y] == -<span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 或者y == 0</span>         x++;      &#125; <span class="hljs-keyword">else</span> &#123;         y = next[y];      &#125;   &#125;   <span class="hljs-keyword">return</span> y == match.length ? x - y : -<span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] getNextArray(<span class="hljs-keyword">char</span>[] ms) &#123;   <span class="hljs-keyword">if</span> (ms.length == <span class="hljs-number">1</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123; -<span class="hljs-number">1</span> &#125;;   &#125;   <span class="hljs-keyword">int</span>[] next = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[ms.length];   next[<span class="hljs-number">0</span>] = -<span class="hljs-number">1</span>;   next[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;   <span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>;   <span class="hljs-comment">// cn代表，cn位置的字符，是当前和i-1位置比较的字符</span>   <span class="hljs-keyword">int</span> cn = <span class="hljs-number">0</span>;   <span class="hljs-keyword">while</span> (i &lt; next.length) &#123;      <span class="hljs-keyword">if</span> (ms[i - <span class="hljs-number">1</span>] == ms[cn]) &#123;         next[i++] = ++cn;         <span class="hljs-comment">// ++cn的值必定是next[i-1]的值</span>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cn &gt; <span class="hljs-number">0</span>) &#123;         cn = next[cn];      &#125; <span class="hljs-keyword">else</span> &#123;         next[i++] = <span class="hljs-number">0</span>;      &#125;   &#125;   <span class="hljs-keyword">return</span> next;&#125;</code></pre><p>利用分析上面while循环复杂度的方法分析next生成复杂度</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210320113033.png" alt="复杂度"></p><h2 id="indexOf方法"><a href="#indexOf方法" class="headerlink" title="indexOf方法"></a>indexOf方法</h2><p>indexlof方法后台不是kmp，是比kmp拥有给小的常数的算法，时间复杂度也是O(N)</p><h2 id="KMP应用"><a href="#KMP应用" class="headerlink" title="KMP应用"></a>KMP应用</h2><h3 id="旋转词问题"><a href="#旋转词问题" class="headerlink" title="旋转词问题"></a>旋转词问题</h3><p>给定一个str1和str2，判断是否互为旋转词</p><blockquote><p>旋转词定义</p></blockquote><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210320115002.png" alt="旋转词"></p><p>方法：</p><p>给str1增加一倍，查str2是否为子串</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210320115412.png" alt="方法"></p><p>str1增加一倍从任何地方开头，长度为str1的串，一定是str1的旋转词</p><h3 id="二叉树子树问题"><a href="#二叉树子树问题" class="headerlink" title="二叉树子树问题"></a>二叉树子树问题</h3><p>给定两棵二叉树的头节点head1和head2</p><p>想知道head1中是否有某个子树的结构和head2完全一样</p><p>解法：先序序列化二叉树，找是否包含子串</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210320121908.png" alt="要包含null"></p><p>因为先序序列化一个子串只代表一个结构，没有歧义</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> value;   <span class="hljs-keyword">public</span> Node left;   <span class="hljs-keyword">public</span> Node right;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v)</span> </span>&#123;      value = v;   &#125;&#125;<span class="hljs-comment">// 暴力 big做头节点的树，其中是否有某颗子树的结构和small为头的树完全一样</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">containsTree1</span><span class="hljs-params">(Node big, Node small)</span> </span>&#123;   <span class="hljs-keyword">if</span> (small == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;   &#125;   <span class="hljs-keyword">if</span> (big == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;   &#125;   <span class="hljs-keyword">if</span> (isSameValueStructure(big, small)) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;   &#125;   <span class="hljs-keyword">return</span> containsTree1(big.left, small) || containsTree1(big.right, small);&#125;<span class="hljs-comment">// head1为头的树是否在结构上完全和head2一样</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSameValueStructure</span><span class="hljs-params">(Node head1, Node head2)</span> </span>&#123;   <span class="hljs-keyword">if</span> (head1 == <span class="hljs-keyword">null</span> &amp;&amp; head2 != <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;   &#125;   <span class="hljs-keyword">if</span> (head1 != <span class="hljs-keyword">null</span> &amp;&amp; head2 == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;   &#125;   <span class="hljs-keyword">if</span> (head1 == <span class="hljs-keyword">null</span> &amp;&amp; head2 == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;   &#125;   <span class="hljs-keyword">if</span> (head1.value != head2.value) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;   &#125;   <span class="hljs-comment">// 1 2有值</span>   <span class="hljs-comment">// 1左树等于2左树</span>   <span class="hljs-keyword">return</span> isSameValueStructure(head1.left, head2.left) &amp;&amp; isSameValueStructure(head1.right, head2.right);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">containsTree2</span><span class="hljs-params">(Node big, Node small)</span> </span>&#123;   <span class="hljs-keyword">if</span> (small == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;   &#125;   <span class="hljs-keyword">if</span> (big == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;   &#125;   <span class="hljs-comment">// 先序 含空的</span>   ArrayList&lt;String&gt; b = preSerial(big);   ArrayList&lt;String&gt; s = preSerial(small);   String[] str = <span class="hljs-keyword">new</span> String[b.size()];   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; str.length; i++) &#123;      str[i] = b.get(i);   &#125;   String[] match = <span class="hljs-keyword">new</span> String[s.size()];   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; match.length; i++) &#123;      match[i] = s.get(i);   &#125;   <span class="hljs-keyword">return</span> getIndexOf(str, match) != -<span class="hljs-number">1</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ArrayList&lt;String&gt; <span class="hljs-title">preSerial</span><span class="hljs-params">(Node head)</span> </span>&#123;   ArrayList&lt;String&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();   pres(head, ans);   <span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pres</span><span class="hljs-params">(Node head, ArrayList&lt;String&gt; ans)</span> </span>&#123;   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;      ans.add(<span class="hljs-keyword">null</span>);   &#125; <span class="hljs-keyword">else</span> &#123;      ans.add(String.valueOf(head.value));      pres(head.left, ans);      pres(head.right, ans);   &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getIndexOf</span><span class="hljs-params">(String[] str1, String[] str2)</span> </span>&#123;   <span class="hljs-keyword">if</span> (str1 == <span class="hljs-keyword">null</span> || str2 == <span class="hljs-keyword">null</span> || str1.length &lt; <span class="hljs-number">1</span> || str1.length &lt; str2.length) &#123;      <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;   &#125;   <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;   <span class="hljs-keyword">int</span> y = <span class="hljs-number">0</span>;   <span class="hljs-keyword">int</span>[] next = getNextArray(str2);   <span class="hljs-keyword">while</span> (x &lt; str1.length &amp;&amp; y &lt; str2.length) &#123;      <span class="hljs-keyword">if</span> (isEqual(str1[x], str2[y])) &#123;         x++;         y++;      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (next[y] == -<span class="hljs-number">1</span>) &#123;         x++;      &#125; <span class="hljs-keyword">else</span> &#123;         y = next[y];      &#125;   &#125;   <span class="hljs-keyword">return</span> y == str2.length ? x - y : -<span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] getNextArray(String[] ms) &#123;   <span class="hljs-keyword">if</span> (ms.length == <span class="hljs-number">1</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123; -<span class="hljs-number">1</span> &#125;;   &#125;   <span class="hljs-keyword">int</span>[] next = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[ms.length];   next[<span class="hljs-number">0</span>] = -<span class="hljs-number">1</span>;   next[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;   <span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>;   <span class="hljs-keyword">int</span> cn = <span class="hljs-number">0</span>;   <span class="hljs-keyword">while</span> (i &lt; next.length) &#123;      <span class="hljs-keyword">if</span> (isEqual(ms[i - <span class="hljs-number">1</span>], ms[cn])) &#123;         next[i++] = ++cn;      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cn &gt; <span class="hljs-number">0</span>) &#123;         cn = next[cn];      &#125; <span class="hljs-keyword">else</span> &#123;         next[i++] = <span class="hljs-number">0</span>;      &#125;   &#125;   <span class="hljs-keyword">return</span> next;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEqual</span><span class="hljs-params">(String a, String b)</span> </span>&#123;   <span class="hljs-keyword">if</span> (a == <span class="hljs-keyword">null</span> &amp;&amp; b == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;   &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-keyword">if</span> (a == <span class="hljs-keyword">null</span> || b == <span class="hljs-keyword">null</span>) &#123;         <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;      &#125; <span class="hljs-keyword">else</span> &#123;         <span class="hljs-keyword">return</span> a.equals(b);      &#125;   &#125;&#125;</code></pre><p>改成数组形式，防止歧义：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210320122739.png" alt="防止歧义"></p><h1 id="Manacher算法及其扩展"><a href="#Manacher算法及其扩展" class="headerlink" title="Manacher算法及其扩展"></a>Manacher算法及其扩展</h1><p>假设字符串str长度为N，想返回最长回文子串的长度</p><p>时间复杂度O(N)</p><p>如果暴力定位字符左右两边扩的话，可能会遗失 “虚轴”</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210321121046.png" alt="虚轴"></p><p>暴力定位要变成下面样子：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210321121544.png"></p><p>暴力法最差情况就是全都是一种字符，每次都要扩到一个边界</p><p>前一半是一个等差数列，后一半也是，所以是O(N^2)</p><h2 id="算法概念"><a href="#算法概念" class="headerlink" title="算法概念"></a>算法概念</h2><h3 id="0、回文半径、直径、区域"><a href="#0、回文半径、直径、区域" class="headerlink" title="0、回文半径、直径、区域"></a>0、回文半径、直径、区域</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210322112218.png" alt="回文"></p><h3 id="1、回文半径数组-parr"><a href="#1、回文半径数组-parr" class="headerlink" title="1、回文半径数组(parr)"></a>1、回文半径数组(parr)</h3><p>前面每一步求出来的答案求加速</p><h3 id="2、回文最右右边界-int-R"><a href="#2、回文最右右边界-int-R" class="headerlink" title="2、回文最右右边界(int R)"></a>2、回文最右右边界(int R)</h3><h3 id="3、中心-int-c"><a href="#3、中心-int-c" class="headerlink" title="3、中心(int c)"></a>3、中心(int c)</h3><p>R和C是一组概念，一开始可以认为R C 为-1，没有意义</p><p>拿 #1#2#2#1#…..举例子</p><p>扩到第一个#时候，位置为0，回文区域最右侧到0，比-1大，更新；R更新时，谁让他更新的，就是C，此时为0</p><p>扩到第一个1时候，区域为#1#，右边界2位置，R更新为2；1让R更新，C为1；</p><h2 id="算法过程"><a href="#算法过程" class="headerlink" title="算法过程"></a>算法过程</h2><p>假设当前处于i位置</p><ol><li>i在R外</li></ol><ul><li>没有任何优化，暴力过程，比较i-1，i-2……</li></ul><ol start="2"><li>i在R内，压线也算</li></ol><ul><li>一定存在i在C和R位置之间</li><li><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210322114003.png" alt="一定存在i&#39;"></li><li>再细分对称点，对称点一定是已经求得答案了<ul><li>i’自己的回文区域彻底在L..R大范围的内部，答案 <strong>和i’一样</strong> <ul><li><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210322114447.png" alt="内部"></li><li>如上图，为什么不会有更大区域，因为上图i’旁边的b等于i右边的b；s等于左边的s，但b不等于s，所以就是这么宽的区域</li></ul></li><li>i’自己的回文区域彻底在L..R大范围的外部，<strong>完全不用扩，i到R位置就是新区域</strong> <ul><li><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210322115624.png" alt="在外"></li><li>以k为中心的只能扩到右边Y左边，i’能扩到外面，但i不能，i外面和a一定不等，不在回文内部</li></ul></li><li>i’自己的回文区域和L压线，可能更长，<strong>需要从R后面的字符和C相不相等</strong> <ul><li><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210322120612.png" alt="压线"></li></ul></li></ul></li></ul><h2 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="分支限定"><a href="#分支限定" class="headerlink" title="分支限定"></a>分支限定</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210322165919.png" alt="分支"></p><p>假定R分析四个分支：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210322165735.png" alt="分析"></p><p>R最多跑到N，所以manacher一定是O(N)的算法</p><h2 id="总体算法-1"><a href="#总体算法-1" class="headerlink" title="总体算法"></a>总体算法</h2><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">manacher</span><span class="hljs-params">(String s)</span> </span>&#123;   <span class="hljs-keyword">if</span> (s == <span class="hljs-keyword">null</span> || s.length() == <span class="hljs-number">0</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;   &#125;   <span class="hljs-keyword">char</span>[] str = manacherString(s);   <span class="hljs-comment">// 回文半径的大小</span>   <span class="hljs-keyword">int</span>[] pArr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[str.length];   <span class="hljs-keyword">int</span> C = -<span class="hljs-number">1</span>;   <span class="hljs-keyword">int</span> R = -<span class="hljs-number">1</span>;<span class="hljs-comment">// 课上：R代表最右的扩成功的位置。代码中：最右的扩成功位置的，再下一个位置</span>   <span class="hljs-keyword">int</span> max = Integer.MIN_VALUE;   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i != str.length; i++) &#123;      <span class="hljs-comment">// R是第一个违规的位置 i&gt;=R就相当于第一个分支 i在R外 i至少不用验的区域是自己这个字符 为1</span>      <span class="hljs-comment">// pArr[i] 初始表示不用验证的区域</span>      <span class="hljs-comment">// i位置扩出来的答案，i位置扩的区域，至少是多大。</span>      <span class="hljs-comment">// 如果R &gt; i 包括了i&#x27;区域在里面和在外面</span>      pArr[i] = R &gt; i ? Math.min(pArr[<span class="hljs-number">2</span> * C - i], R - i) : <span class="hljs-number">1</span>;      <span class="hljs-keyword">while</span> (i + pArr[i] &lt; str.length &amp;&amp; i - pArr[i] &gt; -<span class="hljs-number">1</span>) &#123;         <span class="hljs-comment">// 向左向右扩充</span>         <span class="hljs-comment">// 情况2情况3直接进while就退出</span>         <span class="hljs-keyword">if</span> (str[i + pArr[i]] == str[i - pArr[i]])            pArr[i]++;         <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">break</span>;         &#125;      &#125;      <span class="hljs-keyword">if</span> (i + pArr[i] &gt; R) &#123;         <span class="hljs-comment">// i位置扩出来的答案 如果刷新了R 就更新并记录中心</span>         R = i + pArr[i];         C = i;      &#125;      max = Math.max(max, pArr[i]);   &#125;   <span class="hljs-comment">// #1#2#1# 半径 4 - 1 （该算法记录半径）</span>   <span class="hljs-comment">// #1#2#1# 直径 7/2</span>   <span class="hljs-keyword">return</span> max - <span class="hljs-number">1</span>;&#125;<span class="hljs-comment">// 前后加 #</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">char</span>[] manacherString(String str) &#123;   <span class="hljs-keyword">char</span>[] charArr = str.toCharArray();   <span class="hljs-keyword">char</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[str.length() * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>];   <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i != res.length; i++) &#123;      res[i] = (i &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span> ? <span class="hljs-string">&#x27;#&#x27;</span> : charArr[index++];   &#125;   <span class="hljs-keyword">return</span> res;&#125;</code></pre><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>给定字符串str，让字符串整体变成回文串，只能在后面添加字符，求添加最短字符数。</p><blockquote><p>思考：实际是求什么</p></blockquote><p> <strong>必须包含最后一个字符的回文串有多长</strong> </p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210322172919.png" alt="解"></p><p>然后把不是的逆序，就是答案</p><p>找到 <strong>最左侧</strong> 哪个字符位置能包含住最后一个字符。</p><p>或者直接得到全部的回文半径数组。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">shortestEnd</span><span class="hljs-params">(String str)</span> </span>&#123;   <span class="hljs-keyword">if</span> (str == <span class="hljs-keyword">null</span> || str.length() == <span class="hljs-number">0</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;   &#125;   <span class="hljs-keyword">char</span>[] charArr = manacherString(str);   <span class="hljs-keyword">int</span>[] pArr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[charArr.length];   <span class="hljs-keyword">int</span> C = -<span class="hljs-number">1</span>;   <span class="hljs-keyword">int</span> R = -<span class="hljs-number">1</span>;   <span class="hljs-keyword">int</span> maxContainsEnd = -<span class="hljs-number">1</span>;   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i != charArr.length; i++) &#123;      pArr[i] = R &gt; i ? Math.min(pArr[<span class="hljs-number">2</span> * C - i], R - i) : <span class="hljs-number">1</span>;      <span class="hljs-keyword">while</span> (i + pArr[i] &lt; charArr.length &amp;&amp; i - pArr[i] &gt; -<span class="hljs-number">1</span>) &#123;         <span class="hljs-keyword">if</span> (charArr[i + pArr[i]] == charArr[i - pArr[i]])            pArr[i]++;         <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">break</span>;         &#125;      &#125;      <span class="hljs-keyword">if</span> (i + pArr[i] &gt; R) &#123;         R = i + pArr[i];         C = i;      &#125;      <span class="hljs-keyword">if</span> (R == charArr.length) &#123;         maxContainsEnd = pArr[i];         <span class="hljs-keyword">break</span>;      &#125;   &#125;   <span class="hljs-keyword">char</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[str.length() - maxContainsEnd + <span class="hljs-number">1</span>];   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; res.length; i++) &#123;      res[res.length - <span class="hljs-number">1</span> - i] = charArr[i * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>];   &#125;   <span class="hljs-keyword">return</span> String.valueOf(res);&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">char</span>[] manacherString(String str) &#123;   <span class="hljs-keyword">char</span>[] charArr = str.toCharArray();   <span class="hljs-keyword">char</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[str.length() * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>];   <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i != res.length; i++) &#123;      res[i] = (i &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span> ? <span class="hljs-string">&#x27;#&#x27;</span> : charArr[index++];   &#125;   <span class="hljs-keyword">return</span> res;&#125;</code></pre><h1 id="Morris遍历及其相关扩展"><a href="#Morris遍历及其相关扩展" class="headerlink" title="Morris遍历及其相关扩展"></a>Morris遍历及其相关扩展</h1><h2 id="算法概念-1"><a href="#算法概念-1" class="headerlink" title="算法概念"></a>算法概念</h2><p>一种遍历二叉树的方式，并且时间复杂度O(N)， <strong>额外空间复杂度O(1)</strong> </p><p>通过利用原树中大量空闲指针的方式，达到节省空间的目的</p><p>之前递归方法拿栈花费空间，跟高度相关，O(h)。非递归自己压栈，也是O(h)</p><h2 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h2><p>假设来到当前节点cur，开始时cur来到 <strong>头节点</strong> 位置</p><ul><li><ol><li>如果cur没有左孩子，cur向右移动(cur = cur.right)</li></ol></li><li><ol start="2"><li>如果cur有左孩子，找到左子树上最右的节点mostRight：</li></ol><ul><li>如果mostRight的右指针指向null，让其指向cur，然后cur向左移动(cur = cur.left)</li><li>如果mostRight的右指针指向cur，让其指向null，然后cur向右移动(cur = cur.right)</li></ul></li><li><ol start="3"><li>cur为空时遍历停止</li></ol></li></ul><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210323082818.png" alt="例子"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210323083705.png" alt="例子"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210323084354.png" alt="例子2"></p><p>任何一个结点有左孩子，一定来两次；</p><p>没有左孩子的点，只来到一次；</p><h2 id="算法代码"><a href="#算法代码" class="headerlink" title="算法代码"></a>算法代码</h2><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">morrisIn</span><span class="hljs-params">(Node head)</span> </span>&#123;   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span>;   &#125;   Node cur = head;   Node mostRight = <span class="hljs-keyword">null</span>;   <span class="hljs-keyword">while</span> (cur != <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-comment">// cur 有没有左树</span>      mostRight = cur.left;      <span class="hljs-keyword">if</span> (mostRight != <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// 有左树情况下</span>         <span class="hljs-comment">// 找到cur左树上真实的最右节点</span>         <span class="hljs-keyword">while</span> (mostRight.right != <span class="hljs-keyword">null</span> &amp;&amp; mostRight.right != cur) &#123;            mostRight = mostRight.right;         &#125;         <span class="hljs-comment">// 找到了mostRight</span>         <span class="hljs-comment">// mostRight指向空</span>         <span class="hljs-keyword">if</span> (mostRight.right == <span class="hljs-keyword">null</span>) &#123;            mostRight.right = cur;            cur = cur.left;            <span class="hljs-keyword">continue</span>;         &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// mostRight指向cur</span>            mostRight.right = <span class="hljs-keyword">null</span>;         &#125;      &#125;      cur = cur.right;   &#125;&#125;</code></pre><h2 id="morris序实现先序中序后序"><a href="#morris序实现先序中序后序" class="headerlink" title="morris序实现先序中序后序"></a>morris序实现先序中序后序</h2><h3 id="先序"><a href="#先序" class="headerlink" title="先序"></a>先序</h3><p>第一次来到就 <strong>打印</strong> </p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">morrisPre</span><span class="hljs-params">(Node head)</span> </span>&#123;   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span>;   &#125;   Node cur = head;   Node mostRight = <span class="hljs-keyword">null</span>;   <span class="hljs-keyword">while</span> (cur != <span class="hljs-keyword">null</span>) &#123;      mostRight = cur.left;      <span class="hljs-keyword">if</span> (mostRight != <span class="hljs-keyword">null</span>) &#123;         <span class="hljs-keyword">while</span> (mostRight.right != <span class="hljs-keyword">null</span> &amp;&amp; mostRight.right != cur) &#123;            mostRight = mostRight.right;         &#125;         <span class="hljs-keyword">if</span> (mostRight.right == <span class="hljs-keyword">null</span>) &#123;            mostRight.right = cur;           <span class="hljs-comment">// 有左树就第一次打印</span>            System.out.print(cur.value + <span class="hljs-string">&quot; &quot;</span>);            cur = cur.left;            <span class="hljs-keyword">continue</span>;         &#125; <span class="hljs-keyword">else</span> &#123;            mostRight.right = <span class="hljs-keyword">null</span>;         &#125;      &#125; <span class="hljs-keyword">else</span>         <span class="hljs-comment">// 没有左树就打印</span>         System.out.print(cur.value + <span class="hljs-string">&quot; &quot;</span>);      &#125;      cur = cur.right;   &#125;   System.out.println();&#125;</code></pre><h3 id="中序"><a href="#中序" class="headerlink" title="中序"></a>中序</h3><p>能回到自己两次的结点（有左树），第二次打印，不能则直接打印；</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">morrisIn</span><span class="hljs-params">(Node head)</span> </span>&#123;   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span>;   &#125;   Node cur = head;   Node mostRight = <span class="hljs-keyword">null</span>;   <span class="hljs-keyword">while</span> (cur != <span class="hljs-keyword">null</span>) &#123;      mostRight = cur.left;      <span class="hljs-keyword">if</span> (mostRight != <span class="hljs-keyword">null</span>) &#123;          <span class="hljs-keyword">while</span> (mostRight.right != <span class="hljs-keyword">null</span> &amp;&amp; mostRight.right != cur) &#123;            mostRight = mostRight.right;         &#125;<span class="hljs-comment">// 能回到自己结点两次的不打印</span>         <span class="hljs-keyword">if</span> (mostRight.right == <span class="hljs-keyword">null</span>) &#123;            mostRight.right = cur;            cur = cur.left;            <span class="hljs-keyword">continue</span>;         &#125; <span class="hljs-keyword">else</span> &#123;            mostRight.right = <span class="hljs-keyword">null</span>;         &#125;      &#125;      System.out.print(cur.value + <span class="hljs-string">&quot; &quot;</span>);      cur = cur.right;   &#125;   System.out.println();&#125;</code></pre><h3 id="后序"><a href="#后序" class="headerlink" title="后序"></a>后序</h3><p>打印时机放到能回到自己两次，且第二次回到自己的时候；</p><p>打左树的右边界，逆序打印，最后打印自己的最右边界；</p><p>用 <strong>反转链表</strong> 打印 <strong>逆序右边界</strong> </p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210323094725.png" alt="图解"></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">morrisPos</span><span class="hljs-params">(Node head)</span> </span>&#123;   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span>;   &#125;   Node cur = head;   Node mostRight = <span class="hljs-keyword">null</span>;   <span class="hljs-keyword">while</span> (cur != <span class="hljs-keyword">null</span>) &#123;      mostRight = cur.left;      <span class="hljs-keyword">if</span> (mostRight != <span class="hljs-keyword">null</span>) &#123;         <span class="hljs-keyword">while</span> (mostRight.right != <span class="hljs-keyword">null</span> &amp;&amp; mostRight.right != cur) &#123;            mostRight = mostRight.right;         &#125;         <span class="hljs-keyword">if</span> (mostRight.right == <span class="hljs-keyword">null</span>) &#123;            mostRight.right = cur;            cur = cur.left;            <span class="hljs-keyword">continue</span>;         &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// 第二次回到自己 打印左树右边界</span>            mostRight.right = <span class="hljs-keyword">null</span>;            printEdge(cur.left);         &#125;      &#125;      cur = cur.right;   &#125;   <span class="hljs-comment">// 最后打印整棵树的右边界</span>   printEdge(head);   System.out.println();&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printEdge</span><span class="hljs-params">(Node head)</span> </span>&#123;   Node tail = reverseEdge(head);   Node cur = tail;   <span class="hljs-keyword">while</span> (cur != <span class="hljs-keyword">null</span>) &#123;      System.out.print(cur.value + <span class="hljs-string">&quot; &quot;</span>);      cur = cur.right;   &#125;   reverseEdge(tail);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">reverseEdge</span><span class="hljs-params">(Node from)</span> </span>&#123;   Node pre = <span class="hljs-keyword">null</span>;   Node next = <span class="hljs-keyword">null</span>;   <span class="hljs-keyword">while</span> (from != <span class="hljs-keyword">null</span>) &#123;      next = from.right;      from.right = pre;      pre = from;      from = next;   &#125;   <span class="hljs-keyword">return</span> pre;&#125;</code></pre><h2 id="isBST"><a href="#isBST" class="headerlink" title="isBST"></a>isBST</h2><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210323095917.png" alt="isBST"></p><p>把打印过程变成 <strong>比较过程</strong> ；</p><h2 id="最小高度"><a href="#最小高度" class="headerlink" title="最小高度"></a>最小高度</h2><p>给定一棵二叉树的头节点head</p><p>求以head为头的树中，最小深度是多少？</p><h3 id="二叉树递归套路"><a href="#二叉树递归套路" class="headerlink" title="二叉树递归套路"></a>二叉树递归套路</h3><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minHeight1</span><span class="hljs-params">(Node head)</span> </span>&#123;   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;   &#125;   <span class="hljs-keyword">return</span> p(head);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">p</span><span class="hljs-params">(Node x)</span> </span>&#123;   <span class="hljs-keyword">if</span> (x.left == <span class="hljs-keyword">null</span> &amp;&amp; x.right == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;   &#125;   <span class="hljs-comment">// 左右子树起码有一个不为空</span>   <span class="hljs-keyword">int</span> leftH = Integer.MAX_VALUE;   <span class="hljs-keyword">if</span> (x.left != <span class="hljs-keyword">null</span>) &#123;      leftH = p(x.left);   &#125;   <span class="hljs-keyword">int</span> rightH = Integer.MAX_VALUE;   <span class="hljs-keyword">if</span> (x.right != <span class="hljs-keyword">null</span>) &#123;      rightH = p(x.right);   &#125;   <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + Math.min(leftH, rightH);&#125;</code></pre><h3 id="morris遍历求解"><a href="#morris遍历求解" class="headerlink" title="morris遍历求解"></a>morris遍历求解</h3><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minHeight2</span><span class="hljs-params">(Node head)</span> </span>&#123;   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;   &#125;   Node cur = head;   Node mostRight = <span class="hljs-keyword">null</span>;   <span class="hljs-keyword">int</span> curLevel = <span class="hljs-number">0</span>;   <span class="hljs-keyword">int</span> minHeight = Integer.MAX_VALUE;   <span class="hljs-keyword">while</span> (cur != <span class="hljs-keyword">null</span>) &#123;      mostRight = cur.left;      <span class="hljs-keyword">if</span> (mostRight != <span class="hljs-keyword">null</span>) &#123;         <span class="hljs-comment">// 左树上右边界点的个数</span>         <span class="hljs-keyword">int</span> leftHeight = <span class="hljs-number">1</span>;         <span class="hljs-keyword">while</span> (mostRight.right != <span class="hljs-keyword">null</span> &amp;&amp; mostRight.right != cur) &#123;            leftHeight++;            mostRight = mostRight.right;         &#125;         <span class="hljs-keyword">if</span> (mostRight.right == <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// 第一次到达</span>            curLevel++;            mostRight.right = cur;            cur = cur.left;            <span class="hljs-keyword">continue</span>;         &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 第二次到达</span>            <span class="hljs-keyword">if</span> (mostRight.left == <span class="hljs-keyword">null</span>) &#123;               <span class="hljs-comment">// 说明是叶节点，要更新curlevel，跳到上面去了</span>               minHeight = Math.min(minHeight, curLevel);            &#125;            curLevel -= leftHeight;            mostRight.right = <span class="hljs-keyword">null</span>;         &#125;      &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 只有一次到达</span>         curLevel++;      &#125;      cur = cur.right;   &#125;   <span class="hljs-keyword">int</span> finalRight = <span class="hljs-number">1</span>;   cur = head;   <span class="hljs-keyword">while</span> (cur.right != <span class="hljs-keyword">null</span>) &#123;      finalRight++;      cur = cur.right;   &#125;   <span class="hljs-comment">// 单独跑整棵树的最右节点</span>   <span class="hljs-keyword">if</span> (cur.left == <span class="hljs-keyword">null</span> &amp;&amp; cur.right == <span class="hljs-keyword">null</span>) &#123;      minHeight = Math.min(minHeight, finalRight);   &#125;   <span class="hljs-keyword">return</span> minHeight;&#125;</code></pre><h1 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h1><blockquote><p>定义</p></blockquote><ol><li><p>一种支持范围整体修改和范围整体查询的数据结构</p></li><li><p>解决的问题范畴：<br>大范围信息可以只由左、右两侧信息加工出，而不必遍历左右两个子范围的具体状况</p></li></ol><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210328164125.png" alt="线段树"></p><p>线段树的指标三个方法的性能达到log(n)的水平</p><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>给定一个数组arr，用户希望你实现如下三个方法<br>1）void add(int L, int R, int V) :  让数组arr[L…R]上每个数都加上V<br>2）void update(int L, int R, int V) :  让数组arr[L…R]上每个数都变成V<br>3）int sum(int L, int R) :让返回arr[L…R]这个范围整体的累加和<br>怎么让这三个方法，时间复杂度都是O(logN)</p><p class="note note-danger">注意！以下所有数组的规则规定下标从 1 开始！</p><h2 id="build流程"><a href="#build流程" class="headerlink" title="build流程"></a>build流程</h2><p>假设有一种“格子”可以存储位置上的信息</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210328165141.png" alt="存取"></p><p>二分存储信息</p><p>满二叉树的情况下需要格子 2*8-1，最下面8，上面8-1</p><p>现在让这棵树一定变成 <strong>满二叉树</strong> ，往上构建</p><p>假设N个数， <strong>4N</strong> 的空间，一定足够。</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210328171024.png" alt="数组替代"></p><p>i位置左孩子2i，右孩子2i+1</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210328172630.png" alt="build"></p><pre><code class="hljs java"><span class="hljs-comment">// 在初始化阶段，先把sum数组，填好</span><span class="hljs-comment">// 在arr[l~r]范围上，去build，1~N，</span><span class="hljs-comment">// rt :  这个范围在sum中的下标</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> rt)</span> </span>&#123;   <span class="hljs-keyword">if</span> (l == r) &#123;      sum[rt] = arr[l];      <span class="hljs-keyword">return</span>;   &#125;   <span class="hljs-keyword">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;   <span class="hljs-comment">// rt * 2 下标从1开始才可以位运算</span>   build(l, mid, rt &lt;&lt; <span class="hljs-number">1</span>);   <span class="hljs-comment">// rt * 2 + 1</span>   build(mid + <span class="hljs-number">1</span>, r, rt &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>);   pushUp(rt);&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pushUp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rt)</span> </span>&#123; sum[rt] = sum[rt &lt;&lt; <span class="hljs-number">1</span>] + sum[rt &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>];&#125;</code></pre><h2 id="懒更新机制"><a href="#懒更新机制" class="headerlink" title="懒更新机制"></a>懒更新机制</h2><p>不把任务彻底下发到底</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210328180943.png" alt="懒加载"></p><p>就会把1～4加入lazy</p><p>5~8没有包含1～6，5～6放入lazy</p><blockquote><p>为什么要设置lazy？</p></blockquote><p>假设一开始设置要让1～256加7</p><p>下个任务设置要1~100 加3</p><p>lazy发现无法覆盖，下发任务至1～128和129～256</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210328193121.png" alt="下发"></p><h2 id="push-down操作"><a href="#push-down操作" class="headerlink" title="push down操作"></a>push down操作</h2><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210328194721.png" alt="流程"></p><p>前面已经见过两部，左边lazy3，右边lazy4，现在新任务为1 - 1000，加5</p><p>直接懒住</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210328194852.png" alt="懒更新"></p><p>当第四个任务 1 - 1000 加1时：</p><p>1～1024已经懒住一个5，会把之前 <strong>懒住的5往下发</strong> ，左边子树懒8，右边懒9</p><p>1-1024 lazy清空 变为0 后再懒1</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210328200909.png" alt="当第四个任务到来时"></p><p>1-4懒不住</p><p>把lazy发下去，1-2的lazy变成7更新sum，3-4的lazy变成9更新sum</p><p>lazy变成0</p><h2 id="update"><a href="#update" class="headerlink" title="update"></a>update</h2><p>update后应该更新lazy为0</p><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SegmentTree</span> </span>&#123;   <span class="hljs-comment">// arr[]为原序列的信息从0开始，但在arr里是从1开始的</span>   <span class="hljs-comment">// sum[]模拟线段树维护区间和</span>   <span class="hljs-comment">// lazy[]为累加懒惰标记</span>   <span class="hljs-comment">// change[]为更新的值</span>   <span class="hljs-comment">// update[]为更新慵懒标记</span>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> MAXN;   <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] arr;   <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] sum;   <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] lazy;   <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] change;   <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span>[] update;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SegmentTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] origin)</span> </span>&#123;      MAXN = origin.length + <span class="hljs-number">1</span>;      arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[MAXN]; <span class="hljs-comment">// arr[0] 不用  从1开始使用</span>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; MAXN; i++) &#123;         arr[i] = origin[i - <span class="hljs-number">1</span>];      &#125;      sum = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[MAXN &lt;&lt; <span class="hljs-number">2</span>]; <span class="hljs-comment">// 用来支持脑补概念中，某一个范围的累加和信息</span>      lazy = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[MAXN &lt;&lt; <span class="hljs-number">2</span>]; <span class="hljs-comment">// 用来支持脑补概念中，某一个范围沒有往下傳遞的纍加任務</span>      change = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[MAXN &lt;&lt; <span class="hljs-number">2</span>]; <span class="hljs-comment">// 用来支持脑补概念中，某一个范围有没有更新操作的任务</span>      update = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[MAXN &lt;&lt; <span class="hljs-number">2</span>]; <span class="hljs-comment">// 用来支持脑补概念中，某一个范围更新任务，更新成了什么</span>   &#125;   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pushUp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rt)</span> </span>&#123;      sum[rt] = sum[rt &lt;&lt; <span class="hljs-number">1</span>] + sum[rt &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>];   &#125;   <span class="hljs-comment">// 懒更新和懒增加的分发策略</span>   <span class="hljs-comment">// ln表示左子树元素结点个数，rn表示右子树结点个数</span>   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pushDown</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rt, <span class="hljs-keyword">int</span> ln, <span class="hljs-keyword">int</span> rn)</span> </span>&#123;      <span class="hljs-keyword">if</span> (update[rt]) &#123;         update[rt &lt;&lt; <span class="hljs-number">1</span>] = <span class="hljs-keyword">true</span>;         update[rt &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>] = <span class="hljs-keyword">true</span>;         change[rt &lt;&lt; <span class="hljs-number">1</span>] = change[rt];         change[rt &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>] = change[rt];         lazy[rt &lt;&lt; <span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;         lazy[rt &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;         sum[rt &lt;&lt; <span class="hljs-number">1</span>] = change[rt] * ln;         sum[rt &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>] = change[rt] * rn;         update[rt] = <span class="hljs-keyword">false</span>;      &#125;      <span class="hljs-keyword">if</span> (lazy[rt] != <span class="hljs-number">0</span>) &#123;         lazy[rt &lt;&lt; <span class="hljs-number">1</span>] += lazy[rt];         sum[rt &lt;&lt; <span class="hljs-number">1</span>] += lazy[rt] * ln;         lazy[rt &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>] += lazy[rt];         sum[rt &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>] += lazy[rt] * rn;         lazy[rt] = <span class="hljs-number">0</span>;      &#125;   &#125;   <span class="hljs-comment">// 在初始化阶段，先把sum数组，填好</span>   <span class="hljs-comment">// 在arr[l~r]范围上，去build，1~N，</span>   <span class="hljs-comment">// rt :  这个范围在sum中的下标</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> rt)</span> </span>&#123;      <span class="hljs-keyword">if</span> (l == r) &#123;         sum[rt] = arr[l];         <span class="hljs-keyword">return</span>;      &#125;      <span class="hljs-keyword">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;      <span class="hljs-comment">// rt * 2 下标从1开始才可以位运算</span>      build(l, mid, rt &lt;&lt; <span class="hljs-number">1</span>);      <span class="hljs-comment">// rt * 2 + 1</span>      build(mid + <span class="hljs-number">1</span>, r, rt &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>);      pushUp(rt);   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R, <span class="hljs-keyword">int</span> C, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> rt)</span> </span>&#123;      <span class="hljs-keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) &#123;         update[rt] = <span class="hljs-keyword">true</span>;         change[rt] = C;         sum[rt] = C * (r - l + <span class="hljs-number">1</span>);         lazy[rt] = <span class="hljs-number">0</span>;         <span class="hljs-keyword">return</span>;      &#125;      <span class="hljs-comment">// 当前任务躲不掉，无法懒更新，要往下发</span>      <span class="hljs-keyword">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;      pushDown(rt, mid - l + <span class="hljs-number">1</span>, r - mid);      <span class="hljs-keyword">if</span> (L &lt;= mid) &#123;         update(L, R, C, l, mid, rt &lt;&lt; <span class="hljs-number">1</span>);      &#125;      <span class="hljs-keyword">if</span> (R &gt; mid) &#123;         update(L, R, C, mid + <span class="hljs-number">1</span>, r, rt &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>);      &#125;      pushUp(rt);   &#125;   <span class="hljs-comment">// L..R -&gt; 任务范围 ,所有的值累加上C  1～1000</span>   <span class="hljs-comment">// l,r -&gt; 表达的范围  1～1024</span>   <span class="hljs-comment">// rt  去哪找l，r范围上的信息</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R, <span class="hljs-keyword">int</span> C,</span></span><span class="hljs-function"><span class="hljs-params">         <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, </span></span><span class="hljs-function"><span class="hljs-params">         <span class="hljs-keyword">int</span> rt)</span> </span>&#123;      <span class="hljs-comment">// 任务的范围彻底覆盖了，当前表达的范围</span>      <span class="hljs-keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) &#123;         sum[rt] += C * (r - l + <span class="hljs-number">1</span>);         lazy[rt] += C;         <span class="hljs-keyword">return</span>;      &#125;      <span class="hljs-comment">// 要把任务往下发</span>      <span class="hljs-comment">// 任务  L, R  没有把本身表达范围 l,r 彻底包住</span>      <span class="hljs-keyword">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;      <span class="hljs-comment">// 下发之前的lazy add任务</span>      pushDown(rt, mid - l + <span class="hljs-number">1</span>, r - mid);      <span class="hljs-comment">// 左孩子是否需要接到任务</span>      <span class="hljs-keyword">if</span> (L &lt;= mid) &#123;         add(L, R, C, l, mid, rt &lt;&lt; <span class="hljs-number">1</span>);      &#125;      <span class="hljs-comment">// 右孩子是否需要接到任务</span>      <span class="hljs-keyword">if</span> (R &gt; mid) &#123;         add(L, R, C, mid + <span class="hljs-number">1</span>, r, rt &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>);      &#125;      <span class="hljs-comment">// 左右孩子做完任务后，我更新我的sum信息</span>      pushUp(rt);   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> rt)</span> </span>&#123;      <span class="hljs-keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) &#123;         <span class="hljs-keyword">return</span> sum[rt];      &#125;      <span class="hljs-keyword">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;      pushDown(rt, mid - l + <span class="hljs-number">1</span>, r - mid);      <span class="hljs-keyword">long</span> ans = <span class="hljs-number">0</span>;      <span class="hljs-keyword">if</span> (L &lt;= mid) &#123;         ans += query(L, R, l, mid, rt &lt;&lt; <span class="hljs-number">1</span>);      &#125;      <span class="hljs-keyword">if</span> (R &gt; mid) &#123;         ans += query(L, R, mid + <span class="hljs-number">1</span>, r, rt &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>);      &#125;      <span class="hljs-keyword">return</span> ans;   &#125;&#125;</code></pre><h2 id="线段树应用"><a href="#线段树应用" class="headerlink" title="线段树应用"></a>线段树应用</h2><p>想象一下标准的俄罗斯方块游戏，X轴是积木最终下落到底的轴线<br>下面是这个游戏的简化版：<br>1）只会下落正方形积木<br>2）[a,b] -&gt; 代表一个边长为b的正方形积木，积木左边缘沿着X = a这条线从上方掉落<br>3）认为整个X轴都可能接住积木，也就是说简化版游戏是没有整体的左右边界的<br>4）没有整体的左右边界，所以简化版游戏不会消除积木，因为不会有哪一层被填满。</p><p>给定一个N*2的二维数组matrix，可以代表N个积木依次掉落，<br>返回每一次掉落之后的最大高度</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210329045829.png" alt="解"></p><p>返回的是“结果数组”，每一步后的结果都要储存</p><p>假设[3,4 ]应该是3到6范围高度增加，不能增加7，下一个如果沿着7的边界，会被挡住</p><p>线段树的信息代表高度的信息</p><p>来了[ L, H]要看[L, L + H - 1]的高度是多少</p><p>只有update和query操作</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SegmentTree</span> </span>&#123;   <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] max;   <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] change;   <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span>[] update;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SegmentTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span> size)</span> </span>&#123;      <span class="hljs-keyword">int</span> N = size + <span class="hljs-number">1</span>;      max = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[N &lt;&lt; <span class="hljs-number">2</span>];      change = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[N &lt;&lt; <span class="hljs-number">2</span>];      update = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[N &lt;&lt; <span class="hljs-number">2</span>];   &#125;   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pushUp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rt)</span> </span>&#123;      max[rt] = Math.max(max[rt &lt;&lt; <span class="hljs-number">1</span>], max[rt &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>]);   &#125;   <span class="hljs-comment">// ln表示左子树元素结点个数，rn表示右子树结点个数</span>   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pushDown</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rt, <span class="hljs-keyword">int</span> ln, <span class="hljs-keyword">int</span> rn)</span> </span>&#123;      <span class="hljs-keyword">if</span> (update[rt]) &#123;         update[rt &lt;&lt; <span class="hljs-number">1</span>] = <span class="hljs-keyword">true</span>;         update[rt &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>] = <span class="hljs-keyword">true</span>;         change[rt &lt;&lt; <span class="hljs-number">1</span>] = change[rt];         change[rt &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>] = change[rt];         max[rt &lt;&lt; <span class="hljs-number">1</span>] = change[rt];         max[rt &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>] = change[rt];         update[rt] = <span class="hljs-keyword">false</span>;      &#125;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R, <span class="hljs-keyword">int</span> C, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> rt)</span> </span>&#123;      <span class="hljs-keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) &#123;         update[rt] = <span class="hljs-keyword">true</span>;         change[rt] = C;         max[rt] = C;         <span class="hljs-keyword">return</span>;      &#125;      <span class="hljs-keyword">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;      pushDown(rt, mid - l + <span class="hljs-number">1</span>, r - mid);      <span class="hljs-keyword">if</span> (L &lt;= mid) &#123;         update(L, R, C, l, mid, rt &lt;&lt; <span class="hljs-number">1</span>);      &#125;      <span class="hljs-keyword">if</span> (R &gt; mid) &#123;         update(L, R, C, mid + <span class="hljs-number">1</span>, r, rt &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>);      &#125;      pushUp(rt);   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> rt)</span> </span>&#123;      <span class="hljs-keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) &#123;         <span class="hljs-keyword">return</span> max[rt];      &#125;      <span class="hljs-keyword">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;      pushDown(rt, mid - l + <span class="hljs-number">1</span>, r - mid);      <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;      <span class="hljs-keyword">int</span> right = <span class="hljs-number">0</span>;      <span class="hljs-keyword">if</span> (L &lt;= mid) &#123;         left = query(L, R, l, mid, rt &lt;&lt; <span class="hljs-number">1</span>);      &#125;      <span class="hljs-keyword">if</span> (R &gt; mid) &#123;         right = query(L, R, mid + <span class="hljs-number">1</span>, r, rt &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>);      &#125;      <span class="hljs-keyword">return</span> Math.max(left, right);   &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> HashMap&lt;Integer, Integer&gt; <span class="hljs-title">index</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] positions)</span> </span>&#123;   TreeSet&lt;Integer&gt; pos = <span class="hljs-keyword">new</span> TreeSet&lt;&gt;();   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] arr : positions) &#123;      pos.add(arr[<span class="hljs-number">0</span>]);      pos.add(arr[<span class="hljs-number">0</span>] + arr[<span class="hljs-number">1</span>] - <span class="hljs-number">1</span>);   &#125;   HashMap&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();   <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;   <span class="hljs-keyword">for</span> (Integer index : pos) &#123;      <span class="hljs-comment">// 编号排序 从1开始</span>      map.put(index, ++count);   &#125;   <span class="hljs-keyword">return</span> map;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">fallingSquares</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] positions)</span> </span>&#123;   <span class="hljs-comment">// 位置离散化 把所有的块左右两个边界都有哪些值</span>   <span class="hljs-comment">// [100, 7] 认为是[100, 106]为边界</span>   HashMap&lt;Integer, Integer&gt; map = index(positions);   <span class="hljs-keyword">int</span> N = map.size();   <span class="hljs-comment">// 不拿x值修改，拿编好号排好序的修改</span>   SegmentTree segmentTree = <span class="hljs-keyword">new</span> SegmentTree(N);   <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;   List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] arr : positions) &#123;      <span class="hljs-keyword">int</span> L = map.get(arr[<span class="hljs-number">0</span>]);      <span class="hljs-keyword">int</span> R = map.get(arr[<span class="hljs-number">0</span>] + arr[<span class="hljs-number">1</span>] - <span class="hljs-number">1</span>);      <span class="hljs-keyword">int</span> height = segmentTree.query(L, R, <span class="hljs-number">1</span>, N, <span class="hljs-number">1</span>) + arr[<span class="hljs-number">1</span>];      max = Math.max(max, height);      res.add(max);      segmentTree.update(L, R, height, <span class="hljs-number">1</span>, N, <span class="hljs-number">1</span>);   &#125;   <span class="hljs-keyword">return</span> res;&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210329084729.png" alt="第一次"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210329084800.png" alt="第二次"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210329084830.png" alt="第三次"></p><h2 id="线段重合问题"><a href="#线段重合问题" class="headerlink" title="线段重合问题"></a>线段重合问题</h2><p>给你一段线段，求重合线段；</p><p>可以用线段树做，和上面的俄罗斯方块类似，左右边界离散化，遇到线段加1；</p><p>更好实现的方法：</p><p> <strong>开始位置排个序</strong> </p><p>线段开始位置越早越先处理，准备一个小根堆，</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210329090901.png" alt="开始"></p><p>把10放进去：堆里面一个数，</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210329091033.png" alt="第二回"></p><p>两个数；</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210329091131.png" alt="第n回合"></p><blockquote><p>小根堆的意义</p></blockquote><p>之前还有哪些线段会对此时的线段产生影响，这些线段的结尾都在这个小根堆里面；</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210329091740.png"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210329093040.png" alt="code"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210329093106.png" alt="code"></p><h2 id="线段重合拓展"><a href="#线段重合拓展" class="headerlink" title="线段重合拓展"></a>线段重合拓展</h2><p>[1, 3, 2, 1]代表一个矩阵，矩形左上角和右下角</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210329093511.png" alt="矩阵"></p><p>给很多个矩阵，N * 4</p><p>求哪个区域盖的矩形最多，返回数量；</p><blockquote><p>怎么遍历一个矩形？</p></blockquote><p>下底最靠下，最先遍历</p><p>遍历时，假设底是无限延伸的，如果固定一个矩形，下一个矩形的上边都小于底，则不可能覆盖</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210329094432.png" alt="无限延伸"></p><p>再根据左边界右边界抽出来认为是一个线段，就变成了线段重合问题；</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210329094710.png" alt="code"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210329095013.png" alt="code2"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210329095116.png" alt="code3"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210329100521.png" alt="code"></p><blockquote><p> 为什么list要用treeset表示？</p></blockquote><p>要转换为线段重合问题，莫不如修改为set排序好</p><p>while循环是优化，如果底边一样，一票求一下</p><h1 id="AC自动机"><a href="#AC自动机" class="headerlink" title="AC自动机"></a>AC自动机</h1><p>解决在一个大字符串中，找到 <strong>多个候选字符串</strong> 的问题</p><h2 id="AC自动机算法核心"><a href="#AC自动机算法核心" class="headerlink" title="AC自动机算法核心"></a>AC自动机算法核心</h2><p>1）把所有匹配串生成一棵前缀树</p><p>2）前缀树节点增加 <strong>fail指针</strong> ，每一个结点都有</p><p>3）fail指针的含义：如果必须以当前字符结尾，当前形成的路径是str，剩下哪一个字符串的前缀和str的后缀，拥有最大的匹配长度。fail指针就指向那个字符串的最后一个字符所对应的节点。</p><p>头结点fail指针人为规定 <strong>指向空</strong> ，第一级孩子人为规定 <strong>指向头</strong> ；</p><p>加fail指针的方式是前缀树建立好后，再做一个fail指针设定过程（宽度优先遍历）</p><p>再接下来的 fail指针，假如来到X结点，设置孩子的指针，假设通过b到达孩子，自己的fail指针指向甲，如果甲通过b有其他的路，则X的孩子指向这里；</p><p>如果甲没有b的路，找甲的fail指针….直到有b的路，如果都没有，指回头</p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210405004906.png" style="zoom:50%;" /><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210405005439.png" style="zoom:50%;" /><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210405005039.png"></p><p>​    </p><blockquote><p>意义</p></blockquote><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210405010227.png"></p><p>Axctft可以串到xct，f可以串到xctf</p><p>Axctf和xctxxc，t串到xctxxc的t</p><p>其实是 <strong>动态规划</strong> ；</p><h2 id="找寻过程"><a href="#找寻过程" class="headerlink" title="找寻过程"></a>找寻过程</h2><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210405012406.png"></p><p>能到达的点描黑</p><p>每到一个点顺着fail指针收集黑</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210405013416.png"></p><p>收集到了的黑改成白色，收集只是fail指针转一圈，不是到达的结点换位置。</p><h2 id="code-1"><a href="#code-1" class="headerlink" title="code"></a>code</h2><pre><code class="hljs java"><span class="hljs-comment">// 前缀树的节点</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;   <span class="hljs-comment">// 如果一个node，end为空，不是结尾</span>   <span class="hljs-comment">// 如果end不为空，表示这个点是某个字符串的结尾，end的值就是这个字符串</span>   <span class="hljs-keyword">public</span> String end;   <span class="hljs-comment">// 只有在上面的end变量不为空的时候，endUse才有意义</span>   <span class="hljs-comment">// 表示，这个字符串之前有没有加入过答案</span>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> endUse;   <span class="hljs-keyword">public</span> Node fail;   <span class="hljs-keyword">public</span> Node[] nexts;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">()</span> </span>&#123;      endUse = <span class="hljs-keyword">false</span>;      end = <span class="hljs-keyword">null</span>;      fail = <span class="hljs-keyword">null</span>;      nexts = <span class="hljs-keyword">new</span> Node[<span class="hljs-number">26</span>];   &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ACAutomation</span> </span>&#123;   <span class="hljs-keyword">private</span> Node root;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ACAutomation</span><span class="hljs-params">()</span> </span>&#123;      root = <span class="hljs-keyword">new</span> Node();   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(String s)</span> </span>&#123;      <span class="hljs-keyword">char</span>[] str = s.toCharArray();      Node cur = root;      <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; str.length; i++) &#123;         index = str[i] - <span class="hljs-string">&#x27;a&#x27;</span>;         <span class="hljs-keyword">if</span> (cur.nexts[index] == <span class="hljs-keyword">null</span>) &#123;            Node next = <span class="hljs-keyword">new</span> Node();            cur.nexts[index] = next;         &#125;         cur = cur.nexts[index];      &#125;      cur.end = s;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">()</span> </span>&#123;      Queue&lt;Node&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();      queue.add(root);      Node cur = <span class="hljs-keyword">null</span>;      Node cfail = <span class="hljs-keyword">null</span>;      <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;         <span class="hljs-comment">// 当前节点弹出，</span>         <span class="hljs-comment">// 当前节点的所有后代加入到队列里去，</span>         <span class="hljs-comment">// 当前节点给它的子去设置fail指针</span>         <span class="hljs-comment">// cur -&gt; 父亲</span>         cur = queue.poll();         <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++) &#123; <span class="hljs-comment">// 所有的路</span>            <span class="hljs-keyword">if</span> (cur.nexts[i] != <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// 找到所有有效的路</span>               cur.nexts[i].fail = root; <span class="hljs-comment">//</span>               cfail = cur.fail;               <span class="hljs-keyword">while</span> (cfail != <span class="hljs-keyword">null</span>) &#123;                  <span class="hljs-keyword">if</span> (cfail.nexts[i] != <span class="hljs-keyword">null</span>) &#123;                     cur.nexts[i].fail = cfail.nexts[i];                     <span class="hljs-keyword">break</span>;                  &#125;                  cfail = cfail.fail;               &#125;               queue.add(cur.nexts[i]);            &#125;         &#125;      &#125;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">containWords</span><span class="hljs-params">(String content)</span> </span>&#123;      <span class="hljs-keyword">char</span>[] str = content.toCharArray();      Node cur = root;      Node follow = <span class="hljs-keyword">null</span>;      <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;      List&lt;String&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; str.length; i++) &#123;         index = str[i] - <span class="hljs-string">&#x27;a&#x27;</span>; <span class="hljs-comment">// 路</span>         <span class="hljs-comment">// 如果当前字符在这条路上没配出来，就随着fail方向走向下条路径</span>         <span class="hljs-comment">// 如果当前结点没有path的路，通过fail指针跳到别的路上</span>         <span class="hljs-keyword">while</span> (cur.nexts[index] == <span class="hljs-keyword">null</span> &amp;&amp; cur != root) &#123;            cur = cur.fail;         &#125;         <span class="hljs-comment">// 1) 现在来到的路径，是可以继续匹配的</span>         <span class="hljs-comment">// 2) 现在来到的节点，就是前缀树的根节点 来到头了</span>         cur = cur.nexts[index] != <span class="hljs-keyword">null</span> ? cur.nexts[index] : root;         follow = cur;         <span class="hljs-keyword">while</span> (follow != root) &#123;            <span class="hljs-keyword">if</span>(follow.endUse) &#123;               <span class="hljs-keyword">break</span>;            &#125;            <span class="hljs-comment">// 不同的需求，在这一段之间修改</span>            <span class="hljs-keyword">if</span> (follow.end != <span class="hljs-keyword">null</span>) &#123;               ans.add(follow.end);               follow.endUse = <span class="hljs-keyword">true</span>;            &#125;            <span class="hljs-comment">// 不同的需求，在这一段之间修改</span>            follow = follow.fail;         &#125;      &#125;      <span class="hljs-keyword">return</span> ans;   &#125;&#125;</code></pre><h1 id="打表"><a href="#打表" class="headerlink" title="打表"></a>打表</h1><p>1）问题如果返回值不太多，可以用hardcode的方式列出，作为程序的一部分</p><p>2）一个大问题解决时底层频繁使用规模不大的小问题的解，如果小问题的返回值满足条件1），可以把小问题的解列成一张表，作为程序的一部分</p><p>3）打表找规律</p><p>打表是做出一张表，独立于程序之外，参数改变一般不会改变表的数据；</p><h2 id="打表规律"><a href="#打表规律" class="headerlink" title="打表规律"></a>打表规律</h2><p>1）某个面试题，输入参数类型简单，并且只有一个实际参数</p><p>2）要求的返回值类型也简单，并且只有一个</p><p>3）用暴力方法，把输入参数对应的返回值，打印出来看看，进而优化code</p><h2 id="题目1"><a href="#题目1" class="headerlink" title="题目1"></a>题目1</h2><p>小虎去买苹果，商店只提供两种类型的塑料袋，每种类型都有任意数量。<br>1）能装下6个苹果的袋子<br>2）能装下8个苹果的袋子<br>小虎可以自由使用两种袋子来装苹果，但是小虎有强迫症，他要求自己使用的袋子数量必须最少，且使用的每个袋子必须装满。<br>给定一个正整数N，返回至少使用多少袋子。如果N无法让使用的每个袋子必须装满，返回-1</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210329181015.png" alt="正常解题思路"></p><p>解题加速：</p><p>8 6最大公倍数为24</p><p>当剩下的大于24个时，又走循环</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210329181403.png" alt="加速"></p><p>剩余31个的问题等于剩余7个</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minBags</span><span class="hljs-params">(<span class="hljs-keyword">int</span> apple)</span> </span>&#123;   <span class="hljs-keyword">if</span> (apple &lt; <span class="hljs-number">0</span>) &#123;      <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;   &#125;   <span class="hljs-keyword">int</span> bag6 = -<span class="hljs-number">1</span>;   <span class="hljs-keyword">int</span> bag8 = apple / <span class="hljs-number">8</span>;   <span class="hljs-keyword">int</span> rest = apple - <span class="hljs-number">8</span> * bag8;   <span class="hljs-keyword">while</span> (bag8 &gt;= <span class="hljs-number">0</span> &amp;&amp; rest &lt; <span class="hljs-number">24</span>) &#123;      <span class="hljs-keyword">int</span> restUse6 = minBagBase6(rest);      <span class="hljs-keyword">if</span> (restUse6 != -<span class="hljs-number">1</span>) &#123;         bag6 = restUse6;         <span class="hljs-keyword">break</span>;      &#125;      rest = apple - <span class="hljs-number">8</span> * (--bag8);   &#125;   <span class="hljs-keyword">return</span> bag6 == -<span class="hljs-number">1</span> ? -<span class="hljs-number">1</span> : bag6 + bag8;&#125;<span class="hljs-comment">// 如果剩余苹果rest可以被装6个苹果的袋子搞定，返回袋子数量</span><span class="hljs-comment">// 不能搞定返回-1</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minBagBase6</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rest)</span> </span>&#123;   <span class="hljs-keyword">return</span> rest % <span class="hljs-number">6</span> == <span class="hljs-number">0</span> ? (rest / <span class="hljs-number">6</span>) : -<span class="hljs-number">1</span>;&#125;</code></pre><h3 id="打表解题"><a href="#打表解题" class="headerlink" title="打表解题"></a>打表解题</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210329181632.png" alt="规律"></p><p>18开始奇数-1，偶数3</p><p>26开始奇数-1，偶数4</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minBagAwesome</span><span class="hljs-params">(<span class="hljs-keyword">int</span> apple)</span> </span>&#123;   <span class="hljs-keyword">if</span> ((apple &amp; <span class="hljs-number">1</span>) != <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 如果是奇数，返回-1</span>      <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;   &#125;   <span class="hljs-keyword">if</span> (apple &lt; <span class="hljs-number">18</span>) &#123;      <span class="hljs-keyword">return</span> apple == <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : (apple == <span class="hljs-number">6</span> || apple == <span class="hljs-number">8</span>) ? <span class="hljs-number">1</span>            : (apple == <span class="hljs-number">12</span> || apple == <span class="hljs-number">14</span> || apple == <span class="hljs-number">16</span>) ? <span class="hljs-number">2</span> : -<span class="hljs-number">1</span>;   &#125;   <span class="hljs-keyword">return</span> (apple - <span class="hljs-number">18</span>) / <span class="hljs-number">8</span> + <span class="hljs-number">3</span>;&#125;</code></pre><h2 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h2><p>给定一个正整数N，表示有N份青草统一堆放在仓库里<br>有一只牛和一只羊，牛先吃，羊后吃，它俩轮流吃草<br>不管是牛还是羊，每一轮能吃的草量必须是：<br>1，4，16，64…(4的某次方)<br>谁最先把草吃完，谁获胜<br>假设牛和羊都绝顶聪明，都想赢，都会做出理性的决定<br>根据唯一的参数N，返回谁会赢</p><pre><code class="hljs java"><span class="hljs-comment">// n份青草放在一堆</span><span class="hljs-comment">// 先手后手都绝顶聪明</span><span class="hljs-comment">// string &quot;先手&quot; &quot;后手&quot;</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">winner1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;   <span class="hljs-comment">// 0  1  2  3 4</span>   <span class="hljs-comment">// 后 先 后 先 先</span>   <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">5</span>) &#123; <span class="hljs-comment">// base case</span>      <span class="hljs-keyword">return</span> (n == <span class="hljs-number">0</span> || n == <span class="hljs-number">2</span>) ? <span class="hljs-string">&quot;后手&quot;</span> : <span class="hljs-string">&quot;先手&quot;</span>;   &#125;   <span class="hljs-comment">// n &gt;= 5 时</span>   <span class="hljs-keyword">int</span> base = <span class="hljs-number">1</span>; <span class="hljs-comment">// 当前先手决定吃的草数</span>   <span class="hljs-comment">// 当前是先手在选</span>   <span class="hljs-keyword">while</span> (base &lt;= n) &#123;      <span class="hljs-comment">// 当前一共n份草，先手吃掉的是base份，n - base 是留给后手的草</span>      <span class="hljs-comment">// 母过程 先手 在子过程里是 后手</span>      <span class="hljs-keyword">if</span> (winner1(n - base).equals(<span class="hljs-string">&quot;后手&quot;</span>)) &#123;         <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;先手&quot;</span>;      &#125;      <span class="hljs-keyword">if</span> (base &gt; n / <span class="hljs-number">4</span>) &#123; <span class="hljs-comment">// 防止base*4之后溢出</span>         <span class="hljs-keyword">break</span>;      &#125;      <span class="hljs-comment">// 第一次用1 下回试试4 下回试试16.....</span>      base *= <span class="hljs-number">4</span>;   &#125;   <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;后手&quot;</span>;&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210329185551.png" alt="分析"></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">winner2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;   <span class="hljs-keyword">if</span> (n % <span class="hljs-number">5</span> == <span class="hljs-number">0</span> || n % <span class="hljs-number">5</span> == <span class="hljs-number">2</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;后手&quot;</span>;   &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;先手&quot;</span>;   &#125;&#125;</code></pre><h2 id="题目三-1"><a href="#题目三-1" class="headerlink" title="题目三"></a>题目三</h2><p>定义一种数：可以表示成若干（数量&gt;1）连续正数和的数<br>比如:<br>5 = 2+3，5就是这样的数<br>12 = 3+4+5，12就是这样的数<br>1不是这样的数，因为要求数量大于1个、连续正数和<br>2 = 1 + 1，2也不是，因为等号右边不是连续正数<br>给定一个参数N，返回是不是可以表示成若干连续正数和的数</p><p>暴力：从1开始加，加到等于一百返回，大于一百从2开始加</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isMSum1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= num; i++) &#123;      <span class="hljs-keyword">int</span> sum = i;      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt;= num; j++) &#123;         <span class="hljs-keyword">if</span> (sum + j &gt; num) &#123;            <span class="hljs-keyword">break</span>;         &#125;         <span class="hljs-keyword">if</span> (sum + j == num) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;         &#125;         sum += j;      &#125;   &#125;   <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;&#125;</code></pre><p>找规律</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210329190329.png" alt="规律"></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isMSum2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;   <span class="hljs-keyword">if</span> (num &lt; <span class="hljs-number">3</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;   &#125;   <span class="hljs-comment">// 是2的次幂</span>   <span class="hljs-comment">// 规律 二进制上只有一个1</span>   <span class="hljs-keyword">return</span> (num &amp; (num - <span class="hljs-number">1</span>)) != <span class="hljs-number">0</span>;&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210329190740.png" alt="判断2的次幂"></p><h1 id="矩阵处理技巧"><a href="#矩阵处理技巧" class="headerlink" title="矩阵处理技巧"></a>矩阵处理技巧</h1><p>核心技巧：找到coding上的宏观调度，不要局限于局部坐标变换</p><h2 id="zigzag打印矩阵"><a href="#zigzag打印矩阵" class="headerlink" title="zigzag打印矩阵"></a>zigzag打印矩阵</h2><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210329192140.png" alt="打印"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210329192611.png" alt="方法"></p><p>A往右走，B往下走，压到一条斜线</p><p>当A不能往右，就往下，B不能往下，就往右</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210329192748.png" alt="结果"></p><p>分别从左下到右上或者右上到左下，依次调换</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printMatrixZigZag</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix)</span> </span>&#123;   <span class="hljs-keyword">int</span> Ar = <span class="hljs-number">0</span>;<span class="hljs-comment">// A的行号</span>   <span class="hljs-keyword">int</span> Ac = <span class="hljs-number">0</span>;<span class="hljs-comment">// A的列号</span>   <span class="hljs-keyword">int</span> Br = <span class="hljs-number">0</span>;<span class="hljs-comment">// B的行号</span>   <span class="hljs-keyword">int</span> Bc = <span class="hljs-number">0</span>;<span class="hljs-comment">// B的列号</span>   <span class="hljs-keyword">int</span> endR = matrix.length - <span class="hljs-number">1</span>;<span class="hljs-comment">// 终止位置行</span>   <span class="hljs-keyword">int</span> endC = matrix[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span>;<span class="hljs-comment">// 终止位置列</span>   <span class="hljs-keyword">boolean</span> fromUp = <span class="hljs-keyword">false</span>;<span class="hljs-comment">// 是不是从右上往左下打印；一开始是从左下往右上</span>   <span class="hljs-keyword">while</span> (Ar != endR + <span class="hljs-number">1</span>) &#123;<span class="hljs-comment">// A还没来到右下角的位置 + 1</span>      <span class="hljs-comment">// 已知斜线两端，方向，即可打印</span>      printLevel(matrix, Ar, Ac, Br, Bc, fromUp);      Ar = Ac == endC ? Ar + <span class="hljs-number">1</span> : Ar;      Ac = Ac == endC ? Ac : Ac + <span class="hljs-number">1</span>;      Bc = Br == endR ? Bc + <span class="hljs-number">1</span> : Bc;      Br = Br == endR ? Br : Br + <span class="hljs-number">1</span>;      fromUp = !fromUp;   &#125;   System.out.println();&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printLevel</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] m, <span class="hljs-keyword">int</span> tR, <span class="hljs-keyword">int</span> tC, <span class="hljs-keyword">int</span> dR, <span class="hljs-keyword">int</span> dC,</span></span><span class="hljs-function"><span class="hljs-params">      <span class="hljs-keyword">boolean</span> f)</span> </span>&#123;   <span class="hljs-keyword">if</span> (f) &#123;      <span class="hljs-keyword">while</span> (tR != dR + <span class="hljs-number">1</span>) &#123;         System.out.print(m[tR++][tC--] + <span class="hljs-string">&quot; &quot;</span>);      &#125;   &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-keyword">while</span> (dR != tR - <span class="hljs-number">1</span>) &#123;         System.out.print(m[dR--][dC++] + <span class="hljs-string">&quot; &quot;</span>);      &#125;   &#125;&#125;</code></pre><h2 id="转圈打印矩阵"><a href="#转圈打印矩阵" class="headerlink" title="转圈打印矩阵"></a>转圈打印矩阵</h2><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210329195422.png" alt="打印"></p><p>第一层结束的位置等于第二层开始的位置</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210329195739.png"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210329200957.png" alt="规定好"></p><p>b++但不碰到d，a++不要碰到c，d–不要碰到b，c–不要碰到a</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">spiralOrderPrint</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix)</span> </span>&#123;   <span class="hljs-keyword">int</span> tR = <span class="hljs-number">0</span>;   <span class="hljs-keyword">int</span> tC = <span class="hljs-number">0</span>;   <span class="hljs-keyword">int</span> dR = matrix.length - <span class="hljs-number">1</span>;   <span class="hljs-keyword">int</span> dC = matrix[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span>;   <span class="hljs-keyword">while</span> (tR &lt;= dR &amp;&amp; tC &lt;= dC) &#123;      printEdge(matrix, tR++, tC++, dR--, dC--);   &#125;&#125;<span class="hljs-comment">// tR, tC 左上角</span><span class="hljs-comment">// dR, dC 右下角</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printEdge</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] m, <span class="hljs-keyword">int</span> tR, <span class="hljs-keyword">int</span> tC, <span class="hljs-keyword">int</span> dR, <span class="hljs-keyword">int</span> dC)</span> </span>&#123;   <span class="hljs-keyword">if</span> (tR == dR) &#123; <span class="hljs-comment">// 只剩一条横线</span>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = tC; i &lt;= dC; i++) &#123;         <span class="hljs-comment">// 打印横线</span>         System.out.print(m[tR][i] + <span class="hljs-string">&quot; &quot;</span>);      &#125;   &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tC == dC) &#123;      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = tR; i &lt;= dR; i++) &#123;         <span class="hljs-comment">// 打印竖线</span>         System.out.print(m[i][tC] + <span class="hljs-string">&quot; &quot;</span>);      &#125;   &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-keyword">int</span> curC = tC;      <span class="hljs-keyword">int</span> curR = tR;      <span class="hljs-keyword">while</span> (curC != dC) &#123;         System.out.print(m[tR][curC] + <span class="hljs-string">&quot; &quot;</span>);         curC++;      &#125;      <span class="hljs-keyword">while</span> (curR != dR) &#123;         System.out.print(m[curR][dC] + <span class="hljs-string">&quot; &quot;</span>);         curR++;      &#125;      <span class="hljs-keyword">while</span> (curC != tC) &#123;         System.out.print(m[dR][curC] + <span class="hljs-string">&quot; &quot;</span>);         curC--;      &#125;      <span class="hljs-keyword">while</span> (curR != tR) &#123;         System.out.print(m[curR][tC] + <span class="hljs-string">&quot; &quot;</span>);         curR--;      &#125;   &#125;&#125;</code></pre><h2 id="原地旋转正方形矩阵"><a href="#原地旋转正方形矩阵" class="headerlink" title="原地旋转正方形矩阵"></a>原地旋转正方形矩阵</h2><p>一样先转外层的框</p><p>分圈结构！</p><p> <img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210329202839.png" alt="分组"></p><p>4*4有3个小组；</p><p>小组数等于边长 - 1</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210329203434.png" alt="四个坐标"></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix)</span> </span>&#123;   <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>;   <span class="hljs-keyword">int</span> b = <span class="hljs-number">0</span>;   <span class="hljs-keyword">int</span> c = matrix.length - <span class="hljs-number">1</span>;   <span class="hljs-keyword">int</span> d = matrix[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span>;   <span class="hljs-keyword">while</span> (a &lt; c) &#123;      rotateEdge(matrix, a++, b++, c--, d--);   &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rotateEdge</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] m, <span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> c, <span class="hljs-keyword">int</span> d)</span> </span>&#123;   <span class="hljs-keyword">int</span> tmp = <span class="hljs-number">0</span>;   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; d - b; i++) &#123;      <span class="hljs-comment">// i组号</span>      tmp = m[a][b + i];      m[a][b + i] = m[c - i][b];      m[c - i][b] = m[c][d - i];      m[c][d - i] = m[a + i][d];      m[a + i][d] = tmp;   &#125;&#125;</code></pre><h1 id="数组累加和问题三连"><a href="#数组累加和问题三连" class="headerlink" title="数组累加和问题三连"></a>数组累加和问题三连</h1><h2 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h2><p>给定一个正整数组成的无序数组arr，给定一个正整数值K<br>找到arr的所有子数组里，哪个子数组的累加和等于K，并且是长度最大的<br>返回其长度</p><p> <strong>范围和累加和有严格单调性</strong> ，也就是说右扩一定增大，左缩一定减小</p><p>子数组、子串都是连续的；子序列才是散开的</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210330173727.png" alt="方法"></p><p>设置窗口，窗口内为windowsum</p><p>ws&lt;sum, R右移</p><p>ws&gt;sum, L右移</p><p>ws == sum, 判断是否更新, R右移</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMaxLength</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> K)</span> </span>&#123;   <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length == <span class="hljs-number">0</span> || K &lt;= <span class="hljs-number">0</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;   &#125;   <span class="hljs-comment">// [L..R]</span>   <span class="hljs-comment">// [0..0]上的范围</span>   <span class="hljs-comment">// 一开始这样设置窗口内应该设置一个数 arr[0]</span>   <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;   <span class="hljs-keyword">int</span> right = <span class="hljs-number">0</span>;   <span class="hljs-comment">// 这里的sum指的是windowsum k表示sum</span>   <span class="hljs-keyword">int</span> sum = arr[<span class="hljs-number">0</span>];   <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>;   <span class="hljs-keyword">while</span> (right &lt; arr.length) &#123;      <span class="hljs-keyword">if</span> (sum == K) &#123;         len = Math.max(len, right - left + <span class="hljs-number">1</span>);         <span class="hljs-comment">// 这里L或者R动都可以 L减，R加</span>         sum -= arr[left++];      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &lt; K) &#123;         right++;         <span class="hljs-keyword">if</span> (right == arr.length) &#123;            <span class="hljs-keyword">break</span>;         &#125;         sum += arr[right];      &#125; <span class="hljs-keyword">else</span> &#123;         sum -= arr[left++];      &#125;   &#125;   <span class="hljs-keyword">return</span> len;&#125;</code></pre><h2 id="题目二-1"><a href="#题目二-1" class="headerlink" title="题目二"></a>题目二</h2><p>给定一个整数组成的无序数组arr，值可能正、可能负、可能0<br>给定一个整数值K<br>找到arr的所有子数组里，哪个子数组的累加和等于K，并且是长度最大的<br>返回其长度</p><p>假设0 - 17位置累加和为 1000；</p><p>0 - 5位置是第一次出现800的情况；</p><p>所以6 - 17累加和为200，同时又是以17结尾，200最长的，因为800是最早出现的</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210330180620.png" alt="解"></p><p>假设sum为当前位置的累加和，map放累加和 <strong>最早</strong> 出现的位置</p><p>来到5的时候，找map里面有没有5 - 10 = - 5的位置；</p><p>没有，所以以5结尾的没有答案</p><p>把新的累加和加到map里面，5最早的累加和出现在0位置，记录 5 0</p><p>下一个数来到6，加上累加和为11， 找11 - 10 = 1最早出现的位置</p><p>说明以6结尾的没有答案，记录 11 1</p><p>来到4，加上累加和为15， 15 - 10 = 5，map有5</p><p>说明来到2位置的时候，1 - 2为当前最长答案2，15放入map。。。。</p><p> <strong>必须躺着一个 0 -1的键值对</strong> ，不然0 - i正好出现的时候找不到答案</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxLength</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> k)</span> </span>&#123;   <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length == <span class="hljs-number">0</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;   &#125;   HashMap&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;Integer, Integer&gt;();   map.put(<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>); <span class="hljs-comment">// important</span>   <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>;   <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;      sum += arr[i];      <span class="hljs-keyword">if</span> (map.containsKey(sum - k)) &#123;         len = Math.max(i - map.get(sum - k), len);      &#125;      <span class="hljs-keyword">if</span> (!map.containsKey(sum)) &#123;         map.put(sum, i);      &#125;   &#125;   <span class="hljs-keyword">return</span> len;&#125;</code></pre><h3 id="题目二拓展"><a href="#题目二拓展" class="headerlink" title="题目二拓展"></a>题目二拓展</h3><p>一个数组中有正负数，返回里面1和2个数相等的最大子数组</p><p>解法：遇到1 和 2之外的数认为是0，遇到1变成1，遇到2变成-1</p><p>求累加和为0的最长子数组</p><h2 id="题目三-2"><a href="#题目三-2" class="headerlink" title="题目三"></a>题目三</h2><p>给定一个整数组成的无序数组arr，值可能正、可能负、可能0<br>给定一个整数值K<br>找到arr的所有子数组里，哪个子数组的累加和&lt;=K，并且是长度最大的<br>返回其长度</p><p>定义一个概念：</p><p>i开头所有的可能性中，哪一个是取得累加和最小的情况</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210330192125.png"></p><p>生成好这两个数组</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210330193310.png" alt="解"></p><p>就维持一个窗口看看有没有往右看的可能性，如果可能性都没有，一定不是想要的答案</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210330193550.png"></p><p>当扩到1时，sum=1，超过k了</p><p>于是去掉 - 10，加入1 发现sum大于k</p><p>所以此时5开头一定得不到一个更长的答案，舍弃</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxLengthAwesome</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> k)</span> </span>&#123;   <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length == <span class="hljs-number">0</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;   &#125;   <span class="hljs-keyword">int</span>[] minSums = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[arr.length];   <span class="hljs-keyword">int</span>[] minSumEnds = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[arr.length];   minSums[arr.length - <span class="hljs-number">1</span>] = arr[arr.length - <span class="hljs-number">1</span>];   minSumEnds[arr.length - <span class="hljs-number">1</span>] = arr.length - <span class="hljs-number">1</span>;   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = arr.length - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;      <span class="hljs-keyword">if</span> (minSums[i + <span class="hljs-number">1</span>] &lt; <span class="hljs-number">0</span>) &#123;         minSums[i] = arr[i] + minSums[i + <span class="hljs-number">1</span>];         minSumEnds[i] = minSumEnds[i + <span class="hljs-number">1</span>];      &#125; <span class="hljs-keyword">else</span> &#123;         minSums[i] = arr[i];         minSumEnds[i] = i;      &#125;   &#125;   <span class="hljs-comment">// (i...)(...)(...) | (end....</span>   <span class="hljs-comment">// end开始算不进去了</span>   <span class="hljs-comment">// sum是i扩到end的窗口累加和</span>   <span class="hljs-keyword">int</span> end = <span class="hljs-number">0</span>;   <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;   <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;   <span class="hljs-comment">// i是窗口的最左的位置，end扩出来的最右有效块儿的最后一个位置的，再下一个位置</span>   <span class="hljs-comment">// end也是下一块儿的开始位置</span>   <span class="hljs-comment">// 窗口：[i~end)</span>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;      <span class="hljs-comment">// while循环结束之后：</span>      <span class="hljs-comment">// 1) 如果以i开头的情况下，累加和&lt;=k的最长子数组是arr[i..end-1]，看看这个子数组长度能不能更新res；</span>      <span class="hljs-comment">// 2) 如果以i开头的情况下，累加和&lt;=k的最长子数组比arr[i..end-1]短，更新还是不更新res都不会影响最终结果；</span>      <span class="hljs-keyword">while</span> (end &lt; arr.length &amp;&amp; sum + minSums[end] &lt;= k) &#123;         sum += minSums[end];         end = minSumEnds[end] + <span class="hljs-number">1</span>;      &#125;      <span class="hljs-comment">// 不管越界还是累加跳出来的都对</span>      <span class="hljs-comment">// [i....](end...x)</span>      <span class="hljs-comment">// [i.... ] x</span>      res = Math.max(res, end - i);      <span class="hljs-keyword">if</span> (end &gt; i) &#123; <span class="hljs-comment">// 窗口内还有数 [i~end) [4,4)</span>         sum -= arr[i];      &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 窗口内已经没有数了，说明从i开头的所有子数组累加和都不可能&lt;=k</span>         end = i + <span class="hljs-number">1</span>;      &#125;   &#125;   <span class="hljs-keyword">return</span> res;&#125;</code></pre><h1 id="哈希函数有关的结构和岛问题"><a href="#哈希函数有关的结构和岛问题" class="headerlink" title="哈希函数有关的结构和岛问题"></a>哈希函数有关的结构和岛问题</h1><h2 id="认识哈希函数"><a href="#认识哈希函数" class="headerlink" title="认识哈希函数"></a>认识哈希函数</h2><p>out  f(in data)</p><p>in为输入类型，out为输出类型</p><ol><li>输入参数data，假设是in类型，特征：可能性无穷大，比如str类型的参数</li><li>输出参数类型out，特征：可能性可以很大，但一定是有穷尽的</li><li>哈希函数没有任何随机的机制，固定的输入一定是固定的输出</li><li>输入无穷多但输出值有限，所以不同输入也可能输出相同（哈希碰撞）</li><li>再相似的不同输入，得到的输出值，会 <strong>几乎均匀的分布在out域</strong> 上<br>重点：第5条！</li></ol><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210330202849.png"></p><p>假设有一个框能框住s区域，s区域不同的框框中的都差不多；</p><p>散列函数</p><p>输入很像并不能决定输出很像，输出一定会是离散；</p><h2 id="哈希函数作用"><a href="#哈希函数作用" class="headerlink" title="哈希函数作用"></a>哈希函数作用</h2><p>可以把数据根据不同值，几乎均匀的分开</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210330203525.png"></p><p>可以用得到的out模上m，得到的也会是均匀输出</p><p>假设有一个四十亿个整数的文件，每一个整数四个字节，文件一行一个整数</p><p>假设只有1G的内存，统计哪一个数出现的次数最多</p><p>key出现数，value次数，都是无符号整数</p><p>如果1g内存都作哈希表，能放多少个数</p><p>一条记录8字节，key4字节，value4字节，还有内部索引空间…..(假设不算)；</p><p>假设都不一样，最差情况 8 * 40 亿个字节，32G，是会爆内存的</p><p>1G内存最多能装多少记录？</p><p>40亿除以32，假设再保守一点，40亿除以40也就是一亿条的时候不会爆；</p><p>读到一个数，用哈希函数的到返回值，让其 <strong>模上40</strong> </p><p>得到0 - 39范围上的数；</p><p>把原数据分别发送到对应的0，1，2….39号小文件里面</p><p>这时候就可以认为</p><p>0…39文件中所含有不同数字的总数， <strong>几乎均等</strong> </p><p>第一次统计0号文件记录，第二次统计…</p><p>直到得到40个top1，取最大的top</p><h2 id="哈希表的实现"><a href="#哈希表的实现" class="headerlink" title="哈希表的实现"></a>哈希表的实现</h2><p>增删查改 O(1)</p><blockquote><p>最传统的HashMap</p></blockquote><p>假设有17个格子的空间，一开始放入一个键值对为 abc 1</p><p>会把abc用哈希函数再与17去模后放入</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210331003811.png" alt="传统"></p><p>左边类似于单链表串下去</p><p>假设有一个新串的哈希值碰撞了，abc底下再串一个，而不是覆盖</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210331004125.png" alt="哈希碰撞"></p><p>查询的时候，用哈希函数找到对应格子用单链表遍历到abc</p><p>增删改查都类似；</p><p>因为是类似均匀分配，如果有一条链超过x，其他差不多也超过x；</p><p>后面会进行 <strong>扩容</strong> ：</p><p> <strong>暴力扩容</strong> ：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210331004551.png" alt="扩容"></p><p>就是暴力用原数据模新模来放进去，放完之后如果是上图数据大小的话，之后样本长度差不多为之前一半</p><p>log2为底的N基上为扩容的次数</p><p>暴力扩容总代价为(1 + 2 + 4 + 8….+ N/2)；所以扩容总代价O(N)</p><p>如果算上平均 均摊 就是应该为O(1)，后续有 <strong>改进</strong> </p><p>比如JVM可以 <strong>离线扩容</strong> ，不占用用户在线时间</p><p>或者桶 <strong>不按照单链表</strong> 串，而使用 <strong>有序表</strong>  ，不用链表长度为6再扩容，有序表查为logk，可以放很多</p><p>所以 <strong>哈希表再使用时，增删查改时间复杂度都为O(1)</strong> </p><h2 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h2><p>1）利用哈希函数的性质</p><p>2）每一条数据提取特征</p><p>3）加入描黑库</p><p>类似于没有删除的 <strong>黑名单系统</strong> </p><p>100亿的url构成的 <strong>黑名单</strong> （爬虫问题）</p><p>每一个爬虫爬到url，就塞入表；</p><p>假设100亿url64字节的，6400亿字节差不多640G <strong>内存</strong> ；</p><p>首先有一个类似于 <strong>位图</strong> 的东西，bit数组，每一个位置占用一个bit表示01</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210331012220.png" alt="code"></p><p>最终得到就是：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210331012257.png" alt="右移"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210331012459.png" alt="右移"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210331012701.png" alt="设置"></p><p>假设申请的是整形数组，最大数字为21亿多一些，能表示21亿多一些 * 32位的位图</p><p>long能表示21亿多一些 * 64位的位图，因为数组长度Integer.MAX_VALUE</p><p>如果还不够，就可以用矩阵表示</p><p>找行找列</p><p>m长度的位图，m/8个字节数可以使用；</p><p> <strong>布隆过滤器</strong> 先设置一个m长度的位图，利用哈希函数算出哈希值，模上m决定一个位置描黑</p><p>url用另外一个独立的哈希函数算出out2，模上m得到新的位置再描黑；</p><p>若一共有k个哈希函数，能描黑k的位置，有可能k的位置中有重复的；</p><p>这个时候就说url <strong>加入过黑名单</strong> </p><p>查询算k个哈希值模m算k的位置，只有k的位置都黑才算在黑名单中</p><p> <strong>一定存在失误率</strong> ，只给1000个bit位图，100亿url搞完几乎全黑，全黑后报谁都是黑名单；</p><p> <strong>布隆过滤器</strong> 失误类型 <strong>不可能为是黑名单的url误报为非黑名单</strong> ，一定是非黑名单误报为黑名单。</p><h3 id="布隆过滤器重要的三个公式"><a href="#布隆过滤器重要的三个公式" class="headerlink" title="布隆过滤器重要的三个公式"></a>布隆过滤器重要的三个公式</h3><p>1，假设数据量为n，预期的失误率为p（布隆过滤器大小和每个样本的大小无关）<br>2，根据n和p，算出Bloom Filter一共需要多少个bit位，向上取整，记为m<br>3，根据m和n，算出Bloom Filter需要多少个哈希函数，向上取整，记为k<br>4，根据修正公式，算出真实的失误率p_true</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210331014315.png" alt="公式"></p><p>如果设计一个黑名单系统，提前规定 <strong>失误率</strong> </p><p>m空间有理论和实际，用理论算k，k12.7时，k实际为13</p><p>此时就会存在真实失误率，都带入实际值，得到真实失误率， <strong>一般都更低</strong> 。</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210331015050.png" alt="关系"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210331015107.png" alt="关系"></p><p>k个哈希函数怎么得到呢？</p><p>找两个哈希函数就行，f和g；</p><p>f函数的返回值 加上 1 * g的返回值 第一个哈希函数</p><p>f函数的返回值 加上 2 * g的返回值….第二个哈希函数</p><h2 id="一致性哈希"><a href="#一致性哈希" class="headerlink" title="一致性哈希"></a>一致性哈希</h2><p>分布式 <strong>存储结构</strong> 最常见的结构</p><p>1）哈希域变成环的设计</p><p>2）虚拟节点技术</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210331185719.png" alt="传统"></p><p>经典结构为：算hashcode存放到不同的数据端实现分布式；</p><p>如果对key作大量的索引，比如查询 ，要从不同服务器作merge(MapReduce)</p><p>要实现 <strong>负载均衡</strong> 高中低频key也应该均匀分布，都要有一些；</p><p>能作hash的key应该足够多；</p><blockquote><p>传统负载均衡底层数据服务器问题</p></blockquote><p>增加机器和减少机器会特别麻烦；</p><p>要重新做hash，全量迁移</p><h3 id="hash成环"><a href="#hash成环" class="headerlink" title="hash成环"></a>hash成环</h3><blockquote><p>一致性哈希解决问题</p></blockquote><p>既可以做到负载均衡，也可以解决迁移问题</p><p>把哈希函数的返回值想象成一个环；</p><p>假设有三台机器，一定有ip、hostname、mac地址不同，取出能区分的东西；</p><p>一致性哈希里面没有模这个问题，都是hash值；</p><p>假设用hostname作哈希，得到m1，m2，m3；不一定很均分</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210331191429.png"></p><p>假设要存储abc，计算出hash，顺时针找到的第一台机器，就是它的归属</p><p>假设三台机器code足够均匀，就可以负载均衡；</p><p>假设m1要下线，把m1的数据给m2，数据迁移就完成</p><p>假设要加mk，找到属于的一段，迁移就行</p><blockquote><p>怎么找？</p></blockquote><p>m1,m2,m3算出来有hashcode</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210331192104.png" alt="下发"></p><p>找刚刚大于等于abc的hashcode的机器即可（可以用二分）</p><blockquote><p>还存在问题</p></blockquote><ol><li><p>刚开始机器少，散列后可能不均匀</p></li><li><p>减机器的时候也可能造成负载不均匀</p></li></ol><h3 id="虚拟节点技术"><a href="#虚拟节点技术" class="headerlink" title="虚拟节点技术"></a>虚拟节点技术</h3><p>例如给m1,m2,m3分别分配1000个字符串，是能够找到字符串归属于哪一台机器的，</p><p>用每台数据储存服务器的字符串去抢环</p><p>虚拟节点抢到的数据归属于本身机器</p><p>增加机器的时候，一样分配一千个字符串去抢环，然后归属</p><p> <strong>字符串数量没到万亿级别，几乎不会出现碰撞</strong> </p><p>也能实现 <strong>负载管理</strong> ，如果一个机器性能更强，相对给予更多的字符串，抢更多的点</p><h1 id="并行算法"><a href="#并行算法" class="headerlink" title="并行算法"></a>并行算法</h1><h2 id="岛问题"><a href="#岛问题" class="headerlink" title="岛问题"></a>岛问题</h2><blockquote><p> 岛问题只是一种启发性的说明</p></blockquote><p>一个只有0和1两种数字的二维矩阵中，<br>上下左右能练成一片的1，算一个岛<br>返回矩阵中，一共有几个岛(上下左右相连)</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">countIslands1</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] m)</span> </span>&#123;   <span class="hljs-keyword">if</span> (m == <span class="hljs-keyword">null</span> || m[<span class="hljs-number">0</span>] == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;   &#125;   <span class="hljs-keyword">int</span> N = m.length;   <span class="hljs-keyword">int</span> M = m[<span class="hljs-number">0</span>].length;   <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; M; j++) &#123;         <span class="hljs-keyword">if</span> (m[i][j] == <span class="hljs-number">1</span>) &#123;            res++;            infect(m, i, j, N, M);         &#125;      &#125;   &#125;   <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-comment">// 感染函数 来到i，j 把上下左右所到之路感染为2</span><span class="hljs-comment">// N行 M列</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">infect</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] m, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j, <span class="hljs-keyword">int</span> N, <span class="hljs-keyword">int</span> M)</span> </span>&#123;   <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || i &gt;= N || j &lt; <span class="hljs-number">0</span> || j &gt;= M || m[i][j] != <span class="hljs-number">1</span>) &#123;      <span class="hljs-keyword">return</span>;   &#125;   <span class="hljs-comment">// i j不越界也是1</span>   m[i][j] = <span class="hljs-number">2</span>;   infect(m, i + <span class="hljs-number">1</span>, j, N, M);   infect(m, i - <span class="hljs-number">1</span>, j, N, M);   infect(m, i, j + <span class="hljs-number">1</span>, N, M);   infect(m, i, j - <span class="hljs-number">1</span>, N, M);&#125;</code></pre><blockquote><p>问题</p></blockquote><p>O(N * M)</p><p>矩阵如果很大，单cpu运行很乏力；</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210331202150.png" alt="分两个cpu"></p><p>分两个cpu处理，建立分割记录</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210331202700.png"></p><p>只关心左右两边都是1的情况</p><p>遇到则判断是否一个集合，是的话下一个，不是的话union</p><p>可以分为很多个部分，分配cpu</p><h1 id="资源限制技巧汇总"><a href="#资源限制技巧汇总" class="headerlink" title="资源限制技巧汇总"></a>资源限制技巧汇总</h1><p>1）布隆过滤器用于集合的建立与查询，并可以节省大量空间（已讲）<br>2）一致性哈希解决数据服务器的负载管理问题（已讲）<br>3）利用并查集结构做岛问题的并行计算（已讲）<br>4）哈希函数可以把数据按照种类均匀分流<br>5）位图解决某一范围上数字的出现情况，并可以节省大量空间<br>6）利用分段统计思想、并进一步节省大量空间<br>7）利用堆、外排序来做多个处理单元的结果合并</p><h2 id="题目一-1"><a href="#题目一-1" class="headerlink" title="题目一"></a>题目一</h2><p>32位无符号整数的范围是0~4,294,967,295，<br>现在有一个正好包含40亿个无符号整数的文件，<br>可以使用最多1GB的内存，怎么找到出现次数最多的数？</p><p> <strong>上面哈希章节</strong> </p><h2 id="题目二-2"><a href="#题目二-2" class="headerlink" title="题目二"></a>题目二</h2><p>32位无符号整数的范围是0~4,294,967,295，<br>现在有一个正好包含40亿个无符号整数的文件，<br>所以在整个范围中必然存在没出现过的数。<br>可以使用最多1GB的内存，怎么找到所有未出现过的数？</p><p>用哈希表 42亿 * 4字节 差不多16G</p><p>用 <strong>位图</strong> ，0 - 2^ 32 -1 用2^ 32个bit表示一个数出现过没有</p><p>哈希表是4个字节表示是否出现，位图一个bit表示一个数是否出现，16G/32差不多500多M</p><p>【进阶】<br>内存限制为 10MB，但是只用找到一个没出现过的数即可</p><p>内存限制为 3kb，但是只用找到一个没出现过的数即可</p><p> <strong>3kb转化为int数组</strong> ，比如找到3k / 4 = 3 * 256 ，找离这个数最近的2的次方，即为 2^ 9；</p><p>所以吧数组定成512长度的话，一定不会爆空间；</p><p>int[512]:  0~2^32 - 1数字，2^32能均分512，均分一份是2^32 / 512 = 8388608</p><p>第0份统计8388608出现了多少个数；</p><p>遍历所有数组，中了范围在counts[i]++</p><p>必在某一个范围内词频统计不够8388608，则在这个范围上必缺数字，</p><p>找到L…R，继续重复拿3kb分，直到3kb能单独做到统计数组；</p><p>内存限制为 3个变量，但是只用找到一个没出现过的数即可</p><p> <strong>二分</strong> </p><p>遍历左侧，判断哪边数字小于一半，继续二分小于一半的区域….</p><h2 id="题目三-3"><a href="#题目三-3" class="headerlink" title="题目三"></a>题目三</h2><p>有一个包含100亿个URL的大文件，假设每个URL占用64B，<br>请找出其中所有重复的URL<br>【补充】<br>某搜索公司一天的用户搜索词汇是海量的(百亿数据量)，<br>请设计一种求出每天热门Top100词汇的可行办法</p><p>补充和重复是一样的问题</p><p>用 <strong>哈希</strong> 发配到不同机器上，如果一个机器种类过多，继续哈希；</p><p> <strong>不怕重复的多，怕种类多</strong> </p><p>top100就是哈希分机器，哈希分文件，统计文件top100</p><p>总体都是mapper和reducer</p><p> <strong>外排</strong> ，各个文件top1 pk弹出，再pk新顶部和其他的….</p><p>也可以用 <strong>二维堆</strong> 找出来</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210401172823.png" alt="二维堆"></p><p>每个大根堆的结点还是一个大根堆</p><h2 id="题目四"><a href="#题目四" class="headerlink" title="题目四"></a>题目四</h2><p>32位无符号整数的范围是0~4294967295，<br>现在有40亿个无符号整数，<br>可以使用最多1GB的内存，<br>找出所有出现了两次的数。</p><p>用两个bit表示一个数字出现的频率；00表示初始状态，出现多一次变成01，再多10…出现更多次都是11</p><p>16G/32 * 2 = 1G左右</p><h2 id="题目五"><a href="#题目五" class="headerlink" title="题目五"></a>题目五</h2><p>32位无符号整数的范围是0~4294967295，现在有40亿个无符号整数<br>可以使用最多10MB的内存，怎么找到这40亿个整数的中位数？</p><p>用题目二的方式用3kb开整型数组，int[512]，每一份8388608，求第二十亿小的数；</p><p>遍历统计，定位到第二十亿位数的空间</p><h2 id="题目六"><a href="#题目六" class="headerlink" title="题目六"></a>题目六</h2><p>32位无符号整数的范围是0~4294967295，<br>有一个10G大小的文件，每一行都装着这种类型的数字，<br>整个文件是无序的，给你5G的内存空间，<br>请你输出一个10G大小的文件，就是原文件所有数字排序的结果</p><p> <strong>小根堆</strong> 记录目前为止最大的两个数，并记录出现次数，哈希表记录在小根堆出现的位置；</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210401181749.png" alt="例子"></p><p>能统计全局最大前两个及次数，下一次重复行为，大于等于第二大的数不再统计；</p><blockquote><p>10G文件，5G内存</p></blockquote><p>估算map和小根堆能堆放的记录，去怼文件排序就行</p><h1 id="有序表的原理、应用、扩展"><a href="#有序表的原理、应用、扩展" class="headerlink" title="有序表的原理、应用、扩展"></a>有序表的原理、应用、扩展</h1><p class="note note-primary">代码传github</p><h2 id="搜索二叉树"><a href="#搜索二叉树" class="headerlink" title="搜索二叉树"></a>搜索二叉树</h2><p>搜索二叉树一定要说明以什么标准来排序</p><p>经典的搜索二叉树，树上 <strong>没有重复</strong> 的用来排序的key值</p><p>(没有重复因为 <strong>平衡性调整问题</strong> ，无法控制一律放在哪边的问题)</p><p>如果有重复节点的需求，可以在一个节点 <strong>内部增加数据项</strong> </p><h3 id="搜索二叉树查询key"><a href="#搜索二叉树查询key" class="headerlink" title="搜索二叉树查询key"></a>搜索二叉树查询key</h3><p>1）如果当前节点的value==key，返回true<br>2）如果当前节点的value&lt;key，当前节点向左移动<br>3）如果当前节点的value&gt;key，当前节点向右移动<br>4）如果当前节点变成null，返回false</p><h3 id="搜索二叉树插入新的key"><a href="#搜索二叉树插入新的key" class="headerlink" title="搜索二叉树插入新的key"></a>搜索二叉树插入新的key</h3><p>和查询过程一样，但当前节点滑到空的时候，就插入在这里</p><h3 id="搜索二叉树删除key"><a href="#搜索二叉树删除key" class="headerlink" title="搜索二叉树删除key"></a>搜索二叉树删除key</h3><p>0）先找到key所在的节点<br>1）如果该节点没有左孩子、没有右孩子，直接删除即可<br>2）如果该节点有左孩子、没有右孩子，直接用左孩子顶替该节点<br>3）如果该节点没有左孩子、有右孩子，直接用右孩子顶替该节点<br>4）如果该节点有左孩子、有右孩子，用该节点 <strong>后继节点</strong> 顶替该节点</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210401193315.png" alt="右树最左"></p><p>6有右孩子扔给8即可</p><p>删除要判断后继结点的父节点是否为待删除节点；</p><h3 id="裸搜索二叉树问题"><a href="#裸搜索二叉树问题" class="headerlink" title="裸搜索二叉树问题"></a>裸搜索二叉树问题</h3><p> <strong>输入状况决定性能</strong> </p><p>输入状况很好，左右均分，logN</p><p>输入状况不好，全左全右，N</p><p>1）基础的搜索二叉树，添加、删除时候 <strong>不照顾平衡性</strong> </p><p>2）数据状况很差时，性能就很差</p><p>给搜索二叉树引入两个动作：<strong>左旋、右旋</strong> ，log(N)</p><p>对 X 进行右旋， X倒向右方</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210401200133.png" alt="对a右旋"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210401200409.png" alt="左旋"></p><p>有序表特殊功能</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210401201836.png"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210401201936.png"></p><p>TreeMap底层平衡搜索二叉树</p><p>hashMap增删改查O(1)</p><p>TreeMap O(logN)</p><h2 id="AVL树、SB树、红黑树的共性"><a href="#AVL树、SB树、红黑树的共性" class="headerlink" title="AVL树、SB树、红黑树的共性"></a>AVL树、SB树、红黑树的共性</h2><p>1）都是搜索二叉树</p><p>2）插入、删除、查询（一切查询）搜索二叉树怎么做，这些结构都这么做</p><p>3）使用调整的基本动作都只有左旋、右旋</p><p>4）插入、删除时，从最底层被影响到的节点开始，对往上路径的节点做平衡性检查</p><p>5）因为只对一条向上路径的每个节点做O(1)的检查和调整，所以可以做到O(logN)</p><p>性能指标完全一样，有差别的是常数时间、跳表、实现</p><h2 id="AVL树、SB树、红黑树的不同"><a href="#AVL树、SB树、红黑树的不同" class="headerlink" title="AVL树、SB树、红黑树的不同"></a>AVL树、SB树、红黑树的不同</h2><p>1）平衡性的约束不同</p><p>AVL树最严格（ <strong>左树高 - 右树高 的绝对值 &lt; 2</strong> ）、</p><p>SB树稍宽松（任何一个 <strong>叔结点</strong> 所拥有的结点数不少于它的任何一个 <strong>侄子结点</strong> ）、</p><p>这样左树跟右树数量关系 维持到 <strong>至多多一倍 + 1</strong> </p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210401202616.png"></p><p>红黑树最宽松</p><blockquote><p>红黑树特性</p></blockquote><ol><li>每一个结点红 或者 黑</li><li>头结点黑 叶节点黑</li><li>红结点的子结点为黑（两红不相邻）</li><li>从任何一个结点到每一个子的所有路径上黑结点一样多</li></ol><p>最长的链一定是黑红交替，最短的一定是全黑，所以也不会超过一半</p><p>2）插入、删除和搜索二叉树一样，但是额外，做各自的平衡性调整。各自的平衡性调整所使用的动作都是 <strong>左旋或者右旋</strong> </p><p>三种树都是从 <strong>受影响的结点</strong> 开始检查，只不过到具体一个结点的 <strong>检查的动作不一样</strong> 。</p><h2 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h2><p>1）最严格的平衡性，任何节点左树高度和右树高度差不超过1</p><p>2） <strong>受影响的结点</strong> 开始（删除、插入），往上沿途检查每个节点时，都去检查四种违规情况：LL、RR、LR、RL</p><p>​        如果删除时，用了后继结点替代，则从 <strong>后继结点原位置</strong> 开始网上检查。</p><p>3）不同情况虽然看起来复杂，但是核心点是：<br>LL（做一次右旋）、RR（做一次左旋）<br>LR和RL（利用旋转让底层那个上到顶部）</p><p>| 左树高度 - 右树高度 | &lt; 2 不违规；</p><p>| 左树高度 - 右树高度 | &gt; 1；</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210401225201.png" alt="LL型"></p><p>LL型，左树的左树导致不平</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210401225412.png" alt="LR型"></p><p>LR型，左树的右树不平….</p><p>RR..RL</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210401225814.png">假设左边为7右边为6，只可能左树的左子树为6或者右子树为6，不可能都为6，都为6之前就已经违规了</p><blockquote><p>如何旋转</p></blockquote><ul><li>LL型x右旋即可,RR型x左旋即可，一次动作</li></ul><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210401230223.png" alt="右旋"></p><ul><li><p>LR型</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210401230440.png"></p><p>让底下的 <strong>孙结点</strong> 上到顶部</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210401230704.png" alt="先让左边c代替a"></p><p>再让x右旋</p><p>所插的点一路插到最顶</p><p>转两次，每个节点都是O(1)的代价，一路往上每个节点都查找，O(log(N))的复杂度</p></li></ul><h2 id="SB树（size-balance-tree）"><a href="#SB树（size-balance-tree）" class="headerlink" title="SB树（size-balance-tree）"></a>SB树（size-balance-tree）</h2><p>AVL维护 <strong>高度</strong> ，sb树维护 <strong>节点数</strong> ，不算重复的key，只算种类</p><p>1）让每一个叔叔节点为头的数，节点个数都不少于其任何一个侄子节点<br>2）也是从底层被影响节点开始向上做路径每个节点检查<br>3）与AVL树非常像，也是四种违规类型：LL、RR、LR、RL<br>4）与AVL树非常像，核心点是：<br>LL（做一次右旋）、RR（做一次左旋）<br>LR和RL（利用旋转让底层那个上到顶部）<br>5）与AVL树不同的是，每轮经过调整后，谁的孩子发生变化了，谁就再查</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210402000039.png" alt="sb RL型"></p><p>查到x时，发现左孩子没有右孩子的左孩子多，RL；</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210402000133.png" alt="RR"></p><p>没有右孩子的右孩子多，RR；</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210402000251.png"></p><blockquote><p>平衡调整</p></blockquote><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210402001131.png" alt="LL"></p><p>进行一波右旋后，要找到子孩子改变的结点（x和b）进行递归调用m（x）调整平衡性</p><p>m(x)函数的意义是在x上进行检查孩子和孩子的孩子违规情况</p><p>是一个递归套递归的过程</p><p>因为 <strong>换了孩子后，孩子pk的对象改变了</strong> ，要重复执行m(x)和m(b)防止孩子出现问题；</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210402002011.png" alt="RR"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210402192028.png" alt="LR"></p><h3 id="SB树在使用时候的改进"><a href="#SB树在使用时候的改进" class="headerlink" title="SB树在使用时候的改进"></a>SB树在使用时候的改进</h3><p>1）删除时候 <strong>可以不用检查</strong> </p><p>2）就把平衡性的调整放在 <strong>插入</strong> 的时候</p><p>3）因为这种只要变就递归的特性，别的树没有</p><p>4）可以在节点上封装别的数据项，来增加功能</p><h2 id="跳表（skiplist）"><a href="#跳表（skiplist）" class="headerlink" title="跳表（skiplist）"></a>跳表（skiplist）</h2><p>实现机制和二叉树没关系</p><p>1）结构上根本和 <strong>搜索二叉树无关</strong> </p><p>2）利用随机概率分布来使得高层索引可以无视数据规律，做到整体性能优良</p><p>3） <strong>思想</strong> 是所有有序表中最 <strong>先进</strong> 的</p><p>4）结构简单就是 <strong>多级单链表</strong> </p><p>最初的node，最顶部天然存在，全局最小值为null</p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210403192343.png" alt="node" style="zoom:25%;" /><p>假设要加（3，abc），会生成一个node，并且本身有一条指针，然后掷骰子决定</p><p>掷出0，加一条指针，直到掷1；</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210403192548.png" alt="掷骰子"></p><p>自己结点不会再拓展了，只会拓展初始的</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210403192833.png" alt="拓展"></p><p>然后依次从第一层（最高层）找到小于等于3的key，没有，则指向(3, abc)</p><p>从第二层找…第三层…</p><p>直到</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210403193053.png"></p><p>有高层一定有底层，不会断层</p><p>假设再加一个5，假设5只有2层，左侧三层，不需要扩；</p><p>从最高层开始找，遍历最高层单链表，找到小于等于5最晚的结点3，但是5没有三层，3此时不指向5</p><p>直接往下跳，3第二层指针指向5；</p><p>往下走，3第三层指向5；</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210403193403.png"></p><p>假设一个结点2，只有一层，</p><p>最高层开始，小于等于2最晚的key在大结点上，无法跳到3，</p><p>2没有三层结点，往下跳，往下跳，在最后一层</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210403193510.png"></p><blockquote><p>查询过程</p></blockquote><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210403193900.png" alt="查询"></p><p>找都是从最高层开始找；</p><blockquote><p>好在哪？</p></blockquote><p>假设加入了N个记录，第一层一定是N个，拥有第二个期望是 N/2，第三层 N/4……</p><p>从最高层开始找…..</p><p> <strong>由高层到底层建立了索引关系</strong> </p><p>可以收敛到 logN</p><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><ol><li>每一个结点非红即黑</li><li>头结点黑 叶节点黑</li><li>红结点的子结点为黑（两红不相邻）</li><li>从任何一个结点到每一个叶节点的所有路径上黑结点一样多</li><li>最长链黑红黑红黑红黑…最短链黑黑黑黑</li></ol><p>1）平衡性规定非常诡异<br>2）平衡性调整最为复杂（插入5种，删除8种）<br>3）优点在于每次插入删除扰动较好，但是在今天看来这个优势也极其微弱了<br>原因：贪图插入频繁 扰动小的话，底层硬盘组织的 B+树、2-3-4树可能更好，还是那句话，到底图什么<br>4）除此之外，红黑树并不比AVL树、SB树、跳表更加优秀</p><p>红黑树在纯插入和纯查询这两者之间达到了一种平衡</p><p>redis为什么用跳表？</p><p>可能有序列化要求，skiplist好序列化</p><h2 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h2><h3 id="数组区间问题"><a href="#数组区间问题" class="headerlink" title="数组区间问题"></a>数组区间问题</h3><p>二维数组，每一行都有序，想找到一个左闭右闭的区间。</p><p>使每一个数组总有一个数字命中在区间里面；</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210404202146.png"></p><blockquote><p>流程</p></blockquote><p>第一回把数组中第0个数放到有序表里面</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210404202449.png"></p><p>找到了有序表中的一个区间，最小值和最大构成 [1, 5]</p><p>有序表中弹出最小的，来自于谁，把谁的下一个数字扔进来，拍完后[3, 5]</p><p>比原来更窄，记上新答案；</p><p>再弹出，把来源下一个数字9加入，[4, 9]</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210404202708.png"></p><h3 id="改写有序表（子数组累加和区间问题）"><a href="#改写有序表（子数组累加和区间问题）" class="headerlink" title="改写有序表（子数组累加和区间问题）"></a>改写有序表（子数组累加和区间问题）</h3><p>给定一个数组arr，和两个整数a和b（a&lt;=b）<br>求arr中有多少个子数组，累加和在[a,b]这个范围上<br>返回达标的子数组数量</p><p>假设 0 - i整体累加和是100，如果 0 -j的累加和是 80， j + 1 - i的累加和是20</p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210404233611.png" style="zoom:50%;" /><p>如果子数组必须以i位置数结尾的情况下，多少子数组最后累加和可以 10 - 30？</p><p>等于求 0 - i - 1 多少前缀和范围在 70 - 90 范围上</p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210404233846.png" style="zoom:50%;" /><p>问题就转化为了求前缀和</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210404234149.png"></p><p>就变成找到一种结构，存储前缀和</p><p>这种结构可以add() 允许重复值，给一个上界和下界求范围上多少个</p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210404234741.png" style="zoom:50%;" /><p>求[L, R]可以先求小于R + 1；再求小于 L，减一下即可；</p><blockquote><p>怎么让有序表允许增加重复</p></blockquote><p>增加一个字段 all，计算到达次数。</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210404235507.png"></p><p>往左滑 ans不获得任何数据</p><p>往右滑 ans获得头结点减去右的信息</p><p>找到6 不用滑了 如果6有左树加上左树的量</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SBTNode</span> </span>&#123;   <span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> key;   <span class="hljs-keyword">public</span> SBTNode l;   <span class="hljs-keyword">public</span> SBTNode r;   <span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> size; <span class="hljs-comment">// 不同key的size</span>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> all; <span class="hljs-comment">// 总的size</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SBTNode</span><span class="hljs-params">(<span class="hljs-keyword">long</span> k)</span> </span>&#123;      key = k;      size = <span class="hljs-number">1</span>;      all = <span class="hljs-number">1</span>;   &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SizeBalancedTreeSet</span> </span>&#123;   <span class="hljs-keyword">private</span> SBTNode root;   <span class="hljs-keyword">private</span> HashSet&lt;Long&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();   <span class="hljs-function"><span class="hljs-keyword">private</span> SBTNode <span class="hljs-title">rightRotate</span><span class="hljs-params">(SBTNode cur)</span> </span>&#123;      <span class="hljs-keyword">long</span> same = cur.all - (cur.l != <span class="hljs-keyword">null</span> ? cur.l.all : <span class="hljs-number">0</span>) - (cur.r != <span class="hljs-keyword">null</span> ? cur.r.all : <span class="hljs-number">0</span>);      SBTNode leftNode = cur.l;      cur.l = leftNode.r;      leftNode.r = cur;      leftNode.size = cur.size;      cur.size = (cur.l != <span class="hljs-keyword">null</span> ? cur.l.size : <span class="hljs-number">0</span>) + (cur.r != <span class="hljs-keyword">null</span> ? cur.r.size : <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>;      <span class="hljs-comment">// all modify</span>      leftNode.all = cur.all;      cur.all = (cur.l != <span class="hljs-keyword">null</span> ? cur.l.all : <span class="hljs-number">0</span>) + (cur.r != <span class="hljs-keyword">null</span> ? cur.r.all : <span class="hljs-number">0</span>) + same;      <span class="hljs-keyword">return</span> leftNode;   &#125;   <span class="hljs-function"><span class="hljs-keyword">private</span> SBTNode <span class="hljs-title">leftRotate</span><span class="hljs-params">(SBTNode cur)</span> </span>&#123;      <span class="hljs-keyword">long</span> same = cur.all - (cur.l != <span class="hljs-keyword">null</span> ? cur.l.all : <span class="hljs-number">0</span>) - (cur.r != <span class="hljs-keyword">null</span> ? cur.r.all : <span class="hljs-number">0</span>);      SBTNode rightNode = cur.r;      cur.r = rightNode.l;      rightNode.l = cur;      rightNode.size = cur.size;      cur.size = (cur.l != <span class="hljs-keyword">null</span> ? cur.l.size : <span class="hljs-number">0</span>) + (cur.r != <span class="hljs-keyword">null</span> ? cur.r.size : <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>;      <span class="hljs-comment">// all modify</span>      rightNode.all = cur.all;      cur.all = (cur.l != <span class="hljs-keyword">null</span> ? cur.l.all : <span class="hljs-number">0</span>) + (cur.r != <span class="hljs-keyword">null</span> ? cur.r.all : <span class="hljs-number">0</span>) + same;      <span class="hljs-keyword">return</span> rightNode;   &#125;   <span class="hljs-function"><span class="hljs-keyword">private</span> SBTNode <span class="hljs-title">matain</span><span class="hljs-params">(SBTNode cur)</span> </span>&#123;      <span class="hljs-keyword">if</span> (cur == <span class="hljs-keyword">null</span>) &#123;         <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;      &#125;      <span class="hljs-keyword">if</span> (cur.l != <span class="hljs-keyword">null</span> &amp;&amp; cur.l.l != <span class="hljs-keyword">null</span> &amp;&amp; cur.r != <span class="hljs-keyword">null</span> &amp;&amp; cur.l.l.size &gt; cur.r.size) &#123;         cur = rightRotate(cur);         cur.r = matain(cur.r);         cur = matain(cur);      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cur.l != <span class="hljs-keyword">null</span> &amp;&amp; cur.l.r != <span class="hljs-keyword">null</span> &amp;&amp; cur.r != <span class="hljs-keyword">null</span> &amp;&amp; cur.l.r.size &gt; cur.r.size) &#123;         cur.l = leftRotate(cur.l);         cur = rightRotate(cur);         cur.l = matain(cur.l);         cur.r = matain(cur.r);         cur = matain(cur);      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cur.r != <span class="hljs-keyword">null</span> &amp;&amp; cur.r.r != <span class="hljs-keyword">null</span> &amp;&amp; cur.l != <span class="hljs-keyword">null</span> &amp;&amp; cur.r.r.size &gt; cur.l.size) &#123;         cur = leftRotate(cur);         cur.l = matain(cur.l);         cur = matain(cur);      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cur.r != <span class="hljs-keyword">null</span> &amp;&amp; cur.r.l != <span class="hljs-keyword">null</span> &amp;&amp; cur.l != <span class="hljs-keyword">null</span> &amp;&amp; cur.r.l.size &gt; cur.l.size) &#123;         cur.r = rightRotate(cur.r);         cur = leftRotate(cur);         cur.l = matain(cur.l);         cur.r = matain(cur.r);         cur = matain(cur);      &#125;      <span class="hljs-keyword">return</span> cur;   &#125;   <span class="hljs-function"><span class="hljs-keyword">private</span> SBTNode <span class="hljs-title">add</span><span class="hljs-params">(SBTNode cur, <span class="hljs-keyword">long</span> key, <span class="hljs-keyword">boolean</span> contains)</span> </span>&#123;      <span class="hljs-keyword">if</span> (cur == <span class="hljs-keyword">null</span>) &#123;         <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SBTNode(key);      &#125; <span class="hljs-keyword">else</span> &#123;         cur.all++;         <span class="hljs-keyword">if</span> (key == cur.key) &#123;            <span class="hljs-keyword">return</span> cur;         &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 还在左滑或者右滑</span>            <span class="hljs-keyword">if</span> (!contains) &#123;               cur.size++;            &#125;            <span class="hljs-keyword">if</span> (key &lt; cur.key) &#123;               cur.l = add(cur.l, key, contains);            &#125; <span class="hljs-keyword">else</span> &#123;               cur.r = add(cur.r, key, contains);            &#125;            <span class="hljs-keyword">return</span> matain(cur);         &#125;      &#125;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">long</span> sum)</span> </span>&#123;      <span class="hljs-keyword">boolean</span> contains = set.contains(sum);      root = add(root, sum, contains);      set.add(sum);   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">lessKeySize</span><span class="hljs-params">(<span class="hljs-keyword">long</span> key)</span> </span>&#123;      SBTNode cur = root;      <span class="hljs-keyword">long</span> ans = <span class="hljs-number">0</span>;      <span class="hljs-keyword">while</span> (cur != <span class="hljs-keyword">null</span>) &#123;         <span class="hljs-keyword">if</span> (key == cur.key) &#123;            <span class="hljs-keyword">return</span> ans + (cur.l != <span class="hljs-keyword">null</span> ? cur.l.all : <span class="hljs-number">0</span>);         &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key &lt; cur.key) &#123;            cur = cur.l;         &#125; <span class="hljs-keyword">else</span> &#123;            ans += cur.all - (cur.r != <span class="hljs-keyword">null</span> ? cur.r.all : <span class="hljs-number">0</span>);            cur = cur.r;         &#125;      &#125;      <span class="hljs-keyword">return</span> ans;   &#125;   <span class="hljs-comment">// &gt; 7 8...</span>   <span class="hljs-comment">// &lt;8 ...&lt;=7</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">moreKeySize</span><span class="hljs-params">(<span class="hljs-keyword">long</span> key)</span> </span>&#123;      <span class="hljs-keyword">return</span> root != <span class="hljs-keyword">null</span> ? (root.all - lessKeySize(key + <span class="hljs-number">1</span>)) : <span class="hljs-number">0</span>;   &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">countRangeSum2</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> lower, <span class="hljs-keyword">int</span> upper)</span> </span>&#123;   SizeBalancedTreeSet treeSet = <span class="hljs-keyword">new</span> SizeBalancedTreeSet();   <span class="hljs-keyword">long</span> sum = <span class="hljs-number">0</span>;   <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;   treeSet.add(<span class="hljs-number">0</span>);<span class="hljs-comment">// 一个数都没有 已经有一个前缀和0</span>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;      sum += nums[i];      <span class="hljs-comment">// sum i结尾的时候[lower, upper]</span>      <span class="hljs-comment">// 先求之前有多少在[sum - upper, sum - lower]</span>      <span class="hljs-comment">// 查 ? &lt; sum - lower + 1 a</span>      <span class="hljs-comment">// 查 ? &lt; sum - upper b</span>      <span class="hljs-comment">// a - b</span>      <span class="hljs-keyword">long</span> a = treeSet.lessKeySize(sum - lower + <span class="hljs-number">1</span>);      <span class="hljs-keyword">long</span> b = treeSet.lessKeySize(sum - upper);      ans += a - b;      treeSet.add(sum);   &#125;   <span class="hljs-keyword">return</span> ans;&#125;</code></pre><h3 id="滑动窗口中位数"><a href="#滑动窗口中位数" class="headerlink" title="滑动窗口中位数"></a>滑动窗口中位数</h3><p>有一个滑动窗口（讲过的）：</p><p>1）L是滑动窗口最左位置、R是滑动窗口最右位置，一开始LR都在数组左侧<br>2）任何一步都可能R往右动，表示某个数进了窗口<br>3）任何一步都可能L往右动，表示某个数出了窗口</p><p>想知道每一个窗口状态的中位数(严格的中位数)</p><p>增加重复数字，允许删掉一次，得到第小K的函数就行</p><p>从头部开始滑，左孩子如果都小K，看自己，再看右边….</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SBTNode</span>&lt;<span class="hljs-title">K</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">K</span>&gt;&gt; </span>&#123;   <span class="hljs-keyword">public</span> K key;   <span class="hljs-keyword">public</span> SBTNode&lt;K&gt; l;   <span class="hljs-keyword">public</span> SBTNode&lt;K&gt; r;   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> size;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SBTNode</span><span class="hljs-params">(K k)</span> </span>&#123;      key = k;      size = <span class="hljs-number">1</span>;   &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SizeBalancedTreeMap</span>&lt;<span class="hljs-title">K</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">K</span>&gt;&gt; </span>&#123;   <span class="hljs-keyword">private</span> SBTNode&lt;K&gt; root;   <span class="hljs-function"><span class="hljs-keyword">private</span> SBTNode&lt;K&gt; <span class="hljs-title">rightRotate</span><span class="hljs-params">(SBTNode&lt;K&gt; cur)</span> </span>&#123;      SBTNode&lt;K&gt; leftNode = cur.l;      cur.l = leftNode.r;      leftNode.r = cur;      leftNode.size = cur.size;      cur.size = (cur.l != <span class="hljs-keyword">null</span> ? cur.l.size : <span class="hljs-number">0</span>) + (cur.r != <span class="hljs-keyword">null</span> ? cur.r.size : <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>;      <span class="hljs-keyword">return</span> leftNode;   &#125;   <span class="hljs-function"><span class="hljs-keyword">private</span> SBTNode&lt;K&gt; <span class="hljs-title">leftRotate</span><span class="hljs-params">(SBTNode&lt;K&gt; cur)</span> </span>&#123;      SBTNode&lt;K&gt; rightNode = cur.r;      cur.r = rightNode.l;      rightNode.l = cur;      rightNode.size = cur.size;      cur.size = (cur.l != <span class="hljs-keyword">null</span> ? cur.l.size : <span class="hljs-number">0</span>) + (cur.r != <span class="hljs-keyword">null</span> ? cur.r.size : <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>;      <span class="hljs-keyword">return</span> rightNode;   &#125;   <span class="hljs-function"><span class="hljs-keyword">private</span> SBTNode&lt;K&gt; <span class="hljs-title">matain</span><span class="hljs-params">(SBTNode&lt;K&gt; cur)</span> </span>&#123;      <span class="hljs-keyword">if</span> (cur == <span class="hljs-keyword">null</span>) &#123;         <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;      &#125;      <span class="hljs-keyword">if</span> (cur.l != <span class="hljs-keyword">null</span> &amp;&amp; cur.l.l != <span class="hljs-keyword">null</span> &amp;&amp; cur.r != <span class="hljs-keyword">null</span> &amp;&amp; cur.l.l.size &gt; cur.r.size) &#123;         cur = rightRotate(cur);         cur.r = matain(cur.r);         cur = matain(cur);      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cur.l != <span class="hljs-keyword">null</span> &amp;&amp; cur.l.r != <span class="hljs-keyword">null</span> &amp;&amp; cur.r != <span class="hljs-keyword">null</span> &amp;&amp; cur.l.r.size &gt; cur.r.size) &#123;         cur.l = leftRotate(cur.l);         cur = rightRotate(cur);         cur.l = matain(cur.l);         cur.r = matain(cur.r);         cur = matain(cur);      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cur.r != <span class="hljs-keyword">null</span> &amp;&amp; cur.r.r != <span class="hljs-keyword">null</span> &amp;&amp; cur.l != <span class="hljs-keyword">null</span> &amp;&amp; cur.r.r.size &gt; cur.l.size) &#123;         cur = leftRotate(cur);         cur.l = matain(cur.l);         cur = matain(cur);      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cur.r != <span class="hljs-keyword">null</span> &amp;&amp; cur.r.l != <span class="hljs-keyword">null</span> &amp;&amp; cur.l != <span class="hljs-keyword">null</span> &amp;&amp; cur.r.l.size &gt; cur.l.size) &#123;         cur.r = rightRotate(cur.r);         cur = leftRotate(cur);         cur.l = matain(cur.l);         cur.r = matain(cur.r);         cur = matain(cur);      &#125;      <span class="hljs-keyword">return</span> cur;   &#125;   <span class="hljs-function"><span class="hljs-keyword">private</span> SBTNode&lt;K&gt; <span class="hljs-title">findLastIndex</span><span class="hljs-params">(K key)</span> </span>&#123;      SBTNode&lt;K&gt; pre = root;      SBTNode&lt;K&gt; cur = root;      <span class="hljs-keyword">while</span> (cur != <span class="hljs-keyword">null</span>) &#123;         pre = cur;         <span class="hljs-keyword">if</span> (key.compareTo(cur.key) == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">break</span>;         &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key.compareTo(cur.key) &lt; <span class="hljs-number">0</span>) &#123;            cur = cur.l;         &#125; <span class="hljs-keyword">else</span> &#123;            cur = cur.r;         &#125;      &#125;      <span class="hljs-keyword">return</span> pre;   &#125;   <span class="hljs-function"><span class="hljs-keyword">private</span> SBTNode&lt;K&gt; <span class="hljs-title">add</span><span class="hljs-params">(SBTNode&lt;K&gt; cur, K key)</span> </span>&#123;      <span class="hljs-keyword">if</span> (cur == <span class="hljs-keyword">null</span>) &#123;         <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SBTNode&lt;K&gt;(key);      &#125; <span class="hljs-keyword">else</span> &#123;         cur.size++;         <span class="hljs-keyword">if</span> (key.compareTo(cur.key) &lt; <span class="hljs-number">0</span>) &#123;            cur.l = add(cur.l, key);         &#125; <span class="hljs-keyword">else</span> &#123;            cur.r = add(cur.r, key);         &#125;         <span class="hljs-keyword">return</span> matain(cur);      &#125;   &#125;   <span class="hljs-function"><span class="hljs-keyword">private</span> SBTNode&lt;K&gt; <span class="hljs-title">delete</span><span class="hljs-params">(SBTNode&lt;K&gt; cur, K key)</span> </span>&#123;      cur.size--;      <span class="hljs-keyword">if</span> (key.compareTo(cur.key) &gt; <span class="hljs-number">0</span>) &#123;         cur.r = delete(cur.r, key);      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key.compareTo(cur.key) &lt; <span class="hljs-number">0</span>) &#123;         cur.l = delete(cur.l, key);      &#125; <span class="hljs-keyword">else</span> &#123;         <span class="hljs-keyword">if</span> (cur.l == <span class="hljs-keyword">null</span> &amp;&amp; cur.r == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-comment">// free cur memory -&gt; C++</span>            cur = <span class="hljs-keyword">null</span>;         &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cur.l == <span class="hljs-keyword">null</span> &amp;&amp; cur.r != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-comment">// free cur memory -&gt; C++</span>            cur = cur.r;         &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cur.l != <span class="hljs-keyword">null</span> &amp;&amp; cur.r == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-comment">// free cur memory -&gt; C++</span>            cur = cur.l;         &#125; <span class="hljs-keyword">else</span> &#123;            SBTNode&lt;K&gt; pre = <span class="hljs-keyword">null</span>;            SBTNode&lt;K&gt; des = cur.r;            des.size--;            <span class="hljs-keyword">while</span> (des.l != <span class="hljs-keyword">null</span>) &#123;               pre = des;               des = des.l;               des.size--;            &#125;            <span class="hljs-keyword">if</span> (pre != <span class="hljs-keyword">null</span>) &#123;               pre.l = des.r;               des.r = cur.r;            &#125;            des.l = cur.l;            des.size = des.l.size + (des.r == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : des.r.size) + <span class="hljs-number">1</span>;            <span class="hljs-comment">// free cur memory -&gt; C++</span>            cur = des;         &#125;      &#125;      <span class="hljs-keyword">return</span> cur;   &#125;   <span class="hljs-function"><span class="hljs-keyword">private</span> SBTNode&lt;K&gt; <span class="hljs-title">getIndex</span><span class="hljs-params">(SBTNode&lt;K&gt; cur, <span class="hljs-keyword">int</span> kth)</span> </span>&#123;      <span class="hljs-keyword">if</span> (kth == (cur.l != <span class="hljs-keyword">null</span> ? cur.l.size : <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>) &#123;         <span class="hljs-keyword">return</span> cur;      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (kth &lt;= (cur.l != <span class="hljs-keyword">null</span> ? cur.l.size : <span class="hljs-number">0</span>)) &#123;         <span class="hljs-keyword">return</span> getIndex(cur.l, kth);      &#125; <span class="hljs-keyword">else</span> &#123;         <span class="hljs-keyword">return</span> getIndex(cur.r, kth - (cur.l != <span class="hljs-keyword">null</span> ? cur.l.size : <span class="hljs-number">0</span>) - <span class="hljs-number">1</span>);      &#125;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> root == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : root.size;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">containsKey</span><span class="hljs-params">(K key)</span> </span>&#123;      <span class="hljs-keyword">if</span> (key == <span class="hljs-keyword">null</span>) &#123;         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;invalid parameter.&quot;</span>);      &#125;      SBTNode&lt;K&gt; lastNode = findLastIndex(key);      <span class="hljs-keyword">return</span> lastNode != <span class="hljs-keyword">null</span> &amp;&amp; key.compareTo(lastNode.key) == <span class="hljs-number">0</span> ? <span class="hljs-keyword">true</span> : <span class="hljs-keyword">false</span>;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(K key)</span> </span>&#123;      <span class="hljs-keyword">if</span> (key == <span class="hljs-keyword">null</span>) &#123;         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;invalid parameter.&quot;</span>);      &#125;      SBTNode&lt;K&gt; lastNode = findLastIndex(key);      <span class="hljs-keyword">if</span> (lastNode == <span class="hljs-keyword">null</span> || key.compareTo(lastNode.key) != <span class="hljs-number">0</span>) &#123;         root = add(root, key);      &#125;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(K key)</span> </span>&#123;      <span class="hljs-keyword">if</span> (key == <span class="hljs-keyword">null</span>) &#123;         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;invalid parameter.&quot;</span>);      &#125;      <span class="hljs-keyword">if</span> (containsKey(key)) &#123;         root = delete(root, key);      &#125;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> K <span class="hljs-title">getIndexKey</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;      <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt;= <span class="hljs-keyword">this</span>.size()) &#123;         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;invalid parameter.&quot;</span>);      &#125;      <span class="hljs-keyword">return</span> getIndex(root, index + <span class="hljs-number">1</span>).key;   &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">Node</span>&gt; </span>&#123;   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> index;   <span class="hljs-comment">// 先根据value排序，再排序index</span>   <span class="hljs-comment">// 5第一次出现 再5第二次出现前面</span>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> value;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> v)</span> </span>&#123;      index = i;      value = v;   &#125;   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(Node o)</span> </span>&#123;      <span class="hljs-keyword">return</span> value != o.value ? Integer.valueOf(value).compareTo(o.value)            : Integer.valueOf(index).compareTo(o.index);   &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">double</span>[] medianSlidingWindow(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k) &#123;   SizeBalancedTreeMap&lt;Node&gt; map = <span class="hljs-keyword">new</span> SizeBalancedTreeMap&lt;&gt;();   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k - <span class="hljs-number">1</span>; i++) &#123;      map.add(<span class="hljs-keyword">new</span> Node(i, nums[i]));   &#125;   <span class="hljs-keyword">double</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-keyword">double</span>[nums.length - k + <span class="hljs-number">1</span>];   <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = k - <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;      map.add(<span class="hljs-keyword">new</span> Node(i, nums[i]));      <span class="hljs-keyword">if</span> (map.size() % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;         Node upmid = map.getIndexKey(map.size() / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>);         Node downmid = map.getIndexKey(map.size() / <span class="hljs-number">2</span>);         ans[index++] = ((<span class="hljs-keyword">double</span>) upmid.value + (<span class="hljs-keyword">double</span>) downmid.value) / <span class="hljs-number">2</span>;      &#125; <span class="hljs-keyword">else</span> &#123;         Node mid = map.getIndexKey(map.size() / <span class="hljs-number">2</span>);         ans[index++] = (<span class="hljs-keyword">double</span>) mid.value;      &#125;      map.remove(<span class="hljs-keyword">new</span> Node(i - k + <span class="hljs-number">1</span>, nums[i - k + <span class="hljs-number">1</span>]));   &#125;   <span class="hljs-keyword">return</span> ans;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指offer</title>
    <link href="/2020/12/25/%E5%89%91%E6%8C%87offer/"/>
    <url>/2020/12/25/%E5%89%91%E6%8C%87offer/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>开始更新了！</p><h1 id="数组和字符串"><a href="#数组和字符串" class="headerlink" title="数组和字符串"></a>数组和字符串</h1><h2 id="04-二维数组中的查找"><a href="#04-二维数组中的查找" class="headerlink" title="04. 二维数组中的查找"></a>04. 二维数组中的查找</h2><p>在一个 n * m 的二维数组中，每一行都按照 <strong>从左到右递增</strong> 的顺序排序，每一列都按照 <strong>从上到下递增</strong> 的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><blockquote><p>示例</p></blockquote><p>[<br>  [1,   4,  7, 11, 15],<br>  [2,   5,  8, 12, 19],<br>  [3,   6,  9, 16, 22],<br>  [10, 13, 14, 17, 24],<br>  [18, 21, 23, 26, 30]<br>]</p><p>给定 target = <code>5</code>，返回 <code>true</code>。</p><p>给定 target = <code>20</code>，返回 <code>false</code>。</p><h3 id="错误的贪心策略"><a href="#错误的贪心策略" class="headerlink" title="错误的贪心策略"></a>错误的贪心策略</h3><p class="note note-danger"> 错误策略 </p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201230105314.png" alt="错误"></p><p>我们找 <strong>对角线</strong>，当上一个对角线值小于target并且下一个对角线值大于target的时候，我们从上一个开始往右和往下找，即可以盲目遍历，也可以在新位置进行新的找对角线。</p><p>代码很 <strong>复杂</strong>， 判断的条件多。</p><p>能解决很多的例子：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201230105549.png" alt="例子"></p><p>但为什么是错误的？</p><p>我们仔细看上面一张图，是否出现遗漏区域：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201230105641.png" alt="遗漏区域"></p><p>框所示，为遗漏区域，所以当矩阵为：</p><p>[[1,3,5,7,9],</p><p>[2,4,6,8,10],</p><p>[11,13,15,17,19],</p><p>[12,14,16,18,20],</p><p>[21,22,23,24,25]]</p><p>我们是找不到11的，因为我们定的位置在 4 - 13，开始找4右边和4下面，这两个位置都没有11，11在第一列中。</p><h3 id="正确的贪心策略"><a href="#正确的贪心策略" class="headerlink" title="正确的贪心策略"></a>正确的贪心策略</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201230110103.png" alt="正确策略"></p><p>我们利用左下角位置，上面都小，右边都大的策略，</p><p>如果发现当前cur 小于 target 往右找；cur 大于 target 往上找，直到出边界或者找到为止。</p><p>Code:</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">findNumberIn2DArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix, <span class="hljs-keyword">int</span> target)</span> </span>&#123;      <span class="hljs-keyword">int</span> n = matrix.length; <span class="hljs-comment">// 行数</span>      <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>)&#123;          <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;      &#125;      <span class="hljs-keyword">int</span> m = matrix[<span class="hljs-number">0</span>].length; <span class="hljs-comment">// 列</span>      <span class="hljs-keyword">if</span> (m == <span class="hljs-number">0</span>)&#123;          <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;      &#125;      <span class="hljs-keyword">int</span> row = n - <span class="hljs-number">1</span>; <span class="hljs-comment">// 行数</span>      <span class="hljs-keyword">int</span> col = <span class="hljs-number">0</span>; <span class="hljs-comment">// 列数</span>      <span class="hljs-keyword">while</span> ( row &gt;= <span class="hljs-number">0</span> &amp;&amp; col &lt; m)&#123;          <span class="hljs-keyword">if</span> (matrix[row][col] == target)&#123;              <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;          &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (matrix[row][col] &gt; target)&#123;              row --;          &#125; <span class="hljs-keyword">else</span> &#123;              col ++;          &#125;      &#125;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;  &#125;</code></pre><h2 id="05-替换空格"><a href="#05-替换空格" class="headerlink" title="05. 替换空格"></a>05. 替换空格</h2><p> <a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/">05. 替换空格</a></p><p>请实现一个函数，把字符串 <code>s</code> 中的每个空格替换成”%20”。</p><blockquote><p>示例</p></blockquote><pre><code class="hljs perl">输入：<span class="hljs-keyword">s</span> = <span class="hljs-string">&quot;We are happy.&quot;</span>输出：<span class="hljs-string">&quot;We%20are%20happy.&quot;</span></code></pre><p class="note note-primary"> 三种方式实现，思考String Builder底层 </p><h3 id="java自带api"><a href="#java自带api" class="headerlink" title="java自带api"></a>java自带api</h3><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">replaceSpace</span><span class="hljs-params">(String s)</span> </span>&#123;    <span class="hljs-keyword">return</span> s.replace(<span class="hljs-string">&quot; &quot;</span>, <span class="hljs-string">&quot;%20&quot;</span>);&#125;</code></pre><p>一行代码解决问题</p><h3 id="String-Builder追加"><a href="#String-Builder追加" class="headerlink" title="String Builder追加"></a>String Builder追加</h3><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">replaceSpace1</span><span class="hljs-params">(String s)</span> </span>&#123;    <span class="hljs-keyword">char</span>[] chars = s.toCharArray();    StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; chars.length; i ++)&#123;        <span class="hljs-keyword">if</span> (chars[i] != <span class="hljs-string">&#x27; &#x27;</span>)&#123;            sb.append(chars[i]);        &#125;<span class="hljs-keyword">else</span> &#123;            sb.append(<span class="hljs-string">&quot;%20&quot;</span>);        &#125;       &#125;    <span class="hljs-keyword">return</span> sb.toString();&#125;</code></pre><h3 id="静态char数组"><a href="#静态char数组" class="headerlink" title="静态char数组"></a>静态char数组</h3><p> <strong>StringBuilder</strong> ，本质上是一个 <strong>char</strong> 类型的 <strong>动态数组</strong>：</p><p>当初始化 StringBuilder 的时候，会初始化一个固定长度的 char 类型的数组<br>当往 StringBuilder 中 append 数据的时候，其实就是往 char 类型的数组最后追加数据</p><p>但是 <strong>扩容</strong> 这个过程是有损性能的，我们可以直接设置一个 三倍长度的静态char[]数组</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">replaceSpace</span><span class="hljs-params">(String s)</span> </span>&#123;        <span class="hljs-keyword">char</span>[] chars = s.toCharArray();        <span class="hljs-keyword">int</span> n = chars.length;        <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;        <span class="hljs-keyword">char</span>[] append = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">3</span> * n];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; chars.length; i ++)&#123;            <span class="hljs-keyword">if</span> (chars[i] == <span class="hljs-string">&#x27; &#x27;</span>)&#123;                append[j++] = <span class="hljs-string">&#x27;%&#x27;</span>;                append[j++] = <span class="hljs-string">&#x27;2&#x27;</span>;                append[j++] = <span class="hljs-string">&#x27;0&#x27;</span>;            &#125;<span class="hljs-keyword">else</span> &#123;                append[j++] = chars[i];            &#125;                 &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(append, <span class="hljs-number">0</span>, j);    &#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201230142311.png" alt="图解"></p><h2 id="剑指-Offer-45-把数组排成最小的数"><a href="#剑指-Offer-45-把数组排成最小的数" class="headerlink" title="剑指 Offer 45. 把数组排成最小的数"></a>剑指 Offer 45. 把数组排成最小的数</h2><p><a href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/">剑指 Offer 45. 把数组排成最小的数</a></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210104082536.png" alt="question"></p><p>思路，参考：</p><p>重写 <strong>比较器</strong> <a href="https://blog.qiukework.top/2020/11/25/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/#%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95">贪心字典序问题</a></p><p>即 x,y比较拼接后大小,需要比较 xy和yx</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">minNumber</span> <span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">if</span> (nums == <span class="hljs-keyword">null</span> || nums.length == <span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;        &#125;        String[] strs = <span class="hljs-keyword">new</span> String[nums.length];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i ++)&#123;            strs[i] = <span class="hljs-string">&quot;&quot;</span> + nums[i];        &#125;                    Arrays.sort(strs, <span class="hljs-keyword">new</span> MyComparator1());        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; strs.length;i++ )&#123;            sb.append(strs[i]);        &#125;        <span class="hljs-keyword">return</span> sb.toString();    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyComparator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparator</span>&lt;<span class="hljs-title">String</span>&gt; </span>&#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(String a, String b)</span> </span>&#123;            <span class="hljs-keyword">return</span> (a + b).compareTo(b + a);        &#125;    &#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>剑指offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode</title>
    <link href="/2020/12/25/leetcode/"/>
    <url>/2020/12/25/leetcode/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="188-买卖股票-IV"><a href="#188-买卖股票-IV" class="headerlink" title="188. 买卖股票 IV"></a>188. 买卖股票 IV</h2><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/">188. 买卖股票的最佳时机 IV</a></p><p class="note note-primary">买卖股票有六种题型，后续更新</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201228180405.png" alt="question"></p><p>状态图：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201229091140.png" alt="状态图"></p><p>由题意分析，不难得出：</p><ul><li><p>如果状态是是 <strong>买入</strong> :</p><ul><li>那么可以 <strong>保持不动</strong></li><li>或者马上 <strong>卖掉</strong></li></ul></li><li><p>如果状态是 <strong>卖出</strong>:</p><ul><li>可以 <strong>保持不动</strong> (等待更好的股价出现，暂时不买)</li><li>或者 <strong>立马再买一股</strong></li><li>同时将count数+1，表示交易过一次了</li></ul></li></ul><h3 id="暴力递归思考问题"><a href="#暴力递归思考问题" class="headerlink" title="暴力递归思考问题"></a>暴力递归思考问题</h3><p>我们可以用 <strong>三个变量</strong> 来表示买卖k次的交易状态</p><ul><li>index，用来表示 <strong>当前是哪一天</strong></li><li>status，用来表示 <strong>当前是买入、还是卖出</strong> </li><li>count，用来表示 <strong>交易了几次</strong></li></ul><p>暴力法中我们尝试所有的解决策略：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201229091330.png" alt="递归树"></p><pre><code class="hljs java">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;    <span class="hljs-comment">// 暴力</span>    <span class="hljs-keyword">if</span>(prices.length== <span class="hljs-number">0</span> || prices == <span class="hljs-keyword">null</span>)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, k, prices);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> status, <span class="hljs-keyword">int</span> count, <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span>[] prices)</span></span>&#123;    <span class="hljs-keyword">if</span> (count == k || index == prices.length) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-comment">// 保持不变</span>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>, b = <span class="hljs-number">0</span>, c = <span class="hljs-number">0</span>;    a = dfs(index + <span class="hljs-number">1</span>, status, count, k, prices);    <span class="hljs-keyword">if</span> (status == <span class="hljs-number">1</span>)&#123;        <span class="hljs-comment">// 卖出</span>        b = dfs(index + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, count + <span class="hljs-number">1</span>, k, prices) + prices[index];    &#125;<span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">// 买入</span>        c = dfs(index + <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, count, k, prices) - prices[index];    &#125;    <span class="hljs-keyword">return</span> Math.max(Math.max(a, b), c);&#125;</code></pre><h3 id="动态规划-1"><a href="#动态规划-1" class="headerlink" title="动态规划"></a>动态规划</h3><blockquote><p>三个参数三维表，但有一维为01，转为两个二维表</p></blockquote><p>我们再次回顾一下状态转化：</p><p>每次到达i位置时：</p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201229091455.png" alt="i位置" style="zoom:50%;" /><p>如果三维表最后一位 0表示卖出，1表示买入：</p><pre><code class="hljs js">第一次买入：从初始状态转换而来，或者第一次买入后保持不动#dp[i][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = max(dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>],dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]-prices[i])第一次卖出：从第一次买入转换而来，或者第一次卖出后保持不动#dp[i][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = max(dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>],dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]+prices[i])第二次买入：从第一次卖出转换而来，或者第二次买入后保持不动dp[i][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = max(dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>],dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]-prices[i])第二次卖出：从第二次买入转换而来，或者第二次卖出后保持不动dp[i][<span class="hljs-number">2</span>][<span class="hljs-number">0</span>] = max(dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">2</span>][<span class="hljs-number">0</span>],dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]+prices[i])第三次买入：dp[i][<span class="hljs-number">2</span>][<span class="hljs-number">1</span>] = max(dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">2</span>][<span class="hljs-number">1</span>],dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">2</span>][<span class="hljs-number">0</span>]-prices[i])第三次卖出：   dp[i][<span class="hljs-number">3</span>][<span class="hljs-number">0</span>] = max(dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">3</span>][<span class="hljs-number">0</span>],dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">2</span>][<span class="hljs-number">1</span>]+prices[i])</code></pre><p>扩展至j次交易的话：</p><pre><code class="hljs js">第k次买入： 从第k-<span class="hljs-number">1</span>次卖出转换而来，或者第k次买入后保持不动dp[i][j-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = max(dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>],dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]-prices[i])第k次卖出： 从第k次买入后转换而来，或者是第k次卖出后保持不动dp[i][j][<span class="hljs-number">0</span>] = max(dp[i-<span class="hljs-number">1</span>][j][<span class="hljs-number">0</span>],dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]+prices[i])第k+<span class="hljs-number">1</span>次买入：dp[i][j][<span class="hljs-number">1</span>] = max(dp[i-<span class="hljs-number">1</span>][j][<span class="hljs-number">1</span>],dp[i-<span class="hljs-number">1</span>][j][<span class="hljs-number">0</span>]-prices[i])</code></pre><p>因此我们设置 <strong>两张表</strong>：</p><p>buy和sell，都为二维表，这样就可以忽略三维表第三位：</p><p>我们的规则如下：</p><p> buy[i] [j]表示到达索引i时候，达成j次交易买入获得最大收益<br> sell[i] [j]表示到达索引i时候，达成j次交易卖出获得最大收益<br> buy[i] [j] = Math.max( buy[i - 1] [j], sell[i - 1] [j] - price[i])<br> sell[i] [j] = Math.max( sell[i - 1] [j], buy[i - 1] [j - 1] + price[i])</p><pre><code class="hljs java">    <span class="hljs-comment">// 动态规划</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;    <span class="hljs-keyword">if</span>(prices.length== <span class="hljs-number">0</span> || prices == <span class="hljs-keyword">null</span>)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">int</span> n = prices.length;    k = Math.min(n/<span class="hljs-number">2</span>, k);    <span class="hljs-comment">// 动态规划的意义</span>    <span class="hljs-comment">// buy[i][j]表示到达索引i时候，达成j次交易买入获得最大收益</span>    <span class="hljs-comment">// sell[i][j]表示到达索引i时候，达成j次交易卖出获得最大收益</span>    <span class="hljs-comment">// buy[i][j] = Math.max( buy[i - 1][j], sell[i - 1][j] - price[i])</span>    <span class="hljs-comment">// sell[i][j] = Math.max( sell[i - 1][j], buy[i - 1][j - 1] + price[i])</span>    <span class="hljs-keyword">int</span>[][] buy = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n][k + <span class="hljs-number">1</span>];    <span class="hljs-keyword">int</span>[][] sell = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n][k + <span class="hljs-number">1</span>];    buy[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = -prices[<span class="hljs-number">0</span>];    sell[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 注意：buy[0][i] 和 sell[0][i] 是没有意义的</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= k; ++i) &#123;        buy[<span class="hljs-number">0</span>][i] = sell[<span class="hljs-number">0</span>][i] = Integer.MIN_VALUE / <span class="hljs-number">2</span>;    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)&#123;        buy[i][<span class="hljs-number">0</span>] = Math.max( buy[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], sell[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] - prices[i]);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j&lt;= k; j++)&#123;            buy[i][j] = Math.max( buy[i - <span class="hljs-number">1</span>][j], sell[i - <span class="hljs-number">1</span>][j] - prices[i]);            sell[i][j] = Math.max( sell[i - <span class="hljs-number">1</span>][j], buy[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + prices[i]);        &#125;    &#125;    <span class="hljs-keyword">return</span> Arrays.stream(sell[n - <span class="hljs-number">1</span>]).max().getAsInt();&#125;</code></pre><h3 id="动态规划优化"><a href="#动态规划优化" class="headerlink" title="动态规划优化"></a>动态规划优化</h3><blockquote><p>空间优化</p></blockquote><p>上述中：</p><ul><li>外层的循环是n，即遍历数组</li><li>内层的循环是k，遍历k次交易</li></ul><p>不难看出上述二维表中的i并没有被实际用到</p><p>又或者说：状态转移方程中，<strong>buy[i] [j] 和 sell[i] [j] 都从 buy[i−1] [..] 以及 sell[i−1] [..] 转移而来</strong></p><pre><code class="hljs java">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;    <span class="hljs-comment">// 动态规划空间优化</span>    <span class="hljs-keyword">if</span>(prices.length== <span class="hljs-number">0</span> || prices == <span class="hljs-keyword">null</span>)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">int</span> n = prices.length;    k = Math.min(n/<span class="hljs-number">2</span>, k);    <span class="hljs-keyword">int</span>[] buy = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[k + <span class="hljs-number">1</span>];    <span class="hljs-keyword">int</span>[] sell = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[k + <span class="hljs-number">1</span>];    buy[<span class="hljs-number">0</span>] = -prices[<span class="hljs-number">0</span>];    sell[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 注意：buy[0][i] 和 sell[0][i] 是没有意义的</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= k; ++i) &#123;        buy[i] = sell[i] = Integer.MIN_VALUE / <span class="hljs-number">2</span>;    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)&#123;        buy[<span class="hljs-number">0</span>] = Math.max( buy[<span class="hljs-number">0</span>], sell[<span class="hljs-number">0</span>] - prices[i]);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j&lt;= k; j++)&#123;            buy[j] = Math.max( buy[j], sell[j] - prices[i]);            sell[j] = Math.max( sell[j], buy[j - <span class="hljs-number">1</span>] + prices[i]);        &#125;    &#125;    <span class="hljs-keyword">return</span> Arrays.stream(sell).max().getAsInt();&#125;</code></pre><p class="note note-danger">buy[0][i] 和 sell[0][i] 是没有意义的,必须值为负最小</p><h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><h2 id="330-按要求补齐数组"><a href="#330-按要求补齐数组" class="headerlink" title="330. 按要求补齐数组"></a>330. 按要求补齐数组</h2><p><a href="https://leetcode-cn.com/problems/patching-array/">330. 按要求补齐数组</a></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201229084726.png" alt="question"></p><h3 id="贪心策略"><a href="#贪心策略" class="headerlink" title="贪心策略"></a>贪心策略</h3><p>每次找到未被 <strong>数组nums</strong> 覆盖的 <strong>最小的整数x</strong>，在数组中 <strong>补充x</strong>，然后寻找下一个 <strong>未被覆盖的最小的整数</strong> ，重复上述步骤直到区间 [1,n] 中的所有数字都被覆盖。</p><p class="note note-primary">贪心原理及证明</p><p>对于正整数 x，如果区间 <strong>[1,x-1]</strong> 内的所有数字都已经被覆盖，且 x 在数组中，则区间 <strong>[1,2x-1]</strong> 内的所有数字也都被覆盖。证明如下。</p><p>对于任意  1≤y&lt;x，y 已经被覆盖，x 在数组中，因此 y+x 也被覆盖，区间 [x+1,2x-1]（即区间 [1,x-1] 内的每个数字加上 x 之后得到的区间）内的所有数字也被覆盖，由此可得区间 [1,2x-1] 内的所有数字都被覆盖。</p><p>直接看证明可能有点 <strong>晦涩难懂</strong> ，我们看一下 <strong>例子</strong> ：</p><p>对于数组[1, 5, 10] 要求加x个数字能够覆盖20，即[1, 20]。</p><p>1⃣️ 我们设 <strong>初始能够覆盖的边界</strong> 为boundary = 1，即当前我们还没开始遍历数组，我们的 <strong>初始覆盖范围为[1, 1)</strong></p><p>2⃣️ 现在我们开始遍历数组，从第一位开始，遍历到 1，当前数组自身第一个数就能够覆盖的范围为 [1, 1]，1&lt;= boundary，所以我们加上boundary，覆盖范围变成 <strong>[1, 1 + boundary)</strong> ，即[1, 2)，注意右边为 <strong>开区间</strong> ，你可以把boundary想象成 <strong>闭区间且初始没有覆盖为0</strong> ；</p><p>3⃣️ 我们再遍历下一位，来到5，此时我们发现 <strong>[1, 2) 无法遍历到 5</strong>，于是我们加入 <strong>最小的整数x</strong> ，寻找新覆盖范围，能否覆盖到5，我们加入的数正根据上述的 <strong>贪心原理及证明</strong> 规则中加入， 边界[1, 2)我们加入2，所以新的覆盖范围为[1, 4)，加入数加一，我们再次来到5，发现还是无法遍历到5，我们再加入最小整数x，新的覆盖范围为[1, 8)，加入数加一。</p><p>4⃣️ 我们又一次来到5，发现可以覆盖到5了，但数组中的5改怎么办呢？</p><p>即因为数组中5存在，所以我们需要扩大我们的覆盖范围，实际上就是覆盖范围加上5，变为 <strong>[1, 8 + 5)</strong> ，证明上述已经证明，下一次来到10，发现可以覆盖10，又因为数组中有10，所以我们再次更新覆盖范围 <strong>[1, 8 + 5 + 10)</strong> ，最后覆盖范围能够越过20.</p><h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><pre><code class="hljs java">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minPatches</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> n)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = nums.length;    <span class="hljs-comment">// 从1开始验证覆盖范围， 此时可覆盖的范围是[1,1)</span>    <span class="hljs-comment">// boundary表示连续覆盖范围的右边界</span>    <span class="hljs-keyword">long</span> boundary = <span class="hljs-number">1</span>;     <span class="hljs-comment">// count 表示 添加了几个数字</span>    <span class="hljs-comment">// i表示目前遍历到的nums中的index</span>    <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;     <span class="hljs-comment">// 若目前还没连续覆盖到n，则继续循环</span>    <span class="hljs-keyword">while</span> (boundary &lt;= n)&#123;        <span class="hljs-comment">// 原本覆盖范围为[1,add)，如果当前加入nums[i]到[i,boundary)中</span>        <span class="hljs-comment">// 那么此时可构成的连续覆盖范围就是[1,boundary + nums[i])</span>        <span class="hljs-keyword">if</span> ( (index &lt; len ) &amp;&amp; ( nums[index] &lt;= boundary ))&#123;            boundary += nums[index];            index++;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// 否则，那么目前由数组中原本的数字没法继续扩大为下一级别的连续范围，</span>            <span class="hljs-comment">// 则向数组中加入此时的右边界add，可覆盖[1,2boundary)范围  </span>            boundary = boundary &lt;&lt; <span class="hljs-number">1</span>;            count++;        &#125;    &#125;    <span class="hljs-keyword">return</span> count;&#125;</code></pre><p class="note note-danger">boundary应该小于等于n，该程序中边界为开区间 </p><h2 id="435-无重叠区间"><a href="#435-无重叠区间" class="headerlink" title="435. 无重叠区间"></a>435. 无重叠区间</h2><p><a href="https://leetcode-cn.com/problems/non-overlapping-intervals/">435. 无重叠区间</a></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210104083302.png" alt="question"></p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210104084026.png" alt="绿色为不相交" style="zoom:50%;" /><p>绿色区间就为不相交，我们需要先算出不相交的个数。</p><p>解题思路：</p><p>按照尾端排序（nlogn），排好序后对区间遍历，如果下一个start大于当前end，加一，求出不相交个数</p><p>总个数 - 不相交个数 就为需要 <strong>移除</strong> 的结果。</p><p>注意：初始一定会有一个区间不相交，初始count为1。</p><p>Code:</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">eraseOverlapIntervals</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] intervals)</span> </span>&#123;        <span class="hljs-keyword">return</span> intervals.length - findMaxIntervals(intervals);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findMaxIntervals</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] intervals)</span></span>&#123;        <span class="hljs-keyword">if</span> (intervals.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-comment">// 按 end 升序排序</span>        Arrays.sort(intervals, <span class="hljs-keyword">new</span> Comparator&lt;<span class="hljs-keyword">int</span>[]&gt;() &#123;            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span>[] b)</span> </span>&#123;                <span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>] - b[<span class="hljs-number">1</span>];            &#125;        &#125;);                <span class="hljs-comment">// 找不相交的最大区间数目</span>        <span class="hljs-comment">// 一开始定在第一个 ，如果下一个的左区间大于等于第一个的右区间</span>        <span class="hljs-comment">// 就不会相交</span>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> end = intervals[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] interval : intervals)&#123;            <span class="hljs-keyword">int</span> start = interval[<span class="hljs-number">0</span>];            <span class="hljs-keyword">if</span> (start &gt;= end)&#123;                count ++;                end = interval[<span class="hljs-number">1</span>];            &#125;        &#125;        <span class="hljs-keyword">return</span> count;    &#125;</code></pre><p class="note note-primary">下题为上题同一个模板的延展题</p><h2 id="452-用最少数量的箭引爆气球"><a href="#452-用最少数量的箭引爆气球" class="headerlink" title="452. 用最少数量的箭引爆气球"></a>452. 用最少数量的箭引爆气球</h2><p><a href="https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/">452. 用最少数量的箭引爆气球</a></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210104085016.png" alt="question"></p><p>同一个模板套入：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findMinArrowShots</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] points)</span> </span>&#123;        <span class="hljs-keyword">return</span> findMaxIntervals(points);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findMaxIntervals</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] intervals)</span></span>&#123;        <span class="hljs-keyword">if</span> (intervals.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-comment">// 按 end 升序排序</span>        Arrays.sort(intervals, (p1, p2) -&gt; p1[<span class="hljs-number">1</span>] &lt; p2[<span class="hljs-number">1</span>] ? -<span class="hljs-number">1</span> : <span class="hljs-number">1</span>);        <span class="hljs-comment">// 找不相交的最大区间数目</span>        <span class="hljs-comment">// 一开始定在第一个 ，如果下一个的左区间大于等于第一个的右区间</span>        <span class="hljs-comment">// 就不会相交</span>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> end = intervals[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] interval : intervals)&#123;            <span class="hljs-keyword">int</span> start = interval[<span class="hljs-number">0</span>];            <span class="hljs-keyword">if</span> (start &gt; end)&#123;                count ++;                end = interval[<span class="hljs-number">1</span>];            &#125;        &#125;        <span class="hljs-keyword">return</span> count;    &#125;</code></pre><p class="note note-danger">比较器必须写全</p><p>或者：</p><p>最近新增了Test Case， <code>[[-2147483646,-2147483645],[2147483646,2147483647]]</code> 就过不了了，这是因为差值过大而产生溢出。sort的时候不要用<code>a-b</code>来比较，要用<code>Integer.compare(a, b)</code>!!!</p><h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><h2 id="1046-最后一块石头的重量"><a href="#1046-最后一块石头的重量" class="headerlink" title="1046. 最后一块石头的重量"></a>1046. 最后一块石头的重量</h2><p><a href="https://leetcode-cn.com/problems/last-stone-weight/">1046. 最后一块石头的重量</a></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201230114619.png" alt="question"></p><p>方法很简单，只需要创建一个大根堆，每次取出两个数a，b，第一次取出的a一定大于等于b</p><p>如果a &gt; b，把 a - b放进去，如果 a = b，什么都不做</p><p class="note note-info"> 可以尝试自己手写堆结构实现 </p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lastStoneWeight</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] stones)</span> </span>&#123;        PriorityQueue&lt;Integer&gt; pq = <span class="hljs-keyword">new</span> PriorityQueue&lt;Integer&gt;((a, b) -&gt; b - a);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> stone : stones) &#123;            pq.offer(stone);        &#125;        <span class="hljs-keyword">while</span> (pq.size() &gt; <span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">int</span> a = pq.poll();            <span class="hljs-keyword">int</span> b = pq.poll();            <span class="hljs-keyword">if</span> (a &gt; b) &#123;                pq.offer(a - b);            &#125;        &#125;        <span class="hljs-keyword">return</span> pq.isEmpty() ? <span class="hljs-number">0</span> : pq.poll();    &#125;&#125;</code></pre><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="316-去除重复字母"><a href="#316-去除重复字母" class="headerlink" title="316. 去除重复字母"></a>316. 去除重复字母</h2><p><a href="https://leetcode-cn.com/problems/remove-duplicate-letters/">316. 去除重复字母</a></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210104080806.png" alt="question"></p><h3 id="栈解决思路"><a href="#栈解决思路" class="headerlink" title="栈解决思路"></a>栈解决思路</h3><p>例子：bcabc，预期结果为abc</p><p>我们准备一个数组，记录每个字符 <strong>最后一次</strong> 出现的位置，准备一个 <strong>栈</strong>， 准备一个数组 <strong>记录栈中是否存在该字符</strong> </p><p>每次都放入栈，放入前对栈遍历，记录当前来到字符为cur，如果栈中peek大于cur并且peek值 <strong>后续还会出现</strong> </p><p>那就弹出。</p><p>1⃣️ 来到b，加入栈，栈为b。</p><p>2⃣️ 来到c，b小于c，加入栈，栈为bc。</p><p>3⃣️ 来到a，c大于a，后续还有c，弹出，栈为b，继续到b，b大于a，后续还有b，弹出，把a压入栈，栈为a。</p><p>4⃣️ 来到b、c，压入栈，全部弹出逆序。</p><p>Code:</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">removeDuplicateLetters</span><span class="hljs-params">(String s)</span></span>&#123;        <span class="hljs-keyword">int</span> len = s.length();        <span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">2</span>)&#123;            <span class="hljs-keyword">return</span> s;        &#125;        <span class="hljs-comment">// abca</span>        <span class="hljs-keyword">char</span>[] chars = s.toCharArray();        <span class="hljs-keyword">int</span>[] place = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">26</span>]; <span class="hljs-comment">// 记录chars中字符出现的最后一次位置</span>        <span class="hljs-keyword">boolean</span>[] visited = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[<span class="hljs-number">26</span>]; <span class="hljs-comment">// 记录chars中字符是否保存在栈中</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)&#123;            <span class="hljs-comment">// place[ a - a] = 0;</span>            place[chars[i] - <span class="hljs-string">&#x27;a&#x27;</span>] = i;            <span class="hljs-comment">// ....</span>            <span class="hljs-comment">// place [ a - a] = 4</span>        &#125;        Stack stack = <span class="hljs-keyword">new</span> Stack();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)&#123;            <span class="hljs-keyword">char</span> currentChar = chars[i];            <span class="hljs-keyword">if</span> (visited[currentChar - <span class="hljs-string">&#x27;a&#x27;</span>])&#123;                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-comment">// 弹出条件:</span>            <span class="hljs-comment">// 1.栈不为空</span>            <span class="hljs-comment">// 2.栈顶元素字典序 大于 当前元素</span>            <span class="hljs-comment">// 3.栈顶元素 在后序会再次出现</span>            <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; (<span class="hljs-keyword">char</span>)stack.peek() &gt; currentChar &amp;&amp; place[(<span class="hljs-keyword">char</span>)stack.peek()  - <span class="hljs-string">&#x27;a&#x27;</span>] &gt; i)&#123;                visited[(<span class="hljs-keyword">char</span>)stack.pop() - <span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-keyword">false</span>;            &#125;            stack.push(currentChar);            visited[currentChar - <span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-keyword">true</span>;        &#125;        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();        <span class="hljs-keyword">int</span> size = stack.size();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;            sb.append(stack.pop());        &#125;        <span class="hljs-keyword">return</span> sb.reverse().toString();    &#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nowcoder Community Code Review</title>
    <link href="/2020/12/14/Nowcoder%20Community%20Code%20Review/"/>
    <url>/2020/12/14/Nowcoder%20Community%20Code%20Review/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><iframe frameborder="no" border="0" marginwidth="0" position="fixed"  marginheight="0" left=0 width=330 height=86 src="//music.163.com/outchain/player?type=2&id=347572&auto=1&height=66"></iframe><h1 id="系统分析"><a href="#系统分析" class="headerlink" title="系统分析"></a>系统分析</h1><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201216143154.png" alt="需求列表"></p><h2 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h2><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201216150139.png" alt="数据库表设计1"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201216150203.png" alt="数据库表设计2"></p><h2 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h2><ul><li><p>技术栈架构</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201216151114.png" alt="技术栈"></p></li><li><p>部署架构</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201219154749.png" alt="部署架构图"></p></li></ul><h2 id="项目结构一览"><a href="#项目结构一览" class="headerlink" title="项目结构一览"></a>项目结构一览</h2><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201219160159.png" alt="结构"></p><p>此结构有瑕疵，application配置文件应区分 <strong>dev or produce</strong></p><h2 id="项目开发前框架基础配置"><a href="#项目开发前框架基础配置" class="headerlink" title="项目开发前框架基础配置"></a>项目开发前框架基础配置</h2><blockquote><p>Mybatis</p></blockquote><pre><code class="hljs xml"># MybatisPropertiesmybatis.mapper-locations=classpath:mapper/*.xmlmybatis.type-aliases-package=com.nowcoder.community.entitymybatis.configuration.useGeneratedKeys=true#驼峰命名与数据库下划线命名转换mybatis.configuration.mapUnderscoreToCamelCase=true</code></pre><blockquote><p>Spring</p></blockquote><pre><code class="hljs yaml"><span class="hljs-comment"># ServerProperties</span><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span>  <span class="hljs-attr">servlet:</span>    <span class="hljs-attr">context-path:</span> <span class="hljs-string">/community</span><span class="hljs-comment"># ThymeleafProperties</span><span class="hljs-attr">spring:</span>  <span class="hljs-attr">thymeleaf:</span>    <span class="hljs-attr">cache:</span> <span class="hljs-literal">false</span>  <span class="hljs-comment"># DataSourceProperties</span>  <span class="hljs-attr">datasource:</span>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/community?characterEncoding=utf-8&amp;useSSL=false&amp;serverTimezone=Hongkong</span>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span>    <span class="hljs-attr">password:</span> <span class="hljs-string">password</span>    <span class="hljs-attr">type:</span> <span class="hljs-string">com.zaxxer.hikari.HikariDataSource</span>    <span class="hljs-attr">hikari:</span>      <span class="hljs-attr">maximum-pool-size:</span> <span class="hljs-number">15</span>      <span class="hljs-attr">minimum-idle:</span> <span class="hljs-number">5</span>      <span class="hljs-attr">idle-timeout:</span> <span class="hljs-number">30000</span></code></pre><p>默认使用 <strong>hikari连接池</strong></p><blockquote><p>maven</p></blockquote><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.junit.vintage<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit-vintage-engine<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.12<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-comment">&lt;!--&lt;scope&gt;test&lt;/scope&gt;--&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-devtools<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></code></pre><h1 id="首页展示模块"><a href="#首页展示模块" class="headerlink" title="首页展示模块"></a>首页展示模块</h1><h2 id="开发社区首页"><a href="#开发社区首页" class="headerlink" title="开发社区首页"></a>开发社区首页</h2><h3 id="开发流程概括"><a href="#开发流程概括" class="headerlink" title="开发流程概括"></a>开发流程概括</h3><ul><li><p>流程请求执行过程</p><ul><li><p>1次请求的执行过程</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201219155543.png" alt="请求过程"></p></li></ul></li><li><p>分步实现</p><ul><li>开发首页，显示前十个帖子</li><li>开发 <strong>分页</strong> 组件(手动实现)，分页显示所有帖子</li></ul></li></ul><p>基础配置已在系统分析给出，不再多概述。</p><blockquote><p>编写分页前，只显示十条数据</p></blockquote><ol><li><p>编写 <strong>实体类</strong></p><p>为什么要同时编写 User相关的，因为页面需要Username，headerUrl等信息，所以查询一并返回。</p><pre><code class="hljs java"><span class="hljs-meta">@Data</span><span class="hljs-meta">@AllArgsConstructor</span><span class="hljs-meta">@NoArgsConstructor</span><span class="hljs-comment">// 使用了lombok</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DiscussPost</span> </span>&#123;      <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> userId;    <span class="hljs-keyword">private</span> String title;    <span class="hljs-keyword">private</span> String content;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> type;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> status;    <span class="hljs-keyword">private</span> Date createTime;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> commentCount;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> score;&#125;<span class="hljs-meta">@Data</span><span class="hljs-meta">@AllArgsConstructor</span><span class="hljs-meta">@NoArgsConstructor</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;    <span class="hljs-keyword">private</span> String username;    <span class="hljs-keyword">private</span> String password;    <span class="hljs-keyword">private</span> String salt;    <span class="hljs-keyword">private</span> String email;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> type;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> status;    <span class="hljs-keyword">private</span> String activationCode;    <span class="hljs-keyword">private</span> String headerUrl;    <span class="hljs-keyword">private</span> Date createTime;&#125;</code></pre></li><li><p>描述接口Mapper</p><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">DiscussPostMapper</span> </span>&#123;    <span class="hljs-comment">// userId为&quot;我发布的帖子&quot;功能调用</span>    <span class="hljs-comment">// offset,limit为分页功能调用</span>    <span class="hljs-function">List&lt;DiscussPost&gt; <span class="hljs-title">selectDiscussPosts</span><span class="hljs-params">(<span class="hljs-keyword">int</span> userId, <span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">int</span> limit, <span class="hljs-keyword">int</span> orderMode)</span></span>;<span class="hljs-comment">// @Param注解用于给参数取别名</span>    <span class="hljs-comment">// 动态sql在&lt;if&gt;中使用,单一参数,一定要取别名,否则报错</span>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">selectDiscussPostRows</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;userId&quot;)</span> <span class="hljs-keyword">int</span> userId)</span></span>;&#125;<span class="hljs-meta">@Mapper</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserMapper</span> </span>&#123;    <span class="hljs-function">User <span class="hljs-title">selectById</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span></span>;&#125;</code></pre></li><li><p>写接口对应的Mapper文件</p><p>xml文件开头过于冗余，已忽略，请查略源代码文件</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- discussPost-mapper --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">sql</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectFields&quot;</span>&gt;</span>    id, user_id, title, content, type, status, create_time, comment_count, score<span class="hljs-tag">&lt;/<span class="hljs-name">sql</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectDiscussPosts&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;DiscussPost&quot;</span>&gt;</span>        select        <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">&quot;selectFields&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span>        from discuss_post        where status != 2        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;userId!=0&quot;</span>&gt;</span>            and user_id = #&#123;userId&#125;        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>        limit #&#123;offset&#125;,#&#123;limit&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectDiscussPostRows&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;int&quot;</span>&gt;</span>        select count(id)        from discuss_post        where status != 2        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;userId!=0&quot;</span>&gt;</span>            and user_id = #&#123;userId&#125;        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><span class="hljs-comment">&lt;!-- user-mapper --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">sql</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectFields&quot;</span>&gt;</span>        id, username, password, salt, email, type, status, activation_code, header_url, create_time<span class="hljs-tag">&lt;/<span class="hljs-name">sql</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectById&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;User&quot;</span>&gt;</span>        select <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">&quot;selectFields&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span>        from user        where id = #&#123;id&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre></li><li><p>写Service</p><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DiscussPostService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> DiscussPostMapper discussPostMapper;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;DiscussPost&gt; <span class="hljs-title">findDiscussPosts</span><span class="hljs-params">(<span class="hljs-keyword">int</span> userId, <span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">int</span> limit)</span> </span>&#123;        <span class="hljs-keyword">return</span> discussPostMapper.selectDiscussPosts(userId, offset, limit);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findDiscussPostRows</span><span class="hljs-params">(<span class="hljs-keyword">int</span> userId)</span> </span>&#123;        <span class="hljs-keyword">return</span> discussPostMapper.selectDiscussPostRows(userId);    &#125;&#125;<span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> UserMapper userMapper;    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">findUserById</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;        <span class="hljs-keyword">return</span> userMapper.selectById(id);    &#125;&#125;</code></pre></li><li><p>编写HomeController</p><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HomeController</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> DiscussPostService discussPostService;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> UserService userService;    <span class="hljs-meta">@RequestMapping(path = &quot;/index&quot;, method = RequestMethod.GET)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getIndexPage</span><span class="hljs-params">(Model model)</span> </span>&#123;        List&lt;DiscussPost&gt; list = discussPostService.findDiscussPosts(<span class="hljs-number">0</span>, page.getOffset(), page.getLimit());        List&lt;Map&lt;String, Object&gt;&gt; discussPosts = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">if</span> (list != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">for</span> (DiscussPost post : list) &#123;                Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();                map.put(<span class="hljs-string">&quot;post&quot;</span>, post);                User user = userService.findUserById(post.getUserId());                map.put(<span class="hljs-string">&quot;user&quot;</span>, user);                discussPosts.add(map);            &#125;        &#125;        model.addAttribute(<span class="hljs-string">&quot;discussPosts&quot;</span>, discussPosts);        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;/index&quot;</span>;    &#125;&#125;</code></pre></li><li><p>对index页进行 <strong>模版引擎修改</strong> </p><p>详细修改请查看源代码</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201219164449.png" alt="index修改"></p></li><li><p>总体流程归纳：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201219164943.png" alt="流程归纳"></p></li></ol><blockquote><p>编写分页</p></blockquote><ol><li><p>封装分页对象</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 封装分页相关信息</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Page</span> </span>&#123;    <span class="hljs-comment">// 当前页码(默认为1)</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> current = <span class="hljs-number">1</span>;    <span class="hljs-comment">// 显示上限(默认为10)</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> limit = <span class="hljs-number">10</span>;    <span class="hljs-comment">// 数据总数,用于计算总的页数</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> rows;    <span class="hljs-comment">// 查询路径,用于复用分页链接</span>    <span class="hljs-keyword">private</span> String path;&#125;</code></pre><p>分页里面的set和get方法有 <strong>技巧</strong>，有许多判断和默认值，不使用lombok，详细代码请看源码。</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201219165225.png" alt="分页对象信息"></p></li><li><p>修改HomeController</p><p>修改后的controller：</p><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(path = &quot;/index&quot;, method = RequestMethod.GET)</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getIndexPage</span><span class="hljs-params">(Model model, Page page)</span> </span>&#123;    <span class="hljs-comment">// 方法调用前,SpringMVC会自动实例化Model和Page,并将Page注入Model.</span>    <span class="hljs-comment">// 所以,在thymeleaf中可以直接访问Page对象中的数据.</span>    page.setRows(discussPostService.findDiscussPostRows(<span class="hljs-number">0</span>));    page.setPath(<span class="hljs-string">&quot;/index&quot;</span>);    List&lt;DiscussPost&gt; list = discussPostService.findDiscussPosts(<span class="hljs-number">0</span>, page.getOffset(), page.getLimit());    List&lt;Map&lt;String, Object&gt;&gt; discussPosts = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">if</span> (list != <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">for</span> (DiscussPost post : list) &#123;            Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();            map.put(<span class="hljs-string">&quot;post&quot;</span>, post);            User user = userService.findUserById(post.getUserId());            map.put(<span class="hljs-string">&quot;user&quot;</span>, user);            discussPosts.add(map);        &#125;    &#125;    model.addAttribute(<span class="hljs-string">&quot;discussPosts&quot;</span>, discussPosts);    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;/index&quot;</span>;&#125;</code></pre></li><li><p>修改模版引擎分页系统(可复用)</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201219165634.png" alt="模版引擎处理"></p></li><li><p>分页总体流程归纳</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201219170954.png" alt="流程图"></p></li></ol><h2 id="日志分级输出"><a href="#日志分级输出" class="headerlink" title="日志分级输出"></a>日志分级输出</h2><p>详细请参考resources目录下的logback-spring.xml文件</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201219171414.png" alt="日志"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201219171501.png" alt="日志分级"></p><h2 id="发送邮件功能-非aliyun实现"><a href="#发送邮件功能-非aliyun实现" class="headerlink" title="发送邮件功能 (非aliyun实现)"></a>发送邮件功能 (非aliyun实现)</h2><ul><li>邮件设置<ul><li>启用客户端SMTP服务</li></ul></li><li>Spring Email<ul><li>导入jar包</li><li>邮箱参数配置</li><li>使用 <strong>JavaMailSender</strong> 发送邮件</li></ul></li><li>模版引擎<ul><li>使用 <strong>Thymeleaf</strong> 发送 <strong>HTML</strong> 邮件</li></ul></li></ul><h3 id="开发流程概括-1"><a href="#开发流程概括-1" class="headerlink" title="开发流程概括"></a>开发流程概括</h3><ol><li><p>确保邮箱服务开启</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201219172636.png" alt="邮箱服务"></p></li><li><p>Maven导入</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-mail<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.6.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></li><li><p>配置文件</p><pre><code class="hljs yaml"><span class="hljs-comment">#MailProperties</span><span class="hljs-attr">mail:</span>  <span class="hljs-attr">host:</span> <span class="hljs-string">smtp.163.com</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">465</span>  <span class="hljs-attr">username:</span> <span class="hljs-string">username</span>  <span class="hljs-attr">password:</span> <span class="hljs-string">pwd</span>  <span class="hljs-attr">protocol:</span> <span class="hljs-string">smtps</span>  <span class="hljs-attr">properties:</span>    <span class="hljs-attr">smtp:</span>      <span class="hljs-attr">ssl:</span>        <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span></code></pre></li><li><p>编写MailClient的工具类</p><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MailClient</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger logger = LoggerFactory.getLogger(MailClient.class);    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> JavaMailSender mailSender;    <span class="hljs-meta">@Value(&quot;$&#123;spring.mail.username&#125;&quot;)</span>    <span class="hljs-keyword">private</span> String mailFrom;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendMail</span><span class="hljs-params">(String mailTo, String title, String content)</span></span>&#123;        <span class="hljs-keyword">try</span> &#123;            MimeMessage mimeMessage = mailSender.createMimeMessage();            MimeMessageHelper helper = <span class="hljs-keyword">new</span> MimeMessageHelper(mimeMessage);            helper.setFrom(mailFrom);            helper.setTo(mailTo);            helper.setSubject(title);            helper.setText(content,<span class="hljs-keyword">true</span>);            mailSender.send(helper.getMimeMessage());        &#125; <span class="hljs-keyword">catch</span> (MessagingException e) &#123;            logger.error(<span class="hljs-string">&quot;邮件发送失败：&quot;</span>+e.getMessage());        &#125;    &#125;&#125;</code></pre></li><li><p>测试 (省略，请查看test包下的MailTest)</p></li></ol><h2 id="开放注册功能"><a href="#开放注册功能" class="headerlink" title="开放注册功能"></a>开放注册功能</h2><ul><li>访问注册页面<ul><li>点击顶部区域内的链接，打开注册页面</li></ul></li><li>提交注册数据<ul><li>通过表单提交数据</li><li>服务端验证账号是否已存在、邮箱是否已注册。</li><li>服务端发送激活邮件。</li></ul></li><li>激活注册账号<ul><li>点击邮件中的链接，访问服务端的激活服务。</li></ul></li></ul><h3 id="开发流程概括-2"><a href="#开发流程概括-2" class="headerlink" title="开发流程概括"></a>开发流程概括</h3><ol><li><p>跳转注册页面</p><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginController</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CommunityConstant</span> </span>&#123;      <span class="hljs-meta">@RequestMapping(path = &quot;/register&quot;,method = RequestMethod.GET)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getRegisterPage</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;site/register&quot;</span>;    &#125;&#125;</code></pre></li><li><p>修改主页模版引擎</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;nav-item ml-3 btn-group-vertical&quot;</span> <span class="hljs-attr">th:if</span>=<span class="hljs-string">&quot;$&#123;loginUser==null&#125;&quot;</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;nav-link&quot;</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">&quot;@&#123;/register&#125;&quot;</span>&gt;</span>注册<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></code></pre></li><li><p>配置激活邮箱发送时附带的激活链接和Commonslang包</p><pre><code class="hljs yaml"><span class="hljs-comment"># community</span><span class="hljs-attr">community:</span>  <span class="hljs-attr">path:</span>    <span class="hljs-attr">domain:</span> <span class="hljs-string">http://localhost:8080</span>    <span class="hljs-attr">upload:</span> <span class="hljs-string">/Users/qiuke/Desktop/nowcoder_source/work/picture</span></code></pre><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--    空值比较    --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.commons<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-lang3<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></li><li><p>编写MD5、UUID工具类</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CommunityUtil</span> </span>&#123;    <span class="hljs-comment">// 生成随机字符串</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">generateUUID</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> UUID.randomUUID().toString().replaceAll(<span class="hljs-string">&quot;-&quot;</span>,<span class="hljs-string">&quot;&quot;</span>);    &#125;    <span class="hljs-comment">// md5加密 key为pwd+salt</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">md5</span><span class="hljs-params">(String key)</span></span>&#123;        <span class="hljs-keyword">if</span> (StringUtils.isBlank(key))&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-keyword">return</span> DigestUtils.md5DigestAsHex(key.getBytes());    &#125;&#125;</code></pre></li><li><p>编写UserService</p><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><span class="hljs-keyword">private</span> MailClient mailClient;<span class="hljs-meta">@Autowired</span><span class="hljs-keyword">private</span> TemplateEngine templateEngine;<span class="hljs-meta">@Value(&quot;$&#123;community.path.domain&#125;&quot;)</span><span class="hljs-keyword">private</span> String domain;<span class="hljs-meta">@Value(&quot;$&#123;server.servlet.context-path&#125;&quot;)</span><span class="hljs-keyword">private</span> String contextPath;<span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String, Object&gt; <span class="hljs-title">register</span><span class="hljs-params">(User user)</span></span>&#123;        Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        <span class="hljs-comment">// 空值处理</span>        <span class="hljs-keyword">if</span> (user == <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;User参数不能为空&quot;</span>);        &#125;        <span class="hljs-keyword">if</span> (StringUtils.isBlank(user.getUsername()))&#123;            map.put(<span class="hljs-string">&quot;usernameMsg&quot;</span>,<span class="hljs-string">&quot;账号不能为空&quot;</span>);            <span class="hljs-keyword">return</span> map;        &#125;        <span class="hljs-keyword">if</span> (StringUtils.isBlank(user.getPassword()))&#123;            map.put(<span class="hljs-string">&quot;passwordMsg&quot;</span>,<span class="hljs-string">&quot;密码不能为空&quot;</span>);            <span class="hljs-keyword">return</span> map;        &#125;        <span class="hljs-keyword">if</span> (StringUtils.isBlank(user.getEmail()))&#123;            map.put(<span class="hljs-string">&quot;emailMsg&quot;</span>,<span class="hljs-string">&quot;邮箱不能为空&quot;</span>);            <span class="hljs-keyword">return</span> map;        &#125;        User u = userMapper.selectByName(user.getUsername());        <span class="hljs-keyword">if</span> (u != <span class="hljs-keyword">null</span>)&#123;            map.put(<span class="hljs-string">&quot;usernameMsg&quot;</span>,<span class="hljs-string">&quot;该账号已存在&quot;</span>);            <span class="hljs-keyword">return</span> map;        &#125;        u = userMapper.selectByEmail(user.getEmail());        <span class="hljs-keyword">if</span> (u != <span class="hljs-keyword">null</span>)&#123;            map.put(<span class="hljs-string">&quot;emailMsg&quot;</span>,<span class="hljs-string">&quot;该邮箱已存在&quot;</span>);            <span class="hljs-keyword">return</span> map;        &#125;        <span class="hljs-comment">// 注册用户</span>        user.setSalt(CommunityUtil.generateUUID().substring(<span class="hljs-number">0</span>,<span class="hljs-number">6</span>));        user.setPassword(CommunityUtil.md5(user.getPassword()+user.getSalt()));        user.setType(<span class="hljs-number">0</span>); <span class="hljs-comment">// 普通用户</span>        user.setStatus(<span class="hljs-number">0</span>); <span class="hljs-comment">// 未激活</span>        user.setActivationCode(CommunityUtil.generateUUID()); <span class="hljs-comment">// 邮箱激活码</span>        user.setHeaderUrl(String.format(<span class="hljs-string">&quot;http://images.nowcoder.com/head/%dt.png&quot;</span>, <span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">1000</span>))); <span class="hljs-comment">// 牛客网的随机头像</span>        user.setCreateTime(<span class="hljs-keyword">new</span> Date());        userMapper.insertUser(user);        <span class="hljs-comment">// 激活邮件</span>        Context context = <span class="hljs-keyword">new</span> Context();        context.setVariable(<span class="hljs-string">&quot;email&quot;</span>, user.getEmail());        <span class="hljs-comment">// 请求格式为：http://localhost:8080/community/activation/id/code</span>        <span class="hljs-comment">// 设置了mybatis.configuration.useGeneratedKeys=true,user主键id会自动赋值自增</span>        String url = domain + contextPath + <span class="hljs-string">&quot;/activation/&quot;</span>  + user.getId() + <span class="hljs-string">&quot;/&quot;</span> + user.getActivationCode();        context.setVariable(<span class="hljs-string">&quot;url&quot;</span>, url);        <span class="hljs-comment">// /mail/activation为HTML格式的邮件所在路径</span>        String process = templateEngine.process(<span class="hljs-string">&quot;/mail/activation&quot;</span>, context);        mailClient.sendMail(user.getEmail(), <span class="hljs-string">&quot;激活邮件&quot;</span>, process);        <span class="hljs-keyword">return</span> map;&#125;</code></pre></li><li><p>修改模版引擎</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201219175018.png" alt="模版引擎"></p></li><li><p>写LoginController</p><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(path = &quot;/register&quot;,method = RequestMethod.POST)</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">register</span><span class="hljs-params">(Model model, User user)</span></span>&#123;    Map&lt;String, Object&gt; map = userService.register(user);    <span class="hljs-keyword">if</span> (map == <span class="hljs-keyword">null</span> || map.isEmpty())&#123;        model.addAttribute(<span class="hljs-string">&quot;msg&quot;</span>, <span class="hljs-string">&quot;注册成功,我们已经向您的邮箱发送了一封激活邮件,请尽快激活！&quot;</span>);        <span class="hljs-comment">// 点击跳转回首页</span>        model.addAttribute(<span class="hljs-string">&quot;target&quot;</span>,<span class="hljs-string">&quot;/index&quot;</span>);        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;site/operate-result&quot;</span>;    &#125; <span class="hljs-keyword">else</span> &#123;        model.addAttribute(<span class="hljs-string">&quot;usernameMsg&quot;</span>, map.get(<span class="hljs-string">&quot;usernameMsg&quot;</span>));        model.addAttribute(<span class="hljs-string">&quot;passwordMsg&quot;</span>, map.get(<span class="hljs-string">&quot;passwordMsg&quot;</span>));        model.addAttribute(<span class="hljs-string">&quot;emailMsg&quot;</span>, map.get(<span class="hljs-string">&quot;emailMsg&quot;</span>));        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;site/register&quot;</span>;    &#125;&#125;</code></pre></li><li><p>修改operate-result模版引擎</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201219175509.png" alt="模版引擎"></p></li><li><p>修改register模版引擎(省略，请查看源代码)</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201219175654.png" alt="模版引擎"></p></li><li><p>编写常量接口</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CommunityConstant</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 激活成功</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">int</span> ACTIVATION_SUCCESS = <span class="hljs-number">1</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 激活失败</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">int</span> ACTIVATION_FAILURE = -<span class="hljs-number">1</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 重复激活</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">int</span> ACTIVATION_REPEAT = <span class="hljs-number">0</span>;&#125;</code></pre></li><li><p>编写activation 激活函数</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">activation</span><span class="hljs-params">(<span class="hljs-keyword">int</span> userId, String code)</span></span>&#123;    User user = userMapper.selectById(userId);    <span class="hljs-keyword">if</span> (user.getStatus() == <span class="hljs-number">1</span>)&#123;        <span class="hljs-keyword">return</span> ACTIVATION_REPEAT;    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (user.getActivationCode().equals(code))&#123;        userMapper.updateStatus(userId,<span class="hljs-number">1</span>);        clearCache(userId);        <span class="hljs-keyword">return</span> ACTIVATION_SUCCESS;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">return</span> ACTIVATION_FAILURE;    &#125;&#125;</code></pre></li><li><p>编写LoginController</p><pre><code class="hljs java"><span class="hljs-comment">// http://localhost:8080/community/activation/id/code</span><span class="hljs-meta">@RequestMapping(path = &quot;/activation/&#123;userId&#125;/&#123;code&#125;&quot;, method = RequestMethod.GET)</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">activation</span><span class="hljs-params">(Model model, <span class="hljs-meta">@PathVariable(&quot;userId&quot;)</span> <span class="hljs-keyword">int</span> userId, <span class="hljs-meta">@PathVariable(&quot;code&quot;)</span> String code)</span></span>&#123;    <span class="hljs-keyword">int</span> activation_code = userService.activation(userId, code);    <span class="hljs-keyword">if</span> (activation_code == ACTIVATION_SUCCESS)&#123;        model.addAttribute(<span class="hljs-string">&quot;msg&quot;</span>, <span class="hljs-string">&quot;激活成功,您的账号已经可以正常使用了！&quot;</span>);        <span class="hljs-comment">// 点击跳转回首页</span>        model.addAttribute(<span class="hljs-string">&quot;target&quot;</span>,<span class="hljs-string">&quot;/login&quot;</span>);    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (activation_code == ACTIVATION_REPEAT)&#123;        model.addAttribute(<span class="hljs-string">&quot;msg&quot;</span>, <span class="hljs-string">&quot;激活无效,您的账号已经激活过了！&quot;</span>);        <span class="hljs-comment">// 点击跳转回首页</span>        model.addAttribute(<span class="hljs-string">&quot;target&quot;</span>,<span class="hljs-string">&quot;/index&quot;</span>);    &#125;<span class="hljs-keyword">else</span> &#123;        model.addAttribute(<span class="hljs-string">&quot;msg&quot;</span>, <span class="hljs-string">&quot;激活失败,您提供的激活码不正确&quot;</span>);        <span class="hljs-comment">// 点击跳转回首页</span>        model.addAttribute(<span class="hljs-string">&quot;target&quot;</span>,<span class="hljs-string">&quot;/index&quot;</span>);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;site/operate-result&quot;</span>;&#125;    <span class="hljs-meta">@RequestMapping(path = &quot;/login&quot;,method = RequestMethod.GET)</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getLoginPage</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;site/login&quot;</span>;&#125;</code></pre></li><li><p>修改index可以点击注册</p></li></ol><h3 id="流程概括图"><a href="#流程概括图" class="headerlink" title="流程概括图"></a>流程概括图</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201219181942.png" alt="注册流程"></p><h2 id="生成验证码功能"><a href="#生成验证码功能" class="headerlink" title="生成验证码功能"></a>生成验证码功能</h2><blockquote><p>先存session后，后续redis更改项目时，存入redis</p></blockquote><ul><li><p>Kaptcha</p><ul><li>导入jar包</li><li>编写Kaptcha配置类</li><li>生成随机字符、生成图片</li></ul></li><li><p>kaptcha手册 <a href="https//code.google.com/archive/p/kaptcha">手册</a></p></li></ul><h3 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h3><ol><li><p>Maven导入</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--    验证码工具    --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.penggle<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>kaptcha<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></li><li><p>编写Kaptcha配置类</p><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">KaptchaConfig</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Producer <span class="hljs-title">kaptchaProducer</span><span class="hljs-params">()</span></span>&#123;        Properties properties = <span class="hljs-keyword">new</span> Properties();        properties.setProperty(<span class="hljs-string">&quot;kaptcha.image.width&quot;</span>, <span class="hljs-string">&quot;100&quot;</span>);        properties.setProperty(<span class="hljs-string">&quot;kaptcha.image.height&quot;</span>, <span class="hljs-string">&quot;40&quot;</span>);        properties.setProperty(<span class="hljs-string">&quot;kaptcha.textproducer.font.size&quot;</span>, <span class="hljs-string">&quot;32&quot;</span>);        properties.setProperty(<span class="hljs-string">&quot;kaptcha.textproducer.font.color&quot;</span>, <span class="hljs-string">&quot;0,0,0&quot;</span>);        properties.setProperty(<span class="hljs-string">&quot;kaptcha.textproducer.char.string&quot;</span>, <span class="hljs-string">&quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span>);        properties.setProperty(<span class="hljs-string">&quot;kaptcha.textproducer.char.length&quot;</span>, <span class="hljs-string">&quot;4&quot;</span>);        properties.setProperty(<span class="hljs-string">&quot;kaptcha.textproducer.noise.impl&quot;</span>, <span class="hljs-string">&quot;com.google.code.kaptcha.impl.NoNoise&quot;</span>);        <span class="hljs-comment">// 建议另建properties</span>        DefaultKaptcha kaptcha = <span class="hljs-keyword">new</span> DefaultKaptcha();        Config config = <span class="hljs-keyword">new</span> Config(properties);        kaptcha.setConfig(config);        <span class="hljs-keyword">return</span> kaptcha;    &#125;&#125;</code></pre></li><li><p>编写LoginController</p><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(path = &quot;/kaptcha&quot;,method = RequestMethod.GET)</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getKaptcha</span><span class="hljs-params">(HttpServletResponse response, HttpSession session)</span></span>&#123;    <span class="hljs-comment">// 生成验证码</span>    String text = kaptchProducer.createText();    BufferedImage image = kaptchProducer.createImage(text);    <span class="hljs-comment">// 验证码文字存入session</span>    session.setAttribute(<span class="hljs-string">&quot;kaptcha&quot;</span>,text);    <span class="hljs-comment">// 将图片输出给浏览器</span>    response.setContentType(<span class="hljs-string">&quot;image/png&quot;</span>);    <span class="hljs-keyword">try</span> &#123;        OutputStream os = response.getOutputStream();        ImageIO.write(image, <span class="hljs-string">&quot;png&quot;</span>, os);    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;        logger.error(<span class="hljs-string">&quot;验证码响应失败：&quot;</span> + e.getMessage());    &#125;&#125;</code></pre></li><li><p>修改login页面模版引擎路径</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201219183214.png" alt="模版引擎"></p><pre><code class="hljs js">&lt;script&gt;   <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">refresh_kaptcha</span>(<span class="hljs-params"></span>) </span>&#123;      <span class="hljs-keyword">var</span> path = CONTEXT_PATH + <span class="hljs-string">&quot;/kaptcha?p=&quot;</span> + <span class="hljs-built_in">Math</span>.random();      $(<span class="hljs-string">&quot;#kaptcha&quot;</span>).attr(<span class="hljs-string">&quot;src&quot;</span>, path);   &#125;&lt;/script&gt;</code></pre></li></ol><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201219183831.png" alt="流程图"></p><h3 id="登录开发流程"><a href="#登录开发流程" class="headerlink" title="登录开发流程"></a>登录开发流程</h3><ol><li><p>生成loginTicket实体类并编写Mapper</p><pre><code class="hljs java"><span class="hljs-meta">@Data</span><span class="hljs-meta">@AllArgsConstructor</span><span class="hljs-meta">@NoArgsConstructor</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginTicket</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> userId;    <span class="hljs-keyword">private</span> String ticket;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> status;    <span class="hljs-keyword">private</span> Date expired;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">LoginTicketMapper</span> </span>&#123;    <span class="hljs-meta">@Insert(&#123;</span><span class="hljs-meta">            &quot;insert into login_ticket(user_id,ticket,status,expired) &quot;,</span><span class="hljs-meta">            &quot;values(#&#123;userId&#125;,#&#123;ticket&#125;,#&#123;status&#125;,#&#123;expired&#125;)&quot;</span><span class="hljs-meta">    &#125;)</span>    <span class="hljs-meta">@Options(useGeneratedKeys = true,keyProperty = &quot;id&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">insertLoginTicket</span><span class="hljs-params">(LoginTicket loginTicket)</span></span>;    <span class="hljs-meta">@Select(&#123;</span><span class="hljs-meta">            &quot;select id,user_id,ticket,status,expired &quot;,</span><span class="hljs-meta">            &quot;from login_ticket &quot;,</span><span class="hljs-meta">            &quot;where ticket = #&#123;ticket&#125;&quot;</span><span class="hljs-meta">    &#125;)</span>    <span class="hljs-function">LoginTicket <span class="hljs-title">selectByTicket</span><span class="hljs-params">(String ticket)</span></span>;    <span class="hljs-meta">@Update(&#123;</span><span class="hljs-meta">            &quot;update login_ticket set status = #&#123;status&#125; &quot;,</span><span class="hljs-meta">            &quot;where ticket = #&#123;ticket&#125;&quot;</span><span class="hljs-meta">    &#125;)</span>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">updateStatus</span><span class="hljs-params">(String ticket, <span class="hljs-keyword">int</span> status)</span></span>;&#125;</code></pre></li><li><p>编写UserService的login方法，一个实现跳转，一个实现登录业务</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String, Object&gt; <span class="hljs-title">login</span><span class="hljs-params">(String username, String password, <span class="hljs-keyword">int</span> expiredSeconds)</span></span>&#123;     Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        <span class="hljs-comment">// 空值处理</span>     <span class="hljs-keyword">if</span> (StringUtils.isBlank(username))&#123;         map.put(<span class="hljs-string">&quot;usernameMsg&quot;</span>,<span class="hljs-string">&quot;账号不能为空！&quot;</span>);         <span class="hljs-keyword">return</span> map;     &#125;     <span class="hljs-keyword">if</span> (StringUtils.isBlank(password))&#123;         map.put(<span class="hljs-string">&quot;passwordMsg&quot;</span>,<span class="hljs-string">&quot;密码不能为空！&quot;</span>);         <span class="hljs-keyword">return</span> map;     &#125;        <span class="hljs-comment">// 查询 激活处理</span>     User user = userMapper.selectByName(username);     <span class="hljs-keyword">if</span> (user == <span class="hljs-keyword">null</span>)&#123;         map.put(<span class="hljs-string">&quot;usernameMsg&quot;</span>,<span class="hljs-string">&quot;账号不存在！&quot;</span>);         <span class="hljs-keyword">return</span> map;     &#125;     <span class="hljs-keyword">if</span> (user.getStatus() == <span class="hljs-number">0</span>)&#123;         map.put(<span class="hljs-string">&quot;usernameMsg&quot;</span>,<span class="hljs-string">&quot;账号未激活！&quot;</span>);         <span class="hljs-keyword">return</span> map;     &#125;        <span class="hljs-comment">// 验证密码</span>     password = CommunityUtil.md5(password + user.getSalt());     <span class="hljs-keyword">if</span> (!user.getPassword().equals(password))&#123;         map.put(<span class="hljs-string">&quot;passwordMsg&quot;</span>,<span class="hljs-string">&quot;密码不正确！&quot;</span>);         <span class="hljs-keyword">return</span> map;     &#125;        <span class="hljs-comment">// 登陆成功 生成登陆凭证</span>     LoginTicket loginTicket = <span class="hljs-keyword">new</span> LoginTicket();     loginTicket.setUserId(user.getId());     loginTicket.setTicket(CommunityUtil.generateUUID());     loginTicket.setStatus(<span class="hljs-number">0</span>);     loginTicket.setExpired(<span class="hljs-keyword">new</span> Date(System.currentTimeMillis() + <span class="hljs-number">1000</span> * expiredSeconds));     loginTicketMapper.insertLoginTicket(loginTicket);      <span class="hljs-comment">// 浏览器只需要记录key</span>      <span class="hljs-comment">// TODO redis</span>     map.put(<span class="hljs-string">&quot;ticket&quot;</span>, loginTicket.getTicket());        <span class="hljs-keyword">return</span> map; &#125;</code></pre></li><li><p>编写LoginController</p><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(path = &quot;/login&quot;,method = RequestMethod.GET)</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getLoginPage</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;site/login&quot;</span>;&#125;<span class="hljs-meta">@RequestMapping(path = &quot;/login&quot;,method = RequestMethod.POST)</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">login</span><span class="hljs-params">(String username, String password, String code, Boolean rememberme,</span></span><span class="hljs-function"><span class="hljs-params">                    Model model, HttpServletResponse response, <span class="hljs-meta">@CookieValue(&quot;kaptchaOwner&quot;)</span>String kaptchaOwner)</span></span>&#123;    <span class="hljs-comment">// 最先判断验证码</span>    String kaptcha = (String) session.getAttribute(<span class="hljs-string">&quot;kaptcha&quot;</span>);      <span class="hljs-keyword">if</span> (StringUtils.isBlank(kaptcha)            || StringUtils.isBlank(code)            || !kaptcha.equalsIgnoreCase(code))&#123;        model.addAttribute(<span class="hljs-string">&quot;codeMsg&quot;</span>, <span class="hljs-string">&quot;验证码不正确&quot;</span>);        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;site/login&quot;</span>;    &#125;    <span class="hljs-comment">// 前端一直拿不到rememberme为false,便加入这行代码自动false,但能拿到true</span>    <span class="hljs-keyword">if</span> (rememberme == <span class="hljs-keyword">null</span>)&#123;        rememberme = <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-comment">// 检查账号密码</span>    <span class="hljs-keyword">int</span> expiredSeconds = rememberme ? REMEMBER_EXPIRED_SECONDS : DEFAULT_EXPIRED_SECONDS;    Map&lt;String, Object&gt; map = userService.login(username, password, expiredSeconds);    <span class="hljs-keyword">if</span> (map.containsKey(<span class="hljs-string">&quot;ticket&quot;</span>))&#123;        Cookie cookie =  <span class="hljs-keyword">new</span> Cookie(<span class="hljs-string">&quot;ticket&quot;</span>, map.get(<span class="hljs-string">&quot;ticket&quot;</span>).toString());        <span class="hljs-comment">// application.yaml中有</span>        cookie.setPath(contextPath);        cookie.setMaxAge(expiredSeconds);        response.addCookie(cookie);        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;redirect:/index&quot;</span>;    &#125;<span class="hljs-keyword">else</span> &#123;        model.addAttribute(<span class="hljs-string">&quot;usernameMsg&quot;</span>, map.get(<span class="hljs-string">&quot;usernameMsg&quot;</span>));        model.addAttribute(<span class="hljs-string">&quot;passwordMsg&quot;</span>, map.get(<span class="hljs-string">&quot;passwordMsg&quot;</span>));        model.addAttribute(<span class="hljs-string">&quot;emailMsg&quot;</span>, map.get(<span class="hljs-string">&quot;emailMsg&quot;</span>));        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;site/login&quot;</span>;    &#125;&#125;</code></pre></li></ol><p>​     期间对应的工具类常量接口数值为：</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 默认状态登录凭证的超时时间</span><span class="hljs-comment"> */</span><span class="hljs-keyword">int</span> DEFAULT_EXPIRED_SECONDS = <span class="hljs-number">3600</span> * <span class="hljs-number">12</span>;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 记住状态登录凭证的超时时间</span><span class="hljs-comment"> */</span><span class="hljs-keyword">int</span> REMEMBER_EXPIRED_SECONDS = <span class="hljs-number">3600</span> * <span class="hljs-number">24</span> * <span class="hljs-number">14</span>;</code></pre><ol start="4"><li><p>修改模版引擎</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201221151740.png" alt="模版引擎"></p><p>代码修改请见源码。</p></li><li><p>编写UserService logout功能</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">logout</span><span class="hljs-params">(String ticket)</span></span>&#123;    loginTicketMapper.updateStatus(ticket,<span class="hljs-number">1</span>);&#125;</code></pre></li><li><p>编写的LoginController logout请求</p><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(path = &quot;/logout&quot;,method = RequestMethod.GET)</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">logout</span><span class="hljs-params">(<span class="hljs-meta">@CookieValue(&quot;ticket&quot;)</span> String ticket)</span></span>&#123;    userService.logout(ticket);    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;redirect:/login&quot;</span>;&#125;</code></pre></li><li><p>修改模版引擎导航栏请求</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201221152201.png" alt="模版引擎"></p></li></ol><blockquote><p>业务流程图</p></blockquote><p>   <img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201221154233.png" alt="登录流程"></p><p>   <img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201221154357.png" alt="退出功能"></p><h2 id="显示登录信息"><a href="#显示登录信息" class="headerlink" title="显示登录信息"></a>显示登录信息</h2><ul><li><p>拦截器</p><ul><li>在请求开始时查询登录用户</li><li>在本次请求中持有用户数据</li><li>在模版视图上显示用户数据</li><li>在请求结束时清理用户数据</li></ul></li></ul><ol><li><p>原理图</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201221155649.png" alt="原理图"></p></li><li><p>编写HostHolder持有用户信息</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 容器作用,持有用户信息,用于代替session对象,线程隔离</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HostHolder</span> </span>&#123;    <span class="hljs-keyword">private</span> ThreadLocal&lt;User&gt; users = <span class="hljs-keyword">new</span> ThreadLocal&lt;&gt;();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUsers</span><span class="hljs-params">(User user)</span></span>&#123;        users.set(user);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">getUsers</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> users.get();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span></span>&#123;        users.remove();    &#125;&#125;</code></pre></li><li><p>编写登录拦截器(实现CookieUtil)</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CookieUtil</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getValue</span><span class="hljs-params">(HttpServletRequest request, String name)</span></span>&#123;        <span class="hljs-keyword">if</span> (request == <span class="hljs-keyword">null</span> || name == <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;参数为空！&quot;</span>);        &#125;        Cookie[] cookies = request.getCookies();        <span class="hljs-keyword">if</span> (cookies != <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">for</span> (Cookie cookie : cookies) &#123;                <span class="hljs-keyword">if</span> (cookie.getName().equals(name))&#123;                    <span class="hljs-keyword">return</span> cookie.getValue();                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginTicketInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HandlerInterceptor</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    UserService userService;    <span class="hljs-meta">@Autowired</span>    HostHolder hostHolder;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">// 从cookie中获取ticket</span>        String ticket = CookieUtil.getValue(request, <span class="hljs-string">&quot;ticket&quot;</span>);        <span class="hljs-keyword">if</span> (ticket != <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-comment">// 查询</span>            LoginTicket loginTicket = userService.findLoginTicket(ticket);            <span class="hljs-comment">// 检测有效</span>            <span class="hljs-keyword">if</span> (loginTicket != <span class="hljs-keyword">null</span> &amp;&amp; loginTicket.getStatus() == <span class="hljs-number">0</span> &amp;&amp; loginTicket.getExpired().after(<span class="hljs-keyword">new</span> Date()))&#123;                <span class="hljs-comment">// 根据凭证找到用户</span>                User user = userService.findUserById(loginTicket.getUserId());                <span class="hljs-comment">// 在本次请求中持有用户</span>                hostHolder.setUsers(user);                <span class="hljs-comment">// 构建用户认证结果 存入SecurityContext 以便与security进行授权(越过了security认证 用了自己的认证 需要自己授权)</span>            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        User user = hostHolder.getUsers();        <span class="hljs-keyword">if</span> (user != <span class="hljs-keyword">null</span> &amp;&amp; modelAndView != <span class="hljs-keyword">null</span>)&#123;            modelAndView.addObject(<span class="hljs-string">&quot;loginUser&quot;</span>,user);        &#125;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterCompletion</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        hostHolder.clear();        SecurityContextHolder.clearContext();    &#125;&#125;</code></pre><p>modelAndView.addObject(“loginUser”,user) </p><p>这样user就会被模版引擎拿到</p></li><li><p>注入到WebMvcConfig</p><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebMvcConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> LoginTicketInterceptor loginTicketInterceptor;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> </span>&#123;        registry.addInterceptor(loginTicketInterceptor)                .excludePathPatterns(<span class="hljs-string">&quot;/**/*.css&quot;</span>, <span class="hljs-string">&quot;/**/*.js&quot;</span>, <span class="hljs-string">&quot;/**/*.png&quot;</span>, <span class="hljs-string">&quot;/**/*.jpg&quot;</span>, <span class="hljs-string">&quot;/**/*.jpeg&quot;</span>);    &#125;&#125;</code></pre></li><li><p>更改模版引擎</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201221160610.png" alt="模版引擎"></p></li></ol><h2 id="账号设置"><a href="#账号设置" class="headerlink" title="账号设置"></a>账号设置</h2><h3 id="上传文件-头像"><a href="#上传文件-头像" class="headerlink" title="上传文件(头像)"></a>上传文件(头像)</h3><blockquote><p>七牛云上传在后续，先实现本地存储</p></blockquote><ul><li>请求POST</li><li>表单：enctype = “multipart/form-data”</li><li>Spring MVC : 通过MultipartFile处理上传文件<ul><li>访问账号设置页面</li><li>上传头像</li><li>获取头像</li></ul></li></ul><h3 id="上传文件开发流程"><a href="#上传文件开发流程" class="headerlink" title="上传文件开发流程"></a>上传文件开发流程</h3><ol><li><p>设置跳转请求并配置模版引擎</p><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(path = &quot;/setting&quot;, method = RequestMethod.GET)</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getSettingPage</span><span class="hljs-params">(Model model)</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;site/setting&quot;</span>;&#125;</code></pre></li><li><p>yaml文件设置访问路径</p><pre><code class="hljs yaml"><span class="hljs-comment"># community</span><span class="hljs-attr">community:</span>  <span class="hljs-attr">path:</span>    <span class="hljs-attr">domain:</span> <span class="hljs-string">http://localhost:8080</span>    <span class="hljs-attr">upload:</span> <span class="hljs-string">路径</span></code></pre></li><li><p>编写UserService更新头像并编写mapper(省略)</p><pre><code class="hljs java">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">updateHeadUrl</span><span class="hljs-params">(<span class="hljs-keyword">int</span> userId, String headerUrl)</span></span>&#123;<span class="hljs-comment">//        return userMapper.updateHeader(userId, headerUrl);</span>        <span class="hljs-keyword">int</span> rows = userMapper.updateHeader(userId, headerUrl);        <span class="hljs-keyword">return</span> rows;    &#125;</code></pre></li><li><p>编写UserController中upload方法</p><pre><code class="hljs java"><span class="hljs-meta">@Value(&quot;$&#123;community.path.upload&#125;&quot;)</span><span class="hljs-keyword">private</span> String uploadPath;<span class="hljs-meta">@RequestMapping(path = &quot;/upload&quot;, method = RequestMethod.POST)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">uploadHeader</span><span class="hljs-params">(MultipartFile headerImage, Model model)</span> </span>&#123;        <span class="hljs-keyword">if</span> (headerImage == <span class="hljs-keyword">null</span>) &#123;            model.addAttribute(<span class="hljs-string">&quot;error&quot;</span>, <span class="hljs-string">&quot;文件还未上传！&quot;</span>);            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;site/setting&quot;</span>;        &#125;        <span class="hljs-comment">// 获取后缀</span>        String fileName = headerImage.getOriginalFilename();        String suffix = fileName.substring(fileName.lastIndexOf(<span class="hljs-string">&quot;.&quot;</span>));        <span class="hljs-keyword">if</span> (StringUtils.isBlank(suffix)) &#123;            model.addAttribute(<span class="hljs-string">&quot;error&quot;</span>, <span class="hljs-string">&quot;文件格式不正确！&quot;</span>);            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;site/setting&quot;</span>;        &#125;        <span class="hljs-comment">// 生成随机文件名</span>        fileName = CommunityUtil.generateUUID() + suffix;        <span class="hljs-comment">// 确定文件存放路径</span>        File dest = <span class="hljs-keyword">new</span> File(uploadPath + <span class="hljs-string">&quot;/&quot;</span> + fileName);        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">// 存文件</span>            headerImage.transferTo(dest);        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            logger.error(<span class="hljs-string">&quot;上传文件失败：&quot;</span> + e.getMessage());            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;上传文件失败，服务器发生异常&quot;</span>, e);        &#125;        <span class="hljs-comment">// 更新当前用户头像路径</span>        <span class="hljs-comment">// web访问路径</span>        <span class="hljs-comment">// http:localhost:8080/community/user/header/xxx.png</span>        User user = hostHolder.getUsers();        String headerUrl = domain + contextPath + <span class="hljs-string">&quot;/user&quot;</span> + <span class="hljs-string">&quot;/header/&quot;</span> + fileName;        <span class="hljs-keyword">int</span> rows = userService.updateHeadUrl(user.getId(), headerUrl);        <span class="hljs-keyword">if</span> (rows&gt;<span class="hljs-number">0</span>)&#123;            model.addAttribute(<span class="hljs-string">&quot;success&quot;</span>,<span class="hljs-string">&quot;成功&quot;</span>);        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;site/setting&quot;</span>;<span class="hljs-comment">//        return &quot;redirect:/index&quot;;</span>    &#125;</code></pre></li><li><p>编写UserController中展示头像方法</p><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(path = &quot;/header/&#123;fileName&#125;&quot;, method = RequestMethod.GET)</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getHeader</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;fileName&quot;)</span> String fileName, HttpServletResponse response)</span> </span>&#123;    <span class="hljs-comment">// 获取服务器存放路径</span>    String filePath = uploadPath + <span class="hljs-string">&quot;/&quot;</span> + fileName;    <span class="hljs-comment">// 文件后缀名</span>    String suffix = fileName.substring(fileName.lastIndexOf(<span class="hljs-string">&quot;.&quot;</span>));    <span class="hljs-comment">// 响应类型</span>    response.setContentType(<span class="hljs-string">&quot;image/&quot;</span> + suffix);    <span class="hljs-keyword">try</span> (            FileInputStream fis = <span class="hljs-keyword">new</span> FileInputStream(filePath);            ServletOutputStream os = response.getOutputStream()    ) &#123;        <span class="hljs-keyword">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];        <span class="hljs-keyword">int</span> length = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> ((length = fis.read(buffer)) != -<span class="hljs-number">1</span>) &#123;            os.write(buffer, <span class="hljs-number">0</span>, length);        &#125;    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;        logger.error(<span class="hljs-string">&quot;读取头像失败&quot;</span> + e.getMessage());    &#125;&#125;</code></pre></li><li><p>修改模版引擎</p></li></ol><h3 id="更改密码"><a href="#更改密码" class="headerlink" title="更改密码"></a>更改密码</h3><ol><li><p>编写UserService中updatePassword方法</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String, Object&gt; <span class="hljs-title">updatePassword</span><span class="hljs-params">(String oldPassword, String newPassword, String newPasswordConfim)</span></span>&#123;    Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    <span class="hljs-keyword">if</span>(StringUtils.isBlank(oldPassword))&#123;        map.put(<span class="hljs-string">&quot;oldPasswordMsg&quot;</span>,<span class="hljs-string">&quot;旧密码不能为空！&quot;</span>);        <span class="hljs-keyword">return</span> map;    &#125;    <span class="hljs-keyword">if</span>(StringUtils.isBlank(newPassword))&#123;        map.put(<span class="hljs-string">&quot;newPasswordMsg&quot;</span>,<span class="hljs-string">&quot;新密码不能为空！&quot;</span>);        <span class="hljs-keyword">return</span> map;    &#125;    <span class="hljs-keyword">if</span>(StringUtils.isBlank(newPasswordConfim))&#123;        map.put(<span class="hljs-string">&quot;newPasswordConfimMsg&quot;</span>,<span class="hljs-string">&quot;确认密码不能为空！&quot;</span>);        <span class="hljs-keyword">return</span> map;    &#125;    <span class="hljs-keyword">if</span>(oldPassword.equals(newPassword))&#123;        map.put(<span class="hljs-string">&quot;newPasswordMsg&quot;</span>,<span class="hljs-string">&quot;新密码不能和原密码相同！&quot;</span>);        <span class="hljs-keyword">return</span> map;    &#125;    <span class="hljs-keyword">if</span>(!newPassword.equals(newPasswordConfim))&#123;        map.put(<span class="hljs-string">&quot;newPasswordConfimMsg&quot;</span>,<span class="hljs-string">&quot;确认密码与新密码不同！&quot;</span>);        <span class="hljs-keyword">return</span> map;    &#125;    User user = hostHolder.getUsers();    oldPassword=CommunityUtil.md5(oldPassword+user.getSalt());    <span class="hljs-keyword">if</span>(!oldPassword.equals(user.getPassword()))&#123;        map.put(<span class="hljs-string">&quot;oldPasswordMsg&quot;</span>,<span class="hljs-string">&quot;密码错误！&quot;</span>);        <span class="hljs-keyword">return</span> map;    &#125;    userMapper.updatePassword(user.getId(),CommunityUtil.md5(newPassword+user.getSalt()));    <span class="hljs-keyword">return</span> map;&#125;</code></pre></li><li><p>编写Mapper</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;updatePassword&quot;</span>&gt;</span>    update user set password = #&#123;password&#125; where id = #&#123;id&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span></code></pre></li><li><p>编写UserControlle请求</p><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(path = &quot;/updatePassword&quot;, method = RequestMethod.POST)</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">updatePasswordByOld</span><span class="hljs-params">(String oldPassword, String newPassword, String newPasswordConfim,</span></span><span class="hljs-function"><span class="hljs-params">                                  Model model, <span class="hljs-meta">@CookieValue(&quot;ticket&quot;)</span> String ticket)</span> </span>&#123;    Map&lt;String, Object&gt; map = userService.updatePassword(oldPassword, newPassword, newPasswordConfim);    <span class="hljs-keyword">if</span> (map == <span class="hljs-keyword">null</span> || map.isEmpty()) &#123;        userService.logout(ticket);        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;redirect:/login&quot;</span>;    &#125;    model.addAttribute(<span class="hljs-string">&quot;oldPasswordMsg&quot;</span>, map.get(<span class="hljs-string">&quot;oldPasswordMsg&quot;</span>));    model.addAttribute(<span class="hljs-string">&quot;newPasswordMsg&quot;</span>, map.get(<span class="hljs-string">&quot;newPasswordMsg&quot;</span>));    model.addAttribute(<span class="hljs-string">&quot;newPasswordConfimMsg&quot;</span>, map.get(<span class="hljs-string">&quot;newPasswordConfimMsg&quot;</span>));    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;site/setting&quot;</span>;&#125;</code></pre></li><li><p>修改模版引擎</p></li></ol><h3 id="业务流程图"><a href="#业务流程图" class="headerlink" title="业务流程图"></a>业务流程图</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201221163918.png" alt="业务流程图"></p><h2 id="注解实现检查登录状态"><a href="#注解实现检查登录状态" class="headerlink" title="注解实现检查登录状态"></a>注解实现检查登录状态</h2><ul><li><p>使用拦截器</p><ul><li>在方法前标注自定义注解</li><li>拦截所有请求，只处理带有该注解的方法</li></ul></li><li><p>自定义注解</p><ul><li><p>常用元注解</p><p>@Target、@Retention、@Document、@Inherited</p></li><li><p>如何读取注解</p><p>Method.getDeclaredAnnotations()</p><p>Method.getAnnotation(Class<T> annotationClass)</p></li></ul></li></ul><h3 id="开发流程-1"><a href="#开发流程-1" class="headerlink" title="开发流程"></a>开发流程</h3><ol><li><p>实现注解</p><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.METHOD)</span><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> LoginRequired &#123;    &#125;</code></pre><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201221165052.png" alt="包位置" style="zoom:50%;" /></li><li><p>给想要拦截的Controller加上注解</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201221165130.png" alt="加注解"></p></li><li><p>编写拦截注解的拦截器</p><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-meta">@Deprecated</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginRequiredInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HandlerInterceptor</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    HostHolder hostHolder;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">// 判定拦截对象handler是否为method</span>        <span class="hljs-keyword">if</span> (handler <span class="hljs-keyword">instanceof</span> HandlerMethod)&#123;            HandlerMethod handlerMethod = (HandlerMethod) handler;            Method method = handlerMethod.getMethod();            LoginRequired loginRequired = method.getAnnotation(LoginRequired.class);            <span class="hljs-keyword">if</span> (loginRequired != <span class="hljs-keyword">null</span> &amp;&amp; hostHolder.getUsers() == <span class="hljs-keyword">null</span>)&#123;                response.sendRedirect(request.getContextPath() + <span class="hljs-string">&quot;/login&quot;</span>);                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;&#125;</code></pre></li><li><p>给WebMvcConfig添加拦截器</p><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebMvcConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> LoginTicketInterceptor loginTicketInterceptor;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> LoginRequiredInterceptor loginRequiredInterceptor;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> </span>&#123;        registry.addInterceptor(loginTicketInterceptor)                .excludePathPatterns(<span class="hljs-string">&quot;/**/*.css&quot;</span>, <span class="hljs-string">&quot;/**/*.js&quot;</span>, <span class="hljs-string">&quot;/**/*.png&quot;</span>, <span class="hljs-string">&quot;/**/*.jpg&quot;</span>, <span class="hljs-string">&quot;/**/*.jpeg&quot;</span>);        <span class="hljs-comment">//registry.addInterceptor(loginRequiredInterceptor)</span>        <span class="hljs-comment">//        .excludePathPatterns(&quot;/**/*.css&quot;, &quot;/**/*.js&quot;, &quot;/**/*.png&quot;, &quot;/**/*.jpg&quot;, &quot;/**/*.jpeg&quot;);</span>&#125;</code></pre></li></ol><h1 id="帖子模块"><a href="#帖子模块" class="headerlink" title="帖子模块"></a>帖子模块</h1><h2 id="前缀树过滤敏感词"><a href="#前缀树过滤敏感词" class="headerlink" title="前缀树过滤敏感词"></a>前缀树过滤敏感词</h2><ul><li>前缀树<ul><li>Trie、字典树、查找树</li><li>查找效率高、消耗内存大</li><li>字符串检索、词频统计、字符串排序</li></ul></li><li>敏感词过滤<ul><li>定义前缀树</li><li>根据敏感词，初始化前缀树</li><li>编写过滤敏感词的方法</li></ul></li></ul><ol><li><p>编写前缀树算法</p><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SensitiveFilter</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger logger = LoggerFactory.getLogger(SensitiveFilter.class);    <span class="hljs-comment">// 替换符</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String REPLACEMENT = <span class="hljs-string">&quot;*&quot;</span>;    <span class="hljs-comment">// 根节点</span>    <span class="hljs-keyword">private</span> TrieNode root = <span class="hljs-keyword">new</span> TrieNode();    <span class="hljs-comment">// 前缀树过滤</span>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TrieNode</span></span>&#123;        <span class="hljs-comment">// 敏感词结束结尾</span>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> isKeywordEnd = <span class="hljs-keyword">false</span>;        <span class="hljs-comment">// 子节点(key是下级字符,value是下级节点)</span>        <span class="hljs-keyword">private</span> Map&lt;Character, TrieNode&gt; subNode = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isKeywordEnd</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> isKeywordEnd;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setKeywordEnd</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> keywordEnd)</span> </span>&#123;            isKeywordEnd = keywordEnd;        &#125;        <span class="hljs-comment">// 添加子节点</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addSubNode</span><span class="hljs-params">(Character c, TrieNode node)</span></span>&#123;            subNode.put(c, node);        &#125;        <span class="hljs-comment">// 获取子节点</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> TrieNode <span class="hljs-title">getSubNode</span><span class="hljs-params">(Character c)</span></span>&#123;            <span class="hljs-keyword">return</span> subNode.get(c);        &#125;    &#125;    <span class="hljs-comment">// 初始化</span>    <span class="hljs-meta">@PostConstruct</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">try</span>(                InputStream is = <span class="hljs-keyword">this</span>.getClass().getClassLoader().getResourceAsStream(<span class="hljs-string">&quot;sensitive-words.txt&quot;</span>);                BufferedReader reader = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(is));        ) &#123;            String sensitiveWord;            <span class="hljs-keyword">while</span> ((sensitiveWord = reader.readLine()) != <span class="hljs-keyword">null</span>)&#123;                <span class="hljs-comment">// 添加到前缀树</span>                <span class="hljs-keyword">this</span>.addSensitiveWord(sensitiveWord);            &#125;        &#125; <span class="hljs-keyword">catch</span> (IOException e)&#123;            logger.error(<span class="hljs-string">&quot;加载敏感词文件失败&quot;</span> + e.getMessage());        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addSensitiveWord</span><span class="hljs-params">(String sensitiveWord)</span> </span>&#123;        TrieNode tempNode = root;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; sensitiveWord.length(); i++) &#123;            <span class="hljs-keyword">char</span> c = sensitiveWord.charAt(i);            TrieNode subNode = tempNode.getSubNode(c);            <span class="hljs-keyword">if</span> (subNode == <span class="hljs-keyword">null</span>)&#123;                <span class="hljs-comment">// 初始化</span>                subNode = <span class="hljs-keyword">new</span> TrieNode();                tempNode.addSubNode(c, subNode);            &#125;            <span class="hljs-comment">// 改变指针</span>            tempNode = subNode;            <span class="hljs-comment">// 设置敏感词结尾标记</span>            <span class="hljs-keyword">if</span> (i == sensitiveWord.length() - <span class="hljs-number">1</span>)&#123;                tempNode.setKeywordEnd(<span class="hljs-keyword">true</span>);            &#125;        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 过滤敏感词</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> text 待过滤文本</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 过滤后的文本</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">Filter</span><span class="hljs-params">(String text)</span></span>&#123;        <span class="hljs-keyword">if</span> (StringUtils.isBlank(text))&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-comment">// 指针1 指向树的根</span>        TrieNode tempNode = root;        <span class="hljs-comment">// 指针2 指向字符串首位</span>        <span class="hljs-keyword">int</span> begin = <span class="hljs-number">0</span>;        <span class="hljs-comment">// 指针3</span>        <span class="hljs-keyword">int</span> position = <span class="hljs-number">0</span>;        <span class="hljs-comment">// 结果</span>        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();        <span class="hljs-keyword">while</span> (position &lt; text.length())&#123;            <span class="hljs-keyword">char</span> c = text.charAt(position);            <span class="hljs-comment">// 跳过符号</span>            <span class="hljs-keyword">if</span> (isSymbol(c))&#123;                <span class="hljs-comment">// 若指针1处于根节点,将此符号计入结果,不用过滤,指针2向下走一步</span>                <span class="hljs-keyword">if</span> (tempNode == root)&#123;                    sb.append(c);                    begin++;                &#125;                <span class="hljs-comment">// 无论符号在开头、结尾,指针3都向下走一步</span>                position++;                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-comment">// 检查下级节点</span>            tempNode = tempNode.getSubNode(c);            <span class="hljs-keyword">if</span> (tempNode == <span class="hljs-keyword">null</span>)&#123;                <span class="hljs-comment">// 以为begin开头的字符串不是敏感词</span>                sb.append(text.charAt(begin));                position = ++ begin;                tempNode = root;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tempNode.isKeywordEnd)&#123;                <span class="hljs-comment">// 发现敏感词,将begin到position字符串替换掉</span>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; position - begin + <span class="hljs-number">1</span>; i++) &#123;                    sb.append(REPLACEMENT);                &#125;                begin = ++ position;                tempNode = root;            &#125; <span class="hljs-keyword">else</span> &#123;                position ++;            &#125;        &#125;        <span class="hljs-comment">// 最后一批字符计入结果</span>        sb.append(text.substring(begin));        <span class="hljs-keyword">return</span> sb.toString();    &#125;    <span class="hljs-comment">// 判断是否为符号</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSymbol</span><span class="hljs-params">(Character c)</span></span>&#123;        <span class="hljs-comment">// c &lt; 0x2E80 || c &gt; 0x9FFF 之间为东亚文字范围</span>        <span class="hljs-keyword">return</span> !CharUtils.isAsciiAlphanumeric(c) &amp;&amp; (c &lt; <span class="hljs-number">0x2E80</span> || c &gt; <span class="hljs-number">0x9FFF</span>);    &#125;&#125;</code></pre></li><li><p>编写sensitive-words.txt，设置要过滤的词</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201221165956.png" alt="过滤词"></p></li></ol><h2 id="发布帖子"><a href="#发布帖子" class="headerlink" title="发布帖子"></a>发布帖子</h2><ul><li>采用AJAX请求，实现发布帖子的功能  <ul><li>使用jQuery发送AJAX</li></ul></li></ul><h3 id="开发流程-2"><a href="#开发流程-2" class="headerlink" title="开发流程"></a>开发流程</h3><ol><li><p>导入fastJson</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>fastjson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.73<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></li><li><p>编写工具类，增加Json转换方法</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CommunityUtil</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getJSONString</span><span class="hljs-params">(<span class="hljs-keyword">int</span> code, String msg, Map&lt;String, Object&gt; map)</span></span>&#123;        JSONObject json = <span class="hljs-keyword">new</span> JSONObject();        json.put(<span class="hljs-string">&quot;code&quot;</span>, code);        json.put(<span class="hljs-string">&quot;msg&quot;</span>, msg);        <span class="hljs-keyword">if</span> (map != <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">for</span> (String key :map.keySet())&#123;                json.put(key, map.get(key));            &#125;        &#125;        <span class="hljs-keyword">return</span> json.toJSONString();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getJSONString</span><span class="hljs-params">(<span class="hljs-keyword">int</span> code, String msg)</span></span>&#123;        <span class="hljs-keyword">return</span> getJSONString(code, msg, <span class="hljs-keyword">null</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getJSONString</span><span class="hljs-params">(<span class="hljs-keyword">int</span> code)</span></span>&#123;        <span class="hljs-keyword">return</span> getJSONString(code, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);    &#125;&#125;</code></pre></li><li><p>discussPost-mapper增加insert</p><pre><code class="hljs java">&lt;insert id=<span class="hljs-string">&quot;insertDiscussPost&quot;</span> parameterType=<span class="hljs-string">&quot;DiscussPost&quot;</span> keyProperty=<span class="hljs-string">&quot;id&quot;</span>&gt;    <span class="hljs-function">insert into <span class="hljs-title">discuss_post</span><span class="hljs-params">(&lt;include refid=<span class="hljs-string">&quot;insertFields&quot;</span>&gt;&lt;/include&gt;)</span></span><span class="hljs-function">    <span class="hljs-title">values</span> <span class="hljs-params">(#&#123;userId&#125;,#&#123;title&#125;,#&#123;content&#125;,#&#123;type&#125;,#&#123;status&#125;,#&#123;createTime&#125;,#&#123;commentCount&#125;,#&#123;score&#125;)</span></span><span class="hljs-function">&lt;/insert&gt;</span></code></pre></li><li><p>DiscussPostService添加add方法</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">addDiscussPost</span><span class="hljs-params">(DiscussPost discussPost)</span></span>&#123;    <span class="hljs-keyword">if</span> (discussPost == <span class="hljs-keyword">null</span>)&#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;参数不能为空&quot;</span>);    &#125;    <span class="hljs-comment">// 转义html标记</span>    discussPost.setTitle(HtmlUtils.htmlEscape(discussPost.getTitle()));    discussPost.setContent(HtmlUtils.htmlEscape(discussPost.getContent()));    <span class="hljs-comment">// 敏感词过滤</span>    discussPost.setTitle(sensitiveFilter.Filter(discussPost.getTitle()));    discussPost.setContent(sensitiveFilter.Filter(discussPost.getContent()));    <span class="hljs-keyword">return</span> discussPostMapper.insertDiscussPost(discussPost);&#125;</code></pre></li><li><p>便携DiscussPostController</p><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(path = &quot;/add&quot;, method = RequestMethod.POST)</span><span class="hljs-meta">@ResponseBody</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">addDiscussPost</span><span class="hljs-params">(String title, String content)</span></span>&#123;    User user = hostHolder.getUsers();    <span class="hljs-keyword">if</span> (user == <span class="hljs-keyword">null</span>)&#123;        <span class="hljs-comment">// 未登陆</span>        <span class="hljs-keyword">return</span> CommunityUtil.getJSONString(<span class="hljs-number">403</span>, <span class="hljs-string">&quot;用户未登录！&quot;</span>);    &#125;    DiscussPost discussPost = <span class="hljs-keyword">new</span> DiscussPost();    discussPost.setUserId(user.getId());    discussPost.setTitle(title);    discussPost.setContent(content);    discussPost.setCreateTime(<span class="hljs-keyword">new</span> Date());    <span class="hljs-comment">// 报错将来统一处理</span>    discussPostService.addDiscussPost(discussPost);&#125;</code></pre></li><li><p>修改前端</p><pre><code class="hljs js">$(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;   $(<span class="hljs-string">&quot;#publishBtn&quot;</span>).click(publish);&#125;);<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">publish</span>(<span class="hljs-params"></span>) </span>&#123;   $(<span class="hljs-string">&quot;#publishModal&quot;</span>).modal(<span class="hljs-string">&quot;hide&quot;</span>);   <span class="hljs-comment">// 获取标题和内容</span>   <span class="hljs-keyword">var</span> title = $(<span class="hljs-string">&quot;#recipient-name&quot;</span>).val();   <span class="hljs-keyword">var</span> content = $(<span class="hljs-string">&quot;#message-text&quot;</span>).val();   <span class="hljs-comment">// 发送异步请求(POST)</span>   $.post(      CONTEXT_PATH + <span class="hljs-string">&quot;/discuss/add&quot;</span>,      &#123;<span class="hljs-string">&quot;title&quot;</span>:title,<span class="hljs-string">&quot;content&quot;</span>:content&#125;,      <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>) </span>&#123;         data = $.parseJSON(data);         <span class="hljs-comment">// 在提示框中显示返回消息</span>         $(<span class="hljs-string">&quot;#hintBody&quot;</span>).text(data.msg);         <span class="hljs-comment">// 显示提示框</span>         $(<span class="hljs-string">&quot;#hintModal&quot;</span>).modal(<span class="hljs-string">&quot;show&quot;</span>);         <span class="hljs-comment">// 2秒后,自动隐藏提示框</span>         <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;            $(<span class="hljs-string">&quot;#hintModal&quot;</span>).modal(<span class="hljs-string">&quot;hide&quot;</span>);            <span class="hljs-comment">// 刷新页面</span>            <span class="hljs-keyword">if</span>(data.code == <span class="hljs-number">0</span>) &#123;               <span class="hljs-built_in">window</span>.location.reload();            &#125;         &#125;, <span class="hljs-number">2000</span>);      &#125;   );&#125;</code></pre></li><li><p>修改模版引擎</p></li></ol><h3 id="业务流程图-1"><a href="#业务流程图-1" class="headerlink" title="业务流程图"></a>业务流程图</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201221173121.png" alt="流程图"></p><h2 id="帖子详情"><a href="#帖子详情" class="headerlink" title="帖子详情"></a>帖子详情</h2><ul><li>index.html在帖子标题上增加访问路径</li><li>discuss-detail.html<ul><li>处理静态资源访问路径</li><li>复用index.html的header区</li><li>显示标题、作者、发布时间、正文等内容</li></ul></li></ul><h3 id="开发流程-3"><a href="#开发流程-3" class="headerlink" title="开发流程"></a>开发流程</h3><ol><li><p>编写discussPost-mapper 增select</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectDiscussPostById&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;DiscussPost&quot;</span> &gt;</span>    select    <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">&quot;selectFields&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span>    from discuss_post    where id = #&#123;id&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre></li><li><p>编写discussPostService 增find</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> DiscussPost <span class="hljs-title">findDiscussPostById</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span></span>&#123;    <span class="hljs-keyword">return</span> discussPostMapper.selectDiscussPostById(id);&#125;</code></pre></li><li><p>编写DiscussPostController</p><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(path = &quot;/detail/&#123;discussPostId&#125;&quot;, method = RequestMethod.GET)</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getDiscussPost</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;discussPostId&quot;)</span> <span class="hljs-keyword">int</span> discussPostId, Page page, Model model)</span></span>&#123;    DiscussPost post = discussPostService.findDiscussPostById(discussPostId);    model.addAttribute(<span class="hljs-string">&quot;post&quot;</span>, post);    <span class="hljs-comment">// 获取user得到username 还可以用关联查询 之后改为redis缓存</span>    User user = userService.findUserById(post.getUserId());    model.addAttribute(<span class="hljs-string">&quot;user&quot;</span>, user);    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;site/discuss-detail&quot;</span>;&#125;</code></pre></li><li><p>处理模版引擎，详情查看源码</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201221173900.png" alt="其他省略"></p></li></ol><h2 id="显示评论"><a href="#显示评论" class="headerlink" title="显示评论"></a>显示评论</h2><ul><li>数据层<ul><li>根据实体查询一页评论数据</li><li>根据实体查询评论的数量</li></ul></li><li>业务层<ul><li>处理查询评论业务</li><li>处理查询评论数量业务</li></ul></li><li>表现层<ul><li>显示帖子详情数据时，同时显示帖子所有的评论数据</li></ul></li></ul><h3 id="开发流程-4"><a href="#开发流程-4" class="headerlink" title="开发流程"></a>开发流程</h3><ol><li><p>编写评论pojo</p><pre><code class="hljs java"><span class="hljs-meta">@Data</span><span class="hljs-meta">@AllArgsConstructor</span><span class="hljs-meta">@NoArgsConstructor</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Comment</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> userId;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> entityType;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> entityId;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> targetId;    <span class="hljs-keyword">private</span> String content;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> status;    <span class="hljs-keyword">private</span> Date createTime;&#125;</code></pre></li><li><p>编写comment-mapper.xml和CommentMapper基础</p><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><span class="hljs-comment">//@Repository</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CommentMapper</span> </span>&#123;        <span class="hljs-function">List&lt;Comment&gt; <span class="hljs-title">selectCommentsByEntity</span><span class="hljs-params">(<span class="hljs-keyword">int</span> entityType, <span class="hljs-keyword">int</span> entityId, <span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">int</span> limit)</span></span>;        <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">selectCountByEntity</span><span class="hljs-params">(<span class="hljs-keyword">int</span> entityType, <span class="hljs-keyword">int</span> entityId)</span></span>;&#125;</code></pre><pre><code class="hljs java">&lt;sql id=<span class="hljs-string">&quot;selectFields&quot;</span> &gt;    id, user_id, entity_type, entity_id, target_id, content, status, create_time&lt;/sql&gt;&lt;select id=<span class="hljs-string">&quot;selectCommentsByEntity&quot;</span> resultType=<span class="hljs-string">&quot;Comment&quot;</span>&gt;    select    &lt;include refid=&quot;selectFields&quot;&gt;&lt;/include&gt;    from comment    where status = <span class="hljs-number">0</span>    and entity_type = #&#123;entityType&#125;    and entity_id = #&#123;entityId&#125;    order by create_time asc    limit #&#123;offset&#125;,#&#123;limit&#125;&lt;/select&gt;&lt;select id=<span class="hljs-string">&quot;selectCountByEntity&quot;</span> resultType=<span class="hljs-string">&quot;int&quot;</span>&gt;    <span class="hljs-function">select <span class="hljs-title">count</span><span class="hljs-params">(id)</span></span><span class="hljs-function">    from comment</span><span class="hljs-function">    where status </span>= <span class="hljs-number">0</span>    and entity_type = #&#123;entityType&#125;    and entity_id = #&#123;entityId&#125;&lt;/select&gt;</code></pre></li><li><p>编写service</p><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CommentService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CommunityConstant</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> CommentMapper commentMapper;       <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Comment&gt; <span class="hljs-title">findCommentsByEntity</span><span class="hljs-params">(<span class="hljs-keyword">int</span> entityType, <span class="hljs-keyword">int</span> entityId, <span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">int</span> limit)</span></span>&#123;        <span class="hljs-keyword">return</span> commentMapper.selectCommentsByEntity(entityType, entityId, offset, limit);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findCommentCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> entityType, <span class="hljs-keyword">int</span> entityId)</span></span>&#123;        <span class="hljs-keyword">return</span> commentMapper.selectCountByEntity(entityType, entityId);    &#125;</code></pre></li><li><p>编写DiscussPostController, 丰富/detail/{discussPostId}请求</p><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(path = &quot;/detail/&#123;discussPostId&#125;&quot;, method = RequestMethod.GET)</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getDiscussPost</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;discussPostId&quot;)</span> <span class="hljs-keyword">int</span> discussPostId, Page page, Model model)</span></span>&#123;    DiscussPost post = discussPostService.findDiscussPostById(discussPostId);    model.addAttribute(<span class="hljs-string">&quot;post&quot;</span>, post);    <span class="hljs-comment">// 获取user得到username 还可以用关联查询 之后改为redis缓存</span>    User user = userService.findUserById(post.getUserId());    model.addAttribute(<span class="hljs-string">&quot;user&quot;</span>, user);    <span class="hljs-comment">// 评论区</span>    page.setLimit(<span class="hljs-number">5</span>);    page.setPath(<span class="hljs-string">&quot;/discuss/detail/&quot;</span> + discussPostId);    page.setRows(post.getCommentCount());    List&lt;Comment&gt; comments = commentService.findCommentsByEntity(            ENTITY_TYPE_POST, post.getId(), page.getOffset(), page.getLimit());    List&lt;Map&lt;String, Object&gt;&gt; show_comments = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">if</span> (comments != <span class="hljs-keyword">null</span>)&#123;        <span class="hljs-keyword">for</span> (Comment comment: comments             ) &#123;            Map&lt;String,Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();            <span class="hljs-comment">// 评论</span>            map.put(<span class="hljs-string">&quot;comment&quot;</span>, comment);            User userOfComment = userService.findUserById(comment.getUserId());            <span class="hljs-comment">// 评论作者</span>            map.put(<span class="hljs-string">&quot;user&quot;</span>, userOfComment);            <span class="hljs-comment">// 评论也有评论</span>            <span class="hljs-comment">// 回复不进行分页</span>            List&lt;Comment&gt; replyList = commentService.findCommentsByEntity(                    ENTITY_TYPE_COMMENT, comment.getId(), <span class="hljs-number">0</span>, Integer.MAX_VALUE);            List&lt;Map&lt;String, Object&gt;&gt; show_reply = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();            <span class="hljs-keyword">if</span> (show_reply != <span class="hljs-keyword">null</span>)&#123;                <span class="hljs-keyword">for</span> (Comment reply: replyList                     ) &#123;                    Map&lt;String,Object&gt; replyMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();                    replyMap.put(<span class="hljs-string">&quot;reply&quot;</span>, reply);                    User userOfReply = userService.findUserById(reply.getUserId());                    replyMap.put(<span class="hljs-string">&quot;user&quot;</span>, userOfReply );                    <span class="hljs-comment">// 回复目标！</span>                    User target = reply.getTargetId() == <span class="hljs-number">0</span> ? <span class="hljs-keyword">null</span> : userService.findUserById(reply.getTargetId());                    replyMap.put(<span class="hljs-string">&quot;target&quot;</span>, target);                &#125;            &#125;            map.put(<span class="hljs-string">&quot;replys&quot;</span>,show_reply);            <span class="hljs-comment">// 回复数量</span>            <span class="hljs-keyword">int</span> replyCount = commentService.findCommentCount(ENTITY_TYPE_COMMENT, comment.getId());            map.put(<span class="hljs-string">&quot;replyCount&quot;</span>,replyCount);            show_comments.add(map);        &#125;    &#125;    model.addAttribute(<span class="hljs-string">&quot;comments&quot;</span>,show_comments);    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;site/discuss-detail&quot;</span>;&#125;</code></pre><p>对应的常量接口</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 实体类型:帖子</span><span class="hljs-comment"> */</span><span class="hljs-keyword">int</span> ENTITY_TYPE_POST = <span class="hljs-number">1</span>;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 实体类型:评论</span><span class="hljs-comment"> */</span><span class="hljs-keyword">int</span> ENTITY_TYPE_COMMENT = <span class="hljs-number">2</span>;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 实体类型:用户</span><span class="hljs-comment"> */</span><span class="hljs-keyword">int</span> ENTITY_TYPE_USER = <span class="hljs-number">3</span>;</code></pre></li><li><p>修改discuss-detail.html模版引擎(代码众多，查看源文件)</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201222143039.png" alt="模版引擎"></p></li></ol><h3 id="开发流程图"><a href="#开发流程图" class="headerlink" title="开发流程图"></a>开发流程图</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201222145118.png" alt="流程图"></p><h1 id="评论私信模块"><a href="#评论私信模块" class="headerlink" title="评论私信模块"></a>评论私信模块</h1><h2 id="添加评论"><a href="#添加评论" class="headerlink" title="添加评论"></a>添加评论</h2><ul><li>数据层<ul><li>增加评论数据</li><li>修改帖子评论的数量</li><li>（事务）</li></ul></li><li>业务层<ul><li>处理添加评论的业务</li><li>先增再更新评论数量</li></ul></li><li>表现层<ul><li>处理添加评论数据的请求</li><li>设置添加评论的表单</li></ul></li></ul><h3 id="开发流程-5"><a href="#开发流程-5" class="headerlink" title="开发流程"></a>开发流程</h3><ol><li><p>编写CommentMapper 以及mapper文件</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">insertComment</span><span class="hljs-params">(Comment comment)</span></span>;</code></pre><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">sql</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insertFields&quot;</span> &gt;</span>        user_id, entity_type, entity_id, target_id, content, status, create_time<span class="hljs-tag">&lt;/<span class="hljs-name">sql</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insertComment&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;Comment&quot;</span>&gt;</span>    insert into comment (<span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">&quot;insertFields&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span>)    values(#&#123;userId&#125;,#&#123;entityType&#125;,#&#123;entityId&#125;,#&#123;targetId&#125;,#&#123;content&#125;,#&#123;status&#125;,#&#123;createTime&#125;)<span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span></code></pre></li><li><p>编写DiscussPostMapper 更新评论方法</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">updateCommentCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, <span class="hljs-keyword">int</span> commentCount)</span></span>;</code></pre><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;updateCommentCount&quot;</span> &gt;</span>    update discuss_post set comment_count = #&#123;commentCount&#125;    where id = #&#123;id&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span></code></pre></li><li><p>编写DiscussPostService</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">updateCommentCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, <span class="hljs-keyword">int</span> commentCount)</span></span>&#123;    <span class="hljs-keyword">return</span> discussPostMapper.updateCommentCount(id, commentCount);&#125;</code></pre></li><li><p>编写CommentService add方法</p><pre><code class="hljs java"><span class="hljs-meta">@Transactional(isolation = Isolation.READ_COMMITTED, propagation = Propagation.REQUIRED)</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">addComment</span><span class="hljs-params">(Comment comment)</span></span>&#123;    <span class="hljs-comment">// 要过滤</span>    <span class="hljs-keyword">if</span> (comment == <span class="hljs-keyword">null</span>)&#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;参数为空！&quot;</span>);    &#125;    comment.setContent(HtmlUtils.htmlEscape(comment.getContent()));    comment.setContent(sensitiveFilter.Filter(comment.getContent()));    <span class="hljs-keyword">int</span> rows = commentMapper.insertComment(comment);    <span class="hljs-comment">// 更新帖子评论数量</span>    <span class="hljs-keyword">if</span> (comment.getEntityType() == ENTITY_TYPE_POST)&#123;        <span class="hljs-keyword">int</span> count = commentMapper.selectCountByEntity(ENTITY_TYPE_POST, comment.getEntityId());        discussPostService.updateCommentCount(comment.getEntityId(), count);    &#125;    <span class="hljs-keyword">return</span> rows;&#125;</code></pre></li><li><p>编写CommentController</p><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><span class="hljs-keyword">private</span> RedisTemplate redisTemplate;<span class="hljs-meta">@RequestMapping(path = &quot;/add/&#123;discussPostId&#125;&quot;, method = RequestMethod.POST)</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">addComment</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;discussPostId&quot;)</span><span class="hljs-keyword">int</span> discussPostId,Comment comment)</span></span>&#123;    comment.setUserId(hostHolder.getUsers().getId());    comment.setStatus(<span class="hljs-number">0</span>);    comment.setCreateTime(<span class="hljs-keyword">new</span> Date());    commentService.addComment(comment);    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;redirect:/discuss/detail/&quot;</span> + discussPostId;&#125;</code></pre></li><li><p>修改模版引擎</p></li></ol><h3 id="开发流程图-1"><a href="#开发流程图-1" class="headerlink" title="开发流程图"></a>开发流程图</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201222150634.png" alt="流程图"></p><h2 id="私信列表-数据库小游戏"><a href="#私信列表-数据库小游戏" class="headerlink" title="私信列表(数据库小游戏)"></a>私信列表(数据库小游戏)</h2><ul><li>私信列表<ul><li>查询当前会话列表</li><li>每个会话只显示一条最新的私信</li><li>支持分页</li></ul></li><li>私信详情<ul><li>查询某个会话所包含的私信</li><li>支持分页显示</li></ul></li></ul><h3 id="私信首页和详情开发流程"><a href="#私信首页和详情开发流程" class="headerlink" title="私信首页和详情开发流程"></a>私信首页和详情开发流程</h3><ol><li><p>编写MessageMapper 添加方法</p><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MessageMapper</span> </span>&#123;    <span class="hljs-comment">// 查询当前用户会话列表,针对每个会话只返回一条最新私信</span>    <span class="hljs-function">List&lt;Message&gt; <span class="hljs-title">selectConversations</span><span class="hljs-params">(<span class="hljs-keyword">int</span> userId, <span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">int</span> limit)</span></span>;    <span class="hljs-comment">// 查询当前用户会话数量</span>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">selectConversationCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> userId)</span></span>;    <span class="hljs-comment">// 查询某个会话所包含的私信列表</span>    <span class="hljs-function">List&lt;Message&gt; <span class="hljs-title">selectLetters</span><span class="hljs-params">(String conversationId, <span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">int</span> limit)</span></span>;    <span class="hljs-comment">// 查询某个会话所包含的私信数量</span>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">selectLetterCount</span><span class="hljs-params">(String conversationId)</span></span>;    <span class="hljs-comment">// 查询未读私信数量,查询总未读,查询对某用户未读需动态conversationId</span>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">selectLetterUnreadCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> userId, String conversationId)</span></span>;&#125;</code></pre></li><li><p>编写mapper文件</p><pre><code class="hljs java">&lt;sql id=<span class="hljs-string">&quot;selectFields&quot;</span>&gt;    id,from_id,to_id,conversation_id,content,status,create_time&lt;/sql&gt;&lt;sql id=<span class="hljs-string">&quot;insertFields&quot;</span>&gt;    from_id,to_id,conversation_id,content,status,create_time&lt;/sql&gt;&lt;!--  获取每个通话中最新的一条消息  --&gt;&lt;select id=<span class="hljs-string">&quot;selectConversations&quot;</span> resultType=<span class="hljs-string">&quot;Message&quot;</span>&gt;    select &lt;include refid=&quot;selectFields&quot;&gt;&lt;/include&gt;    from message    <span class="hljs-function">where id <span class="hljs-title">in</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">        select max(id)</span> from message</span><span class="hljs-function">        where status !</span>= <span class="hljs-number">2</span>        and from_id != <span class="hljs-number">1</span>        and (from_id = #&#123;userId&#125; or to_id = #&#123;userId&#125;)        group by conversation_id    )    order by create_time desc    limit #&#123;offset&#125;,#&#123;limit&#125;&lt;/select&gt;&lt;select id=<span class="hljs-string">&quot;selectConversationCount&quot;</span> resultType=<span class="hljs-string">&quot;int&quot;</span>&gt;    <span class="hljs-function">select <span class="hljs-title">count</span><span class="hljs-params">(m.maxid)</span> <span class="hljs-title">from</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">        select max(id)</span> as maxid from message</span><span class="hljs-function">        where status !</span>= <span class="hljs-number">2</span>        and from_id != <span class="hljs-number">1</span>        and (from_id = #&#123;userId&#125; or to_id = #&#123;userId&#125;)        group by conversation_id    )as m&lt;/select&gt;&lt;select id=<span class="hljs-string">&quot;selectLetters&quot;</span> resultType=<span class="hljs-string">&quot;Message&quot;</span>&gt;    select &lt;include refid=&quot;selectFields&quot;&gt;&lt;/include&gt;    from message    where status != <span class="hljs-number">2</span>    and from_id != <span class="hljs-number">1</span>    and conversation_id = #&#123;conversationId&#125;    order by create_time desc    limit #&#123;offset&#125;,#&#123;limit&#125;&lt;/select&gt;&lt;select id=<span class="hljs-string">&quot;selectLetterCount&quot;</span> resultType=<span class="hljs-string">&quot;int&quot;</span>&gt;    <span class="hljs-function">select <span class="hljs-title">count</span><span class="hljs-params">(id)</span></span><span class="hljs-function">    from message</span><span class="hljs-function">    where status !</span>= <span class="hljs-number">2</span>    and from_id != <span class="hljs-number">1</span>    and conversation_id = #&#123;conversationId&#125;&lt;/select&gt;&lt;select id=<span class="hljs-string">&quot;selectLetterUnreadCount&quot;</span> resultType=<span class="hljs-string">&quot;int&quot;</span>&gt;    <span class="hljs-function">select <span class="hljs-title">count</span><span class="hljs-params">(id)</span></span><span class="hljs-function">    from message</span><span class="hljs-function">    where status </span>= <span class="hljs-number">0</span>    and from_id != <span class="hljs-number">1</span>    and to_id = #&#123;userId&#125;    &lt;<span class="hljs-keyword">if</span> test=<span class="hljs-string">&quot;conversationId!=null&quot;</span>&gt;        and conversation_id = #&#123;conversationId&#125;    &lt;/if&gt;&lt;/select&gt;</code></pre></li><li><p>编写MessageService</p><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> MessageMapper messageMapper;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Message&gt; <span class="hljs-title">findConversations</span><span class="hljs-params">(<span class="hljs-keyword">int</span> userId, <span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">int</span> limit)</span></span>&#123;        <span class="hljs-keyword">return</span> messageMapper.selectConversations(userId, offset, limit);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findConversationCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> userId)</span></span>&#123;        <span class="hljs-keyword">return</span> messageMapper.selectConversationCount(userId);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Message&gt; <span class="hljs-title">findLetters</span><span class="hljs-params">(String conversationId, <span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">int</span> limit)</span></span>&#123;        <span class="hljs-keyword">return</span> messageMapper.selectLetters(conversationId, offset, limit);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findLetterCount</span><span class="hljs-params">(String conversationId)</span></span>&#123;        <span class="hljs-keyword">return</span> messageMapper.selectLetterCount(conversationId);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findeLetterUnreadCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> userId, String conversationId)</span></span>&#123;        <span class="hljs-keyword">return</span> messageMapper.selectLetterUnreadCount(userId, conversationId);    &#125;&#125;</code></pre></li><li><p>编写MessageController 展示私信首页</p><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(path = &quot;/list&quot;,method = RequestMethod.GET)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getMessageList</span><span class="hljs-params">(Model model, Page page)</span></span>&#123;        User user = hostHolder.getUsers();        <span class="hljs-comment">// 设置分页信息</span>        page.setPath(<span class="hljs-string">&quot;/message/list&quot;</span>);        page.setLimit(<span class="hljs-number">5</span>);        page.setRows(messageService.findConversationCount(user.getId()));        List&lt;Message&gt; conversations = messageService.findConversations(user.getId(), page.getOffset(), page.getLimit());        List&lt;Map&lt;String, Object&gt;&gt; show_conversations = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">for</span> (Message m: conversations             ) &#123;            Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();            map.put(<span class="hljs-string">&quot;conversation&quot;</span>, m);            map.put(<span class="hljs-string">&quot;unreadCount&quot;</span>, messageService.findeLetterUnreadCount(user.getId(), m.getConversationId()));            map.put(<span class="hljs-string">&quot;letterCount&quot;</span>, messageService.findLetterCount(m.getConversationId()));            <span class="hljs-keyword">int</span> targetId = user.getId() == m.getFromId() ? m.getToId() : m.getFromId();            map.put(<span class="hljs-string">&quot;targetUser&quot;</span>, userService.findUserById(targetId));            show_conversations.add(map);        &#125;        model.addAttribute(<span class="hljs-string">&quot;conversations&quot;</span>, show_conversations);        <span class="hljs-comment">// 查询未读消息数量</span>        <span class="hljs-keyword">int</span> unreadCountAll = messageService.findeLetterUnreadCount(user.getId(), <span class="hljs-keyword">null</span>);        model.addAttribute(<span class="hljs-string">&quot;unreadCountAll&quot;</span>, unreadCountAll);        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;site/letter&quot;</span>;    &#125;</code></pre></li><li><p>修改模版引擎</p></li><li><p>编写MessageController 展示私信详情页面</p><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(path = &quot;/detail/&#123;conversationId&#125;&quot;,method = RequestMethod.GET)</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getMessageDetail</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> String conversationId, Model model, Page page)</span></span>&#123;    page.setPath(<span class="hljs-string">&quot;/message/detail/&quot;</span>+conversationId);    page.setRows(messageService.findLetterCount(conversationId));    page.setLimit(<span class="hljs-number">5</span>);    List&lt;Message&gt; letters = messageService.findLetters(conversationId, page.getOffset(), page.getLimit());    List&lt;Map&lt;String, Object&gt;&gt; show_letters = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">for</span> (Message m:letters         ) &#123;        Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        map.put(<span class="hljs-string">&quot;letter&quot;</span>, m);        map.put(<span class="hljs-string">&quot;fromUser&quot;</span>, userService.findUserById(m.getFromId()));        show_letters.add(map);    &#125;    model.addAttribute(<span class="hljs-string">&quot;targetUser&quot;</span>, findTargetUser(conversationId));    model.addAttribute(<span class="hljs-string">&quot;letters&quot;</span>, show_letters);    <span class="hljs-comment">// 设置已读</span>    List&lt;Integer&gt; ids = getMessageIds(letters);    <span class="hljs-keyword">if</span> (ids != <span class="hljs-keyword">null</span> &amp;&amp; !ids.isEmpty())&#123;        messageService.readMessage(ids);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;site/letter-detail&quot;</span>;&#125;</code></pre></li></ol><p>​     期间涉及私有方法:</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> User <span class="hljs-title">findTargetUser</span><span class="hljs-params">(String conversationId)</span></span>&#123;    String[] s = conversationId.split(<span class="hljs-string">&quot;_&quot;</span>);    <span class="hljs-keyword">int</span> id0 = Integer.valueOf(s[<span class="hljs-number">0</span>]);    <span class="hljs-keyword">int</span> id1 = Integer.valueOf(s[<span class="hljs-number">1</span>]);    <span class="hljs-keyword">if</span> (hostHolder.getUsers().getId() == id0)&#123;        <span class="hljs-keyword">return</span> userService.findUserById(id1);    &#125;<span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">return</span> userService.findUserById(id0);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> List&lt;Integer&gt; <span class="hljs-title">getMessageIds</span><span class="hljs-params">(List&lt;Message&gt; messageList)</span></span>&#123;    List&lt;Integer&gt; ids = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">if</span> (messageList!=<span class="hljs-keyword">null</span>)&#123;        <span class="hljs-keyword">for</span> (Message message :messageList                ) &#123;            <span class="hljs-keyword">if</span> (hostHolder.getUsers().getId() == message.getToId() &amp;&amp; message.getStatus() == <span class="hljs-number">0</span>)&#123;                <span class="hljs-comment">// 接收者身份</span>                ids.add(message.getId());            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> ids;&#125;</code></pre><h3 id="开发流程图-2"><a href="#开发流程图-2" class="headerlink" title="开发流程图"></a>开发流程图</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201222160141.png" alt="流程图"></p><h2 id="发送私信"><a href="#发送私信" class="headerlink" title="发送私信"></a>发送私信</h2><ul><li><p>发送私信</p><ul><li>采用异步的方式发送私信</li><li>发送成功后刷新私信列表</li></ul></li><li><p>设置已读</p></li></ul><h3 id="开发流程-6"><a href="#开发流程-6" class="headerlink" title="开发流程"></a>开发流程</h3><ol><li><p>编写MessageMapper以及mapper文件</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">insertMessage</span><span class="hljs-params">(Message message)</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">updateMessageStatus</span><span class="hljs-params">(List&lt;Integer&gt; ids, <span class="hljs-keyword">int</span> status)</span></span>;</code></pre><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insertMessage&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;Message&quot;</span> <span class="hljs-attr">keyProperty</span>=<span class="hljs-string">&quot;id&quot;</span>&gt;</span>    insert into message(<span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">&quot;insertFields&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span>)    values(#&#123;fromId&#125;,#&#123;toId&#125;,#&#123;conversationId&#125;,#&#123;content&#125;,#&#123;status&#125;,#&#123;createTime&#125;)<span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;updateMessageStatus&quot;</span>&gt;</span>    update message set status = #&#123;status&#125;    where id in    <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;ids&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">open</span>=<span class="hljs-string">&quot;(&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;,&quot;</span> <span class="hljs-attr">close</span>=<span class="hljs-string">&quot;)&quot;</span>&gt;</span>        #&#123;id&#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span></code></pre></li><li><p>编写MessageService</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">insertLetter</span><span class="hljs-params">(Message message)</span></span>&#123;    <span class="hljs-comment">// 敏感词过滤</span>    message.setContent(HtmlUtils.htmlEscape(message.getContent()));    message.setContent(sensitiveFilter.Filter(message.getContent()));    <span class="hljs-keyword">return</span> messageMapper.insertMessage(message);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">readMessage</span><span class="hljs-params">(List&lt;Integer&gt; ids)</span></span>&#123;    <span class="hljs-keyword">return</span> messageMapper.updateMessageStatus(ids, <span class="hljs-number">1</span>);&#125;</code></pre></li><li><p>编写MessageController</p><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(path = &quot;/send&quot;,method = RequestMethod.POST)</span><span class="hljs-meta">@ResponseBody</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">sendMessage</span><span class="hljs-params">(String toName, String content)</span></span>&#123;    User toUser = userService.findUserByUsername(toName);    <span class="hljs-keyword">if</span> (toUser == <span class="hljs-keyword">null</span>)&#123;        <span class="hljs-keyword">return</span> CommunityUtil.getJSONString(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;目标用户不存在&quot;</span>);    &#125;    Message message = <span class="hljs-keyword">new</span> Message();    message.setFromId(hostHolder.getUsers().getId());    message.setToId(toUser.getId());    <span class="hljs-keyword">if</span> (message.getFromId() &lt; message.getToId())&#123;        message.setConversationId(message.getFromId()+<span class="hljs-string">&quot;_&quot;</span>+message.getToId());    &#125;<span class="hljs-keyword">else</span> &#123;        message.setConversationId(message.getToId()+<span class="hljs-string">&quot;_&quot;</span>+message.getFromId());    &#125;    message.setContent(content);    message.setCreateTime(<span class="hljs-keyword">new</span> Date());    messageService.insertLetter(message);    <span class="hljs-keyword">return</span> CommunityUtil.getJSONString(<span class="hljs-number">0</span>);&#125;</code></pre></li><li><p>编写js</p><pre><code class="hljs java">$(function()&#123;   $(<span class="hljs-string">&quot;#sendBtn&quot;</span>).click(send_letter);   $(<span class="hljs-string">&quot;.close&quot;</span>).click(delete_msg);&#125;);<span class="hljs-function">function <span class="hljs-title">send_letter</span><span class="hljs-params">()</span> </span>&#123;   $(<span class="hljs-string">&quot;#sendModal&quot;</span>).modal(<span class="hljs-string">&quot;hide&quot;</span>);   <span class="hljs-keyword">var</span> toName = $(<span class="hljs-string">&quot;#recipient-name&quot;</span>).val();   <span class="hljs-keyword">var</span> content = $(<span class="hljs-string">&quot;#message-text&quot;</span>).val();   $.post(      CONTEXT_PATH + <span class="hljs-string">&quot;/message/send&quot;</span>,      &#123;<span class="hljs-string">&quot;toName&quot;</span>:toName,<span class="hljs-string">&quot;content&quot;</span>:content&#125;,      function(data) &#123;         data = $.parseJSON(data);         <span class="hljs-keyword">if</span>(data.code == <span class="hljs-number">0</span>) &#123;            $(<span class="hljs-string">&quot;#hintBody&quot;</span>).text(<span class="hljs-string">&quot;发送成功!&quot;</span>);         &#125; <span class="hljs-keyword">else</span> &#123;            $(<span class="hljs-string">&quot;#hintBody&quot;</span>).text(data.msg);         &#125;         $(<span class="hljs-string">&quot;#hintModal&quot;</span>).modal(<span class="hljs-string">&quot;show&quot;</span>);         setTimeout(function()&#123;            $(<span class="hljs-string">&quot;#hintModal&quot;</span>).modal(<span class="hljs-string">&quot;hide&quot;</span>);            location.reload();         &#125;, <span class="hljs-number">2000</span>);      &#125;   );&#125;<span class="hljs-function">function <span class="hljs-title">delete_msg</span><span class="hljs-params">()</span> </span>&#123;   <span class="hljs-comment">// TODO 删除数据</span>   $(<span class="hljs-keyword">this</span>).parents(<span class="hljs-string">&quot;.media&quot;</span>).remove();&#125;</code></pre></li></ol><h3 id="开发流程-7"><a href="#开发流程-7" class="headerlink" title="开发流程"></a>开发流程</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201222161836.png" alt="设置未读"></p><h1 id="项目管理模块"><a href="#项目管理模块" class="headerlink" title="项目管理模块"></a>项目管理模块</h1><h2 id="统一异常处理"><a href="#统一异常处理" class="headerlink" title="统一异常处理"></a>统一异常处理</h2><ul><li>@ControllerAdvice<ul><li>用于修饰类,表示该类是Controller的全局配置类。</li><li>在此类中，可以对Controller进行如下三种全局配置:异常处理方案、绑定数据方案、绑定参数方案。</li></ul></li><li>@ExceptionHandler<ul><li>用于修饰方法，该方法会在Controller出现异常后被调用，用于处理捕获到的异常。</li></ul></li><li>@ModelAttribute<ul><li>用于修饰方法，该方法会在Controller方法执行前被调用，用 于为Model对象绑定参数。</li></ul></li><li>@DataBinder<ul><li>用于修饰方法，该方法会在Controller方法执行前被调用，用于绑定参数的转换器。</li></ul></li></ul><h3 id="error页面"><a href="#error页面" class="headerlink" title="error页面"></a>error页面</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201222164736.png" alt="error"></p><h3 id="统一异常处理-1"><a href="#统一异常处理-1" class="headerlink" title="统一异常处理"></a>统一异常处理</h3><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(path = &quot;/error&quot;,method = RequestMethod.GET)</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getErrorPage</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;error/500&quot;</span>;&#125;<span class="hljs-comment">// 拒绝访问时的提示页面</span><span class="hljs-meta">@RequestMapping(path = &quot;/denied&quot;, method = RequestMethod.GET)</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getDeniedPage</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;/error/404&quot;</span>;&#125;</code></pre><h3 id="Controller全局配置类"><a href="#Controller全局配置类" class="headerlink" title="Controller全局配置类"></a>Controller全局配置类</h3><blockquote><p>不需要对任何Controller加处理，只需要编写全局配置类</p></blockquote><pre><code class="hljs java"><span class="hljs-meta">@ControllerAdvice(annotations = Controller.class)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExceptionAdvice</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger logger = LoggerFactory.getLogger(ExceptionAdvice.class);    <span class="hljs-meta">@ExceptionHandler(&#123;Exception.class&#125;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handlerException</span><span class="hljs-params">(Exception e, HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        logger.error(<span class="hljs-string">&quot;服务器发生异常&quot;</span> + e.getMessage());        <span class="hljs-keyword">for</span> (StackTraceElement element : e.getStackTrace())&#123;            logger.error(element.toString());        &#125;        String xRequestedWith = request.getHeader(<span class="hljs-string">&quot;x-requested-with&quot;</span>);        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;XMLHttpRequest&quot;</span>.equals(xRequestedWith))&#123;            <span class="hljs-comment">// 异步请求</span>            response.setContentType(<span class="hljs-string">&quot;application/plain;charset=utf-8&quot;</span>);            PrintWriter writer = response.getWriter();            writer.write(CommunityUtil.getJSONString(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;服务器异常&quot;</span>));        &#125;<span class="hljs-keyword">else</span> &#123;            response.sendRedirect(request.getContextPath() + <span class="hljs-string">&quot;/error&quot;</span>);        &#125;    &#125;&#125;</code></pre><h2 id="统一记录日志"><a href="#统一记录日志" class="headerlink" title="统一记录日志"></a>统一记录日志</h2><ul><li>AOP实现<ul><li><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201222165608.png" alt="AOP"></li></ul></li></ul><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201222170059.png" alt="原理图"></p><p>详细原理查看Spring AOP</p><h3 id="Aspect实现AOP"><a href="#Aspect实现AOP" class="headerlink" title="Aspect实现AOP"></a>Aspect实现AOP</h3><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-meta">@Aspect</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServiceLogAspect</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger logger = LoggerFactory.getLogger(ServiceLogAspect.class);    <span class="hljs-meta">@Pointcut(&quot;execution(* com.nowcoder.community.service.*.*(..))&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pointcut</span><span class="hljs-params">()</span></span>&#123;&#125;    <span class="hljs-meta">@Before(&quot;pointcut()&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">(JoinPoint joinPoint)</span></span>&#123;        <span class="hljs-comment">// 用户[ip],在[xxx]时间 访问[com.xxx.xxx]功能</span>        ServletRequestAttributes attributes =(ServletRequestAttributes) RequestContextHolder.getRequestAttributes();        <span class="hljs-keyword">if</span> (attributes == <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-comment">// 是特殊调用 kafka</span>            <span class="hljs-keyword">return</span>;        &#125;        HttpServletRequest request = attributes.getRequest();        String ip = request.getRemoteHost();        String now = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>).format(<span class="hljs-keyword">new</span> Date());        String classname = joinPoint.getSignature().getDeclaringTypeName() + <span class="hljs-string">&quot;.&quot;</span> + joinPoint.getSignature().getName();        logger.info(String.format(<span class="hljs-string">&quot;用户[%s],在[%s],访问了[%s]&quot;</span>, ip, now, classname));    &#125;&#125;</code></pre><h1 id="点赞关注模块"><a href="#点赞关注模块" class="headerlink" title="点赞关注模块"></a>点赞关注模块</h1><h2 id="整合redis"><a href="#整合redis" class="headerlink" title="整合redis"></a>整合redis</h2><h3 id="开发流程-8"><a href="#开发流程-8" class="headerlink" title="开发流程"></a>开发流程</h3><ol><li><p>引入依赖</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></li><li><p>配置redis</p><p>ymal配置：</p><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span>  <span class="hljs-comment">#RedisProperties</span>  <span class="hljs-attr">redis:</span>    <span class="hljs-attr">database:</span> <span class="hljs-number">1</span>    <span class="hljs-attr">host:</span> <span class="hljs-string">localhost</span>    <span class="hljs-attr">port:</span> <span class="hljs-number">6379</span></code></pre><p>编写配置类</p><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisConfig</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="hljs-title">redisTemplate</span><span class="hljs-params">(RedisConnectionFactory factory)</span></span>&#123;        RedisTemplate&lt;String, Object&gt; template = <span class="hljs-keyword">new</span> RedisTemplate&lt;&gt;();        template.setConnectionFactory(factory);        <span class="hljs-comment">// 设置key序列化方式</span>        template.setKeySerializer(RedisSerializer.string());        <span class="hljs-comment">// 设置value序列化方式</span>        template.setValueSerializer(RedisSerializer.json());        <span class="hljs-comment">// 设置hash key序列化方式</span>        template.setHashKeySerializer(RedisSerializer.string());        <span class="hljs-comment">// 设置hash value序列化方式</span>        template.setHashValueSerializer(RedisSerializer.json());        template.afterPropertiesSet();        <span class="hljs-keyword">return</span> template;    &#125;&#125;</code></pre></li><li><p>测试</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201222170723.png" alt="测试"></p><p>测试类在测试包下，可自行使用</p></li></ol><h2 id="点赞、取消赞"><a href="#点赞、取消赞" class="headerlink" title="点赞、取消赞"></a>点赞、取消赞</h2><ul><li>点赞<ul><li>支持对帖子、评论点赞</li><li>第一次点赞、第二次取消点赞</li></ul></li><li>首页点赞数量<ul><li>统计帖子点赞数量</li></ul></li><li>详情页点赞数量<ul><li>统计点赞数量</li><li>显示点赞状态</li></ul></li></ul><h3 id="帖子点赞开发流程"><a href="#帖子点赞开发流程" class="headerlink" title="帖子点赞开发流程"></a>帖子点赞开发流程</h3><ol><li><p>编写RedisKeyUtil 设置业务key</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisKeyUtil</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String SPILIT = <span class="hljs-string">&quot;:&quot;</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String PREFIX_ENTITY_LIKE = <span class="hljs-string">&quot;like:entity&quot;</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String PREFIX_USER_LIKE = <span class="hljs-string">&quot;like:user&quot;</span>;    <span class="hljs-comment">// 某个实体赞的key</span>    <span class="hljs-comment">// 格式:  like:entity:entityType:entityId -&gt; set(userId)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getEntityLikeKey</span><span class="hljs-params">(<span class="hljs-keyword">int</span> entityType, <span class="hljs-keyword">int</span> entityId)</span></span>&#123;        <span class="hljs-keyword">return</span> PREFIX_ENTITY_LIKE + SPILIT + entityType + SPILIT + entityId;    &#125;    <span class="hljs-comment">// 某个用户的赞</span>    <span class="hljs-comment">// 格式:  like:user:userid -&gt; int</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getUserLikeKey</span><span class="hljs-params">(<span class="hljs-keyword">int</span> userId)</span></span>&#123;        <span class="hljs-keyword">return</span> PREFIX_USER_LIKE + SPILIT + userId;    &#125;&#125;</code></pre></li><li><p>编写LikeService</p><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LikeService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> RedisTemplate redisTemplate;    <span class="hljs-comment">// 点赞</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">like</span><span class="hljs-params">(<span class="hljs-keyword">int</span> userId, <span class="hljs-keyword">int</span> entityType, <span class="hljs-keyword">int</span> entityId, <span class="hljs-keyword">int</span> entityUserId)</span></span>&#123;        redisTemplate.execute(<span class="hljs-keyword">new</span> SessionCallback() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">execute</span><span class="hljs-params">(RedisOperations redisOperations)</span> <span class="hljs-keyword">throws</span> DataAccessException </span>&#123;                <span class="hljs-comment">// 实体用户同时更新 保证事务性</span>                String entityLikeKey = RedisKeyUtil.getEntityLikeKey(entityType, entityId);                String userLikeKey = RedisKeyUtil.getUserLikeKey(entityUserId);                Boolean isMember = redisOperations.opsForSet().isMember(entityLikeKey, userId);                redisOperations.multi();                <span class="hljs-keyword">if</span> (isMember)&#123;                    <span class="hljs-comment">// 已经点赞</span>                    redisOperations.opsForSet().remove(entityLikeKey, userId);                    redisOperations.opsForValue().decrement(userLikeKey);                &#125;<span class="hljs-keyword">else</span> &#123;                    redisOperations.opsForSet().add(entityLikeKey, userId);                    redisOperations.opsForValue().increment(userLikeKey);                &#125;                <span class="hljs-keyword">return</span> redisOperations.exec();            &#125;        &#125;);    &#125;    <span class="hljs-comment">// 查询某实体(帖子\评论)点赞数量</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">findEntityLikeCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> entityType, <span class="hljs-keyword">int</span> entityId)</span></span>&#123;        String entityLikeKey = RedisKeyUtil.getEntityLikeKey(entityType, entityId);        <span class="hljs-keyword">return</span> redisTemplate.opsForSet().size(entityLikeKey);    &#125;    <span class="hljs-comment">// 查询对某实体(帖子\评论)点赞状态</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findEntityLikeStatus</span><span class="hljs-params">(<span class="hljs-keyword">int</span> userId, <span class="hljs-keyword">int</span> entityType, <span class="hljs-keyword">int</span> entityId)</span></span>&#123;        String entityLikeKey = RedisKeyUtil.getEntityLikeKey(entityType, entityId);        <span class="hljs-keyword">return</span> redisTemplate.opsForSet().isMember(entityLikeKey, userId) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;    &#125;&#125;</code></pre></li><li><p>编写LikeController</p><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LikeController</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CommunityConstant</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> LikeService likeService;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> HostHolder hostHolder;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> RedisTemplate redisTemplate;    <span class="hljs-meta">@RequestMapping(path = &quot;/like&quot;, method = RequestMethod.POST)</span>    <span class="hljs-meta">@ResponseBody</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">like</span><span class="hljs-params">(<span class="hljs-keyword">int</span> entityType, <span class="hljs-keyword">int</span> entityId, <span class="hljs-keyword">int</span> entityUserId, <span class="hljs-keyword">int</span> postId)</span></span>&#123;        User user = hostHolder.getUsers();        likeService.like(user.getId(), entityType, entityId, entityUserId);        <span class="hljs-comment">// 点赞数量和状态</span>        Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        <span class="hljs-keyword">int</span> likeStatus = likeService.findEntityLikeStatus(user.getId(), entityType, entityId);        map.put(<span class="hljs-string">&quot;likeCount&quot;</span>, likeService.findEntityLikeCount(entityType, entityId));        map.put(<span class="hljs-string">&quot;likeStatus&quot;</span>, likeStatus);        <span class="hljs-keyword">return</span> CommunityUtil.getJSONString(<span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>, map);    &#125;&#125;</code></pre></li><li><p>修改模版引擎</p></li><li><p>编写js</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">like</span>(<span class="hljs-params">btn, entityType, entityId, entityUserId, postId</span>) </span>&#123;    $.post(        CONTEXT_PATH + <span class="hljs-string">&quot;/like&quot;</span>,        &#123;<span class="hljs-string">&quot;entityType&quot;</span>:entityType,<span class="hljs-string">&quot;entityId&quot;</span>:entityId,<span class="hljs-string">&quot;entityUserId&quot;</span>:entityUserId,<span class="hljs-string">&quot;postId&quot;</span>:postId&#125;,        <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>) </span>&#123;            data = $.parseJSON(data);            <span class="hljs-keyword">if</span>(data.code == <span class="hljs-number">0</span>) &#123;                $(btn).children(<span class="hljs-string">&quot;i&quot;</span>).text(data.likeCount);                $(btn).children(<span class="hljs-string">&quot;b&quot;</span>).text(data.likeStatus==<span class="hljs-number">1</span>?<span class="hljs-string">&#x27;已赞&#x27;</span>:<span class="hljs-string">&quot;赞&quot;</span>);            &#125; <span class="hljs-keyword">else</span> &#123;                alert(data.msg);            &#125;        &#125;    );&#125;</code></pre></li><li><p>给其他Controller添加查询赞的功能</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201222172546.png" alt="DiscussPostController添加like"></p><p>再更改模版引擎即可</p></li></ol><h3 id="获取用户主页获得的赞数开发流程"><a href="#获取用户主页获得的赞数开发流程" class="headerlink" title="获取用户主页获得的赞数开发流程"></a>获取用户主页获得的赞数开发流程</h3><ol><li><p>添加RedisKeyUtil</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String PREFIX_USER_LIKE = <span class="hljs-string">&quot;like:user&quot;</span>; <span class="hljs-comment">// 某个用户的赞</span> <span class="hljs-comment">// 格式:  like:user:userid -&gt; int</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getUserLikeKey</span><span class="hljs-params">(<span class="hljs-keyword">int</span> userId)</span></span>&#123;     <span class="hljs-keyword">return</span> PREFIX_USER_LIKE + SPILIT + userId; &#125;</code></pre></li><li><p>事务化点赞Service，点赞后更新用户获赞数</p><pre><code class="hljs java">redisTemplate.execute(<span class="hljs-keyword">new</span> SessionCallback() &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">execute</span><span class="hljs-params">(RedisOperations redisOperations)</span> <span class="hljs-keyword">throws</span> DataAccessException </span>&#123;        <span class="hljs-comment">// 实体用户同时更新 保证事务性</span>        String entityLikeKey = RedisKeyUtil.getEntityLikeKey(entityType, entityId);        String userLikeKey = RedisKeyUtil.getUserLikeKey(entityUserId);        Boolean isMember = redisOperations.opsForSet().isMember(entityLikeKey, userId);        redisOperations.multi();        <span class="hljs-keyword">if</span> (isMember)&#123;            <span class="hljs-comment">// 已经点赞</span>            redisOperations.opsForSet().remove(entityLikeKey, userId);            redisOperations.opsForValue().decrement(userLikeKey);        &#125;<span class="hljs-keyword">else</span> &#123;            redisOperations.opsForSet().add(entityLikeKey, userId);            redisOperations.opsForValue().increment(userLikeKey);        &#125;        <span class="hljs-keyword">return</span> redisOperations.exec();    &#125;&#125;);</code></pre></li><li><p>添加用户获得赞个数方法</p><pre><code class="hljs java"><span class="hljs-comment">// 查询用户获得的点赞数量</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findUserLikeCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> userId)</span></span>&#123;    String UserLikeKey = RedisKeyUtil.getUserLikeKey(userId);    <span class="hljs-keyword">return</span> (Integer) redisTemplate.opsForValue().get(UserLikeKey) == <span class="hljs-keyword">null</span>?<span class="hljs-number">0</span>:(Integer) ((Integer) redisTemplate.opsForValue().get(UserLikeKey)).intValue();&#125;</code></pre></li><li><p>给Controller和js添加一个entityUserId参数即可（上述点赞代码已给出）</p></li><li><p>编写UserController 定位个人主页</p><pre><code class="hljs java"><span class="hljs-comment">// 个人主页</span><span class="hljs-meta">@RequestMapping(path = &quot;/profile/&#123;userId&#125;&quot;, method = RequestMethod.GET)</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getProfilePage</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;userId&quot;)</span> <span class="hljs-keyword">int</span> userId, Model model)</span> </span>&#123;    User user = userService.findUserById(userId);    <span class="hljs-keyword">if</span> (user == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;该用户不存在&quot;</span>);    &#125;    model.addAttribute(<span class="hljs-string">&quot;user&quot;</span>, user);    <span class="hljs-comment">// 获赞数量</span>    <span class="hljs-keyword">int</span> userLikeCount = likeService.findUserLikeCount(userId);    model.addAttribute(<span class="hljs-string">&quot;userLikeCount&quot;</span>, userLikeCount);    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;site/profile&quot;</span>;&#125;</code></pre></li><li><p>修改模版引擎profile.html</p></li></ol><h3 id="开发流程图-3"><a href="#开发流程图-3" class="headerlink" title="开发流程图"></a>开发流程图</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201222180108.png" alt="开发流程图"></p><p>上图应该是 <strong>json装入点赞数、状态</strong> </p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201222184143.png" alt="redisKey"></p><h2 id="关注、取消关注"><a href="#关注、取消关注" class="headerlink" title="关注、取消关注"></a>关注、取消关注</h2><ul><li>需求<ul><li>开发关注、取消关注功能</li><li>统计用户的关注数、粉丝数</li></ul></li><li>rediskey<ul><li>若A关注B，则A是B的粉丝（Follower），B是A的目标（Followee）</li></ul></li></ul><h3 id="开发流程-9"><a href="#开发流程-9" class="headerlink" title="开发流程"></a>开发流程</h3><ol><li><p>编写RedisKeyUtil</p><pre><code class="hljs java"><span class="hljs-comment">// 关注</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String PREFIX_FOLLOWEE = <span class="hljs-string">&quot;followee&quot;</span>;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String PREFIX_FOLLOWER = <span class="hljs-string">&quot;follower&quot;</span>;<span class="hljs-comment">// 某个用户关注的实体</span><span class="hljs-comment">// 格式: followee:userId:entityType -&gt; zset(entityId, now date()) 时间排序</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getFolloweeKey</span><span class="hljs-params">(<span class="hljs-keyword">int</span> userId, <span class="hljs-keyword">int</span> entityType)</span></span>&#123;    <span class="hljs-keyword">return</span> PREFIX_FOLLOWEE + SPILIT + userId + SPILIT + entityType;&#125;   <span class="hljs-comment">// 某个实体的粉丝</span><span class="hljs-comment">// 格式: follower:entityType:entityId -&gt; zset(userId, now date()) 时间排序</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getFollowerKey</span><span class="hljs-params">(<span class="hljs-keyword">int</span> entityType, <span class="hljs-keyword">int</span> entityId)</span></span>&#123;    <span class="hljs-keyword">return</span> PREFIX_FOLLOWER + SPILIT + entityType + SPILIT + entityId;&#125;</code></pre></li><li><p>编写FollowService</p><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FollowService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CommunityConstant</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> RedisTemplate redisTemplate;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">follow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> userId, <span class="hljs-keyword">int</span> entityType, <span class="hljs-keyword">int</span> entityId)</span></span>&#123;        redisTemplate.execute(<span class="hljs-keyword">new</span> SessionCallback() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">execute</span><span class="hljs-params">(RedisOperations redisOperations)</span> <span class="hljs-keyword">throws</span> DataAccessException </span>&#123;                String followeeKey = RedisKeyUtil.getFolloweeKey(userId, entityType);                String followerKey = RedisKeyUtil.getFollowerKey(entityType, entityId);                redisOperations.multi();                redisOperations.opsForZSet().add(followeeKey, entityId, System.currentTimeMillis());                redisOperations.opsForZSet().add(followerKey, userId, System.currentTimeMillis());                <span class="hljs-keyword">return</span> redisOperations.exec();            &#125;        &#125;);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unfollow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> userId, <span class="hljs-keyword">int</span> entityType, <span class="hljs-keyword">int</span> entityId)</span></span>&#123;        redisTemplate.execute(<span class="hljs-keyword">new</span> SessionCallback() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">execute</span><span class="hljs-params">(RedisOperations redisOperations)</span> <span class="hljs-keyword">throws</span> DataAccessException </span>&#123;                String followeeKey = RedisKeyUtil.getFolloweeKey(userId, entityType);                String followerKey = RedisKeyUtil.getFollowerKey(entityType, entityId);                redisOperations.multi();                redisOperations.opsForZSet().remove(followeeKey, entityId);                redisOperations.opsForZSet().remove(followerKey, userId);                <span class="hljs-keyword">return</span> redisOperations.exec();            &#125;        &#125;);    &#125; &#125;</code></pre></li><li><p>Service添加查询关注、粉丝数以及关注状态</p><pre><code class="hljs java"><span class="hljs-comment">// 关注列表数量</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">findFolloweeCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> userId, <span class="hljs-keyword">int</span> entityType)</span></span>&#123;    String followeeKey = RedisKeyUtil.getFolloweeKey(userId, entityType);    <span class="hljs-keyword">return</span> redisTemplate.opsForZSet().zCard(followeeKey);&#125;<span class="hljs-comment">// 粉丝列表数量</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">findFollowerCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> entityType, <span class="hljs-keyword">int</span> entityId)</span></span>&#123;    String followerKey = RedisKeyUtil.getFolloweeKey(entityType, entityId);    <span class="hljs-keyword">return</span> redisTemplate.opsForZSet().zCard(followerKey);&#125;<span class="hljs-comment">// 查询关注状态</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasFollow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> userId, <span class="hljs-keyword">int</span> entityType, <span class="hljs-keyword">int</span> entityId)</span></span>&#123;    String followeeKey = RedisKeyUtil.getFolloweeKey(userId, entityType);    <span class="hljs-keyword">return</span> redisTemplate.opsForZSet().score(followeeKey, entityId) != <span class="hljs-keyword">null</span>;&#125;</code></pre></li><li><p>编写FollowController以及js</p><pre><code class="hljs js">$(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;   $(<span class="hljs-string">&quot;.follow-btn&quot;</span>).click(follow);&#125;);<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">follow</span>(<span class="hljs-params"></span>) </span>&#123;   <span class="hljs-keyword">var</span> btn = <span class="hljs-built_in">this</span>;   <span class="hljs-keyword">if</span>($(btn).hasClass(<span class="hljs-string">&quot;btn-info&quot;</span>)) &#123;      <span class="hljs-comment">// 关注TA</span>      $.post(         CONTEXT_PATH + <span class="hljs-string">&quot;/follow&quot;</span>,         &#123;<span class="hljs-string">&quot;entityType&quot;</span>:<span class="hljs-number">3</span>,<span class="hljs-string">&quot;entityId&quot;</span>:$(btn).prev().val()&#125;,         <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>) </span>&#123;            data = $.parseJSON(data);            <span class="hljs-keyword">if</span>(data.code == <span class="hljs-number">0</span>) &#123;               <span class="hljs-built_in">window</span>.location.reload();            &#125; <span class="hljs-keyword">else</span> &#123;               alert(data.msg);            &#125;         &#125;      );      <span class="hljs-comment">// $(btn).text(&quot;已关注&quot;).removeClass(&quot;btn-info&quot;).addClass(&quot;btn-secondary&quot;);</span>   &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-comment">// 取消关注</span>      $.post(         CONTEXT_PATH + <span class="hljs-string">&quot;/unfollow&quot;</span>,         &#123;<span class="hljs-string">&quot;entityType&quot;</span>:<span class="hljs-number">3</span>,<span class="hljs-string">&quot;entityId&quot;</span>:$(btn).prev().val()&#125;,         <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>) </span>&#123;            data = $.parseJSON(data);            <span class="hljs-keyword">if</span>(data.code == <span class="hljs-number">0</span>) &#123;               <span class="hljs-built_in">window</span>.location.reload();            &#125; <span class="hljs-keyword">else</span> &#123;               alert(data.msg);            &#125;         &#125;      );      <span class="hljs-comment">//$(btn).text(&quot;关注TA&quot;).removeClass(&quot;btn-secondary&quot;).addClass(&quot;btn-info&quot;);</span>   &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FollowController</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CommunityConstant</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> HostHolder hostHolder;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> FollowService followService;    <span class="hljs-meta">@RequestMapping(path = &quot;/follow&quot;, method = RequestMethod.POST)</span>    <span class="hljs-meta">@ResponseBody</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">follow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> entityType, <span class="hljs-keyword">int</span> entityId)</span></span>&#123;        User user = hostHolder.getUsers();        followService.follow(user.getId(), entityType, entityId);        <span class="hljs-keyword">return</span> CommunityUtil.getJSONString(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;已关注&quot;</span>);    &#125;    <span class="hljs-meta">@RequestMapping(path = &quot;/unfollow&quot;, method = RequestMethod.POST)</span>    <span class="hljs-meta">@ResponseBody</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">unfollow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> entityType, <span class="hljs-keyword">int</span> entityId)</span></span>&#123;        User user = hostHolder.getUsers();        followService.unfollow(user.getId(), entityType, entityId);        <span class="hljs-keyword">return</span> CommunityUtil.getJSONString(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;已取消关注&quot;</span>);    &#125;</code></pre></li><li><p>编写UserController主页显示请求 添加关注状态</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201222181231.png" alt="usercontroller"></p><h3 id="业务流程图-2"><a href="#业务流程图-2" class="headerlink" title="业务流程图"></a>业务流程图</h3></li></ol><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201222183222.png" alt="流程图"></p><h2 id="关注列表、粉丝列表"><a href="#关注列表、粉丝列表" class="headerlink" title="关注列表、粉丝列表"></a>关注列表、粉丝列表</h2><ul><li>业务层<ul><li>查询某个用户关注的人，支持分页</li><li>查询某个用户的粉丝，支持分页</li></ul></li><li>表现层<ul><li>处理请求</li><li>编写模版</li></ul></li></ul><h3 id="开发流程-10"><a href="#开发流程-10" class="headerlink" title="开发流程"></a>开发流程</h3><ol><li><p>编写FollowService</p><pre><code class="hljs java"><span class="hljs-comment">// 查询关注的用户</span><span class="hljs-keyword">public</span> List&lt;Map&lt;String, Object&gt;&gt; findFollowees(<span class="hljs-keyword">int</span> userId, <span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">int</span> limit)&#123;    String followeeKey = RedisKeyUtil.getFolloweeKey(userId, ENTITY_TYPE_USER);    Set&lt;Integer&gt; targetIds = redisTemplate.opsForZSet().reverseRange(followeeKey, offset, offset + limit - <span class="hljs-number">1</span>);    List&lt;Map&lt;String, Object&gt;&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">if</span> (targetIds == <span class="hljs-keyword">null</span>)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-keyword">for</span> (Integer targetId :targetIds            ) &#123;        User user = userService.findUserById(targetId);        Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        map.put(<span class="hljs-string">&quot;user&quot;</span>, user);        Double time = redisTemplate.opsForZSet().score(followeeKey, targetId);        map.put(<span class="hljs-string">&quot;userFolloweeDate&quot;</span>, <span class="hljs-keyword">new</span> Date(time.longValue()));        list.add(map);    &#125;    <span class="hljs-keyword">return</span> list;&#125;<span class="hljs-comment">// 查询用户的粉丝</span><span class="hljs-keyword">public</span> List&lt;Map&lt;String, Object&gt;&gt; findFollowers(<span class="hljs-keyword">int</span> userId, <span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">int</span> limit)&#123;    String followerKey = RedisKeyUtil.getFollowerKey(ENTITY_TYPE_USER, userId);    Set&lt;Integer&gt; targetIds = redisTemplate.opsForZSet().reverseRange(followerKey, offset, offset + limit - <span class="hljs-number">1</span>);    List&lt;Map&lt;String, Object&gt;&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">if</span> (targetIds == <span class="hljs-keyword">null</span>)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-keyword">for</span> (Integer targetId :targetIds    ) &#123;        User user = userService.findUserById(targetId);        Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        map.put(<span class="hljs-string">&quot;user&quot;</span>, user);        Double time = redisTemplate.opsForZSet().score(followerKey, targetId);        map.put(<span class="hljs-string">&quot;userFollowerDate&quot;</span>, <span class="hljs-keyword">new</span> Date(time.longValue()));        list.add(map);    &#125;    <span class="hljs-keyword">return</span> list;&#125;</code></pre></li><li><p>编写FollowController</p><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(path = &quot;/followees/&#123;userId&#125;&quot;, method = RequestMethod.GET)</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getFollowees</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;userId&quot;)</span> <span class="hljs-keyword">int</span> userId, Page page, Model model)</span></span>&#123;    User user = userService.findUserById(userId);    <span class="hljs-keyword">if</span> (user == <span class="hljs-keyword">null</span>)&#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;用户不存在&quot;</span>);    &#125;    model.addAttribute(<span class="hljs-string">&quot;user&quot;</span>, user);    page.setLimit(<span class="hljs-number">5</span>);    page.setPath(<span class="hljs-string">&quot;/followees/&quot;</span> + userId);    page.setRows((<span class="hljs-keyword">int</span>) followService.findFolloweeCount(userId, ENTITY_TYPE_USER));    <span class="hljs-comment">// 给list加入关注状态</span>    List&lt;Map&lt;String, Object&gt;&gt; followeesList = followService.findFollowees(userId, page.getOffset(), page.getLimit());    <span class="hljs-keyword">if</span> (followeesList != <span class="hljs-keyword">null</span>)&#123;        <span class="hljs-keyword">for</span> (Map&lt;String, Object&gt; followeeMap : followeesList                ) &#123;            <span class="hljs-comment">// 加入当前登陆用户对每个关注列表用户的关注状态</span>            User followeeUser = (User) followeeMap.get(<span class="hljs-string">&quot;user&quot;</span>);            followeeMap.put(<span class="hljs-string">&quot;followStatus&quot;</span>, hasFollow(followeeUser.getId()));        &#125;    &#125;    model.addAttribute(<span class="hljs-string">&quot;followees&quot;</span>, followeesList);    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;/site/followee&quot;</span>;&#125;<span class="hljs-meta">@RequestMapping(path = &quot;/followers/&#123;userId&#125;&quot;, method = RequestMethod.GET)</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getFollowers</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;userId&quot;)</span> <span class="hljs-keyword">int</span> userId, Page page, Model model)</span></span>&#123;    User user = userService.findUserById(userId);    <span class="hljs-keyword">if</span> (user == <span class="hljs-keyword">null</span>)&#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;用户不存在&quot;</span>);    &#125;    model.addAttribute(<span class="hljs-string">&quot;user&quot;</span>, user);    page.setLimit(<span class="hljs-number">5</span>);    page.setPath(<span class="hljs-string">&quot;/followers/&quot;</span> + userId);    page.setRows((<span class="hljs-keyword">int</span>) followService.findFollowerCount(ENTITY_TYPE_USER, userId));    <span class="hljs-comment">// 给list加入关注状态</span>    List&lt;Map&lt;String, Object&gt;&gt; followersList = followService.findFollowers(userId, page.getOffset(), page.getLimit());    <span class="hljs-keyword">if</span> (followersList != <span class="hljs-keyword">null</span>)&#123;        <span class="hljs-keyword">for</span> (Map&lt;String, Object&gt; followerMap : followersList        ) &#123;            <span class="hljs-comment">// 加入当前登陆用户对每个关注列表用户的关注状态</span>            User followerUser = (User) followerMap.get(<span class="hljs-string">&quot;user&quot;</span>);            followerMap.put(<span class="hljs-string">&quot;followStatus&quot;</span>, hasFollow(followerUser.getId()));        &#125;    &#125;    model.addAttribute(<span class="hljs-string">&quot;followers&quot;</span>, followersList);    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;/site/follower&quot;</span>;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasFollow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> userId)</span></span>&#123;    <span class="hljs-keyword">if</span> (hostHolder.getUsers() == <span class="hljs-keyword">null</span>)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-keyword">return</span> followService.hasFollow(hostHolder.getUsers().getId(), ENTITY_TYPE_USER, userId);&#125;</code></pre></li><li><p>修改模版引擎</p></li></ol><h3 id="业务流程图-3"><a href="#业务流程图-3" class="headerlink" title="业务流程图"></a>业务流程图</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201222183920.png" alt="流程图"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201222184215.png" alt="redisKey"></p><h1 id="缓存与消息队列模块"><a href="#缓存与消息队列模块" class="headerlink" title="缓存与消息队列模块"></a>缓存与消息队列模块</h1><ul><li>使用Redis存储验证码<ul><li>验证码需要频繁的访问与刷新,对性能要求较高。</li><li>验证码不需永久保存，通常在很短的时间后就会失效。</li><li>分布式部署时，存在Session共享的问题</li></ul></li><li>使用Redis存储登录凭证<ul><li>处理每次请求时，都要查询用户的登录凭证，访问的频率非常高。</li></ul></li><li>使用Redis缓存用户信息<ul><li>处理每次请求时，都要根据凭证查询用户信息，访问的频率非常高。</li></ul></li></ul><h2 id="储存验证码"><a href="#储存验证码" class="headerlink" title="储存验证码"></a>储存验证码</h2><h3 id="储存验证码开发流程"><a href="#储存验证码开发流程" class="headerlink" title="储存验证码开发流程"></a>储存验证码开发流程</h3><ol><li><p>编写RedisKeyUtil</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String KAPTCHA = <span class="hljs-string">&quot;kaptcha&quot;</span>; <span class="hljs-comment">// 登录验证码</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getKaptchaKey</span><span class="hljs-params">(String owner)</span></span>&#123;     <span class="hljs-keyword">return</span> KAPTCHA + SPILIT + owner; &#125;</code></pre></li><li><p>修改LoginController中/kaptcha请求</p><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(path = &quot;/kaptcha&quot;,method = RequestMethod.GET)</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getKaptcha</span><span class="hljs-params">(HttpServletResponse response)</span></span>&#123;    <span class="hljs-comment">// 生成验证码</span>    String text = kaptchProducer.createText();    BufferedImage image = kaptchProducer.createImage(text);    <span class="hljs-comment">// 验证码的归属者</span>    String kaptchaOwner = CommunityUtil.generateUUID();    <span class="hljs-comment">// 存入cookie</span>    Cookie cookie = <span class="hljs-keyword">new</span> Cookie(<span class="hljs-string">&quot;kaptchaOwner&quot;</span>, kaptchaOwner);    cookie.setMaxAge(<span class="hljs-number">60</span>);    cookie.setPath(contextPath);    response.addCookie(cookie);    <span class="hljs-comment">// 验证码文字存入redis</span>    String kaptchaKey = RedisKeyUtil.getKaptchaKey(kaptchaOwner);    redisTemplate.opsForValue().set(kaptchaKey, text, <span class="hljs-number">60</span> , TimeUnit.SECONDS);    <span class="hljs-comment">// 将图片输出给浏览器</span>    response.setContentType(<span class="hljs-string">&quot;image/png&quot;</span>);    <span class="hljs-keyword">try</span> &#123;        OutputStream os = response.getOutputStream();        ImageIO.write(image, <span class="hljs-string">&quot;png&quot;</span>, os);    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;        logger.error(<span class="hljs-string">&quot;验证码响应失败：&quot;</span> + e.getMessage());    &#125;&#125;</code></pre></li><li><p>修改LoginController中/login请求</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201223090056.png" alt="redis存验证码"></p></li></ol><h3 id="开发流程图-4"><a href="#开发流程图-4" class="headerlink" title="开发流程图"></a>开发流程图</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201223095133.png" alt="开发流程图"></p><h2 id="存储登录凭证"><a href="#存储登录凭证" class="headerlink" title="存储登录凭证"></a>存储登录凭证</h2><h3 id="存储登录凭证开发流程"><a href="#存储登录凭证开发流程" class="headerlink" title="存储登录凭证开发流程"></a>存储登录凭证开发流程</h3><ol><li><p>编写redisKeyUtil</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String PREFIX_TICKET = <span class="hljs-string">&quot;ticket&quot;</span>; <span class="hljs-comment">// 登录凭证</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getTicketKey</span><span class="hljs-params">(String ticket)</span></span>&#123;     <span class="hljs-keyword">return</span> PREFIX_TICKET + SPILIT + ticket; &#125;</code></pre></li><li><p>废弃LoginTicketMapper(不再MySql存储登录凭证)</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201223090329.png" alt="废弃"></p></li><li><p>修改UserService login方法</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201223090538.png" alt="redis"></p></li><li><p>修改UserService logout方法</p><pre><code class="hljs java">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">logout</span><span class="hljs-params">(String ticket)</span></span>&#123;<span class="hljs-comment">//        loginTicketMapper.updateStatus(ticket,1);</span>        String redisKey = RedisKeyUtil.getTicketKey(ticket);        LoginTicket loginTicket =(LoginTicket) redisTemplate.opsForValue().get(redisKey);        loginTicket.setStatus(<span class="hljs-number">1</span>);        redisTemplate.opsForValue().set(redisKey, loginTicket);    &#125;</code></pre></li><li><p>修改findLoginTicket方法</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> LoginTicket <span class="hljs-title">findLoginTicket</span><span class="hljs-params">(String ticket)</span></span>&#123;    String redisKey = RedisKeyUtil.getTicketKey(ticket);    <span class="hljs-keyword">return</span> (LoginTicket) redisTemplate.opsForValue().get(redisKey);&#125;</code></pre><p>这样拦截器能通过redis找到</p></li></ol><h3 id="开发流程图-5"><a href="#开发流程图-5" class="headerlink" title="开发流程图"></a>开发流程图</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201223095906.png" alt="流程图"></p><h2 id="存储用户信息"><a href="#存储用户信息" class="headerlink" title="存储用户信息"></a>存储用户信息</h2><h3 id="存储用户信息开发流程"><a href="#存储用户信息开发流程" class="headerlink" title="存储用户信息开发流程"></a>存储用户信息开发流程</h3><ol><li><p>编写RedisKeyUtil</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String PREFIX_USER = <span class="hljs-string">&quot;user&quot;</span>;<span class="hljs-comment">// 用户</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getUserKey</span><span class="hljs-params">(<span class="hljs-keyword">int</span> userId)</span></span>&#123;    <span class="hljs-keyword">return</span> PREFIX_USER + SPILIT + userId;&#125;</code></pre></li><li><p>修改UserService</p><pre><code class="hljs java">    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">findUserById</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span></span>&#123;<span class="hljs-comment">//        return userMapper.selectById(id);</span>        User user = getCache(id);        <span class="hljs-keyword">if</span> (user == <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-comment">// 初始化</span>            user = initCache(id);        &#125;        <span class="hljs-keyword">return</span> user;    &#125;    <span class="hljs-comment">// 缓存管理用户信息:</span>    <span class="hljs-comment">// 1. 优先从缓存中取值</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> User <span class="hljs-title">getCache</span><span class="hljs-params">(<span class="hljs-keyword">int</span> userId)</span></span>&#123;        String redisKey = RedisKeyUtil.getUserKey(userId);        <span class="hljs-keyword">return</span> (User) redisTemplate.opsForValue().get(redisKey);    &#125;    <span class="hljs-comment">// 2. 取不到时初始化缓存数据</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> User <span class="hljs-title">initCache</span><span class="hljs-params">(<span class="hljs-keyword">int</span> userId)</span></span>&#123;        User user = userMapper.selectById(userId);        String redisKey = RedisKeyUtil.getUserKey(userId);        redisTemplate.opsForValue().set(redisKey, user, <span class="hljs-number">36000</span>, TimeUnit.SECONDS);        <span class="hljs-keyword">return</span> user;    &#125;    <span class="hljs-comment">// 3. 数据变更时清楚缓存</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clearCache</span><span class="hljs-params">(<span class="hljs-keyword">int</span> userId)</span></span>&#123;        String redisKey = RedisKeyUtil.getUserKey(userId);        redisTemplate.delete(redisKey);    &#125;</code></pre></li><li><p>给相应方法添加清除缓存</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201223091454.png" alt="activation"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201223091512.png" alt="pwd"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201223091535.png" alt="headerUrl"></p></li></ol><h3 id="开发流程图-6"><a href="#开发流程图-6" class="headerlink" title="开发流程图"></a>开发流程图</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201223100648.png" alt="开发流程图"></p><h2 id="Spring整合Kafka"><a href="#Spring整合Kafka" class="headerlink" title="Spring整合Kafka"></a>Spring整合Kafka</h2><ul><li>引入依赖<ul><li>spring-kafka</li></ul></li><li>配置kafka<ul><li>配置server、consumer</li></ul></li><li>访问kafka<ul><li>生产者</li><li>消费者</li></ul></li></ul><h3 id="开发流程-11"><a href="#开发流程-11" class="headerlink" title="开发流程"></a>开发流程</h3><ol><li><p>Maven</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--    kafka    --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.kafka<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-kafka<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></li><li><p>配置kafka</p><pre><code class="hljs properties"><span class="hljs-comment"># KafkaProperties</span><span class="hljs-meta">spring.kafka.bootstrap-servers</span>=<span class="hljs-string">localhost:9092</span><span class="hljs-meta">spring.kafka.consumer.group-id</span>=<span class="hljs-string">test</span><span class="hljs-meta">spring.kafka.consumer.enable-auto-commit</span>=<span class="hljs-string">true</span><span class="hljs-meta">spring.kafka.consumer.auto-commit-interval</span>=<span class="hljs-string">3000</span><span class="hljs-meta">spring.kafka.listener.missing-topics-fatal</span>=<span class="hljs-string">false</span><span class="hljs-comment">#如果无主题会报错 选择false</span></code></pre></li><li><p>检查kafka本地配置</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201223101350.png" alt="kafka"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201223101442.png" alt="与properties对应"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201223101528.png" alt="开端口"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201223101557.png" alt="开端口"></p></li></ol><ol start="4"><li><p>编写测试类</p><pre><code class="hljs java"><span class="hljs-meta">@RunWith(SpringRunner.class)</span><span class="hljs-meta">@SpringBootTest</span><span class="hljs-meta">@ContextConfiguration(classes = CommunityApplication.class)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">KafkaTest</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> KafkaProducer kafkaProducer;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testKafka</span><span class="hljs-params">()</span> </span>&#123;        kafkaProducer.sendMessage(<span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-string">&quot;你好&quot;</span>);        System.out.println(<span class="hljs-number">1</span>);        kafkaProducer.sendMessage(<span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-string">&quot;在吗&quot;</span>);        <span class="hljs-keyword">try</span> &#123;            Thread.sleep(<span class="hljs-number">1000</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;<span class="hljs-meta">@Component</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">KafkaProducer</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> KafkaTemplate kafkaTemplate;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendMessage</span><span class="hljs-params">(String topic, String content)</span> </span>&#123;        kafkaTemplate.send(topic, content);    &#125;&#125;<span class="hljs-meta">@Component</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">KafkaConsumer</span> </span>&#123;    <span class="hljs-meta">@KafkaListener(topics = &#123;&quot;test&quot;&#125;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleMessage</span><span class="hljs-params">(ConsumerRecord record)</span> </span>&#123;        System.out.println(record.value()        );    &#125;&#125;</code></pre><p>单元测试源文件已给出</p></li></ol><h2 id="发送系统通知"><a href="#发送系统通知" class="headerlink" title="发送系统通知"></a>发送系统通知</h2><ul><li>触发事件<ul><li>评论后，发布通知</li><li>点赞后，发布通知</li><li>关注后，发布通知</li></ul></li><li>处理事件<ul><li>封装事件对象</li><li>开发事件的生产者</li><li>开发事件的消费者</li></ul></li></ul><h3 id="开发原理"><a href="#开发原理" class="headerlink" title="开发原理"></a>开发原理</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201223102514.png" alt="原理"></p><h3 id="开发流程-12"><a href="#开发流程-12" class="headerlink" title="开发流程"></a>开发流程</h3><ol><li><p>创建事件对象</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Event</span> </span>&#123;     <span class="hljs-comment">// return this的原因是让其可以链式编程</span>    <span class="hljs-keyword">private</span> String topic;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> userId;    <span class="hljs-comment">// type为1 id为帖子id type为2 id为评论表当前回复的id</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> entityType;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> entityId;    <span class="hljs-comment">// 发布帖子/发表评论的人</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> entityUserId;    <span class="hljs-comment">// 拓展其他业务</span>    <span class="hljs-keyword">private</span> Map&lt;String, Object&gt; data = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getTopic</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> topic;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Event <span class="hljs-title">setTopic</span><span class="hljs-params">(String topic)</span> </span>&#123;        <span class="hljs-keyword">this</span>.topic = topic;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getUserId</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> userId;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Event <span class="hljs-title">setUserId</span><span class="hljs-params">(<span class="hljs-keyword">int</span> userId)</span> </span>&#123;        <span class="hljs-keyword">this</span>.userId = userId;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getEntityType</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> entityType;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Event <span class="hljs-title">setEntityType</span><span class="hljs-params">(<span class="hljs-keyword">int</span> entityType)</span> </span>&#123;        <span class="hljs-keyword">this</span>.entityType = entityType;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getEntityId</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> entityId;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Event <span class="hljs-title">setEntityId</span><span class="hljs-params">(<span class="hljs-keyword">int</span> entityId)</span> </span>&#123;        <span class="hljs-keyword">this</span>.entityId = entityId;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getEntityUserId</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> entityUserId;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Event <span class="hljs-title">setEntityUserId</span><span class="hljs-params">(<span class="hljs-keyword">int</span> entityUserId)</span> </span>&#123;        <span class="hljs-keyword">this</span>.entityUserId = entityUserId;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String, Object&gt; <span class="hljs-title">getData</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> data;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Event <span class="hljs-title">setData</span><span class="hljs-params">(String key, Object value)</span> </span>&#123;        <span class="hljs-keyword">this</span>.data.put(key, value);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;&#125;</code></pre></li><li><p>业务层角度创建事件生产者</p><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EventProducer</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> KafkaTemplate kafkaTemplate;    <span class="hljs-comment">// 处理事件</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fireEvent</span><span class="hljs-params">(Event event)</span></span>&#123;        <span class="hljs-comment">// 将事件发送指定主题</span>        kafkaTemplate.send(event.getTopic(), JSONObject.toJSONString(event));    &#125;&#125;</code></pre></li><li><p>创建事件消费者</p><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EventConsumer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CommunityConstant</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger logger = LoggerFactory.getLogger(EventConsumer.class);    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> MessageService messageService;    <span class="hljs-meta">@KafkaListener(topics = &#123;TOPIC_COMMENT, TOPIC_LIKE, TOPIC_FOLLOW&#125;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleEventMessage</span><span class="hljs-params">(ConsumerRecord record)</span></span>&#123;        <span class="hljs-keyword">if</span> (record == <span class="hljs-keyword">null</span> || record.value() == <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-comment">// 空消息</span>            logger.error(<span class="hljs-string">&quot;消息内容为空！&quot;</span>);            <span class="hljs-keyword">return</span>;        &#125;        Event event = JSONObject.parseObject(record.value().toString(), Event.class);        <span class="hljs-keyword">if</span> (event == <span class="hljs-keyword">null</span>)&#123;            logger.error(<span class="hljs-string">&quot;消息格式为空！&quot;</span>);            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">// 发送站内通知</span>        Message message = <span class="hljs-keyword">new</span> Message();        message.setFromId(SYSTEM_USERID);        message.setToId(event.getEntityUserId());        message.setConversationId(event.getTopic());        message.setCreateTime(<span class="hljs-keyword">new</span> Date());        Map&lt;String, Object&gt; content = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        content.put(<span class="hljs-string">&quot;userId&quot;</span>, event.getUserId());        content.put(<span class="hljs-string">&quot;entityType&quot;</span>, event.getEntityType());        content.put(<span class="hljs-string">&quot;entityId&quot;</span>, event.getEntityId());        <span class="hljs-comment">// 额外date</span>        <span class="hljs-keyword">if</span> (!event.getData().isEmpty())&#123;            <span class="hljs-keyword">for</span> (Map.Entry&lt;String, Object&gt; entry:event.getData().entrySet())&#123;                content.put(entry.getKey(), entry.getValue());            &#125;        &#125;        message.setContent(JSONObject.toJSONString(content));        messageService.insertLetter(message);    &#125;&#125;</code></pre></li><li><p>修改常量接口</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 主题:评论</span><span class="hljs-comment"> */</span>String TOPIC_COMMENT = <span class="hljs-string">&quot;comment&quot;</span>;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 主题:点赞</span><span class="hljs-comment"> */</span>String TOPIC_LIKE = <span class="hljs-string">&quot;like&quot;</span>;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 主题:关注</span><span class="hljs-comment"> */</span>String TOPIC_FOLLOW = <span class="hljs-string">&quot;follow&quot;</span>;</code></pre></li><li><p>修改评论、点赞、关注Controller</p></li><li><p>评论事件</p><pre><code class="hljs java"><span class="hljs-comment">// 触发评论事件</span><span class="hljs-comment">// type为1 id为帖子id</span><span class="hljs-comment">// type为2 id为评论的id</span>Event event = <span class="hljs-keyword">new</span> Event()        .setTopic(TOPIC_COMMENT)        .setUserId(hostHolder.getUsers().getId())        .setEntityType(comment.getEntityType())        .setEntityId(comment.getEntityId())        .setData(<span class="hljs-string">&quot;postId&quot;</span>, discussPostId);<span class="hljs-keyword">if</span> (comment.getEntityType() == ENTITY_TYPE_POST)&#123;    <span class="hljs-comment">// EntityUserId 存帖子作者id 给作者发消息</span>    DiscussPost target = discussPostService.findDiscussPostById(comment.getEntityId());    event.setEntityUserId(target.getUserId());&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (comment.getEntityType() == ENTITY_TYPE_COMMENT)&#123;    <span class="hljs-comment">// EntityUserId 存当前评论的id 给评论作者发消息</span>    Comment target = commentService.findCommentById(comment.getEntityId());    event.setEntityUserId(target.getUserId());&#125;eventProducer.fireEvent(event);</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201223103720.png" alt="评论事件"></p></li><li><p>点赞事件</p><pre><code class="hljs java"><span class="hljs-comment">// 触发点赞事件</span><span class="hljs-keyword">if</span> (likeStatus == <span class="hljs-number">1</span>)&#123;    Event event = <span class="hljs-keyword">new</span> Event()            .setTopic(TOPIC_LIKE)            .setUserId(user.getId())            .setEntityType(entityType)            .setEntityId(entityId)            .setEntityUserId(entityUserId)            .setData(<span class="hljs-string">&quot;postId&quot;</span>, postId);    eventProducer.fireEvent(event);&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201223103905.png" alt="点赞事件"></p></li><li><p>关注事件</p><pre><code class="hljs java"><span class="hljs-comment">// 触发关注事件</span>Event event = <span class="hljs-keyword">new</span> Event()        .setTopic(TOPIC_FOLLOW)        .setUserId(user.getId())        .setEntityType(entityType)        .setEntityId(entityId)        .setEntityUserId(entityId);eventProducer.fireEvent(event);</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201223103952.png" alt="image-20201223103949547"></p></li></ol><h3 id="开发流程图-7"><a href="#开发流程图-7" class="headerlink" title="开发流程图"></a>开发流程图</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201223110623.png" alt="流程图"></p><h2 id="显示系统消息"><a href="#显示系统消息" class="headerlink" title="显示系统消息"></a>显示系统消息</h2><ul><li>通知列表<ul><li>显示评论、点赞、关注三种类型通知</li></ul></li><li>通知详情<ul><li>分页显示某一类主题通知</li></ul></li><li>未读<ul><li>页面头部显示所有未读消息</li></ul></li></ul><h3 id="开发流程-13"><a href="#开发流程-13" class="headerlink" title="开发流程"></a>开发流程</h3><ol><li><p>编写MessageMapper和mapper.xml</p><pre><code class="hljs java"><span class="hljs-comment">// 查询某个主题下最新的通知</span><span class="hljs-function">Message <span class="hljs-title">selectLatestNotice</span><span class="hljs-params">(<span class="hljs-keyword">int</span> userId, String topic)</span></span>;<span class="hljs-comment">// 查询某个主题包含通知数量</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">selectNoticeCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> userId, String topic)</span></span>;<span class="hljs-comment">// 查询未读通知数量</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">selectNoticeUnreadCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> userId, String topic)</span></span>;<span class="hljs-comment">// 查询某个主题所有的通知</span><span class="hljs-function">List&lt;Message&gt; <span class="hljs-title">selectNotices</span><span class="hljs-params">(<span class="hljs-keyword">int</span> userId, String topic, <span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">int</span> limit)</span></span>;</code></pre><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectLatestNotice&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Message&quot;</span>&gt;</span>    select <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">&quot;selectFields&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span>    from message    where id in (    select max(id) from message    where status != 2    and from_id = 1    and to_id = #&#123;userId&#125;    and conversation_id = #&#123;topic&#125;    )<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectNoticeCount&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;int&quot;</span>&gt;</span>    select count(id) from message    where status != 2    and from_id = 1    and to_id = #&#123;userId&#125;    and conversation_id = #&#123;topic&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectNoticeUnreadCount&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;int&quot;</span>&gt;</span>    select count(id) from message    where status = 0    and from_id = 1    and to_id = #&#123;userId&#125;    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;topic!=null&quot;</span>&gt;</span>        and conversation_id = #&#123;topic&#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectNotices&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Message&quot;</span>&gt;</span>    select <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">&quot;selectFields&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span>    from message    where status != 2    and from_id = 1    and to_id = #&#123;userId&#125;    and conversation_id = #&#123;topic&#125;    order by create_time desc    limit #&#123;offset&#125;, #&#123;limit&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre></li><li><p>编写MessageService</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Message <span class="hljs-title">findLatestNotice</span><span class="hljs-params">(<span class="hljs-keyword">int</span> userId, String topic)</span></span>&#123;    <span class="hljs-keyword">return</span> messageMapper.selectLatestNotice(userId, topic);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findNoticeCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> userId, String topic)</span></span>&#123;    <span class="hljs-keyword">return</span> messageMapper.selectNoticeCount(userId, topic);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findNoticeUnreadCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> userId, String topic)</span></span>&#123;    <span class="hljs-keyword">return</span> messageMapper.selectNoticeUnreadCount(userId, topic);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Message&gt; <span class="hljs-title">findNotices</span><span class="hljs-params">(<span class="hljs-keyword">int</span> userId, String topic, <span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">int</span> limit)</span></span>&#123;    <span class="hljs-keyword">return</span> messageMapper.selectNotices(userId, topic, offset, limit);&#125;</code></pre></li><li><p>编写MessageController 显示消息主页</p><pre><code class="hljs java">    <span class="hljs-meta">@RequestMapping(path = &quot;/notice/list&quot;, method = RequestMethod.GET)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getNoticeList</span><span class="hljs-params">(Model model)</span></span>&#123;        User user = hostHolder.getUsers();        <span class="hljs-comment">// 查询评论类通知</span>        Message message = messageService.findLatestNotice(user.getId(), TOPIC_COMMENT);        Map&lt;String, Object&gt; messageVo = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        <span class="hljs-keyword">if</span> (message != <span class="hljs-keyword">null</span>)&#123;            messageVo.put(<span class="hljs-string">&quot;message&quot;</span>, message);            String content = HtmlUtils.htmlUnescape(message.getContent());            Map&lt;String, Object&gt; data = JSONObject.parseObject(content, HashMap.class);            messageVo.put(<span class="hljs-string">&quot;user&quot;</span>, userService.findUserById((Integer) data.get(<span class="hljs-string">&quot;userId&quot;</span>)));            messageVo.put(<span class="hljs-string">&quot;entityType&quot;</span>, data.get(<span class="hljs-string">&quot;entityType&quot;</span>));            messageVo.put(<span class="hljs-string">&quot;entityId&quot;</span>, data.get(<span class="hljs-string">&quot;entityId&quot;</span>));            messageVo.put(<span class="hljs-string">&quot;postId&quot;</span>, data.get(<span class="hljs-string">&quot;postid&quot;</span>));            <span class="hljs-keyword">int</span> count = messageService.findNoticeCount(user.getId(), TOPIC_COMMENT);            messageVo.put(<span class="hljs-string">&quot;count&quot;</span>, count);            <span class="hljs-keyword">int</span> unread = messageService.findNoticeUnreadCount(user.getId(), TOPIC_COMMENT);            messageVo.put(<span class="hljs-string">&quot;unread&quot;</span>, unread);        &#125;<span class="hljs-keyword">else</span> &#123;            messageVo.put(<span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-keyword">null</span>);        &#125;        model.addAttribute(<span class="hljs-string">&quot;commentNotice&quot;</span>, messageVo);        <span class="hljs-comment">// 查询点赞类通知</span>        message = messageService.findLatestNotice(user.getId(), TOPIC_LIKE);        messageVo = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        <span class="hljs-keyword">if</span> (message != <span class="hljs-keyword">null</span>)&#123;            messageVo.put(<span class="hljs-string">&quot;message&quot;</span>, message);            String content = HtmlUtils.htmlUnescape(message.getContent());            Map&lt;String, Object&gt; data = JSONObject.parseObject(content, HashMap.class);            messageVo.put(<span class="hljs-string">&quot;user&quot;</span>, userService.findUserById((Integer) data.get(<span class="hljs-string">&quot;userId&quot;</span>)));            messageVo.put(<span class="hljs-string">&quot;entityType&quot;</span>, data.get(<span class="hljs-string">&quot;entityType&quot;</span>));            messageVo.put(<span class="hljs-string">&quot;entityId&quot;</span>, data.get(<span class="hljs-string">&quot;entityId&quot;</span>));            messageVo.put(<span class="hljs-string">&quot;postId&quot;</span>, data.get(<span class="hljs-string">&quot;postid&quot;</span>));            <span class="hljs-keyword">int</span> count = messageService.findNoticeCount(user.getId(), TOPIC_LIKE);            messageVo.put(<span class="hljs-string">&quot;count&quot;</span>, count);            <span class="hljs-keyword">int</span> unread = messageService.findNoticeUnreadCount(user.getId(), TOPIC_LIKE);            messageVo.put(<span class="hljs-string">&quot;unread&quot;</span>, unread);        &#125;<span class="hljs-keyword">else</span> &#123;            messageVo.put(<span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-keyword">null</span>);        &#125;        model.addAttribute(<span class="hljs-string">&quot;likeNotice&quot;</span>, messageVo);        <span class="hljs-comment">// 查询关注类通知</span>        message = messageService.findLatestNotice(user.getId(), TOPIC_FOLLOW);        messageVo = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        <span class="hljs-keyword">if</span> (message != <span class="hljs-keyword">null</span>)&#123;            messageVo.put(<span class="hljs-string">&quot;message&quot;</span>, message);            String content = HtmlUtils.htmlUnescape(message.getContent());            Map&lt;String, Object&gt; data = JSONObject.parseObject(content, HashMap.class);            messageVo.put(<span class="hljs-string">&quot;user&quot;</span>, userService.findUserById((Integer) data.get(<span class="hljs-string">&quot;userId&quot;</span>)));            messageVo.put(<span class="hljs-string">&quot;entityType&quot;</span>, data.get(<span class="hljs-string">&quot;entityType&quot;</span>));            messageVo.put(<span class="hljs-string">&quot;entityId&quot;</span>, data.get(<span class="hljs-string">&quot;entityId&quot;</span>));<span class="hljs-comment">//            messageVo.put(&quot;postId&quot;, data.get(&quot;postid&quot;));</span>            <span class="hljs-keyword">int</span> count = messageService.findNoticeCount(user.getId(), TOPIC_FOLLOW);            messageVo.put(<span class="hljs-string">&quot;count&quot;</span>, count);            <span class="hljs-keyword">int</span> unread = messageService.findNoticeUnreadCount(user.getId(), TOPIC_FOLLOW);            messageVo.put(<span class="hljs-string">&quot;unread&quot;</span>, unread);        &#125;<span class="hljs-keyword">else</span> &#123;            messageVo.put(<span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-keyword">null</span>);        &#125;        model.addAttribute(<span class="hljs-string">&quot;followNotice&quot;</span>, messageVo);        <span class="hljs-comment">// 查询未读消息数量</span>        <span class="hljs-keyword">int</span> letterUnreadCount = messageService.findeLetterUnreadCount(user.getId(), <span class="hljs-keyword">null</span>);        <span class="hljs-keyword">int</span> noticeUnreadCount = messageService.findNoticeUnreadCount(user.getId(), <span class="hljs-keyword">null</span>);        model.addAttribute(<span class="hljs-string">&quot;letterUnreadCount&quot;</span>, letterUnreadCount);        model.addAttribute(<span class="hljs-string">&quot;noticeUnreadCount&quot;</span>, noticeUnreadCount);        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;site/notice&quot;</span>;    &#125;</code></pre></li><li><p>编写MessageController 显示具体消息的全部页面</p><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(path = &quot;/notice/detail/&#123;topic&#125;&quot;, method = RequestMethod.GET)</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getNoticeDetail</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;topic&quot;)</span>String topic,Page page, Model model)</span></span>&#123;    User user = hostHolder.getUsers();    page.setLimit(<span class="hljs-number">5</span>);    page.setRows(messageService.findNoticeCount(user.getId(), topic));    page.setPath(<span class="hljs-string">&quot;/message/notice/detail/&quot;</span>+topic);    List&lt;Message&gt; noticeList = messageService.findNotices(user.getId(), topic, page.getOffset(), page.getLimit());    List&lt;Map&lt;String, Object&gt;&gt; noticeVoList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">if</span> (noticeList!=<span class="hljs-keyword">null</span>)&#123;        <span class="hljs-keyword">for</span> (Message notice: noticeList) &#123;            Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();            <span class="hljs-comment">// 通知</span>            map.put(<span class="hljs-string">&quot;notice&quot;</span>, notice);            <span class="hljs-comment">// 内容</span>            String content = HtmlUtils.htmlUnescape(notice.getContent());            Map&lt;String, Object&gt; data = JSONObject.parseObject(content, HashMap.class);            map.put(<span class="hljs-string">&quot;user&quot;</span>, userService.findUserById((Integer) data.get(<span class="hljs-string">&quot;userId&quot;</span>)));            map.put(<span class="hljs-string">&quot;entityType&quot;</span>, data.get(<span class="hljs-string">&quot;entityType&quot;</span>));            map.put(<span class="hljs-string">&quot;entityId&quot;</span>, data.get(<span class="hljs-string">&quot;entityId&quot;</span>));            map.put(<span class="hljs-string">&quot;postId&quot;</span>, data.get(<span class="hljs-string">&quot;postId&quot;</span>));            map.put(<span class="hljs-string">&quot;fromUser&quot;</span>, userService.findUserById(notice.getFromId()));            noticeVoList.add(map);        &#125;    &#125;    model.addAttribute(<span class="hljs-string">&quot;notices&quot;</span>, noticeVoList);    <span class="hljs-comment">// 设置已读</span>    List&lt;Integer&gt; ids = getMessageIds(noticeList);    <span class="hljs-keyword">if</span> (!ids.isEmpty())&#123;        messageService.readMessage(ids);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;site/notice-detail&quot;</span>;&#125;</code></pre></li><li><p>编写拦截器记录全局消息未读数</p><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageUnreadInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HandlerInterceptor</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> HostHolder hostHolder;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> MessageService messageService;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        User user = hostHolder.getUsers();        <span class="hljs-keyword">if</span> (user != <span class="hljs-keyword">null</span> &amp;&amp; modelAndView!=<span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">int</span> letterUnreadCount = messageService.findeLetterUnreadCount(user.getId(), <span class="hljs-keyword">null</span>);            <span class="hljs-keyword">int</span> noticeUnreadCount = messageService.findNoticeUnreadCount(user.getId(), <span class="hljs-keyword">null</span>);            modelAndView.addObject(<span class="hljs-string">&quot;unread&quot;</span>, letterUnreadCount + noticeUnreadCount);        &#125;    &#125;&#125;</code></pre></li><li><p>添加至WebMvcConfig</p><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><span class="hljs-keyword">private</span> MessageUnreadInterceptor messageUnreadInterceptor;    registry.addInterceptor(messageUnreadInterceptor)            .excludePathPatterns(<span class="hljs-string">&quot;/**/*.css&quot;</span>, <span class="hljs-string">&quot;/**/*.js&quot;</span>, <span class="hljs-string">&quot;/**/*.png&quot;</span>, <span class="hljs-string">&quot;/**/*.jpg&quot;</span>, <span class="hljs-string">&quot;/**/*.jpeg&quot;</span>);&#125;</code></pre></li><li><p>修改模版引擎（查看源文件）</p></li></ol><h3 id="开发流程图-8"><a href="#开发流程图-8" class="headerlink" title="开发流程图"></a>开发流程图</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201223111729.png" alt="流程图"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201223112157.png" alt="拦截器"></p><h1 id="ES与Security模块"><a href="#ES与Security模块" class="headerlink" title="ES与Security模块"></a>ES与Security模块</h1><h2 id="Spring-整合-Elastic-Search"><a href="#Spring-整合-Elastic-Search" class="headerlink" title="Spring 整合 Elastic Search"></a>Spring 整合 Elastic Search</h2><ul><li>引入依赖<ul><li>spirng-boot-starter-data-elastcsearch</li></ul></li><li>配置Elasticsearch<ul><li>cluster-name、cluster-nodes</li></ul></li><li>Spring Data Elasticsearch<ul><li>ElasticsearchTemplate</li><li>ElasticsearchRepository</li></ul></li></ul><p>注意：Elasticsearch版本与Spring Boot版本必须严格遵循统一</p><p>本项目使用elasticsearch 6.4.3</p><h3 id="开发流程-14"><a href="#开发流程-14" class="headerlink" title="开发流程"></a>开发流程</h3><ol><li><p>Maven依赖</p><pre><code class="hljs java">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-elasticsearch&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre></li><li><p>配置es</p><pre><code class="hljs properties"><span class="hljs-comment"># ElasticSearchProperties</span><span class="hljs-meta">spring.data.elasticsearch.cluster-name</span>=<span class="hljs-string">nowcoder</span><span class="hljs-meta">spring.data.elasticsearch.cluster-nodes</span>=<span class="hljs-string">127.0.0.1:9300</span></code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201223113939.png" alt="配置本地"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201223114002.png" alt="与上面一致"></p></li></ol><ol start="3"><li><p>解决es和redis同时占用netty问题</p><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CommunityApplication</span> </span>&#123;    <span class="hljs-meta">@PostConstruct</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-comment">// 解决redis和es同时使用NettyRuntime启动冲突问题</span>        <span class="hljs-comment">// Netty4Utils setAvailableProcessors</span>        System.setProperty(<span class="hljs-string">&quot;es.set.netty.runtime.available.processors&quot;</span>, <span class="hljs-string">&quot;false&quot;</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(CommunityApplication.class, args);    &#125;&#125;</code></pre></li><li><p>配置表对象和es存储对应的索引关系</p><pre><code class="hljs java"><span class="hljs-meta">@Data</span><span class="hljs-meta">@AllArgsConstructor</span><span class="hljs-meta">@NoArgsConstructor</span><span class="hljs-meta">@Document(indexName = &quot;discusspost&quot;, type =&quot;_doc&quot;, shards = 6, replicas = 3)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DiscussPost</span> </span>&#123;    <span class="hljs-meta">@Id</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;    <span class="hljs-meta">@Field(type = FieldType.Integer)</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> userId;    <span class="hljs-comment">// 往es存 互联网校招 analyzer把搜索的内容进行拆解最多单词 进行搜索匹配</span>    <span class="hljs-comment">// searchAnalyzer 把搜索条目拆解最少单词, searchAnalyzer = &quot;ik_smart&quot;</span>    <span class="hljs-meta">@Field(type = FieldType.Text, analyzer = &quot;ik_max_word&quot;, searchAnalyzer = &quot;ik_smart&quot;)</span>    <span class="hljs-keyword">private</span> String title;    <span class="hljs-meta">@Field(type = FieldType.Text, analyzer = &quot;ik_max_word&quot;, searchAnalyzer = &quot;ik_smart&quot;)</span>    <span class="hljs-keyword">private</span> String content;    <span class="hljs-meta">@Field(type = FieldType.Integer)</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> type;    <span class="hljs-meta">@Field(type = FieldType.Integer)</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> status;    <span class="hljs-meta">@Field(type = FieldType.Date)</span>    <span class="hljs-keyword">private</span> Date createTime;    <span class="hljs-meta">@Field(type = FieldType.Integer)</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> commentCount;    <span class="hljs-meta">@Field(type = FieldType.Double)</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> score;&#125;</code></pre><p>其中es的ik插件请前往github下载对应版本 <a href="https://github.com/medcl/elasticsearch-analysis-ik">ik</a></p></li><li><p>编写接口文件</p><pre><code class="hljs java"><span class="hljs-meta">@Repository</span><span class="hljs-comment">// 声明主键类型</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">DiscussPostRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ElasticsearchRepository</span>&lt;<span class="hljs-title">DiscussPost</span>, <span class="hljs-title">Integer</span>&gt; </span>&#123;&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201223114530.png" alt="es"></p></li><li><p>编写测试类（源文件给出）</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201223114717.png" alt="测试类"></p></li></ol><h2 id="搜索功能"><a href="#搜索功能" class="headerlink" title="搜索功能"></a>搜索功能</h2><ul><li>搜索服务<ul><li>将帖子保存至Elasticsearch服务器。</li><li>从Elasticsearch服务器删除帖子。</li><li>从Elasticsearch服务器搜索帖子。</li></ul></li><li>发布事件<ul><li>发布帖子时，将帖子异步的提交到Elasticsearch服务器。</li><li>增加评论时，将帖子异步的提交到Elasticsearch服务器。</li><li>在消费组件中增加一个方法，消费帖子发布事件。</li></ul></li><li>显示结果<ul><li>在控制器中处理搜索请求，在HTML上显示搜索结果。</li></ul></li></ul><h3 id="开发流程-15"><a href="#开发流程-15" class="headerlink" title="开发流程"></a>开发流程</h3><ol><li><p>编写ElasticsearchService</p><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ElasticSearchService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> DiscussPostRepository discussPostRepository;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> ElasticsearchTemplate elasticTemplate;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">saveDiscussPost</span><span class="hljs-params">(DiscussPost discussPost)</span></span>&#123;        discussPostRepository.save(discussPost);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteDiscussPost</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span></span>&#123;        discussPostRepository.deleteById(id);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Page&lt;DiscussPost&gt; <span class="hljs-title">searchDiscussPost</span><span class="hljs-params">(String keywords, <span class="hljs-keyword">int</span> current, <span class="hljs-keyword">int</span> limit)</span></span>&#123;        SearchQuery searchQuery = <span class="hljs-keyword">new</span> NativeSearchQueryBuilder()                .withQuery(QueryBuilders.multiMatchQuery(keywords, <span class="hljs-string">&quot;title&quot;</span>, <span class="hljs-string">&quot;content&quot;</span>))                .withSort(SortBuilders.fieldSort(<span class="hljs-string">&quot;type&quot;</span>).order(SortOrder.DESC))                .withSort(SortBuilders.fieldSort(<span class="hljs-string">&quot;score&quot;</span>).order(SortOrder.DESC))                .withSort(SortBuilders.fieldSort(<span class="hljs-string">&quot;createTime&quot;</span>).order(SortOrder.DESC))                .withPageable(PageRequest.of(current, limit))                .withHighlightFields(                        <span class="hljs-keyword">new</span> HighlightBuilder.Field(<span class="hljs-string">&quot;title&quot;</span>).preTags(<span class="hljs-string">&quot;&lt;em&gt;&quot;</span>).postTags(<span class="hljs-string">&quot;&lt;/em&gt;&quot;</span>),                        <span class="hljs-keyword">new</span> HighlightBuilder.Field(<span class="hljs-string">&quot;content&quot;</span>).preTags(<span class="hljs-string">&quot;&lt;em&gt;&quot;</span>).postTags(<span class="hljs-string">&quot;&lt;/em&gt;&quot;</span>)                ).build();        <span class="hljs-keyword">return</span> elasticTemplate.queryForPage(searchQuery, DiscussPost.class, <span class="hljs-keyword">new</span> SearchResultMapper() &#123;                       <span class="hljs-meta">@Override</span>            <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">AggregatedPage&lt;T&gt; <span class="hljs-title">mapResults</span><span class="hljs-params">(SearchResponse response, Class&lt;T&gt; aClass, Pageable pageable)</span> </span>&#123;                SearchHits hits = response.getHits();                <span class="hljs-keyword">if</span> (hits.getTotalHits() &lt;= <span class="hljs-number">0</span>) &#123;                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;                &#125;                List&lt;DiscussPost&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();                <span class="hljs-keyword">for</span> (SearchHit hit : hits) &#123;                    DiscussPost post = <span class="hljs-keyword">new</span> DiscussPost();                    String id = hit.getSourceAsMap().get(<span class="hljs-string">&quot;id&quot;</span>).toString();                    post.setId(Integer.valueOf(id));                    String userId = hit.getSourceAsMap().get(<span class="hljs-string">&quot;userId&quot;</span>).toString();                    post.setUserId(Integer.valueOf(userId));                    String title = hit.getSourceAsMap().get(<span class="hljs-string">&quot;title&quot;</span>).toString();                    post.setTitle(title);                    String content = hit.getSourceAsMap().get(<span class="hljs-string">&quot;content&quot;</span>).toString();                    post.setContent(content);                    String status = hit.getSourceAsMap().get(<span class="hljs-string">&quot;status&quot;</span>).toString();                    post.setStatus(Integer.valueOf(status));                    String createTime = hit.getSourceAsMap().get(<span class="hljs-string">&quot;createTime&quot;</span>).toString();                    post.setCreateTime(<span class="hljs-keyword">new</span> Date(Long.valueOf(createTime)));                    String commentCount = hit.getSourceAsMap().get(<span class="hljs-string">&quot;commentCount&quot;</span>).toString();                    post.setCommentCount(Integer.valueOf(commentCount));                    <span class="hljs-comment">// 处理高亮显示的结果</span>                    HighlightField titleField = hit.getHighlightFields().get(<span class="hljs-string">&quot;title&quot;</span>);                    <span class="hljs-keyword">if</span> (titleField != <span class="hljs-keyword">null</span>) &#123;                        post.setTitle(titleField.getFragments()[<span class="hljs-number">0</span>].toString());                    &#125;                    HighlightField contentField = hit.getHighlightFields().get(<span class="hljs-string">&quot;content&quot;</span>);                    <span class="hljs-keyword">if</span> (contentField != <span class="hljs-keyword">null</span>) &#123;                        post.setContent(contentField.getFragments()[<span class="hljs-number">0</span>].toString());                    &#125;                    list.add(post);                &#125;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AggregatedPageImpl(list, pageable,                        hits.getTotalHits(), response.getAggregations(), response.getScrollId(), hits.getMaxScore());            &#125;            <span class="hljs-meta">@Override</span>            <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">mapSearchHit</span><span class="hljs-params">(SearchHit searchHit, Class&lt;T&gt; aClass)</span> </span>&#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;            &#125;        &#125;);    &#125;&#125;</code></pre></li><li><p>处理发帖事件</p><p>常量接口添加：</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 主题:发帖</span><span class="hljs-comment"> */</span>String TOPIC_PUBLISH = <span class="hljs-string">&quot;publish&quot;</span>;</code></pre></li><li><p>处理事件消费者</p><pre><code class="hljs java"><span class="hljs-meta">@KafkaListener(topics = TOPIC_PUBLISH)</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleEventPublish</span><span class="hljs-params">(ConsumerRecord record)</span></span>&#123;    <span class="hljs-keyword">if</span> (record == <span class="hljs-keyword">null</span> || record.value() == <span class="hljs-keyword">null</span>)&#123;        <span class="hljs-comment">// 空消息</span>        logger.error(<span class="hljs-string">&quot;消息内容为空！&quot;</span>);        <span class="hljs-keyword">return</span>;    &#125;    Event event = JSONObject.parseObject(record.value().toString(), Event.class);    <span class="hljs-keyword">if</span> (event == <span class="hljs-keyword">null</span>)&#123;        logger.error(<span class="hljs-string">&quot;消息格式为空！&quot;</span>);        <span class="hljs-keyword">return</span>;    &#125;    DiscussPost post = discussPostService.findDiscussPostById(event.getEntityId());    elasticSearchService.saveDiscussPost(post);&#125;</code></pre></li><li><p>DiscusspostController处理发帖事件</p><pre><code class="hljs java"><span class="hljs-comment">// 触发发帖事件</span>Event event = <span class="hljs-keyword">new</span> Event()        .setTopic(TOPIC_PUBLISH)        .setUserId(user.getId())        .setEntityType(ENTITY_TYPE_POST)        .setEntityId(discussPost.getId());eventProducer.fireEvent(event);</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201223140158.png" alt="发帖事件"></p></li><li><p>CommentController 处理发帖事件</p><pre><code class="hljs java"><span class="hljs-keyword">if</span> (comment.getEntityType() == ENTITY_TYPE_POST)&#123;    <span class="hljs-comment">// 触发发帖事件</span>    event = <span class="hljs-keyword">new</span> Event()            .setTopic(TOPIC_PUBLISH)            .setUserId(comment.getUserId())            .setEntityType(ENTITY_TYPE_POST)            <span class="hljs-comment">// 更新的是帖子</span>            .setEntityId(discussPostId);    eventProducer.fireEvent(event);&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201223140313.png" alt="发帖事件"></p></li><li><p>编写SearchController</p><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SearchController</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CommunityConstant</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> UserService userService;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> ElasticSearchService elasticSearchService;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> LikeService likeService;    <span class="hljs-comment">//    /serach?keywords=</span>    <span class="hljs-meta">@RequestMapping(path = &quot;/search&quot;, method = RequestMethod.GET)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">search</span><span class="hljs-params">(String keywords, Page page, Model model)</span></span>&#123;        org.springframework.data.domain.Page&lt;DiscussPost&gt; discussPosts                = elasticSearchService.searchDiscussPost(keywords, page.getCurrent() - <span class="hljs-number">1</span>, page.getLimit());        List&lt;Map&lt;String, Object&gt;&gt; discussposts = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">for</span> (DiscussPost post: discussPosts             ) &#123;            Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();            <span class="hljs-comment">// 帖子</span>            map.put(<span class="hljs-string">&quot;post&quot;</span>, post);            <span class="hljs-comment">// 作者</span>            map.put(<span class="hljs-string">&quot;user&quot;</span>, userService.findUserById(post.getUserId()));            <span class="hljs-comment">// 点赞</span>            map.put(<span class="hljs-string">&quot;likeCount&quot;</span>, likeService.findEntityLikeCount(ENTITY_TYPE_POST, post.getId()));            discussposts.add(map);        &#125;        <span class="hljs-comment">// 分页信息</span>        page.setPath(<span class="hljs-string">&quot;/search?keywords=&quot;</span>+keywords);        page.setRows(discussPosts == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : (<span class="hljs-keyword">int</span>) discussPosts.getTotalElements());        model.addAttribute(<span class="hljs-string">&quot;discussPosts&quot;</span>, discussposts);        model.addAttribute(<span class="hljs-string">&quot;keywords&quot;</span>, keywords);        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;site/search&quot;</span>;    &#125;&#125;</code></pre></li><li><p>处理模版引擎</p></li></ol><h3 id="开发流程图-9"><a href="#开发流程图-9" class="headerlink" title="开发流程图"></a>开发流程图</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201223142518.png" alt="流程图"></p><h2 id="Spring-Security-权限管理"><a href="#Spring-Security-权限管理" class="headerlink" title="Spring Security 权限管理"></a>Spring Security 权限管理</h2><h3 id="Spring-Security原理大概"><a href="#Spring-Security原理大概" class="headerlink" title="Spring Security原理大概"></a>Spring Security原理大概</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201223143326.png" alt="原理"></p><ul><li>登录检查<ul><li>之前采用拦截器实现了登录检查,这是简单的权限管理方案,现在将其废弃。</li></ul></li><li>授权配置<ul><li>对当前系统内包含的所有的请求，分配访问权限(普通用户、版主、管理员)。</li></ul></li><li>认证方案<ul><li>绕过Security认证流程, 采用系统原来的认证方案。</li></ul></li><li>CSRF配置<ul><li>防止CSRF攻击的基本原理，以及表单、AJAX相关的配置。</li></ul></li></ul><blockquote><p>Spring Security 写的我差点脑溢血</p></blockquote><h3 id="开发流程-16"><a href="#开发流程-16" class="headerlink" title="开发流程"></a>开发流程</h3><ol><li><p>Maven引入</p><pre><code class="hljs java">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre></li><li><p>废弃之前的LoginRequired注解</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201223143832.png" alt="废弃"></p></li></ol><ol start="3"><li><p>常量接口增加权限常量</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 普通用户</span><span class="hljs-comment"> */</span>String AUTHORITY_USER = <span class="hljs-string">&quot;user&quot;</span>;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 管理员(删除)</span><span class="hljs-comment"> */</span>String AUTHORITY_ADMIN = <span class="hljs-string">&quot;admin&quot;</span>;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 版主(置顶、加精)</span><span class="hljs-comment"> */</span>String AUTHORITY_MODERATOR = <span class="hljs-string">&quot;moderator&quot;</span>;</code></pre></li><li><p>SecurityConfig配置</p><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringSecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CommunityConstant</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(WebSecurity web)</span> </span>&#123;        web.ignoring().antMatchers(<span class="hljs-string">&quot;/resources/**&quot;</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        http.authorizeRequests()                .antMatchers(                      <span class="hljs-string">&quot;/user/setting&quot;</span>,<span class="hljs-string">&quot;/user/upload&quot;</span>,<span class="hljs-string">&quot;/user/updatePassword&quot;</span>,<span class="hljs-string">&quot;/user/mypost&quot;</span>,<span class="hljs-string">&quot;/user/myreply&quot;</span>,                        <span class="hljs-string">&quot;/discuss/add&quot;</span>, <span class="hljs-string">&quot;/comment/add/**&quot;</span>, <span class="hljs-string">&quot;/message/**&quot;</span>,                        <span class="hljs-string">&quot;/like&quot;</span>, <span class="hljs-string">&quot;/follow&quot;</span>, <span class="hljs-string">&quot;/unfollow&quot;</span>                )                .hasAnyAuthority(                        AUTHORITY_USER, AUTHORITY_MODERATOR, AUTHORITY_ADMIN                )                .antMatchers(                        <span class="hljs-string">&quot;/discuss/top&quot;</span>,                        <span class="hljs-string">&quot;/discuss/wonderful&quot;</span>                )                .hasAnyAuthority(                        AUTHORITY_MODERATOR                )                .antMatchers(                        <span class="hljs-string">&quot;/data/**&quot;</span>,                        <span class="hljs-string">&quot;/discuss/delete&quot;</span>,                        <span class="hljs-string">&quot;/actuator/**&quot;</span>                )                .hasAnyAuthority(                        AUTHORITY_ADMIN                )                .anyRequest().permitAll()                .and().csrf().disable();        <span class="hljs-comment">// 权限冲突处理 普通请求(返回html)和异步请求(返回json)</span>        http.exceptionHandling()                <span class="hljs-comment">// 未登录处理</span>                .authenticationEntryPoint(<span class="hljs-keyword">new</span> AuthenticationEntryPoint() &#123;                    <span class="hljs-meta">@Override</span>                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">commence</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, AuthenticationException e)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;                        <span class="hljs-comment">// 分普通和异步请求</span>                        String xRequestedWith = request.getHeader(<span class="hljs-string">&quot;x-requested-with&quot;</span>);                        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;XMLHttpRequest&quot;</span>.equals(xRequestedWith))&#123;                            <span class="hljs-comment">// 异步请求</span>                            response.setContentType(<span class="hljs-string">&quot;application/plain;charset=utf-8&quot;</span>);                            PrintWriter writer = response.getWriter();                            writer.write(CommunityUtil.getJSONString(<span class="hljs-number">403</span>, <span class="hljs-string">&quot;用户未登录!&quot;</span>));                        &#125;<span class="hljs-keyword">else</span> &#123;                            response.sendRedirect(request.getContextPath() + <span class="hljs-string">&quot;/login&quot;</span>);                        &#125;                    &#125;                &#125;)                <span class="hljs-comment">// 登录处理</span>                .accessDeniedHandler(<span class="hljs-keyword">new</span> AccessDeniedHandler() &#123;                    <span class="hljs-meta">@Override</span>                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, AccessDeniedException e)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;                        <span class="hljs-comment">// 分普通和异步请求</span>                        String xRequestedWith = request.getHeader(<span class="hljs-string">&quot;x-requested-with&quot;</span>);                        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;XMLHttpRequest&quot;</span>.equals(xRequestedWith))&#123;                            <span class="hljs-comment">// 异步请求</span>                            response.setContentType(<span class="hljs-string">&quot;application/plain;charset=utf-8&quot;</span>);                            PrintWriter writer = response.getWriter();                            writer.write(CommunityUtil.getJSONString(<span class="hljs-number">403</span>, <span class="hljs-string">&quot;用户权限不足&quot;</span>));                        &#125;<span class="hljs-keyword">else</span> &#123;                            response.sendRedirect(request.getContextPath() + <span class="hljs-string">&quot;/denied&quot;</span>);                        &#125;                    &#125;                &#125;);        <span class="hljs-comment">// SpringSecurity底层默认拦截/logout请求,并运行其logout逻辑</span>        <span class="hljs-comment">// SpringSecurity为Filter filter在controller之前</span>        <span class="hljs-comment">// 想要运行自己的/logout 覆盖其默认逻辑 欺骗</span>        http.logout().logoutUrl(<span class="hljs-string">&quot;/securitylogout&quot;</span>);    &#125;&#125;</code></pre></li><li><p>UserService权限配置</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> Collection&lt;? extends GrantedAuthority&gt; getAuthorities(<span class="hljs-keyword">int</span> userId) &#123;    User user = userMapper.selectById(userId);    List&lt;GrantedAuthority&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    list.add(<span class="hljs-keyword">new</span> GrantedAuthority() &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getAuthority</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">switch</span> (user.getType()) &#123;                <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:                    <span class="hljs-keyword">return</span> AUTHORITY_ADMIN;                <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:                    <span class="hljs-keyword">return</span> AUTHORITY_MODERATOR;                    <span class="hljs-keyword">default</span>:                        <span class="hljs-keyword">return</span> AUTHORITY_USER;            &#125;        &#125;    &#125;);    <span class="hljs-keyword">return</span> list;&#125;</code></pre></li><li><p>拦截器预判断用户权限</p><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    <span class="hljs-comment">// 从cookie中获取ticket</span>    String ticket = CookieUtil.getValue(request, <span class="hljs-string">&quot;ticket&quot;</span>);    <span class="hljs-keyword">if</span> (ticket != <span class="hljs-keyword">null</span>)&#123;        <span class="hljs-comment">// 查询</span>        LoginTicket loginTicket = userService.findLoginTicket(ticket);        <span class="hljs-comment">// 检测有效</span>        <span class="hljs-keyword">if</span> (loginTicket != <span class="hljs-keyword">null</span> &amp;&amp; loginTicket.getStatus() == <span class="hljs-number">0</span> &amp;&amp; loginTicket.getExpired().after(<span class="hljs-keyword">new</span> Date()))&#123;            <span class="hljs-comment">// 根据凭证找到用户</span>            User user = userService.findUserById(loginTicket.getUserId());            <span class="hljs-comment">// 在本次请求中持有用户</span>            hostHolder.setUsers(user);            <span class="hljs-comment">// 构建用户认证结果 存入SecurityContext 以便与security进行授权(越过了security认证 用了自己的认证 需要自己授权)</span>            Authentication authentication = <span class="hljs-keyword">new</span> UsernamePasswordAuthenticationToken(                    user, user.getPassword(), userService.getAuthorities(user.getId())            );            SecurityContextHolder.setContext(<span class="hljs-keyword">new</span> SecurityContextImpl(authentication));        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201223144555.png" alt="退出功能"></p></li></ol><h2 id="置顶、加精、删除"><a href="#置顶、加精、删除" class="headerlink" title="置顶、加精、删除"></a>置顶、加精、删除</h2><ul><li>功能实现<ul><li>点击置顶，修改帖子的类型。</li><li>点击“加精”、“删除”， 修改帖子的状态。</li></ul></li><li>权限管理<ul><li>版主可以执行“置顶”</li><li>管理员可以执行“删除”操作。</li></ul></li><li>按钮显示<ul><li>版主可以看到“置顶”</li><li>管理员可以看到“删除”按钮。</li></ul></li></ul><h3 id="开发流程-17"><a href="#开发流程-17" class="headerlink" title="开发流程"></a>开发流程</h3><ol><li><p>Maven导入</p><pre><code class="hljs java">&lt;dependency&gt;    &lt;groupId&gt;org.thymeleaf.extras&lt;/groupId&gt;    &lt;artifactId&gt;thymeleaf-extras-springsecurity5&lt;/artifactId&gt;    &lt;version&gt;3.0.4.RELEASE&lt;/version&gt;&lt;/dependency&gt;</code></pre></li><li><p>便DiscusspostMapper 和 mapper文件</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">updateType</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, <span class="hljs-keyword">int</span> type)</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">updateStatus</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, <span class="hljs-keyword">int</span> status)</span></span>;</code></pre><pre><code class="hljs java">&lt;update id=<span class="hljs-string">&quot;updateType&quot;</span>&gt;    update discuss_post set type = #&#123;type&#125;    where id = #&#123;id&#125;&lt;/update&gt;&lt;update id=<span class="hljs-string">&quot;updateStatus&quot;</span>&gt;    update discuss_post set status = #&#123;status&#125;    where id = #&#123;id&#125;&lt;/update&gt;</code></pre></li><li><p>编写DiscusspostService</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">updateType</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, <span class="hljs-keyword">int</span> type)</span></span>&#123;    <span class="hljs-keyword">return</span> discussPostMapper.updateType(id, type);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">updateStatus</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, <span class="hljs-keyword">int</span> status)</span></span>&#123;    <span class="hljs-keyword">return</span> discussPostMapper.updateStatus(id, status);&#125;</code></pre></li><li><p>编写DiscusspostController</p><pre><code class="hljs java"><span class="hljs-comment">// 置顶</span><span class="hljs-meta">@RequestMapping(path = &quot;/top&quot;, method = RequestMethod.POST)</span><span class="hljs-meta">@ResponseBody</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">setTop</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span></span>&#123;    discussPostService.updateType(id, <span class="hljs-number">1</span>);    <span class="hljs-comment">// 触发发帖事件 ES更新</span>    Event event = <span class="hljs-keyword">new</span> Event()            .setTopic(TOPIC_PUBLISH)            .setUserId(hostHolder.getUsers().getId())            .setEntityType(ENTITY_TYPE_POST)            .setEntityId(id);    eventProducer.fireEvent(event);    <span class="hljs-keyword">return</span> CommunityUtil.getJSONString(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;置顶成功！&quot;</span>);&#125;<span class="hljs-comment">// 加精</span><span class="hljs-meta">@RequestMapping(path = &quot;/wonderful&quot;, method = RequestMethod.POST)</span><span class="hljs-meta">@ResponseBody</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">setWonderful</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span></span>&#123;    discussPostService.updateStatus(id, <span class="hljs-number">1</span>);    <span class="hljs-comment">// 触发发帖事件 ES更新</span>    Event event = <span class="hljs-keyword">new</span> Event()            .setTopic(TOPIC_PUBLISH)            .setUserId(hostHolder.getUsers().getId())            .setEntityType(ENTITY_TYPE_POST)            .setEntityId(id);    eventProducer.fireEvent(event);&#125;<span class="hljs-comment">// 删除</span><span class="hljs-meta">@RequestMapping(path = &quot;/delete&quot;, method = RequestMethod.POST)</span><span class="hljs-meta">@ResponseBody</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">setDelete</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span></span>&#123;    discussPostService.updateStatus(id, <span class="hljs-number">2</span>);    <span class="hljs-comment">// ES删除帖 触发删帖事件</span>    Event event = <span class="hljs-keyword">new</span> Event()            .setTopic(TOPIC_DELETE)            .setUserId(hostHolder.getUsers().getId())            .setEntityType(ENTITY_TYPE_POST)            .setEntityId(id);    eventProducer.fireEvent(event);    <span class="hljs-keyword">return</span> CommunityUtil.getJSONString(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;删除成功！&quot;</span>);&#125;</code></pre></li><li><p>编写js</p><pre><code class="hljs js"><span class="hljs-comment">// 置顶</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setTop</span>(<span class="hljs-params"></span>) </span>&#123;    $.post(        CONTEXT_PATH + <span class="hljs-string">&quot;/discuss/top&quot;</span>,        &#123;<span class="hljs-string">&quot;id&quot;</span>:$(<span class="hljs-string">&quot;#postId&quot;</span>).val()&#125;,        <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>) </span>&#123;            data = $.parseJSON(data);            <span class="hljs-keyword">if</span>(data.code == <span class="hljs-number">0</span>) &#123;                $(<span class="hljs-string">&quot;#topBtn&quot;</span>).attr(<span class="hljs-string">&quot;disabled&quot;</span>, <span class="hljs-string">&quot;disabled&quot;</span>);            &#125; <span class="hljs-keyword">else</span> &#123;                alert(data.msg);            &#125;        &#125;    );&#125;<span class="hljs-comment">// 加精</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setWonderful</span>(<span class="hljs-params"></span>) </span>&#123;    $.post(        CONTEXT_PATH + <span class="hljs-string">&quot;/discuss/wonderful&quot;</span>,        &#123;<span class="hljs-string">&quot;id&quot;</span>:$(<span class="hljs-string">&quot;#postId&quot;</span>).val()&#125;,        <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>) </span>&#123;            data = $.parseJSON(data);            <span class="hljs-keyword">if</span>(data.code == <span class="hljs-number">0</span>) &#123;                $(<span class="hljs-string">&quot;#wonderfulBtn&quot;</span>).attr(<span class="hljs-string">&quot;disabled&quot;</span>, <span class="hljs-string">&quot;disabled&quot;</span>);            &#125; <span class="hljs-keyword">else</span> &#123;                alert(data.msg);            &#125;        &#125;    );&#125;<span class="hljs-comment">// 删除</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setDelete</span>(<span class="hljs-params"></span>) </span>&#123;    $.post(        CONTEXT_PATH + <span class="hljs-string">&quot;/discuss/delete&quot;</span>,        &#123;<span class="hljs-string">&quot;id&quot;</span>:$(<span class="hljs-string">&quot;#postId&quot;</span>).val()&#125;,        <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>) </span>&#123;            data = $.parseJSON(data);            <span class="hljs-keyword">if</span>(data.code == <span class="hljs-number">0</span>) &#123;                location.href = CONTEXT_PATH + <span class="hljs-string">&quot;/index&quot;</span>;            &#125; <span class="hljs-keyword">else</span> &#123;                alert(data.msg);            &#125;        &#125;    );&#125;</code></pre></li><li><p>修改模版引擎</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201223145804.png" alt="权限"></p></li><li><p>SecurityConfig配置权限 源码已给出</p></li></ol><h3 id="开发流程图-10"><a href="#开发流程图-10" class="headerlink" title="开发流程图"></a>开发流程图</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201223150722.png" alt="流程图"></p><h1 id="额外功能丰富模块"><a href="#额外功能丰富模块" class="headerlink" title="额外功能丰富模块"></a>额外功能丰富模块</h1><h2 id="网站数据统计"><a href="#网站数据统计" class="headerlink" title="网站数据统计"></a>网站数据统计</h2><ul><li>UV (Unique Visitor)<ul><li>独立访客，需通过用户IP排重统计数据。</li><li>每次访问都要进行统计。</li><li>HyperLogLog，性能好，且存储空间小。</li></ul></li><li>DAU (Daily Active User)<ul><li>日活跃用户，需通过用户ID排重统计数据。访问过一次， 则认为其活跃。</li><li>Bitmap,性能好、且可以统计精确的结果</li></ul></li></ul><h3 id="开发流程-18"><a href="#开发流程-18" class="headerlink" title="开发流程"></a>开发流程</h3><ol><li><p>编写RedisKeyUtil</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String PREFIX_UV = <span class="hljs-string">&quot;uv&quot;</span>;   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String PREFIX_DAU = <span class="hljs-string">&quot;dau&quot;</span>;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getUVkey</span><span class="hljs-params">(String date)</span></span>&#123;    <span class="hljs-keyword">return</span> PREFIX_UV + SPILIT + date;&#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getUVkey</span><span class="hljs-params">(String startDate, String endDate)</span></span>&#123;    <span class="hljs-keyword">return</span> PREFIX_UV + SPILIT + startDate + SPILIT + endDate;&#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getDAUkey</span><span class="hljs-params">(String date)</span></span>&#123;    <span class="hljs-keyword">return</span> PREFIX_DAU + SPILIT + date;&#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getDAUkey</span><span class="hljs-params">(String startDate, String endDate)</span></span>&#123;    <span class="hljs-keyword">return</span> PREFIX_DAU + SPILIT + startDate + SPILIT + endDate;&#125;</code></pre><p>看一天/多天的</p></li><li><p>编写DataService</p><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DataService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> RedisTemplate redisTemplate;    <span class="hljs-keyword">private</span> SimpleDateFormat df = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyyMMdd&quot;</span>);    <span class="hljs-comment">// 将ip存入UV</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">recordUV</span><span class="hljs-params">(String ip)</span></span>&#123;        String redisKey = RedisKeyUtil.getUVkey(df.format(<span class="hljs-keyword">new</span> Date()));        redisTemplate.opsForHyperLogLog().add(redisKey, ip);    &#125;    <span class="hljs-comment">// 统计UV</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">calculateUV</span><span class="hljs-params">(Date start, Date end)</span></span>&#123;        <span class="hljs-keyword">if</span> (start == <span class="hljs-keyword">null</span> || end == <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;参数异常&quot;</span>);        &#125;        String redisKey = RedisKeyUtil.getUVkey(df.format(start), df.format(end));        List&lt;String&gt; keys = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        Calendar calendar = Calendar.getInstance();        calendar.setTime(start);        <span class="hljs-keyword">while</span> (!calendar.getTime().after(end))&#123;            String key = RedisKeyUtil.getUVkey(df.format(calendar.getTime()));            keys.add(key);            calendar.add(Calendar.DATE, <span class="hljs-number">1</span>);        &#125;        redisTemplate.opsForHyperLogLog().union(redisKey, keys.toArray());        <span class="hljs-keyword">return</span> redisTemplate.opsForHyperLogLog().size(redisKey);    &#125;    <span class="hljs-comment">// 将指定用户计入DAU</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">recordDAU</span><span class="hljs-params">(<span class="hljs-keyword">int</span> userId)</span></span>&#123;        String redisKey = RedisKeyUtil.getDAUkey(df.format(<span class="hljs-keyword">new</span> Date()));        redisTemplate.opsForValue().setBit(redisKey, userId, <span class="hljs-keyword">true</span>);    &#125;    <span class="hljs-comment">// 统计DAU</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">calculateDAU</span><span class="hljs-params">(Date start, Date end)</span></span>&#123;        <span class="hljs-keyword">if</span> (start == <span class="hljs-keyword">null</span> || end == <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;参数异常&quot;</span>);        &#125;        String redisKey = RedisKeyUtil.getDAUkey(df.format(start), df.format(end));        List&lt;<span class="hljs-keyword">byte</span>[]&gt; keys = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        Calendar calendar = Calendar.getInstance();        calendar.setTime(start);        <span class="hljs-keyword">while</span> (!calendar.getTime().after(end))&#123;            String key = RedisKeyUtil.getDAUkey(df.format(calendar.getTime()));            keys.add(key.getBytes());            calendar.add(Calendar.DATE, <span class="hljs-number">1</span>);        &#125;        <span class="hljs-comment">// 进行OR运算</span>        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">long</span>)redisTemplate.execute(<span class="hljs-keyword">new</span> RedisCallback() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">doInRedis</span><span class="hljs-params">(RedisConnection connection)</span> <span class="hljs-keyword">throws</span> DataAccessException </span>&#123;                connection.bitOp(RedisStringCommands.BitOperation.OR,                        redisKey.getBytes(), keys.toArray(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]));                <span class="hljs-keyword">return</span> connection.bitCount(redisKey.getBytes());            &#125;        &#125;);    &#125;&#125;</code></pre></li><li><p>编写data拦截器 统计并计入</p><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DataInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HandlerInterceptor</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> DataService dataService;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> HostHolder hostHolder;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">// 统计UV DAU</span>        <span class="hljs-comment">// UV:ip</span>        String ip = request.getRemoteHost();        dataService.recordUV(ip);        <span class="hljs-comment">// DAU:userId</span>        User user = hostHolder.getUsers();        <span class="hljs-keyword">if</span> (user!=<span class="hljs-keyword">null</span>)&#123;            dataService.recordDAU(user.getId());        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;</code></pre></li><li><p>WebMvcConfig添加拦截器</p><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><span class="hljs-keyword">private</span> DataInterceptor dataInterceptor;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> </span>&#123;    registry.addInterceptor(dataInterceptor)            .excludePathPatterns(<span class="hljs-string">&quot;/**/*.css&quot;</span>, <span class="hljs-string">&quot;/**/*.js&quot;</span>, <span class="hljs-string">&quot;/**/*.png&quot;</span>, <span class="hljs-string">&quot;/**/*.jpg&quot;</span>, <span class="hljs-string">&quot;/**/*.jpeg&quot;</span>);&#125;</code></pre></li><li><p>编写DataController</p><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DataController</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> DataService dataService;    <span class="hljs-comment">// 统计页面</span>    <span class="hljs-meta">@RequestMapping(path = &quot;/data&quot;, method = &#123;RequestMethod.GET, RequestMethod.POST&#125;)</span>    <span class="hljs-comment">// 后续用到转发 转发用的一个请求 后面为post</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getDataPage</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;site/admin/data&quot;</span>;    &#125;    <span class="hljs-comment">// 统计网站UV</span>    <span class="hljs-meta">@RequestMapping(path = &quot;/data/uv&quot;, method = RequestMethod.POST)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getUV</span><span class="hljs-params">(<span class="hljs-meta">@DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)</span> Date start,</span></span><span class="hljs-function"><span class="hljs-params">                        <span class="hljs-meta">@DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)</span> Date end, Model model)</span> </span>&#123;        <span class="hljs-keyword">long</span> uv = dataService.calculateUV(start, end);        model.addAttribute(<span class="hljs-string">&quot;uvResult&quot;</span>, uv);        model.addAttribute(<span class="hljs-string">&quot;uvStartDate&quot;</span>, start);        model.addAttribute(<span class="hljs-string">&quot;uvEndDate&quot;</span>, end);        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;forward:/data&quot;</span>;    &#125;    <span class="hljs-comment">// 统计活跃用户</span>    <span class="hljs-meta">@RequestMapping(path = &quot;/data/dau&quot;, method = RequestMethod.POST)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getDAU</span><span class="hljs-params">(<span class="hljs-meta">@DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)</span> Date start,</span></span><span class="hljs-function"><span class="hljs-params">                         <span class="hljs-meta">@DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)</span> Date end, Model model)</span> </span>&#123;        <span class="hljs-keyword">long</span> dau = dataService.calculateDAU(start, end);        model.addAttribute(<span class="hljs-string">&quot;dauResult&quot;</span>, dau);        model.addAttribute(<span class="hljs-string">&quot;dauStartDate&quot;</span>, start);        model.addAttribute(<span class="hljs-string">&quot;dauEndDate&quot;</span>, end);        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;forward:/data&quot;</span>;    &#125;&#125;</code></pre></li><li><p>处理模版引擎</p></li></ol><h3 id="开发流程图-11"><a href="#开发流程图-11" class="headerlink" title="开发流程图"></a>开发流程图</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201223161822.png" alt="流程图"></p><h2 id="热帖排行"><a href="#热帖排行" class="headerlink" title="热帖排行"></a>热帖排行</h2><ul><li>JDK线程池<ul><li>ExecutorService</li><li>ScheduledExecutorService</li></ul></li><li>Spring线程池<ul><li>ThreadPoolTaskExecutor</li><li>ThreadPoolTaskScheduler</li></ul></li><li>分布式定时任务<ul><li>Spring Quartz</li></ul></li></ul><p>JDK和Spring定时任务组件是基于内存的，配置参数基于内存，不同服务器内存不共享。</p><p>Quartz参数存到数据库，可以实现共享。</p><h3 id="Quartz原理"><a href="#Quartz原理" class="headerlink" title="Quartz原理"></a>Quartz原理</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201223162549.png" alt="原理图"></p><h3 id="Spring-整合-Quartz"><a href="#Spring-整合-Quartz" class="headerlink" title="Spring 整合 Quartz"></a>Spring 整合 Quartz</h3><ol><li><p>导入Quartz数据库</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201223162756.png" alt="Quartz_db"></p></li><li><p>Maven</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-quartz<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></li><li><p>配置</p><pre><code class="hljs properties"><span class="hljs-comment"># QuartzProperties</span><span class="hljs-meta">spring.quartz.job-store-type</span>=<span class="hljs-string">jdbc</span><span class="hljs-meta">spring.quartz.scheduler-name</span>=<span class="hljs-string">communityScheduler</span><span class="hljs-meta">spring.quartz.properties.org.quartz.scheduler.instanceId</span>=<span class="hljs-string">AUTO</span><span class="hljs-meta">spring.quartz.properties.org.quartz.jobStore.class</span>=<span class="hljs-string">org.quartz.impl.jdbcjobstore.JobStoreTX</span><span class="hljs-meta">spring.quartz.properties.org.quartz.jobStore.driverDelegateClass</span>=<span class="hljs-string">org.quartz.impl.jdbcjobstore.StdJDBCDelegate</span><span class="hljs-meta">spring.quartz.properties.org.quartz.jobStore.isClustered</span>=<span class="hljs-string">true</span><span class="hljs-meta">spring.quartz.properties.org.quartz.threadPool.class</span>=<span class="hljs-string">org.quartz.simpl.SimpleThreadPool</span><span class="hljs-meta">spring.quartz.properties.org.quartz.threadPool.threadCount</span>=<span class="hljs-string">5</span></code></pre></li></ol><h3 id="热帖开发流程"><a href="#热帖开发流程" class="headerlink" title="热帖开发流程"></a>热帖开发流程</h3><ol><li><p>编写rediskey</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String PREFIX_POST = <span class="hljs-string">&quot;post&quot;</span>; <span class="hljs-comment">//帖子分数(点赞加精等操作 存入postId)</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getPostScoreKey</span><span class="hljs-params">()</span></span>&#123;     <span class="hljs-keyword">return</span> PREFIX_POST + SPILIT + <span class="hljs-string">&quot;score&quot;</span>; &#125;</code></pre></li><li><p>编写DiscusspotsController</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201223163417.png" alt="1"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201223163438.png" alt="2"></p></li></ol><ol start="3"><li><p>编写likeController</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201223163525.png" alt="like"></p></li><li><p>编写CommentController</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201223163613.png" alt="comment"></p></li><li><p>编写job（任务）</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PostScoreRefreshJob</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Job</span>, <span class="hljs-title">CommunityConstant</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger logger = LoggerFactory.getLogger(PostScoreRefreshJob.class);    <span class="hljs-comment">// 牛客纪元</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Date epoch;    <span class="hljs-keyword">static</span> &#123;        <span class="hljs-keyword">try</span> &#123;            epoch = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>).parse(<span class="hljs-string">&quot;2014-08-01 00:00:00&quot;</span>);        &#125; <span class="hljs-keyword">catch</span> (ParseException e) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;初始化牛客纪元失败!&quot;</span>, e);        &#125;    &#125;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> RedisTemplate redisTemplate;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> DiscussPostService discussPostService;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> LikeService likeService;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> ElasticSearchService elasticSearchService;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(JobExecutionContext context)</span> <span class="hljs-keyword">throws</span> JobExecutionException </span>&#123;        String redisKey = RedisKeyUtil.getPostScoreKey();        BoundSetOperations operations = redisTemplate.boundSetOps(redisKey);        <span class="hljs-keyword">if</span> (operations.size() == <span class="hljs-number">0</span>) &#123;            logger.info(<span class="hljs-string">&quot;[任务取消] 没有需要刷新的帖子!&quot;</span>);            <span class="hljs-keyword">return</span>;        &#125;        logger.info(<span class="hljs-string">&quot;[任务开始] 正在刷新帖子分数: &quot;</span> + operations.size());        <span class="hljs-keyword">while</span> (operations.size() &gt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">this</span>.refresh((Integer) operations.pop());        &#125;        logger.info(<span class="hljs-string">&quot;[任务结束] 帖子分数刷新完毕!&quot;</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">refresh</span><span class="hljs-params">(<span class="hljs-keyword">int</span> postId)</span> </span>&#123;        DiscussPost post = discussPostService.findDiscussPostById(postId);        <span class="hljs-keyword">if</span> (post == <span class="hljs-keyword">null</span>) &#123;            logger.error(<span class="hljs-string">&quot;该帖子不存在: id = &quot;</span> + postId);            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">// 是否精华</span>        <span class="hljs-keyword">boolean</span> wonderful = post.getStatus() == <span class="hljs-number">1</span>;        <span class="hljs-comment">// 评论数量</span>        <span class="hljs-keyword">int</span> commentCount = post.getCommentCount();        <span class="hljs-comment">// 点赞数量</span>        <span class="hljs-keyword">long</span> likeCount = likeService.findEntityLikeCount(ENTITY_TYPE_POST, postId);        <span class="hljs-comment">// 计算权重</span>        <span class="hljs-keyword">double</span> w = (wonderful ? <span class="hljs-number">75</span> : <span class="hljs-number">0</span>) + commentCount * <span class="hljs-number">10</span> + likeCount * <span class="hljs-number">2</span>;        <span class="hljs-comment">// 分数 = 帖子权重 + 距离天数</span>        <span class="hljs-keyword">double</span> score = Math.log10(Math.max(w, <span class="hljs-number">1</span>))                + (post.getCreateTime().getTime() - epoch.getTime()) / (<span class="hljs-number">1000</span> * <span class="hljs-number">3600</span> * <span class="hljs-number">24</span>);        <span class="hljs-comment">// 更新帖子分数</span>        discussPostService.updateScore(postId, score);        <span class="hljs-comment">// 同步搜索数据</span>        post.setScore(score);        elasticSearchService.saveDiscussPost(post);    &#125;&#125;</code></pre></li><li><p>编写DiscusspostService</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">updateScore</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, <span class="hljs-keyword">double</span> score)</span></span>&#123;    <span class="hljs-keyword">return</span> discussPostMapper.updateScore(id, score);&#125;</code></pre></li><li><p>编写QuartzConfig</p><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-comment">// 配置 -&gt; 数据库 -&gt; 访问db调度任务</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QuartzConfig</span> </span>&#123;    <span class="hljs-comment">// BeanFactory 是IOC容器顶层接口</span>    <span class="hljs-comment">// FactoryBean 可简化Bean的实例化过程:</span>    <span class="hljs-comment">// 1.Spring通过FactoryBean封装了Bean的实例化过程</span>    <span class="hljs-comment">// 2.将FactoryBean装配到Spring容器中</span>    <span class="hljs-comment">// 3.将FactoryBean注入给其他的Bean</span>    <span class="hljs-comment">// 4.该Bean得到的是FactoryBean所管理的对象实例</span>    <span class="hljs-comment">// 配置JobDetail</span>    <span class="hljs-comment">//@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> JobDetailFactoryBean <span class="hljs-title">jobDetailTest</span><span class="hljs-params">()</span></span>&#123;        JobDetailFactoryBean jobDetailFactoryBean = <span class="hljs-keyword">new</span>  JobDetailFactoryBean();        jobDetailFactoryBean.setJobClass(JobTest.class);        jobDetailFactoryBean.setName(<span class="hljs-string">&quot;JobTest&quot;</span>);        jobDetailFactoryBean.setGroup(<span class="hljs-string">&quot;testJobGroup&quot;</span>);        <span class="hljs-comment">// 声明任务持久保存</span>        jobDetailFactoryBean.setDurability(<span class="hljs-keyword">true</span>);        <span class="hljs-comment">// 任务是否可恢复</span>        jobDetailFactoryBean.setRequestsRecovery(<span class="hljs-keyword">true</span>);        <span class="hljs-keyword">return</span> jobDetailFactoryBean;    &#125;    <span class="hljs-comment">// trigger 触发器 与 JobDetail有关系</span>    <span class="hljs-comment">// 配置Trigger(SimpleTriggerFactoryBean, CronTriggerFactoryBea(复杂,解决每个月月底何时xxx))</span>    <span class="hljs-comment">//@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> SimpleTriggerFactoryBean <span class="hljs-title">triggerTest</span><span class="hljs-params">(JobDetail jobDetailTest)</span></span>&#123;        SimpleTriggerFactoryBean factoryBean = <span class="hljs-keyword">new</span> SimpleTriggerFactoryBean();        factoryBean.setJobDetail(jobDetailTest);        factoryBean.setName(<span class="hljs-string">&quot;triggerTest&quot;</span>);        factoryBean.setGroup(<span class="hljs-string">&quot;testTriggerGroup&quot;</span>);        <span class="hljs-comment">// 执行频率</span>        factoryBean.setRepeatInterval(<span class="hljs-number">3000</span>);        <span class="hljs-comment">// trigger底层存储job状态</span>        factoryBean.setJobDataMap(<span class="hljs-keyword">new</span> JobDataMap());        <span class="hljs-keyword">return</span> factoryBean;    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> JobDetailFactoryBean <span class="hljs-title">postScoreRefreshJobDetail</span><span class="hljs-params">()</span></span>&#123;        JobDetailFactoryBean jobDetailFactoryBean = <span class="hljs-keyword">new</span>  JobDetailFactoryBean();        jobDetailFactoryBean.setJobClass(PostScoreRefreshJob.class);        jobDetailFactoryBean.setName(<span class="hljs-string">&quot;postScoreRefreshJob&quot;</span>);        jobDetailFactoryBean.setGroup(<span class="hljs-string">&quot;communityJobGroup&quot;</span>);        <span class="hljs-comment">// 声明任务持久保存</span>        jobDetailFactoryBean.setDurability(<span class="hljs-keyword">true</span>);        <span class="hljs-comment">// 任务是否可恢复</span>        jobDetailFactoryBean.setRequestsRecovery(<span class="hljs-keyword">true</span>);        <span class="hljs-keyword">return</span> jobDetailFactoryBean;    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> SimpleTriggerFactoryBean <span class="hljs-title">postScoreRefreshTrigger</span><span class="hljs-params">(JobDetail postScoreRefreshJobDetail)</span></span>&#123;        SimpleTriggerFactoryBean factoryBean = <span class="hljs-keyword">new</span> SimpleTriggerFactoryBean();        factoryBean.setJobDetail(postScoreRefreshJobDetail);        factoryBean.setName(<span class="hljs-string">&quot;postScoreRefreshTrigger&quot;</span>);        factoryBean.setGroup(<span class="hljs-string">&quot;communityTriggerGroup&quot;</span>);        <span class="hljs-comment">// 执行频率</span>        factoryBean.setRepeatInterval(<span class="hljs-number">1000</span> * <span class="hljs-number">60</span> * <span class="hljs-number">5</span>);        <span class="hljs-comment">// trigger底层存储job状态</span>        factoryBean.setJobDataMap(<span class="hljs-keyword">new</span> JobDataMap());        <span class="hljs-keyword">return</span> factoryBean;    &#125;&#125;</code></pre></li></ol><h3 id="开发流程图-12"><a href="#开发流程图-12" class="headerlink" title="开发流程图"></a>开发流程图</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201223164912.png" alt="流程图"></p><h2 id="头像上传七牛云"><a href="#头像上传七牛云" class="headerlink" title="头像上传七牛云"></a>头像上传七牛云</h2><h3 id="开发流程-19"><a href="#开发流程-19" class="headerlink" title="开发流程"></a>开发流程</h3><ol><li><p>Maven</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/com.qiniu/qiniu-java-sdk --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.qiniu<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>qiniu-java-sdk<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>7.2.28<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></li><li><p>配置qini</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201223165129.png" alt="配置"></p><p>具体依赖自己的qiniu配置</p></li><li><p>修改UserController</p><pre><code class="hljs java"><span class="hljs-meta">@Value(&quot;$&#123;qiniu.key.access&#125;&quot;)</span><span class="hljs-keyword">private</span> String accessKey;   <span class="hljs-meta">@Value(&quot;$&#123;qiniu.key.secret&#125;&quot;)</span><span class="hljs-keyword">private</span> String secretKey;   <span class="hljs-meta">@Value(&quot;$&#123;qiniu.bucket.header.name&#125;&quot;)</span><span class="hljs-keyword">private</span> String headerBucketName;   <span class="hljs-meta">@Value(&quot;$&#123;qiniu.bucket.header.url&#125;&quot;)</span><span class="hljs-keyword">private</span> String headerBucketUrl;   <span class="hljs-meta">@LoginRequired</span><span class="hljs-meta">@RequestMapping(path = &quot;/setting&quot;, method = RequestMethod.GET)</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getSettingPage</span><span class="hljs-params">(Model model)</span> </span>&#123;    <span class="hljs-comment">// 生成上传文件名称</span>    String fileName = CommunityUtil.generateUUID();    <span class="hljs-comment">// 设置响应信息</span>    StringMap policy = <span class="hljs-keyword">new</span> StringMap();    policy.put(<span class="hljs-string">&quot;returnBody&quot;</span>, CommunityUtil.getJSONString(<span class="hljs-number">0</span>));    <span class="hljs-comment">// 生成上传凭证</span>    Auth auth = Auth.create(accessKey, secretKey);    String uploadToken = auth.uploadToken(headerBucketName, fileName, <span class="hljs-number">3600</span>, policy);       model.addAttribute(<span class="hljs-string">&quot;uploadToken&quot;</span>, uploadToken);    model.addAttribute(<span class="hljs-string">&quot;fileName&quot;</span>, fileName);       <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;site/setting&quot;</span>;&#125;   <span class="hljs-comment">// 更新头像路径 异步</span><span class="hljs-meta">@RequestMapping(path = &quot;/header/url&quot;, method = RequestMethod.POST)</span><span class="hljs-meta">@ResponseBody</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">updateHeader</span><span class="hljs-params">(String fileName)</span> </span>&#123;    <span class="hljs-keyword">if</span> (StringUtils.isBlank(fileName)) &#123;        <span class="hljs-keyword">return</span> CommunityUtil.getJSONString(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;文件名不能为空&quot;</span>);    &#125;       String url = headerBucketUrl + <span class="hljs-string">&quot;/&quot;</span> + fileName;    userService.updateHeadUrl(hostHolder.getUsers().getId(), url);       <span class="hljs-keyword">return</span> CommunityUtil.getJSONString(<span class="hljs-number">0</span>);&#125;</code></pre></li><li><p>更新前端表单</p><pre><code class="hljs js">$(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;    $(<span class="hljs-string">&quot;#uploadForm&quot;</span>).submit(upload);&#125;);<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">upload</span>(<span class="hljs-params"></span>) </span>&#123;    $.ajax(&#123;        url: <span class="hljs-string">&quot;http://upload-z2.qiniup.com&quot;</span>,        method: <span class="hljs-string">&quot;post&quot;</span>,        processData: <span class="hljs-literal">false</span>,        contentType: <span class="hljs-literal">false</span>,        data: <span class="hljs-keyword">new</span> FormData($(<span class="hljs-string">&quot;#uploadForm&quot;</span>)[<span class="hljs-number">0</span>]),        success: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>) </span>&#123;            <span class="hljs-keyword">if</span>(data &amp;&amp; data.code == <span class="hljs-number">0</span>) &#123;                <span class="hljs-comment">// 更新头像访问路径</span>                $.post(                    CONTEXT_PATH + <span class="hljs-string">&quot;/user/header/url&quot;</span>,                    &#123;<span class="hljs-string">&quot;fileName&quot;</span>:$(<span class="hljs-string">&quot;input[name=&#x27;key&#x27;]&quot;</span>).val()&#125;,                    <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>) </span>&#123;                        data = $.parseJSON(data);                        <span class="hljs-keyword">if</span>(data.code == <span class="hljs-number">0</span>) &#123;                            <span class="hljs-built_in">window</span>.location.reload();                        &#125; <span class="hljs-keyword">else</span> &#123;                            alert(data.msg);                        &#125;                    &#125;                );            &#125; <span class="hljs-keyword">else</span> &#123;                alert(<span class="hljs-string">&quot;上传失败!&quot;</span>);            &#125;        &#125;    &#125;);    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;</code></pre></li><li><p>更新表单</p><pre><code class="hljs java">&lt;form <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;mt-5&quot;</span> id=<span class="hljs-string">&quot;uploadForm&quot;</span>&gt;   &lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;form-group row mt-4&quot;</span>&gt;      &lt;label for=&quot;head-image&quot; class=&quot;col-sm-2 col-form-label text-right&quot;&gt;选择头像:&lt;/label&gt;      &lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;col-sm-10&quot;</span>&gt;         &lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;custom-file&quot;</span>&gt;            &lt;input type=<span class="hljs-string">&quot;hidden&quot;</span> name=<span class="hljs-string">&quot;token&quot;</span> th:value=<span class="hljs-string">&quot;$&#123;uploadToken&#125;&quot;</span>&gt;            &lt;input type=<span class="hljs-string">&quot;hidden&quot;</span> name=<span class="hljs-string">&quot;key&quot;</span> th:value=<span class="hljs-string">&quot;$&#123;fileName&#125;&quot;</span>&gt;            &lt;input type=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;custom-file-input&quot;</span> id=<span class="hljs-string">&quot;head-image&quot;</span> name=<span class="hljs-string">&quot;file&quot;</span> lang=<span class="hljs-string">&quot;es&quot;</span> required=<span class="hljs-string">&quot;&quot;</span>&gt;            &lt;label class=&quot;custom-file-label&quot; for=&quot;head-image&quot; data-browse=&quot;文件&quot;&gt;选择一张图片&lt;/label&gt;            &lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;invalid-feedback&quot;</span>&gt;               该账号不存在!            &lt;/div&gt;         &lt;/div&gt;      &lt;/div&gt;   &lt;/div&gt;   &lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;form-group row mt-4&quot;</span>&gt;      &lt;div class=&quot;col-sm-2&quot;&gt;&lt;/div&gt;      &lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;col-sm-10 text-center&quot;</span>&gt;         &lt;button type=&quot;submit&quot; class=&quot;btn btn-info text-white form-control&quot;&gt;立即上传&lt;/button&gt;      &lt;/div&gt;   &lt;/div&gt;&lt;/form&gt;</code></pre></li></ol><h3 id="开发流程图-13"><a href="#开发流程图-13" class="headerlink" title="开发流程图"></a>开发流程图</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201223170535.png" alt="流程图"></p><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><ul><li>本地缓存<ul><li>将数据缓存在应用服务器上,性能最好。</li><li>常用缓存工具: Ehcache、 Guava、 Caffeine等。</li></ul></li><li>分布式缓存<ul><li>将数据缓存在NoSQL数据库上，跨服务器。常用缓存工具: MemCache、Redis等。</li></ul></li><li>多级缓存<ul><li>一级缓存(本地缓存)&gt;二级缓存(分布式缓存)&gt;DB</li></ul></li><li>避免缓存雪崩(缓存失效，大量请求直达DB )，提高系统的可用性。</li></ul><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201223171345.png" alt="redis共享缓存"></p><p>​       redis可以跨服务器</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201223171726.png" alt="redis单体"></p><h3 id="caffeine-作缓存开发流程"><a href="#caffeine-作缓存开发流程" class="headerlink" title="caffeine 作缓存开发流程"></a>caffeine 作缓存开发流程</h3><ol><li><p>Maven</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/com.github.ben-manes.caffeine/caffeine --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.ben-manes.caffeine<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>caffeine<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.8.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></li><li><p>配置caffeine</p><pre><code class="hljs properties"><span class="hljs-comment"># caffeine 缓存热帖</span><span class="hljs-meta">caffeine.posts.max-size</span>=<span class="hljs-string">15</span><span class="hljs-comment"># 三分钟</span><span class="hljs-meta">caffeine.posts.expire-seconds</span>=<span class="hljs-string">180</span></code></pre></li><li><p>编写DiscussPostService</p><pre><code class="hljs java"><span class="hljs-meta">@Value(&quot;$&#123;caffeine.posts.max-size&#125;&quot;)</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> maxSize;   <span class="hljs-meta">@Value(&quot;$&#123;caffeine.posts.expire-seconds&#125;&quot;)</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> expireSeconds;   <span class="hljs-comment">// caffeine 核心接口: Cache, LoadingCache, AsyncLoadingCache</span>   <span class="hljs-comment">// 缓存帖子列表</span><span class="hljs-keyword">private</span> LoadingCache&lt;String, List&lt;DiscussPost&gt;&gt; postListCache;   <span class="hljs-comment">// 缓存帖子总数</span><span class="hljs-keyword">private</span> LoadingCache&lt;Integer, Integer&gt; postRowsCache;   <span class="hljs-meta">@PostConstruct</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-comment">// 初始化缓存</span>    <span class="hljs-comment">// 帖子列表</span>    postListCache = Caffeine.newBuilder()            .maximumSize(maxSize)            .expireAfterWrite(expireSeconds, TimeUnit.SECONDS)            .build(<span class="hljs-keyword">new</span> CacheLoader&lt;String, List&lt;DiscussPost&gt;&gt;() &#123;                <span class="hljs-meta">@Nullable</span>                <span class="hljs-meta">@Override</span>                <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;DiscussPost&gt; <span class="hljs-title">load</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> String key)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                    <span class="hljs-keyword">if</span> (key == <span class="hljs-keyword">null</span> || key.length() == <span class="hljs-number">0</span>)&#123;                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;参数错误&quot;</span>);                    &#125;                       String[] params = key.split(<span class="hljs-string">&quot;:&quot;</span>);                    <span class="hljs-keyword">if</span> (params == <span class="hljs-keyword">null</span> || params.length!=<span class="hljs-number">2</span>)&#123;                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;参数错误&quot;</span>);                    &#125;                    <span class="hljs-keyword">int</span> offset = Integer.valueOf(params[<span class="hljs-number">0</span>]);                    <span class="hljs-keyword">int</span> limit = Integer.valueOf(params[<span class="hljs-number">1</span>]);                    <span class="hljs-comment">// 可以加入二级缓存:Redis -&gt; mysql</span>                    logger.debug(<span class="hljs-string">&quot;load post list from DB.&quot;</span>);                    <span class="hljs-keyword">return</span> discussPostMapper.selectDiscussPosts(<span class="hljs-number">0</span>, offset, limit, <span class="hljs-number">1</span>);                &#125;            &#125;);    <span class="hljs-comment">// 帖子总数</span>    postRowsCache = Caffeine.newBuilder()            .maximumSize(maxSize)            .expireAfterWrite(expireSeconds, TimeUnit.SECONDS)            .build(<span class="hljs-keyword">new</span> CacheLoader&lt;Integer, Integer&gt;() &#123;                <span class="hljs-meta">@Nullable</span>                <span class="hljs-meta">@Override</span>                <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">load</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Integer integer)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                    logger.debug(<span class="hljs-string">&quot;load post rows from DB.&quot;</span>);                    <span class="hljs-keyword">return</span> discussPostMapper.selectDiscussPostRows(integer);                &#125;            &#125;);&#125;</code></pre></li><li><p>对find方法修改</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201223172210.png" alt="修改"></p></li></ol><h3 id="caffeine缓存性能测试"><a href="#caffeine缓存性能测试" class="headerlink" title="caffeine缓存性能测试"></a>caffeine缓存性能测试</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201223173220.png" alt="添加缓存"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201223173259.png" alt="添加缓存"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201223173344.png" alt="优化去除后"></p><p>再次测试</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201223173436.png" alt="吞吐量变化"></p>]]></content>
    
    
    
    <tags>
      
      <tag>项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM解密</title>
    <link href="/2020/12/02/JVM%E8%A7%A3%E5%AF%86/"/>
    <url>/2020/12/02/JVM%E8%A7%A3%E5%AF%86/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><h2 id="什么是JVM"><a href="#什么是JVM" class="headerlink" title="什么是JVM?"></a>什么是JVM?</h2><blockquote><p>定义</p></blockquote><p>​    Java Virtual Machine - java 程序的运行环境(java 二进制字节码的运行环境)</p><blockquote><p>好处</p></blockquote><ul><li>一次编写，到处运行的一个基石</li><li>自动内存的管理机制，提供垃圾回收功能</li><li>数组下标越界的检查</li><li>实现多态</li></ul><blockquote><p>比较</p></blockquote><p>​    jvm jre jdk(java开发工具包):</p><p>​    <img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201202202613.png" alt="区别" style="zoom:50%;" /></p><p>​    JVM去屏蔽java代码与底层操作系统的差异</p><blockquote><p>常见的JVM</p></blockquote><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201202203444.png" alt="JVM种类"></p><h1 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h1><h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201202203747.png" alt="整体架构"></p><pre><code class="hljs mipsasm">ClassLoader为类加载器，<span class="hljs-keyword">java源代码编译为java二进制字节码后通过类加载器加载到JVM里运行，类放在方法区，</span><span class="hljs-keyword">创建的实例、对象放在堆里，其间所用到的方法放入虚拟机栈、程序计数器以及本地方法栈，方法执行时每行代码由</span><span class="hljs-keyword">执行引擎解释器逐行执行，方法中的热点代码(频繁调用的代码)由JIT优化后执行，GC对堆中不再被引用的对象引用</span><span class="hljs-keyword">回收。与操作系统打交道则需要本地方法接口调用</span></code></pre><h2 id="1、程序计数器"><a href="#1、程序计数器" class="headerlink" title="1、程序计数器"></a>1、程序计数器</h2><h3 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h3><blockquote><p>Program Counter Register 程序计数器(寄存器)</p></blockquote><h3 id="1-2-作用"><a href="#1-2-作用" class="headerlink" title="1.2 作用"></a>1.2 作用</h3><ul><li><p>作用:  记住下一条jvm指令的执行地址</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201202205624.png" alt="执行流程"></p><p>​        java源代码被编译成为 <strong>二进制字节码, 左侧为jvm指令</strong>, 对所有平台都是一致的, 指令交给解释器翻译为机器码, 再交给cpu执行, 期间 <strong>程序计数器</strong>记录下一条指令地址, 物理上 <strong>程序计数器由寄存器实现</strong>, 是cpu上读取最快的单元</p></li><li><p>特点:  </p><ul><li><p><strong>线程私有的</strong></p><ul><li>CPU会为每个线程分配时间片，当当前线程的时间片使用完以后，CPU就会去执行另一个线程中的代码</li><li>程序计数器是 <strong>每个线程</strong> 所 <strong>私有</strong> 的，每个线程都有自己的程序计数器，当另一个线程的时间片用完，又返回来执行当前线程的代码时，通过程序计数器可以知道应该执行哪一句指令</li></ul></li><li><p> 唯一一个<strong>不会存在内存溢出</strong>的区</p></li></ul></li></ul><h2 id="2、虚拟机栈"><a href="#2、虚拟机栈" class="headerlink" title="2、虚拟机栈"></a>2、虚拟机栈</h2><h3 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h3><blockquote><p>Java Virtual Machine Stacks (Java 虚拟机栈)</p></blockquote><ul><li>每个 <strong>线程</strong> 运行需要的内存空间，称为 <strong>虚拟机栈</strong></li><li>每个栈由多个 <strong>栈帧</strong> 组成，对应着每次调用方法时所占用的内存</li><li>每个线程只能有 <strong>一个活动栈帧</strong> ，对应着 <strong>当前正在执行的方法</strong></li></ul><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201202210927.png" alt="例子" style="zoom:50%;" /><h3 id="2-2-演示"><a href="#2-2-演示" class="headerlink" title="2.2 演示"></a>2.2 演示</h3><p>代码：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo_01</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        method1();    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span> </span>&#123;        method2(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">method2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;        <span class="hljs-keyword">int</span> c =  a + b;        <span class="hljs-keyword">return</span> c;    &#125;&#125;</code></pre><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201202211143.png" alt="图样" style="zoom:50%;" /><h3 id="2-3-栈问题"><a href="#2-3-栈问题" class="headerlink" title="2.3 栈问题"></a>2.3 栈问题</h3><ul><li><p>垃圾回收是否涉及 <strong>栈内存</strong>？</p><ul><li><p> <strong>不需要</strong>，因为虚拟机栈中是由一个个栈帧组成的，在方法执行完毕后，对应的 <strong>栈帧就会被弹出栈</strong>。所以无需通过垃圾回收机制去回收内存。</p></li><li><p>垃圾回收是对 <strong>堆内存</strong> 中的无用对象回收。</p></li></ul></li><li><p><strong>栈内存分配越大越好吗</strong>？</p><ul><li><p><a href="https://docs.oracle.com/en/java/javase/11/tools/java.html#GUID-3B1CE181-CD30-4178-9602-230B800D4FAE">引用</a></p></li><li><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201203182734.png" alt="栈帧分配"></p></li><li><p>不是。因为 <strong>物理内存是一定的</strong>，栈内存越大，可以支持更多的递归调用，但是 <strong>可执行的线程数就会越少</strong>。</p></li></ul></li><li><p>方法内的局部变量是否是线程安全的？</p><ul><li><p>如果方法内 <strong>局部变量没有逃离方法的作用范围</strong>，则是 <strong>线程安全</strong>的</p></li><li><p>如果如果 <strong>局部变量引用了对象</strong>，并<strong>逃离了方法的作用范围</strong>，则需要考虑线程安全问题</p></li></ul></li></ul><p>  例子:</p>  <pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 局部变量的线程安全问题</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo_01_18</span> </span>&#123;    <span class="hljs-comment">// 多个线程同时执行此方法</span>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m1</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;            x++;        &#125;        System.out.println(x);    &#125;&#125;</code></pre><p>  x变量为方法内的局部变量，一个线程一个栈，每次方法调用都产生一个栈帧，分配局部变量。</p>  <img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201203183431.png" alt="局部变量" style="zoom: 33%;" /><p>  现在每个线程都有一个私有的x变量，各自加五千互不干扰，最终都得出相同的结果。</p><p>   <strong>但如果x为 int static</strong> ，结果就不一样:</p>  <img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201203183659.png" alt="static" style="zoom:33%;" /><p>​    但如果例子为:</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 局部变量的线程安全问题</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo_01_17</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();        sb.append(<span class="hljs-number">4</span>);        sb.append(<span class="hljs-number">5</span>);        sb.append(<span class="hljs-number">6</span>);        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;            m2(sb);        &#125;).start();    &#125;  <span class="hljs-comment">// m1()不会产生线程安全问题，sb为局部变量，线程私有</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m1</span><span class="hljs-params">()</span> </span>&#123;        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();        sb.append(<span class="hljs-number">1</span>);        sb.append(<span class="hljs-number">2</span>);        sb.append(<span class="hljs-number">3</span>);        System.out.println(sb.toString());    &#125;<span class="hljs-comment">// m2()会产生线程安全问题，sb对多个线程是共享的(例如main函数里，main线程和新线程都在修改sb)</span>  <span class="hljs-comment">// 不能用到StringBuilder，应该StringBuffer</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m2</span><span class="hljs-params">(StringBuilder sb)</span> </span>&#123;        sb.append(<span class="hljs-number">1</span>);        sb.append(<span class="hljs-number">2</span>);        sb.append(<span class="hljs-number">3</span>);        System.out.println(sb.toString());    &#125;<span class="hljs-comment">// m3()会产生线程安全问题，sb被返回了</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> StringBuilder <span class="hljs-title">m3</span><span class="hljs-params">()</span> </span>&#123;        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();        sb.append(<span class="hljs-number">1</span>);        sb.append(<span class="hljs-number">2</span>);        sb.append(<span class="hljs-number">3</span>);        <span class="hljs-keyword">return</span> sb;    &#125;&#125;</code></pre><h3 id="2-4-栈内存溢出问题"><a href="#2-4-栈内存溢出问题" class="headerlink" title="2.4 栈内存溢出问题"></a>2.4 栈内存溢出问题</h3><blockquote><p> <strong>Java.lang.stackOverflowError</strong> 栈内存溢出</p></blockquote><h4 id="发生原因"><a href="#发生原因" class="headerlink" title="发生原因"></a>发生原因</h4><ul><li><p>虚拟机栈中， <strong>栈帧过多</strong>（无限递归）</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 演示栈内存溢出 java.lang.StackOverflowError</span><span class="hljs-comment"> * -Xss256k</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo_01_2</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> count;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            method1();        &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;            e.printStackTrace();            System.out.println(count);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span> </span>&#123;        count++;        method1();    &#125;&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201203185104.png" alt="次数"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201203185225.png" alt="修改栈内存"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201203185256.png" alt="结果"></p></li></ul><ul><li>每个栈帧 <strong>所占用过大</strong></li></ul><p>​    引用的包导致栈溢出的例子:</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * json 数据转换</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo_01_19</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> JsonProcessingException </span>&#123;        Dept d = <span class="hljs-keyword">new</span> Dept();        d.setName(<span class="hljs-string">&quot;Market&quot;</span>);        Emp e1 = <span class="hljs-keyword">new</span> Emp();        e1.setName(<span class="hljs-string">&quot;zhang&quot;</span>);        e1.setDept(d);        Emp e2 = <span class="hljs-keyword">new</span> Emp();        e2.setName(<span class="hljs-string">&quot;li&quot;</span>);        e2.setDept(d);        d.setEmps(Arrays.asList(e1, e2));        <span class="hljs-comment">// &#123; name: &#x27;Market&#x27;, emps: [&#123; name:&#x27;zhang&#x27;, dept:&#123; name:&#x27;&#x27;, emps: [ &#123;&#125;]&#125; &#125;,] &#125;</span>        ObjectMapper mapper = <span class="hljs-keyword">new</span> ObjectMapper();        System.out.println(mapper.writeValueAsString(d));    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Emp</span> </span>&#123;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> Dept dept;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Dept <span class="hljs-title">getDept</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> dept;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setDept</span><span class="hljs-params">(Dept dept)</span> </span>&#123;        <span class="hljs-keyword">this</span>.dept = dept;    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dept</span> </span>&#123;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> List&lt;Emp&gt; emps;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Emp&gt; <span class="hljs-title">getEmps</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> emps;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setEmps</span><span class="hljs-params">(List&lt;Emp&gt; emps)</span> </span>&#123;        <span class="hljs-keyword">this</span>.emps = emps;    &#125;&#125;</code></pre><p>Json转换时:{ name: ‘Market’, emps: [{ name:’zhang’, dept:{ name:’’, emps: [ {}]} },] }</p><p>解决方案:</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Emp</span> </span>&#123;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-meta">@JsonIgnore</span>    <span class="hljs-keyword">private</span> Dept dept;    <span class="hljs-comment">// ....</span>&#125;</code></pre><h3 id="2-5-线程运行诊断"><a href="#2-5-线程运行诊断" class="headerlink" title="2.5 线程运行诊断"></a>2.5 线程运行诊断</h3><h4 id="案例1-cpu占用过高"><a href="#案例1-cpu占用过高" class="headerlink" title="案例1: cpu占用过高"></a>案例1: cpu占用过高</h4><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 演示 cpu 占用过高</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo_01_16</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">null</span>, () -&gt; &#123;            System.out.println(<span class="hljs-string">&quot;1...&quot;</span>);            <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;            &#125;        &#125;, <span class="hljs-string">&quot;thread1&quot;</span>).start();        <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">null</span>, () -&gt; &#123;            System.out.println(<span class="hljs-string">&quot;2...&quot;</span>);            <span class="hljs-keyword">try</span> &#123;                Thread.sleep(<span class="hljs-number">1000000L</span>);            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;, <span class="hljs-string">&quot;thread2&quot;</span>).start();        <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">null</span>, () -&gt; &#123;            System.out.println(<span class="hljs-string">&quot;3...&quot;</span>);            <span class="hljs-keyword">try</span> &#123;                Thread.sleep(<span class="hljs-number">1000000L</span>);            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;, <span class="hljs-string">&quot;thread3&quot;</span>).start();    &#125;&#125;</code></pre><p>此代码运行到linux环境下:</p><p>top命令:</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201203191313.png" alt="top"></p><p> <strong>只能定位到进程，无法定位到线程</strong></p><p> <strong>ps H -eo pid, tid（线程id）, %cpu | grep 刚才通过top查到的进程号</strong></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201203191646.png" alt="结果"></p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201203191750.png" alt="test" style="zoom: 50%;" /><blockquote><p>总结</p></blockquote><ul><li>Linux环境下运行某些程序的时候，可能导致CPU的占用过高，这时需要定位占用CPU过高的线程<ul><li> <strong>top</strong>命令，查看是哪个 <strong>进程</strong>占用CPU过高</li><li> <strong>ps H -eo pid, tid（线程id）, %cpu | grep 刚才通过top查到的进程号</strong> 通过ps命令进一步查看是哪个线程占用CPU过高</li><li> <strong>jstack 进程id</strong> 通过查看进程中的线程的nid，刚才通过ps命令看到的tid来 <strong>对比定位</strong>，注意jstack查找出的线程id是 <strong>16进制的</strong>， <strong>需要转换</strong></li></ul></li></ul><h4 id="案例2-程序运行很长时间没有结果"><a href="#案例2-程序运行很长时间没有结果" class="headerlink" title="案例2: 程序运行很长时间没有结果"></a>案例2: 程序运行很长时间没有结果</h4><p>代码:</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 演示线程死锁</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>&#123;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span></span>&#123;&#125;;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo_01_03</span> </span>&#123;    <span class="hljs-keyword">static</span> A a = <span class="hljs-keyword">new</span> A();    <span class="hljs-keyword">static</span> B b = <span class="hljs-keyword">new</span> B();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;            <span class="hljs-keyword">synchronized</span> (a) &#123;                <span class="hljs-keyword">try</span> &#123;                    Thread.sleep(<span class="hljs-number">2000</span>);                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                &#125;                <span class="hljs-keyword">synchronized</span> (b) &#123;                    System.out.println(<span class="hljs-string">&quot;我获得了 a 和 b&quot;</span>);                &#125;            &#125;        &#125;).start();        Thread.sleep(<span class="hljs-number">1000</span>);        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;            <span class="hljs-keyword">synchronized</span> (b) &#123;                <span class="hljs-keyword">synchronized</span> (a) &#123;                    System.out.println(<span class="hljs-string">&quot;我获得了 a 和 b&quot;</span>);                &#125;            &#125;        &#125;).start();    &#125;&#125;</code></pre><p>同样可以利用jstack来查询</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201204101456.png" alt="结果"></p><h2 id="3、本地方法栈"><a href="#3、本地方法栈" class="headerlink" title="3、本地方法栈"></a>3、本地方法栈</h2><blockquote><p>java虚拟机调用本地方法时需要提供的内存空间</p></blockquote><p>本地方法: 一些带有 <strong>native关键字</strong>的方法就是需要JAVA去调用本地的 <strong>C或者C++方法</strong>，因为JAVA有时候没法直接和 <strong>操作系统底层</strong>交互，所以需要用到本地方法。</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201204102423.png" alt="clone()"></p><h2 id="4、堆"><a href="#4、堆" class="headerlink" title="4、堆"></a>4、堆</h2><blockquote><p>堆和方法区是 <strong>线程共享</strong>的</p></blockquote><h3 id="4-1-定义"><a href="#4-1-定义" class="headerlink" title="4.1 定义"></a>4.1 定义</h3><ul><li>通过new关键字 <strong>创建的对象</strong>都会被放在堆内存</li></ul><h3 id="4-2-特点"><a href="#4-2-特点" class="headerlink" title="4.2 特点"></a>4.2 特点</h3><ul><li> <strong>所有线程共享</strong>，堆内存中的对象都需要<strong>考虑线程安全问题</strong></li><li>有垃圾回收机制</li></ul><h3 id="4-3-堆内存溢出问题"><a href="#4-3-堆内存溢出问题" class="headerlink" title="4.3 堆内存溢出问题"></a>4.3 堆内存溢出问题</h3><blockquote><p> <strong>java.lang.OutofMemoryError</strong> ：java heap space. 堆内存溢出</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1_5</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;        <span class="hljs-keyword">try</span> &#123;            List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();            String a = <span class="hljs-string">&quot;hello&quot;</span>;            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;                list.add(a); <span class="hljs-comment">// hello, hellohello, hellohellohellohello ...</span>                a = a + a;  <span class="hljs-comment">// hellohellohellohello</span>                i++;            &#125;        &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;            e.printStackTrace();            System.out.println(i);        &#125;    &#125;&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201204103052.png" alt="结果"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201204103650.png" alt="修改"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201204103719.png" alt="结果"></p><h3 id="4-4-堆内存诊断"><a href="#4-4-堆内存诊断" class="headerlink" title="4.4 堆内存诊断"></a>4.4 堆内存诊断</h3><h4 id="jps-工具"><a href="#jps-工具" class="headerlink" title="jps 工具"></a>jps 工具</h4><ul><li>查看当前系统中有哪些 <strong>java进程</strong></li></ul><h3 id="jmap工具"><a href="#jmap工具" class="headerlink" title="jmap工具"></a>jmap工具</h3><ul><li>查看 <strong>某个时刻</strong> 堆内存占用情况 ( - heap pid)</li><li>Jdk 9以上 jhsdb jmap –heap –pid pid</li></ul><h3 id="jconsole工具"><a href="#jconsole工具" class="headerlink" title="jconsole工具"></a>jconsole工具</h3><ul><li><p>图形界面的，多功能的检测工具，可以 <strong>连续监测</strong></p><p>代码:</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1_4</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        System.out.println(<span class="hljs-string">&quot;1...&quot;</span>);        Thread.sleep(<span class="hljs-number">30000</span>);        <span class="hljs-keyword">byte</span>[] array = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">10</span>]; <span class="hljs-comment">// 10 Mb, 堆空间</span>        System.out.println(<span class="hljs-string">&quot;2...&quot;</span>);        Thread.sleep(<span class="hljs-number">30000</span>);        array = <span class="hljs-keyword">null</span>;        System.gc();        System.out.println(<span class="hljs-string">&quot;3...&quot;</span>);        Thread.sleep(<span class="hljs-number">1000000L</span>);    &#125;&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201204105859.png" alt="检测"></p></li></ul><h3 id="案例-gc回收之后-内存占用仍然很高"><a href="#案例-gc回收之后-内存占用仍然很高" class="headerlink" title="案例: gc回收之后, 内存占用仍然很高"></a>案例: gc回收之后, 内存占用仍然很高</h3><p>​ 代码:</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 演示查看对象个数 堆转储 dump</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1_13</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        List&lt;Student&gt; students = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">200</span>; i++) &#123;            students.add(<span class="hljs-keyword">new</span> Student());<span class="hljs-comment">//            Student student = new Student();</span>        &#125;        Thread.sleep(<span class="hljs-number">1000000000L</span>);    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">byte</span>[] big = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>];&#125;</code></pre><p>​ 执行完gc后, 内存占用还是很高:</p><p>​ <img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201204135214.png" alt="执行完gc后"></p><h3 id="使用jvisualvm"><a href="#使用jvisualvm" class="headerlink" title="使用jvisualvm"></a>使用jvisualvm</h3><p>堆快照:</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201204135748.png" alt="堆快照"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201204135854.png" alt="查找堆"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201204140353.png" alt="查到结果"></p><p>查到结果为Student对象中浪费空间, list一直未被回收, 内存占用高</p><h2 id="5、方法区"><a href="#5、方法区" class="headerlink" title="5、方法区"></a>5、方法区</h2><h3 id="5-1-定义"><a href="#5-1-定义" class="headerlink" title="5.1 定义"></a>5.1 定义</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201204142845.png" alt="定义"></p><h3 id="5-2-结构"><a href="#5-2-结构" class="headerlink" title="5.2 结构"></a>5.2 结构</h3><p>​ <img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201204142945.png" alt="结构"></p><p>​   元空间已经不由jvm管理内存了</p><h3 id="5-3-内存溢出"><a href="#5-3-内存溢出" class="headerlink" title="5.3 内存溢出"></a>5.3 内存溢出</h3><ul><li><p>1.8以后会导致 <strong>元空间</strong>内存溢出</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 演示元空间内存溢出 java.lang.OutOfMemoryError: Metaspace</span><span class="hljs-comment"> * -XX:MaxMetaspaceSize=8m</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1_8</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ClassLoader</span> </span>&#123; <span class="hljs-comment">// 可以用来加载类的二进制字节码</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;        <span class="hljs-keyword">try</span> &#123;            Demo1_8 test = <span class="hljs-keyword">new</span> Demo1_8();            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++, j++) &#123;                <span class="hljs-comment">// ClassWriter 作用是生成类的二进制字节码</span>                ClassWriter cw = <span class="hljs-keyword">new</span> ClassWriter(<span class="hljs-number">0</span>);                <span class="hljs-comment">// 版本号， public， 类名, 包名, 父类， 接口</span>                cw.visit(Opcodes.V1_8, Opcodes.ACC_PUBLIC, <span class="hljs-string">&quot;Class&quot;</span> + i, <span class="hljs-keyword">null</span>, <span class="hljs-string">&quot;java/lang/Object&quot;</span>, <span class="hljs-keyword">null</span>);                <span class="hljs-comment">// 返回 byte[]</span>                <span class="hljs-keyword">byte</span>[] code = cw.toByteArray();                <span class="hljs-comment">// 执行了类的加载</span>                test.defineClass(<span class="hljs-string">&quot;Class&quot;</span> + i, code, <span class="hljs-number">0</span>, code.length); <span class="hljs-comment">// Class 对象</span>            &#125;        &#125; <span class="hljs-keyword">finally</span> &#123;            System.out.println(j);        &#125;    &#125;&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201204143911.png" alt="配置"></p><p>（元空间默认用系统内存，很难演示元空间溢出）</p><p>若改为8m:Error occurred during initialization of VM MaxMetaspaceSize is too small.</p><p>所以改为10m再次测试:          <img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201204144143.png" alt="结果"></p></li></ul><ul><li><p>1.8以前会导致 <strong>永久代</strong>内存溢出</p><p>使用java1.6:</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201204144418.png" alt="结果"></p></li></ul><h3 id="5-4-真实场景"><a href="#5-4-真实场景" class="headerlink" title="5.4 真实场景"></a>5.4 真实场景</h3><p>​ <img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201204145437.png" alt="区别"></p><ul><li><p>Spring</p><ul><li><p><strong>cjlib</strong> 生成代理类, AOP核心</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201204145057.png" alt="cjlib"></p><p>都有ClassWriter和ClassVisitor，都是 <strong>运行期间动态生成类的字节码，完成动态的类加载，代理技术广泛应用这种字节码动态生成技术</strong></p></li></ul></li><li><p>mybatis</p><ul><li> <strong>cjlib</strong> 生成Mapper接口的实现类</li></ul><p>所以使用这种框架, 是很容易产生 <strong>永久代溢出</strong> 的情况的！</p></li></ul><h3 id="5-5-常量池"><a href="#5-5-常量池" class="headerlink" title="5.5 常量池"></a>5.5 常量池</h3><pre><code class="hljs java"><span class="hljs-comment">// 运行先编译二进制字节码，包含了(类的基本信息、常量池、类的方法定义（包含了虚拟机指令）)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorld</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;hello!&quot;</span>);    &#125;&#125;</code></pre><p>找到class文件:</p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201204150212.png" alt="class文件" style="zoom:50%;" /><p>javap -v HelloWorld.class 进行反编译,并显示全部信息:</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201204150438.png" alt="类的基本信息"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201204150537.png" alt="常量池1"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201204150609.png" alt="常量池2"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201204150719.png" alt="无参构造方法"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201204150745.png" alt="main方法"></p><p>0,3,5,8后为虚拟机指令, getstatic为获取 <strong>静态变量</strong> , 即得到sout, ldc加载参数(hello!), invokevirtual虚方法调用,调用println, return为结束</p><p>#2,#3,#4查表翻译:</p><pre><code class="hljs clean">根据#<span class="hljs-number">2</span>查到常量池的表 -&gt; Fieldref -&gt; #<span class="hljs-number">21.</span>#<span class="hljs-number">22</span>#<span class="hljs-number">21</span> -&gt; Class -&gt; #<span class="hljs-number">28</span>(说明要找java/lang/System类的成员变量)#<span class="hljs-number">22</span> -&gt; #<span class="hljs-number">29</span> #<span class="hljs-number">30</span>(说明要找java/lang/System类中out的变量, 类型为java/io/PrintStream)根据#<span class="hljs-number">3</span>查到常量池的表 -&gt; #<span class="hljs-number">23</span>(String) -&gt; hello!(utf<span class="hljs-number">-8</span>) 加载进来#<span class="hljs-number">4</span> -&gt; 方法调用Methodref -&gt; ....</code></pre><blockquote><p>常量池作用</p></blockquote><p> <strong>给指令提供一些常量符号, 根据常量符号查表找到, 虚拟机指令才可正常执行</strong></p><h3 id="5-6-运行时常量池"><a href="#5-6-运行时常量池" class="headerlink" title="5.6 运行时常量池"></a>5.6 运行时常量池</h3><ul><li>常量池<ul><li>就是一张表（如上图中的constant pool），虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量信息</li></ul></li><li>运行时常量池<ul><li>常量池是*.class文件中的，当该 <strong>类被加载以后</strong>，它的常量池信息就会 <strong>放入运行时常量池</strong>，并把里面的 <strong>符号地址变为真实地址</strong></li></ul></li></ul><h3 id="5-7-String-Table-（串池）"><a href="#5-7-String-Table-（串池）" class="headerlink" title="5.7 String Table （串池）"></a>5.7 String Table （串池）</h3><h4 id="字节码和常量池角度理解底层原理"><a href="#字节码和常量池角度理解底层原理" class="headerlink" title="字节码和常量池角度理解底层原理"></a>字节码和常量池角度理解底层原理</h4><p>测试代码：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    String s1 = <span class="hljs-string">&quot;a&quot;</span>; <span class="hljs-comment">// 懒惰的</span>    String s2 = <span class="hljs-string">&quot;b&quot;</span>;    String s3 = <span class="hljs-string">&quot;ab&quot;</span>;&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201225100606.png" alt="进行编译"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201225100858.png" alt="加载"></p><p>Ldc #n 从常量池n号位置加载对应信息（常量、对象引用）</p><p>astore_1 加载好的信息放入局部变量表编号1</p><pre><code class="hljs js">常量池中的信息，都会被加载到运行时常量池中， 这时 a b ab 都是常量池中的符号，还没有变为 java 字符串对象执行到ldc #2 会把 a 符号变为 &quot;a&quot; 字符串对象，此时会准备一份空间为String table[] （哈希表,不可扩容）也就是串池，存入，然后去找，看看有没有取值相同的key执行到ldc #3 会把 b 符号变为 &quot;b&quot; 字符串对象执行到ldc #4 会把 ab 符号变为 &quot;ab&quot; 字符串对象#懒惰的 用到了才会创建，用不到不会提前创建</code></pre><h4 id="字符串变量拼接"><a href="#字符串变量拼接" class="headerlink" title="字符串变量拼接"></a>字符串变量拼接</h4><p>修改代码：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    String s1 = <span class="hljs-string">&quot;a&quot;</span>; <span class="hljs-comment">// 懒惰的 用到了才会创建，用不到不会提前创建</span>    String s2 = <span class="hljs-string">&quot;b&quot;</span>;    String s3 = <span class="hljs-string">&quot;ab&quot;</span>;    String s4 = s1 + s2;&#125;</code></pre><p>再次编译：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201225102356.png" alt="编译"></p><p>先创建一个 <strong>StringBuilder</strong> 对象，invokespecial调用方法， init为 <strong>构造方法，且无参</strong>，aload_1把s1加载进来，和astore_1相对，调用append方法，再aload_2，append方法，再调用toString方法，再存储astore_4</p><p>所以是会调用StringBuilder的toString()方法的，我们找到这个方法</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201225102830.png" alt="toString"></p><pre><code class="hljs java">System.out.println(s3 == s4);<span class="hljs-comment">// false</span></code></pre><p> s3值为ab，是串池中的一个对象，s4引用的是一个新的字符串对象，存在 <strong>堆</strong> 里面，new出来的。</p><h4 id="编译期优化"><a href="#编译期优化" class="headerlink" title="编译期优化"></a>编译期优化</h4><p>代码修改为</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    String s1 = <span class="hljs-string">&quot;a&quot;</span>; <span class="hljs-comment">// 懒惰的 用到了才会创建，用不到不会提前创建</span>    String s2 = <span class="hljs-string">&quot;b&quot;</span>;    String s3 = <span class="hljs-string">&quot;ab&quot;</span>;    String s4 = s1 + s2;<span class="hljs-comment">// new StringBuilder().append(&quot;a&quot;).append(&quot;b&quot;).toString()  new String(&quot;ab&quot;)</span>    String s5 = <span class="hljs-string">&quot;a&quot;</span> + <span class="hljs-string">&quot;b&quot;</span>;    System.out.println(s3 == s5);&#125;<span class="hljs-comment">// true</span></code></pre><p>编译后发现是直接去取值</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201225103458.png" alt="取值"></p><p>直接引用串池中已有的对象</p><blockquote><p>原理</p></blockquote><p> <strong>javac 在编译期间的优化</strong> ，结果已经在编译期确定为ab，并在StringTable中查找。</p><h4 id="字符串延迟实例化"><a href="#字符串延迟实例化" class="headerlink" title="字符串延迟实例化"></a>字符串延迟实例化</h4><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    <span class="hljs-keyword">int</span> x = args.length;    System.out.println(); <span class="hljs-comment">// 字符串个数 2275</span>    System.out.print(<span class="hljs-string">&quot;1&quot;</span>);    System.out.print(<span class="hljs-string">&quot;2&quot;</span>);    System.out.print(<span class="hljs-string">&quot;3&quot;</span>);    System.out.print(<span class="hljs-string">&quot;4&quot;</span>);    System.out.print(<span class="hljs-string">&quot;5&quot;</span>);    System.out.print(<span class="hljs-string">&quot;6&quot;</span>);    System.out.print(<span class="hljs-string">&quot;7&quot;</span>);    System.out.print(<span class="hljs-string">&quot;8&quot;</span>);    System.out.print(<span class="hljs-string">&quot;9&quot;</span>);    System.out.print(<span class="hljs-string">&quot;0&quot;</span>);    System.out.print(<span class="hljs-string">&quot;1&quot;</span>); <span class="hljs-comment">// 字符串个数 2285</span>    System.out.print(<span class="hljs-string">&quot;2&quot;</span>);    System.out.print(<span class="hljs-string">&quot;3&quot;</span>);    System.out.print(<span class="hljs-string">&quot;4&quot;</span>);    System.out.print(<span class="hljs-string">&quot;5&quot;</span>);    System.out.print(<span class="hljs-string">&quot;6&quot;</span>);    System.out.print(<span class="hljs-string">&quot;7&quot;</span>);    System.out.print(<span class="hljs-string">&quot;8&quot;</span>);    System.out.print(<span class="hljs-string">&quot;9&quot;</span>);    System.out.print(<span class="hljs-string">&quot;0&quot;</span>);    System.out.print(x); <span class="hljs-comment">// 字符串个数</span>&#125;</code></pre><p>用的IDEA memory工具查看</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201225110206.png" alt="memory"></p><p>debug</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201225110250.png" alt="memory"></p><p>正好十一个，再到后面，串池重复，String个数不增加</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201225110427.png" alt="memory"></p><blockquote><p>总结</p></blockquote><ul><li>常量池中的字符串仅是符号，第一次用到时才变为对象 </li><li>利用串池的机制，来避免重复创建字符串对象 </li><li>字符串变量拼接的原理是 StringBuilder (1.8) </li><li>字符串常量拼接的原理是编译期优化</li></ul><h4 id="intern方法"><a href="#intern方法" class="headerlink" title="intern方法"></a>intern方法</h4><blockquote><p>主动将串池中没有的串放入</p></blockquote><h5 id="intern-1-8"><a href="#intern-1-8" class="headerlink" title="intern 1.8"></a>intern 1.8</h5><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    <span class="hljs-comment">// a b都是常量，放在串池 两个 a b</span>    <span class="hljs-comment">// new的String放在堆中 三个 a b ab 动态拼接的字符串开始都放在堆中，不在串池</span>    String s = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;a&quot;</span>) + <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;b&quot;</span>);    <span class="hljs-comment">// 堆  new String(&quot;a&quot;)   new String(&quot;b&quot;) new String(&quot;ab&quot;)</span>    String s2 = s.intern();    <span class="hljs-comment">// 将这个字符串对象尝试放入串池</span>    <span class="hljs-comment">// 如果有则并不会放入</span>    <span class="hljs-comment">// 如果没有则放入串池， 会把串池中的对象返回</span>    System.out.println(s2 == <span class="hljs-string">&quot;ab&quot;</span>); <span class="hljs-comment">// ab用的上一步放入串池的</span>    <span class="hljs-comment">// true</span>    System.out.println(s == <span class="hljs-string">&quot;ab&quot;</span>); <span class="hljs-comment">// intern会将s尝试放入串池</span>    <span class="hljs-comment">// true</span>&#125;</code></pre><p>如果“ab”一开始就放入</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    String x = <span class="hljs-string">&quot;ab&quot;</span>; <span class="hljs-comment">// ab放入串池</span>        <span class="hljs-comment">// a b都是常量，放在串池 三个 a b ab</span>    <span class="hljs-comment">// new的String放在堆中 三个 a b ab 动态拼接的字符串开始都放在堆中，不在串池</span>    String s = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;a&quot;</span>) + <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;b&quot;</span>);    <span class="hljs-comment">// 堆  new String(&quot;a&quot;)   new String(&quot;b&quot;) new String(&quot;ab&quot;)</span>    String s2 = s.intern();    <span class="hljs-comment">// 将这个字符串对象尝试放入串池</span>    <span class="hljs-comment">// 如果有则并不会放入</span>    <span class="hljs-comment">// 如果没有则放入串池， 会把串池中的对象返回</span>    System.out.println(s2 == x); <span class="hljs-comment">// 拿串池返回的比</span>    <span class="hljs-comment">// true</span>    System.out.println(s == x); <span class="hljs-comment">// 拿堆的比，intern没有放入</span>    <span class="hljs-comment">// false</span>&#125;</code></pre><p>s.intern()，如果串池没有，s会放入；如果有，会返回串池中的对象</p><p>所以如果串池没有 s == “ab” ，s放入了，所以相等</p><p>但是如果串池有，s == x，s没有放入但返回了s2，所以s2 == x，但s != x</p><h5 id="intern-1-6"><a href="#intern-1-6" class="headerlink" title="intern 1.6"></a>intern 1.6</h5><p>代码：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201225135149.png" alt="code"></p><p>true和false</p><p>另外一种情况：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201225135446.png" alt="new code"></p><p>s.intern是拷贝，返回的串池中的ab，和s不是同一个对象</p><p>所以x、s2都是 <strong>串池中的ab</strong> ，s还是 <strong>堆里的对象</strong></p><p>还是true false</p><p>相同代码 1.8环境两个true</p><h5 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h5><ul><li>可以使用 intern 方法，主动将串池中还没有的字符串对象放入串池<ul><li>1.8 将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有则放入串池， 会把串 池中的对象返回</li><li>1.6 将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有会把此对象 <strong>复制一份， 放入串池</strong> ， 会把串池中的对象返回</li></ul></li></ul><h4 id="String-Table-面试题"><a href="#String-Table-面试题" class="headerlink" title="String Table 面试题"></a>String Table 面试题</h4><p>code：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        String s1 = <span class="hljs-string">&quot;a&quot;</span>;        String s2 = <span class="hljs-string">&quot;b&quot;</span>;        String s3 = <span class="hljs-string">&quot;a&quot;</span> + <span class="hljs-string">&quot;b&quot;</span>; <span class="hljs-comment">// ab</span>        String s4 = s1 + s2;   <span class="hljs-comment">// init,apend,toString -&gt; new String(&quot;ab&quot;)</span>        String s5 = <span class="hljs-string">&quot;ab&quot;</span>;        String s6 = s4.intern();<span class="hljs-comment">// s4不会放入，还是堆上</span>        System.out.println(s3 == s4); <span class="hljs-comment">// false</span>        System.out.println(s3 == s5); <span class="hljs-comment">// true</span>        System.out.println(s3 == s6); <span class="hljs-comment">// true</span>        String x2 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;c&quot;</span>) + <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;d&quot;</span>); <span class="hljs-comment">// new String(&quot;cd&quot;)</span>        String x1 = <span class="hljs-string">&quot;cd&quot;</span>;<span class="hljs-comment">// 串池</span>        x2.intern();<span class="hljs-comment">// x2放入串池失败，堆中</span>               System.out.println(x1 == x2); <span class="hljs-comment">// false</span>    &#125;</code></pre><p>如果代码：</p><pre><code class="hljs java">String x2 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;c&quot;</span>) + <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;d&quot;</span>); <span class="hljs-comment">// new String(&quot;cd&quot;)</span>        x2.intern(); <span class="hljs-comment">// x2放入串池</span>        String x1 = <span class="hljs-string">&quot;cd&quot;</span>;<span class="hljs-comment">// 问，如果调换了【最后两行代码】的位置呢，如果是jdk1.6呢</span>        System.out.println(x1 == x2); <span class="hljs-comment">// 1.8 true 1.6 false</span>    &#125;</code></pre><h4 id="StringTable-位置"><a href="#StringTable-位置" class="headerlink" title="StringTable 位置"></a>StringTable 位置</h4><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201225141334.png" alt="位置"></p><p>原因：永久代内存回收效率很低，永久代需要 <strong>Full GC</strong> 才会触发 <strong>永久代垃圾回收</strong>，Full GC需要等到 <strong>老年代空间不足</strong> 才能触发，间接导致串池回收效率很低。</p><p>堆里面串池只需要 <strong>minor GC</strong> 就可以触发垃圾回收。</p><h5 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h5><p>1.6 环境下运行和1.8环境报错不同</p><p>code：</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 演示 StringTable 位置</span><span class="hljs-comment"> * 在jdk8下设置 -Xmx10m -XX:-UseGCOverheadLimit</span><span class="hljs-comment"> * 在jdk6下设置 -XX:MaxPermSize=10m</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1_6</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">260000</span>; j++) &#123;                list.add(String.valueOf(j).intern());                i++;            &#125;        &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">finally</span> &#123;            System.out.println(i);        &#125;    &#125;&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201225142201.png" alt="VM setting"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201225142737.png" alt="堆错误"></p><p>如果是1.6</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201225143029.png" alt="1.6"></p><p>显示永久代空间不足</p><p>如果只加-Xmx10m：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201225143310.png" alt="xmx10m"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201225143329.png" alt="GC overhead"></p><p>后面的参数实际上是设置 <strong>GC limit开关</strong></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201225143455.png" alt="开关"></p><p>加号表示开启，减号表示关闭</p><h4 id="String-Table-垃圾回收"><a href="#String-Table-垃圾回收" class="headerlink" title="String Table 垃圾回收"></a>String Table 垃圾回收</h4><p>字符串常量并不是永久的，也是会被GC回收的。</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 演示 StringTable 垃圾回收</span><span class="hljs-comment"> * 堆内存最大值       打印字符串表统计信息          打印GC信息</span><span class="hljs-comment"> * -Xmx10m -XX:+PrintStringTableStatistics -XX:+PrintGCDetails -verbose:gc</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1_7</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">100000</span>; j++) &#123; <span class="hljs-comment">// j=100, j=10000</span>                String.valueOf(j).intern();                i++;            &#125;        &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">finally</span> &#123;            System.out.println(i);        &#125;    &#125;&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201225144248.png" alt="JVM配置"></p><p>SymbolTable statistics: 符号表 也在常量池</p><p>StringTable statistics: 串池统计信息</p><p>哈希表：数组 + 链表， 数组个数称为桶（bucket），键值对：entries， literals（字符串常量对象个数）</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201225144722.png" alt="结果"></p><p>如果删除循环</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201225144808.png" alt="结果"></p>]]></content>
    
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式</title>
    <link href="/2020/12/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2020/12/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="设计模式七大原则"><a href="#设计模式七大原则" class="headerlink" title="设计模式七大原则"></a>设计模式七大原则</h1><h2 id="设计模式的目的"><a href="#设计模式的目的" class="headerlink" title="设计模式的目的"></a>设计模式的目的</h2><blockquote><p>编写软件过程中, 程序员面临着来自 <strong><em>耦合性</em></strong>, <strong><em>内聚性</em></strong>, 以及 <strong><em>可维护性</em></strong>, <strong><em>可扩展性</em></strong>, <strong><em>重用性</em></strong>, <strong><em>灵活性</em></strong> 等多方面的挑战, 设计模式是为了让 <strong><em>程序(软件)</em></strong>具有更好的:</p></blockquote><ol><li><p> 代码重用性 (即:相同功能的代码，不用多次编写)</p></li><li><p> 可读性 (即:编程规范性, 便于其他程序员的阅读和理解)</p></li><li><p> 可扩展性 (即:当需要增加新的功能时，非常的方便，称为可维护)</p></li><li><p> 可靠性 (即:当我们增加新的功能后，对原来的功能没有影响)</p></li><li><p>使程序呈现 <strong><em>高内聚，低耦合</em></strong>的特性</p><p> <strong>分享金句</strong>: </p><p>设计模式包含了面向对象的精髓，“懂了设计模式，你就懂了面向对象分析和设计(OOA/D)的精要”</p><p>Scott Mayers 在其巨著《Effective C++》就曾经说过:C++老手和 C++新手的区别就是前者手背上有很多伤疤</p></li></ol><h2 id="设计模式七大原则-1"><a href="#设计模式七大原则-1" class="headerlink" title="设计模式七大原则"></a>设计模式七大原则</h2><blockquote><p>设计模式原则，其实就是 <strong><em>程序员在编程时，应当遵守的原则</em></strong>，也是各种设计模式的基础(即:设计模式为什么这样设计的依据)</p></blockquote><p>设计模式常用的七大原则有:</p><ol><li><p>单一职责原则</p></li><li><p>接口隔离原则</p></li><li><p>依赖倒转(倒置)原则 </p></li><li><p>里氏替换原则</p></li><li><p>开闭原则</p></li><li><p>迪米特法则</p></li><li><p>合成复用原则</p></li></ol><h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>​        对类来说的，即一个类应该 <strong><em>只负责一项职责</em></strong>。如类 A 负责两个不同职责:职责 1，职责 2。当职责 1 需求变更 而改变 A 时，可能造成职责 2 执行错误，所以需要将类 A 的 <strong><em>粒度分解</em></strong>为 A1，A2</p><h4 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h4><p>以交通工具案例讲解</p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201201195254.png" alt="test" style="zoom:50%;" /><p>//  交通工具类<br>// 方式 1<br>// 1)在方式 1 的 run 方法中，违反了 <strong><em>单一职责原则</em></strong><br>// 2)解决的方案非常的简单，根据交通工具运行方法不同，分解成不同类即可</p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201201195739.png" alt="解耦后" style="zoom:50%;" /><p>// 方案 2 的分析<br>// 1. 遵守单一职责原则<br>// 2. 但是这样做的改动很大，即将类分解，同时修改客户端 </p><p> 改进:直接修改 Vehicle 类，改动的代码会比较少=&gt;方案 3</p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201201200149.png" alt="方案3" style="zoom:50%;" /><p>​    // 方式 3 的分析</p><p>​    //  1. 这种修改方法没有对原来的类做大的修改，只是增加方法<br>   //   2. 这里虽然没有在类这个级别上遵守单一职责原则，但是在方法级别上，仍然是遵守单一职责</p><pre><code>#### 单一职责原则注意事项和细节</code></pre><blockquote><p>  方法数量足够少，可以在方法级别保持单一职责原则</p></blockquote><ol><li> 降低类的复杂度，一个类只负责一项职责。</li><li> 提高类的可读性，可维护性</li><li> 降低变更引起的风险</li><li> 通常情况下， <strong>我们应当遵守单一职责原则</strong>，只有  <strong>逻辑足够简单，才可以在代码级违反单一职责原则</strong>;只有类中方法数量足够少，可以在方法级别保持单一职责原则</li></ol><h3 id="接口隔离原则-Interface-Segregation-Principle"><a href="#接口隔离原则-Interface-Segregation-Principle" class="headerlink" title="接口隔离原则(Interface Segregation Principle)"></a>接口隔离原则(Interface Segregation Principle)</h3><h4 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h4><ol><li><p>客户端不应该依赖它不需要的接口，即 <strong>一个类对另一个类的依赖应该建立在最小的接口</strong>上</p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201201201726.png" alt="接口隔离原则" style="zoom: 50%;" /></li></ol><p>B、D代表实现</p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201201203605.png" alt="接口实现" style="zoom:50%;" /><p>​    3.     类A通过接口Interface1依赖类B，类C通过接口Interface1依赖类D，如果接口Interface1对于类A和类C</p><p>来说不是最小接口，那么类 B 和类 D 必须去实现他们不需要的方法。 </p><p>​    4.    按隔离原则应当这样处理:</p><p>​    将接口  Interface1 拆分为独立的几个接口(这里我们拆分成 3 个接口)，类 A 和类 C 分别与他们需要的接口建立 依赖关系。也就是采用接口隔离原则</p><h4 id="应用实例-1"><a href="#应用实例-1" class="headerlink" title="应用实例"></a>应用实例</h4><ol><li>实现方案1+分析说明</li></ol><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Interface1</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operation1</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operation2</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operation3</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operation4</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operation5</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Interface1</span></span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation1</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;B&quot;</span> + <span class="hljs-number">1</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation2</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;B&quot;</span> + <span class="hljs-number">2</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation3</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;B&quot;</span> + <span class="hljs-number">3</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation4</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;B&quot;</span> + <span class="hljs-number">4</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation5</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;B&quot;</span> + <span class="hljs-number">5</span>);    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">D</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Interface1</span></span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation1</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;D&quot;</span> + <span class="hljs-number">1</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation2</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;D&quot;</span> + <span class="hljs-number">2</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation3</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;D&quot;</span> + <span class="hljs-number">3</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation4</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;D&quot;</span> + <span class="hljs-number">4</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation5</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;D&quot;</span> + <span class="hljs-number">5</span>);    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123; <span class="hljs-comment">// A类通过接口Interface1 依赖(使用)B类 但是只会用到1,2,3方法</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">depend1</span><span class="hljs-params">(Interface1 i)</span> </span>&#123;        i.operation1();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">depend2</span><span class="hljs-params">(Interface1 i)</span> </span>&#123;        i.operation2();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">depend3</span><span class="hljs-params">(Interface1 i)</span> </span>&#123;        i.operation3();    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> </span>&#123; <span class="hljs-comment">// C类通过接口Interface1 依赖(使用)D类 但是只会用到1,4,5方法</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">depend1</span><span class="hljs-params">(Interface1 i)</span> </span>&#123;        i.operation1();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">depend4</span><span class="hljs-params">(Interface1 i)</span> </span>&#123;        i.operation4();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">depend5</span><span class="hljs-params">(Interface1 i)</span> </span>&#123;        i.operation5();    &#125;&#125;</code></pre><h4 id="应传统方法的问题和使用接口隔离原则改进"><a href="#应传统方法的问题和使用接口隔离原则改进" class="headerlink" title="应传统方法的问题和使用接口隔离原则改进"></a>应传统方法的问题和使用接口隔离原则改进</h4><ol><li><p>类A通过接口Interface1依赖类B，类C通过接口Interface1依赖类D，如果接口Interface1对于类A和类C</p><p>来说不是最小接口，那么类 B 和类 D 必须去实现他们不需要的方法</p></li><li><p>将接口 <strong>Interface1</strong>拆分为独立的几个接口，类A和类C分别与他们需要的接口建立依赖关系。也就是采用接口 隔离原则</p><p>接口Interface1中出现的方法，根据实际情况拆分为三个接口</p></li></ol><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201201204019.png" alt="原理" style="zoom:50%;" /><img src="../../Library/Application Support/typora-user-images/image-20201201204856491.png" alt="解耦后" style="zoom:50%;" /><pre><code class="hljs java"><span class="hljs-comment">// 接口 1</span><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Interface1</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operation1</span><span class="hljs-params">()</span></span>; &#125;<span class="hljs-comment">// 接口 2</span><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Interface2</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operation2</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operation3</span><span class="hljs-params">()</span></span>; &#125;<span class="hljs-comment">// 接口 3</span><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Interface3</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operation4</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operation5</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Interface1</span>, <span class="hljs-title">Interface2</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation1</span><span class="hljs-params">()</span> </span>&#123; System.out.println(<span class="hljs-string">&quot;B 1&quot;</span>);&#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation2</span><span class="hljs-params">()</span> </span>&#123; System.out.println(<span class="hljs-string">&quot;B 1&quot;</span>);&#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation3</span><span class="hljs-params">()</span> </span>&#123; System.out.println(<span class="hljs-string">&quot;B 3&quot;</span>);&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">D</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Interface1</span>, <span class="hljs-title">Interface3</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation1</span><span class="hljs-params">()</span> </span>&#123; System.out.println(<span class="hljs-string">&quot;D 1&quot;</span>);&#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation4</span><span class="hljs-params">()</span> </span>&#123; System.out.println(<span class="hljs-string">&quot;D 4&quot;</span>);&#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation5</span><span class="hljs-params">()</span> </span>&#123; System.out.println(<span class="hljs-string">&quot;D 5&quot;</span>);&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123; <span class="hljs-comment">// A 类通过接口 Interface1,Interface2 依赖(使用) B 类，但是只会用到 1,2,3 方法 public void depend1(Interface1 i) &#123;</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">depend1</span><span class="hljs-params">(Interface1 i)</span> </span>&#123; i.operation1(); &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">depend2</span><span class="hljs-params">(Interface2 i)</span> </span>&#123; i.operation2(); &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">depend3</span><span class="hljs-params">(Interface2 i)</span> </span>&#123; i.operation3(); &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> </span>&#123; <span class="hljs-comment">// C 类通过接口 Interface1,Interface3 依赖(使用) D 类，但是只会用到 1,4,5 方法 public void depend1(Interface1 i) &#123;</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">depend1</span><span class="hljs-params">(Interface1 i)</span> </span>&#123; i.operation1(); &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">depend4</span><span class="hljs-params">(Interface3 i)</span> </span>&#123; i.operation4(); &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">depend5</span><span class="hljs-params">(Interface3 i)</span> </span>&#123; i.operation5(); &#125;&#125;</code></pre><pre><code class="hljs java">A a = <span class="hljs-keyword">new</span> A();a.depend1(<span class="hljs-keyword">new</span> B()); <span class="hljs-comment">// A类通过接口去依赖B类</span>a.depend2(<span class="hljs-keyword">new</span> B());a.depend3(<span class="hljs-keyword">new</span> B());C c = <span class="hljs-keyword">new</span> C();c.depend1(<span class="hljs-keyword">new</span> D()); <span class="hljs-comment">// C类通过接口去依赖D类</span>c.depend4(<span class="hljs-keyword">new</span> D());c.depend5(<span class="hljs-keyword">new</span> D());</code></pre><h3 id="依赖倒转原则-Dependence-Inversion-Principle"><a href="#依赖倒转原则-Dependence-Inversion-Principle" class="headerlink" title="依赖倒转原则(Dependence Inversion Principle)"></a>依赖倒转原则(Dependence Inversion Principle)</h3><h4 id="基本介绍-2"><a href="#基本介绍-2" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>依赖倒转原则(Dependence Inversion Principle)是指:</p><ol><li><p> 高层模块不应该依赖低层模块，二者都应该依赖其抽象(抽象类、接口都可以)</p></li><li><p> <strong><em>抽象不应该依赖细节，细节应该依赖抽象</em></strong></p></li><li><p> 依赖倒转(倒置)的中心思想是 <strong><em>面向接口编程</em></strong></p></li><li><p> 依赖倒转原则是基于这样的设计理念:相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架 构比以细节为基础的架构要稳定的多。在 java 中，抽象指的是接口或抽象类，细节就是具体的实现类</p></li><li><p>使用 <strong><em>接口或抽象类</em></strong>的目的是制定好 <strong><em>规范</em></strong>，而不涉及任何具体的操作，把 <strong><em>展现细节的任务交给他们的实现类</em></strong>去完成</p><h4 id="应用实例-2"><a href="#应用实例-2" class="headerlink" title="应用实例"></a>应用实例</h4></li></ol><p>请编程完成 Person 接收消息 的功能。</p><ol><li>实现方案1+分析说明</li></ol><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DependecyInversion1</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Person person = <span class="hljs-keyword">new</span> Person();        person.receive(<span class="hljs-keyword">new</span> Email());    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Email</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getInfo</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;电子邮件信息: hello,world&quot;</span>; &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receive</span><span class="hljs-params">(Email email )</span> </span>&#123; System.out.println(email.getInfo()); &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-comment">//  方式 1 分析</span><span class="hljs-number">1.</span> 简单，比较容易想到<span class="hljs-number">2.</span> 如果我们获取的对象是 微信，短信等等，则新增类，同时 Perons 也要增加相应的接收方法<span class="hljs-number">3.</span> 解决思路:引入一个抽象的接口 IReceiver, 表示接收者, 这样 Person 类与接口 IReceiver 发生依赖</code></pre><ol start="2"><li>实现方案2+分析说明</li></ol><pre><code class="hljs java"><span class="hljs-comment">// 定义接口</span><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IReceiver</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getInfo</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EmailImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IReceiver</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getInfo</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;电子邮件信息: hello,world&quot;</span>;    &#125;&#125;<span class="hljs-comment">//增加微信</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WeiXin</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IReceiver</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getInfo</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;微信信息: hello,ok&quot;</span>;    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PersonNew</span> </span>&#123;    <span class="hljs-comment">//这里我们是对接口的依赖</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receive</span><span class="hljs-params">(IReceiver receiver )</span> </span>&#123;        System.out.println(receiver.getInfo());    &#125;&#125;</code></pre><h4 id="依赖关系传递的三种方式和应用案例"><a href="#依赖关系传递的三种方式和应用案例" class="headerlink" title="依赖关系传递的三种方式和应用案例"></a>依赖关系传递的三种方式和应用案例</h4><blockquote><p>接口传递</p></blockquote><pre><code class="hljs java"><span class="hljs-comment">// 方式1：通过接口传递实现依赖</span><span class="hljs-comment">// 开关的接口</span><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IOpenAndClose</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">open</span><span class="hljs-params">(ITV tv)</span></span>; <span class="hljs-comment">//抽象方法，接收接口</span>&#125;<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ITV</span> </span>&#123; <span class="hljs-comment">//ITV接口</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">play</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OpenAndClose</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IOpenAndClose</span></span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">open</span><span class="hljs-params">(ITV tv)</span></span>&#123;   tv.play();   &#125;&#125;<span class="hljs-comment">// 如何使用?</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChangHong</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ITV</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">play</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;打开changhong TV&quot;</span>);    &#125;&#125;<span class="hljs-comment">// 使用</span>ChangHong changHong = <span class="hljs-keyword">new</span> ChangHong();OpenAndClose openAndClose = <span class="hljs-keyword">new</span> OpenAndClose();openAndClose.open(changHong);</code></pre><blockquote><p>构造方法传递 </p></blockquote><pre><code class="hljs java"><span class="hljs-comment">// 方式2：通过构造方法依赖传递</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IOpenAndClose</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">open</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//抽象方法</span> &#125; <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ITV</span> </span>&#123; <span class="hljs-comment">//ITV接口</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">play</span><span class="hljs-params">()</span></span>; &#125; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OpenAndClose</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IOpenAndClose</span></span>&#123;   <span class="hljs-keyword">public</span> ITV tv;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">OpenAndClose</span><span class="hljs-params">(ITV tv)</span></span>&#123; <span class="hljs-comment">//构造器</span>      <span class="hljs-keyword">this</span>.tv = tv;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">open</span><span class="hljs-params">()</span></span>&#123;   <span class="hljs-keyword">this</span>.tv.play();   &#125; &#125;<span class="hljs-comment">// 如何使用？</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChangHong</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ITV</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">play</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;打开changhong TV&quot;</span>);    &#125;&#125;<span class="hljs-comment">// 使用：</span>ChangHong changHong = <span class="hljs-keyword">new</span> ChangHong();OpenAndClose openAndClose = <span class="hljs-keyword">new</span> OpenAndClose(changHong);openAndClose.open();</code></pre><blockquote><p>setter 方式传递</p></blockquote><pre><code class="hljs java"><span class="hljs-comment">// 方式3：setter方法实现</span><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IOpenAndClose</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">open</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 抽象方法</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setTv</span><span class="hljs-params">(ITV tv)</span></span>;&#125;<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ITV</span> </span>&#123; <span class="hljs-comment">// ITV接口</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">play</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OpenAndClose</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IOpenAndClose</span> </span>&#123;   <span class="hljs-keyword">private</span> ITV tv;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setTv</span><span class="hljs-params">(ITV tv)</span> </span>&#123;      <span class="hljs-keyword">this</span>.tv = tv;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">open</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">this</span>.tv.play();   &#125;&#125;<span class="hljs-comment">// 如何使用？</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChangHong</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ITV</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">play</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;打开changhong TV&quot;</span>);    &#125;&#125;        ChangHong changHong = <span class="hljs-keyword">new</span> ChangHong();        OpenAndClose openAndClose = <span class="hljs-keyword">new</span> OpenAndClose();        openAndClose.setTv(changHong);        openAndClose.open();</code></pre><h4 id="依赖倒转原则的注意事项和细节"><a href="#依赖倒转原则的注意事项和细节" class="headerlink" title="依赖倒转原则的注意事项和细节"></a>依赖倒转原则的注意事项和细节</h4><ol><li>  低层模块尽量都要有抽象类或接口，或者两者都有，程序稳定性更好.</li><li>   <strong><em>变量的声明类型尽量是抽象类或接口</em></strong>, 这样我们的变量引用和实际对象间，就存在一个 <strong><em>缓冲层</em></strong>，利于程序扩展和优化</li><li>  继承时遵循 <strong><em>里氏替换</em></strong>原则</li></ol><h3 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h3><h4 id="OO-中的继承性的思考和说明"><a href="#OO-中的继承性的思考和说明" class="headerlink" title="OO 中的继承性的思考和说明"></a>OO 中的继承性的思考和说明</h4><ol><li>继承包含这样一层含义: <strong>父类中凡是已经实现好的方法，实际上是在设定规范和契约</strong>，虽然它不强制要求所有 的子类必须遵循这些契约，但是如果子类对这些已经实现的方法任意修改，就会对整个继承体系造成破坏。</li><li> <strong>继承在给程序设计带来便利的同时，也带来了弊端</strong>。比如使用继承会给程序带来 <strong>侵入性</strong>，程序的可移植性降低， <strong>增加对象间的耦合性</strong>，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且 父类修改后，所有涉及到子类的功能都有可能产生故障</li><li>问题提出: <strong>在编程中，如何正确的使用继承?</strong> =&gt;  <strong>里氏替换原则</strong></li></ol><h4 id="基本介绍-3"><a href="#基本介绍-3" class="headerlink" title="基本介绍"></a>基本介绍</h4><ol><li>里氏替换原则(LiskovSubstitutionPrinciple)在1988年，由麻省理工学院的以为姓里的女士提出的。</li><li>如果对每个类型为T1的对象o1，都有类型为T2的对象o2，使得以T1定义的所有程序P在所有的对象o1都 代换成 o2 时，程序 P 的行为没有发生变化，那么类型 T2 是类型 T1 的子类型。换句话说， <strong><em>所有引用基类的地 方必须能透明地使用其子类的对象</em></strong>。</li><li>在使用继承时，遵循里氏替换原则，在 <strong><em>子类中尽量不要重写父类的方法</em></strong>。</li><li>里氏替换原则告诉我们，继承实际上让两个类耦合性增强了，在适当的情况下，可以通过 <strong><em>聚合，组合，依赖</em></strong>来解决问题。</li></ol><h4 id="一个程序引出的问题和思考"><a href="#一个程序引出的问题和思考" class="headerlink" title="一个程序引出的问题和思考"></a>一个程序引出的问题和思考</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Liskov1</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        A a = <span class="hljs-keyword">new</span> A();        System.out.println(<span class="hljs-string">&quot;11-3=&quot;</span> + a.func1(<span class="hljs-number">11</span>, <span class="hljs-number">3</span>));        System.out.println(<span class="hljs-string">&quot;1-8=&quot;</span> + a.func1(<span class="hljs-number">1</span>, <span class="hljs-number">8</span>));        System.out.println(<span class="hljs-string">&quot;-----------------------&quot;</span>);        B b = <span class="hljs-keyword">new</span> B();        System.out.println(<span class="hljs-string">&quot;11-3=&quot;</span> + b.func1(<span class="hljs-number">11</span>, <span class="hljs-number">3</span>));<span class="hljs-comment">//这里本意是求出 11-3</span>        System.out.println(<span class="hljs-string">&quot;1-8=&quot;</span> + b.func1(<span class="hljs-number">1</span>, <span class="hljs-number">8</span>));        <span class="hljs-comment">// 1-8</span>        System.out.println(<span class="hljs-string">&quot;11+3+9=&quot;</span> + b.func2(<span class="hljs-number">11</span>, <span class="hljs-number">3</span>));    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;    <span class="hljs-comment">// 返回两个数的差</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">func1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num1, <span class="hljs-keyword">int</span> num2)</span> </span>&#123; <span class="hljs-keyword">return</span> num1 - num2; &#125;&#125;<span class="hljs-comment">// B 类继承了 A</span><span class="hljs-comment">// 增加了一个新功能:完成两个数相加,然后和 9 求和</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> </span>&#123;    <span class="hljs-comment">//这里，重写了 A 类的方法, 可能是无意识</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">func1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123; <span class="hljs-keyword">return</span> a + b; &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">func2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123; <span class="hljs-keyword">return</span> func1(a, b) + <span class="hljs-number">9</span>; &#125;&#125;</code></pre><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><ol><li><p>我们发现原来运行正常的相减功能发生了错误。原因就是 <strong><em>类B无意中重写了父类的方法，造成原有功能出现错误</em></strong>。在实际编程中，我们常常会通过重写父类的方法完成新的功能，这样写起来虽然简单，但整个继承体系的复用性会比较差。特别是运行多态比较频繁的时候</p></li><li><p>通用的做法是: <strong><em>原来的父类和子类都继承一个更通俗的基类，原有的继承关系去掉，采用依赖，聚合，组合等 关系代替</em></strong>.</p></li></ol><pre><code class="hljs java"><span class="hljs-comment">//创建一个更加基础的基类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span> </span>&#123;    <span class="hljs-comment">//把更加基础的方法和成员写到 Base 类</span>&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Base</span></span>&#123;    <span class="hljs-comment">// 返回两个数的差</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">func1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num1, <span class="hljs-keyword">int</span> num2)</span> </span>&#123; <span class="hljs-keyword">return</span> num1 - num2; &#125;&#125;<span class="hljs-comment">// 增加了一个新功能:完成两个数相加,然后和 9 求和</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Base</span> </span>&#123;    <span class="hljs-comment">//如果 B 需要使用 A 类的方法,使用组合关系</span>    <span class="hljs-keyword">private</span> A a = <span class="hljs-keyword">new</span> A();    <span class="hljs-comment">//我们仍然想使用 A 的方法</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">func3</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.a.func1(a, b)&#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">func1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123; <span class="hljs-keyword">return</span> a + b; &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">func2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123; <span class="hljs-keyword">return</span> func1(a, b) + <span class="hljs-number">9</span>; &#125;&#125;</code></pre><h3 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h3><h4 id="基本介绍-4"><a href="#基本介绍-4" class="headerlink" title="基本介绍"></a>基本介绍</h4><ol><li><p>开闭原则(OpenClosedPrinciple)是编程中 <strong><em>最基础、最重要</em></strong>的设计原则</p></li><li><p> 一个软件实体如类，模块和函数应该对 <strong><em>扩展开放(对提供方)，对修改关闭(对使用方)</em></strong>。用抽象构建框架，用实</p></li></ol><p>现扩展细节。</p><ol start="3"><li><p> 当软件需要变化时，尽量 <strong>通过扩展</strong>软件实体的行为来实现变化，而不是 <strong>通过修改</strong>已有的代码来实现变化。</p></li><li><p>编程中遵循其它原则，以及使用设计模式的目的就是遵循开闭原则。</p></li></ol><h4 id="应用实例-3"><a href="#应用实例-3" class="headerlink" title="应用实例"></a>应用实例</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ocp</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        GraphicEditor graphicEditor = <span class="hljs-keyword">new</span> GraphicEditor();        graphicEditor.drawShape(<span class="hljs-keyword">new</span> Rectangle());        graphicEditor.drawShape(<span class="hljs-keyword">new</span> Circle());        graphicEditor.drawShape(<span class="hljs-keyword">new</span> Triangle());    &#125;&#125;<span class="hljs-comment">//绘图类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GraphicEditor</span> </span>&#123;    <span class="hljs-comment">//接受Shape对象 根据m_type绘制图像</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">drawShape</span><span class="hljs-params">(Shape s)</span> </span>&#123;        <span class="hljs-keyword">if</span> (s.m_type == <span class="hljs-number">1</span>)            drawRectangle(s);        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s.m_type == <span class="hljs-number">2</span>)            drawCircle(s);    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">drawRectangle</span><span class="hljs-params">(Shape r)</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot; 矩形 &quot;</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">drawCircle</span><span class="hljs-params">(Shape r)</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot; 圆形 &quot;</span>);    &#125;&#125;<span class="hljs-comment">//Shape类 基类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Shape</span> </span>&#123;    <span class="hljs-keyword">int</span> m_type;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Shape</span> </span>&#123;    Rectangle() &#123;        <span class="hljs-keyword">super</span>.m_type = <span class="hljs-number">1</span>;    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Shape</span> </span>&#123;    Circle() &#123;        <span class="hljs-keyword">super</span>.m_type = <span class="hljs-number">2</span>;    &#125;&#125;</code></pre><p> 问题出在, 如果要新增一个, 需要修改许多:</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Triangle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Shape</span> </span>&#123;    Triangle() &#123;        <span class="hljs-keyword">super</span>.m_type = <span class="hljs-number">3</span>;    &#125;&#125;<span class="hljs-comment">// 如果新增 则需要</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">drawTriangle</span><span class="hljs-params">(Shape r)</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;  &quot;</span>);    &#125;<span class="hljs-comment">// 还需要</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">drawShape</span><span class="hljs-params">(Shape s)</span> </span>&#123;        <span class="hljs-keyword">if</span> (s.m_type == <span class="hljs-number">1</span>)            drawRectangle(s);        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s.m_type == <span class="hljs-number">2</span>)            drawCircle(s);        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s.m_type == <span class="hljs-number">3</span>)            drawTriangle(s);&#125;</code></pre><ol><li><p>优点是比较好理解，简单易操作。</p></li><li><p>缺点是 <strong>违反了设计模式的ocp原则</strong>，即对扩展开放(提供方)，对修改关闭(使用方)。即当我们给类增加新功能的时候，尽量不修改代码，或者尽可能少修改代码.</p></li><li><p>比如我们这时要新增加一个图形种类三角形，我们需要做如上修改，修改的地方较多</p></li></ol><h4 id="改进的思路分析"><a href="#改进的思路分析" class="headerlink" title="改进的思路分析"></a>改进的思路分析</h4><p>思路:把创建 <strong>Shape</strong> 类做成抽象类，并提供一个抽象的 <strong>draw</strong> 方法，让子类去实现即可，这样我们有新的图形 种类时，只需要让新的图形类继承 Shape，并实现 draw 方法即可，使用方的代码就不需要修 -&gt; 满足了开闭原则</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ocp</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        GraphicEditor graphicEditor = <span class="hljs-keyword">new</span> GraphicEditor();        graphicEditor.drawShape(<span class="hljs-keyword">new</span> Rectangle());        graphicEditor.drawShape(<span class="hljs-keyword">new</span> Circle());        graphicEditor.drawShape(<span class="hljs-keyword">new</span> Triangle());        graphicEditor.drawShape(<span class="hljs-keyword">new</span> OtherGraphic());    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GraphicEditor</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">drawShape</span><span class="hljs-params">(Shape s)</span> </span>&#123;        s.draw();    &#125;&#125;<span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Shape</span> </span>&#123;    <span class="hljs-keyword">int</span> m_type;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Shape</span> </span>&#123;    Rectangle() &#123;        <span class="hljs-keyword">super</span>.m_type = <span class="hljs-number">1</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot; 矩形 &quot;</span>);    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Shape</span> </span>&#123;    Circle() &#123;        <span class="hljs-keyword">super</span>.m_type = <span class="hljs-number">2</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot; 圆形 &quot;</span>);    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Triangle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Shape</span> </span>&#123;    Triangle() &#123;        <span class="hljs-keyword">super</span>.m_type = <span class="hljs-number">3</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// TODO Auto-generated method stub</span>        System.out.println(<span class="hljs-string">&quot; 三角形 &quot;</span>);    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OtherGraphic</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Shape</span> </span>&#123;    OtherGraphic() &#123;        <span class="hljs-keyword">super</span>.m_type = <span class="hljs-number">4</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// TODO Auto-generated method stub</span>        System.out.println(<span class="hljs-string">&quot; 其他 &quot;</span>);    &#125;&#125;</code></pre><h3 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h3><h4 id="基本介绍-5"><a href="#基本介绍-5" class="headerlink" title="基本介绍"></a>基本介绍</h4><ol><li>一个对象应该对其他对象 <strong>保持最少的了解</strong></li><li>类与类关系越密切，耦合度越大</li><li>迪米特法则(DemeterPrinciple)又叫 <strong>最少知道原则</strong>，即一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类不管多么复杂，都尽量 <strong>将逻辑封装在类的内部</strong>。对外除了提供的 public 方法，不对外泄露任何信息</li><li>迪米特法则还有个更简单的定义: <strong>只与直接的朋友通信</strong></li><li>直接的朋友:每个对象都会与其他对象有 <strong>耦合关系</strong>，只要两个对象之间有耦合关系，我们就说这两个对象之间 是朋友关系。耦合的方式很多，依赖，关联，组合，聚合等。其中，我们称出现 <strong>成员变量，方法参数，方法返 回值中的类</strong>为直接的朋友，而出现在 <strong>局部变量中的类不是直接的朋友</strong>。也就是说，陌生的类最好不要以局部变 量的形式出现在类的内部。</li></ol><h4 id="应用实例-4"><a href="#应用实例-4" class="headerlink" title="应用实例"></a>应用实例</h4><ol><li><p>有一个学校，下属有各个学院和总部，现要求打印出学校总部员工ID和学院员工的id </p></li><li><p>编程实现上面的功能, 看代码演示</p></li><li><p>代码演示</p></li></ol><pre><code class="hljs java"><span class="hljs-comment">//迪米特法则</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demeter1</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SchoolManager schoolManager = <span class="hljs-keyword">new</span> SchoolManager();        schoolManager.printAllEmployee(<span class="hljs-keyword">new</span> CollegeManager());    &#125;&#125;<span class="hljs-comment">// 学校总部员工</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span> </span>&#123;    <span class="hljs-keyword">private</span> String id;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(String id)</span> </span>&#123;        <span class="hljs-keyword">this</span>.id = id;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> id;    &#125;&#125;<span class="hljs-comment">// 学院员工</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CollegeEmployee</span> </span>&#123;    <span class="hljs-keyword">private</span> String id;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(String id)</span> </span>&#123;        <span class="hljs-keyword">this</span>.id = id;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> id;    &#125;&#125;<span class="hljs-comment">// 管理学院员工类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CollegeManager</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;CollegeEmployee&gt; <span class="hljs-title">getAllEmployee</span><span class="hljs-params">()</span> </span>&#123;        List&lt;CollegeEmployee&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;CollegeEmployee&gt;();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;            CollegeEmployee emp = <span class="hljs-keyword">new</span> CollegeEmployee();            emp.setId(<span class="hljs-string">&quot;学校员工id= &quot;</span> + i);            list.add(emp);        &#125;        <span class="hljs-keyword">return</span> list;    &#125;&#125;<span class="hljs-comment">// 管理学校员工类</span><span class="hljs-comment">//分析 SchoolManager 类的直接朋友类有哪些 Employee、CollegeManager </span><span class="hljs-comment">//CollegeEmployee 不是 直接朋友 而是一个陌生类，这样违背了 迪米特法则</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SchoolManager</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Employee&gt; <span class="hljs-title">getAllEmployee</span><span class="hljs-params">()</span> </span>&#123;        List&lt;Employee&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Employee&gt;();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;            Employee emp = <span class="hljs-keyword">new</span> Employee();            emp.setId(<span class="hljs-string">&quot;学院员工id= &quot;</span> + i);            list.add(emp);        &#125;        <span class="hljs-keyword">return</span> list;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printAllEmployee</span><span class="hljs-params">(CollegeManager sub)</span> </span>&#123;                <span class="hljs-comment">//分析问题</span>                <span class="hljs-comment">//1. 这里的 CollegeEmployee 不是 SchoolManager 的直接朋友 </span>        <span class="hljs-comment">//2. CollegeEmployee 是以局部变量方式出现在 SchoolManager</span>        <span class="hljs-comment">//3. 违反了 迪米特法则</span>        List&lt;CollegeEmployee&gt; list1 = sub.getAllEmployee();        System.out.println(<span class="hljs-string">&quot;------------学院总部------------&quot;</span>);        <span class="hljs-keyword">for</span> (CollegeEmployee e : list1) &#123;            System.out.println(e.getId());        &#125;        List&lt;Employee&gt; list2 = <span class="hljs-keyword">this</span>.getAllEmployee();        System.out.println(<span class="hljs-string">&quot;------------学校总部------------&quot;</span>);        <span class="hljs-keyword">for</span> (Employee e : list2) &#123;            System.out.println(e.getId());        &#125;    &#125;&#125;</code></pre><h4 id="应用实例改进"><a href="#应用实例改进" class="headerlink" title="应用实例改进"></a>应用实例改进</h4><ol><li><p>前面设计的问题在于SchoolManager中，<strong>CollegeEmployee</strong>类并不是<strong>SchoolManager</strong>类的直接朋友(分析) </p></li><li><p>按照迪米特法则，应该避免类中出现这样非直接朋友关系的耦合</p></li></ol><pre><code class="hljs java"><span class="hljs-comment">//迪米特法则</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demeter1</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SchoolManager schoolManager = <span class="hljs-keyword">new</span> SchoolManager();        schoolManager.printAllEmployee(<span class="hljs-keyword">new</span> CollegeManager());    &#125;&#125;<span class="hljs-comment">// 学校总部员工</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span> </span>&#123;    <span class="hljs-keyword">private</span> String id;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(String id)</span> </span>&#123;        <span class="hljs-keyword">this</span>.id = id;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> id;    &#125;&#125;<span class="hljs-comment">// 学院员工</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CollegeEmployee</span> </span>&#123;    <span class="hljs-keyword">private</span> String id;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(String id)</span> </span>&#123;        <span class="hljs-keyword">this</span>.id = id;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> id;    &#125;&#125;<span class="hljs-comment">// 管理学院员工类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CollegeManager</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;CollegeEmployee&gt; <span class="hljs-title">getAllEmployee</span><span class="hljs-params">()</span> </span>&#123;        List&lt;CollegeEmployee&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;CollegeEmployee&gt;();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;            CollegeEmployee emp = <span class="hljs-keyword">new</span> CollegeEmployee();            emp.setId(<span class="hljs-string">&quot;学校员工id= &quot;</span> + i);            list.add(emp);        &#125;        <span class="hljs-keyword">return</span> list;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printAllCollegeEmployee</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-comment">// 将输出转移到CollegeManager类中</span>        List&lt;CollegeEmployee&gt; list1 = <span class="hljs-keyword">this</span>.getAllEmployee();        System.out.println(<span class="hljs-string">&quot;------------学院总部------------&quot;</span>);        <span class="hljs-keyword">for</span> (CollegeEmployee e : list1) &#123;            System.out.println(e.getId());        &#125;    &#125;&#125;<span class="hljs-comment">// 管理学校员工类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SchoolManager</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Employee&gt; <span class="hljs-title">getAllEmployee</span><span class="hljs-params">()</span> </span>&#123;        List&lt;Employee&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Employee&gt;();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;            Employee emp = <span class="hljs-keyword">new</span> Employee();            emp.setId(<span class="hljs-string">&quot;学院员工id= &quot;</span> + i);            list.add(emp);        &#125;        <span class="hljs-keyword">return</span> list;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printAllEmployee</span><span class="hljs-params">(CollegeManager sub)</span> </span>&#123;        <span class="hljs-comment">// 将输出转移到CollegeManager类中</span>        sub.printAllCollegeEmployee();        List&lt;Employee&gt; list2 = <span class="hljs-keyword">this</span>.getAllEmployee();        System.out.println(<span class="hljs-string">&quot;------------学校总部------------&quot;</span>);        <span class="hljs-keyword">for</span> (Employee e : list2) &#123;            System.out.println(e.getId());        &#125;    &#125;&#125;</code></pre><h4 id="迪米特法则注意事项和细节"><a href="#迪米特法则注意事项和细节" class="headerlink" title="迪米特法则注意事项和细节"></a>迪米特法则注意事项和细节</h4><ol><li>迪米特法则的核心是 <strong>降低类之间的耦合</strong></li><li>但是注意:由于每个类都减少了不必要的依赖，因此迪米特法则 <strong>只是要求降低类间(对象间)耦合关系，并不是要求完全没有依赖关系</strong></li></ol><h3 id="合成复用原则-Composite-Reuse-Principle"><a href="#合成复用原则-Composite-Reuse-Principle" class="headerlink" title="合成复用原则(Composite Reuse Principle)"></a>合成复用原则(Composite Reuse Principle)</h3><h4 id="基本介绍-6"><a href="#基本介绍-6" class="headerlink" title="基本介绍"></a>基本介绍</h4><blockquote><p>原则是尽量使用合成/聚合的方式，而不是使用继承</p></blockquote><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201202110642.png" alt="不使用继承" style="zoom:50%;" /><h4 id="设计原则核心思想"><a href="#设计原则核心思想" class="headerlink" title="设计原则核心思想"></a>设计原则核心思想</h4><ol><li><p>找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。 </p></li><li><p>针对 <strong>接口编程</strong>，而不是针对实现编程。</p></li><li><p>为了交互对象之间的 <strong>松耦合设计而努力</strong></p></li></ol><h2 id="UML-基本介绍"><a href="#UML-基本介绍" class="headerlink" title="UML 基本介绍"></a>UML 基本介绍</h2><ul><li><p>UML——Unified modeling language UML (统一建模语言)，是一种用于软件系统分析和设计的语言工具，它用 于帮助软件开发人员进行思考和记录思路的结果</p></li><li><p>UML 本身是一套符号的规定，就像数学符号和化学符号一样，这些符号用于描述软件模型中的各个元素和他 们之间的关系，比如类、接口、实现、泛化、依赖、组合、聚合等，如右图:</p></li></ul><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201202111756.png" alt="test" style="zoom:50%;" /><h3 id="类图—依赖关系-Dependence"><a href="#类图—依赖关系-Dependence" class="headerlink" title="类图—依赖关系(Dependence)"></a>类图—依赖关系(Dependence)</h3><blockquote><p>只要是在类中用到了对方，那么他们之间就存在依赖关系。如果没有对方，连编绎都通过不了。</p></blockquote><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201202112951.png" alt="依赖"></p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201202113519.png" alt="依赖关系" style="zoom:50%;" /><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PersonServiceBean</span> </span>&#123;<span class="hljs-keyword">private</span> PersonDao personDao;<span class="hljs-comment">//类 public void save(Person person)&#123;&#125;</span><span class="hljs-function"><span class="hljs-keyword">public</span> IDCard <span class="hljs-title">getIDCard</span><span class="hljs-params">(Integer personid)</span></span>&#123;&#125; <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">modify</span><span class="hljs-params">()</span></span>&#123;Department department = <span class="hljs-keyword">new</span> Department(); &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PersonDao</span></span>&#123;&#125; <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IDCard</span></span>&#123;&#125; <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;&#125; <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Department</span></span>&#123;&#125;</code></pre><pre><code class="hljs plain">1) 类中用到了对方2) 如果是类的成员属性 3) 如果是方法的返回类型 4) 是方法接收的参数类型 5) 方法中使用到</code></pre><h3 id="类图—泛化关系-generalization"><a href="#类图—泛化关系-generalization" class="headerlink" title="类图—泛化关系(generalization)"></a>类图—泛化关系(generalization)</h3><blockquote><p>泛化关系实际上就是继承关系，他是依赖关系的特例</p></blockquote><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201202113350.png" alt="依赖关系" style="zoom:50%;" /><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201202113543.png" alt="泛化关系" style="zoom:50%;" /><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DaoSupport</span></span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">save</span><span class="hljs-params">(Object entity)</span></span>&#123; &#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delete</span><span class="hljs-params">(Object id)</span></span>&#123;&#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PersonServiceBean</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Daosupport</span></span>&#123; &#125;</code></pre><pre><code class="hljs dns"><span class="hljs-number">1</span>) 泛化关系实际上就是继承关系<span class="hljs-number">2</span>) 如果<span class="hljs-keyword">A</span>类继承了B类，我们就说<span class="hljs-keyword">A</span>和B存在泛化关系</code></pre><h3 id="类图—实现关系-Implementation"><a href="#类图—实现关系-Implementation" class="headerlink" title="类图—实现关系(Implementation)"></a>类图—实现关系(Implementation)</h3><p>实现关系实际上就是 <strong>A</strong> 类实现 <strong>B</strong> 接口，他是 <strong>依赖关系的特例</strong></p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201202113728.png" alt="实现关系" style="zoom:50%;" /><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201202113745.png" alt="实现关系" style="zoom:50%;" /><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">PersonService</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delete</span><span class="hljs-params">(Interger id)</span></span>;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PersonServiceBean</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">PersonService</span> </span>&#123; <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delete</span><span class="hljs-params">(Interger id)</span></span>&#123;&#125;&#125;</code></pre><h3 id="类图—关联关系-Association"><a href="#类图—关联关系-Association" class="headerlink" title="类图—关联关系(Association)"></a>类图—关联关系(Association)</h3><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201202113841.png" alt="关联关系" style="zoom:67%;" /><h3 id="类图—聚合关系-Aggregation"><a href="#类图—聚合关系-Aggregation" class="headerlink" title="类图—聚合关系(Aggregation)"></a>类图—聚合关系(Aggregation)</h3><h4 id="基本介绍-7"><a href="#基本介绍-7" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>聚合关系(Aggregation)表示的是整体和部分的关系，整体与部分可以分开。聚合关系是关联关系的特例，所以他具有 <strong>关联的导航性与多重性</strong>。</p><p>如:一台电脑由键盘(keyboard)、显示器(monitor)，鼠标等组成;组成电脑的各个配件是可以从电脑上分离出来 的，使用带空心菱形的实线来表示:</p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201202114201.png" alt="聚合" style="zoom:50%;" /><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201202114230.png" alt="聚合" style="zoom:50%;" /><h3 id="类图—组合关系-Composition"><a href="#类图—组合关系-Composition" class="headerlink" title="类图—组合关系(Composition)"></a>类图—组合关系(Composition)</h3><h4 id="基本介绍-8"><a href="#基本介绍-8" class="headerlink" title="基本介绍"></a>基本介绍</h4><blockquote><p>组合关系:也是整体与部分的关系，但是整体与部分 <strong><em>不可以分开</em></strong>。</p></blockquote><p>再看一个案例:在程序中我们定义实体:Person 与 IDCard、Head, 那么 Head 和 Person 就是 组合，IDCard 和 Person 就是聚合。</p><p>但是如果在程序中 Person 实体中定义了对 IDCard 进行级联删除，即删除 Person 时连同 IDCard 一起删除，那 么 IDCard 和 Person 就是组合了.</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;    <span class="hljs-keyword">private</span> IDCard card;     <span class="hljs-keyword">private</span> Head head = <span class="hljs-keyword">new</span> Head(); <span class="hljs-comment">// 注意区别</span>&#125;</code></pre><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201202114443.png" alt="组合" style="zoom:50%;" /><p>如果把聚合案例代码改成:</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Computer</span> </span>&#123;<span class="hljs-keyword">private</span> Mouse mouse = <span class="hljs-keyword">new</span> Mouse(); <span class="hljs-comment">//鼠标可以和 computer 不能分离 </span><span class="hljs-keyword">private</span> Moniter moniter = <span class="hljs-keyword">new</span> Moniter();<span class="hljs-comment">//显示器可以和 Computer 不能分离</span>&#125;</code></pre><h2 id="设计模式介绍"><a href="#设计模式介绍" class="headerlink" title="设计模式介绍"></a>设计模式介绍</h2><ol><li>设计模式是程序员在面对同类软件工程设计问题所总结出来的有用的经验， <strong>模式不是代码</strong>，而是某类问题的通 用解决方案， <strong>设计模式(Design pattern)代表了最佳的实践</strong>。这些解决方案是众多软件开发人员经过相当长的 一段时间的试验和错误总结出来的。</li><li>设计模式的本质 <strong>提高软件的维护性，通用性和扩展性，并降低软件的复杂度</strong>。</li><li>&lt;&lt;设计模式&gt;&gt; 是经典的书，作者是 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides Design(俗称 “四人组 GOF”)</li><li>设计模式并 <strong>不局限于某种语言</strong>，java，php，c++ 都有设计模式.</li></ol><h2 id="设计模式类型"><a href="#设计模式类型" class="headerlink" title="设计模式类型"></a>设计模式类型</h2><blockquote><p>设计模式分为三种类型，共 <strong>23</strong> 种</p></blockquote><ol><li><p>创建型模式: <strong><em>单例模式</em></strong>、抽象工厂模式、原型模式、建造者模式、 <strong><em>工厂模式</em></strong>。</p></li><li><p>结构型模式:适配器模式、桥接模式、 <strong><em>装饰模式</em></strong>、组合模式、外观模式、享元模式、 <strong><em>代理模式</em></strong>。</p></li><li><p>行为型模式:模版方法模式、命令模式、访问者模式、迭代器模式、 <strong><em>观察者模式</em></strong>、中介者模式、备忘录模式、 解释器模式(Interpreter 模式)、状态模式、策略模式、职责链模式(责任链模式)。</p></li></ol><p>注意: <strong>不同的书籍上对分类和名称略有差别</strong></p><h1 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h1><h2 id="单例设计模式介绍"><a href="#单例设计模式介绍" class="headerlink" title="单例设计模式介绍"></a>单例设计模式介绍</h2><blockquote><p>所谓类的单例设计模式, 就是 **采取一定的方法保证在整个的软件系统中, 对某一个类只能存在一个对象实例, 并且该类只提供一个取得其对象实例的方法(静态方法)**。</p></blockquote><p>​       比如 Hibernate 的 SessionFactory，它充当数据存储源的代理，并负责创建 Session 对象。SessionFactory 并不是 轻量级的，一般情况下，一个项目通常只需要一个 SessionFactory 就够，这是就会使用到单例模式。</p><h2 id="单例设计模式八种方式"><a href="#单例设计模式八种方式" class="headerlink" title="单例设计模式八种方式"></a>单例设计模式八种方式</h2><p><strong>1) 饿汉式(静态常量)</strong></p><p><strong>2) 饿汉式(静态代码块)</strong></p><ol start="3"><li><p>懒汉式(线程不安全)</p></li><li><p>懒汉式(线程安全，同步方法) </p></li><li><p>懒汉式(线程不安全，同步代码块) </p></li></ol><p> <strong>6) 双重检查</strong></p><p> <strong>7) 静态内部类</strong></p><p> <strong>8) 枚举</strong></p><h3 id="饿汉式-静态常量"><a href="#饿汉式-静态常量" class="headerlink" title="饿汉式(静态常量)"></a>饿汉式(静态常量)</h3><ol><li>构造器私有化 (防止 new )</li><li>类的内部创建对象</li><li>向外暴露一个静态的公共方法。getInstance </li></ol><p>代码实现:</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 饿汉式(静态常量)实现单例模式</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonTest</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Singleton singleton1 = Singleton.getInstance();        Singleton singleton2 = Singleton.getInstance();        System.out.println(singleton1 == singleton2); <span class="hljs-comment">// true</span>        System.out.println(<span class="hljs-string">&quot;singleton1.hashCode():&quot;</span>+singleton1.hashCode());        System.out.println(<span class="hljs-string">&quot;singleton2.hashCode():&quot;</span>+singleton2.hashCode());        <span class="hljs-comment">//singleton1.hashCode():1639705018</span>        <span class="hljs-comment">//singleton2.hashCode():1639705018</span>    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span></span>&#123;    <span class="hljs-comment">// 1. 构造器私有化</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span></span>&#123;&#125;    <span class="hljs-comment">// 2. 本类内部创建对象实例</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton instance = <span class="hljs-keyword">new</span> Singleton();    <span class="hljs-comment">// 3. 提供公有的静态方法返回实例对象</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> instance;    &#125;&#125;</code></pre><ol><li><p>优点:这种写法比较简单，就是在 <strong>类装载的时候就完成实例化</strong>。 <strong>避免了线程同步问题</strong>。</p></li><li><p>缺点:在类装载的时候就完成实例化，<strong>没有达到LazyLoading的效果</strong>。如果从始至终从未使用过这个实例，则</p><p>会造成内存的浪费</p></li><li><p>这种方式基于classloder机制避免了多线程的同步问题，不过，instance在类装载时就实例化，在单例模式中大多数都是调用 getInstance 方法，但是 <strong>导致类装载的原因有很多种</strong>，因此不能确定有其他的方式(或者其他的静态方法)导致类装载，这时候初始化 instance 就 <strong>没有达到 lazy loading 的效果</strong></p></li></ol><p>结论:这种单例模式 <strong><em>可用</em></strong>，可能造成 <strong><em>内存浪费</em></strong></p><h3 id="饿汉式-静态代码块"><a href="#饿汉式-静态代码块" class="headerlink" title="饿汉式(静态代码块)"></a>饿汉式(静态代码块)</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonTest</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Singleton singleton1 = Singleton.getInstance();        Singleton singleton2 = Singleton.getInstance();        System.out.println(singleton1 == singleton2); <span class="hljs-comment">// true</span>        System.out.println(<span class="hljs-string">&quot;singleton1.hashCode():&quot;</span>+singleton1.hashCode());        System.out.println(<span class="hljs-string">&quot;singleton2.hashCode():&quot;</span>+singleton2.hashCode());        <span class="hljs-comment">//singleton1.hashCode():1639705018</span>        <span class="hljs-comment">//singleton2.hashCode():1639705018</span>    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span></span>&#123;    <span class="hljs-comment">// 1.构造器私有化</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span></span>&#123;&#125;    <span class="hljs-comment">// 2.类中创建对象事例</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;    <span class="hljs-keyword">static</span> &#123;        <span class="hljs-comment">// 静态代码块中创建事例</span>        instance = <span class="hljs-keyword">new</span> Singleton();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> instance;&#125;&#125;</code></pre><ol><li>这种方式和上面的方式其实类似，只不过将类实例化的过程放在了静态代码块中，也是在类装载的时候，就执行静态代码块中的代码，初始化类的实例。优缺点和上面是一样的。</li></ol><p>结论:这种单例模式可用，但是可能造成内存浪费</p><h3 id="懒汉式-线程不安全"><a href="#懒汉式-线程不安全" class="headerlink" title="懒汉式(线程不安全)"></a>懒汉式(线程不安全)</h3><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 懒汉式(线程不安全写法)</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonTest</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Singleton singleton1 = Singleton.getInstance();        Singleton singleton2 = Singleton.getInstance();        System.out.println(singleton1 == singleton2); <span class="hljs-comment">// true</span>        System.out.println(<span class="hljs-string">&quot;singleton1.hashCode():&quot;</span>+singleton1.hashCode());        System.out.println(<span class="hljs-string">&quot;singleton2.hashCode():&quot;</span>+singleton2.hashCode());        <span class="hljs-comment">// singleton1.hashCode():1639705018</span>        <span class="hljs-comment">// singleton2.hashCode():1639705018</span>    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span></span>&#123;&#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;    <span class="hljs-comment">// 构造一个静态方法, 当用到该方法时, 才创建实例</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>)&#123;            instance = <span class="hljs-keyword">new</span> Singleton();        &#125;        <span class="hljs-keyword">return</span> instance;    &#125;&#125;</code></pre><ol><li><p>起到了 <strong>LazyLoading</strong>的效果，但是只能在 <strong>单线程</strong>下使用。</p></li><li><p>如果在多线程下，一个线程进入了if(singleton==null)判断语句块，还未来得及往下执行，另一个线程也通过</p><p>了这个判断语句，这时便会产生 <strong>多个实例</strong>。所以在多线程环境下不可使用这种方式 </p></li></ol><p>​   结论:在实际开发中，<strong>不要使用这种方式</strong>.</p><h3 id="懒汉式-线程安全，同步方法"><a href="#懒汉式-线程安全，同步方法" class="headerlink" title="懒汉式(线程安全，同步方法)"></a>懒汉式(线程安全，同步方法)</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span></span>&#123;&#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>)&#123;            instance = <span class="hljs-keyword">new</span> Singleton();        &#125;        <span class="hljs-keyword">return</span> instance;    &#125;&#125;</code></pre><ol><li><p><strong>解决了线程安全问题</strong></p></li><li><p><strong>效率太低</strong>了，每个线程在想获得类的实例时候，执行getInstance()方法 <strong>都要进行同步</strong>。而其实这个方法只执行一次实例化代码就够了，后面的想获得该类实例，直接 return 就行了。方法进行同步效率太低 </p><p>结论:在实际开发中，<strong>不推荐使用这种方式</strong></p></li></ol><h3 id="懒汉式-线程不安全，同步代码块"><a href="#懒汉式-线程不安全，同步代码块" class="headerlink" title="懒汉式(线程不安全，同步代码块)"></a>懒汉式(线程不安全，同步代码块)</h3><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201202150123.png" alt="无效" style="zoom:50%;" /><p>​   在这里加入synchronized无效, 无法解决线程安全问题, 一个线程进入了if(singleton==null)判断语句块, 还未来得及往下执行, 另一个线程也通过了这个判断语句, 这时便会产生 <strong>多个实例</strong>。</p><h3 id="双重检查"><a href="#双重检查" class="headerlink" title="双重检查"></a>双重检查</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span></span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Singleton instance;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span></span>&#123;&#125;    <span class="hljs-comment">// 提供一个静态代码块，双重检查，解决线程安全问题，同时解决懒加载问题</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">synchronized</span> (Singleton.class)&#123;                <span class="hljs-keyword">if</span>(instance == <span class="hljs-keyword">null</span>)&#123;                    instance = <span class="hljs-keyword">new</span> Singleton();                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> instance;    &#125;&#125;</code></pre><ol><li>Double-Check 概念是多线程开发中常使用到的，如代码中所示，我们进行了两次 if (singleton == null)检查，这 样就可以保证线程安全了。</li><li>这样，实例化代码只用执行一次，后面再次访问时，判断if(singleton==null)，直接return实例化对象，也避免的反复进行方法同步.</li><li><strong>线程安全; 延迟加载;效率较高</strong></li></ol><p>结论:在实际开发中， <strong>推荐使用这种单例设计模式</strong></p><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><blockquote><p>JVM装载类的时候线程是安全的</p></blockquote><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span></span>&#123;&#125;    <span class="hljs-comment">// 写一个静态内部类，该类中有一个静态属性Singleton</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonInstance</span></span>&#123;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton INSTANCE = <span class="hljs-keyword">new</span> Singleton();    &#125;    <span class="hljs-comment">// 提供一个静态公有方法，返回SingletonInstance.INSTANCE</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> SingletonInstance.INSTANCE;    &#125;&#125;</code></pre><ol><li><p>这种方式采用了 <strong>类装载的机制</strong>来保证初始化实例时只有一个线程。(因为类装载是线程安全的)</p></li><li><p>  <strong>静态内部类方式在Singleton类被装载时并不会立即实例化</strong>，而是在需要实例化时， <strong>调用getInstance方法</strong>， <strong>才会装载 SingletonInstance 类</strong>，从而完成 Singleton 的实例化。</p></li><li><p> 类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM帮助我们保证了线程的安全性，在类进行   初始化时，别的线程是无法进入的。</p></li><li><p> 优点: <strong>避免了线程不安全，利用静态内部类特点实现延迟加载，效率高</strong></p></li><li><p> 结论: <strong>推荐</strong>使用.</p></li></ol><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Singleton</span></span>&#123;    INSTANCE;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayOK</span><span class="hljs-params">()</span></span>&#123;        System.out.println(<span class="hljs-string">&quot;ok!&quot;</span>);    &#125;&#125;</code></pre><p>使用:</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    Singleton instance = Singleton.INSTANCE;    Singleton instance2 = Singleton.INSTANCE;    System.out.println(instance == instance2);    System.out.println(instance.hashCode());    System.out.println(instance2.hashCode());    instance.sayOK(); &#125;</code></pre><ol><li><p> 这 <strong>借助JDK1.5中添加的枚举</strong>来实现单例模式。不仅能 <strong>避免多线程同步问题，而且还能防止反序列化重新创建 新的对象</strong>。</p></li><li><p> 这种方式是<strong>EffectiveJava</strong>作者<strong>JoshBloch</strong>提倡的方式</p></li></ol><p>​    结论: <strong>推荐</strong>使用</p>]]></content>
    
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java并发编程 学习笔记</title>
    <link href="/2020/11/27/Java%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    <url>/2020/11/27/Java%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1、进程与线程"><a href="#1、进程与线程" class="headerlink" title="1、进程与线程"></a>1、进程与线程</h2><h3 id="1-1、概念"><a href="#1-1、概念" class="headerlink" title="1.1、概念"></a>1.1、概念</h3><blockquote><p> 进程</p></blockquote><ul><li>程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至 CPU，数据加载至内存。在 指令运行过程中还需要用到磁盘、网络等设备。进程就是用来加载指令、管理内存、管理 IO 的 </li><li>当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。 </li><li>进程就可以视为程序的一个实例。大部分程序可以同时运行多个实例进程(例如记事本、画图、浏览器 等)，也有的程序只能启动一个实例进程(例如网易云音乐、360 安全卫士等)</li></ul><blockquote><p>线程</p></blockquote><ul><li>一个进程之内可以分为一到多个线程。 </li><li>一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给 CPU 执行</li><li>Java 中，线程作为最小调度单位，进程作为资源分配的最小单位。 在 windows 中进程是不活动的，只是作为线程的容器</li></ul><blockquote><p>二者对比</p></blockquote><ul><li><p>进程基本上相互独立的，而线程存在于进程内，是进程的一个子集</p></li><li><p>进程拥有共享的资源，如内存空间等，供其内部的线程共享</p></li><li><p>进程间通信较为复杂</p><ul><li>同一台计算机的进程通信称为 IPC(Inter-process communication) </li><li>不同计算机之间的进程通信，需要通过网络，并遵守共同的协议，例如 HTTP</li></ul></li><li><p>线程通信相对简单，因为它们共享进程内的内存，一个例子是多个线程可以访问同一个共享变量</p></li><li><p>线程更轻量，线程上下文切换成本一般上要比进程上下文切换低</p></li></ul><h3 id="1-2-并行与并发"><a href="#1-2-并行与并发" class="headerlink" title="1.2 并行与并发"></a>1.2 并行与并发</h3><blockquote><p>并发</p></blockquote><p>单核 cpu 下，线程实际还是 <strong><em>串行执行</em></strong> 的。操作系统中有一个组件叫做 <strong><em>任务调度器</em></strong>，将 cpu 的时间片(windows 下时间片最小约为 15 毫秒)分给不同的程序使用，只是由于 cpu 在线程间(时间片很短)的切换非常快，人类感 觉是 同时运行的 。总结为一句话就是: <strong><em>微观串行，宏观并行</em></strong> ，</p><p>一般会将这种 <strong><em>线程轮流使用 CPU</em></strong> 的做法称为 <strong><em>并发</em></strong>， concurrent</p><table><thead><tr><th align="center">CPU</th><th>时间片1</th><th>时间片2</th><th>时间片3</th><th>时间片4</th></tr></thead><tbody><tr><td align="center">core</td><td>线程1</td><td>线程2</td><td>线程3</td><td>线程4</td></tr></tbody></table><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201127140415.png" alt="执行" style="zoom:33%;" /><blockquote><p>并行</p></blockquote><p>多核 cpu下，每个 核(core) 都可以调度运行线程，这时候线程可以是并行的。</p><table><thead><tr><th align="center">CPU</th><th>时间片1</th><th>时间片2</th><th>时间片3</th><th>时间片4</th></tr></thead><tbody><tr><td align="center">Core1</td><td>线程1</td><td>线程1</td><td>线程3</td><td>线程3</td></tr><tr><td align="center">Core2</td><td>线程2</td><td>线程4</td><td>线程2</td><td>线程4</td></tr></tbody></table><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201127140834.png" alt="执行" style="zoom:33%;" /><p>引用 Rob Pike (golang 创始人)的一段描述: </p><ul><li><p><strong>并发(concurrent)是同一时间应对(dealing with)多件事情的能力</strong></p></li><li><p><strong>并行(parallel)是同一时间动手做(doing)多件事情的能力</strong></p></li></ul><blockquote><p>例子</p></blockquote><ul><li><p>家庭主妇做饭、打扫卫生、给孩子喂奶，她一个人轮流交替做这多件事，这时就是并发</p></li><li><p>家庭主妇雇了个保姆，她们一起这些事，这时既有并发，也有并行(这时会产生竞争，例如锅只有一口，一<br>  个人用锅时，另一个人就得等待)</p></li><li><p>雇了3个保姆，一个专做饭、一个专打扫卫生、一个专喂奶，互不干扰，这时是并行</p></li></ul><h3 id="1-3、应用"><a href="#1-3、应用" class="headerlink" title="1.3、应用"></a>1.3、应用</h3><blockquote><p>应用之异步调用(案例1)</p></blockquote><p>以调用方角度来讲，如果</p><ul><li>需要等待结果返回，才能继续运行就是同步</li><li>不需要等待结果返回，就能继续运行就是异步</li></ul><ol><li>设计<br>多线程可以让方法执行变为异步的(即不要巴巴干等着)比如说读取磁盘文件时，假设读取操作花费了 5 秒钟，如</li></ol><p>果没有线程调度机制，这 5 秒 cpu 什么都做不了，其它代码都得暂停…</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201127144136.png" alt="同步"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201127144618.png" alt="异步"></p><ol start="2"><li>结论</li></ol><ul><li>比如在项目中，视频文件需要转换格式等操作比较费时，这时开一个新线程处理视频转换，避免阻塞主线程 - </li><li>tomcat 的异步 servlet 也是类似的目的，让用户线程处理耗时较长的操作，避免阻塞 tomcat 的工作线程 </li><li>ui 程序中，开线程进行其他操作，避免阻塞 ui 线程</li></ul><blockquote><p>应用之提高效率(案例1)</p></blockquote><p>充分利用多核 cpu 的优势，提高运行效率。想象下面的场景，执行 3 个计算，最后将计算结果汇总。</p><pre><code class="hljs crmsh">计算 <span class="hljs-number">1</span> 花费 <span class="hljs-number">10</span> <span class="hljs-keyword">ms</span> <span class="hljs-title"></span><span class="hljs-title">计算 2</span> 花费 <span class="hljs-number">11</span> <span class="hljs-keyword">ms</span> <span class="hljs-title"></span><span class="hljs-title">计算 3</span> 花费 <span class="hljs-number">9</span> <span class="hljs-keyword">ms</span> <span class="hljs-title"></span><span class="hljs-title">汇总需要 1</span> ms</code></pre><ul><li>如果是串行执行，那么总共花费的时间是 10 + 11 + 9 + 1 = 31ms</li><li> 但如果是四核 cpu，各个核心分别使用线程 1 执行计算 1，线程 2 执行计算 2，线程 3 执行计算 3，那么 3 个 线程是并行的，花费时间只取决于最长的那个线程运行的时间，即 11ms 最后加上汇总时间只会花费 12ms</li></ul><p><strong><em>注意</em></strong>:<strong><em>需要在多核 cpu 才能提高效率，单核仍然时是轮流执行</em></strong></p><hr><h4 id="1-3、效率案例"><a href="#1-3、效率案例" class="headerlink" title="1.3、效率案例"></a>1.3、效率案例</h4><blockquote><p>// TODO JMH测试</p></blockquote><p>1)设计代码:</p><pre><code class="hljs java"><span class="hljs-meta">@Fork(1)</span><span class="hljs-meta">@BenchmarkMode(Mode.AverageTime)</span><span class="hljs-meta">@Warmup(iterations=3)</span><span class="hljs-meta">@Measurement(iterations=5)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBenchmark</span> </span>&#123;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] ARRAY = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">1000_000_00</span>];    <span class="hljs-keyword">static</span> &#123;        Arrays.fill(ARRAY, <span class="hljs-number">1</span>);    &#125;    <span class="hljs-meta">@Benchmark</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">c</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-keyword">int</span>[] array = ARRAY;        FutureTask&lt;Integer&gt; t1 = <span class="hljs-keyword">new</span> FutureTask&lt;&gt;(()-&gt;&#123;            <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">250_000_00</span>;i++) &#123;                sum += array[<span class="hljs-number">0</span>+i];            &#125;            <span class="hljs-keyword">return</span> sum;        &#125;);        FutureTask&lt;Integer&gt; t2 = <span class="hljs-keyword">new</span> FutureTask&lt;&gt;(()-&gt;&#123;            <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">250_000_00</span>;i++) &#123;                sum += array[<span class="hljs-number">250_000_00</span>+i];            &#125;            <span class="hljs-keyword">return</span> sum;        &#125;);        FutureTask&lt;Integer&gt; t3 = <span class="hljs-keyword">new</span> FutureTask&lt;&gt;(()-&gt;&#123;            <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">250_000_00</span>;i++) &#123;                sum += array[<span class="hljs-number">500_000_00</span>+i];            &#125;            <span class="hljs-keyword">return</span> sum;        &#125;);        FutureTask&lt;Integer&gt; t4 = <span class="hljs-keyword">new</span> FutureTask&lt;&gt;(()-&gt;&#123;            <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">250_000_00</span>;i++) &#123;                sum += array[<span class="hljs-number">750_000_00</span>+i];            &#125;            <span class="hljs-keyword">return</span> sum;        &#125;);        <span class="hljs-keyword">new</span> Thread(t1).start();        <span class="hljs-keyword">new</span> Thread(t2).start();        <span class="hljs-keyword">new</span> Thread(t3).start();        <span class="hljs-keyword">new</span> Thread(t4).start();        <span class="hljs-keyword">return</span> t1.get() + t2.get() + t3.get()+ t4.get();    &#125;    <span class="hljs-meta">@Benchmark</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">d</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-keyword">int</span>[] array = ARRAY;        FutureTask&lt;Integer&gt; t1 = <span class="hljs-keyword">new</span> FutureTask&lt;&gt;(()-&gt;&#123;            <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000_000_00</span>;i++) &#123;                sum += array[<span class="hljs-number">0</span>+i];            &#125;            <span class="hljs-keyword">return</span> sum;        &#125;);        <span class="hljs-keyword">new</span> Thread(t1).start();        <span class="hljs-keyword">return</span> t1.get();    &#125;&#125;</code></pre><p>测试结果:</p><blockquote><p>多核</p></blockquote><pre><code class="hljs apache"><span class="hljs-attribute">Benchmark</span> Mode Samples Score Score error Units <span class="hljs-attribute">o</span>.s.MyBenchmark.c avgt <span class="hljs-number">5</span> <span class="hljs-number">0</span>.<span class="hljs-number">020</span> <span class="hljs-number">0</span>.<span class="hljs-number">001</span> s/op <span class="hljs-attribute">o</span>.s.MyBenchmark.d avgt <span class="hljs-number">5</span> <span class="hljs-number">0</span>.<span class="hljs-number">043</span> <span class="hljs-number">0</span>.<span class="hljs-number">003</span> s/op</code></pre><blockquote><p>单核</p></blockquote><pre><code class="hljs apache"><span class="hljs-attribute">Benchmark</span> Mode Samples Score Score error Units <span class="hljs-attribute">o</span>.s.MyBenchmark.c avgt <span class="hljs-number">5</span> <span class="hljs-number">0</span>.<span class="hljs-number">061</span> <span class="hljs-number">0</span>.<span class="hljs-number">060</span> s/op <span class="hljs-attribute">o</span>.s.MyBenchmark.d avgt <span class="hljs-number">5</span> <span class="hljs-number">0</span>.<span class="hljs-number">064</span> <span class="hljs-number">0</span>.<span class="hljs-number">071</span> s/op</code></pre><p>2)结论:</p><ul><li><p>单核 cpu 下，多线程不能实际提高程序运行效率，只是为了能够在不同的任务之间切换，不同线程轮流使用 cpu ，不至于一个线程总占用 cpu，别的线程没法干活</p></li><li><p>多核 cpu 可以并行跑多个线程，但能否提高程序运行效率还是要分情况的</p><ul><li>有些任务，经过精心设计，将任务拆分，并行执行，当然可以提高程序的运行效率。但不是所有计算任<br> 务都能拆分(参考后文的 <strong><em>【阿姆达尔定律】</em></strong>)</li><li> 也不是所有任务都需要拆分，任务的目的如果不同，谈拆分和效率没啥意义</li></ul></li><li><p>IO 操作不占用 cpu，只是我们一般拷贝文件使用的是 <strong><em>【阻塞 IO】</em></strong>，这时相当于线程虽然不用 cpu，但需要一 直等待 IO 结束，没能充分利用线程。所以才有后面的 <strong><em>【非阻塞 IO】</em></strong>和 <strong><em>【异步 IO】</em></strong>优化</p></li></ul><h2 id="2、Java-线程"><a href="#2、Java-线程" class="headerlink" title="2、Java 线程"></a>2、Java 线程</h2><h3 id="2-1、创建和运行线程"><a href="#2-1、创建和运行线程" class="headerlink" title="2.1、创建和运行线程"></a>2.1、创建和运行线程</h3><h4 id="方法一-直接使用Thread"><a href="#方法一-直接使用Thread" class="headerlink" title="方法一, 直接使用Thread"></a>方法一, 直接使用Thread</h4><pre><code class="hljs java"><span class="hljs-comment">// 创建线程对象</span>Thread t = <span class="hljs-keyword">new</span> Thread()&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 要执行的任务</span>    &#125;&#125;;t.setName(<span class="hljs-string">&quot;t0&quot;</span>);<span class="hljs-comment">// 启动线程</span>t.start();</code></pre><p>例如:</p><pre><code class="hljs java"><span class="hljs-comment">// 构造方法的参数是给线程指定名字，推荐 </span>Thread t1 = <span class="hljs-keyword">new</span> Thread(<span class="hljs-string">&quot;t1&quot;</span>)&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        log.info(<span class="hljs-string">&quot;hello&quot;</span>);    &#125;&#125;;t1.start();</code></pre><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201127161656.png" alt="test" style="zoom:50%;" /><h4 id="方法二-使用Runnable配合thread"><a href="#方法二-使用Runnable配合thread" class="headerlink" title="方法二, 使用Runnable配合thread"></a>方法二, 使用Runnable配合thread</h4><p>把【线程】和【任务】(要执行的代码)分开</p><ul><li>Thread 代表线程</li><li>Runnable 可运行的任务(线程要执行的代码)</li></ul><pre><code class="hljs java">Runnable runnable = <span class="hljs-keyword">new</span> Runnable() &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 要执行的任务</span>        log.debug(<span class="hljs-string">&quot;running&quot;</span>);    &#125;&#125;;<span class="hljs-comment">// 创建线程对象</span>Thread t = <span class="hljs-keyword">new</span> Thread(runnable, <span class="hljs-string">&quot;t2&quot;</span>);<span class="hljs-comment">// 启动线程</span>t.start();</code></pre><pre><code class="hljs css">16<span class="hljs-selector-pseudo">:22</span><span class="hljs-selector-pseudo">:02</span> <span class="hljs-selector-attr">[t2]</span> <span class="hljs-selector-tag">c</span><span class="hljs-selector-class">.Test</span> <span class="hljs-selector-tag">-</span> <span class="hljs-selector-tag">running</span></code></pre><h4 id="lambda精简代码"><a href="#lambda精简代码" class="headerlink" title="lambda精简代码"></a>lambda精简代码</h4><blockquote><p>JDK中只有一个抽象方法的接口会加一个 @FunctionalInterface 注解，可被lambda表达式简化</p></blockquote><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201127162415.png" alt="注解" style="zoom:33%;" /><pre><code class="hljs java">Runnable r2 = () -&gt; &#123;log.debug(<span class="hljs-string">&quot;running&quot;</span>);&#125;;Thread t2 = <span class="hljs-keyword">new</span> Thread(r2, <span class="hljs-string">&quot;t2&quot;</span>);t2.start();Runnable r3 = () -&gt; log.debug(<span class="hljs-string">&quot;running&quot;</span>);Thread t3 = <span class="hljs-keyword">new</span> Thread(r3, <span class="hljs-string">&quot;t3&quot;</span>);t3.start();Thread t4 = <span class="hljs-keyword">new</span> Thread(()-&gt;log.debug(<span class="hljs-string">&quot;running&quot;</span>), <span class="hljs-string">&quot;t4&quot;</span>);        t4.start();</code></pre><h4 id="原理之-Thread-与-Runnable-的关系"><a href="#原理之-Thread-与-Runnable-的关系" class="headerlink" title="原理之 Thread 与 Runnable 的关系"></a>原理之 Thread 与 Runnable 的关系</h4><p>1.跟随Thread(Runnable target)源码</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Thread</span><span class="hljs-params">(Runnable target)</span> </span>&#123;    init(<span class="hljs-keyword">null</span>, target, <span class="hljs-string">&quot;Thread-&quot;</span> + nextThreadNum(), <span class="hljs-number">0</span>);&#125;</code></pre><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-comment">// 对于Runnable创建Thread, 最终target(Runnable)在run方法中被调到, 优先采用Runnable对象的run方法</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">if</span> (target != <span class="hljs-keyword">null</span>) &#123;        target.run();    &#125;&#125;<span class="hljs-comment">// 而对于未采用Runnable, 直接创建的Thread子类对象, 重写了Thread中的run()方法, 最终执行子类中的run()方法</span>Thread t = <span class="hljs-keyword">new</span> Thread()&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 要执行的任务</span>    &#125;&#125;;</code></pre><blockquote><p>小结</p></blockquote><ul><li><p>方法1 是把线程和任务合并在了一起，方法2 是把线程和任务分开了 </p></li><li><p>用 Runnable 更容易与线程池等高级 API 配合</p></li><li><p>用 Runnable 让任务类脱离了 Thread 继承体系，更灵活</p><p> java中组合由于继承!</p></li></ul><h4 id="方法三-FutureTask配合Thread"><a href="#方法三-FutureTask配合Thread" class="headerlink" title="方法三, FutureTask配合Thread"></a>方法三, FutureTask配合Thread</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">RunnableFuture</span>&lt;<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Runnable</span>, <span class="hljs-title">Future</span>&lt;<span class="hljs-title">V</span>&gt; </span><span class="hljs-class">  // 说明能返回运行结果</span></code></pre><blockquote><p> FutureTask 能够接收 Callable 类型的参数，用来处理有返回结果的情况</p></blockquote><pre><code class="hljs java">FutureTask&lt;Integer&gt; task1 = <span class="hljs-keyword">new</span> FutureTask(<span class="hljs-keyword">new</span> Callable() &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        log.debug(<span class="hljs-string">&quot;running&quot;</span>);        Thread.sleep(<span class="hljs-number">3000</span>);        <span class="hljs-keyword">return</span> <span class="hljs-number">200</span>;    &#125;&#125;);Thread t5 = <span class="hljs-keyword">new</span> Thread(task1, <span class="hljs-string">&quot;t_task1&quot;</span>);t5.start();log.debug(<span class="hljs-string">&quot;&#123;&#125;,&quot;</span>, task1.get());<span class="hljs-comment">// 等待task返回结果</span>FutureTask&lt;Integer&gt; task2 = <span class="hljs-keyword">new</span> FutureTask(()-&gt;log.debug(<span class="hljs-string">&quot;running&quot;</span>), <span class="hljs-number">200</span>);<span class="hljs-keyword">new</span> Thread(task2, <span class="hljs-string">&quot;t_task2&quot;</span>).start();log.debug(<span class="hljs-string">&quot;&#123;&#125;,&quot;</span>, task2.get());</code></pre><pre><code class="hljs css">17<span class="hljs-selector-pseudo">:19</span><span class="hljs-selector-pseudo">:44</span> <span class="hljs-selector-attr">[t_task1]</span> <span class="hljs-selector-tag">c</span><span class="hljs-selector-class">.Test</span> <span class="hljs-selector-tag">-</span> <span class="hljs-selector-tag">running</span>17<span class="hljs-selector-pseudo">:19</span><span class="hljs-selector-pseudo">:47</span> <span class="hljs-selector-attr">[main]</span> <span class="hljs-selector-tag">c</span><span class="hljs-selector-class">.Test</span> <span class="hljs-selector-tag">-</span> 200,17<span class="hljs-selector-pseudo">:19</span><span class="hljs-selector-pseudo">:47</span> <span class="hljs-selector-attr">[t_task2]</span> <span class="hljs-selector-tag">c</span><span class="hljs-selector-class">.Test</span> <span class="hljs-selector-tag">-</span> <span class="hljs-selector-tag">running</span>17<span class="hljs-selector-pseudo">:19</span><span class="hljs-selector-pseudo">:47</span> <span class="hljs-selector-attr">[main]</span> <span class="hljs-selector-tag">c</span><span class="hljs-selector-class">.Test</span> <span class="hljs-selector-tag">-</span> 200,</code></pre><h3 id="2-2-观察多个线程同时运行"><a href="#2-2-观察多个线程同时运行" class="headerlink" title="2.2 观察多个线程同时运行"></a>2.2 观察多个线程同时运行</h3><pre><code class="hljs java"><span class="hljs-keyword">new</span> Thread(() -&gt; &#123;    <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;        log.debug(<span class="hljs-string">&quot;running...&quot;</span>);    &#125;&#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();<span class="hljs-keyword">new</span> Thread(()-&gt;&#123;    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>)&#123;        log.debug(<span class="hljs-string">&quot;running...&quot;</span>);    &#125;&#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();</code></pre><p>主要是理解:</p><ul><li>交替执行</li><li>谁先谁后，不由我们控制</li></ul><p>由底层任务调度器控制</p><h3 id="2-3-查看进程线程的方法"><a href="#2-3-查看进程线程的方法" class="headerlink" title="2.3 查看进程线程的方法"></a>2.3 查看进程线程的方法</h3><blockquote><p>windows</p></blockquote><ul><li><p>任务管理器可以查看进程和线程数，也可以用来杀死进程</p></li><li><p>tasklist 查看进程</p></li><li><p>taskkill 杀死进程</p></li></ul><blockquote><p>linux</p></blockquote><ul><li><p>ps -fe 查看所有进程</p></li><li><p>ps -fT -p <PID> 查看某个进程(PID)的所有线程 kill 杀死进程</p></li><li><p>top 按大写 H 切换是否显示线程</p></li><li><p>top -H -p <PID> 查看某个进程(PID)的所有线程</p></li></ul><blockquote><p>Java</p></blockquote><ul><li> jps 命令查看所有 Java 进程</li><li> jstack <PID> 查看某个 Java 进程(PID)的所有线程状态</li><li> jconsole 来查看某个 Java 进程中线程的运行情况(图形界面)</li></ul><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201127172857.png" alt="test" style="zoom:50%;" /><p>jconsole 远程监控配置 </p><ul><li>需要以如下方式运行你的 java 类</li></ul><pre><code class="hljs java"><span class="hljs-comment">//输入linux 根据选择true/false</span>java -Djava.rmi.server.hostname=`ip地址` -Dcom.sun.management.jmxremote - Dcom.sun.management.jmxremote.port=`连接端口` -Dcom.sun.management.jmxremote.ssl=是否安全连接 - Dcom.sun.management.jmxremote.authenticate=是否认证 java类</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201127174348.png" alt="连接"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201127174536.png" alt="线程"></p><h3 id="2-4-线程运行原理"><a href="#2-4-线程运行原理" class="headerlink" title="2.4 线程运行原理"></a>2.4 线程运行原理</h3><h4 id="栈与栈帧"><a href="#栈与栈帧" class="headerlink" title="栈与栈帧"></a>栈与栈帧</h4><blockquote><p>Java Virtual Machine Stacks (Java 虚拟机栈)</p><p>我们都知道 JVM 中由堆、栈、方法区所组成，其中栈内存是给谁用的呢?其实就是线程，每个线程启动后，虚拟 机就会为其分配一块栈内存。</p></blockquote><ul><li>每个栈由多个栈帧(Frame)组成，对应着每次方法调用时所占用的内存 </li><li>每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法</li></ul><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestFrames</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Thread t1 = <span class="hljs-keyword">new</span> Thread()&#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                method1(<span class="hljs-number">20</span>);            &#125;        &#125;;        t1.setName(<span class="hljs-string">&quot;t1&quot;</span>);        t1.start();        method1(<span class="hljs-number">10</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;        <span class="hljs-keyword">int</span> y = x + <span class="hljs-number">1</span>;        Object m = method2();        System.out.println(m);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title">method2</span><span class="hljs-params">()</span> </span>&#123;        Object n = <span class="hljs-keyword">new</span> Object();        <span class="hljs-keyword">return</span> n;    &#125;&#125;</code></pre><p>debug:</p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201127175404.png" alt="为主方法分配的栈帧" style="zoom:50%;" /><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201127175543.png" alt="开辟method1栈帧" style="zoom:50%;" /><blockquote><p>里面有参数信息, 局部变量信息</p></blockquote><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201127175648.png" alt="参数存放于局部变量表中"></p><blockquote><p>这些参数都存在于 <strong><em>局部变量表</em></strong>中</p></blockquote><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201127175800.png" alt="栈结构很明显"></p><h4 id="栈帧图解"><a href="#栈帧图解" class="headerlink" title="栈帧图解"></a>栈帧图解</h4><blockquote><p>当我们运行TestFrames时发生了什么?</p></blockquote><pre><code class="hljs less">首先执行 类加载 把<span class="hljs-selector-tag">TestFrames</span>字节码加载到<span class="hljs-selector-tag">Java</span>虚拟机中(放入方法区)类加载完成后<span class="hljs-selector-tag">Java</span>虚拟机启动一个名称为<span class="hljs-selector-tag">main</span>的主线程, 并分配一块栈内存, 线程再交给任务调度器执行线程栈中有一个程序计数器组件, 记录了当前该执行哪行代码栈帧中的局部变量表(栈帧创建时就会分配, 非边运行边分配, 但赋值是边运行边执行的)包含当前方法局部变量和方法参数返回地址对应退出地址,</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201127181557.png" alt="执行method2之前"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201127181744.png" alt="继续执行"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201127181939.png" alt="执行完method2"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201127182209.png" alt="执行完method2后, 栈帧消失"></p><p>之后同样出栈并根据返回地址返回, 继续执行下面的代码</p><h4 id="多线程栈与栈帧原理"><a href="#多线程栈与栈帧原理" class="headerlink" title="多线程栈与栈帧原理"></a>多线程栈与栈帧原理</h4><blockquote><p>把Debug模式改成Thread</p></blockquote><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201127182651.png" alt="debug" style="zoom:50%;" /><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201127182814.png" alt="主线程栈内存"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201127182912.png" alt="t1线程栈内存"></p><h4 id="线程的上下文切换-Thread-Context-Switch"><a href="#线程的上下文切换-Thread-Context-Switch" class="headerlink" title="线程的上下文切换(Thread Context Switch)"></a>线程的上下文切换(Thread Context Switch)</h4><blockquote><p>当任务调度器把时间片分配给每个线程运行的时候, 每个线程的时间片用完后把cpu使用权交给其他线程, 此时就会发生上下文切换</p></blockquote><p>因为以下一些原因导致 cpu 不再执行当前的线程，转而执行另一个线程的代码</p><ul><li>线程的 cpu 时间片用完</li><li> 垃圾回收  (<strong>会暂停当前所有的工作线程, 让垃圾回收线程回收垃圾</strong>)</li><li> 有更高优先级的线程需要运行</li><li> 线程自己调用了 sleep、yield、wait、join、park、synchronized、lock 等方法</li></ul><p>当 Context Switch 发生时，需要由操作系统保存当前线程的状态（ <strong>比如执行到第n行代码时间片结束，要记录n，否则下次再次轮到该线程，cpu不知道该从哪执行</strong>），并恢复另一个线程的状态，Java 中对应的概念 就是 <strong><em>程序计数器(Program Counter Register)</em></strong>，它的作用是记住 <strong><em>下一条 jvm 指令的执行地址</em></strong>，是线程 <strong><em>私有</em></strong>的</p><ul><li><p>状态包括 <strong><em>程序计数器</em></strong>、 <strong><em>虚拟机栈中每个栈帧的信息</em></strong>，如 <strong><em>局部变量</em></strong>、 <strong><em>操作数栈</em></strong>、 <strong><em>返回地址</em></strong>等 </p></li><li><p>Context Switch 频繁发生会影响性能</p><blockquote><p>假如运行到return n;的时候时间片结束</p></blockquote><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201127184513.png" alt="图解"></p><blockquote><p>加入t1执行完后</p></blockquote><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201127184706.png" alt="t1执行完后, main重新开始执行"></p></li></ul><h3 id="2-5-线程常用方法"><a href="#2-5-线程常用方法" class="headerlink" title="2.5 线程常用方法"></a>2.5 线程常用方法</h3><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法:"></a>常用方法:</h4><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201209100229.png" alt="1"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201209100254.png" alt="2"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201209100315.png" alt="3"></p><h4 id="start-vs-run"><a href="#start-vs-run" class="headerlink" title="start vs run"></a>start vs run</h4><blockquote><p>如果直接run会发生什么？</p></blockquote><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201209101753.png" alt="单独run"></p><p>并不是t1线程执行，并不能起到异步效果。</p><p>start启用线程，再由新的线程执行。</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 打印线程状态</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Slf4j(topic = &quot;c.Test&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test5</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            log.debug(<span class="hljs-string">&quot;running&quot;</span>);        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);        System.out.println(t1.getState());        t1.run();        System.out.println(t1.getState());        t1.start();        System.out.println(t1.getState());    &#125;&#125;</code></pre><pre><code class="hljs css"><span class="hljs-selector-tag">NEW</span>10<span class="hljs-selector-pseudo">:25</span><span class="hljs-selector-pseudo">:53</span> <span class="hljs-selector-attr">[main]</span> <span class="hljs-selector-tag">c</span><span class="hljs-selector-class">.Test</span> <span class="hljs-selector-tag">-</span> <span class="hljs-selector-tag">running</span><span class="hljs-selector-tag">NEW</span><span class="hljs-selector-tag">RUNNABLE</span>10<span class="hljs-selector-pseudo">:25</span><span class="hljs-selector-pseudo">:53</span> <span class="hljs-selector-attr">[t1]</span> <span class="hljs-selector-tag">c</span><span class="hljs-selector-class">.Test</span> <span class="hljs-selector-tag">-</span> <span class="hljs-selector-tag">running</span></code></pre><blockquote><p>不能调用多次start()方法</p></blockquote><pre><code class="hljs css"><span class="hljs-selector-tag">Exception</span> <span class="hljs-selector-tag">in</span> <span class="hljs-selector-tag">thread</span> &quot;<span class="hljs-selector-tag">main</span>&quot; 10<span class="hljs-selector-pseudo">:27</span><span class="hljs-selector-pseudo">:05</span> <span class="hljs-selector-attr">[t1]</span> <span class="hljs-selector-tag">c</span><span class="hljs-selector-class">.Test</span> <span class="hljs-selector-tag">-</span> <span class="hljs-selector-tag">running</span><span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.IllegalThreadStateException</span>    <span class="hljs-selector-tag">at</span> <span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.Thread</span><span class="hljs-selector-class">.start</span>(<span class="hljs-selector-tag">Thread</span><span class="hljs-selector-class">.java</span><span class="hljs-selector-pseudo">:708)</span>    <span class="hljs-selector-tag">at</span> <span class="hljs-selector-tag">com</span><span class="hljs-selector-class">.qiuke</span><span class="hljs-selector-class">.test</span><span class="hljs-selector-class">.Test5</span><span class="hljs-selector-class">.main</span>(<span class="hljs-selector-tag">Test5</span><span class="hljs-selector-class">.java</span><span class="hljs-selector-pseudo">:19)</span>// 多次调用<span class="hljs-selector-tag">start</span>()</code></pre><blockquote><p>小结</p></blockquote><p>直接调用 run 是在 <strong>主线程中执行了 run</strong>，没有启动新的线程<br> 使用 start 是 <strong>启动新的线程</strong>，通过新的线程间接执行 run 中的代码</p><h4 id="sleep-vs-yield"><a href="#sleep-vs-yield" class="headerlink" title="sleep vs yield"></a>sleep vs yield</h4><p> <strong><em>sleep</em></strong></p><ul><li><p>调用 sleep 会让当前线程从  <strong>Running 进入 Timed Waiting 状态(阻塞)</strong></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201209103716.png" alt="Timed Waiting"></p></li><li><p>其它线程可以使用  <strong>interrupt</strong> 方法打断正在睡眠的线程，这时 sleep 方法会抛出  **InterruptedException **</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201209104226.png" alt="interrupted异常"></p></li><li><p>睡眠结束后的线程 <strong>未必会立刻得到执行</strong></p><ul><li>要等任务调度器分配时间片</li></ul></li><li><p>建议用 <strong>TimeUnit 的 sleep</strong> 代替 Thread 的 sleep 来获得更好的可读性</p><ul><li><pre><code class="java">public void sleep(long timeout) throws InterruptedException &#123;    if (timeout &gt; 0) &#123;        long ms = toMillis(timeout);        int ns = excessNanos(timeout, ms);        Thread.sleep(ms, ns);    &#125;&#125;// 内部仍然是sleep<pre><code class="hljs reasonml">- ```java  <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">TimeUnit</span>.</span><span class="hljs-module"><span class="hljs-identifier">SECONDS</span>.</span></span>sleep(<span class="hljs-number">2000</span>);</code></pre></code></pre></li></ul></li></ul><p> <strong><em>yield</em></strong></p><ul><li><p>调用 yield 会让当前线程从  <strong>Running 进入 Runnable 就绪状态</strong>，然后调度执行其它线程</p><ul><li>任务调度器会把时间片分配给 <strong>就绪状态</strong>，但不会分配给 <strong>阻塞状态</strong>。</li><li>yield几乎没有 <strong>等待时间</strong>。</li></ul></li><li><p>具体的实现依赖于操作系统的任务调度器</p><ul><li>想让，但没有其他线程要运行， <strong>任务调度器还是会把时间片分配给自己</strong>。</li></ul></li></ul><h4 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h4><ul><li>线程优先级会 <strong>提示(hint)**调度器优先调度该线程，但它 **仅仅是一个提示</strong>，调度器可以忽略它。</li><li>如果 cpu 比较忙，那么优先级高的线程会获得更多的时间片，但 cpu 闲时，优先级几乎没作用</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Runnable task1 = () -&gt; &#123;            <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;            <span class="hljs-keyword">for</span> (;;) &#123;                System.out.println(<span class="hljs-string">&quot;----&gt;1 &quot;</span> + count++);            &#125;        &#125;;        Runnable task2 = () -&gt; &#123;            <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;            <span class="hljs-keyword">for</span> (;;) &#123;<span class="hljs-comment">//                Thread.yield();</span>                System.out.println(<span class="hljs-string">&quot;              ----&gt;2 &quot;</span> + count++);            &#125;        &#125;;        Thread t1 = <span class="hljs-keyword">new</span> Thread(task1, <span class="hljs-string">&quot;t1&quot;</span>);        Thread t2 = <span class="hljs-keyword">new</span> Thread(task2, <span class="hljs-string">&quot;t2&quot;</span>);        t1.setPriority(Thread.MIN_PRIORITY);        t2.setPriority(Thread.MAX_PRIORITY);        t1.start();        t2.start();    &#125;</code></pre><blockquote><p>优先级高的，最终打印的count应该更大</p></blockquote><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201209110407.png" alt="结果"></p><p>如果线程2开启yield：</p><pre><code class="hljs java">Runnable task2 = () -&gt; &#123;    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (;;) &#123;        Thread.yield();        System.out.println(<span class="hljs-string">&quot;              ----&gt;2 &quot;</span> + count++);    &#125;&#125;;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201209110459.png" alt="新结果"></p><p>如果将优先级注释掉：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201209110557.png" alt="新结果"></p><h4 id="sleep案例-防止cpu占用百分之百"><a href="#sleep案例-防止cpu占用百分之百" class="headerlink" title="sleep案例:防止cpu占用百分之百"></a>sleep案例:防止cpu占用百分之百</h4><h5 id="sleep实现"><a href="#sleep实现" class="headerlink" title="sleep实现"></a>sleep实现</h5><ul><li><p>在没有利用 cpu 来计算时，不要让 while(true) 空转浪费 cpu，这时可以使用 yield 或 sleep 来让出 cpu 的使用权 给其他程序</p><pre><code class="hljs java"><span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;   <span class="hljs-keyword">try</span> &#123;      Thread.sleep(<span class="hljs-number">50</span>);  &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;      e.printStackTrace(); &#125;&#125;</code></pre><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201209111647.png" alt="测试(加了sleep)" style="zoom: 50%;" /><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201209112407.png" alt="服务器"></p><p>注意：自己服务器多核，可能没有这样的效果！</p><ul><li><p>如果没有加sleep：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201209112645.png" alt="没有sleep"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201209112747.png" alt="cpu直接被打满"></p><p>如图，cpu直接被打满。</p></li></ul></li><li><p>可以用 wait 或 条件变量达到类似的效果 </p></li><li><p>不同的是，后两种都 <strong>需要加锁</strong>，并且需要相应的唤醒操作，一般适用于要进行同步的场景 </p></li><li><p>sleep 适用于 <strong>无需锁同步的场景</strong></p></li></ul><h4 id="join"><a href="#join" class="headerlink" title="join"></a>join</h4><blockquote><p>下面的代码执行，打印 r 是什么?</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    test1();&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;    log.debug(<span class="hljs-string">&quot;开始&quot;</span>);    Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;        log.debug(<span class="hljs-string">&quot;开始&quot;</span>);        <span class="hljs-keyword">try</span> &#123;            Thread.sleep(<span class="hljs-number">1</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        log.debug(<span class="hljs-string">&quot;结束&quot;</span>);         r = <span class="hljs-number">10</span>;    &#125;);    t1.start();    log.debug(<span class="hljs-string">&quot;结果为:&#123;&#125;&quot;</span>, r);    log.debug(<span class="hljs-string">&quot;结束&quot;</span>);&#125;</code></pre><pre><code class="hljs css">11<span class="hljs-selector-pseudo">:32</span><span class="hljs-selector-pseudo">:52</span> <span class="hljs-selector-attr">[main]</span> <span class="hljs-selector-tag">c</span><span class="hljs-selector-class">.Test10</span> <span class="hljs-selector-tag">-</span> 开始11<span class="hljs-selector-pseudo">:32</span><span class="hljs-selector-pseudo">:52</span> <span class="hljs-selector-attr">[Thread-0]</span> <span class="hljs-selector-tag">c</span><span class="hljs-selector-class">.Test10</span> <span class="hljs-selector-tag">-</span> 开始11<span class="hljs-selector-pseudo">:32</span><span class="hljs-selector-pseudo">:52</span> <span class="hljs-selector-attr">[main]</span> <span class="hljs-selector-tag">c</span><span class="hljs-selector-class">.Test10</span> <span class="hljs-selector-tag">-</span> 结果为<span class="hljs-selector-pseudo">:0</span>11<span class="hljs-selector-pseudo">:32</span><span class="hljs-selector-pseudo">:52</span> <span class="hljs-selector-attr">[Thread-0]</span> <span class="hljs-selector-tag">c</span><span class="hljs-selector-class">.Test10</span> <span class="hljs-selector-tag">-</span> 结束11<span class="hljs-selector-pseudo">:32</span><span class="hljs-selector-pseudo">:52</span> <span class="hljs-selector-attr">[main]</span> <span class="hljs-selector-tag">c</span><span class="hljs-selector-class">.Test10</span> <span class="hljs-selector-tag">-</span> 结束</code></pre><p>主线程调用test1，线程1被启动，主线程继续往下运行，不会等到t1结束，直接打印结果r=0；</p><blockquote><p>分析</p></blockquote><p>因为 **主线程和线程 t1 是并行执行的 **，t1 线程需要 1 秒之后才能算出 r=10</p><p>而主线程一开始就要打印 r 的结果，所以只能打印出 r=0</p><blockquote><p>解决方法</p></blockquote><p>用 sleep 行不行?为什么?</p><ul><li><p>可实现，但不推荐，因为未知线程t1执行到r赋值语句所需执行的时间</p><p>用 join，加在 t1.start() 之后即可</p></li><li><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201209135850.png" alt="join"></p></li></ul><h4 id="join案例-同步"><a href="#join案例-同步" class="headerlink" title="join案例:同步"></a>join案例:同步</h4><ul><li>需要等待结果返回，才能继续运行就是 <strong>同步</strong><ul><li>刚才的案例中：</li><li><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201209140223.png" alt="主线程在同步等待t1线程"></li></ul></li><li>不需要等待结果返回，就能继续运行就是 <strong>异步</strong></li></ul><h5 id="等待多个结果"><a href="#等待多个结果" class="headerlink" title="等待多个结果"></a>等待多个结果</h5><blockquote><p>下面代码 cost 大约多少秒?</p></blockquote><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;    Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;        <span class="hljs-keyword">try</span> &#123;            TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        r1 = <span class="hljs-number">10</span>;    &#125;);    Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;        <span class="hljs-keyword">try</span> &#123;            TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        r2 = <span class="hljs-number">20</span>;    &#125;);    t1.start();    t2.start();    <span class="hljs-keyword">long</span> start = System.currentTimeMillis();    log.debug(<span class="hljs-string">&quot;join begin&quot;</span>);    <span class="hljs-comment">// t1先join</span>    t1.join();    log.debug(<span class="hljs-string">&quot;t2 join end&quot;</span>);    <span class="hljs-comment">// t2再join</span>    t2.join();    log.debug(<span class="hljs-string">&quot;t1 join end&quot;</span>);    <span class="hljs-keyword">long</span> end = System.currentTimeMillis();    log.debug(<span class="hljs-string">&quot;r1: &#123;&#125; r2: &#123;&#125; cost: &#123;&#125;&quot;</span>, r1, r2, end - start);&#125;</code></pre><pre><code class="hljs css">14<span class="hljs-selector-pseudo">:07</span><span class="hljs-selector-pseudo">:10</span> <span class="hljs-selector-attr">[main]</span> <span class="hljs-selector-tag">c</span><span class="hljs-selector-class">.TestJoin</span> <span class="hljs-selector-tag">-</span> <span class="hljs-selector-tag">join</span> <span class="hljs-selector-tag">begin</span>14<span class="hljs-selector-pseudo">:07</span><span class="hljs-selector-pseudo">:12</span> <span class="hljs-selector-attr">[main]</span> <span class="hljs-selector-tag">c</span><span class="hljs-selector-class">.TestJoin</span> <span class="hljs-selector-tag">-</span> <span class="hljs-selector-tag">t2</span> <span class="hljs-selector-tag">join</span> <span class="hljs-selector-tag">end</span>14<span class="hljs-selector-pseudo">:07</span><span class="hljs-selector-pseudo">:12</span> <span class="hljs-selector-attr">[main]</span> <span class="hljs-selector-tag">c</span><span class="hljs-selector-class">.TestJoin</span> <span class="hljs-selector-tag">-</span> <span class="hljs-selector-tag">t1</span> <span class="hljs-selector-tag">join</span> <span class="hljs-selector-tag">end</span>14<span class="hljs-selector-pseudo">:07</span><span class="hljs-selector-pseudo">:12</span> <span class="hljs-selector-attr">[main]</span> <span class="hljs-selector-tag">c</span><span class="hljs-selector-class">.TestJoin</span> <span class="hljs-selector-tag">-</span> <span class="hljs-selector-tag">r1</span>: 10 <span class="hljs-selector-tag">r2</span>: 20 <span class="hljs-selector-tag">cost</span>: 2002</code></pre><p>时间差值为 <strong>2s</strong>！</p><p>如果t2先join，t1再join呢？</p><p>时间差值仍为 <strong>2s</strong>！</p><blockquote><p>分析如下</p></blockquote><ul><li><p>第一个 join:等待 t1 时, t2 并没有停止, 而在运行</p></li><li><p>第二个 join:1s 后, 执行到此, t2 也运行了 1s, 因此也只需再等待 1s</p></li></ul><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201209141248.png" alt="流程图"></p><h5 id="join的限时同步"><a href="#join的限时同步" class="headerlink" title="join的限时同步"></a>join的限时同步</h5><blockquote><p>Join(long n)等待n毫秒</p></blockquote><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201209141710.png" alt="测试"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201209141803.png" alt="测试2"></p><h4 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt"></a>interrupt</h4><h5 id="打断-sleep，wait，join-的线程"><a href="#打断-sleep，wait，join-的线程" class="headerlink" title="打断 sleep，wait，join 的线程"></a>打断 <strong>sleep，wait，join</strong> 的线程</h5><blockquote><p>打断 <strong>sleep，wait，join</strong> 的线程，且清空打断标记，置为false</p></blockquote><p>这几个方法都会让线程 <strong>进入阻塞状态</strong><br> 打断 sleep 的线程, 会 <strong>清空打断状态</strong>，以 sleep 为例</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201209142900.png" alt="测试interrupt"></p><p>注意：一定要 <strong>先sleep再打断</strong>，如果先打断再sleep，打断表示为true！</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201209143036.png" alt="先打断再sleep情况"></p><h5 id="打断正常运行的线程"><a href="#打断正常运行的线程" class="headerlink" title="打断正常运行的线程"></a>打断正常运行的线程</h5><p>Code:</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;    Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;            <span class="hljs-keyword">boolean</span> interrupted = Thread.currentThread().isInterrupted();            <span class="hljs-keyword">if</span>(interrupted) &#123;                log.debug(<span class="hljs-string">&quot;被打断了, 退出循环&quot;</span>);                <span class="hljs-keyword">break</span>;            &#125;        &#125;    &#125;, <span class="hljs-string">&quot;t1&quot;</span>);    t1.start();    Thread.sleep(<span class="hljs-number">1000</span>);    log.debug(<span class="hljs-string">&quot;interrupt&quot;</span>);    t1.interrupt();&#125;</code></pre><p>如果不加break，退不出循环。并不会影响程序正常运行。</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201209143718.png" alt="不加break 程序仍在运行"></p><p>主线程执行打断，只是告诉线程你要打断， <strong>继续运行还是停止运行由该线程自己决定</strong>。</p><h5 id="模式之两阶段终止"><a href="#模式之两阶段终止" class="headerlink" title="* 模式之两阶段终止"></a>* 模式之两阶段终止</h5><blockquote><p>Two Phase Termination</p></blockquote><p>在一个线程T1中如何“ <strong>优雅</strong> ”的终止线程T2？这里的优雅指的是给T2一个料理后事的机会。</p><blockquote><p>错误思想</p></blockquote><ul><li><p>使用线程对象的 <strong>stop()</strong> 方法停止线程</p><ul><li>stop方法会 <strong>真正杀死线程</strong>，如果这时线程锁住了 <strong>共享资源</strong> ，那么当它被杀死后就再也 <strong>没有机会释放锁</strong>，其他线程将永远无法获取锁</li></ul></li><li><p>使用 <strong>System.exit(int)</strong> 方法停止线程</p><ul><li>目的仅是停止一个线程，这种做法会 <strong>让整个程序都停止</strong></li></ul></li></ul><blockquote><p>对于监控线程来说，应该使用while(true)不断运行</p></blockquote><ul><li><p>怎么让监控线程停止监控，就得使用 <strong>两阶段终止模式</strong></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201209145702.png" alt="流程"></p><p>​ 需要sleep，不然会打满cpu。</p><p>​ 如果在 <strong>监控阶段被打断</strong>，打断标记为 true，下一轮判断是否被打断后会退出。</p><p>​ 如果在 <strong>睡眠阶段被打断</strong>，抛出InterruptedException异常，打断标记清空。可以抓住这个异常，重新设计打断标记，下一轮继续判断。</p><p>​ code模拟:</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 通过两阶段终止模式实现监控线程</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Slf4j(topic = &quot;c.Test13&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test13</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        TwoPhaseTermination tpt = <span class="hljs-keyword">new</span> TwoPhaseTermination();        tpt.start();        Thread.sleep(<span class="hljs-number">4000</span>);        tpt.stop();    &#125;&#125;<span class="hljs-meta">@Slf4j(topic = &quot;c.TwoPhaseTermination&quot;)</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TwoPhaseTermination</span></span>&#123;    <span class="hljs-keyword">private</span> Thread monitorThread;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span></span>&#123;        monitorThread.interrupt();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span></span>&#123;        monitorThread = <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>)&#123;                Thread current = Thread.currentThread();                <span class="hljs-keyword">if</span> (current.isInterrupted())&#123;                    log.debug(<span class="hljs-string">&quot;料理后事&quot;</span>);                    <span class="hljs-keyword">break</span>;                &#125;                <span class="hljs-keyword">try</span> &#123;                    Thread.sleep(<span class="hljs-number">1000</span>); <span class="hljs-comment">// 如果期间被打断 需要捕获异常 重置打断标记</span>                    log.debug(<span class="hljs-string">&quot;执行监控中...&quot;</span>);                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                    <span class="hljs-comment">// 重新设置打断标记</span>                    current.interrupt();                    System.out.println(current.isInterrupted());                &#125;            &#125;        &#125;,<span class="hljs-string">&quot;monitor&quot;</span>);        monitorThread.start();    &#125;&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201209162750.png" alt="结果演示"></p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构与算法基础回顾笔记</title>
    <link href="/2020/11/25/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/"/>
    <url>/2020/11/25/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>跟左神重学！</p></blockquote><h1 id="认识复杂度、对数器、二分法与异或运算"><a href="#认识复杂度、对数器、二分法与异或运算" class="headerlink" title="认识复杂度、对数器、二分法与异或运算"></a>认识复杂度、对数器、二分法与异或运算</h1><h2 id="认识复杂度"><a href="#认识复杂度" class="headerlink" title="认识复杂度"></a>认识复杂度</h2><blockquote><p>评估算法优劣的核心指标是什么？</p></blockquote><ul><li><p>时间复杂度（流程决定）</p></li><li><p>额外空间复杂度（流程决定）</p></li><li><p>常数项时间（实现细节决定）</p></li></ul><h3 id="1、什么是时间复杂度？时间复杂度怎么估算？"><a href="#1、什么是时间复杂度？时间复杂度怎么估算？" class="headerlink" title="1、什么是时间复杂度？时间复杂度怎么估算？"></a>1、什么是时间复杂度？时间复杂度怎么估算？</h3><ul><li>常数时间的操作</li><li>确定算法流程的总操作数量与样本数量之间的表达式关系</li><li>只看表达式最高阶项的部分</li></ul><h3 id="2、何为常数时间的操作？"><a href="#2、何为常数时间的操作？" class="headerlink" title="2、何为常数时间的操作？"></a>2、何为常数时间的操作？</h3><blockquote><p>如果一个操作的执行时间不以具体样本量为转移，每次执行时间都是固定时间。称这样的操作为常数时间的操作。如取Array[0]与取Array[1000000]花费时间一致， 不以数据量转移。</p></blockquote><p><strong>常见的常数时间的操作</strong></p><ul><li>常见的算术运算（+、-、*、/、% 等）</li><li>常见的位运算（&gt;&gt;(带符号右移)、&gt;&gt;&gt;(不带符号右移)、&lt;&lt;、|、&amp;、^等）</li><li>赋值、比较、自增、自减操作等</li><li>数组寻址操作</li></ul><p>总之，执行时间固定的操作都是常数时间的操作。<br>反之，执行时间不固定的操作，都不是常数时间的操作。</p><p><strong>如何确定算法流程的总操作数量与样本数量之间的表达式关系？</strong></p><p>​    1，想象该算法流程所处理的数据状况，要按照 <strong><em>最差</em></strong>情况来。</p><p>​    2，把整个流程彻底拆分为一个个 <strong><em>基本动作</em></strong>，保证每个动作都是 <strong><em>常数时间</em></strong>的操作。</p><p>​    3，如果数据量为N，看看基本动作的数量和N是什么关系。</p><h3 id="3、如何确定算法流程的时间复杂度？"><a href="#3、如何确定算法流程的时间复杂度？" class="headerlink" title="3、如何确定算法流程的时间复杂度？"></a>3、如何确定算法流程的时间复杂度？</h3><blockquote><p>当完成了表达式的建立，只要把最高阶项留下即可。低阶项都去掉，高阶项的系数也去掉。<br>记为：<strong>O(忽略掉系数的高阶项)</strong></p></blockquote><p>通过三个具体的例子，来实践一把时间复杂度的估算</p><h4 id="a、选择排序"><a href="#a、选择排序" class="headerlink" title="a、选择排序"></a>a、选择排序</h4><p>过程：<br>arr[0～N-1]范围上，找到最小值所在的位置，然后把最小值交换到0位置。<br>arr[1～N-1]范围上，找到最小值所在的位置，然后把最小值交换到1位置。<br>arr[2～N-1]范围上，找到最小值所在的位置，然后把最小值交换到2位置。<br>…<br>arr[N-1～N-1]范围上，找到最小值位置，然后把最小值交换到N-1位置。</p><p>估算：<br>很明显，如果arr长度为N，每一步常数操作的数量，如等差数列一般<br>所以，总的常数操作数量 = a*(N^2) + b*N + c (a、b、c都是常数)</p><p>所以选择排序的时间复杂度为 **O(N^2)**。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">selectionSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;   <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length &lt; <span class="hljs-number">2</span>) &#123;      <span class="hljs-keyword">return</span>;   &#125;   <span class="hljs-comment">// 0～n-1</span>   <span class="hljs-comment">// 1～n-1</span>   <span class="hljs-comment">// 2～n-1</span>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length - <span class="hljs-number">1</span>; i++) &#123; <span class="hljs-comment">// i ~ N-1</span>      <span class="hljs-comment">// 最小值在哪个位置上  i～n-1</span>      <span class="hljs-keyword">int</span> minIndex = i;      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; arr.length; j++) &#123; <span class="hljs-comment">// i ~ N-1 上找最小值的下标 </span>         minIndex = arr[j] &lt; arr[minIndex] ? j : minIndex;      &#125;      swap(arr, i, minIndex);   &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;   <span class="hljs-keyword">int</span> tmp = arr[i];   arr[i] = arr[j];   arr[j] = tmp;&#125;</code></pre><h4 id="b、冒泡排序"><a href="#b、冒泡排序" class="headerlink" title="b、冒泡排序"></a>b、冒泡排序</h4><p>过程：<br>在arr[0～N-1]范围上：<br>arr[0]和arr[1]，谁大谁来到1位置；arr[1]和arr[2]，谁大谁来到2位置…arr[N-2]和arr[N-1]，谁大谁来到N-1位置</p><p>在arr[0～N-2]范围上，重复上面的过程，但最后一步是arr[N-3]和arr[N-2]，谁大谁来到N-2位置<br>在arr[0～N-3]范围上，重复上面的过程，但最后一步是arr[N-4]和arr[N-3]，谁大谁来到N-3位置<br>…<br>最后在arr[0～1]范围上，重复上面的过程，但最后一步是arr[0]和arr[1]，谁大谁来到1位置</p><p>估算：<br>很明显，如果arr长度为N，每一步常数操作的数量，依然如等差数列一般<br>所以，总的常数操作数量 = a*(N^2) + b*N + c (a、b、c都是常数)</p><p>所以冒泡排序的时间复杂度为O(N^2)。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bubbleSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span></span>&#123;        <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length &lt; <span class="hljs-number">2</span>)&#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = arr.length - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--)&#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++)&#123;                <span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>])&#123;                    swap(arr, j, j+<span class="hljs-number">1</span>);                &#125;            &#125;        &#125;    &#125;    <span class="hljs-comment">// 交换arr的i和j位置上的值</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;        arr[i] = arr[i] ^ arr[j];        arr[j] = arr[i] ^ arr[j];        arr[i] = arr[i] ^ arr[j];    &#125;</code></pre><h4 id="c、插入排序"><a href="#c、插入排序" class="headerlink" title="c、插入排序"></a>c、插入排序</h4><p>过程：<br>想让arr[0<del>0]上有序，这个范围只有一个数，当然是有序的。<br>想让arr[0</del>1]上有序，所以从arr[1]开始往前看，如果arr[1]&lt;arr[0]，就交换。否则什么也不做。<br>想让arr[0<del>i]上有序，所以从arr[i]开始往前看，arr[i]这个数不停向左移动，一直移动到左边的数字不再比自己大，停止移动。<br>最后一步，想让arr[0</del>N-1]上有序， arr[N-1]这个数不停向左移动，一直移动到左边的数字不再比自己大，停止移动。</p><p>估算时发现这个算法流程的复杂程度，会因为数据状况的不同而不同。</p><pre><code class="hljs mathematica">如果某个算法流程的复杂程度会根据数据状况的不同而不同，那么你必须要按照最差情况来估计。很明显，在最差情况下，如果<span class="hljs-variable">arr</span>长度为<span class="hljs-built_in">N</span>，插入排序的每一步常数操作的数量，还是如等差数列一般所以，总的常数操作数量 <span class="hljs-operator">=</span> <span class="hljs-variable">a</span><span class="hljs-operator">*</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-operator">^</span><span class="hljs-number">2</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">+</span> <span class="hljs-variable">b</span><span class="hljs-operator">*</span><span class="hljs-built_in">N</span> <span class="hljs-operator">+</span> <span class="hljs-variable">c</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">a</span>、<span class="hljs-variable">b</span>、<span class="hljs-variable">c</span>都是常数<span class="hljs-punctuation">)</span>所以插入排序排序的时间复杂度为<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-operator">^</span><span class="hljs-number">2</span><span class="hljs-punctuation">)</span>。</code></pre><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertionSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;   <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length &lt; <span class="hljs-number">2</span>) &#123;      <span class="hljs-keyword">return</span>;   &#125;   <span class="hljs-comment">// 0~0 有序的</span>   <span class="hljs-comment">// 0~i 想有序</span>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; arr.length; i++) &#123; <span class="hljs-comment">// 0 ~ i 做到有序</span>            <span class="hljs-comment">// arr[i]往前看，一直交换到合适的位置停止</span>      <span class="hljs-comment">// ...(&lt;=)  ?       &lt;- i</span>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[j] &gt; arr[j + <span class="hljs-number">1</span>]; j--) &#123;         swap(arr, j, j + <span class="hljs-number">1</span>);      &#125;   &#125;&#125;<span class="hljs-comment">// i和j是一个位置的话，会出错</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;   arr[i] = arr[i] ^ arr[j];   arr[j] = arr[i] ^ arr[j];   arr[i] = arr[i] ^ arr[j];&#125;</code></pre><blockquote><p>注意</p></blockquote><ul><li><p>算法的过程，和具体的语言是无关的。</p></li><li><p>想分析一个算法流程的时间复杂度的前提，是对该流程非常熟悉</p></li><li><p>一定要确保在拆分算法流程时，拆分出来的所有行为都是常数时间的操作。这意味着你写算法时，对自己的用过的每一个系统api，都非常的熟悉。否则会影响你对时间复杂度的估算。</p><hr><pre><code class="hljs mathematica">排名从好到差：<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-number">1</span><span class="hljs-punctuation">)</span>   <span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-variable">logN</span><span class="hljs-punctuation">)</span>   <span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-punctuation">)</span>   <span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-operator">*</span><span class="hljs-variable">logN</span><span class="hljs-punctuation">)</span>   <span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-operator">^</span><span class="hljs-number">2</span><span class="hljs-punctuation">)</span>   <span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-operator">^</span><span class="hljs-number">3</span><span class="hljs-punctuation">)</span>   …   <span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-operator">^</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-number">2</span><span class="hljs-operator">^</span><span class="hljs-built_in">N</span><span class="hljs-punctuation">)</span>   <span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-number">3</span><span class="hljs-operator">^</span><span class="hljs-built_in">N</span><span class="hljs-punctuation">)</span>   …   <span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">K</span><span class="hljs-operator">^</span><span class="hljs-built_in">N</span><span class="hljs-punctuation">)</span><span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-operator">!</span><span class="hljs-punctuation">)</span></code></pre></li></ul><h3 id="4、时间复杂度的意义"><a href="#4、时间复杂度的意义" class="headerlink" title="4、时间复杂度的意义"></a>4、时间复杂度的意义</h3><p>抹掉了好多东西，只剩下了一个 <strong><em>最高阶项</em></strong>啊…</p><p>那这个东西有什么意义呢？</p><p>时间复杂度的意义在于：</p><p>当我们要处理的样本量很大很大时，我们会发现*<strong>低阶项是什么不是最重要的 **<em>；每一项的系数是什么，不是最重要的。</em></strong>真正重要的就是最高阶项是什么***。</p><p>这就是时间复杂度的意义，它是衡量算法流程的复杂程度的一种指标，该指标只与 <strong><em>数据量</em></strong>有关，与 <strong><em>过程之外的优化</em></strong>无关。</p><h3 id="5、额外空间复杂度"><a href="#5、额外空间复杂度" class="headerlink" title="5、额外空间复杂度"></a>5、额外空间复杂度</h3><p>你要实现一个算法流程，在实现算法流程的过程中，你需要开辟一些空间来支持你的算法流程。</p><p>作为 <strong><em>输入参数</em></strong>的空间，不算额外空间。<br>作为 <strong><em>输出结果</em></strong>的空间，也不算额外空间。</p><p>因为这些都是必要的、和现实目标有关的。所以都不算。<br>但除此之外，你的流程如果还需要开辟空间才能让你的流程继续下去。这部分空间就是额外空间。<br>如果你的流程只需要开辟有限几个变量，额外空间复杂度就是O(1)。</p><h3 id="6、算法流程的常数项"><a href="#6、算法流程的常数项" class="headerlink" title="6、算法流程的常数项"></a>6、算法流程的常数项</h3><p>我们会发现，时间复杂度这个指标，是忽略低阶项和所有常数系数的。<br>难道同样时间复杂度的流程，在实际运行时候就一样的好吗？<br>当然不是。</p><p>时间复杂度只是一个很重要的指标而已。如果两个时间复杂度一样的算法，你还要去在时间上拼优劣，就进入到拼常数时间的阶段，简称 <strong><em>拼常数项</em></strong>。</p><blockquote><p>算法流程的常数项的比拼方式</p></blockquote><p> <strong><em>放弃理论分析，生成随机数据直接测</em></strong>。</p><p>为什么不去理论分析？<br>不是不能纯分析，而是没必要。因为不同常数时间的操作，虽然都是固定时间，但还是有快慢之分的。</p><p>比如，位运算的常数时间原小于算术运算的常数时间，这两个运算的常数时间又远小于数组寻址的时间。<br>所以如果纯理论分析，往往会需要非常多的分析过程。都已经到了具体细节的程度，莫不如交给实验数据好了。</p><h3 id="7、面试、比赛、刷题中，一个问题的最优解是什么意思？"><a href="#7、面试、比赛、刷题中，一个问题的最优解是什么意思？" class="headerlink" title="7、面试、比赛、刷题中，一个问题的最优解是什么意思？"></a>7、面试、比赛、刷题中，一个问题的最优解是什么意思？</h3><p>一般情况下，认为解决一个问题的算法流程，在 <strong><em>时间复杂度</em></strong>的指标上，一定要尽可能的 <strong><em>低</em></strong>，先满足了时间复杂度最低这个指标之后，使用最少的 <strong><em>空间</em></strong>的算法流程，叫这个问题的最优解。</p><p>一般说起最优解都是 <strong><em>忽略掉常数项</em></strong>这个因素的，因为这个因素只决定了实现层次的优化和考虑，而和怎么解决整个问题的思想无关。</p><h2 id="对数器"><a href="#对数器" class="headerlink" title="对数器"></a>对数器</h2><h3 id="1、什么是对数器"><a href="#1、什么是对数器" class="headerlink" title="1、什么是对数器"></a>1、什么是对数器</h3><blockquote><p>认识对数器</p></blockquote><p>1，你想要测的方法a<br>2，实现复杂度不好但是容易实现的方法b<br>3，实现一个随机样本产生器<br>4，把方法a和方法b跑相同的随机样本，看看得到的结果是否一样<br>5，如果有一个随机样本使得比对结果不一致，打印样本进行人工干预，改对方法a和方法b<br>6，当样本数量很多时比对测试依然正确，可以确定方法a已经正确。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] generateRandomArray(<span class="hljs-keyword">int</span> maxSize, <span class="hljs-keyword">int</span> maxValue) &#123;   <span class="hljs-comment">// Math.random() -&gt;  [0,1) 所有的小数，等概率返回一个</span>   <span class="hljs-comment">// Math.random() * N -&gt; [0,N) 所有小数，等概率返回一个</span>   <span class="hljs-comment">// (int)(Math.random() * N) -&gt; [0,N-1] 所有的整数，等概率返回一个</span>   <span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[(<span class="hljs-keyword">int</span>) ((maxSize + <span class="hljs-number">1</span>) * Math.random())]; <span class="hljs-comment">// 长度随机 </span>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;      <span class="hljs-comment">// [-?,+?]</span>      arr[i] = (<span class="hljs-keyword">int</span>) ((maxValue + <span class="hljs-number">1</span>) * Math.random())             - (<span class="hljs-keyword">int</span>) (maxValue * Math.random());   &#125;   <span class="hljs-keyword">return</span> arr;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">comparator</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;Arrays.sort(arr);&#125;<span class="hljs-comment">// for copy</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] copyArray(<span class="hljs-keyword">int</span>[] arr) &#123;<span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;<span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[arr.length];<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;res[i] = arr[i];&#125;<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-comment">// for compare</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEqual</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr1, <span class="hljs-keyword">int</span>[] arr2)</span> </span>&#123;<span class="hljs-keyword">if</span> ((arr1 == <span class="hljs-keyword">null</span> &amp;&amp; arr2 != <span class="hljs-keyword">null</span>) || (arr1 != <span class="hljs-keyword">null</span> &amp;&amp; arr2 == <span class="hljs-keyword">null</span>)) &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;&#125;<span class="hljs-keyword">if</span> (arr1 == <span class="hljs-keyword">null</span> &amp;&amp; arr2 == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;&#125;<span class="hljs-keyword">if</span> (arr1.length != arr2.length) &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr1.length; i++) &#123;<span class="hljs-keyword">if</span> (arr1[i] != arr2[i]) &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-comment">// for test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;   <span class="hljs-keyword">int</span> testTime = <span class="hljs-number">500000</span>;   <span class="hljs-keyword">int</span> maxSize = <span class="hljs-number">100</span>; <span class="hljs-comment">// 随机数组的长度0～100</span>   <span class="hljs-keyword">int</span> maxValue = <span class="hljs-number">100</span>;<span class="hljs-comment">// 值：-100～100</span>   <span class="hljs-keyword">boolean</span> succeed = <span class="hljs-keyword">true</span>;   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; testTime; i++) &#123;      <span class="hljs-keyword">int</span>[] arr1 = generateRandomArray(maxSize, maxValue);      <span class="hljs-keyword">int</span>[] arr2 = copyArray(arr1);      insertionSort(arr1);      comparator(arr2);      <span class="hljs-keyword">if</span> (!isEqual(arr1, arr2)) &#123;         <span class="hljs-comment">// 打印arr1</span>         <span class="hljs-comment">// 打印arr2</span>         succeed = <span class="hljs-keyword">false</span>;         <span class="hljs-keyword">break</span>;      &#125;   &#125;   System.out.println(succeed ? <span class="hljs-string">&quot;Nice!&quot;</span> : <span class="hljs-string">&quot;Fucking fucked!&quot;</span>);   <span class="hljs-keyword">int</span>[] arr = generateRandomArray(maxSize, maxValue);   printArray(arr);   insertionSort(arr);   printArray(arr);&#125;</code></pre><h2 id="认识二分法"><a href="#认识二分法" class="headerlink" title="认识二分法"></a>认识二分法</h2><blockquote><p> 经常见到的类型是在一个有序数组上，开展二分搜索，但有序真的是所有问题求解时使用二分的必要条件吗？<br>不！<br>只要能正确构建左右两侧的淘汰逻辑，你就可以二分。</p></blockquote><h3 id="1、在一个有序数组中，找某个数是否存在"><a href="#1、在一个有序数组中，找某个数是否存在" class="headerlink" title="1、在一个有序数组中，找某个数是否存在"></a>1、在一个有序数组中，找某个数是否存在</h3><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">exist</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] sortedArr, <span class="hljs-keyword">int</span> num)</span> </span>&#123;   <span class="hljs-keyword">if</span> (sortedArr == <span class="hljs-keyword">null</span> || sortedArr.length == <span class="hljs-number">0</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;   &#125;   <span class="hljs-keyword">int</span> L = <span class="hljs-number">0</span>;   <span class="hljs-keyword">int</span> R = sortedArr.length - <span class="hljs-number">1</span>;   <span class="hljs-keyword">int</span> mid = <span class="hljs-number">0</span>;   <span class="hljs-comment">// L..R</span>   <span class="hljs-keyword">while</span> (L &lt; R) &#123;      <span class="hljs-comment">// 防L R 因数值过大 相加后溢出</span>      mid = L + ((R - L) &gt;&gt; <span class="hljs-number">1</span>); <span class="hljs-comment">// mid = (L + R) / 2</span>      <span class="hljs-keyword">if</span> (sortedArr[mid] == num) &#123;         <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sortedArr[mid] &gt; num) &#123;         R = mid - <span class="hljs-number">1</span>;      &#125; <span class="hljs-keyword">else</span> &#123;         L = mid + <span class="hljs-number">1</span>;      &#125;   &#125;   <span class="hljs-keyword">return</span> sortedArr[L] == num;&#125;</code></pre><h3 id="2、在一个有序数组中，找-gt-某个数最左侧的位置"><a href="#2、在一个有序数组中，找-gt-某个数最左侧的位置" class="headerlink" title="2、在一个有序数组中，找&gt;=某个数最左侧的位置"></a>2、在一个有序数组中，找&gt;=某个数最左侧的位置</h3><pre><code class="hljs java"><span class="hljs-comment">// 在arr上，找满足&gt;=value的最左位置</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">nearestIndex</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> value)</span></span>&#123;    <span class="hljs-keyword">int</span> L = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> R = arr.length - <span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> index = -<span class="hljs-number">1</span>; <span class="hljs-comment">// 记录最左的对号</span>    <span class="hljs-keyword">while</span> (L &lt;= R)&#123;        <span class="hljs-keyword">int</span> mid = L + ((R - L) &gt;&gt; <span class="hljs-number">1</span>);        <span class="hljs-keyword">if</span> (arr[mid] &gt;= value) &#123;            index = mid;            R = mid - <span class="hljs-number">1</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            L = mid + <span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> index;&#125;</code></pre><h3 id="3、-在一个有序数组中，找-lt-某个数最右侧的位置"><a href="#3、-在一个有序数组中，找-lt-某个数最右侧的位置" class="headerlink" title="3、 在一个有序数组中，找&lt;=某个数最右侧的位置"></a>3、 在一个有序数组中，找&lt;=某个数最右侧的位置</h3><pre><code class="hljs java"><span class="hljs-comment">// 在arr上，找满足&lt;=value的最右位置</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">nearestIndex</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> value)</span> </span>&#123;    <span class="hljs-keyword">int</span> L = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> R = arr.length - <span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> index = -<span class="hljs-number">1</span>; <span class="hljs-comment">// 记录最右的对号</span>    <span class="hljs-keyword">while</span> (L &lt;= R) &#123;        <span class="hljs-keyword">int</span> mid = L + ((R - L) &gt;&gt; <span class="hljs-number">1</span>);        <span class="hljs-keyword">if</span> (arr[mid] &lt;= value) &#123;            index = mid;            L = mid + <span class="hljs-number">1</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            R = mid - <span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> index;&#125;</code></pre><h3 id="4、-局部最小值问题"><a href="#4、-局部最小值问题" class="headerlink" title="4、 局部最小值问题"></a>4、 局部最小值问题</h3><blockquote><ol><li>arr[0]&lt;arr[1]</li><li>Arr[len-1]&lt;Arr[len-2]</li><li>arr[i-1]&lt;arr[i]&lt;arr[i+1]</li></ol></blockquote><p>arr无序, 任意两个相邻数不相等, 只需返回一个局部最小位置:</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getLessIndex</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;   <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length == <span class="hljs-number">0</span>) &#123;      <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">// no exist</span>   &#125;   <span class="hljs-keyword">if</span> (arr.length == <span class="hljs-number">1</span> || arr[<span class="hljs-number">0</span>] &lt; arr[<span class="hljs-number">1</span>]) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;   &#125;   <span class="hljs-keyword">if</span> (arr[arr.length - <span class="hljs-number">1</span>] &lt; arr[arr.length - <span class="hljs-number">2</span>]) &#123;      <span class="hljs-keyword">return</span> arr.length - <span class="hljs-number">1</span>;   &#125;   <span class="hljs-keyword">int</span> left = <span class="hljs-number">1</span>;   <span class="hljs-keyword">int</span> right = arr.length - <span class="hljs-number">2</span>;   <span class="hljs-keyword">int</span> mid = <span class="hljs-number">0</span>;   <span class="hljs-keyword">while</span> (left &lt; right) &#123;      mid = (left + right) / <span class="hljs-number">2</span>;      <span class="hljs-keyword">if</span> (arr[mid] &gt; arr[mid - <span class="hljs-number">1</span>]) &#123;         right = mid - <span class="hljs-number">1</span>;      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[mid] &gt; arr[mid + <span class="hljs-number">1</span>]) &#123;         left = mid + <span class="hljs-number">1</span>;      &#125; <span class="hljs-keyword">else</span> &#123;         <span class="hljs-keyword">return</span> mid;      &#125;   &#125;   <span class="hljs-keyword">return</span> left;&#125;</code></pre><h2 id="认识异或运算"><a href="#认识异或运算" class="headerlink" title="认识异或运算"></a>认识异或运算</h2><h3 id="1、如何记住"><a href="#1、如何记住" class="headerlink" title="1、如何记住"></a>1、如何记住</h3><p>异或运算：相同为0，不同为1<br>同或运算：相同以1，不同为0</p><blockquote><p>能长时间记住的概率接近0%</p><p>所以，异或运算就记成无进位相加！ </p></blockquote><h3 id="2、异或运算的性质"><a href="#2、异或运算的性质" class="headerlink" title="2、异或运算的性质"></a>2、异或运算的性质</h3><p>0^N == N      N^N == 0<br>异或运算满足交换律和结合率</p><p>上面的两个性质用无进位相加来理解就非常的容易</p><h3 id="3、如何不用额外变量交换两个数"><a href="#3、如何不用额外变量交换两个数" class="headerlink" title="3、如何不用额外变量交换两个数"></a>3、如何不用额外变量交换两个数</h3><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;    arr[i] = arr[i] ^ arr[j];    arr[j] = arr[i] ^ arr[j];    arr[i] = arr[i] ^ arr[j];&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201125212731.png" alt="结构"></p><blockquote><p>注意:     i和j是一个位置的话，会出错，指向的内存要求是不一样的，各自独立的。</p></blockquote><h3 id="4、一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这种数"><a href="#4、一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这种数" class="headerlink" title="4、一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这种数"></a>4、一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这种数</h3><pre><code class="hljs java"><span class="hljs-comment">// arr中，只有一种数，出现奇数次</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printOddTimesNum1</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;   <span class="hljs-keyword">int</span> eor = <span class="hljs-number">0</span>;   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;      eor ^= arr[i];   &#125;   System.out.println(eor);&#125;</code></pre><h3 id="5、怎么把一个int类型的数，提取出最右侧的1来"><a href="#5、怎么把一个int类型的数，提取出最右侧的1来" class="headerlink" title="5、怎么把一个int类型的数，提取出最右侧的1来"></a>5、怎么把一个int类型的数，提取出最右侧的1来</h3><p>N &amp; ((~N)+1)</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img9SF_F0USXR87N%TE$HW3L80.png" alt="1"></p><h3 id="6、一个数组中有两种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这两种数"><a href="#6、一个数组中有两种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这两种数" class="headerlink" title="6、一个数组中有两种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这两种数"></a>6、一个数组中有两种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这两种数</h3><pre><code class="hljs java"><span class="hljs-comment">// arr中，有两种数，出现奇数次</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printOddTimesNum2</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;   <span class="hljs-keyword">int</span> eor = <span class="hljs-number">0</span>;   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;      eor ^= arr[i];   &#125;   <span class="hljs-comment">// eor = a ^ b</span>   <span class="hljs-comment">// eor != 0</span>   <span class="hljs-comment">// eor必然有一个位置上是1</span>   <span class="hljs-keyword">int</span> rightOne = eor &amp; (~eor + <span class="hljs-number">1</span>); <span class="hljs-comment">// 提取出最右的1</span>   <span class="hljs-keyword">int</span> onlyOne = <span class="hljs-number">0</span>; <span class="hljs-comment">// eor&#x27;</span>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; arr.length;i++) &#123;      <span class="hljs-keyword">if</span> ((arr[i] &amp; rightOne) != <span class="hljs-number">0</span>) &#123;         onlyOne ^= arr[i];      &#125;   &#125;   System.out.println(onlyOne + <span class="hljs-string">&quot; &quot;</span> + (eor ^ onlyOne));&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201125220723.png" alt="图解"></p><h1 id="链表结构、栈、队列、递归行为、哈希表"><a href="#链表结构、栈、队列、递归行为、哈希表" class="headerlink" title="链表结构、栈、队列、递归行为、哈希表"></a>链表结构、栈、队列、递归行为、哈希表</h1><h2 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h2><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> value;    <span class="hljs-keyword">public</span> Node next;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span> </span>&#123;        <span class="hljs-keyword">this</span>.value = data;    &#125;&#125;</code></pre><h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DoubleNode</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> value;    <span class="hljs-keyword">public</span> DoubleNode last;    <span class="hljs-keyword">public</span> DoubleNode next;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DoubleNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span> </span>&#123;        <span class="hljs-keyword">this</span>.value = data;    &#125;&#125;</code></pre><h2 id="单向链表和双向链表最简单的练习"><a href="#单向链表和双向链表最简单的练习" class="headerlink" title="单向链表和双向链表最简单的练习"></a>单向链表和双向链表最简单的练习</h2><blockquote><p> 链表相关的问题几乎都是coding问题</p></blockquote><ul><li><p>单链表和双链表如何反转</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">reverseLinkedList</span><span class="hljs-params">(Node head)</span> </span>&#123;   Node pre = <span class="hljs-keyword">null</span>;   Node next = <span class="hljs-keyword">null</span>;   <span class="hljs-keyword">while</span> (head != <span class="hljs-keyword">null</span>) &#123;      next = head.next; <span class="hljs-comment">// 记录head下一个</span>      head.next = pre; <span class="hljs-comment">// 让head指向pre</span>      pre = head; <span class="hljs-comment">// 记录初始head</span>      head = next;<span class="hljs-comment">// head跳到下一个</span>   &#125;   <span class="hljs-keyword">return</span> pre;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> DoubleNode <span class="hljs-title">reverseDoubleList</span><span class="hljs-params">(DoubleNode head)</span></span>&#123;    DoubleNode pre = <span class="hljs-keyword">null</span>;    DoubleNode next = <span class="hljs-keyword">null</span>;    <span class="hljs-keyword">while</span> (head != <span class="hljs-keyword">null</span>)&#123;        next = head.next;        head.next = pre;        head.last = next;        pre = head;        head = next;    &#125;    <span class="hljs-keyword">return</span> pre;&#125;</code></pre></li><li><p>把给定值都删除</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">removeValue</span><span class="hljs-params">(Node head, <span class="hljs-keyword">int</span> num)</span></span>&#123;    <span class="hljs-comment">// 先找到值不是value的结点，作为头结点</span>    <span class="hljs-keyword">while</span> (head != <span class="hljs-keyword">null</span>)&#123;        <span class="hljs-keyword">if</span> (head.value != num)&#123;            <span class="hljs-keyword">break</span>;        &#125;        head = head.next;    &#125;    <span class="hljs-comment">// 找到后, 删除后面的</span>    Node pre = head; <span class="hljs-comment">// 记录上一个不等于num的位置</span>    Node cur = head; <span class="hljs-comment">// cur作为条件, 每次跳一次, 遍历链表</span>    <span class="hljs-keyword">while</span> (cur != <span class="hljs-keyword">null</span>)&#123;        <span class="hljs-keyword">if</span> (cur.value == num)&#123;            pre.next = cur.next;        &#125;<span class="hljs-keyword">else</span> &#123;            pre = cur;        &#125;        cur = cur.next;    &#125;    <span class="hljs-keyword">return</span> head;&#125;</code></pre></li></ul><p>这里就是熟悉结构。链表还有哪些常见面试题，后续有专门系统学习。</p><h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h2><blockquote><p>逻辑概念<br>栈：数据先进后出，犹如弹匣<br>队列：数据先进先出，好似排队</p></blockquote><h2 id="栈和队列的实际实现"><a href="#栈和队列的实际实现" class="headerlink" title="栈和队列的实际实现"></a>栈和队列的实际实现</h2><ul><li><p>双向链表实现</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;    <span class="hljs-keyword">public</span> T value;    <span class="hljs-keyword">public</span> Node&lt;T&gt; last;    <span class="hljs-keyword">public</span> Node&lt;T&gt; next;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(T data)</span> </span>&#123;        <span class="hljs-keyword">this</span>.value = data;    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DoubleEndsQueue</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;    <span class="hljs-keyword">public</span> Node&lt;T&gt; head;    <span class="hljs-keyword">public</span> Node&lt;T&gt; tail;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addFromHead</span><span class="hljs-params">(T value)</span> </span>&#123;        Node&lt;T&gt; cur = <span class="hljs-keyword">new</span> Node&lt;&gt;(value);        <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>)&#123;            head = cur;            tail = cur;        &#125;<span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// 改变结点</span>            cur.next =  head;            head.last = cur;            <span class="hljs-comment">// 变更新的头结点</span>            head = cur;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addFromBottom</span><span class="hljs-params">(T value)</span> </span>&#123;        Node&lt;T&gt; cur = <span class="hljs-keyword">new</span> Node&lt;&gt;(value);        <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>)&#123;            head = cur;            tail = cur;        &#125;<span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// 改变结点</span>            cur.last = tail;            tail.next = cur;            tail = cur;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">popFromHead</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        Node&lt;T&gt; cur = head;        <span class="hljs-keyword">if</span> (head == tail)&#123;            head = <span class="hljs-keyword">null</span>;            tail = <span class="hljs-keyword">null</span>;        &#125;<span class="hljs-keyword">else</span> &#123;            head = head.next;            cur.next = <span class="hljs-keyword">null</span>;            head.last = <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-keyword">return</span> cur.value;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">popFromBottom</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        Node&lt;T&gt; cur = tail;        <span class="hljs-keyword">if</span> (head == tail)&#123;            head = <span class="hljs-keyword">null</span>;            tail = <span class="hljs-keyword">null</span>;        &#125;<span class="hljs-keyword">else</span> &#123;            tail = tail.last;            tail.next = <span class="hljs-keyword">null</span>;            cur.last = <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-keyword">return</span> cur.value;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> head == <span class="hljs-keyword">null</span>;    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyStack</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;    <span class="hljs-keyword">private</span> DoubleEndsQueue&lt;T&gt; queue;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyStack</span><span class="hljs-params">()</span> </span>&#123;        queue = <span class="hljs-keyword">new</span> DoubleEndsQueue&lt;&gt;();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(T value)</span></span>&#123;        queue.addFromHead(value);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> queue.popFromHead();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> queue.isEmpty();    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyQueue</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;    <span class="hljs-keyword">private</span> DoubleEndsQueue&lt;T&gt; queue;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyQueue</span><span class="hljs-params">()</span> </span>&#123;        queue = <span class="hljs-keyword">new</span> DoubleEndsQueue&lt;&gt;();    &#125;    <span class="hljs-comment">// 出push</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(T value)</span></span>&#123;        queue.addFromHead(value);    &#125;    <span class="hljs-comment">// 进poll</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">poll</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> queue.popFromBottom();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> queue.isEmpty();    &#125;&#125;</code></pre></li><li><p>数组实现</p><blockquote><p>数组实现栈</p></blockquote></li></ul><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayStack</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span>[] a;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size;<span class="hljs-comment">//栈数组的大小</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> top;<span class="hljs-comment">//栈顶</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayStack</span><span class="hljs-params">(<span class="hljs-keyword">int</span> maxSize)</span> </span>&#123;        <span class="hljs-keyword">this</span>.size = maxSize;        <span class="hljs-keyword">this</span>.a = <span class="hljs-keyword">new</span> <span class="hljs-keyword">long</span>[size];        <span class="hljs-keyword">this</span>.top = -<span class="hljs-number">1</span>;<span class="hljs-comment">//表示空栈</span>    &#125;    <span class="hljs-comment">//入栈</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">long</span> value)</span></span>&#123;        <span class="hljs-keyword">if</span>(isFull())&#123;            System.out.println(<span class="hljs-string">&quot;栈已经满！&quot;</span>);            <span class="hljs-keyword">return</span>;        &#125;        a[++top] = value;    &#125;    <span class="hljs-comment">//返回栈顶内容，但是不删除</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">peek</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">if</span>(isEmpty())&#123;            System.out.println(<span class="hljs-string">&quot;栈中没有数据！&quot;</span>);        &#125;        System.out.println(a[top]);    &#125;    <span class="hljs-comment">//弹出栈顶内容，删除</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">if</span>(isEmpty())&#123;            System.out.println(<span class="hljs-string">&quot;栈中没有数据！&quot;</span>);            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">return</span> a[top--];    &#125;    <span class="hljs-comment">//size栈的大小</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> top + <span class="hljs-number">1</span>;    &#125;    <span class="hljs-comment">//是否为空</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> (top == -<span class="hljs-number">1</span>);    &#125;    <span class="hljs-comment">//是否满了</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isFull</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> (top == size - <span class="hljs-number">1</span>);    &#125;    <span class="hljs-comment">//显示</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span></span>&#123;        System.out.print(<span class="hljs-string">&quot;[&quot;</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = top; i &gt;=<span class="hljs-number">0</span> ; i--) &#123;            System.out.print(a[i]);            <span class="hljs-keyword">if</span>(i!=<span class="hljs-number">0</span>)&#123;                System.out.print(<span class="hljs-string">&quot;,&quot;</span>);            &#125;        &#125;        System.out.println(<span class="hljs-string">&quot;]&quot;</span>);    &#125;&#125;</code></pre><blockquote><p>数组实现队列</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyQueue</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] arr;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> pushi;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> polli;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> limit;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyQueue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> limit)</span> </span>&#123;        <span class="hljs-keyword">this</span>.arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[limit];        <span class="hljs-keyword">this</span>.pushi = <span class="hljs-number">0</span>;        <span class="hljs-keyword">this</span>.polli = <span class="hljs-number">0</span>;        <span class="hljs-keyword">this</span>.size = <span class="hljs-number">0</span>;        <span class="hljs-keyword">this</span>.limit = limit;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;        <span class="hljs-keyword">if</span> (size == limit)&#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;栈满了，不能再加了&quot;</span>);        &#125;        size++;        arr[pushi] = value;        pushi = nextIndex(pushi);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">poll</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (size == <span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;栈空了，不能再拿了&quot;</span>);        &#125;        size--;        <span class="hljs-keyword">int</span> ans = arr[polli];        polli = nextIndex(polli);        <span class="hljs-keyword">return</span> ans;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> size == <span class="hljs-number">0</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">nextIndex</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>&#123;        <span class="hljs-keyword">return</span> i &lt; limit - <span class="hljs-number">1</span> ? i + <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;    &#125;&#125;</code></pre><h2 id="栈和队列的常见面试题"><a href="#栈和队列的常见面试题" class="headerlink" title="栈和队列的常见面试题"></a>栈和队列的常见面试题</h2><h3 id="1、实现一个特殊的栈，在基本功能的基础上，再实现返回栈中最小元素的功能"><a href="#1、实现一个特殊的栈，在基本功能的基础上，再实现返回栈中最小元素的功能" class="headerlink" title="1、实现一个特殊的栈，在基本功能的基础上，再实现返回栈中最小元素的功能"></a>1、实现一个特殊的栈，在基本功能的基础上，再实现返回栈中最小元素的功能</h3><blockquote><p>1）pop、push、getMin操作的时间复杂度都是 O(1)。 </p><p>2）设计的栈类型可以使用现成的栈结构。</p></blockquote><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201128160516.png" alt="实现"></p><p> <strong>当前数和最小栈栈顶做比较, 谁小加谁</strong>,  弹出一起弹出 —–&gt; MyStack2</p><p> <strong>当前数和最小栈栈顶做比较, 只有小于最小栈栈顶才压入</strong>,弹出如果Data Peek = Min Peek, 一起弹出 —–&gt; MyStack1</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 想要压入的数比最小栈大 不压入, 小于等于压入</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyStack1</span> </span>&#123;    <span class="hljs-keyword">private</span> Stack&lt;Integer&gt; stackData;    <span class="hljs-keyword">private</span> Stack&lt;Integer&gt; stackMin;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyStack1</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">this</span>.stackData = <span class="hljs-keyword">new</span> Stack&lt;Integer&gt;();        <span class="hljs-keyword">this</span>.stackMin = <span class="hljs-keyword">new</span> Stack&lt;Integer&gt;();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> newNum)</span> </span>&#123;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.stackMin.isEmpty()) &#123;            <span class="hljs-keyword">this</span>.stackMin.push(newNum);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (newNum &lt;= <span class="hljs-keyword">this</span>.getmin()) &#123;            <span class="hljs-keyword">this</span>.stackMin.push(newNum);        &#125;        <span class="hljs-keyword">this</span>.stackData.push(newNum);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 弹出如果Data栈弹出的数等于最小栈栈顶则弹出</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.stackData.isEmpty()) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;Your stack is empty.&quot;</span>);        &#125;        <span class="hljs-keyword">int</span> value = <span class="hljs-keyword">this</span>.stackData.pop();        <span class="hljs-keyword">if</span> (value == <span class="hljs-keyword">this</span>.getmin()) &#123;            <span class="hljs-keyword">this</span>.stackMin.pop();        &#125;        <span class="hljs-keyword">return</span> value;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getmin</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.stackMin.isEmpty()) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;Your stack is empty.&quot;</span>);        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.stackMin.peek();    &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 想要压入的数比最小栈大 重复压入最小栈栈顶</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyStack2</span> </span>&#123;    <span class="hljs-keyword">private</span> Stack&lt;Integer&gt; stackData;    <span class="hljs-keyword">private</span> Stack&lt;Integer&gt; stackMin;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyStack2</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">this</span>.stackData = <span class="hljs-keyword">new</span> Stack&lt;Integer&gt;();        <span class="hljs-keyword">this</span>.stackMin = <span class="hljs-keyword">new</span> Stack&lt;Integer&gt;();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> newNum)</span></span>&#123;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.stackMin.isEmpty())&#123;            <span class="hljs-comment">// 如果最小栈没有元素 直接压入</span>            <span class="hljs-keyword">this</span>.stackMin.push(newNum);        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (newNum &lt; <span class="hljs-keyword">this</span>.getMin())&#123;            <span class="hljs-comment">// 如果最小栈栈顶小于newNum</span>            <span class="hljs-keyword">this</span>.stackMin.push(newNum);        &#125;<span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// 如果最小栈栈顶大于newNum, 重复压入栈顶元素</span>            <span class="hljs-keyword">int</span> minNum = <span class="hljs-keyword">this</span>.getMin();            <span class="hljs-keyword">this</span>.stackMin.push(minNum);        &#125;        <span class="hljs-keyword">this</span>.stackData.push(newNum);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.stackData.isEmpty()) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;Your stack is empty.&quot;</span>);        &#125;        <span class="hljs-keyword">this</span>.stackMin.pop();        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.stackData.pop();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMin</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.stackMin.isEmpty())&#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;Your stack is empty.&quot;</span>);        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.stackMin.peek();    &#125;&#125;</code></pre><h3 id="2、栈与队列互相实现"><a href="#2、栈与队列互相实现" class="headerlink" title="2、栈与队列互相实现"></a>2、栈与队列互相实现</h3><blockquote><p>1）如何用栈结构实现队列结构</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TwoStacksQueue</span> </span>&#123;        <span class="hljs-keyword">public</span> Stack&lt;Integer&gt; stackPush;        <span class="hljs-keyword">public</span> Stack&lt;Integer&gt; stackPop;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TwoStacksQueue</span><span class="hljs-params">()</span> </span>&#123;            stackPush = <span class="hljs-keyword">new</span> Stack&lt;Integer&gt;();            stackPop = <span class="hljs-keyword">new</span> Stack&lt;Integer&gt;();        &#125;        <span class="hljs-comment">// push栈向pop栈倒入数据</span>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pushToPop</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">if</span> (stackPop.empty())&#123;                <span class="hljs-keyword">while</span> (!stackPush.empty())&#123;                    stackPop.push(stackPush.pop());                &#125;            &#125;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pushInt)</span></span>&#123;            stackPush.push(pushInt);<span class="hljs-comment">//            pushToPop();</span>        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">poll</span><span class="hljs-params">()</span></span>&#123;            <span class="hljs-keyword">if</span> (stackPop.empty() &amp;&amp; stackPush.empty()) &#123;                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;Queue is empty!&quot;</span>);            &#125;            pushToPop();            <span class="hljs-keyword">return</span> stackPop.pop();        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">peek</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">if</span> (stackPop.empty() &amp;&amp; stackPush.empty()) &#123;                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;Queue is empty!&quot;</span>);            &#125;            pushToPop();            <span class="hljs-keyword">return</span> stackPop.peek();        &#125;    &#125;</code></pre><blockquote><p>2）如何用队列结构实现栈结构</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TwoQueueStack</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;    <span class="hljs-keyword">public</span> Queue&lt;T&gt; queue;    <span class="hljs-keyword">public</span> Queue&lt;T&gt; help;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TwoQueueStack</span><span class="hljs-params">()</span> </span>&#123;        queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        help = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(T value)</span></span>&#123; queue.offer(value);&#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">poll</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">while</span> (queue.size() &gt; <span class="hljs-number">1</span>)&#123;            help.offer(queue.poll());        &#125;        T ans = queue.poll();        Queue&lt;T&gt; temp = queue;        queue = help;        help = temp;        <span class="hljs-keyword">return</span> ans;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">peek</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">while</span> (queue.size() &gt; <span class="hljs-number">1</span>)&#123;            help.offer(queue.poll());        &#125;        T ans = queue.peek();        Queue&lt;T&gt; temp = queue;        queue = help;        help = temp;        queue.offer(ans);        <span class="hljs-keyword">return</span> ans;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> queue.isEmpty();    &#125;&#125;</code></pre><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><blockquote><p>怎么从思想上理解递归</p></blockquote><p>求数组arr[L..R]中的最大值，怎么用递归方法实现。</p><p>1）将[L..R]范围分成左右两半。左：[L..Mid]  右[Mid+1..R]<br>2）左部分求最大值，右部分求最大值<br>3） [L..R]范围上的最大值，是max{左部分最大值，右部分最大值}</p><p>注意：2）是个递归过程，当范围上只有一个数，就可以不用再递归了</p><pre><code class="hljs java"><span class="hljs-comment">// 求arr中的最大值</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMax</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;    <span class="hljs-keyword">return</span> process(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>);&#125;<span class="hljs-comment">// arr[L..R]范围上求最大值  L ... R   N</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">process</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R)</span> </span>&#123;    <span class="hljs-keyword">if</span> (L == R) &#123; <span class="hljs-comment">// arr[L..R]范围上只有一个数，直接返回，base case</span>        <span class="hljs-keyword">return</span> arr[L];    &#125;    <span class="hljs-keyword">int</span> mid = L + ((R - L) &gt;&gt; <span class="hljs-number">1</span>); <span class="hljs-comment">// 中点    1</span>    <span class="hljs-keyword">int</span> leftMax = process(arr, L, mid);    <span class="hljs-keyword">int</span> rightMax = process(arr, mid + <span class="hljs-number">1</span>, R);    <span class="hljs-keyword">return</span> Math.max(leftMax, rightMax);&#125;</code></pre><h3 id="递归的脑图和实际实现"><a href="#递归的脑图和实际实现" class="headerlink" title="递归的脑图和实际实现"></a>递归的脑图和实际实现</h3><p>对于新手来说，把调用的过程画出结构图是必须的，这有利于分析递归</p><p>递归并不是玄学，递归底层是利用系统栈来实现的</p><p>任何递归函数都一定可以改成非递归</p><h3 id="Master公式"><a href="#Master公式" class="headerlink" title="Master公式"></a>Master公式</h3><blockquote><p>形如T(N) = a * T(N/b) + O(N^d)(其中的a、b、d都是常数)的递归函数，可以直接通过Master公式来确定时间复杂度, a次子问题规模(总问题是子问题的b倍规模)</p></blockquote><p>以b为底, logb(a)</p><p>如果 log(b,a) &lt; d，复杂度为O(N^d)<br>如果 log(b,a) &gt; d，复杂度为O(N^log(b,a))<br>如果 log(b,a) == d，复杂度为O(N^d  * logN)</p><p>上述算法中, 把数组分成两份, 每份1/2, 其他时间复杂度为O(1)</p><p>T(N) = 2 * T(N/2) + O(N^0) 即O(N), 与从左往右遍历一遍是一样的</p><p>如果左边2/3, 右边也2/3, 也是两份, 其他再打印一次, 时间复杂度为O(n)</p><p>T(N) = 2 * T(N/(3/2)) + O(N^1)</p><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>1)哈希表在使用层面上可以理解为一种集合结构<br>2)如果只有key，没有伴随数据value，可以使用 <strong><em>HashSet</em></strong>结构<br>3)如果既有key，又有伴随数据value，可以使用 <strong><em>HashMap</em></strong>结构<br>4) <strong><em>有无伴随数据，是HashMap和HashSet唯一的区别，实际结构是一回事</em></strong><br>5)使用哈希表增(put)、删(remove)、改(put)和查(get)的操作，可以认为时间复杂度为 O(1)，但是 <strong><em>常数时间</em></strong>比较大<br>6)放入哈希表的东西，如果是基础类型， <strong><em>内部按值传递</em></strong>，内存占用是这个东西的大小 </p><pre><code class="hljs java"><span class="hljs-keyword">int</span> a = <span class="hljs-number">100000</span>;<span class="hljs-keyword">int</span> b = <span class="hljs-number">100000</span>;<span class="hljs-comment">// 不关心内存区域, 只关心对应的值</span>System.out.println(a == b);Integer c = <span class="hljs-number">100000</span>;Integer d = <span class="hljs-number">100000</span>;<span class="hljs-comment">// 关心内存区域</span>System.out.println(c.equals(d));Integer e = <span class="hljs-number">127</span>;  <span class="hljs-comment">//  - 128  ~  127 true, 按值传递</span>Integer f = <span class="hljs-number">127</span>;System.out.println(e == f);<span class="hljs-comment">// 但是在哈希表中, 基础类型, 内部都按值传递</span></code></pre><p>7)放入哈希表的东西，如果不是基础类型， <strong><em>内部按引用传递</em></strong>，内存占用是8字节</p><pre><code class="hljs java">HashMap&lt;Node, String&gt; map2 = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();Node node1 = <span class="hljs-keyword">new</span> Node(<span class="hljs-number">1</span>);Node node2 = node1;map2.put(node1, <span class="hljs-string">&quot;我是node1&quot;</span>);map2.put(node2, <span class="hljs-string">&quot;我是node1&quot;</span>);System.out.println(map2.size());<span class="hljs-comment">// 结果为 1</span></code></pre><pre><code class="hljs java">HashMap&lt;Node, String&gt; map2 = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();Node node1 = <span class="hljs-keyword">new</span> Node(<span class="hljs-number">1</span>);Node node2 = <span class="hljs-keyword">new</span> Node(<span class="hljs-number">2</span>);map2.put(node1, <span class="hljs-string">&quot;我是node1&quot;</span>);map2.put(node2, <span class="hljs-string">&quot;我是node1&quot;</span>);System.out.println(map2.size());<span class="hljs-comment">// 结果为 2</span></code></pre><pre><code class="hljs processing">即如果<span class="hljs-keyword">HashMap</span>&lt;<span class="hljs-keyword">String</span>, <span class="hljs-keyword">String</span>&gt; <span class="hljs-built_in">map</span> = <span class="hljs-keyword">new</span> <span class="hljs-keyword">HashMap</span>&lt;&gt;();<span class="hljs-built_in">key</span>和value都传<span class="hljs-number">100</span>位数据, 最终数据占用为 <span class="hljs-number">4</span> * <span class="hljs-number">100</span> * <span class="hljs-number">2</span>但如果<span class="hljs-keyword">HashMap</span>&lt;Node, Node&gt; map2 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">HashMap</span>&lt;&gt;();<span class="hljs-built_in">key</span>和value都传<span class="hljs-number">20</span>g数据, <span class="hljs-built_in">map</span>中只存内存地址<span class="hljs-number">8</span>字节, <span class="hljs-number">4</span> * <span class="hljs-number">8</span> * <span class="hljs-number">2</span>字节大小完成操作</code></pre><h2 id="有序表-TreeMap-O-logN"><a href="#有序表-TreeMap-O-logN" class="headerlink" title="有序表(TreeMap) O(logN)"></a>有序表(TreeMap) O(logN)</h2><p>1)有序表在使用层面上可以理解为一种集合结构<br>2)如果只有key，没有伴随数据value，可以使用TreeSet结构<br>3)如果既有key，又有伴随数据value，可以使用TreeMap结构<br>4)有无伴随数据，是TreeSet和TreeMap唯一的区别，底层的实际结构是一回事<br>5) <strong><em>有序表把key按照顺序组织起来，而哈希表完全不组织</em></strong></p><pre><code class="hljs java">System.out.println(treeMap.firstKey());System.out.println(treeMap.lastKey());<span class="hljs-comment">// &lt;= 4</span>System.out.println(treeMap.floorKey(<span class="hljs-number">4</span>));<span class="hljs-comment">// &gt;= 4</span>System.out.println(treeMap.ceilingKey(<span class="hljs-number">4</span>));</code></pre><ol start="6"><li><strong><em>红黑树</em></strong>、 <strong><em>AVL树</em></strong>、 <strong><em>size-balance-tree</em></strong>和 <strong><em>跳表</em></strong>等都属于 <strong><em>有序表</em></strong>结构，只是底层具体实现不同</li><li>放入如果是基础类型，内部按值传递，内存占用就是这个东西的大小</li><li>放入如果不是基础类型，内部按引用传递，内存占用是8字节</li><li>不管是什么底层具体实现，只要是有序表，都有以下固定的基本功能和固定的时间复杂度 </li></ol><blockquote><p>Api</p></blockquote><p>1)void put(K key, V value)<br>将一个(key，value)记录加入到表中，或者将key的记录 更新成value。<br>2)V get(K key)<br>根据给定的key，查询value并返回。<br>3)void remove(K key)<br>移除key的记录。<br>4)boolean containsKey(K key)<br>询问是否有关于key的记录。</p><p>5)K firstKey()<br>返回所有键值的排序结果中，最小的那个。6)K lastKey()<br>返回所有键值的排序结果中，最大的那个。7)K floorKey(K key)<br>返回&lt;= key 离key最近的那个<br>8)K ceilingKey(K key）<br>返回&gt;= key 离key最近的那个</p><blockquote><p>哈希表在使用时，增删改查时间复杂度都是O(1)<br>有序表在使用时，比哈希表功能多，时间复杂度都是O(logN)</p></blockquote><h1 id="归并排序与随机快排"><a href="#归并排序与随机快排" class="headerlink" title="归并排序与随机快排"></a>归并排序与随机快排</h1><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><blockquote><p>1）整体是递归，左边排好序+右边排好序+merge让整体有序</p></blockquote><p>例子: [3, 1, 2, 4]</p><p>主函数: f(0, 3) </p><p>运行后process(0,1) 再 process(2, 3) 再merge</p><p>而运行process(0,1) 需要process(0,0)再process(1,1)再merge</p><p>运行process(2, 3)需要process(2, 2)再process(3, 3)再merge</p><h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><pre><code class="hljs java"><span class="hljs-comment">// 递归方法实现</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mergeSort1</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span></span>&#123;    <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length &lt; <span class="hljs-number">2</span>) &#123;        <span class="hljs-keyword">return</span>;    &#125;    process(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>);&#125;<span class="hljs-comment">// 让arr L - R范围变成有序</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R)</span></span>&#123;    <span class="hljs-keyword">if</span> (L == R)&#123; <span class="hljs-comment">// base case</span>        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">int</span> mid = L + (( R - L ) &gt;&gt; <span class="hljs-number">2</span>);    process(arr, L, mid);    process(arr, mid + <span class="hljs-number">1</span>, R);    merge(arr, L, mid, R);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span>  <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> M, <span class="hljs-keyword">int</span> R)</span></span>&#123;    <span class="hljs-keyword">int</span>[] help = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[R - L + <span class="hljs-number">1</span>];    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; <span class="hljs-comment">// help数组的指针</span>    <span class="hljs-keyword">int</span> p1 = L; <span class="hljs-comment">// 左部分指针</span>    <span class="hljs-keyword">int</span> p2 = M + <span class="hljs-number">1</span>; <span class="hljs-comment">// 又部分指针</span>    <span class="hljs-keyword">while</span> (p1 &lt;= M &amp;&amp; p2 &lt;= R)&#123;        help[i++] = arr[p1] &lt;= arr[p2] ? arr[p1++] : arr[p2++];    &#125;    <span class="hljs-comment">// 要么p1越界, 要么p2越界</span>    <span class="hljs-keyword">while</span> (p1 &lt;= M)&#123;        help[i++] = arr[p1++];    &#125;    <span class="hljs-keyword">while</span> (p2 &lt;= R)&#123;        help[i++] = arr[p2++];    &#125;    <span class="hljs-comment">// 把help的值赋值回去</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; help.length ; j++) &#123;        arr[L + i] = help[i];    &#125;&#125;</code></pre><h3 id="非递归实现"><a href="#非递归实现" class="headerlink" title="非递归实现"></a>非递归实现</h3><p>例子[2, 3, 1, 4, 5, 6]</p><p>初始k = 1, 每个最小原子单元, 即每个数自我有序,</p><p>K &lt;&lt; 2, 每两个一组进行merge, 变成[2, 3, 1, 4, 5, 6]</p><p>K &lt;&lt; 2, 每四个一组进行merge, 不够则凑一组[1, 2, 3, 4, 5, 6]</p><p>直到k &gt;= N</p><pre><code class="hljs java"><span class="hljs-comment">// 非递归方法实现</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mergeSort2</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;   <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length &lt; <span class="hljs-number">2</span>) &#123;      <span class="hljs-keyword">return</span>;   &#125;   <span class="hljs-keyword">int</span> N = arr.length;   <span class="hljs-keyword">int</span> mergeSize = <span class="hljs-number">1</span>;<span class="hljs-comment">// 一组是两倍的mergeSize, 当前有序的左组长度</span>   <span class="hljs-keyword">while</span> (mergeSize &lt; N) &#123;      <span class="hljs-keyword">int</span> L = <span class="hljs-number">0</span>;      <span class="hljs-keyword">while</span> (L &lt; N) &#123;         <span class="hljs-comment">// L...M 左组(mergeSize大小)</span>         <span class="hljs-comment">// 求中间</span>         <span class="hljs-keyword">int</span> M = L + mergeSize - <span class="hljs-number">1</span>;         <span class="hljs-keyword">if</span> (M &gt;= N) &#123;            <span class="hljs-keyword">break</span>;         &#125;         <span class="hljs-comment">// L...M   M+1...R</span>         <span class="hljs-comment">// 右组可能凑不齐mergeSize个</span>         <span class="hljs-comment">// 求右边</span>         <span class="hljs-keyword">int</span> R = Math.min(M + mergeSize, N - <span class="hljs-number">1</span>);         merge(arr, L, M, R);         <span class="hljs-comment">// 算下一次左边</span>         L = R + <span class="hljs-number">1</span>;      &#125;            <span class="hljs-comment">// 防止溢出</span>      <span class="hljs-keyword">if</span> (mergeSize &gt; N / <span class="hljs-number">2</span>) &#123;         <span class="hljs-keyword">break</span>;      &#125;      mergeSize &lt;&lt;= <span class="hljs-number">1</span>;   &#125;&#125;</code></pre><h3 id="利用master公式来求解时间复杂度"><a href="#利用master公式来求解时间复杂度" class="headerlink" title="利用master公式来求解时间复杂度"></a>利用master公式来求解时间复杂度</h3><pre><code class="hljs mathematica"><span class="hljs-variable">T</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span><span class="hljs-operator">*</span><span class="hljs-variable">T</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-operator">/</span><span class="hljs-number">2</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">+</span> <span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-operator">^</span><span class="hljs-number">1</span><span class="hljs-punctuation">)</span>根据<span class="hljs-variable">master</span>可知时间复杂度为<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-operator">*</span><span class="hljs-variable">logN</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">(</span>非递归分析<span class="hljs-operator">:</span>每次<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span> <span class="hljs-number">2</span><span class="hljs-operator">,</span> <span class="hljs-number">4</span><span class="hljs-operator">,</span> <span class="hljs-number">8</span><span class="hljs-operator">,</span> <span class="hljs-number">16</span> <span class="hljs-operator">....</span> <span class="hljs-built_in">N</span> <span class="hljs-operator">,</span> <span class="hljs-built_in">Log</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-punctuation">)</span>次<span class="hljs-operator">,</span> 所以<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-operator">*</span><span class="hljs-variable">logN</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">)</span><span class="hljs-variable">merge</span>过程需要辅助数组，所以额外空间复杂度为<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-punctuation">)</span>归并排序的实质是把比较行为变成了有序信息并传递，比<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-operator">^</span><span class="hljs-number">2</span><span class="hljs-punctuation">)</span>的排序快<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-operator">^</span><span class="hljs-number">2</span><span class="hljs-punctuation">)</span>在无限浪费比较行为<span class="hljs-operator">,</span> 例如选择排序<span class="hljs-operator">,</span> 每次都与后面比较大小</code></pre><h3 id="用常见面试题再深入理解一下归并排序的精髓"><a href="#用常见面试题再深入理解一下归并排序的精髓" class="headerlink" title="用常见面试题再深入理解一下归并排序的精髓"></a>用常见面试题再深入理解一下归并排序的精髓</h3><blockquote><p> 在一个数组中，一个数左边比它小的数的总和，叫数的小和，所有数的小和累加起来，叫数组小和。求数组小和。</p></blockquote><p>例子： [1,3,4,2,5]<br>1左边比1小的数：没有<br>3左边比3小的数：1<br>4左边比4小的数：1、3<br>2左边比2小的数：1<br>5左边比5小的数：1、3、4、 2<br>所以数组的小和为1+1+3+1+1+3+4+2=16 </p><p>每次merge时, 两个指针对应的数比较大小, 如果小, 则计算另外一个指针包括当前位置以后的有多少个比对方大的数字.</p><pre><code class="hljs css">例子:<span class="hljs-selector-attr">[1,3,4,2,5]</span> 分为<span class="hljs-selector-attr">[1,3]</span>和<span class="hljs-selector-attr">[4,2,5]</span><span class="hljs-selector-attr">[1]</span> <span class="hljs-selector-attr">[3]</span><span class="hljs-selector-tag">merge</span>时, 1比3小, 1个1<span class="hljs-selector-attr">[4,2,5]</span>分为<span class="hljs-selector-attr">[4]</span>,<span class="hljs-selector-attr">[2, 5]</span><span class="hljs-selector-attr">[4]</span><span class="hljs-selector-tag">merge</span>, <span class="hljs-selector-tag">return</span> 0<span class="hljs-selector-attr">[2, 5]</span><span class="hljs-selector-tag">merge</span>时候, 2比5小, 1个2<span class="hljs-selector-attr">[4]</span>与<span class="hljs-selector-attr">[2,5]</span><span class="hljs-selector-tag">merge</span>时候, 左指针初始4, 右指针初始2, 4 &gt; 2, <span class="hljs-selector-tag">help</span>数组放入2, 右指针右移4 &lt; 5, 1个4,<span class="hljs-selector-tag">help</span>数组放入4,越界,放入5<span class="hljs-selector-attr">[1,3]</span>和<span class="hljs-selector-attr">[2,4,5]</span><span class="hljs-selector-tag">merge</span>, 1&lt;2, 3个1, 3&lt;4, 2个3结束4个1, 1个2, 2个3, 1个4,</code></pre><blockquote><p>其实就是在左指针与右指针对比时, 加上右指针开始个大于左指针数(利用右边有序)的左指针当前数</p><p>result += arr[p1] &lt; arr[p2] ? arr[p1] * (R - p2 + 1) : 0;</p><p>也可以解决降序对的问题</p><p>只要纠结右边有多少个数比左边大这类的问题，都可以用归并</p></blockquote><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">smallNum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[])</span></span>&#123;    <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length &lt; <span class="hljs-number">2</span>)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">return</span> process(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">process</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R)</span></span>&#123;    <span class="hljs-keyword">if</span> (L == R)&#123;        <span class="hljs-comment">// 只有一个数, 右组都没有</span>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">int</span> mid = L + ((R - L) &gt;&gt; <span class="hljs-number">2</span>);    <span class="hljs-keyword">return</span> process(arr, L, mid) + process(arr, mid + <span class="hljs-number">1</span>, R) + merge(arr, L, mid, R);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> mid, <span class="hljs-keyword">int</span> R)</span></span>&#123;    <span class="hljs-keyword">int</span> help[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[R - L + <span class="hljs-number">1</span>];    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> p1 = L;    <span class="hljs-keyword">int</span> p2 = mid + <span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> result = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (p1 &lt;= mid &amp;&amp; p2 &lt;= R)&#123;        result += arr[p1] &lt; arr[p2] ? arr[p1] * (R - p2 + <span class="hljs-number">1</span>) : <span class="hljs-number">0</span>;        help[i++] = arr[p1] &lt; arr[p2] ? arr[p1++] : arr[p2++];    &#125;    <span class="hljs-keyword">while</span> (p1 &lt;= mid)&#123;        help[i++] = arr[p1++];    &#125;    <span class="hljs-keyword">while</span> (p2 &lt;= R)&#123;        help[i++] = arr[p2++];    &#125;    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; help.length; i++) &#123;        arr[L + i] = help[i];    &#125;    <span class="hljs-keyword">return</span> result;&#125;</code></pre><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="Partition过程"><a href="#Partition过程" class="headerlink" title="Partition过程"></a>Partition过程</h3><blockquote><p>给定一个数组arr，和一个整数num。请把小于等于num的数放在数组的左边，大于num的数放在数组的右边。<br>要求额外空间复杂度O(1)，时间复杂度O(N) </p></blockquote><p>设置一个 <strong><em>小于等于区</em></strong>, 设初始位置 -1, </p><ol><li><p>[i]&lt;=num,当前数和小于等于区下一个位置交换, 小于等于区右扩, i++</p></li><li><p>[i]&gt;num, i++</p></li></ol><p>例子: [5, 3, 7, 2] num = 3</p><p>一开始小于等于区位置 -1, i=0, i[0]=5 &gt; 3, i++, 跳到3, 3&lt;=num, 与小于等于区下一个数即i[0]交换</p><p>变成[3, 5, 7, 2]小于等于区右扩, 初始位置为0, 逐步下去</p><pre><code class="hljs java"><span class="hljs-comment">// 以arr[R]做划分值</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R)</span> </span>&#123;   <span class="hljs-keyword">if</span> (L &gt; R) &#123;      <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;   &#125;   <span class="hljs-keyword">if</span> (L == R) &#123;      <span class="hljs-keyword">return</span> L;   &#125;   <span class="hljs-keyword">int</span> lessEqual = L - <span class="hljs-number">1</span>;   <span class="hljs-keyword">int</span> index = L;   <span class="hljs-keyword">while</span> (index &lt; R) &#123;      <span class="hljs-keyword">if</span> (arr[index] &lt;= arr[R]) &#123;         swap(arr, index, ++lessEqual);      &#125;      index++;   &#125;   swap(arr, ++lessEqual, R);   <span class="hljs-keyword">return</span> lessEqual;&#125;</code></pre><h3 id="荷兰国旗问题"><a href="#荷兰国旗问题" class="headerlink" title="荷兰国旗问题"></a>荷兰国旗问题</h3><blockquote><p>给定一个数组arr，和一个整数num。请把小于num的数放在数组的左边，等于num的数放在中间，大于num的数放在数组的右边。</p><p>要求额外空间复杂度O(1)，时间复杂度O(N)  </p></blockquote><p>设置一个 <strong><em>小于区</em></strong>,设初始位置 -1 ;  设置一个 <strong><em>大于区</em></strong>,设初始位置 length -1</p><ol><li><p>[i] == num, i++</p></li><li><p>[i] &lt; num, [i] 与小于区下一个交换, 小于区右扩, i++</p></li><li><p>[i] &gt; num, [i] 与大于区左一个交换, 大于区左扩, i <strong><em>停在原地</em></strong></p></li></ol><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201129162221.png" alt="流程图"></p><p>i与大于区边界撞上的时候停</p><pre><code class="hljs java"><span class="hljs-comment">// arr[L...R] 玩荷兰国旗问题的划分，以arr[R]做划分值</span><span class="hljs-comment">//  &lt;arr[R]  ==arr[R]  &gt; arr[R]</span><span class="hljs-comment">// 返回等于区域范围</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] netherlandsFlag(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R) &#123;   <span class="hljs-keyword">if</span> (L &gt; R) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123; -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span> &#125;;   &#125;   <span class="hljs-keyword">if</span> (L == R) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123; L, R &#125;;   &#125;   <span class="hljs-keyword">int</span> less = L - <span class="hljs-number">1</span>; <span class="hljs-comment">// &lt; 区 右边界</span>   <span class="hljs-keyword">int</span> more = R;     <span class="hljs-comment">// &gt; 区 左边界</span>   <span class="hljs-keyword">int</span> index = L;   <span class="hljs-keyword">while</span> (index &lt; more) &#123;      <span class="hljs-keyword">if</span> (arr[index] == arr[R]) &#123;         index++;      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[index] &lt; arr[R]) &#123;         swap(arr, index++, ++less);      &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// &gt;</span>         swap(arr, index, --more);      &#125;   &#125;   <span class="hljs-comment">// L...Less 小于区 less+1...more-1 等于区 more...R-1 大于区  R没动过</span>   <span class="hljs-comment">// 交换后</span>   <span class="hljs-comment">// L...Less 小于区 less+1.....more 等于区 more+1...R 大于区</span>   swap(arr, more, R);   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123; less + <span class="hljs-number">1</span>, more &#125;;&#125;</code></pre><h2 id="快速排序1-0"><a href="#快速排序1-0" class="headerlink" title="快速排序1.0"></a>快速排序1.0</h2><p>在arr[L..R]范围上，进行快速排序的过程：<br>1）用arr[R]对该范围做partition，&lt;= arr[R]的数在左部分并且保证arr[R]最后来到左部分小于区的最后一个位置，记为M； &lt;= arr[R]的数在右部分（arr[M+1..R]）,此时X就已经排好序了<br>2）对arr[L..M-1]进行快速排序(递归)<br>3）对arr[M+1..R]进行快速排序(递归)<br>因为每一次partition都会搞定一个数的位置且不会再变动，所以排序能完成</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quickSort1</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;   <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length &lt; <span class="hljs-number">2</span>) &#123;      <span class="hljs-keyword">return</span>;   &#125;   process1(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process1</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R)</span> </span>&#123;   <span class="hljs-keyword">if</span> (L &gt;= R) &#123;      <span class="hljs-keyword">return</span>;   &#125;   <span class="hljs-comment">// L..R partition arr[R]  [   &lt;=arr[R]   arr[R]    &gt;arr[R]  ]</span>   <span class="hljs-keyword">int</span> M = partition(arr, L, R);   process1(arr, L, M - <span class="hljs-number">1</span>);   process1(arr, M + <span class="hljs-number">1</span>, R);&#125;</code></pre><h2 id="快速排序2-0"><a href="#快速排序2-0" class="headerlink" title="快速排序2.0"></a>快速排序2.0</h2><p>在arr[L..R]范围上，进行快速排序的过程：<br>1）用arr[R]对该范围做partition，&lt; arr[R]的数在左部分，== arr[R]的数中间，&gt;arr[R]的数在右部分。假设== arr[R]的数所在范围是[a,b]<br>2）对arr[L..a-1]进行快速排序(递归)<br>3）对arr[b+1..R]进行快速排序(递归)<br>因为每一次partition都会搞定一批数的位置且不会再变动，所以排序能完成</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quickSort2</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;   <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length &lt; <span class="hljs-number">2</span>) &#123;      <span class="hljs-keyword">return</span>;   &#125;   process2(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process2</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R)</span> </span>&#123;   <span class="hljs-keyword">if</span> (L &gt;= R) &#123;      <span class="hljs-keyword">return</span>;   &#125;   <span class="hljs-keyword">int</span>[] equalArea = netherlandsFlag(arr, L, R);   process2(arr, L, equalArea[<span class="hljs-number">0</span>] - <span class="hljs-number">1</span>);   process2(arr, equalArea[<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>, R);&#125;</code></pre><h2 id="快速排序1-0和2-0的时间复杂度分析"><a href="#快速排序1-0和2-0的时间复杂度分析" class="headerlink" title="快速排序1.0和2.0的时间复杂度分析"></a>快速排序1.0和2.0的时间复杂度分析</h2><blockquote><p>数组已经有序的时候就是复杂度最高的时候<br>时间复杂度O(N^2)</p></blockquote><h2 id="快速排序3-0-随机快排-荷兰国旗技巧优化"><a href="#快速排序3-0-随机快排-荷兰国旗技巧优化" class="headerlink" title="快速排序3.0(随机快排+荷兰国旗技巧优化)"></a>快速排序3.0(随机快排+荷兰国旗技巧优化)</h2><p>在arr[L..R]范围上，进行快速排序的过程：<br>1）在这个范围上，随机选一个数记为num，<br>1）用num对该范围做partition，&lt; num的数在左部分，== num的数中间，&gt;num的数在右部分。假设== num的数所在范围是[a,b]<br>2）对arr[L..a-1]进行快速排序(递归)<br>3）对arr[b+1..R]进行快速排序(递归)<br>因为每一次partition都会搞定一批数的位置且不会再变动，所以排序能完成</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quickSort3</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;   <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length &lt; <span class="hljs-number">2</span>) &#123;      <span class="hljs-keyword">return</span>;   &#125;   process3(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process3</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R)</span> </span>&#123;   <span class="hljs-keyword">if</span> (L &gt;= R) &#123;      <span class="hljs-keyword">return</span>;   &#125;   <span class="hljs-comment">// 1、2拿arr[R]做划分值</span>   <span class="hljs-comment">// 3 随机选一个i, 人为放到arr[R], 再以arr[R]做划分值</span>   swap(arr, L + (<span class="hljs-keyword">int</span>) (Math.random() * (R - L + <span class="hljs-number">1</span>)), R);   <span class="hljs-keyword">int</span>[] equalArea = netherlandsFlag(arr, L, R);   process3(arr, L, equalArea[<span class="hljs-number">0</span>] - <span class="hljs-number">1</span>);   process3(arr, equalArea[<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>, R);&#125;</code></pre><pre><code class="hljs apache"><span class="hljs-attribute">1</span>）通过分析知道，划分值越靠近中间，性能越好；越靠近两边，性能越差<span class="hljs-attribute">2</span>）随机选一个数进行划分的目的就是让好情况和差情况都变成概率事件<span class="hljs-attribute">3</span>）把每一种情况都列出来，会有每种情况下的时间复杂度，但概率都是<span class="hljs-number">1</span>/N<span class="hljs-attribute">4</span>）那么所有情况都考虑，时间复杂度就是这种概率模型下的长期期望！</code></pre><p> *<strong>时间复杂度O(N<em>logN)，额外空间复杂度O(logN)都是这么来的。</em></strong></p><h1 id="比较器与堆"><a href="#比较器与堆" class="headerlink" title="比较器与堆"></a>比较器与堆</h1><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><h3 id="堆的实现"><a href="#堆的实现" class="headerlink" title="堆的实现"></a>堆的实现</h3><p>堆结构</p><p>1）堆结构就是用数组实现的完全二叉树结构</p><blockquote><p>完全二叉树是什么</p></blockquote><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201201131244.png" alt="完全二叉树"></p><blockquote><p>结点从左至右变满, 一个结点也是, 两个结点, 第二个结点在左边也是</p></blockquote><p>堆可以从数组arr[0]开始, 也可以从arr[1]开始, 为什么会出现从arr[1]开始的情况？</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201201131532.png" alt="arr[1]开始的堆"></p><p><strong>如图所示, 如果堆从arr[1]开始增加, 子结点以及父节点的运算都可以用位运算, 位运算就是快！</strong></p><p>2）完全二叉树中如果每棵子树的最大值都在顶部就是大根堆</p><blockquote><p>头结点为头的树, 最大值为头结点</p></blockquote><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201201131811.png" alt="大根堆"></p><p>3）完全二叉树中如果每棵子树的最小值都在顶部就是小根堆</p><blockquote><p>头结点为头的树, 最小值为头结点</p></blockquote><p>4）堆结构的heapInsert与heapify操作</p><blockquote><p>heapInsert: 数放入数组后, 与父节点比较, 如果数更大, 交换, 直到换到根结点</p></blockquote><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span></span>&#123;    <span class="hljs-keyword">if</span> (heapSize &gt; limit)&#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;heap is full!&quot;</span>);    &#125;    heap[heapSize] = value;    heapInsert(heap, heapSize++);&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 把默认最后加进来的数往上提</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> arr</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> index</span><span class="hljs-comment"> * arr[index] &gt; arr[(index - 1) / 2]已经包含两个条件</span><span class="hljs-comment"> * 1)arr[index] 不比arr[index父]大, 停</span><span class="hljs-comment"> * 2)index = 0, 停</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">heapInsert</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> index)</span></span>&#123;    <span class="hljs-keyword">while</span> (arr[index] &gt; arr[(index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>])&#123;        swap(arr, index, (index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>);        index = (index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;    &#125;&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201201133318.png" alt="heapInsert"></p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 删除堆的最大值并返回, 重组堆</span><span class="hljs-comment"> * 用最后的值去顶替arr[0]</span><span class="hljs-comment"> * 再往下交换, 找到左孩子与右孩子之间更大的数, 如果更小, 则交换</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> ans = heap[<span class="hljs-number">0</span>];    <span class="hljs-comment">// -- heapSize, 之后的数据进入无效区</span>    swap(heap, <span class="hljs-number">0</span>, -- heapSize);    heapify(heap, <span class="hljs-number">0</span>, heapSize);    <span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-comment">// 从index的位置往下看, 不断的下沉</span><span class="hljs-comment">// 1) 孩子都不比我大 停; 2) 已经没孩子了, 停</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">heapify</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> heapSize)</span></span>&#123;    <span class="hljs-keyword">int</span> left = index * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;    <span class="hljs-comment">// 左孩子不越界就肯定有孩子</span>    <span class="hljs-keyword">while</span> (left &lt; heapSize)&#123;        <span class="hljs-comment">// 再判断有没有右孩子</span>        <span class="hljs-comment">// 右孩子更大的条件是: 有右孩子 &amp;&amp; 右孩子大于左孩子</span>        <span class="hljs-keyword">int</span> largest = left + <span class="hljs-number">1</span> &lt; heapSize &amp;&amp; arr[left + <span class="hljs-number">1</span>] &gt; arr[left] ? left + <span class="hljs-number">1</span> : left;        largest = arr[largest] &gt; arr[index] ? largest : index;        <span class="hljs-comment">// 如果index更大, 则不用下坠</span>        <span class="hljs-keyword">if</span> (largest == index)&#123;            <span class="hljs-keyword">break</span>;        &#125;        swap(arr, index, largest);        index = largest;        left = index * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;    &#125;&#125;</code></pre><p>5）堆结构的增大和减少<br>6）优先级队列结构，就是堆结构(小根堆)</p><pre><code class="hljs java">PriorityQueue&lt;Integer&gt; heap = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;(<span class="hljs-keyword">new</span> MyComp());</code></pre><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><blockquote><p>先把数组数据变为大根堆结构, 再每次arr[0]与堆最后一个结点互换, 必定会把Max丢到最后, 再heapify</p></blockquote><pre><code class="hljs java"><span class="hljs-comment">// 堆排序额外空间复杂度O(1)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">heapSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;        <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length &lt; <span class="hljs-number">2</span>) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">// O(N*logN)</span><span class="hljs-comment">//    for (int i = 0; i &lt; arr.length; i++) &#123; // O(N)</span><span class="hljs-comment">//       heapInsert(arr, i); // O(logN)</span><span class="hljs-comment">//    &#125;</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = arr.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;            heapify(arr, i, arr.length);        &#125;        <span class="hljs-keyword">int</span> heapSize = arr.length;        swap(arr, <span class="hljs-number">0</span>, --heapSize);        <span class="hljs-comment">// O(N*logN)</span>        <span class="hljs-keyword">while</span> (heapSize &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// O(N)</span>            heapify(arr, <span class="hljs-number">0</span>, heapSize); <span class="hljs-comment">// O(logN)</span>            swap(arr, <span class="hljs-number">0</span>, --heapSize); <span class="hljs-comment">// O(1)</span>        &#125;    &#125;    <span class="hljs-comment">// arr[index]刚来的数，往上</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">heapInsert</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> index)</span> </span>&#123;        <span class="hljs-keyword">while</span> (arr[index] &gt; arr[(index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>]) &#123;            swap(arr, index, (index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>);            index = (index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;        &#125;    &#125;    <span class="hljs-comment">// arr[index]位置的数，能否往下移动</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">heapify</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> heapSize)</span> </span>&#123;        <span class="hljs-keyword">int</span> left = index * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>; <span class="hljs-comment">// 左孩子的下标</span>        <span class="hljs-keyword">while</span> (left &lt; heapSize) &#123; <span class="hljs-comment">// 下方还有孩子的时候</span>            <span class="hljs-comment">// 两个孩子中，谁的值大，把下标给largest</span>            <span class="hljs-comment">// 1）只有左孩子，left -&gt; largest</span>            <span class="hljs-comment">// 2) 同时有左孩子和右孩子，右孩子的值&lt;= 左孩子的值，left -&gt; largest</span>            <span class="hljs-comment">// 3) 同时有左孩子和右孩子并且右孩子的值&gt; 左孩子的值， right -&gt; largest</span>            <span class="hljs-keyword">int</span> largest = left + <span class="hljs-number">1</span> &lt; heapSize &amp;&amp; arr[left + <span class="hljs-number">1</span>] &gt; arr[left] ? left + <span class="hljs-number">1</span> : left;            <span class="hljs-comment">// 父和较大的孩子之间，谁的值大，把下标给largest</span>            largest = arr[largest] &gt; arr[index] ? largest : index;            <span class="hljs-keyword">if</span> (largest == index) &#123;                <span class="hljs-keyword">break</span>;            &#125;            swap(arr, largest, index);            index = largest;            left = index * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;        &#125;    &#125;</code></pre><pre><code class="hljs mathematica"><span class="hljs-number">1</span>，先让整个数组都变成大根堆结构，建立堆的过程<span class="hljs-operator">:</span>     <span class="hljs-number">1</span><span class="hljs-punctuation">)</span>从上到下的方法，时间复杂度为<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-operator">*</span><span class="hljs-variable">logN</span><span class="hljs-punctuation">)</span>     <span class="hljs-number">2</span><span class="hljs-punctuation">)</span>从下到上的方法，时间复杂度为<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-punctuation">)</span> <span class="hljs-number">2</span>，把堆的最大值和堆末尾的值交换，然后减少堆的大小之后，再去调整堆，一直周而复始，时间复杂度为<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-operator">*</span><span class="hljs-variable">logN</span><span class="hljs-punctuation">)</span> <span class="hljs-number">3</span>，堆的大小减小成<span class="hljs-number">0</span>之后，排序完成</code></pre><blockquote><p>堆排序优化</p></blockquote><pre><code class="hljs java"><span class="hljs-comment">// O(N*logN)</span><span class="hljs-comment">// 给定数据的数组,一个一个插入都可以</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123; <span class="hljs-comment">// O(N)</span>   heapInsert(arr, i); <span class="hljs-comment">// O(logN)</span>&#125;      <span class="hljs-comment">// O(N)</span><span class="hljs-comment">// 一定要给定数据数组, 一个一个插入无法使用</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = arr.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;   heapify(arr, i, arr.length);&#125;</code></pre><p>一个O(N*logN), 一个O(N)</p><p>怎么证明?</p><p>对于从数组最后开始heapify来说, 一颗N结点的树, 最后一层结点应该为N/2, 往上依次为N/4, N/8</p><p>最后一层只有”看”的操作, 倒数第二层有”看”和至多一次”换”的操作, 倒数第三层有”看”和至多两次”换”的操作</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201201135242.png" alt="堆排序优化"></p><h2 id="堆问题"><a href="#堆问题" class="headerlink" title="堆问题"></a>堆问题</h2><blockquote><p>已知一个几乎有序的数组。几乎有序是指，如果把数组排好顺序的话，每个元素移动的距离一定不超过k，并且k相对于数组长度来说是比较小的。<br>请选择一个合适的排序策略，对这个数组进行排序。</p></blockquote><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201207140824.png" alt="流程"></p><p>把前k+1个数放入小根堆, 例如0,1,2,3,4,5位置数放入小根堆, 0～5的数才可能来到0位置, 每排好一次序, 把最小值弹出放到0位置, 再把6位置放入小根堆, 再弹最小值…</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sortedArrDistanceLessK</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> k)</span> </span>&#123;   <span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span>) &#123;      <span class="hljs-keyword">return</span>;   &#125;   <span class="hljs-comment">// 默认小根堆</span>   PriorityQueue&lt;Integer&gt; heap = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;();   <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;   <span class="hljs-comment">// 0...K-1</span>   <span class="hljs-keyword">for</span> (; index &lt;= Math.min(arr.length - <span class="hljs-number">1</span>, k - <span class="hljs-number">1</span>); index++) &#123;      heap.add(arr[index]);   &#125;   <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;   <span class="hljs-comment">// 先加后弹</span>   <span class="hljs-keyword">for</span> (; index &lt; arr.length; i++, index++) &#123;      heap.add(arr[index]);      arr[i] = heap.poll();   &#125;   <span class="hljs-comment">// 没有数可以加了 只弹</span>   <span class="hljs-keyword">while</span> (!heap.isEmpty()) &#123;      arr[i++] = heap.poll();   &#125;&#125;</code></pre><p>O(N*logK), 前提是k小于数组长度, 每次加减logk, N次则乘</p><h2 id="比较器"><a href="#比较器" class="headerlink" title="比较器"></a>比较器</h2><blockquote><p>目前都是基于 <strong>比较</strong> 的排序, 只要告诉两个样本如何比较大小就足够</p></blockquote><p>1)比较器的实质就是 **重载比较运算符 **</p><p>2)比较器可以很好的应用在 <strong>特殊标准的排序</strong>上 </p><p>3)比较器可以很好的应用在 <strong>根据特殊标准排序的结构</strong>上</p><p>4)写代码变得异常容易，还用于 <strong>范型编程</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;   <span class="hljs-keyword">public</span> String name;   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> id;   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> age;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> id, <span class="hljs-keyword">int</span> age)</span> </span>&#123;      <span class="hljs-keyword">this</span>.name = name;      <span class="hljs-keyword">this</span>.id = id;      <span class="hljs-keyword">this</span>.age = age;   &#125;&#125;</code></pre><blockquote><p>comp(T o1, T o2) 返回负数o1放前, 正数o2放前</p></blockquote><pre><code class="hljs java">Student student1 = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-number">2</span>, <span class="hljs-number">20</span>);Student student2 = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-number">3</span>, <span class="hljs-number">21</span>);Student student3 = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">22</span>);Student[] students = <span class="hljs-keyword">new</span> Student[] &#123; student1, student2, student3 &#125;;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IdAscendingComparator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparator</span>&lt;<span class="hljs-title">Student</span>&gt; </span>&#123;   <span class="hljs-comment">// 返回负数的时候，第一个参数排在前面</span>   <span class="hljs-comment">// 返回正数的时候，第二个参数排在前面</span>   <span class="hljs-comment">// 返回0的时候，谁在前面无所谓</span>   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Student o1, Student o2)</span> </span>&#123;      <span class="hljs-keyword">return</span> o1.id - o2.id;   &#125;&#125;Arrays.sort(students, <span class="hljs-keyword">new</span> IdAscendingComparator());<span class="hljs-comment">// id升序</span></code></pre><pre><code class="hljs java"><span class="hljs-comment">// 先按照id排序，id小的，放前面；</span><span class="hljs-comment">// id一样，age大的，前面；</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IdInAgeDe</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparator</span>&lt;<span class="hljs-title">Student</span>&gt; </span>&#123;   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Student o1, Student o2)</span> </span>&#123;      <span class="hljs-keyword">return</span> o1.id != o2.id ? o1.id - o2.id  : (  o2.age - o1.age  );   &#125;<span class="hljs-comment">// 更复杂的比较器</span>&#125;</code></pre><h3 id="应用在根据特殊标准排序的结构上"><a href="#应用在根据特殊标准排序的结构上" class="headerlink" title="应用在根据特殊标准排序的结构上"></a>应用在根据特殊标准排序的结构上</h3><pre><code class="hljs java">PriorityQueue&lt;Student&gt; minHeapBasedId        = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;(<span class="hljs-keyword">new</span> AgeAscendingComparator());minHeapBasedId.add(student1);minHeapBasedId.add(student2);minHeapBasedId.add(student3);<span class="hljs-keyword">while</span> (!minHeapBasedId.isEmpty()) &#123;    Student student = minHeapBasedId.poll();    System.out.println(<span class="hljs-string">&quot;Name : &quot;</span> + student.name + <span class="hljs-string">&quot;, Id : &quot;</span> + student.id + <span class="hljs-string">&quot;, Age : &quot;</span> + student.age);&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AgeAscendingComparator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparator</span>&lt;<span class="hljs-title">Student</span>&gt; </span>&#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Student o1, Student o2)</span> </span>&#123;            <span class="hljs-keyword">return</span> o1.age - o2.age;        &#125;&#125;</code></pre><p>结果:</p><pre><code class="hljs asciidoc">===========================Name : A, Id : 2, Age : 20Name : B, Id : 3, Age : 21Name : C, Id : 1, Age : 22===========================</code></pre><h2 id="语言提供的堆结构-vs-手写的堆结构"><a href="#语言提供的堆结构-vs-手写的堆结构" class="headerlink" title="语言提供的堆结构 vs 手写的堆结构"></a>语言提供的堆结构 vs 手写的堆结构</h2><p>取决于，你有没有动态改信息的需求！</p><p>语言提供的堆结构，如果你动态改数据，不保证依然有序</p><p>手写堆结构，因为增加了对象的位置表，所以能够满足动态改信息的需求</p><blockquote><p>例子</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> classNo;   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> age;   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> id;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(<span class="hljs-keyword">int</span> c, <span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> i)</span> </span>&#123;      classNo = c;      age = a;      id = i;   &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StudentComparator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparator</span>&lt;<span class="hljs-title">Student</span>&gt; </span>&#123;   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Student o1, Student o2)</span> </span>&#123;      <span class="hljs-keyword">return</span> o1.age - o2.age;   &#125;&#125;</code></pre><pre><code class="hljs java">PriorityQueue&lt;Student&gt; heap = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;(<span class="hljs-keyword">new</span> StudentComparator());heap.add(s1);heap.add(s2);heap.add(s3);heap.add(s4);heap.add(s5);heap.add(s6);<span class="hljs-keyword">while</span> (!heap.isEmpty()) &#123;   Student cur = heap.poll();   System.out.println(cur.classNo + <span class="hljs-string">&quot;,&quot;</span> + cur.age + <span class="hljs-string">&quot;,&quot;</span> + cur.id);&#125;System.out.println(<span class="hljs-string">&quot;===============&quot;</span>);</code></pre><pre><code class="hljs asciidoc">6,10,333331,14,666663,20,444442,50,111111,60,222227,72,55555===============</code></pre><pre><code class="hljs java">s1 = <span class="hljs-keyword">new</span> Student(<span class="hljs-number">2</span>, <span class="hljs-number">50</span>, <span class="hljs-number">11111</span>);s2 = <span class="hljs-keyword">new</span> Student(<span class="hljs-number">1</span>, <span class="hljs-number">60</span>, <span class="hljs-number">22222</span>);s3 = <span class="hljs-keyword">new</span> Student(<span class="hljs-number">6</span>, <span class="hljs-number">10</span>, <span class="hljs-number">33333</span>);s4 = <span class="hljs-keyword">new</span> Student(<span class="hljs-number">3</span>, <span class="hljs-number">20</span>, <span class="hljs-number">44444</span>);s5 = <span class="hljs-keyword">new</span> Student(<span class="hljs-number">7</span>, <span class="hljs-number">72</span>, <span class="hljs-number">55555</span>);s6 = <span class="hljs-keyword">new</span> Student(<span class="hljs-number">1</span>, <span class="hljs-number">14</span>, <span class="hljs-number">66666</span>);heap = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;(<span class="hljs-keyword">new</span> StudentComparator());heap.add(s1);heap.add(s2);heap.add(s3);heap.add(s4);heap.add(s5);heap.add(s6);<span class="hljs-comment">// 加进去后 动态改已经加入堆里面的东西</span>s2.age = <span class="hljs-number">6</span>;s4.age = <span class="hljs-number">12</span>;s5.age = <span class="hljs-number">10</span>;s6.age = <span class="hljs-number">84</span>;<span class="hljs-keyword">while</span> (!heap.isEmpty()) &#123;    Student cur = heap.poll();    System.out.println(cur.classNo + <span class="hljs-string">&quot;,&quot;</span> + cur.age + <span class="hljs-string">&quot;,&quot;</span> + cur.id);&#125;</code></pre><pre><code class="hljs asciidoc">6,10,333333,12,444441,6,222227,10,555552,50,111111,84,66666===============</code></pre><blockquote><p>自己设计某一个值会发生变化的堆</p></blockquote><pre><code class="hljs java"><span class="hljs-comment">// 堆</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyHeap</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;    <span class="hljs-comment">// 没有 T[], 动态数组实现</span>    <span class="hljs-keyword">private</span> ArrayList&lt;T&gt; heap;    <span class="hljs-comment">// 记录在堆上的位置</span>    <span class="hljs-keyword">private</span> HashMap&lt;T, Integer&gt; indexMap;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> heapSize;    <span class="hljs-keyword">private</span> Comparator&lt;? <span class="hljs-keyword">super</span> T&gt; comparator;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyHeap</span><span class="hljs-params">(Comparator&lt;? <span class="hljs-keyword">super</span> T&gt; com)</span> </span>&#123;        heap = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        indexMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        heapSize = <span class="hljs-number">0</span>;        comparator = com;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> heapSize == <span class="hljs-number">0</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> heapSize;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">contains</span><span class="hljs-params">(T key)</span> </span>&#123;        <span class="hljs-keyword">return</span> indexMap.containsKey(key);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(T value)</span> </span>&#123;        heap.add(value);        indexMap.put(value, heapSize);        heapInsert(heapSize++);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;        T ans = heap.get(<span class="hljs-number">0</span>);        <span class="hljs-keyword">int</span> end = heapSize - <span class="hljs-number">1</span>;        swap(<span class="hljs-number">0</span>, end);        heap.remove(end);        indexMap.remove(ans);        heapify(<span class="hljs-number">0</span>, --heapSize);        <span class="hljs-keyword">return</span> ans;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">resign</span><span class="hljs-params">(T value)</span> </span>&#123;        <span class="hljs-keyword">int</span> valueIndex = indexMap.get(value);        <span class="hljs-comment">// 只会中一个逻辑</span>        heapInsert(valueIndex);        heapify(valueIndex, heapSize);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">heapInsert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;        <span class="hljs-keyword">while</span> (comparator.compare(heap.get(index), heap.get((index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>)) &lt; <span class="hljs-number">0</span>) &#123;            swap(index, (index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>);            index = (index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">heapify</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> heapSize)</span> </span>&#123;        <span class="hljs-keyword">int</span> left = index * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (left &lt; heapSize) &#123;            <span class="hljs-keyword">int</span> largest = left + <span class="hljs-number">1</span> &lt; heapSize &amp;&amp; (comparator.compare(heap.get(left + <span class="hljs-number">1</span>), heap.get(left)) &lt; <span class="hljs-number">0</span>)                    ? left + <span class="hljs-number">1</span>                    : left;            largest = comparator.compare(heap.get(largest), heap.get(index)) &lt; <span class="hljs-number">0</span> ? largest : index;            <span class="hljs-keyword">if</span> (largest == index) &#123;                <span class="hljs-keyword">break</span>;            &#125;            swap(largest, index);            index = largest;            left = index * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;        T o1 = heap.get(i);        T o2 = heap.get(j);        heap.set(i, o2);        heap.set(j, o1);        indexMap.put(o1, j);        indexMap.put(o2, i);    &#125;&#125;</code></pre><h1 id="trie、桶排序、排序总结"><a href="#trie、桶排序、排序总结" class="headerlink" title="trie、桶排序、排序总结"></a>trie、桶排序、排序总结</h1><h2 id="前缀树"><a href="#前缀树" class="headerlink" title="前缀树"></a>前缀树</h2><p>1）单个字符串中，字符从前到后的加到一棵多叉树上<br>2）字符放在路上，节点上有专属的数据项（常见的是pass和end值）<br>3）所有样本都这样添加，如果没有路就新建，如有路就复用<br>4）沿途节点的pass值增加1，每个字符串结束时来到的节点end值增加1</p><p>可以完成前缀相关的查询</p><blockquote><p>例子</p></blockquote><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201207154038.png" alt="test1"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201207154211.png" alt="test2"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201207154255.png" alt="test3"></p><p>所有字符串字符数量为 <strong>N</strong>, </p><p>新建树代价为 <strong>O(N)</strong>, </p><p>可以找”ab”插入多少次(找ab顺下去b的e值)  <strong>O(N)</strong>, </p><p>或者以”a”为前缀的有多少个字符串(找a的p值)  <strong>O(N)</strong></p><blockquote><p>代码(方式一) <strong>固定数组实现</strong></p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node1</span> </span>&#123;   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> pass;   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> end;   <span class="hljs-keyword">public</span> Node1[] nexts;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node1</span><span class="hljs-params">()</span> </span>&#123;      pass = <span class="hljs-number">0</span>;      end = <span class="hljs-number">0</span>;      <span class="hljs-comment">// 如何标记存在与否</span>      <span class="hljs-comment">// nexts[0] -&gt; a</span>      <span class="hljs-comment">// nexts[1] -&gt; b</span>      <span class="hljs-comment">// ..     -&gt; ..</span>      <span class="hljs-comment">// nexts[25]-&gt; z</span>      <span class="hljs-comment">// nexts[i]== null, i方向的路不存在</span>      <span class="hljs-comment">// nexts[i]!= null, i方向的路存在</span>      nexts = <span class="hljs-keyword">new</span> Node1[<span class="hljs-number">26</span>];<span class="hljs-comment">// a — z</span>   &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Trie1</span> </span>&#123;   <span class="hljs-keyword">private</span> Node1 root;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Trie1</span><span class="hljs-params">()</span> </span>&#123;      root = <span class="hljs-keyword">new</span> Node1();   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(String word)</span> </span>&#123;      <span class="hljs-keyword">if</span> (word == <span class="hljs-keyword">null</span>) &#123;         <span class="hljs-keyword">return</span>;      &#125;      <span class="hljs-keyword">char</span>[] chs = word.toCharArray();      Node1 node = root;      node.pass++;      <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;<span class="hljs-comment">// 路</span>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; chs.length; i++) &#123; <span class="hljs-comment">// 从左往右遍历字符</span>         index = chs[i] - <span class="hljs-string">&#x27;a&#x27;</span>; <span class="hljs-comment">// 由字符，对应成走向哪条路</span>         <span class="hljs-keyword">if</span> (node.nexts[index] == <span class="hljs-keyword">null</span>) &#123;            node.nexts[index] = <span class="hljs-keyword">new</span> Node1();         &#125;         node = node.nexts[index];         node.pass++;      &#125;      node.end++;   &#125;   <span class="hljs-comment">// 沿途p--, 最后e--</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delete</span><span class="hljs-params">(String word)</span> </span>&#123;      <span class="hljs-keyword">if</span> (search(word) != <span class="hljs-number">0</span>) &#123;         <span class="hljs-keyword">char</span>[] chs = word.toCharArray();         Node1 node = root;         node.pass--;         <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;         <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; chs.length; i++) &#123;            index = chs[i] - <span class="hljs-string">&#x27;a&#x27;</span>;            <span class="hljs-comment">// 只要有p变成0，以后肯定都不会经过了</span>            <span class="hljs-keyword">if</span> (--node.nexts[index].pass == <span class="hljs-number">0</span>) &#123;               node.nexts[index] = <span class="hljs-keyword">null</span>;               <span class="hljs-comment">// 直接让jvm释放</span>               <span class="hljs-comment">// c++需要遍历后续手动释放</span>               <span class="hljs-keyword">return</span>;            &#125;            node = node.nexts[index];         &#125;         node.end--;      &#125;   &#125;   <span class="hljs-comment">// word这个单词之前加入过几次</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(String word)</span> </span>&#123;      <span class="hljs-keyword">if</span> (word == <span class="hljs-keyword">null</span>) &#123;         <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;      &#125;      <span class="hljs-keyword">char</span>[] chs = word.toCharArray();      Node1 node = root;      <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; chs.length; i++) &#123;         index = chs[i] - <span class="hljs-string">&#x27;a&#x27;</span>;         <span class="hljs-keyword">if</span> (node.nexts[index] == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;         &#125;         node = node.nexts[index];      &#125;      <span class="hljs-keyword">return</span> node.end;   &#125;   <span class="hljs-comment">// 所有加入的字符串中，有几个是以pre这个字符串作为前缀的</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">prefixNumber</span><span class="hljs-params">(String pre)</span> </span>&#123;      <span class="hljs-keyword">if</span> (pre == <span class="hljs-keyword">null</span>) &#123;         <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;      &#125;      <span class="hljs-keyword">char</span>[] chs = pre.toCharArray();      Node1 node = root;      <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; chs.length; i++) &#123;         index = chs[i] - <span class="hljs-string">&#x27;a&#x27;</span>;         <span class="hljs-keyword">if</span> (node.nexts[index] == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;         &#125;         node = node.nexts[index];      &#125;      <span class="hljs-keyword">return</span> node.pass;   &#125;&#125;</code></pre><blockquote><p>代码(方式二)  <strong>哈希表实现</strong>:字符种类变多!</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node2</span> </span>&#123;   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> pass;   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> end;   <span class="hljs-comment">// ASCII码值, 下一个结点</span>   <span class="hljs-keyword">public</span> HashMap&lt;Integer, Node2&gt; nexts;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node2</span><span class="hljs-params">()</span> </span>&#123;      pass = <span class="hljs-number">0</span>;      end = <span class="hljs-number">0</span>;      nexts = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();   &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Trie2</span> </span>&#123;   <span class="hljs-keyword">private</span> Node2 root;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Trie2</span><span class="hljs-params">()</span> </span>&#123;      root = <span class="hljs-keyword">new</span> Node2();   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(String word)</span> </span>&#123;      <span class="hljs-keyword">if</span> (word == <span class="hljs-keyword">null</span>) &#123;         <span class="hljs-keyword">return</span>;      &#125;      <span class="hljs-keyword">char</span>[] chs = word.toCharArray();      Node2 node = root;      node.pass++;      <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; chs.length; i++) &#123;         index = (<span class="hljs-keyword">int</span>) chs[i];         <span class="hljs-keyword">if</span> (!node.nexts.containsKey(index)) &#123;            node.nexts.put(index, <span class="hljs-keyword">new</span> Node2());         &#125;         node = node.nexts.get(index);         node.pass++;      &#125;      node.end++;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delete</span><span class="hljs-params">(String word)</span> </span>&#123;      <span class="hljs-keyword">if</span> (search(word) != <span class="hljs-number">0</span>) &#123;         <span class="hljs-keyword">char</span>[] chs = word.toCharArray();         Node2 node = root;         node.pass--;         <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;         <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; chs.length; i++) &#123;            index = (<span class="hljs-keyword">int</span>) chs[i];            <span class="hljs-keyword">if</span> (--node.nexts.get(index).pass == <span class="hljs-number">0</span>) &#123;               node.nexts.remove(index);               <span class="hljs-keyword">return</span>;            &#125;            node = node.nexts.get(index);         &#125;         node.end--;      &#125;   &#125;   <span class="hljs-comment">// word这个单词之前加入过几次</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(String word)</span> </span>&#123;      <span class="hljs-keyword">if</span> (word == <span class="hljs-keyword">null</span>) &#123;         <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;      &#125;      <span class="hljs-keyword">char</span>[] chs = word.toCharArray();      Node2 node = root;      <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; chs.length; i++) &#123;         index = (<span class="hljs-keyword">int</span>) chs[i];         <span class="hljs-keyword">if</span> (!node.nexts.containsKey(index)) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;         &#125;         node = node.nexts.get(index);      &#125;      <span class="hljs-keyword">return</span> node.end;   &#125;   <span class="hljs-comment">// 所有加入的字符串中，有几个是以pre这个字符串作为前缀的</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">prefixNumber</span><span class="hljs-params">(String pre)</span> </span>&#123;      <span class="hljs-keyword">if</span> (pre == <span class="hljs-keyword">null</span>) &#123;         <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;      &#125;      <span class="hljs-keyword">char</span>[] chs = pre.toCharArray();      Node2 node = root;      <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; chs.length; i++) &#123;         index = (<span class="hljs-keyword">int</span>) chs[i];         <span class="hljs-keyword">if</span> (!node.nexts.containsKey(index)) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;         &#125;         node = node.nexts.get(index);      &#125;      <span class="hljs-keyword">return</span> node.pass;   &#125;&#125;</code></pre><h2 id="不基于比较的排序"><a href="#不基于比较的排序" class="headerlink" title="不基于比较的排序"></a>不基于比较的排序</h2><p>桶排序思想下的排序：**计数排序 &amp; 基数排序 **</p><p>1)桶排序思想下的排序都是 <strong>不基于比较的排序</strong></p><ol start="2"><li><strong>时间复杂度为O(N)，额外空间负载度O(M)</strong>:无法确定</li></ol><p>3)应用范围有限， <strong>需要样本的数据状况</strong> 满足桶的划分,  <strong>强相关</strong></p><blockquote><p>区别</p></blockquote><p>1）一般来讲，计数排序要求，样本是 <strong>整数</strong>，且 <strong>范围比较窄</strong></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201207164502.png" alt="计数排序"></p><p>例子:[]里数据为年龄, 年龄不会超过200, 准备一个[0-200]的桶, 记录arr的数, 有就加一, 再遍历桶</p><p>2）一般来讲，基数排序要求，样本是 <strong>10进制的正整数</strong></p><p>例子:</p><p>[100,17,29,13,5,27]</p><p>找到最大值100, 补齐位数变成[100,017,029,013,005,027]</p><p>准备一个桶 0,1,2,3,4,5,6,7,8,9, 每一个桶 <strong>队列</strong>, 先进先出</p><p>[100,017,029,013,005,027]根据个位数入桶, 再倒出来, 由于队列, 先进先出</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201207165238.png" alt="第一次排序后"></p><p>再根据十位数字入桶, 再倒出来, 由于队列, 先进先出</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201207165457.png" alt="第二次后"></p><p>再根据百位数字入桶, 再倒出来, 由于队列, 先进先出</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201207165615.png" alt="第三次排序后"></p><p> <strong>一旦要求稍有升级，改写代价增加是显而易见的！</strong></p><h3 id="计数排序代码"><a href="#计数排序代码" class="headerlink" title="计数排序代码"></a>计数排序代码</h3><pre><code class="hljs JAVA"><span class="hljs-comment">// only for 0~200 value</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">countSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;   <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length &lt; <span class="hljs-number">2</span>) &#123;      <span class="hljs-keyword">return</span>;   &#125;   <span class="hljs-keyword">int</span> max = Integer.MIN_VALUE;   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;      max = Math.max(max, arr[i]);   &#125;   <span class="hljs-keyword">int</span>[] bucket = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[max + <span class="hljs-number">1</span>];   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;      bucket[arr[i]]++;   &#125;   <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; bucket.length; j++) &#123;      <span class="hljs-keyword">while</span> (bucket[j]-- &gt; <span class="hljs-number">0</span>) &#123;         arr[i++] = j;      &#125;   &#125;&#125;</code></pre><h3 id="基数排序代码-O-N-log10为底max"><a href="#基数排序代码-O-N-log10为底max" class="headerlink" title="基数排序代码 O(N*log10为底max)"></a>基数排序代码 O(N*log10为底max)</h3><pre><code class="hljs Java"><span class="hljs-comment">// only for no-negative value</span><span class="hljs-comment">// 非负</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">radixSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;   <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length &lt; <span class="hljs-number">2</span>) &#123;      <span class="hljs-keyword">return</span>;   &#125;   radixSort(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>, maxbits(arr));&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxbits</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;   <span class="hljs-keyword">int</span> max = Integer.MIN_VALUE;   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;      max = Math.max(max, arr[i]);   &#125;   <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;   <span class="hljs-keyword">while</span> (max != <span class="hljs-number">0</span>) &#123;      res++;      max /= <span class="hljs-number">10</span>;   &#125;   <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-comment">// arr[l..r]排序  ,  digit(最大值位数)</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">radixSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R, <span class="hljs-keyword">int</span> digit)</span> </span>&#123;   <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> radix = <span class="hljs-number">10</span>; <span class="hljs-comment">// 以十为基底</span>   <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;   <span class="hljs-comment">// 有多少个数准备多少个辅助空间</span>   <span class="hljs-keyword">int</span>[] help = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[R - L + <span class="hljs-number">1</span>];   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> d = <span class="hljs-number">1</span>; d &lt;= digit; d++) &#123; <span class="hljs-comment">// 有多少位就进出几次</span>      <span class="hljs-comment">// 10个空间</span>       <span class="hljs-comment">// count[0] 当前位(d位)是0的数字有多少个</span>      <span class="hljs-comment">// count[1] 当前位(d位)是(0和1)的数字有多少个</span>      <span class="hljs-comment">// count[2] 当前位(d位)是(0、1和2)的数字有多少个</span>      <span class="hljs-comment">// count[i] 当前位(d位)是(0~i)的数字有多少个</span>      <span class="hljs-keyword">int</span>[] count = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[radix]; <span class="hljs-comment">// count[0..9]</span>      <span class="hljs-keyword">for</span> (i = L; i &lt;= R; i++) &#123;         <span class="hljs-comment">// 取出Digit位数上的数 </span>         <span class="hljs-comment">// 103 1 3</span>         <span class="hljs-comment">// 202 1 2</span>         j = getDigit(arr[i], d);         count[j]++;      &#125;      <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; radix; i++) &#123;         <span class="hljs-comment">// count自己变成count&#x27;</span>         count[i] = count[i] + count[i - <span class="hljs-number">1</span>];      &#125;      <span class="hljs-keyword">for</span> (i = R; i &gt;= L; i--) &#123;         j = getDigit(arr[i], d);         help[count[j] - <span class="hljs-number">1</span>] = arr[i];         count[j]--;      &#125;      <span class="hljs-keyword">for</span> (i = L, j = <span class="hljs-number">0</span>; i &lt;= R; i++, j++) &#123;         arr[i] = help[j];      &#125;   &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getDigit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> d)</span> </span>&#123;   <span class="hljs-keyword">return</span> ((x / ((<span class="hljs-keyword">int</span>) Math.pow(<span class="hljs-number">10</span>, d - <span class="hljs-number">1</span>))) % <span class="hljs-number">10</span>);&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201207172931.png" alt="基数排序解析"></p><p>准备count数组为10长度，下标0 - 9</p><p>先对比个位数大小，分别放入对应count数组，count转化为count’词频数组，代表小于等于索引i的数有多少个</p><p>再从 <strong>右往左遍历</strong>数组（正常来说从左往右时302应该在队列末尾最后出队），开辟最大个数（小于等于9的数字有五个）的help数组，从右往左遍历时候302个位下标为2，小于等于2的有四个，所以可能放在第0 - 第3个数字，但因为从右往左遍历，302应该在2号桶最后倒出来， 所以302放help[3]，count’的词频减1，41应该在1号桶最后倒出来，个位数小于等于1有两个，所以放help[1]，202放剩下的2最后，小于等于2变成三个，所以help[2]….</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201207173538.png" alt="只用数组模拟入桶出桶行为"></p><h1 id="排序算法的稳定性及总结"><a href="#排序算法的稳定性及总结" class="headerlink" title="排序算法的稳定性及总结"></a>排序算法的稳定性及总结</h1><h2 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h2><p>稳定性是指同样大小的样本再 <strong>排序之后不会改变相对次序</strong></p><ul><li>第一个1还在第一个, 第二个2还在第二个</li></ul><p>对 <strong>基础类型</strong> 来说，稳定性毫无意义</p><ul><li>不用区分是第几个1</li></ul><p>对 <strong>非基础类型</strong> (引用)来说，稳定性有重要意义</p><ul><li>班级号、年龄的学生类，第一回按照所有学生年龄从小到大排序，基于此再按照班级号从小到大排序</li><li>如果 <strong>具有稳定性</strong> : [一班年纪小, 一班年纪大, 二班年纪小, 三班年纪大…]</li><li>即可选择 价格最低和好评最高 -&gt; 物美价廉</li></ul><p>有些排序算法可以实现成稳定的，而有些排序算法无论如何都实现不成稳定的</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​             时间复杂度 额外空间复杂度   稳定性<br>选择排序    O(N^2)          O(1)            无<br>冒泡排序    O(N^2)          O(1)            有<br>插入排序    O(N^2)          O(1)            有<br>归并排序    O(NlogN)         O(N)           有<br>随机快排    O(NlogN)         O(logN)        无<br>堆排序      O(NlogN)        O(1)           无<br>= = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =<br>计数排序    O(N)      O(M)    有<br>基数排序    O(N)      O(N)    有</p><ul><li><p><strong>选择排序</strong> 问题</p><p>[5,5,5,5,1,5,5,5,5] 直接第一个5位置放到1位置交换，5位置被破坏</p></li><li><p><strong>冒泡排序</strong> </p><p>相等时候不交换，稳定性就不会被破坏</p></li><li><p><strong>插入排序</strong> </p><p>面对相等时，不替换，稳定性也不会被破坏</p></li><li><p><strong>归并排序</strong></p><p>面对相等时，先拷贝左边的，稳定性也不会被破坏</p><p>但如果解决逆序对等问题先拷贝右边则会出现问题</p></li><li><p><strong>随机快排</strong></p><p>Partition过程无法做稳定</p><p>小于等于区下一个数交换，交换的会是等于区的数字，数字的位置就会被破坏</p></li><li><p><strong>堆排序</strong></p><p>变成大根堆的时候, 3，3，3，3遇到4后有很多个3的位置会改变</p></li></ul><blockquote><p>总结</p></blockquote><pre><code class="hljs mathematica"><span class="hljs-number">1</span>）不基于比较的排序，对样本数据有严格要求，不易改写<span class="hljs-number">2</span>）基于比较的排序，只要规定好两个样本怎么比大小就可以直接复用<span class="hljs-number">3</span>）基于比较的排序，时间复杂度的极限是<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-operator">*</span><span class="hljs-variable">logN</span><span class="hljs-punctuation">)</span><span class="hljs-number">4</span>）时间复杂度<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-operator">*</span><span class="hljs-variable">logN</span><span class="hljs-punctuation">)</span>、额外空间复杂度低于<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-punctuation">)</span>、且稳定的基于比较的排序是不存在的。<span class="hljs-number">5</span>）为了绝对的速度选快排（常数时间最少）、为了省空间选堆排、为了稳定性选归并</code></pre><h2 id="常见的坑"><a href="#常见的坑" class="headerlink" title="常见的坑"></a>常见的坑</h2><ul><li>归并排序的额外空间复杂度可以变成O(1)，“ <strong>归并排序 内部缓存法</strong> ”，但是将变得 <strong>不再稳定</strong>。</li><li>“ <strong>原地归并排序</strong> “ 是垃圾贴，会让时间复杂度变成O(N^2) </li><li>快速排序稳定性改进，“01 stable sort”，但是会对 <strong>样本数据要求更多</strong>。</li></ul><ul><li><p>在整型数组中，请把奇数放在数组左边，偶数放在数组右边，要求所有奇数之间原始的相对次序不变，所有偶数之间原始相对次序不变。</p><p>要求：时间复杂度做到O(N)，额外空间复杂度做到O(1)</p><p>**这是一个 0,1标准的Partition **(原始小于等于和大于分界，此问题奇数偶数分界), 而Partition过程无法做到稳定性</p></li></ul><p>系统函数：先反射，判定是引用传递还是值传递，引用归并，值传递快排</p><h1 id="链表问题"><a href="#链表问题" class="headerlink" title="链表问题"></a>链表问题</h1><blockquote><p> 面试时链表解题的 <strong>方法论</strong></p></blockquote><p>1)对于笔试，不用太在乎空间复杂度，一切为了时间复杂度</p><p>2)对于面试，时间复杂度依然放在第一位，但是一定要找到空间最省的方法</p><h2 id="链表面试题常用数据结构和技巧"><a href="#链表面试题常用数据结构和技巧" class="headerlink" title="链表面试题常用数据结构和技巧"></a>链表面试题常用数据结构和技巧</h2><p>1）使用容器(哈希表、数组等)</p><p>2）快慢指针 </p><h2 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h2><p>1）输入链表头节点，奇数长度返回中点，偶数长度返回上中点</p><p>1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt;5 找到3, 1 -&gt; 2 -&gt; 3 -&gt; 4  找到2</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">midOrUpMidNode</span><span class="hljs-params">(Node head)</span> </span>&#123;   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span> || head.next == <span class="hljs-keyword">null</span> || head.next.next == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span> head;   &#125;   <span class="hljs-comment">// 链表 &gt;= 三个结点</span>   Node slow = head.next;   Node fast = head.next.next;   <span class="hljs-keyword">while</span> (fast.next != <span class="hljs-keyword">null</span> &amp;&amp; fast.next.next != <span class="hljs-keyword">null</span>) &#123;      slow = slow.next;      fast = fast.next.next;   &#125;   <span class="hljs-keyword">return</span> slow;&#125;</code></pre><p>2）输入链表头节点，奇数长度返回中点，偶数长度返回下中点</p><p>1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt;5 找到3,  1 -&gt; 2 -&gt; 3 -&gt; 4  找到3</p><p>3）输入链表头节点，奇数长度返回中点前一个，偶数长度返回上中点前一个</p><p>4）输入链表头节点，奇数长度返回中点前一个，偶数长度返回下中点前一个</p><h2 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h2><h3 id="给定一个单链表的头节点head，请判断该链表是否为回文结构。"><a href="#给定一个单链表的头节点head，请判断该链表是否为回文结构。" class="headerlink" title="给定一个单链表的头节点head，请判断该链表是否为回文结构。"></a>给定一个单链表的头节点head，请判断该链表是否为回文结构。</h3><p>1）栈方法特别简单（笔试用）</p><ul><li><p><strong>栈实现</strong></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201208150841.png" alt="栈"></p><p>把链表value全放栈中，再弹出一个一个对比。</p><p>Code:</p><pre><code class="hljs java"><span class="hljs-comment">// need n extra space</span><span class="hljs-comment">// stack</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPalindrome1</span><span class="hljs-params">(Node head)</span> </span>&#123;   Stack&lt;Node&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;Node&gt;();   Node cur = head;   <span class="hljs-keyword">while</span> (cur != <span class="hljs-keyword">null</span>) &#123;      stack.push(cur);      cur = cur.next;   &#125;   <span class="hljs-keyword">while</span> (head != <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">if</span> (head.value != stack.pop().value) &#123;         <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;      &#125;      head = head.next;   &#125;   <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;&#125;</code></pre></li><li><p><strong>栈实现2</strong></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201208151246.png" alt="快慢指针定位"></p><p>快慢指针定位到中点的位置, 奇数唯一中点偶数上中点, 把右半部分加到栈中, 弹出与head一一对比</p><pre><code class="hljs java"><span class="hljs-comment">// need n/2 extra space</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPalindrome2</span><span class="hljs-params">(Node head)</span> </span>&#123;   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span> || head.next == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;   &#125;   Node right = head.next;   Node cur = head;   <span class="hljs-keyword">while</span> (cur.next != <span class="hljs-keyword">null</span> &amp;&amp; cur.next.next != <span class="hljs-keyword">null</span>) &#123;      right = right.next;      cur = cur.next.next;   &#125;   Stack&lt;Node&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;Node&gt;();   <span class="hljs-keyword">while</span> (right != <span class="hljs-keyword">null</span>) &#123;      stack.push(right);      right = right.next;   &#125;   <span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;      <span class="hljs-keyword">if</span> (head.value != stack.pop().value) &#123;         <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;      &#125;      head = head.next;   &#125;   <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;&#125;</code></pre></li></ul><p>2）改原链表的方法就需要注意边界了（面试用）</p><p>​ <img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201208151959.png" alt="原链表"></p><p>变化为-&gt;</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201208152030.png" alt="变化后"></p><p>再L与R对比, 直到比到S, 最后再变回链表位置即可。</p><p>这样的 <strong>额外空间复杂度为 O(1);</strong></p><p>code:</p><pre><code class="hljs java"><span class="hljs-comment">// need O(1) extra space</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPalindrome3</span><span class="hljs-params">(Node head)</span> </span>&#123;   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span> || head.next == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;   &#125;   Node n1 = head; <span class="hljs-comment">// slow</span>   Node n2 = head; <span class="hljs-comment">// fast</span>   <span class="hljs-keyword">while</span> (n2.next != <span class="hljs-keyword">null</span> &amp;&amp; n2.next.next != <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// find mid node</span>      n1 = n1.next; <span class="hljs-comment">// n1 -&gt; mid</span>      n2 = n2.next.next; <span class="hljs-comment">// n2 -&gt; end</span>   &#125;   n2 = n1.next; <span class="hljs-comment">// n2 -&gt; right part first node</span>   n1.next = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// mid.next -&gt; null</span>   Node n3 = <span class="hljs-keyword">null</span>;   <span class="hljs-keyword">while</span> (n2 != <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// right part convert</span>      n3 = n2.next; <span class="hljs-comment">// n3 -&gt; save next node</span>      n2.next = n1; <span class="hljs-comment">// next of right node convert</span>      n1 = n2; <span class="hljs-comment">// n1 move</span>      n2 = n3; <span class="hljs-comment">// n2 move</span>   &#125;   n3 = n1; <span class="hljs-comment">// n3 -&gt; save last node</span>   n2 = head;<span class="hljs-comment">// n2 -&gt; left first node</span>   <span class="hljs-keyword">boolean</span> res = <span class="hljs-keyword">true</span>;   <span class="hljs-keyword">while</span> (n1 != <span class="hljs-keyword">null</span> &amp;&amp; n2 != <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// check palindrome</span>      <span class="hljs-keyword">if</span> (n1.value != n2.value) &#123;         res = <span class="hljs-keyword">false</span>;         <span class="hljs-keyword">break</span>;      &#125;      n1 = n1.next; <span class="hljs-comment">// left to mid</span>      n2 = n2.next; <span class="hljs-comment">// right to mid</span>   &#125;   n1 = n3.next;   n3.next = <span class="hljs-keyword">null</span>;   <span class="hljs-keyword">while</span> (n1 != <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// recover list</span>      n2 = n1.next;      n1.next = n3;      n3 = n1;      n1 = n2;   &#125;   <span class="hljs-keyword">return</span> res;&#125;</code></pre><h3 id="将单向链表按某值划分成左边小、中间相等、右边大的形式"><a href="#将单向链表按某值划分成左边小、中间相等、右边大的形式" class="headerlink" title="将单向链表按某值划分成左边小、中间相等、右边大的形式"></a>将单向链表按某值划分成左边小、中间相等、右边大的形式</h3><p>1）把链表放入数组里，在数组上做partition（笔试用）( <strong>不稳定</strong> )</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">listPartition1</span><span class="hljs-params">(Node head, <span class="hljs-keyword">int</span> pivot)</span> </span>&#123;   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span> head;   &#125;   Node cur = head;   <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;   <span class="hljs-keyword">while</span> (cur != <span class="hljs-keyword">null</span>) &#123;      i++;      cur = cur.next;   &#125;   Node[] nodeArr = <span class="hljs-keyword">new</span> Node[i];   i = <span class="hljs-number">0</span>;   cur = head;   <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i != nodeArr.length; i++) &#123;      nodeArr[i] = cur;      cur = cur.next;   &#125;   arrPartition(nodeArr, pivot);   <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i != nodeArr.length; i++) &#123;      nodeArr[i - <span class="hljs-number">1</span>].next = nodeArr[i];   &#125;   nodeArr[i - <span class="hljs-number">1</span>].next = <span class="hljs-keyword">null</span>;   <span class="hljs-keyword">return</span> nodeArr[<span class="hljs-number">0</span>];&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">arrPartition</span><span class="hljs-params">(Node[] nodeArr, <span class="hljs-keyword">int</span> pivot)</span> </span>&#123;   <span class="hljs-keyword">int</span> small = -<span class="hljs-number">1</span>;   <span class="hljs-keyword">int</span> big = nodeArr.length;   <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;   <span class="hljs-keyword">while</span> (index != big) &#123;      <span class="hljs-keyword">if</span> (nodeArr[index].value &lt; pivot) &#123;         swap(nodeArr, ++small, index++);      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nodeArr[index].value == pivot) &#123;         index++;      &#125; <span class="hljs-keyword">else</span> &#123;         swap(nodeArr, --big, index);      &#125;   &#125;&#125;</code></pre><p>2）分成小、中、大三部分，再把各个部分之间串起来（面试用）</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201208161643.png" alt="六个变量"></p><p>设置六个变量，分别为小于区头尾结点，大于区头尾结点，等于区头尾结点。</p><p>依次遍历，例如遍历4结点，bH、bT = 4，4结点断开。2也是，发至sH和sT=2，3发至eH和eT=3。</p><p>来到5时，要发到大于区，5串到4下面，bH=4，让bT指向5但5变成bT。</p><p>来到6时，bT指向6并让bT找到6的位置。</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201208162538.png" alt="流程"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201208162652.png" alt="流程2"></p><p>每一步O(1),整体O(N); 且是 <strong>稳定的</strong></p><p>code:</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">listPartition2</span><span class="hljs-params">(Node head, <span class="hljs-keyword">int</span> pivot)</span> </span>&#123;   Node sH = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// small head</span>   Node sT = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// small tail</span>   Node eH = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// equal head</span>   Node eT = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// equal tail</span>   Node mH = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// big head</span>   Node mT = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// big tail</span>   Node next = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// save next node</span>   <span class="hljs-comment">// every node distributed to three lists</span>   <span class="hljs-keyword">while</span> (head != <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-comment">// 记录head.next 后面结点next是要销毁的</span>      next = head.next;      head.next = <span class="hljs-keyword">null</span>;      <span class="hljs-keyword">if</span> (head.value &lt; pivot) &#123;         <span class="hljs-keyword">if</span> (sH == <span class="hljs-keyword">null</span>) &#123;            sH = head;            sT = head;         &#125; <span class="hljs-keyword">else</span> &#123;            sT.next = head;            sT = head;         &#125;      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (head.value == pivot) &#123;         <span class="hljs-keyword">if</span> (eH == <span class="hljs-keyword">null</span>) &#123;            eH = head;            eT = head;         &#125; <span class="hljs-keyword">else</span> &#123;            eT.next = head;            eT = head;         &#125;      &#125; <span class="hljs-keyword">else</span> &#123;         <span class="hljs-keyword">if</span> (mH == <span class="hljs-keyword">null</span>) &#123;            mH = head;            mT = head;         &#125; <span class="hljs-keyword">else</span> &#123;            mT.next = head;            mT = head;         &#125;      &#125;      head = next;   &#125;   <span class="hljs-comment">// small and equal reconnect</span>   <span class="hljs-keyword">if</span> (sT != <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// 如果有小于区域</span>      sT.next = eH;      eT = eT == <span class="hljs-keyword">null</span> ? sT : eT; <span class="hljs-comment">// 下一步，谁去连大于区域的头，谁就变成eT</span>   &#125;   <span class="hljs-comment">// 上面的if，不管跑了没有，et</span>   <span class="hljs-comment">// all reconnect</span>   <span class="hljs-keyword">if</span> (eT != <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// 如果小于区域和等于区域，不是都没有</span>      eT.next = mH;   &#125;   <span class="hljs-keyword">return</span> sH != <span class="hljs-keyword">null</span> ? sH : (eH != <span class="hljs-keyword">null</span> ? eH : mH);&#125;</code></pre><h3 id="一种特殊的单链表节点类-random"><a href="#一种特殊的单链表节点类-random" class="headerlink" title="一种特殊的单链表节点类 random"></a>一种特殊的单链表节点类 random</h3><blockquote><p> 一种特殊的单链表节点类描述如下</p></blockquote><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123; <span class="hljs-keyword">int</span> value; Node next; Node rand; Node(<span class="hljs-keyword">int</span> val) &#123; value = val; &#125; &#125;</code></pre><p>rand指针是单链表节点结构中新增的指针，rand可能指向链表中的任意一个节点，也可能指向null。<br>给定一个由Node节点类型组成的无环单链表的头节点 head，请实现一个函数完成这个链表的复制，并返回复制的新链表的头节点。<br> <strong>【要求】</strong><br> **时间复杂度O(N)，额外空间复杂度O(1) **</p><ul><li><p>哈希表</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">copyListWithRand1</span><span class="hljs-params">(Node head)</span> </span>&#123;   HashMap&lt;Node, Node&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;Node, Node&gt;();   Node cur = head;   <span class="hljs-keyword">while</span> (cur != <span class="hljs-keyword">null</span>) &#123;      map.put(cur, <span class="hljs-keyword">new</span> Node(cur.value));      cur = cur.next;   &#125;   cur = head;   <span class="hljs-keyword">while</span> (cur != <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-comment">// cur 老          (key)</span>      <span class="hljs-comment">// map.get(cur) 新 (value)</span>      map.get(cur).next = map.get(cur.next);      map.get(cur).rand = map.get(cur.rand);      cur = cur.next;   &#125;   <span class="hljs-keyword">return</span> map.get(head);&#125;</code></pre></li></ul><ul><li><p>不用哈希表</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201208175756.png" alt="克隆, 放置后面"></p><p>一次拿出一对:</p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201208175936.png" alt="如何克隆？" style="zoom:50%;" /></li></ul><p>  我们通过1找到1的random 3，又因为3’就在3后面，所以可以直接3.next找到并与1’连接</p><p>  最后分离</p><p>  code:</p>  <pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">copyListWithRand2</span><span class="hljs-params">(Node head)</span> </span>&#123;   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;   &#125;   Node cur = head;   Node next = <span class="hljs-keyword">null</span>;   <span class="hljs-comment">// copy node and link to every node</span>   <span class="hljs-comment">// 1 -&gt; 2</span>   <span class="hljs-comment">// 1 -&gt; 1&#x27; -&gt; 2</span>   <span class="hljs-keyword">while</span> (cur != <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-comment">// cur 老</span>      <span class="hljs-comment">// next表示 老 的下一个</span>      next = cur.next;      cur.next = <span class="hljs-keyword">new</span> Node(cur.value);      cur.next.next = next;      cur = next;   &#125;   cur = head;   Node curCopy = <span class="hljs-keyword">null</span>;   <span class="hljs-comment">// set copy node rand</span>   <span class="hljs-comment">// 1 -&gt; 1&#x27; -&gt; 2 -&gt; 2&#x27;</span>   <span class="hljs-keyword">while</span> (cur != <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-comment">// cur 老</span>      <span class="hljs-comment">// cur.next  新 copy</span>      next = cur.next.next;      curCopy = cur.next;      <span class="hljs-comment">// 老的rand的下一个(插入进来的)</span>      curCopy.rand = cur.rand != <span class="hljs-keyword">null</span> ? cur.rand.next : <span class="hljs-keyword">null</span>;      cur = next;   &#125;   Node res = head.next;   cur = head;   <span class="hljs-comment">// split</span>   <span class="hljs-keyword">while</span> (cur != <span class="hljs-keyword">null</span>) &#123;      next = cur.next.next;      curCopy = cur.next;      cur.next = next;      curCopy.next = next != <span class="hljs-keyword">null</span> ? next.next : <span class="hljs-keyword">null</span>;      cur = next;   &#125;   <span class="hljs-keyword">return</span> res;&#125;</code></pre><p>  不能边设置边断链： <strong>如果后面指向前面，前面已经和自己的 ‘ 断连了，.next已经没有用</strong></p><h3 id="与约瑟夫环问题相同的噩梦（相交）"><a href="#与约瑟夫环问题相同的噩梦（相交）" class="headerlink" title="与约瑟夫环问题相同的噩梦（相交）"></a>与约瑟夫环问题相同的噩梦（相交）</h3><p>给定两个可能有环也可能无环的单链表，头节点head1和head2。请实现一个函数，如果两个链表相交，请返回相交的 第一个节点。如果不相交，返回null </p><p>相交就是地址共用相同部分！</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201208182234.png" alt="相交"></p><p>【要求】<br> <strong>如果两个链表长度之和为N，时间复杂度请达到O(N)，额外空间复杂度 请达到O(1)。</strong></p><blockquote><p>先设计 Node f(head) 返回 <strong>入环第一个结点</strong></p></blockquote><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201208182419.png" alt="入环结点" style="zoom:50%;" /><p>如果整个是环，就是head</p><p> <strong>一个链表只有一个next指针，进了环，是不能出来的。</strong></p><p>可以用set<Node> 先查有没有在set里，查到第一个在的就是入环结点，没有环一定走到空上。</p><ul><li><p>不用set:</p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201208183357.png" alt="流程" style="zoom:50%;" /><p>一开始slow和fast指针从head开始出发，slow走一步，fast走两步；</p><p>一直这样走下去，slow和fast一定会在同一个地方，当到达同一个地方时： <strong>证明一定有环</strong></p><p>slow不变位置，fast回到开头，fast变成一次走一步，slow也继续一次走一步，</p><p>当slow和fast再次相交时，这个点就是 <strong>第一个入环点</strong>。</p><p>code：</p><pre><code class="hljs java"><span class="hljs-comment">// 找到链表第一个入环节点，如果无环，返回null</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">getLoopNode</span><span class="hljs-params">(Node head)</span> </span>&#123;   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span> || head.next == <span class="hljs-keyword">null</span> || head.next.next == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;   &#125;   <span class="hljs-comment">// n1 慢  n2 快</span>   Node n1 = head.next; <span class="hljs-comment">// n1 -&gt; slow</span>   Node n2 = head.next.next; <span class="hljs-comment">// n2 -&gt; fast</span>   <span class="hljs-keyword">while</span> (n1 != n2) &#123;      <span class="hljs-keyword">if</span> (n2.next == <span class="hljs-keyword">null</span> || n2.next.next == <span class="hljs-keyword">null</span>) &#123;         <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;      &#125;      n2 = n2.next.next;      n1 = n1.next;   &#125;   n2 = head; <span class="hljs-comment">// n2 -&gt; walk again from head</span>   <span class="hljs-keyword">while</span> (n1 != n2) &#123;      n1 = n1.next;      n2 = n2.next;   &#125;   <span class="hljs-keyword">return</span> n1;&#125;</code></pre></li></ul><blockquote><p>问题解决</p></blockquote><ol><li>如果 <strong>两个无环链表相交</strong>，相交后为全部相交部分。</li></ol><ul><li><p>用set</p><p>把一个链表全部注册进去，对第二个链表逐步遍历直到找到第一个相交。</p></li><li><p>不用set</p><p>假设第一个链表100个，第二个链表80个，两个都找到其最后一个结点（即下一个结点为null的结点），分别为end1和end2。</p><ul><li>判断 end1 是否等于 end2 ，如果不等于， 不相交。</li><li>如果 end1 等于 end2， 链表1走（100-80）= 20步，从这里开始链表二也开始走，两个链表肯定会走到第一个相遇的地方。</li></ul><p>Code:</p><pre><code class="hljs java"><span class="hljs-comment">// 如果两个链表都无环，返回第一个相交节点，如果不想交，返回null</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">noLoop</span><span class="hljs-params">(Node head1, Node head2)</span> </span>&#123;   <span class="hljs-keyword">if</span> (head1 == <span class="hljs-keyword">null</span> || head2 == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;   &#125;   Node cur1 = head1;   Node cur2 = head2;   <span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>;   <span class="hljs-keyword">while</span> (cur1.next != <span class="hljs-keyword">null</span>) &#123;      n++;      cur1 = cur1.next;   &#125;   <span class="hljs-keyword">while</span> (cur2.next != <span class="hljs-keyword">null</span>) &#123;      n--;      cur2 = cur2.next;   &#125;   <span class="hljs-comment">// n = cur1.len - cur2.len</span>   <span class="hljs-keyword">if</span> (cur1 != cur2) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;   &#125;   <span class="hljs-comment">// n  :  链表1长度减去链表2长度的值</span>   cur1 = n &gt; <span class="hljs-number">0</span> ? head1 : head2; <span class="hljs-comment">// 谁长，谁的头变成cur1</span>   cur2 = cur1 == head1 ? head2 : head1; <span class="hljs-comment">// 谁短，谁的头变成cur2</span>   n = Math.abs(n);   <span class="hljs-comment">// 长链表先走</span>   <span class="hljs-keyword">while</span> (n != <span class="hljs-number">0</span>) &#123;      n--;      cur1 = cur1.next;   &#125;   <span class="hljs-comment">// 一起走 走到相交点</span>   <span class="hljs-keyword">while</span> (cur1 != cur2) &#123;      cur1 = cur1.next;      cur2 = cur2.next;   &#125;   <span class="hljs-keyword">return</span> cur1;&#125;</code></pre></li></ul><ol start="2"><li>如果 <strong>两个有环链表相交</strong>，一定是 <strong>共用这个环的</strong></li></ol><p>​ <img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201208190644.png" alt="三种情况"></p><ul><li>没有相交部分<ul><li>让loop1往下走，如果在 <strong>遇见自己之前一直没碰到loop2</strong>。</li></ul></li><li>入环结点相同<ul><li>loop1和loop2不等于空且相同</li><li>不用再看环，把入环点作为尾结点，就变成了两个无环单链表相交问题</li></ul></li><li>入环结点不同<ul><li> 让loop1往下走，如果在 <strong>遇见自己之前一直碰到了loop2</strong>。</li></ul></li></ul><ol start="3"><li>如果 <strong>一个有环一个无环</strong>， <strong>不可能相交</strong>。</li></ol><p>​ 因为是单链表。</p><pre><code class="hljs java"><span class="hljs-comment">// 两个有环链表，返回第一个相交节点，如果不想交返回null</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">bothLoop</span><span class="hljs-params">(Node head1, Node loop1, Node head2, Node loop2)</span> </span>&#123;   Node cur1 = <span class="hljs-keyword">null</span>;   Node cur2 = <span class="hljs-keyword">null</span>;   <span class="hljs-keyword">if</span> (loop1 == loop2) &#123;      <span class="hljs-comment">// 解决无环问题，只不过end变为loop</span>      cur1 = head1;      cur2 = head2;      <span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>;      <span class="hljs-keyword">while</span> (cur1 != loop1) &#123;         n++;         cur1 = cur1.next;      &#125;      <span class="hljs-keyword">while</span> (cur2 != loop2) &#123;         n--;         cur2 = cur2.next;      &#125;      cur1 = n &gt; <span class="hljs-number">0</span> ? head1 : head2;      cur2 = cur1 == head1 ? head2 : head1;      n = Math.abs(n);      <span class="hljs-keyword">while</span> (n != <span class="hljs-number">0</span>) &#123;         n--;         cur1 = cur1.next;      &#125;      <span class="hljs-keyword">while</span> (cur1 != cur2) &#123;         cur1 = cur1.next;         cur2 = cur2.next;      &#125;      <span class="hljs-keyword">return</span> cur1;   &#125; <span class="hljs-keyword">else</span> &#123;      cur1 = loop1.next;      <span class="hljs-keyword">while</span> (cur1 != loop1) &#123;         <span class="hljs-keyword">if</span> (cur1 == loop2) &#123;            <span class="hljs-keyword">return</span> loop1;         &#125;         cur1 = cur1.next;      &#125;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;   &#125;&#125;</code></pre><p>最后总结：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">getIntersectNode</span><span class="hljs-params">(Node head1, Node head2)</span> </span>&#123;   <span class="hljs-keyword">if</span> (head1 == <span class="hljs-keyword">null</span> || head2 == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;   &#125;   Node loop1 = getLoopNode(head1);   Node loop2 = getLoopNode(head2);   <span class="hljs-keyword">if</span> (loop1 == <span class="hljs-keyword">null</span> &amp;&amp; loop2 == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span> noLoop(head1, head2);   &#125;   <span class="hljs-keyword">if</span> (loop1 != <span class="hljs-keyword">null</span> &amp;&amp; loop2 != <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span> bothLoop(head1, loop1, head2, loop2);   &#125;   <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;</code></pre><h3 id="能不能不给单链表的头节点，只给想要删除的节点，就能做到在链表上把这个点删掉？"><a href="#能不能不给单链表的头节点，只给想要删除的节点，就能做到在链表上把这个点删掉？" class="headerlink" title="能不能不给单链表的头节点，只给想要删除的节点，就能做到在链表上把这个点删掉？"></a>能不能不给单链表的头节点，只给想要删除的节点，就能做到在链表上把这个点删掉？</h3><p>把下一个值赋给当前结点，当前结点跳到下下个。</p><p>1）但 <strong>实际上没有删除 “自己”，只是替代了内容！</strong></p><p>2）如果不再是简单的结点问题，而是服务器问题， <strong>拷贝</strong>会变成一件很困难的事情！</p><p>3） <strong>绝对无法删除链表最后一个结点的！</strong>没有办法改前一个结点的走向。NULL是一个特定系统区域，去调析构函数是没有用的！</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201208192831.png" alt="test代码"></p><blockquote><p>为什么不行？</p></blockquote><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201208192918.png" alt="原因"></p><p>c = null;只是让c没有指向Node(3), 但Node(2)还是指向Node(3)了！</p><h1 id="二叉树的基本算法"><a href="#二叉树的基本算法" class="headerlink" title="二叉树的基本算法"></a>二叉树的基本算法</h1><blockquote><p>结构描述：</p></blockquote><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;  V value;  Node left;  Node right;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> value;   <span class="hljs-keyword">public</span> Node left;   <span class="hljs-keyword">public</span> Node right;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v)</span> </span>&#123;      value = v;   &#125;&#125;</code></pre><h2 id="二叉树的先序、中序、后序遍历"><a href="#二叉树的先序、中序、后序遍历" class="headerlink" title="二叉树的先序、中序、后序遍历"></a>二叉树的先序、中序、后序遍历</h2><p>​ <img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201209164047.png" alt="如图"></p><ul><li><p>先序：任何子树的处理顺序都是，先头节点、再左子树、然后右子树</p><pre><code class="hljs java"><span class="hljs-comment">// 先序打印所有结点</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pre</span><span class="hljs-params">(Node head)</span> </span>&#123;   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span>;   &#125;   System.out.println(head.value);   pre(head.left);   pre(head.right);&#125;</code></pre><p>​ </p></li><li><p>中序：任何子树的处理顺序都是，先左子树、再头节点、然后右子树</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">in</span><span class="hljs-params">(Node head)</span> </span>&#123;   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span>;   &#125;   in(head.left);   System.out.println(head.value);   in(head.right);&#125;</code></pre></li></ul><ul><li><p>后序：任何子树的处理顺序都是，先左子树、再右子树、然后头节点</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pos</span><span class="hljs-params">(Node head)</span> </span>&#123;   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span>;   &#125;   pos(head.left);   pos(head.right);   System.out.println(head.value);&#125;</code></pre></li></ul><h3 id="递归的本质是-递归序"><a href="#递归的本质是-递归序" class="headerlink" title="递归的本质是  递归序"></a>递归的本质是  <strong>递归序</strong></h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201209170646.png" alt="流程"></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(Node head)</span> </span>&#123;   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span>;   &#125;   <span class="hljs-comment">// 先序</span>   f(head.left);   <span class="hljs-comment">// 中序</span>   f(head.right);   <span class="hljs-comment">// 后序</span>&#125;</code></pre><p>对于这样的代码，一定会 <strong>访问(返回)</strong> 三次：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201209170852.png" alt="每一个结点都会到达三次"></p><p>先序就是每一次第一次到达了就打印：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201209171028.png" alt="第一次到达打印就是先序"></p><p>先序，中序，后序只是 <strong>递归序的结果</strong>。</p><p>所以在树上做动态规划的前提就是 <strong>每一个结点都会到此，走左边再回来，走右边再回来。</strong></p><p>让一个东西来到 <strong>此地三次！</strong></p><ul><li>理解递归序</li><li>先序、中序、后序都可以在递归序的基础上加工出来</li><li>第一次到达一个节点就打印就是先序、第二次打印即中序、第三次即后序</li></ul><h3 id="非递归方式实现二叉树的先序、中序、后序遍历"><a href="#非递归方式实现二叉树的先序、中序、后序遍历" class="headerlink" title="非递归方式实现二叉树的先序、中序、后序遍历"></a>非递归方式实现二叉树的先序、中序、后序遍历</h3><ul><li><p>任何递归函数都可以改成非递归</p></li><li><p>非递归实现先序遍历</p><pre><code class="hljs java"><span class="hljs-comment">// 先序遍历</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pre</span><span class="hljs-params">(Node head)</span> </span>&#123;   System.out.print(<span class="hljs-string">&quot;pre-order: &quot;</span>);   <span class="hljs-keyword">if</span> (head != <span class="hljs-keyword">null</span>) &#123;      Stack&lt;Node&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;Node&gt;();      stack.add(head);      <span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;         head = stack.pop();         System.out.print(head.value + <span class="hljs-string">&quot; &quot;</span>);         <span class="hljs-keyword">if</span> (head.right != <span class="hljs-keyword">null</span>) &#123;            stack.push(head.right);         &#125;         <span class="hljs-keyword">if</span> (head.left != <span class="hljs-keyword">null</span>) &#123;            stack.push(head.left);         &#125;      &#125;   &#125;   System.out.println();&#125;</code></pre><ul><li><p>先放头结点，弹出就打印</p></li><li><p>弹出打印后，如果有右孩子，先压入右孩子</p></li><li><p>如果有左孩子，再压入右孩子</p></li><li><p>例如对上面的树，先压入1，弹出1，压入3、2，弹出2，压入5、4，弹出4，弹出5，弹出3，压入7、6，弹出6、7</p></li></ul></li></ul><ul><li><p>非递归实现后序遍历</p><ul><li><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201209172717.png" alt="流程与先序相反"></p></li><li><p> 如果上述，先压左再压入右， 头左右就会变成头右左，正好是后序的相反。</p></li></ul><p>Code:</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pos1</span><span class="hljs-params">(Node head)</span> </span>&#123;   System.out.print(<span class="hljs-string">&quot;pos-order: &quot;</span>);   <span class="hljs-keyword">if</span> (head != <span class="hljs-keyword">null</span>) &#123;      Stack&lt;Node&gt; s1 = <span class="hljs-keyword">new</span> Stack&lt;Node&gt;();      Stack&lt;Node&gt; s2 = <span class="hljs-keyword">new</span> Stack&lt;Node&gt;();      s1.push(head);      <span class="hljs-keyword">while</span> (!s1.isEmpty()) &#123;         head = s1.pop();         <span class="hljs-comment">// 转移到s2里面，先序这里是直接打印</span>         s2.push(head);         <span class="hljs-comment">// 先压左</span>         <span class="hljs-keyword">if</span> (head.left != <span class="hljs-keyword">null</span>) &#123;            s1.push(head.left);         &#125;         <span class="hljs-keyword">if</span> (head.right != <span class="hljs-keyword">null</span>) &#123;            s1.push(head.right);         &#125;      &#125;      <span class="hljs-keyword">while</span> (!s2.isEmpty()) &#123;         System.out.print(s2.pop().value + <span class="hljs-string">&quot; &quot;</span>);      &#125;   &#125;   System.out.println();&#125;</code></pre></li><li><p>非递归实现后序遍历（方法二）</p><ul><li><p>死亡代码</p></li><li><p>左边到最底下，弹出一个往上管右边，右边再找左边最底下，直到把左边处理完再处理右边再处理自己。</p></li></ul></li></ul>  <pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pos2</span><span class="hljs-params">(Node h)</span> </span>&#123;   System.out.print(<span class="hljs-string">&quot;pos-order: &quot;</span>);   <span class="hljs-keyword">if</span> (h != <span class="hljs-keyword">null</span>) &#123;      Stack&lt;Node&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;Node&gt;();      stack.push(h);      Node c = <span class="hljs-keyword">null</span>;      <span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;         c = stack.peek();         <span class="hljs-comment">// 左树没处理先处理左树</span>         <span class="hljs-keyword">if</span> (c.left != <span class="hljs-keyword">null</span> &amp;&amp; h != c.left &amp;&amp; h != c.right) &#123;            stack.push(c.left);         <span class="hljs-comment">// 右树没处理先处理右树</span>         &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c.right != <span class="hljs-keyword">null</span> &amp;&amp; h != c.right) &#123;            stack.push(c.right);         <span class="hljs-comment">// 该处理自己了</span>         &#125; <span class="hljs-keyword">else</span> &#123;            System.out.print(stack.pop().value + <span class="hljs-string">&quot; &quot;</span>);            <span class="hljs-comment">// h跟踪上次打印的结点</span>            h = c;         &#125;      &#125;   &#125;   System.out.println();&#125;</code></pre><ul><li><p>非递归实现中序遍历</p><ul><li><p>整条左边界依次入栈</p></li><li><p>第一条逻辑无法再命中，就弹出结点并打印，然后来到弹出结点的右树上继续执行条件一</p></li><li><p>如上面的树，左边界全入栈，栈顶 - &gt; 栈底以此为 4,2,1，不能再命中了，弹出4，来到4的右孩子且为Null，弹出2，来到2的右孩子且为5，压入5，弹出5，来到5的右孩子且为Null，弹出1，来到1的右孩子3，3、6依此入栈，弹出6，来到6的右孩子且为Null，弹出3，来到3的右孩子且为7，弹出7。</p><pre><code class="hljs java"><span class="hljs-comment">// 左头无限分解</span><span class="hljs-comment">// 左边左头分解，右边也左头分解</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">in</span><span class="hljs-params">(Node head)</span> </span>&#123;    System.out.print(<span class="hljs-string">&quot;in-order: &quot;</span>);    <span class="hljs-keyword">if</span> (head != <span class="hljs-keyword">null</span>) &#123;      Stack&lt;Node&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;Node&gt;();      <span class="hljs-keyword">while</span> (!stack.isEmpty() || head != <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-comment">// 把左边全压入</span>        <span class="hljs-keyword">if</span> (head != <span class="hljs-keyword">null</span>) &#123;          stack.push(head);          head = head.left;        &#125; <span class="hljs-keyword">else</span> &#123;          head = stack.pop();          System.out.print(head.value + <span class="hljs-string">&quot; &quot;</span>);          head = head.right;        &#125;      &#125;    &#125;    System.out.println();  &#125;</code></pre></li></ul></li></ul><h2 id="实现二叉树的按层遍历"><a href="#实现二叉树的按层遍历" class="headerlink" title="实现二叉树的按层遍历"></a>实现二叉树的按层遍历</h2><ul><li><p>其实就是 <strong>宽度优先遍历</strong> ，用 <strong>队列</strong></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">level</span><span class="hljs-params">(Node head)</span> </span>&#123;   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span>;   &#125;   Queue&lt;Node&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();   queue.add(head);   <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;      Node cur = queue.poll();      System.out.println(cur.value);      <span class="hljs-keyword">if</span> (cur.left != <span class="hljs-keyword">null</span>) &#123;         queue.add(cur.left);      &#125;      <span class="hljs-keyword">if</span> (cur.right != <span class="hljs-keyword">null</span>) &#123;         queue.add(cur.right);      &#125;   &#125;&#125;</code></pre><ul><li><p>先把头结点加入</p></li><li><p>开始循环，弹出打印，先加左再加右</p></li><li><p>1弹出，2、3进，2弹出，4、5进，3弹出，6、7进…..</p></li></ul></li></ul><h3 id="二叉树最大宽度"><a href="#二叉树最大宽度" class="headerlink" title="二叉树最大宽度"></a>二叉树最大宽度</h3><ul><li><p>可以通过设置 <strong>flag变量</strong> 的方式，来发现某一层的 <strong>结束</strong>（看题目）</p><p>如：找到二叉树最宽的一层，建议一个发现机制就行，发现结束就意味着开始。</p><pre><code class="hljs java"><span class="hljs-comment">// 寻找到二叉树最大宽度</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxWidthUseMap</span><span class="hljs-params">(Node head)</span> </span>&#123;   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;   &#125;   Queue&lt;Node&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();   queue.add(head);   <span class="hljs-comment">// key在哪一层</span>   HashMap&lt;Node, Integer&gt; levelMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();   levelMap.put(head, <span class="hljs-number">1</span>);   <span class="hljs-comment">// 当前正在统计哪一层的宽度</span>   <span class="hljs-keyword">int</span> curLevel = <span class="hljs-number">1</span>;   <span class="hljs-comment">// 当前正在统计层的宽度是多少</span>   <span class="hljs-keyword">int</span> curLevelNodes = <span class="hljs-number">0</span>; <span class="hljs-comment">// 一律规定出来的时候加，初始为0</span>   <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;   <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;      Node cur = queue.poll();      <span class="hljs-comment">// 当前层级别</span>      <span class="hljs-keyword">int</span> curNodeLevel = levelMap.get(cur);      <span class="hljs-keyword">if</span> (cur.left != <span class="hljs-keyword">null</span>) &#123;         levelMap.put(cur.left, curNodeLevel + <span class="hljs-number">1</span>);         queue.add(cur.left);      &#125;      <span class="hljs-keyword">if</span> (cur.right != <span class="hljs-keyword">null</span>) &#123;         levelMap.put(cur.right, curNodeLevel + <span class="hljs-number">1</span>);         queue.add(cur.right);      &#125;      <span class="hljs-keyword">if</span> (curNodeLevel == curLevel) &#123;         curLevelNodes++;      &#125; <span class="hljs-keyword">else</span> &#123;         max = Math.max(max, curLevelNodes);         curLevel++;         curLevelNodes = <span class="hljs-number">1</span>;      &#125;   &#125;   <span class="hljs-comment">// 最后一层没有出发max机制</span>   max = Math.max(max, curLevelNodes);   <span class="hljs-keyword">return</span> max;&#125;</code></pre><p>用map记录结点位置（每一个新层到来结算上一层的老层）</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201210083532.png" alt="流程"></p></li></ul><ul><li><p>不用map寻找最大宽度机制：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxWidthNoMap</span><span class="hljs-params">(Node head)</span> </span>&#123;   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;   &#125;   Queue&lt;Node&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();   queue.add(head);   <span class="hljs-comment">// 当前层最右结点是谁</span>   Node curEnd = head;   <span class="hljs-comment">// 如果有下一层，下一层最右结点是谁</span>   Node nextEnd = <span class="hljs-keyword">null</span>;   <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;   <span class="hljs-keyword">int</span> curLevelNodes = <span class="hljs-number">0</span>; <span class="hljs-comment">// 当前层结点数</span>   <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;      Node cur = queue.poll();      <span class="hljs-keyword">if</span> (cur.left != <span class="hljs-keyword">null</span>) &#123;         queue.add(cur.left);         nextEnd = cur.left;      &#125;      <span class="hljs-keyword">if</span> (cur.right != <span class="hljs-keyword">null</span>) &#123;         queue.add(cur.right);         nextEnd = cur.right;      &#125;      curLevelNodes++;      <span class="hljs-comment">// 当前层结点是否为当前层最右结点</span>      <span class="hljs-keyword">if</span> (cur == curEnd) &#123;         max = Math.max(max, curLevelNodes);         curLevelNodes = <span class="hljs-number">0</span>;         curEnd = nextEnd;      &#125;   &#125;</code></pre></li></ul><h2 id="二叉树的序列化和反序列化"><a href="#二叉树的序列化和反序列化" class="headerlink" title="二叉树的序列化和反序列化"></a>二叉树的序列化和反序列化</h2><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201210085559.png" alt="序列化"></p><h3 id="先序序列化"><a href="#先序序列化" class="headerlink" title="先序序列化"></a>先序序列化</h3><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Queue&lt;String&gt; <span class="hljs-title">preSerial</span><span class="hljs-params">(Node head)</span> </span>&#123;   Queue&lt;String&gt; ans = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();   pres(head, ans);   <span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pres</span><span class="hljs-params">(Node head, Queue&lt;String&gt; ans)</span> </span>&#123;   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;      ans.add(<span class="hljs-keyword">null</span>);   &#125; <span class="hljs-keyword">else</span> &#123;      ans.add(String.valueOf(head.value));      pres(head.left, ans);      pres(head.right, ans);   &#125;&#125;</code></pre><h3 id="已知序列化好的队列，还原树"><a href="#已知序列化好的队列，还原树" class="headerlink" title="已知序列化好的队列，还原树"></a>已知序列化好的队列，还原树</h3><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">buildByPreQueue</span><span class="hljs-params">(Queue&lt;String&gt; prelist)</span> </span>&#123;   <span class="hljs-keyword">if</span> (prelist == <span class="hljs-keyword">null</span> || prelist.size() == <span class="hljs-number">0</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;   &#125;   <span class="hljs-keyword">return</span> preb(prelist);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">preb</span><span class="hljs-params">(Queue&lt;String&gt; prelist)</span> </span>&#123;   String value = prelist.poll();   <span class="hljs-keyword">if</span> (value == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;   &#125;   Node head = <span class="hljs-keyword">new</span> Node(Integer.valueOf(value));   head.left = preb(prelist);   head.right = preb(prelist);   <span class="hljs-keyword">return</span> head;&#125;</code></pre><blockquote><p>中序、后序只需要改一下顺序就可以了</p></blockquote><h3 id="按层序列化"><a href="#按层序列化" class="headerlink" title="按层序列化"></a>按层序列化</h3><p>整体上就是 <strong>宽度优先遍历</strong></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Queue&lt;String&gt; <span class="hljs-title">levelSerial</span><span class="hljs-params">(Node head)</span> </span>&#123;   <span class="hljs-comment">// 序列化结果</span>   Queue&lt;String&gt; ans = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;      ans.add(<span class="hljs-keyword">null</span>);   &#125; <span class="hljs-keyword">else</span> &#123;      ans.add(String.valueOf(head.value));      Queue&lt;Node&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;Node&gt;();      queue.add(head);      <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;         head = queue.poll();         <span class="hljs-keyword">if</span> (head.left != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-comment">// 即序列化 也加队列</span>            ans.add(String.valueOf(head.left.value));            queue.add(head.left);         &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// 只序列化</span>            ans.add(<span class="hljs-keyword">null</span>);         &#125;         <span class="hljs-keyword">if</span> (head.right != <span class="hljs-keyword">null</span>) &#123;            ans.add(String.valueOf(head.right.value));            queue.add(head.right);         &#125; <span class="hljs-keyword">else</span> &#123;            ans.add(<span class="hljs-keyword">null</span>);         &#125;      &#125;   &#125;   <span class="hljs-keyword">return</span> ans;&#125;</code></pre><p>其实就是多了一个ans队列，把空补齐。层序遍历的时候只有一个queue，queue里面放的一定不为null，再弹出判断。序列化只是ans可以放null，自己另外准备的queue不放null进行层序遍历而已。</p><h3 id="按层反序列化"><a href="#按层反序列化" class="headerlink" title="按层反序列化"></a>按层反序列化</h3><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">buildByLevelQueue</span><span class="hljs-params">(Queue&lt;String&gt; levelList)</span> </span>&#123;   <span class="hljs-keyword">if</span> (levelList == <span class="hljs-keyword">null</span> || levelList.size() == <span class="hljs-number">0</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;   &#125;   Node head = generateNode(levelList.poll());   Queue&lt;Node&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;Node&gt;();   <span class="hljs-keyword">if</span> (head != <span class="hljs-keyword">null</span>) &#123;      queue.add(head);   &#125;   Node node = <span class="hljs-keyword">null</span>;   <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;      node = queue.poll();      node.left = generateNode(levelList.poll());      node.right = generateNode(levelList.poll());      <span class="hljs-keyword">if</span> (node.left != <span class="hljs-keyword">null</span>) &#123;         queue.add(node.left);      &#125;      <span class="hljs-keyword">if</span> (node.right != <span class="hljs-keyword">null</span>) &#123;         queue.add(node.right);      &#125;   &#125;   <span class="hljs-keyword">return</span> head;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">generateNode</span><span class="hljs-params">(String val)</span> </span>&#123;   <span class="hljs-keyword">if</span> (val == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;   &#125;   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Node(Integer.valueOf(val));&#125;</code></pre><h2 id="设计一种打印树的方式"><a href="#设计一种打印树的方式" class="headerlink" title="设计一种打印树的方式"></a>设计一种打印树的方式</h2><blockquote><p>如何设计一个打印整棵树的打印函数?</p></blockquote><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201211094340.png" alt="打印出来的效果"></p><p>Code:</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printTree</span><span class="hljs-params">(Node head)</span> </span>&#123;   System.out.println(<span class="hljs-string">&quot;Binary Tree:&quot;</span>);   printInOrder(head, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;H&quot;</span>, <span class="hljs-number">17</span>);   System.out.println();&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printInOrder</span><span class="hljs-params">(Node head, <span class="hljs-keyword">int</span> height, String to, <span class="hljs-keyword">int</span> len)</span> </span>&#123;   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span>;   &#125;   printInOrder(head.right, height + <span class="hljs-number">1</span>, <span class="hljs-string">&quot;v&quot;</span>, len);   String val = to + head.value + to;   <span class="hljs-keyword">int</span> lenM = val.length();   <span class="hljs-keyword">int</span> lenL = (len - lenM) / <span class="hljs-number">2</span>;   <span class="hljs-keyword">int</span> lenR = len - lenM - lenL;   val = getSpace(lenL) + val + getSpace(lenR);   System.out.println(getSpace(height * len) + val);   printInOrder(head.left, height + <span class="hljs-number">1</span>, <span class="hljs-string">&quot;^&quot;</span>, len);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getSpace</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;   String space = <span class="hljs-string">&quot; &quot;</span>;   StringBuffer buf = <span class="hljs-keyword">new</span> StringBuffer(<span class="hljs-string">&quot;&quot;</span>);   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; num; i++) &#123;      buf.append(space);   &#125;   <span class="hljs-keyword">return</span> buf.toString();&#125;</code></pre><p>思路：</p><p>要打印上面的树，实际上就是按照 <strong>右头左</strong> 的顺序打印。</p><p> <strong>printInOrder</strong> 函数就是先打印右边，再头，再左边。</p><p>对于每个要打印的当前头部：height表示高度，to标识二叉树左右子树分支关系或头结点关系，len表示当前数字占用的距离。中间的打印头过程其实就是对当前头结点“渲染”了一下而已。</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201211095016.png" alt="例子"></p><p>前面的空格数由层数决定，每个数字占17位，前后补气空格</p><h2 id="特殊二叉树返回该节点的后继节点"><a href="#特殊二叉树返回该节点的后继节点" class="headerlink" title="特殊二叉树返回该节点的后继节点"></a>特殊二叉树返回该节点的后继节点</h2><p>二叉树结构如下定义：</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;  V value;  Node left;  Node right;  Node parent;&#125;</code></pre><blockquote><p>后继结点定义</p></blockquote><p>后继结点是：<strong>中序遍历</strong> 中一个结点的下一个结点。 </p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201211095339.png" alt="后继结点"></p><ul><li><p>思路一</p><p>因为有parent结点，所以可以一直往上找，找到头结点。再根据头结点 <strong>中序遍历</strong> ，最后根据 <strong>中序遍历</strong> 的结果找后继结点。 <strong>时间复杂度为 O(N)</strong></p></li></ul><ul><li><p>思路二</p><ul><li><p>假设当前结点距离后继结点距离为k，此方法 <strong>时间复杂度为O(K)</strong></p></li><li><p>对于 <strong>有右子树</strong> 的结点，其 <strong>后继结点就是右子树最左结点</strong> 。</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201211095756.png" alt="有右树的情况"></p></li><li><p>对于 <strong>没有右子树</strong> 的结点，如果 <strong>我是我的父节点的右孩子</strong>  ，<strong>就一直往上找</strong> ，直到到达的结点为当前结点 <strong>父节点的左孩子</strong>，这个父节点就是后继结点。</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201211100108.png" alt="后继"></p></li><li><p>由此可以定义: 如果 <strong>结点a左子树上的最右结点(最后打印的结点)为b</strong> ，则a为b的后继结点。</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201211100308.png" alt="结论"></p></li><li><p>整棵树的最右结点的后继结点为空</p></li></ul><p>code:</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">getSuccessorNode</span><span class="hljs-params">(Node node)</span> </span>&#123;   <span class="hljs-keyword">if</span> (node == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span> node;   &#125;   <span class="hljs-keyword">if</span> (node.right != <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span> getLeftMost(node.right);   &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 无右子树</span>      Node parent = node.parent;      <span class="hljs-keyword">while</span> (parent != <span class="hljs-keyword">null</span> &amp;&amp; parent.left != node) &#123; <span class="hljs-comment">// 当前节点是其父亲节点右孩子</span>         node = parent;         parent = node.parent;      &#125;      <span class="hljs-keyword">return</span> parent;   &#125;&#125;<span class="hljs-comment">// 找最左边</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">getLeftMost</span><span class="hljs-params">(Node node)</span> </span>&#123;   <span class="hljs-keyword">if</span> (node == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span> node;   &#125;   <span class="hljs-keyword">while</span> (node.left != <span class="hljs-keyword">null</span>) &#123;      node = node.left;   &#125;   <span class="hljs-keyword">return</span> node;&#125;</code></pre></li></ul><h3 id="前驱结点"><a href="#前驱结点" class="headerlink" title="前驱结点"></a>前驱结点</h3><p>正好相反，先找有无左子树，如果有，找左子树最右结点。</p><p>如果没有左子树，如果当前结点为父节点的左孩子，一直往上直到当前结点为父节点的右孩子。</p><h2 id="折痕问题"><a href="#折痕问题" class="headerlink" title="折痕问题"></a>折痕问题</h2><p>请把一段纸条竖着放在桌子上，然后从纸条的下边向上方对折1次，压出折痕后展开。此时折痕是凹下去的，即折痕突起的方向指向纸条的背面。 如果从纸条的下边向上方连续对折2次，压出折痕后展开，此时有三条折痕，从上到下依次是下折痕、下折痕和上折痕。 </p><p>给定一个输入参数N，代表纸条都从下边向上方连续对折N次。 请从上到下打印所有折痕的方向。<br>例如:N=1时，打印: down N=2时，打印: down down up </p><ul><li>实际对折，会发现：每次对折都会在当前折痕前面加一个down，后面加一个up。</li></ul><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201211101348.png" alt="图解"></p><ul><li><p>所以实际上就是中序遍历</p><ul><li>如果用数组实现，N次折产生2的n次方-1个折痕，浪费空间。</li><li>新code:</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printAllFolds</span><span class="hljs-params">(<span class="hljs-keyword">int</span> N)</span> </span>&#123;   printProcess(<span class="hljs-number">1</span>, N, <span class="hljs-keyword">true</span>);&#125;<span class="hljs-comment">// 递归过程，来到了某一个节点，</span><span class="hljs-comment">// i是节点的层数，N一共的层数，down == true  凹    down == false 凸</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printProcess</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> N, <span class="hljs-keyword">boolean</span> down)</span> </span>&#123;   <span class="hljs-keyword">if</span> (i &gt; N) &#123;      <span class="hljs-keyword">return</span>;   &#125;   printProcess(i + <span class="hljs-number">1</span>, N, <span class="hljs-keyword">true</span>);   System.out.println(down ? <span class="hljs-string">&quot;凹 &quot;</span> : <span class="hljs-string">&quot;凸 &quot;</span>);   printProcess(i + <span class="hljs-number">1</span>, N, <span class="hljs-keyword">false</span>);&#125;</code></pre><ul><li>空间复杂度 O(N) 创建了N个i</li></ul><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201211101703.png" alt="流程"></p></li></ul><h1 id="二叉树的递归套路"><a href="#二叉树的递归套路" class="headerlink" title="二叉树的递归套路"></a>二叉树的递归套路</h1><blockquote><p>本质是利用递归遍历二叉树的 <strong>便利性</strong> (会到每个结点 <strong>3次</strong> )</p></blockquote><p>潜意识：任何结点x为头的树，可以得到 <strong>左右子树信息</strong> ，并利用此信息求解过程。</p><p>1）假设以X节点为头，假设可以向X左树和X右树要任何信息</p><p>2）在上一步的假设下，讨论以X为头节点的树，得到答案的可能性（最重要）</p><p>3）列出所有可能性后，确定到底需要向左树和右树要什么样的信息</p><p>3）列出所有可能性后，确定到底需要向左树和右树要什么样的信息</p><p>4）把左树信息和右树信息求全集，就是任何一棵子树都需要返回的信息S</p><p>5）递归函数都返回S，每一棵子树都这么要求</p><p>6）写代码，在代码中考虑如何把左树的信息和右树信息整合出整棵树的信</p><h2 id="给定一棵二叉树的头节点head，返回这颗二叉树是不是平衡二叉树"><a href="#给定一棵二叉树的头节点head，返回这颗二叉树是不是平衡二叉树" class="headerlink" title="给定一棵二叉树的头节点head，返回这颗二叉树是不是平衡二叉树"></a>给定一棵二叉树的头节点head，返回这颗二叉树是不是平衡二叉树</h2><p>二叉树中每一颗子树，左数的 <strong>高度差</strong> 与右树的高度差不超过 1。</p><ol><li>左树平衡 2) 右树平衡 3) 左右树高度差不大于一            <strong>|左高 - 右高| &lt; 2</strong></li></ol><p>在能确定获取子树信息情况下列出可能性：要的信息： <strong>是否平衡， 高度多少</strong></p><p>求解过程就变成如何返回信息的过程：</p><p>平衡树info：</p><pre><code class="hljs java"><span class="hljs-comment">// 左树和右树要求一样的</span><span class="hljs-comment">// 信息返回的结构体</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Info</span> </span>&#123;   <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> isBalaced;   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> height;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Info</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> b, <span class="hljs-keyword">int</span> h)</span> </span>&#123;      isBalaced = b;      height = h;   &#125;&#125;</code></pre><p>code:</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isBalanced2</span><span class="hljs-params">(Node head)</span> </span>&#123;   <span class="hljs-keyword">return</span> process2(head).isBalaced;&#125;<span class="hljs-comment">// 左树和右树要求一样的</span><span class="hljs-comment">// 信息返回的结构体</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Info</span> </span>&#123;   <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> isBalaced;   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> height;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Info</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> b, <span class="hljs-keyword">int</span> h)</span> </span>&#123;      isBalaced = b;      height = h;   &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Info <span class="hljs-title">process2</span><span class="hljs-params">(Node head)</span> </span>&#123;   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Info(<span class="hljs-keyword">true</span>, <span class="hljs-number">0</span>);   &#125;   Info leftInfo = process2(head.left);   Info rightInfo = process2(head.right);   <span class="hljs-keyword">int</span> height = Math.max(leftInfo.height, rightInfo.height) + <span class="hljs-number">1</span>;   <span class="hljs-keyword">boolean</span> isBalanced = <span class="hljs-keyword">true</span>;   <span class="hljs-keyword">if</span> (!leftInfo.isBalaced || !rightInfo.isBalaced || Math.abs(leftInfo.height - rightInfo.height) &gt; <span class="hljs-number">1</span>) &#123;      isBalanced = <span class="hljs-keyword">false</span>;   &#125;   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Info(isBalanced, height);&#125;</code></pre><h2 id="给定一棵二叉树的头节点head，任何两个节点之间都存在距离，返回整棵二叉树的最大距离"><a href="#给定一棵二叉树的头节点head，任何两个节点之间都存在距离，返回整棵二叉树的最大距离" class="headerlink" title="给定一棵二叉树的头节点head，任何两个节点之间都存在距离，返回整棵二叉树的最大距离"></a>给定一棵二叉树的头节点head，任何两个节点之间都存在距离，返回整棵二叉树的最大距离</h2><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201211104832.png" alt="距离"></p><p>最大距离不是最左到最后！</p><ul><li>与x无关时，不跨过x，要么是左树最大距离，要么是右树最大距离。</li></ul><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201211105433.png" alt="最大距离与x无关"></p><ul><li><p>与x有关时，最大距离会通过x，x左树上离他最远的点走到右树上离他最远的点，也就是左边高度，加自己一步，加右边高度。</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201211105622.png" alt="有关"></p></li></ul><blockquote><p>所以info就需要包含 <strong>最大距离 和 高度</strong></p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Info</span> </span>&#123;   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> maxDistance;   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> height;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Info</span><span class="hljs-params">(<span class="hljs-keyword">int</span> dis, <span class="hljs-keyword">int</span> h)</span> </span>&#123;      maxDistance = dis;      height = h;   &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Info <span class="hljs-title">process</span><span class="hljs-params">(Node head)</span> </span>&#123;   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Info(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);   &#125;   Info leftInfo = process(head.left);   Info rightInfo = process(head.right);   <span class="hljs-keyword">int</span> height = Math.max(leftInfo.height, rightInfo.height) + <span class="hljs-number">1</span>;   <span class="hljs-comment">// 返回的 (左子树和右子树最大距离)和(左子树高加上右子树高)的最大值</span>   <span class="hljs-comment">// 距离只可能为左子树最大距离或者右子树最大距离或者左子树高度加上右子树高度</span>   <span class="hljs-keyword">int</span> maxDistance = Math.max(Math.max(leftInfo.maxDistance, rightInfo.maxDistance),         leftInfo.height + rightInfo.height + <span class="hljs-number">1</span>);   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Info(maxDistance, height);&#125;</code></pre><h2 id="给定一棵二叉树的头节点head，返回这颗二叉树中最大的二叉搜索子树的大小（结点的个数）"><a href="#给定一棵二叉树的头节点head，返回这颗二叉树中最大的二叉搜索子树的大小（结点的个数）" class="headerlink" title="给定一棵二叉树的头节点head，返回这颗二叉树中最大的二叉搜索子树的大小（结点的个数）"></a>给定一棵二叉树的头节点head，返回这颗二叉树中最大的二叉搜索子树的大小（结点的个数）</h2><p>搜索二叉树：整个树上没有重复值，左树值都小于父，右树值都大于父</p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201211112015.png" alt="搜索二叉" style="zoom:50%;" /><ul><li><p>与x无关，就可能为左边子树或者右边子树</p></li><li><p>与x有关，三个条件，左树整体是搜索二叉树，右树整体是搜索二叉树，左树最大值小于x，右树最大值大于x</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201211113138.png" alt="条件"></p></li></ul><ul><li>左树信息就变成<ul><li>左边最大子搜索树大小</li><li>是否为最大子搜索树</li><li>左树最大值</li></ul></li><li>右树信息就变成<ul><li>右边最大子搜索树大小</li><li>是否为最大子搜索树</li><li>右树最小值</li></ul></li></ul><blockquote><p>就要用到合并左右树信息</p></blockquote><pre><code class="hljs java"><span class="hljs-comment">// 对于任何子树都返回四个信息</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Info</span> </span>&#123;   <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> isBST;   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> maxSubBSTSize;   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> min;   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> max;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Info</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> is, <span class="hljs-keyword">int</span> size, <span class="hljs-keyword">int</span> mi, <span class="hljs-keyword">int</span> ma)</span> </span>&#123;      isBST = is;      maxSubBSTSize = size;      min = mi;      max = ma;   &#125;&#125;</code></pre><p>算法code：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Info <span class="hljs-title">process</span><span class="hljs-params">(Node head)</span> </span>&#123;   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;   &#125;   Info leftInfo = process(head.left);   Info rightInfo = process(head.right);   <span class="hljs-keyword">int</span> min = head.value;   <span class="hljs-keyword">int</span> max = head.value;   <span class="hljs-keyword">int</span> maxSubBSTSize = <span class="hljs-number">0</span>;   <span class="hljs-keyword">if</span> (leftInfo != <span class="hljs-keyword">null</span>) &#123;      min = Math.min(min, leftInfo.min);      max = Math.max(max, leftInfo.max);      maxSubBSTSize = Math.max(maxSubBSTSize, leftInfo.maxSubBSTSize);   &#125;   <span class="hljs-keyword">if</span> (rightInfo != <span class="hljs-keyword">null</span>) &#123;      min = Math.min(min, rightInfo.min);      max = Math.max(max, rightInfo.max);      maxSubBSTSize = Math.max(maxSubBSTSize, rightInfo.maxSubBSTSize);   &#125;   <span class="hljs-keyword">boolean</span> isBST = <span class="hljs-keyword">false</span>;   <span class="hljs-comment">// 左树是搜索二叉树</span>   <span class="hljs-comment">// 右树也是搜索二叉树</span>   <span class="hljs-comment">// 左边max小于x，右边min大于x</span>   <span class="hljs-keyword">if</span> ((leftInfo == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">true</span> : (leftInfo.isBST &amp;&amp; leftInfo.max &lt; head.value))         &amp;&amp; (rightInfo == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">true</span> : (rightInfo.isBST &amp;&amp; rightInfo.min &gt; head.value))) &#123;      isBST = <span class="hljs-keyword">true</span>;      maxSubBSTSize = (leftInfo == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : leftInfo.maxSubBSTSize)            + (rightInfo == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : rightInfo.maxSubBSTSize) + <span class="hljs-number">1</span>;   &#125;   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Info(isBST, maxSubBSTSize, min, max);&#125;</code></pre><p>代码等价：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201213132931.png" alt="code"></p><h2 id="派对的最大快乐值"><a href="#派对的最大快乐值" class="headerlink" title="派对的最大快乐值"></a>派对的最大快乐值</h2><p>员工信息的定义如下:</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> happy; <span class="hljs-comment">// 这名员工可以带来的快乐值</span>    List&lt;Employee&gt; subordinates; <span class="hljs-comment">// 这名员工有哪些直接下级</span>&#125;</code></pre><p>多叉树！</p><p>​   公司的每个员工都符合 Employee 类的描述。整个公司的人员结构可以看作是一棵标准的、 没有环的多叉树。树的头节点是公司唯一的老板。除老板之外的每个员工都有唯一的直接上级。 叶节点是没有任何下属的基层员工(subordinates列表为空)，除基层员工外，每个员工都有一个或多个直接下级。</p><p>这个公司现在要办party，你可以决定哪些员工来，哪些员工不来，规则：</p><ul><li>如果某个员工来了，那么这个 员工的所有直接下级都不能来</li><li>派对的整体快乐值是所有到场员工快乐值的累加</li><li>你的目标是让派对的整体快乐值尽量大</li><li>给定一棵多叉树的头节点boss，请返回派对的最大快乐值。</li></ul><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201213134214.png" alt="情况分类"></p><ol><li><p>如果x来，则x的happy，a不来情况下整棵树的最大值，b不来情况下整棵树的最大值，c不来情况下整棵树的最大值</p></li><li><p>如果x不来，a、b、c不一定会发，应该求Max(a来情况下整棵树最大值，a不来情况下整棵树最大值)</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201213134923.png" alt="x不来情况"></p></li><li><p>比较第一种和第二种情况</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Info</span> </span>&#123;   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> yes; <span class="hljs-comment">// 头结点来情况下整棵树最大值</span>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> no; <span class="hljs-comment">// 头结点不来情况下整棵树最大值</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Info</span><span class="hljs-params">(<span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> n)</span> </span>&#123;      yes = y;      no = n;   &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Info <span class="hljs-title">process2</span><span class="hljs-params">(Employee x)</span> </span>&#123;   <span class="hljs-keyword">if</span> (x.nexts.isEmpty()) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Info(x.happy, <span class="hljs-number">0</span>);   &#125;   <span class="hljs-keyword">int</span> yes = x.happy;   <span class="hljs-keyword">int</span> no = <span class="hljs-number">0</span>;   <span class="hljs-keyword">for</span> (Employee next : x.nexts) &#123;     <span class="hljs-comment">// 遍历孩子</span>      Info nextInfo = process2(next);     <span class="hljs-comment">// 父亲来的值加上子不来</span>      yes += nextInfo.no;     <span class="hljs-comment">// 父亲不来值加上子来或不来最大值</span>      no += Math.max(nextInfo.yes, nextInfo.no);   &#125;   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Info(yes, no);&#125;</code></pre></li></ol><h2 id="给定一棵二叉树的头节点head，返回这颗二叉树是不是满二叉树"><a href="#给定一棵二叉树的头节点head，返回这颗二叉树是不是满二叉树" class="headerlink" title="给定一棵二叉树的头节点head，返回这颗二叉树是不是满二叉树"></a>给定一棵二叉树的头节点head，返回这颗二叉树是不是满二叉树</h2><blockquote><p>2^L - 1 = N</p></blockquote><p>找出一棵树的高度和结点个数，组成info。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Info</span> </span>&#123;   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> height; <span class="hljs-comment">// L</span>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> nodes; <span class="hljs-comment">// N</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Info</span><span class="hljs-params">(<span class="hljs-keyword">int</span> h, <span class="hljs-keyword">int</span> n)</span> </span>&#123;      height = h;      nodes = n;   &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Info <span class="hljs-title">process</span><span class="hljs-params">(Node head)</span> </span>&#123;   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Info(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);   &#125;   Info leftInfo = process(head.left);   Info rightInfo = process(head.right);   <span class="hljs-keyword">int</span> height = Math.max(leftInfo.height, rightInfo.height) + <span class="hljs-number">1</span>;   <span class="hljs-keyword">int</span> nodes = leftInfo.nodes + rightInfo.nodes + <span class="hljs-number">1</span>;   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Info(height, nodes);&#125;</code></pre><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isFull2</span><span class="hljs-params">(Node head)</span> </span>&#123;   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;   &#125;   Info all = process(head);   <span class="hljs-keyword">return</span> (<span class="hljs-number">1</span> &lt;&lt; all.height) - <span class="hljs-number">1</span> == all.nodes;&#125;</code></pre><h2 id="给定一棵二叉树的头节点head，返回这颗二叉树是不是搜索二叉树"><a href="#给定一棵二叉树的头节点head，返回这颗二叉树是不是搜索二叉树" class="headerlink" title="给定一棵二叉树的头节点head，返回这颗二叉树是不是搜索二叉树"></a>给定一棵二叉树的头节点head，返回这颗二叉树是不是搜索二叉树</h2><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Info</span> </span>&#123;   <span class="hljs-keyword">boolean</span> isBST;   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> min;   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> max;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Info</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> is, <span class="hljs-keyword">int</span> mi, <span class="hljs-keyword">int</span> ma)</span> </span>&#123;      isBST = is;      min = mi;      max = ma;   &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Info <span class="hljs-title">process</span><span class="hljs-params">(Node head)</span> </span>&#123;   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;   &#125;   Info leftInfo = process(head.left);   Info rightInfo = process(head.right);   <span class="hljs-keyword">int</span> min = head.value;   <span class="hljs-keyword">int</span> max = head.value;   <span class="hljs-keyword">if</span> (leftInfo != <span class="hljs-keyword">null</span>) &#123;      min = Math.min(min, leftInfo.min);      max = Math.max(max, leftInfo.max);   &#125;   <span class="hljs-keyword">if</span> (rightInfo != <span class="hljs-keyword">null</span>) &#123;      min = Math.min(min, rightInfo.min);      max = Math.max(max, rightInfo.max);   &#125;   <span class="hljs-keyword">boolean</span> isBST = <span class="hljs-keyword">false</span>;   <span class="hljs-keyword">if</span> (      (leftInfo == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">true</span> : (leftInfo.isBST &amp;&amp; leftInfo.max &lt; head.value))      &amp;&amp;       (rightInfo == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">true</span> : (rightInfo.isBST &amp;&amp; rightInfo.min &gt; head.value))             ) &#123;      isBST = <span class="hljs-keyword">true</span>;   &#125;   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Info(isBST, min, max);&#125;</code></pre><h2 id="给定一棵二叉树的头节点head，返回这颗二叉树中最大的二叉搜索子树的头节点"><a href="#给定一棵二叉树的头节点head，返回这颗二叉树中最大的二叉搜索子树的头节点" class="headerlink" title="给定一棵二叉树的头节点head，返回这颗二叉树中最大的二叉搜索子树的头节点"></a>给定一棵二叉树的头节点head，返回这颗二叉树中最大的二叉搜索子树的头节点</h2><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Info</span> </span>&#123;  <span class="hljs-comment">// 最大二叉搜索子树的头结点</span>   <span class="hljs-keyword">public</span> Node maxSubBSTHead;   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> maxSubBSTSize;   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> min;   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> max;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Info</span><span class="hljs-params">(Node h, <span class="hljs-keyword">int</span> size, <span class="hljs-keyword">int</span> mi, <span class="hljs-keyword">int</span> ma)</span> </span>&#123;      maxSubBSTHead = h;      maxSubBSTSize = size;      min = mi;      max = ma;   &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Info <span class="hljs-title">process</span><span class="hljs-params">(Node head)</span> </span>&#123;   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;   &#125;   Info leftInfo = process(head.left);   Info rightInfo = process(head.right);   <span class="hljs-keyword">int</span> min = head.value;   <span class="hljs-keyword">int</span> max = head.value;   Node maxSubBSTHead = <span class="hljs-keyword">null</span>;   <span class="hljs-keyword">int</span> maxSubBSTSize = <span class="hljs-number">0</span>;   <span class="hljs-keyword">if</span> (leftInfo != <span class="hljs-keyword">null</span>) &#123;      min = Math.min(min, leftInfo.min);      max = Math.max(max, leftInfo.max);      maxSubBSTHead = leftInfo.maxSubBSTHead;      maxSubBSTSize = leftInfo.maxSubBSTSize;   &#125;   <span class="hljs-keyword">if</span> (rightInfo != <span class="hljs-keyword">null</span>) &#123;      min = Math.min(min, rightInfo.min);      max = Math.max(max, rightInfo.max);      <span class="hljs-keyword">if</span> (rightInfo.maxSubBSTSize &gt; maxSubBSTSize) &#123;         maxSubBSTHead = rightInfo.maxSubBSTHead;         maxSubBSTSize = rightInfo.maxSubBSTSize;      &#125;   &#125;   <span class="hljs-keyword">if</span> ((leftInfo == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">true</span> : (leftInfo.maxSubBSTHead == head.left &amp;&amp; leftInfo.max &lt; head.value))         &amp;&amp; (rightInfo == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">true</span> : (rightInfo.maxSubBSTHead == head.right &amp;&amp; rightInfo.min &gt; head.value))) &#123;      maxSubBSTHead = head;      maxSubBSTSize = (leftInfo == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : leftInfo.maxSubBSTSize)            + (rightInfo == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : rightInfo.maxSubBSTSize) + <span class="hljs-number">1</span>;   &#125;   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Info(maxSubBSTHead, maxSubBSTSize, min, max);&#125;</code></pre><h2 id="给定一棵二叉树的头节点head，返回这颗二叉树中是不是完全二叉树"><a href="#给定一棵二叉树的头节点head，返回这颗二叉树中是不是完全二叉树" class="headerlink" title="给定一棵二叉树的头节点head，返回这颗二叉树中是不是完全二叉树"></a>给定一棵二叉树的头节点head，返回这颗二叉树中是不是完全二叉树</h2><p>要么满，要么从左到右依次变慢。</p><p>基本解法：宽度优先遍历</p><p>Code1:</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isCBT1</span><span class="hljs-params">(Node head)</span> </span>&#123;   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;   &#125;   LinkedList&lt;Node&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();   <span class="hljs-comment">// 是否遇到过左右两个孩子不双全的节点</span>   <span class="hljs-keyword">boolean</span> leaf = <span class="hljs-keyword">false</span>;   Node l = <span class="hljs-keyword">null</span>;   Node r = <span class="hljs-keyword">null</span>;   queue.add(head);   <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;      head = queue.poll();      l = head.left;      r = head.right;      <span class="hljs-keyword">if</span> (      <span class="hljs-comment">// 如果遇到了不双全的节点之后，又发现当前节点不是叶节点</span>      (leaf &amp;&amp; !(l == <span class="hljs-keyword">null</span> &amp;&amp; r == <span class="hljs-keyword">null</span>)) || (l == <span class="hljs-keyword">null</span> &amp;&amp; r != <span class="hljs-keyword">null</span>)) &#123;         <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;      &#125;      <span class="hljs-keyword">if</span> (l != <span class="hljs-keyword">null</span>) &#123;         queue.add(l);      &#125;      <span class="hljs-keyword">if</span> (r != <span class="hljs-keyword">null</span>) &#123;         queue.add(r);      &#125;      <span class="hljs-keyword">if</span> (l == <span class="hljs-keyword">null</span> || r == <span class="hljs-keyword">null</span>) &#123;         leaf = <span class="hljs-keyword">true</span>;      &#125;   &#125;   <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;&#125;</code></pre><ol><li><p>任何结点有右无左，肯定不是。</p></li><li><p>否则继续，遇到第一个左右孩子不双全的结点，后续遇到的左右结点都必须是叶结点。</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201213164434.png" alt="流程"></p><p>条件2找到缺口，以下必须为叶子结点。</p></li></ol><p>Code2:</p><p>根据最后一个结点到哪了进行分类：</p><ol><li><p>满二叉树，无缺口 （左树满，右树满，高度一样）</p></li><li><p>有缺口，第一种缺口停左树 ，最后左边有（左完全二叉，右树满，左树高 - 右树高 = 1）</p></li><li><p>有缺口，左树填满，缺口还没到右边 （左树满，右树满，左树高度 - 右树高度 = 1）</p></li><li><p>有缺口，左树填满，右树最后左边有，（左树满，右树完全二叉， 左树高度 = 右树高度）</p></li></ol><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Info</span> </span>&#123;   <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> isFull;   <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> isCBT;   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> height;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Info</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> full, <span class="hljs-keyword">boolean</span> cbt, <span class="hljs-keyword">int</span> h)</span> </span>&#123;      isFull = full;      isCBT = cbt;      height = h;   &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Info <span class="hljs-title">process</span><span class="hljs-params">(Node head)</span> </span>&#123;   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Info(<span class="hljs-keyword">true</span>, <span class="hljs-keyword">true</span>, <span class="hljs-number">0</span>);   &#125;   Info leftInfo = process(head.left);   Info rightInfo = process(head.right);   <span class="hljs-keyword">int</span> height = Math.max(leftInfo.height, rightInfo.height) + <span class="hljs-number">1</span>;   <span class="hljs-keyword">boolean</span> isFull = leftInfo.isFull &amp;&amp; rightInfo.isFull &amp;&amp; leftInfo.height == rightInfo.height;   <span class="hljs-keyword">boolean</span> isCBT = <span class="hljs-keyword">false</span>;   <span class="hljs-keyword">if</span> (isFull) &#123;      isCBT = <span class="hljs-keyword">true</span>;   &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-keyword">if</span> (leftInfo.isCBT &amp;&amp; rightInfo.isCBT) &#123;         <span class="hljs-keyword">if</span> (leftInfo.isCBT &amp;&amp; rightInfo.isFull &amp;&amp; leftInfo.height == rightInfo.height + <span class="hljs-number">1</span>) &#123;            isCBT = <span class="hljs-keyword">true</span>;         &#125;         <span class="hljs-keyword">if</span> (leftInfo.isFull &amp;&amp; rightInfo.isFull &amp;&amp; leftInfo.height == rightInfo.height + <span class="hljs-number">1</span>) &#123;            isCBT = <span class="hljs-keyword">true</span>;         &#125;         <span class="hljs-keyword">if</span> (leftInfo.isFull &amp;&amp; rightInfo.isCBT &amp;&amp; leftInfo.height == rightInfo.height) &#123;            isCBT = <span class="hljs-keyword">true</span>;         &#125;      &#125;   &#125;   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Info(isFull, isCBT, height);&#125;</code></pre><h2 id="给定一棵二叉树的头节点head，和另外两个节点a和b。返回a和b的最低公共祖先"><a href="#给定一棵二叉树的头节点head，和另外两个节点a和b。返回a和b的最低公共祖先" class="headerlink" title="给定一棵二叉树的头节点head，和另外两个节点a和b。返回a和b的最低公共祖先"></a>给定一棵二叉树的头节点head，和另外两个节点a和b。返回a和b的最低公共祖先</h2><p>不用套路：整棵树遍历过程中 <strong>生成一张表</strong>，记录父节点。</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201213171301.png" alt="让Y往上找"></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">lowestAncestor1</span><span class="hljs-params">(Node head, Node o1, Node o2)</span> </span>&#123;   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;   &#125;   HashMap&lt;Node, Node&gt; parentMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();   parentMap.put(head, <span class="hljs-keyword">null</span>);   fillParentMap(head, parentMap);   HashSet&lt;Node&gt; o1Set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();   Node cur = o1;   o1Set.add(cur);   <span class="hljs-keyword">while</span> (parentMap.get(cur) != <span class="hljs-keyword">null</span>) &#123;      cur = parentMap.get(cur);      o1Set.add(cur);   &#125;   cur = o2;   <span class="hljs-keyword">while</span> (!o1Set.contains(cur)) &#123;      cur = parentMap.get(cur);   &#125;   <span class="hljs-keyword">return</span> cur;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fillParentMap</span><span class="hljs-params">(Node head, HashMap&lt;Node, Node&gt; parentMap)</span> </span>&#123;   <span class="hljs-keyword">if</span> (head.left != <span class="hljs-keyword">null</span>) &#123;      parentMap.put(head.left, head);      fillParentMap(head.left, parentMap);   &#125;   <span class="hljs-keyword">if</span> (head.right != <span class="hljs-keyword">null</span>) &#123;      parentMap.put(head.right, head);      fillParentMap(head.right, parentMap);   &#125;&#125;</code></pre><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201213171603.png" alt="流程" style="zoom:50%;" /><p>记录e以上都有谁，f网上找，第一个找到的就是。</p><p>套路：</p><ol><li><p>01, 02没有在x上</p></li><li><p>01, 02只有一个在x上</p></li><li><p>01, 02都在x为头的树上 A:左树右树各一个，B:左树或者右树包含全</p></li><li><p>01, 02有一个为x</p></li></ol><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Info</span> </span>&#123;   <span class="hljs-comment">// o1,o2最初交汇点</span>   <span class="hljs-keyword">public</span> Node ans;   <span class="hljs-comment">// 有无发现过o1</span>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> findO1;   <span class="hljs-comment">// 有无发现过o2</span>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> findO2;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Info</span><span class="hljs-params">(Node a, <span class="hljs-keyword">boolean</span> f1, <span class="hljs-keyword">boolean</span> f2)</span> </span>&#123;      ans = a;      findO1 = f1;      findO2 = f2;   &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Info <span class="hljs-title">process</span><span class="hljs-params">(Node head, Node o1, Node o2)</span> </span>&#123;   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Info(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>);   &#125;   Info leftInfo = process(head.left, o1, o2);   Info rightInfo = process(head.right, o1, o2);   <span class="hljs-keyword">boolean</span> findO1 = head == o1 || leftInfo.findO1 || rightInfo.findO1;   <span class="hljs-keyword">boolean</span> findO2 = head == o2 || leftInfo.findO2 || rightInfo.findO2;  <span class="hljs-comment">// 找交汇点</span>   Node ans = <span class="hljs-keyword">null</span>;  <span class="hljs-comment">// 左树提前交汇了</span>   <span class="hljs-keyword">if</span> (leftInfo.ans != <span class="hljs-keyword">null</span>) &#123;      ans = leftInfo.ans;   &#125;  <span class="hljs-comment">// 右树提前交汇了</span>   <span class="hljs-keyword">if</span> (rightInfo.ans != <span class="hljs-keyword">null</span>) &#123;      ans = rightInfo.ans;   &#125;  <span class="hljs-comment">// head为交汇点</span>   <span class="hljs-keyword">if</span> (ans == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">if</span> (findO1 &amp;&amp; findO2) &#123;         ans = head;      &#125;   &#125;   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Info(ans, findO1, findO2);&#125;</code></pre><h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><p>1）最 <strong>自然智慧</strong> 的算法</p><p>2）用一种局部最功利的标准，总是做出 <strong>在当前看来</strong> 是最好的选择</p><p>3）难点在于 <strong>证明局部最功利的标准可以得到全局最优解</strong></p><p>4）对于贪心算法的学习主要以增加阅历和经验为主</p><p> <strong>能得到最优解</strong> 的例子：一个数组中N个数，全是正数，第m个数 * arr[i] 得到分数，求分数最大最小。</p><p>​       排序后相乘就行了。</p><p> <strong>无法得到最优解</strong> 的例子：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201214075537.png" alt="例子"></p><p>贪心求解，每次拿最多数量的 1:</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201214075629.png" alt="错误解"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201214075705.png" alt="正确解"></p><h2 id="经典问题"><a href="#经典问题" class="headerlink" title="经典问题"></a>经典问题</h2><p>给定一个由字符串组成的 <strong>数组strs</strong> ，<br>必须把所有的字符串 <strong>拼接</strong> 起来，<br>返回所有可能的拼接结果中， <strong>字典序最小</strong>的结果</p><h3 id="字典序"><a href="#字典序" class="headerlink" title="字典序"></a>字典序</h3><blockquote><p>字典序</p></blockquote><ul><li>字符串长度一样认为字符串就是a-z的正数，即abc小于abk</li><li>字符串长度不一样时，短的补长，ac与b就是ac与b0，ac小于b</li></ul><p>java中compareTo方法就是比较字典序</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201214080633.png" alt="按照字符串本身字典序排序"></p><p>再由字典序小的拼接到大的，并不是对的。</p><p> <strong>错误例子</strong> :</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201214080809.png" alt="错误例子"></p><p>正确策略：</p><p>x拼接上y，对比y拼接上x的字典序</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201214081014.png" alt="正确策略"></p><p> <strong>例如[b, ba] bab &lt; bba 所以ba放前</strong></p><h3 id="排序的传递性"><a href="#排序的传递性" class="headerlink" title="排序的传递性"></a>排序的传递性</h3><blockquote><p>排序的传递序，定义的排序是否一定会具有传递性？</p></blockquote><p>不一定！</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201214081443.png" alt="没有传递性的例子"></p><p>这就如同 <strong>石头剪刀布</strong> 一样，甲乙对比，甲在前；….</p><p>如何证明刚才的排序是有传递性的？</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201214081633.png" alt="传递性"></p><p>a.b &lt;= b.a a前，排好序后，在数组中，任何一个位置前.后都 &lt;= 后.前</p><blockquote><p>证明</p></blockquote><p>假设认为字符为26位进制，拼接这件事就可以变为数学移位并相加的运算。</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201214082243.png" alt="移位并相加"></p><p>先认为字符串进位为函数m(b) 代表的意义为 K^b次方，b为字符串长度</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201214083309.png" alt="证明"></p><p>中间部分共同含有ac，减掉，再共同除以b，再移动减法位置得到：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201214083535.png" alt="结果"></p><p>所以这个排序策略是有传递性的。</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201214084002.png" alt="数学归纳法"></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyComparator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparator</span>&lt;<span class="hljs-title">String</span>&gt; </span>&#123;   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(String a, String b)</span> </span>&#123;      <span class="hljs-keyword">return</span> (a + b).compareTo(b + a);   &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">lowestString2</span><span class="hljs-params">(String[] strs)</span> </span>&#123;   <span class="hljs-keyword">if</span> (strs == <span class="hljs-keyword">null</span> || strs.length == <span class="hljs-number">0</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;   &#125;   Arrays.sort(strs, <span class="hljs-keyword">new</span> MyComparator());   String res = <span class="hljs-string">&quot;&quot;</span>;   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; strs.length; i++) &#123;      res += strs[i];   &#125;   <span class="hljs-keyword">return</span> res;&#125;</code></pre><h2 id="贪心算法求解的标准过程"><a href="#贪心算法求解的标准过程" class="headerlink" title="贪心算法求解的标准过程"></a>贪心算法求解的标准过程</h2><p>1，分析业务</p><p>2，根据业务逻辑找到 <strong>不同的贪心策略</strong></p><p>3，对于能 <strong>举出反例</strong> 的策略直接跳过，不能举出反例的策略要证明有效性</p><p>这往往是特别困难的，要求数学能力很高且不具有统一的技巧性</p><h2 id="贪心算法的解题套路"><a href="#贪心算法的解题套路" class="headerlink" title="贪心算法的解题套路"></a>贪心算法的解题套路</h2><p>1，实现一个不依靠贪心策略的解法X，可以用最暴力的尝试</p><p>2，脑补出贪心策略A、贪心策略B、贪心策略C…</p><p>3，用解法X和对数器，用实验的方式得知哪个贪心策略正确 </p><p>4， **不要去纠结贪心策略的证明 **</p><h2 id="贪心算法的解题套路实战"><a href="#贪心算法的解题套路实战" class="headerlink" title="贪心算法的解题套路实战"></a>贪心算法的解题套路实战</h2><h3 id="会议室题"><a href="#会议室题" class="headerlink" title="会议室题"></a>会议室题</h3><p>一些项目要占用一个会议室宣讲，会议室不能同时容纳两个项目的宣讲。<br>给你每一个项目 <strong>开始的时间和结束的时间</strong><br>你来安排宣讲的日程，要求会议室进行的宣讲的场次最多。<br>返回最多的宣讲场次。 </p><p> <strong>按会议结束时间早来贪，安排一个，把不能安排的打X，安排其他的</strong></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">bestArrange2</span><span class="hljs-params">(Program[] programs)</span> </span>&#123;   Arrays.sort(programs, <span class="hljs-keyword">new</span> ProgramComparator());   <span class="hljs-keyword">int</span> timeLine = <span class="hljs-number">0</span>;   <span class="hljs-keyword">int</span> result = <span class="hljs-number">0</span>;   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; programs.length; i++) &#123;      <span class="hljs-keyword">if</span> (timeLine &lt;= programs[i].start) &#123;         result++;         timeLine = programs[i].end;      &#125;   &#125;   <span class="hljs-keyword">return</span> result;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProgramComparator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparator</span>&lt;<span class="hljs-title">Program</span>&gt; </span>&#123;   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Program o1, Program o2)</span> </span>&#123;      <span class="hljs-keyword">return</span> o1.end - o2.end;   &#125;&#125;</code></pre><h3 id="点灯问题"><a href="#点灯问题" class="headerlink" title="点灯问题"></a>点灯问题</h3><p>给定一个字符串str，只由‘X’和‘.’两种字符构成。<br> <strong>‘X’表示墙，不能放灯，也不需要点亮</strong><br> <strong>‘.’表示居民点，可以放灯，需要点亮</strong><br>如果灯放在i位置，可以让i-1，i和i+1三个位置被点亮<br>返回如果点亮str中所有需要点亮的位置，至少需要几盏灯</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201214143040.png" alt="贪心"></p><ul><li>i位置为x，跳下一个</li><li>i位置为点<ul><li>如果i+1为x，必须放，跳i+2</li><li>如果i+1为点，i+2为x，放一个，跳i+3</li><li>如果i+1为点，i+2为点，i+1放一个，跳i+3</li></ul></li></ul><p>总是在当前步做 <strong>最优决定</strong>。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minLight2</span><span class="hljs-params">(String road)</span> </span>&#123;   <span class="hljs-keyword">char</span>[] str = road.toCharArray();   <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;   <span class="hljs-keyword">int</span> light = <span class="hljs-number">0</span>;   <span class="hljs-keyword">while</span> (index &lt; str.length) &#123;      <span class="hljs-keyword">if</span> (str[index] == <span class="hljs-string">&#x27;X&#x27;</span>) &#123;         index++;      &#125; <span class="hljs-keyword">else</span> &#123;         light++;         <span class="hljs-keyword">if</span> (index + <span class="hljs-number">1</span> == str.length) &#123;            <span class="hljs-keyword">break</span>;         &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">if</span> (str[index + <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;X&#x27;</span>) &#123;               index = index + <span class="hljs-number">2</span>;            &#125; <span class="hljs-keyword">else</span> &#123;               index = index + <span class="hljs-number">3</span>;            &#125;         &#125;      &#125;   &#125;   <span class="hljs-keyword">return</span> light;&#125;</code></pre><h3 id="金块分割问题"><a href="#金块分割问题" class="headerlink" title="金块分割问题"></a>金块分割问题</h3><p>一块金条切成两半，是需要花费和长度数值一样的铜板的。<br>比如长度为20的金条，不管怎么切，都要花费20个铜板。 一群人想整分整块金条，怎么分最省铜板? </p><p>例如,给定数组{10,20,30}，代表一共三个人，整块金条长度为60，金条要分成10，20，30三个部分。</p><p>如果先把长度60的金条分成10和50，花费60; 再把长度50的金条分成20和30，花费50;一共花费110铜板。<br>但如果先把长度60的金条分成30和30，花费60;再把长度30金条分成10和20， 花费30;一共花费90铜板。<br>输入一个数组，返回分割的最小代价。 </p><blockquote><p>哈夫曼树</p></blockquote><p>堆和排序是贪心最常用手段</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201214145441.png" alt="堆 哈夫曼树"></p><p>合成哈夫曼树就是从小根堆里面取两个合并再加入小根堆再合并….</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lessMoney2</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;   PriorityQueue&lt;Integer&gt; pQ = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;();   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;      pQ.add(arr[i]);   &#125;   <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;   <span class="hljs-keyword">int</span> cur = <span class="hljs-number">0</span>;   <span class="hljs-keyword">while</span> (pQ.size() &gt; <span class="hljs-number">1</span>) &#123;      cur = pQ.poll() + pQ.poll();      sum += cur;      pQ.add(cur);   &#125;   <span class="hljs-keyword">return</span> sum;&#125;</code></pre><h3 id="项目利益问题"><a href="#项目利益问题" class="headerlink" title="项目利益问题"></a>项目利益问题</h3><p>输入: 正数数组costs、正数数组profits、正数K、正数M<br>costs[i]表示i号项目的 <strong>花费</strong><br>profits[i]表示i号项目在扣除花费之后还能 <strong>挣到的钱(利润)</strong><br>K表示你只能串行的最多做k个项目<br>M表示你初始的资金<br>说明: 每做完一个项目，马上获得的收益，可以支持你去做下一个项目。不能并行的做项目。<br>输出：你最后获得的最大钱数。 </p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201214150806.png" alt="解法"></p><ul><li>设置一个小根堆，按照花费排序，称为此时 <strong>被锁住的项目</strong></li><li>设置一个大根堆，按照利润排序，称为此事 <strong>被解锁的项目</strong></li><li>从小根堆里 <strong>弹出所有能被初始资金满足</strong> 的项目到大根堆，因为按照利润组织，挑选大根堆堆顶做。初始资金变为4。拿初始资金继续寻找小根堆里能满足的放入大根堆，挑选大根堆堆顶，改变资金…. </li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findMaximizedCapital</span><span class="hljs-params">(<span class="hljs-keyword">int</span> K, <span class="hljs-keyword">int</span> W, <span class="hljs-keyword">int</span>[] Profits, <span class="hljs-keyword">int</span>[] Capital)</span> </span>&#123;   PriorityQueue&lt;Program&gt; minCostQ = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;(<span class="hljs-keyword">new</span> MinCostComparator());   PriorityQueue&lt;Program&gt; maxProfitQ = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;(<span class="hljs-keyword">new</span> MaxProfitComparator());   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; Profits.length; i++) &#123;      minCostQ.add(<span class="hljs-keyword">new</span> Program(Profits[i], Capital[i]));   &#125;   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; K; i++) &#123;      <span class="hljs-keyword">while</span> (!minCostQ.isEmpty() &amp;&amp; minCostQ.peek().c &lt;= W) &#123;         maxProfitQ.add(minCostQ.poll());      &#125;      <span class="hljs-keyword">if</span> (maxProfitQ.isEmpty()) &#123;         <span class="hljs-keyword">return</span> W;      &#125;      W += maxProfitQ.poll().p;   &#125;   <span class="hljs-keyword">return</span> W;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span> </span>&#123;   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> p;   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> c;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Program</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> c)</span> </span>&#123;      <span class="hljs-keyword">this</span>.p = p;      <span class="hljs-keyword">this</span>.c = c;   &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MinCostComparator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparator</span>&lt;<span class="hljs-title">Program</span>&gt; </span>&#123;   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Program o1, Program o2)</span> </span>&#123;      <span class="hljs-keyword">return</span> o1.c - o2.c;   &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MaxProfitComparator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparator</span>&lt;<span class="hljs-title">Program</span>&gt; </span>&#123;   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Program o1, Program o2)</span> </span>&#123;      <span class="hljs-keyword">return</span> o2.p - o1.p;   &#125;&#125;</code></pre><p> <strong>暴力解贪心真的很折磨</strong> </p><h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><h2 id="并查集code"><a href="#并查集code" class="headerlink" title="并查集code"></a>并查集code</h2><ol><li>有若干个样本a、b、c、d…类型假设是V</li><li>在并查集中一开始认为每个样本都在 <strong>单独的集合</strong> 里用户可以在任何时候调用如下两个方法：<pre><code>    **boolean isSameSet(V x, V y)** : 查询样本x和样本y是否属于一个集合    **void union(V x, V y)** : 把x和y各自所在集合的所有样本合并成一个集合</code></pre></li><li> isSameSet和union方法的代价越低越好, 最好O(1)</li></ol><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201214153822.png" alt="代表点"></p><p>结果若干union后，代表点不一样，就不是一个集合</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201214153934.png" alt="union后"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201214154334.png" alt="union操作"></p><p> <strong>小数量挂大数量，数量相等无所谓</strong> </p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201214154455.png" alt="union操作完毕"></p><p>1）每个节点都有一条往上指的指针<br>2）节点a往上找到的头节点，叫做a所在集合的代表节点<br>3）查询x和y是否属于同一个集合，就是看看找到的代表节点是不是一个<br>4）把x和y各自所在集合的所有点合并成一个集合，只需要小集合的代表点挂在大集合的代表点的下方即可</p><p>code:</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">V</span>&gt; </span>&#123;   V value;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(V v)</span> </span>&#123;      value = v;   &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnionSet</span>&lt;<span class="hljs-title">V</span>&gt; </span>&#123;   <span class="hljs-comment">// V -&gt; 结点 一一对应，建好后不会改动，记录对应关系</span>   <span class="hljs-keyword">public</span> HashMap&lt;V, Node&lt;V&gt;&gt; nodes;   <span class="hljs-keyword">public</span> HashMap&lt;Node&lt;V&gt;, Node&lt;V&gt;&gt; parents;   <span class="hljs-comment">// 代表点才会有记录</span>   <span class="hljs-keyword">public</span> HashMap&lt;Node&lt;V&gt;, Integer&gt; sizeMap;   <span class="hljs-comment">// 初始化过程</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UnionSet</span><span class="hljs-params">(List&lt;V&gt; values)</span> </span>&#123;      <span class="hljs-keyword">for</span> (V value : values) &#123;         Node&lt;V&gt; node = <span class="hljs-keyword">new</span> Node&lt;&gt;(value);         nodes.put(value, node);         <span class="hljs-comment">// 一开始每个点都为代表点 指向自己</span>         parents.put(node, node);         sizeMap.put(node, <span class="hljs-number">1</span>);      &#125;   &#125;   <span class="hljs-comment">// 从cur开始找，找到不能再往上找的代表点并返回</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> Node&lt;V&gt; <span class="hljs-title">findFather</span><span class="hljs-params">(Node&lt;V&gt; cur)</span> </span>&#123;      Stack&lt;Node&lt;V&gt;&gt; path = <span class="hljs-keyword">new</span> Stack&lt;&gt;();      <span class="hljs-keyword">while</span> (cur != parents.get(cur)) &#123;         path.push(cur);         cur = parents.get(cur);      &#125;      <span class="hljs-comment">// cur头节点</span>      <span class="hljs-keyword">while</span> (!path.isEmpty()) &#123;         parents.put(path.pop(), cur);      &#125;      <span class="hljs-keyword">return</span> cur;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSameSet</span><span class="hljs-params">(V a, V b)</span> </span>&#123;      <span class="hljs-keyword">if</span> (!nodes.containsKey(a) || !nodes.containsKey(b)) &#123;         <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;      &#125;      <span class="hljs-keyword">return</span> findFather(nodes.get(a)) == findFather(nodes.get(b));   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">union</span><span class="hljs-params">(V a, V b)</span> </span>&#123;      <span class="hljs-keyword">if</span> (!nodes.containsKey(a) || !nodes.containsKey(b)) &#123;         <span class="hljs-keyword">return</span>;      &#125;      Node&lt;V&gt; aHead = findFather(nodes.get(a));      Node&lt;V&gt; bHead = findFather(nodes.get(b));      <span class="hljs-keyword">if</span> (aHead != bHead) &#123;         <span class="hljs-keyword">int</span> aSetSize = sizeMap.get(aHead);         <span class="hljs-keyword">int</span> bSetSize = sizeMap.get(bHead);         <span class="hljs-keyword">if</span> (aSetSize &gt;= bSetSize) &#123;            parents.put(bHead, aHead);            sizeMap.put(aHead, aSetSize + bSetSize);            sizeMap.remove(bHead);         &#125; <span class="hljs-keyword">else</span> &#123;            parents.put(aHead, bHead);            sizeMap.put(bHead, aSetSize + bSetSize);            sizeMap.remove(aHead);         &#125;      &#125;   &#125;&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201214155250.png" alt="parent表和size表"></p><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>1）节点往上找代表点的过程，把沿途的链变成扁平的</p><p>2）小集合挂在大集合的下面</p><p>3）如果方法调用很频繁，那么单次调用的代价为O(1)，两个方法都如此</p><p>findFather()方法的优化:</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201214160644.png" alt="打扁平"></p><p>将原来串联起来，改变成father全指向代表点</p><p>往上找的过程是该算法的瓶颈，让找的方法变为O(1)即可。</p><p>解释了为什么 <strong>小挂大</strong> ，也减少了 <strong>遍历链的高度</strong> </p><h2 id="复杂度计算"><a href="#复杂度计算" class="headerlink" title="复杂度计算"></a>复杂度计算</h2><p>N个结点 -&gt; N个集合</p><p>find <strong>方法越频繁，代价越低</strong>。</p><p>当调用次数到达 O(n)或超过，单次调用的代价为O(1)。</p><h2 id="题"><a href="#题" class="headerlink" title="题"></a>题</h2><p>学生类有三个String属性，身份证，b站id，githubid，任何一个属性有一组一样就算一个人。</p><p>一大堆实例中有几个独立出来的人。</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201214162132.png" alt="例子"></p><p>所有实例进并查集，准备三张表，记录三个字段拥有者</p><p>当表中key相同时，并查集合并这两个实例。</p><p>最后看sizeMap的数。</p><p> <strong>解决连通性的利器</strong> </p><h2 id="并查集的应用"><a href="#并查集的应用" class="headerlink" title="并查集的应用"></a>并查集的应用</h2><p>解决两大块区域的合并问题</p><p>常用在图等领域中</p><h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><blockquote><p>不难在算法，难在结构</p></blockquote><p>1）由点的集合和边的集合构成</p><p>2）虽然存在有向图和无向图的概念，但实际上都可以用有向图来表达，无向图可以想象两条有向边</p><p>3）边上可能带有权值</p><h2 id="图结构的表达"><a href="#图结构的表达" class="headerlink" title="图结构的表达"></a>图结构的表达</h2><p>1）邻接表法</p><p>2）邻接矩阵法</p><p>3）除此之外还有其他众多的方式</p><p>邻接表法：记录能直接到达的点</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201215085231.png" alt="邻接表法"></p><p>邻接矩阵法：abcd列行填格子</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201215085523.png" alt="邻接矩阵"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201215085839.png" alt="另外的表达"></p><h2 id="图的面试题如何搞定"><a href="#图的面试题如何搞定" class="headerlink" title="图的面试题如何搞定"></a>图的面试题如何搞定</h2><p>图的算法都不算难，只不过coding的代价比较高</p><p>1）先用 <strong>自己最熟练的方式</strong> ，实现图结构的表达</p><p>2）在自己熟悉的结构上， <strong>实现所有常用的图算法作为模板</strong></p><p>3）把面试题 <strong>提供的图结构转化为自己熟悉的图结构</strong> ，再调用模板或改写即可</p><pre><code class="hljs java"><span class="hljs-comment">// 点结构描述</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;   <span class="hljs-comment">// 编号</span>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> value;   <span class="hljs-comment">// 入度 多少个点直接连向</span>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> in;   <span class="hljs-comment">// 出度 多少个点直接出向</span>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> out;   <span class="hljs-comment">// 直接邻居</span>   <span class="hljs-keyword">public</span> ArrayList&lt;Node&gt; nexts;   <span class="hljs-comment">// 边</span>   <span class="hljs-keyword">public</span> ArrayList&lt;Edge&gt; edges;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;      <span class="hljs-keyword">this</span>.value = value;      in = <span class="hljs-number">0</span>;      out = <span class="hljs-number">0</span>;      nexts = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();      edges = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();   &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-comment">// 边描述 无向图只是from to相同</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Edge</span> </span>&#123;   <span class="hljs-comment">// 权重</span>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> weight;   <span class="hljs-keyword">public</span> Node from;   <span class="hljs-keyword">public</span> Node to;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Edge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> weight, Node from, Node to)</span> </span>&#123;      <span class="hljs-keyword">this</span>.weight = weight;      <span class="hljs-keyword">this</span>.from = from;      <span class="hljs-keyword">this</span>.to = to;   &#125;&#125;</code></pre><p>图结构就出来了：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Graph</span> </span>&#123;   <span class="hljs-comment">// Integer表示Node里面的value编号</span>   <span class="hljs-keyword">public</span> HashMap&lt;Integer, Node&gt; nodes;   <span class="hljs-keyword">public</span> HashSet&lt;Edge&gt; edges;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Graph</span><span class="hljs-params">()</span> </span>&#123;      nodes = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();      edges = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();   &#125;&#125;</code></pre><blockquote><p>结构转化为上述第三图中矩阵N*3的图结构</p></blockquote><pre><code class="hljs java"><span class="hljs-comment">// matrix 所有的边</span><span class="hljs-comment">// N*3 的矩阵</span><span class="hljs-comment">// [weight, from节点上面的值，to节点上面的值]</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Graph <span class="hljs-title">createGraph</span><span class="hljs-params">(Integer[][] matrix)</span> </span>&#123;   Graph graph = <span class="hljs-keyword">new</span> Graph();   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; matrix.length; i++) &#123; <span class="hljs-comment">// matrix[0][0], matrix[0][1]  matrix[0][2]</span>      Integer from = matrix[i][<span class="hljs-number">0</span>];      Integer to = matrix[i][<span class="hljs-number">1</span>];      Integer weight = matrix[i][<span class="hljs-number">2</span>];      <span class="hljs-keyword">if</span> (!graph.nodes.containsKey(from)) &#123;         graph.nodes.put(from, <span class="hljs-keyword">new</span> Node(from));      &#125;      <span class="hljs-keyword">if</span> (!graph.nodes.containsKey(to)) &#123;         graph.nodes.put(to, <span class="hljs-keyword">new</span> Node(to));      &#125;      Node fromNode = graph.nodes.get(from);      Node toNode = graph.nodes.get(to);      Edge newEdge = <span class="hljs-keyword">new</span> Edge(weight, fromNode, toNode);      fromNode.nexts.add(toNode);      fromNode.out++;      toNode.in++;      fromNode.edges.add(newEdge);      graph.edges.add(newEdge);   &#125;   <span class="hljs-keyword">return</span> graph;&#125;</code></pre><h2 id="图的宽度优先-amp-深度优先遍历"><a href="#图的宽度优先-amp-深度优先遍历" class="headerlink" title="图的宽度优先&amp;深度优先遍历"></a>图的宽度优先&amp;深度优先遍历</h2><p>宽度优先遍历 (同一层内部的顺序可以无所谓)<br>1，利用 <strong>队列</strong> 实现<br>2，从源节点开始依次按照宽度进队列，然后弹出<br>3，每弹出一个点，把该节点 <strong>所有没有进过队列的邻接点放入队列</strong><br>4，直到队列变空</p><pre><code class="hljs java"><span class="hljs-comment">// 从node出发，进行宽度优先遍历</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(Node node)</span> </span>&#123;   <span class="hljs-keyword">if</span> (node == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span>;   &#125;   Queue&lt;Node&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();   <span class="hljs-comment">// 图会有环的问题，二叉树没有</span>   HashSet&lt;Node&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();   queue.add(node);   set.add(node);   <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;      Node cur = queue.poll();      <span class="hljs-comment">// 出打印</span>      System.out.println(cur.value);      <span class="hljs-keyword">for</span> (Node next : cur.nexts) &#123;         <span class="hljs-keyword">if</span> (!set.contains(next)) &#123;            set.add(next);            queue.add(next);         &#125;      &#125;   &#125;&#125;</code></pre><p>深度优先遍历<br>1，利用 <strong>栈</strong> 实现<br>2，从源节点开始把节点按照深度放入栈，然后弹出<br>3，每弹出一个点，把该节点 <strong>下一个没有进过栈的邻接点放入栈</strong><br>4，直到栈变空 </p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(Node node)</span> </span>&#123;   <span class="hljs-keyword">if</span> (node == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span>;   &#125;   <span class="hljs-comment">// 记录从头结点走到的路径</span>   Stack&lt;Node&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();   HashSet&lt;Node&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();   stack.add(node);   set.add(node);   System.out.println(node.value);   <span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;      Node cur = stack.pop();      <span class="hljs-keyword">for</span> (Node next : cur.nexts) &#123;         <span class="hljs-keyword">if</span> (!set.contains(next)) &#123;            <span class="hljs-comment">// 一条路走到不能再走直接返回</span>            stack.push(cur);            stack.push(next);            set.add(next);            <span class="hljs-comment">// 进去的时候打印</span>            System.out.println(next.value);            <span class="hljs-keyword">break</span>;         &#125;      &#125;   &#125;&#125;</code></pre><h2 id="图的拓扑排序算法-有向无环图"><a href="#图的拓扑排序算法-有向无环图" class="headerlink" title="图的拓扑排序算法(有向无环图)"></a>图的拓扑排序算法(有向无环图)</h2><p>1）在图中找到 <strong>所有入度为0</strong> 的点输出<br>2）把所有入度为0的点在图中 <strong>删掉</strong> ，继续找入度为0的点输出，周而复始<br>3）图的所有点都被删除后，依次输出的顺序就是拓扑排序</p><p>要求： <strong>有向图且其中没有环</strong><br>应用： <strong>事件安排</strong> 、 <strong>编译顺序</strong></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201215103658.png" alt="拓扑"></p><p>a、b、c、e、f、t</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201215104648.png" alt="循环依赖与图关系"></p><p>ABC各有各自的config，最终会变成有向无环图，如果有环，就形成了循环依赖。</p><p>拓扑排序从最底层包往上编译，最终编译出来。</p><pre><code class="hljs java"><span class="hljs-comment">// directed graph and no loop</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Node&gt; <span class="hljs-title">sortedTopology</span><span class="hljs-params">(Graph graph)</span> </span>&#123;   <span class="hljs-comment">// key：某一个node</span>   <span class="hljs-comment">// value：剩余的入度</span>   HashMap&lt;Node, Integer&gt; inMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();   <span class="hljs-comment">// 入度为0的点，才能进这个队列</span>   Queue&lt;Node&gt; zeroInQueue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();   <span class="hljs-keyword">for</span> (Node node : graph.nodes.values()) &#123;      inMap.put(node, node.in);      <span class="hljs-comment">// 有向无环图，一定会有入度为0的点</span>      <span class="hljs-keyword">if</span> (node.in == <span class="hljs-number">0</span>) &#123;         zeroInQueue.add(node);      &#125;   &#125;   <span class="hljs-comment">// 拓扑排序的结果，依次加入result</span>   List&lt;Node&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();   <span class="hljs-keyword">while</span> (!zeroInQueue.isEmpty()) &#123;      Node cur = zeroInQueue.poll();      result.add(cur);      <span class="hljs-keyword">for</span> (Node next : cur.nexts) &#123;         inMap.put(next, inMap.get(next) - <span class="hljs-number">1</span>);         <span class="hljs-keyword">if</span> (inMap.get(next) == <span class="hljs-number">0</span>) &#123;            zeroInQueue.add(next);         &#125;      &#125;   &#125;   <span class="hljs-keyword">return</span> result;&#125;</code></pre><h2 id="最小生成树算法之Kruskal"><a href="#最小生成树算法之Kruskal" class="headerlink" title="最小生成树算法之Kruskal"></a>最小生成树算法之Kruskal</h2><p>1）总是从 <strong>权值最小的边</strong> 开始考虑，依次考察权值依次变大的边<br>2）当前的边要么进入最小生成树的集合，要么丢弃<br>3）如果当前的边进入最小生成树的集合中不会形成环，就要当前边<br>4）如果当前的边进入最小生成树的集合中会形成环，就不要当前边<br>5）考察完所有边之后，最小生成树的集合也得到了</p><p>最小权值连通所有的点</p><p>流程：</p><p>所有的 <strong>边</strong> 根据 <strong>权值由小到大排序</strong> ，对边遍历，如果左右两头没有在同一个集合，union，如果在一个集合，淘汰。</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201215110718.png" alt="流程"></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Set&lt;Edge&gt; <span class="hljs-title">kruskalMST</span><span class="hljs-params">(Graph graph)</span> </span>&#123;   UnionFind unionFind = <span class="hljs-keyword">new</span> UnionFind();   unionFind.makeSets(graph.nodes.values());   PriorityQueue&lt;Edge&gt; priorityQueue = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;(<span class="hljs-keyword">new</span> EdgeComparator());   <span class="hljs-keyword">for</span> (Edge edge : graph.edges) &#123; <span class="hljs-comment">// M 条边</span>      priorityQueue.add(edge);  <span class="hljs-comment">// O(logM)</span>   &#125;   Set&lt;Edge&gt; result = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();   <span class="hljs-keyword">while</span> (!priorityQueue.isEmpty()) &#123; <span class="hljs-comment">// M 条边</span>      Edge edge = priorityQueue.poll(); <span class="hljs-comment">// O(logM)</span>      <span class="hljs-keyword">if</span> (!unionFind.isSameSet(edge.from, edge.to)) &#123; <span class="hljs-comment">// O(1)</span>         result.add(edge);         unionFind.union(edge.from, edge.to);      &#125;   &#125;   <span class="hljs-keyword">return</span> result;&#125;</code></pre><p>有向图有效，如果是 <strong>无向图，会少一半边</strong> ：</p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201215111956.png" alt="少一半边" style="zoom:50%;" /><p>每次只会union一次，下次不会再union</p><h2 id="最小生成树算法之Prim"><a href="#最小生成树算法之Prim" class="headerlink" title="最小生成树算法之Prim"></a>最小生成树算法之Prim</h2><p>1）可以从 <strong>任意节点</strong> 出发来寻找最小生成树<br>2）某个点加入到被选取的点中后，解锁这个点出发的所有新的边<br>3）在所有解锁的边中选最小的边，然后看看这个边会不会形成环<br>4）如果会，不要当前边，继续考察剩下解锁的边中最小的边，重复3）<br>5）如果不会，要当前边，将该边的指向点加入到被选取的点中，重复2）<br>6）当所有点都被选取，最小生成树就得到了</p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201215113103.png" alt="例子" style="zoom:33%;" /><p>a点被解锁，直接边被解锁，在可以被看到的边里选一个最小的边，看看边两侧有没有新结点，解锁，没有新结点抛弃。c被解锁，已经选过的边不被重复解锁，b被解锁，边被解锁，找到所有解锁的边最小继续解锁…一直到所有点被解锁</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201215113614.png" alt="结果"></p><p>总是一个一个点进，而不是一大片结合，所以一个set即可。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Set&lt;Edge&gt; <span class="hljs-title">primMST</span><span class="hljs-params">(Graph graph)</span> </span>&#123;   <span class="hljs-comment">// 解锁的边进入小根堆</span>   PriorityQueue&lt;Edge&gt; priorityQueue = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;(         <span class="hljs-keyword">new</span> EdgeComparator());   HashSet&lt;Node&gt; nodeSet = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();   <span class="hljs-comment">// 防止边重复</span>   HashSet&lt;Edge&gt; edgeSet = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();   Set&lt;Edge&gt; result = <span class="hljs-keyword">new</span> HashSet&lt;&gt;(); <span class="hljs-comment">// 依次挑选的的边在result里</span>   <span class="hljs-keyword">for</span> (Node node : graph.nodes.values()) &#123; <span class="hljs-comment">// 随便挑了一个点</span>   <span class="hljs-comment">// for循环防森林</span>      <span class="hljs-comment">// node 是开始点</span>      <span class="hljs-keyword">if</span> (!set.contains(node)) &#123;         set.add(node);         <span class="hljs-keyword">for</span> (Edge edge : node.edges) &#123; <span class="hljs-comment">// 由一个点，解锁所有相连的边</span>            <span class="hljs-keyword">if</span> (!edgeSet.contains(edge))&#123;               edgeSet.add(edge);               priorityQueue.add(edge);            &#125;         &#125;         <span class="hljs-keyword">while</span> (!priorityQueue.isEmpty()) &#123;            Edge edge = priorityQueue.poll(); <span class="hljs-comment">// 弹出解锁的边中，最小的边</span>            Node toNode = edge.to; <span class="hljs-comment">// 可能的一个新的点</span>            <span class="hljs-keyword">if</span> (!set.contains(toNode)) &#123; <span class="hljs-comment">// 不含有的时候，就是新的点</span>               set.add(toNode);               result.add(edge);               <span class="hljs-keyword">for</span> (Edge nextEdge : toNode.edges) &#123;                  <span class="hljs-keyword">if</span> (!edgeSet.contains(nextEdge))&#123;                     edgeSet.add(nextEdge);                     priorityQueue.add(nextEdge);                  &#125;               &#125;            &#125;         &#125;      &#125;      <span class="hljs-comment">//break;</span>   &#125;   <span class="hljs-keyword">return</span> result;&#125;</code></pre><h2 id="Dijkstra算法-是一种贪心"><a href="#Dijkstra算法-是一种贪心" class="headerlink" title="Dijkstra算法(是一种贪心)"></a>Dijkstra算法(是一种贪心)</h2><p>1）Dijkstra算法必须指定一个源点<br>2）生成一个源点到各个点的最小距离表，一开始只有一条记录，即原点到自己的最小距离为0，源点到其他所有点的最小距离都为正无穷大</p><p>​ <img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201216085732.png" alt="初始表" style="zoom:50%;" /></p><p>3）从距离表中拿出没拿过记录里的最小记录，通过这个点发出的边，更新源点到各个点的最小距离表，不断重复这一步</p><p>​ <img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201216085957.png" alt="更新一次" style="zoom:50%;" /></p><p>​ 选B再更新…. 注： <strong>使用完的记录，要锁住</strong></p><p>4）源点到所有的点记录如果都被拿过一遍，过程停止，最小距离表得到了</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201216085032.png" alt="最小距离表"></p><p> <strong>权值为正数，如果出现负数，环问题可能没有解</strong></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> HashMap&lt;Node, Integer&gt; <span class="hljs-title">dijkstra1</span><span class="hljs-params">(Node from)</span> </span>&#123;   <span class="hljs-comment">// 从from出发到所有点的最小距离</span>   <span class="hljs-comment">// key : 从head出发到达key</span>   <span class="hljs-comment">// value : 从head出发到达key的最小距离</span>   <span class="hljs-comment">// 如果在表中，没有T的记录，含义是从head出发到T这个点的距离为正无穷</span>   HashMap&lt;Node, Integer&gt; distanceMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();   distanceMap.put(from, <span class="hljs-number">0</span>);   <span class="hljs-comment">// 已经求过距离的节点，存在selectedNodes中，以后再也不碰</span>   HashSet&lt;Node&gt; selectedNodes = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();   <span class="hljs-comment">// 选择最小距离且没有被锁住的点</span>   Node minNode = getMinDistanceAndUnselectedNode(distanceMap, selectedNodes);   <span class="hljs-keyword">while</span> (minNode != <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">int</span> distance = distanceMap.get(minNode);      <span class="hljs-keyword">for</span> (Edge edge : minNode.edges) &#123;         Node toNode = edge.to;         <span class="hljs-keyword">if</span> (!distanceMap.containsKey(toNode)) &#123;            distanceMap.put(toNode, distance + edge.weight);         &#125; <span class="hljs-keyword">else</span> &#123;            distanceMap.put(edge.to, Math.min(distanceMap.get(toNode), distance + edge.weight));         &#125;      &#125;      selectedNodes.add(minNode);      minNode = getMinDistanceAndUnselectedNode(distanceMap, selectedNodes);   &#125;   <span class="hljs-keyword">return</span> distanceMap;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">getMinDistanceAndUnselectedNode</span><span class="hljs-params">(HashMap&lt;Node, Integer&gt; distanceMap, HashSet&lt;Node&gt; touchedNodes)</span> </span>&#123;   <span class="hljs-comment">// touchedNodes为selectedNodes</span>   <span class="hljs-comment">// 找到最小且未被锁住的点</span>   Node minNode = <span class="hljs-keyword">null</span>;   <span class="hljs-keyword">int</span> minDistance = Integer.MAX_VALUE;   <span class="hljs-keyword">for</span> (Entry&lt;Node, Integer&gt; entry : distanceMap.entrySet()) &#123;      Node node = entry.getKey();      <span class="hljs-keyword">int</span> distance = entry.getValue();      <span class="hljs-keyword">if</span> (!touchedNodes.contains(node) &amp;&amp; distance &lt; minDistance) &#123;         minNode = node;         minDistance = distance;      &#125;   &#125;   <span class="hljs-keyword">return</span> minNode;&#125;</code></pre><h3 id="小根堆优化"><a href="#小根堆优化" class="headerlink" title="小根堆优化"></a>小根堆优化</h3><p>上述的算法中，for (Entry&lt;Node, Integer&gt; entry : distanceMap.entrySet())这段代码需要对当前取出的结点的下面所有点进行 <strong>遍历</strong>，可以使用一个小根堆，每次取出的就是最小。</p><p>原来是遍历哈希表 O(N) 现在是小根堆 O(logN)</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NodeRecord</span> </span>&#123;   <span class="hljs-keyword">public</span> Node node;   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> distance;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NodeRecord</span><span class="hljs-params">(Node node, <span class="hljs-keyword">int</span> distance)</span> </span>&#123;      <span class="hljs-keyword">this</span>.node = node;      <span class="hljs-keyword">this</span>.distance = distance;   &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NodeHeap</span> </span>&#123;   <span class="hljs-keyword">private</span> Node[] nodes; <span class="hljs-comment">// 实际的堆结构</span>   <span class="hljs-comment">// key 某一个node， value 上面数组中的位置  -1表示曾经进来过</span>   <span class="hljs-keyword">private</span> HashMap&lt;Node, Integer&gt; heapIndexMap;   <span class="hljs-comment">// key 某一个节点， value 从源节点出发到该节点的目前最小距离</span>   <span class="hljs-keyword">private</span> HashMap&lt;Node, Integer&gt; distanceMap;   <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size; <span class="hljs-comment">// 堆上有多少个点</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NodeHeap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> size)</span> </span>&#123;      nodes = <span class="hljs-keyword">new</span> Node[size];      heapIndexMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();      distanceMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();      size = <span class="hljs-number">0</span>;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> size == <span class="hljs-number">0</span>;   &#125;   <span class="hljs-comment">// 有一个点叫node，现在发现了一个从源节点出发到达node的距离为distance</span>   <span class="hljs-comment">// 判断要不要更新，如果需要的话，就更新</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addOrUpdateOrIgnore</span><span class="hljs-params">(Node node, <span class="hljs-keyword">int</span> distance)</span> </span>&#123;      <span class="hljs-keyword">if</span> (inHeap(node)) &#123;         distanceMap.put(node, Math.min(distanceMap.get(node), distance));         insertHeapify(node, heapIndexMap.get(node));      &#125;      <span class="hljs-keyword">if</span> (!isEntered(node)) &#123;         nodes[size] = node;         heapIndexMap.put(node, size);         distanceMap.put(node, distance);         insertHeapify(node, size++);      &#125;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> NodeRecord <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;      NodeRecord nodeRecord = <span class="hljs-keyword">new</span> NodeRecord(nodes[<span class="hljs-number">0</span>], distanceMap.get(nodes[<span class="hljs-number">0</span>]));      swap(<span class="hljs-number">0</span>, size - <span class="hljs-number">1</span>);      heapIndexMap.put(nodes[size - <span class="hljs-number">1</span>], -<span class="hljs-number">1</span>);      distanceMap.remove(nodes[size - <span class="hljs-number">1</span>]);      <span class="hljs-comment">// free C++同学还要把原本堆顶节点析构，对java同学不必</span>      nodes[size - <span class="hljs-number">1</span>] = <span class="hljs-keyword">null</span>;      heapify(<span class="hljs-number">0</span>, --size);      <span class="hljs-keyword">return</span> nodeRecord;   &#125;   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertHeapify</span><span class="hljs-params">(Node node, <span class="hljs-keyword">int</span> index)</span> </span>&#123;      <span class="hljs-keyword">while</span> (distanceMap.get(nodes[index]) &lt; distanceMap.get(nodes[(index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>])) &#123;         swap(index, (index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>);         index = (index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;      &#125;   &#125;   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">heapify</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> size)</span> </span>&#123;      <span class="hljs-keyword">int</span> left = index * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;      <span class="hljs-keyword">while</span> (left &lt; size) &#123;         <span class="hljs-keyword">int</span> smallest = left + <span class="hljs-number">1</span> &lt; size &amp;&amp; distanceMap.get(nodes[left + <span class="hljs-number">1</span>]) &lt; distanceMap.get(nodes[left])               ? left + <span class="hljs-number">1</span>               : left;         smallest = distanceMap.get(nodes[smallest]) &lt; distanceMap.get(nodes[index]) ? smallest : index;         <span class="hljs-keyword">if</span> (smallest == index) &#123;            <span class="hljs-keyword">break</span>;         &#125;         swap(smallest, index);         index = smallest;         left = index * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;      &#125;   &#125;   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEntered</span><span class="hljs-params">(Node node)</span> </span>&#123;      <span class="hljs-keyword">return</span> heapIndexMap.containsKey(node);   &#125;   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">inHeap</span><span class="hljs-params">(Node node)</span> </span>&#123;      <span class="hljs-keyword">return</span> isEntered(node) &amp;&amp; heapIndexMap.get(node) != -<span class="hljs-number">1</span>;   &#125;   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index1, <span class="hljs-keyword">int</span> index2)</span> </span>&#123;      heapIndexMap.put(nodes[index1], index2);      heapIndexMap.put(nodes[index2], index1);      Node tmp = nodes[index1];      nodes[index1] = nodes[index2];      nodes[index2] = tmp;   &#125;&#125;<span class="hljs-comment">// 改进后的dijkstra算法</span><span class="hljs-comment">// 从head出发，所有head能到达的节点，生成到达每个节点的最小路径记录并返回</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> HashMap&lt;Node, Integer&gt; <span class="hljs-title">dijkstra2</span><span class="hljs-params">(Node head, <span class="hljs-keyword">int</span> size)</span> </span>&#123;   NodeHeap nodeHeap = <span class="hljs-keyword">new</span> NodeHeap(size);   nodeHeap.addOrUpdateOrIgnore(head, <span class="hljs-number">0</span>);   HashMap&lt;Node, Integer&gt; result = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();   <span class="hljs-keyword">while</span> (!nodeHeap.isEmpty()) &#123;      NodeRecord record = nodeHeap.pop();      Node cur = record.node;      <span class="hljs-keyword">int</span> distance = record.distance;      <span class="hljs-keyword">for</span> (Edge edge : cur.edges) &#123;         nodeHeap.addOrUpdateOrIgnore(edge.to, edge.weight + distance);      &#125;      result.put(cur, distance);   &#125;   <span class="hljs-keyword">return</span> result;&#125;</code></pre><h1 id="暴力递归"><a href="#暴力递归" class="headerlink" title="暴力递归"></a>暴力递归</h1><blockquote><p> 暴力递归就是尝试 </p></blockquote><p>1，把问题转化为规模缩小了的同类问题的子问题<br>2，有明确的不需要继续进行递归的条件(base case)<br>3，有当得到了子问题的结果之后的决策过程<br>4， <strong>不记录</strong>每一个子问题的解，记录就是 <strong>动态规划</strong> </p><h2 id="熟悉什么叫尝试？"><a href="#熟悉什么叫尝试？" class="headerlink" title="熟悉什么叫尝试？"></a>熟悉什么叫尝试？</h2><ul><li><p>打印n层汉诺塔从最左边移动到最右边的全部过程（2^n -1 步）</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201216104132.png" alt="汉诺塔"></p></li></ul><p>​ 思路：1 - N-1个挪到中间，第N个挪到最右边，1 - N-1挪到最右边</p><blockquote><p>细化递归过程的代码:</p></blockquote><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hanoi1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;   leftToRight(n);&#125;<span class="hljs-comment">// 把 1 - N层圆盘从左移动到右</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">leftToRight</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;   <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;      System.out.println(<span class="hljs-string">&quot;Move 1 from left to right&quot;</span>);      <span class="hljs-keyword">return</span>;   &#125;   leftToMid(n - <span class="hljs-number">1</span>);   System.out.println(<span class="hljs-string">&quot;Move &quot;</span> + n + <span class="hljs-string">&quot; from left to right&quot;</span>);   midToRight(n - <span class="hljs-number">1</span>);&#125;<span class="hljs-comment">// 腾出空间</span><span class="hljs-comment">// 移动最底</span><span class="hljs-comment">// 移动其他</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">leftToMid</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;   <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;      System.out.println(<span class="hljs-string">&quot;Move 1 from left to mid&quot;</span>);      <span class="hljs-keyword">return</span>;   &#125;   leftToRight(n - <span class="hljs-number">1</span>);   System.out.println(<span class="hljs-string">&quot;Move &quot;</span> + n + <span class="hljs-string">&quot; from left to mid&quot;</span>);   rightToMid(n - <span class="hljs-number">1</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rightToMid</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;   <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;      System.out.println(<span class="hljs-string">&quot;Move 1 from right to mid&quot;</span>);      <span class="hljs-keyword">return</span>;   &#125;   rightToLeft(n - <span class="hljs-number">1</span>);   System.out.println(<span class="hljs-string">&quot;Move &quot;</span> + n + <span class="hljs-string">&quot; from right to mid&quot;</span>);   leftToMid(n - <span class="hljs-number">1</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">midToRight</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;   <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;      System.out.println(<span class="hljs-string">&quot;Move 1 from mid to right&quot;</span>);      <span class="hljs-keyword">return</span>;   &#125;   midToLeft(n - <span class="hljs-number">1</span>);   System.out.println(<span class="hljs-string">&quot;Move &quot;</span> + n + <span class="hljs-string">&quot; from mid to right&quot;</span>);   leftToRight(n - <span class="hljs-number">1</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">midToLeft</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;   <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;      System.out.println(<span class="hljs-string">&quot;Move 1 from mid to left&quot;</span>);      <span class="hljs-keyword">return</span>;   &#125;   midToRight(n - <span class="hljs-number">1</span>);   System.out.println(<span class="hljs-string">&quot;Move &quot;</span> + n + <span class="hljs-string">&quot; from mid to left&quot;</span>);   rightToLeft(n - <span class="hljs-number">1</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rightToLeft</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;   <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;      System.out.println(<span class="hljs-string">&quot;Move 1 from right to left&quot;</span>);      <span class="hljs-keyword">return</span>;   &#125;   rightToMid(n - <span class="hljs-number">1</span>);   System.out.println(<span class="hljs-string">&quot;Move &quot;</span> + n + <span class="hljs-string">&quot; from right to left&quot;</span>);   midToLeft(n - <span class="hljs-number">1</span>);&#125;</code></pre><p>为每个移动过程都描述过程。</p><blockquote><p>如果忽略左中右，直接from to other代替全部</p></blockquote><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hanoi2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;   <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">0</span>) &#123;      func(n, <span class="hljs-string">&quot;left&quot;</span>, <span class="hljs-string">&quot;right&quot;</span>, <span class="hljs-string">&quot;mid&quot;</span>);   &#125;&#125;<span class="hljs-comment">// 1~i 圆盘 目标是from -&gt; to， other是另外一个</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span> N, String from, String to, String other)</span> </span>&#123;   <span class="hljs-keyword">if</span> (N == <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// base</span>      System.out.println(<span class="hljs-string">&quot;Move 1 from &quot;</span> + from + <span class="hljs-string">&quot; to &quot;</span> + to);   &#125; <span class="hljs-keyword">else</span> &#123;      func(N - <span class="hljs-number">1</span>, from, other, to);      System.out.println(<span class="hljs-string">&quot;Move &quot;</span> + N + <span class="hljs-string">&quot; from &quot;</span> + from + <span class="hljs-string">&quot; to &quot;</span> + to);      func(N - <span class="hljs-number">1</span>, other, to, from);   &#125;&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201216111446.png" alt="过程"></p><pre><code class="hljs livecodeserver">打印过程：Move <span class="hljs-number">1</span> <span class="hljs-built_in">from</span> left <span class="hljs-built_in">to</span> <span class="hljs-literal">right</span>Move <span class="hljs-number">2</span> <span class="hljs-built_in">from</span> left <span class="hljs-built_in">to</span> <span class="hljs-keyword">mid</span>Move <span class="hljs-number">1</span> <span class="hljs-built_in">from</span> <span class="hljs-literal">right</span> <span class="hljs-built_in">to</span> <span class="hljs-keyword">mid</span>Move <span class="hljs-number">3</span> <span class="hljs-built_in">from</span> left <span class="hljs-built_in">to</span> <span class="hljs-literal">right</span>Move <span class="hljs-number">1</span> <span class="hljs-built_in">from</span> <span class="hljs-keyword">mid</span> <span class="hljs-built_in">to</span> leftMove <span class="hljs-number">2</span> <span class="hljs-built_in">from</span> <span class="hljs-keyword">mid</span> <span class="hljs-built_in">to</span> <span class="hljs-literal">right</span>Move <span class="hljs-number">1</span> <span class="hljs-built_in">from</span> left <span class="hljs-built_in">to</span> <span class="hljs-literal">right</span></code></pre><ul><li><p>打印一个字符串的全部子序列</p><p> <strong>子串</strong> 必须连续。子序列不需要连续，但相对次序不能乱。</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201217083355.png" alt="子串"></p></li></ul><p>  <img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201217083652.png" alt="子序列每个都可以选择要或不要"></p>  <pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;String&gt; <span class="hljs-title">subs</span><span class="hljs-params">(String s)</span> </span>&#123;   <span class="hljs-keyword">char</span>[] str = s.toCharArray();   String path = <span class="hljs-string">&quot;&quot;</span>;   List&lt;String&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();   process1(str, <span class="hljs-number">0</span>, ans, path);   <span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-comment">// str为原始字符串</span><span class="hljs-comment">// index此时来到的位置</span><span class="hljs-comment">// 如果index来到终止位置 路径所形成的答案放到ans中</span><span class="hljs-comment">// 之前做出的选择，就是path</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process1</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] str, <span class="hljs-keyword">int</span> index, List&lt;String&gt; ans, String path)</span> </span>&#123;   <span class="hljs-keyword">if</span> (index == str.length) &#123;      ans.add(path);      <span class="hljs-keyword">return</span>;   &#125;   String no = path;   process1(str, index + <span class="hljs-number">1</span>, ans, no);   String yes = path + String.valueOf(str[index]);   process1(str, index + <span class="hljs-number">1</span>, ans, yes);&#125;</code></pre><ul><li><p>打印一个字符串的全部子序列，要求不要出现重复字面值的子序列</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process2</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] str, <span class="hljs-keyword">int</span> index, HashSet&lt;String&gt; set, String path)</span> </span>&#123;   <span class="hljs-keyword">if</span> (index == str.length) &#123;      set.add(path);      <span class="hljs-keyword">return</span>;   &#125;   String no = path;   process2(str, index + <span class="hljs-number">1</span>, set, no);   String yes = path + String.valueOf(str[index]);   process2(str, index + <span class="hljs-number">1</span>, set, yes);&#125;</code></pre></li></ul><ul><li><p>打印一个字符串的全部排列</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201217085722.png" alt="不用额外空间尝试"></p><p>只需要一个数组，让index所到位置后面所有字符都到该位置一次</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ArrayList&lt;String&gt; <span class="hljs-title">permutation</span><span class="hljs-params">(String str)</span> </span>&#123;   ArrayList&lt;String&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();   <span class="hljs-keyword">if</span> (str == <span class="hljs-keyword">null</span> || str.length() == <span class="hljs-number">0</span>) &#123;      <span class="hljs-keyword">return</span> res;   &#125;   <span class="hljs-keyword">char</span>[] chs = str.toCharArray();   process(chs, <span class="hljs-number">0</span>, res);   <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-comment">// str[0..i-1]已经做好决定</span><span class="hljs-comment">// str[i...]后的都有机会来到i位置</span><span class="hljs-comment">// i来到终止位置，全部做好决定，已经排列好</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] str, <span class="hljs-keyword">int</span> i, ArrayList&lt;String&gt; res)</span> </span>&#123;   <span class="hljs-keyword">if</span> (i == str.length) &#123;      res.add(String.valueOf(str));   &#125;  <span class="hljs-comment">// i没有到终止位置，i往后所有位置来到i位置</span>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i; j &lt; str.length; j++) &#123;      swap(str, i, j);      process(str, i + <span class="hljs-number">1</span>, res);     <span class="hljs-comment">// 恢复现场</span>      swap(str, i, j);   &#125;&#125;</code></pre></li></ul><ul><li><p>打印一个字符串的全部排列，要求不要出现重复的排列</p><p>直接在上面代码改为set，是暴力递归 ➕ 过滤</p><p>但如果使用分支限界方法不一样，在执行过程前杀死支路。</p><pre><code class="hljs java"><span class="hljs-comment">// 分支限界方法</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ArrayList&lt;String&gt; <span class="hljs-title">permutationNoRepeat</span><span class="hljs-params">(String str)</span> </span>&#123;   ArrayList&lt;String&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();   <span class="hljs-keyword">if</span> (str == <span class="hljs-keyword">null</span> || str.length() == <span class="hljs-number">0</span>) &#123;      <span class="hljs-keyword">return</span> res;   &#125;   <span class="hljs-keyword">char</span>[] chs = str.toCharArray();   process2(chs, <span class="hljs-number">0</span>, res);   <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process2</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] str, <span class="hljs-keyword">int</span> i, ArrayList&lt;String&gt; res)</span> </span>&#123;   <span class="hljs-keyword">if</span> (i == str.length) &#123;      res.add(String.valueOf(str));   &#125;     <span class="hljs-comment">// x位置有没有使用过</span>   <span class="hljs-keyword">boolean</span>[] visit = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[<span class="hljs-number">26</span>]; <span class="hljs-comment">// visit[0 1 .. 25]</span>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i; j &lt; str.length; j++) &#123;      <span class="hljs-keyword">if</span> (!visit[str[j] - <span class="hljs-string">&#x27;a&#x27;</span>]) &#123;         visit[str[j] - <span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-keyword">true</span>;         swap(str, i, j);         process2(str, i + <span class="hljs-number">1</span>, res);         swap(str, i, j);      &#125;   &#125;&#125;</code></pre></li></ul><h2 id="仰望好的尝试？"><a href="#仰望好的尝试？" class="headerlink" title="仰望好的尝试？"></a>仰望好的尝试？</h2><p>给你一个栈，请你 <strong>逆序</strong> 这个栈，<br>不能申请额外的数据结构，<br>只能使用递归函数。 如何实现? </p><p>f函数功能: 把栈底元素抽离</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201216114416.png" alt="流程"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201216114856.png" alt="reverse流程"></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reverse</span><span class="hljs-params">(Stack&lt;Integer&gt; stack)</span> </span>&#123;   <span class="hljs-keyword">if</span> (stack.isEmpty()) &#123;      <span class="hljs-keyword">return</span>;   &#125;   <span class="hljs-keyword">int</span> i = f(stack);   reverse(stack);   stack.push(i);&#125;<span class="hljs-comment">// 功能： 莫名其妙把栈底元素搞没了 还返回了</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">(Stack&lt;Integer&gt; stack)</span> </span>&#123;   <span class="hljs-keyword">int</span> result = stack.pop();   <span class="hljs-keyword">if</span> (stack.isEmpty()) &#123;      <span class="hljs-keyword">return</span> result;   &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-keyword">int</span> last = f(stack);      stack.push(result);      <span class="hljs-keyword">return</span> last;   &#125;&#125;</code></pre><h2 id="从左往右的尝试模型1"><a href="#从左往右的尝试模型1" class="headerlink" title="从左往右的尝试模型1"></a>从左往右的尝试模型1</h2><h2 id="从左往右的尝试模型2"><a href="#从左往右的尝试模型2" class="headerlink" title="从左往右的尝试模型2"></a>从左往右的尝试模型2</h2><h2 id="范围上尝试的模型"><a href="#范围上尝试的模型" class="headerlink" title="范围上尝试的模型"></a>范围上尝试的模型</h2><h2 id="人过河问题"><a href="#人过河问题" class="headerlink" title="人过河问题"></a>人过河问题</h2><p>假设河里有鳄鱼，吃人后非常虚弱，虚弱后同时也会被其他鳄鱼吃，考虑人是否应该过河。假设鱼都绝顶聪明。</p><p>当鱼 <strong>偶数</strong> 时，可以过河；</p><p>鱼为 <strong>奇数</strong> 时，不能过河；</p><h2 id="海盗分硬币问题思考"><a href="#海盗分硬币问题思考" class="headerlink" title="海盗分硬币问题思考"></a>海盗分硬币问题思考</h2><p>假设有 100 个硬币， ABCDE五人分并依次提议，当赞成数大于等于一半时，提议成功，否则会被杀死。</p><p>思考：</p><p>如果只有 <strong>E一个人</strong> ，一百个硬币全部归 E；</p><p>如果只有 <strong>DE</strong> 两个人，只要E投反对票，D就会被杀死，所以100硬币全部归E；</p><p>如果只有 <strong>CDE三个人</strong>， 只要C被投死，D也一定死，所以D为了存活只能投C，C获得100硬币；</p><p>如果只有 <strong>BCDE四个人</strong>， B知道D、E没有硬币，所以给D、E各一个，自己98个，就能拉到票；</p><p>当 <strong>ABCDE</strong> 时，A知道C没有，给c一个，知道D、E只有一个，只需要给一个人两个硬币就行，所以自己97个；</p><h2 id="欧拉信封问题"><a href="#欧拉信封问题" class="headerlink" title="欧拉信封问题"></a>欧拉信封问题</h2><p>一个村子有N个人，每个人能寄出一封信，也能收到一封信，但不能是自己，问有多少种方法寄收。</p><p>当只有 1 个人时，寄收方法为0；</p><p>当有 2 个人时，寄收方法为1；</p><p>当有 3 个人时，ABC，如果A寄给B，B只能寄给C，一种；A寄给C，C只能寄给B，一种；一共 2 种方法；</p><p>当有 5 个人时，ABCDE，假设是B寄给E，如果E寄给B，剩下三个人玩欧拉信封问题，就有f(3)；假设E不寄给B，EB就可以看为一个整体，一条出度，一条入度，变成四个人玩欧拉信封问题，就有f(4)；</p><p>B一共能寄给4种，所以 4 * ( f(3) + f(4) )</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201218104738.png" alt="N = 5"></p><p>结果为 f(n) = (n - 1) * ( f(n - 2) + f(n - 1) )</p><h2 id="N皇后"><a href="#N皇后" class="headerlink" title="N皇后"></a>N皇后</h2><p>N皇后问题是指在 *<em>N</em>N的棋盘上** 要 <strong>摆N个</strong> 皇后，<br>要求任何两个皇后不同行、不同列， 也不在同一条斜线上<br>给定一个整数n，返回n皇后的摆法有多少种。n=1，返回1<br>n=2或3，2皇后和3皇后问题无论怎么摆都不行，返回0<br>n=8，返回92</p><p> <strong>每行放一个，不会存在行上攻击问题</strong> ，</p><p> <strong>判断下一行与其它行斜线是否合法</strong>： 如果点分别为(a, b) (c, d) 判断 <strong>|a-c| == |b-d|</strong> </p><p>Code1:</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">num1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;   <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">1</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;   &#125;   <span class="hljs-comment">// record[0] ?  record[1]  ?  record[2]</span>   <span class="hljs-keyword">int</span>[] record = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n]; <span class="hljs-comment">// record[i] -&gt; i行的皇后，放在了第几列</span>   <span class="hljs-keyword">return</span> process1(<span class="hljs-number">0</span>, record, n);&#125;<span class="hljs-comment">// 潜台词：record[0..i-1]的皇后，任何两个皇后一定都不共行、不共列，不共斜线</span><span class="hljs-comment">// 目前来到了第i行</span><span class="hljs-comment">// record[0..i-1]表示之前的行，放了的皇后位置，index可以描述行数，value为列树</span><span class="hljs-comment">// n代表整体一共有多少行</span><span class="hljs-comment">// 返回值是，摆完所有的皇后，合理的摆法有多少种</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">process1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span>[] record, <span class="hljs-keyword">int</span> n)</span> </span>&#123;   <span class="hljs-keyword">if</span> (i == n) &#123; <span class="hljs-comment">// 终止行，行数从0开始算</span>      <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;   &#125;   <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;   <span class="hljs-comment">// j为列</span>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123; <span class="hljs-comment">// 当前行在i行，尝试i行所有的列  -&gt; j</span>      <span class="hljs-comment">// 判断当前i行的皇后，放在j列，会不会和之前(0..i-1)的皇后，不共行共列或者共斜线，</span>      <span class="hljs-comment">// 如果是，认为有效</span>      <span class="hljs-comment">// 如果不是，认为无效</span>      <span class="hljs-keyword">if</span> (isValid(record, i, j)) &#123;         <span class="hljs-comment">// record不用还原，数组可以直接覆盖</span>         record[i] = j;         res += process1(i + <span class="hljs-number">1</span>, record, n);      &#125;   &#125;   <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-comment">// record[0..i-1]你需要看，record[i...]不需要看</span><span class="hljs-comment">// 返回i行皇后，放在了j列，是否有效</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValid</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] record, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; i; k++) &#123; <span class="hljs-comment">// 之前的某个k行的皇后</span>      <span class="hljs-comment">// (k, record[k])  现在的 (i, j)</span>      <span class="hljs-keyword">if</span> (j == record[k] || Math.abs(record[k] - j) == Math.abs(i - k)) &#123;         <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;      &#125;   &#125;   <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;&#125;</code></pre><blockquote><p>可以进行 <strong>常数项</strong> 优化</p></blockquote><p>初始变量:</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201218113922.png" alt="初始变量"></p><p>如果放第一个：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201218114358.png" alt="放第一个到0位置"></p><p>如果放第一个到4位置：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201218114723.png" alt="放4位置"></p><p> <strong>把三个limit 或运算，就是下一行能够放的位置</strong> </p><p> 如果第一行放4位置，第二行放1位置，限制变成</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201218135309.png" alt="放第二个到1位置"></p><p>左limit对比第一次，就是先在第一个位置放皇后，01010000后，左移一位，变成10100000</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201218135531.png" alt="放第二个后的右限制"></p><p>右limit对比第一次，就是先在第一个位置放皇后，01000100后，右移一位，变成00100010；</p><p>下次皇后位置，就为三个limit或起来：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201218135851.png" alt="下次可放位置"></p><p>Code2:</p><pre><code class="hljs java"><span class="hljs-comment">// 请不要超过32皇后问题</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">num2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;   <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">1</span> || n &gt; <span class="hljs-number">32</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;   &#125;   <span class="hljs-comment">// n皇后问题，limit后面有多少个1</span>   <span class="hljs-comment">// 比如8皇后问题，1左移8位 8个0， 减1后 8个1</span>   <span class="hljs-keyword">int</span> limit = n == <span class="hljs-number">32</span> ? -<span class="hljs-number">1</span> : (<span class="hljs-number">1</span> &lt;&lt; n) - <span class="hljs-number">1</span>;   <span class="hljs-keyword">return</span> process2(limit, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);&#125;<span class="hljs-comment">// limit划定问题规模 永远不变</span><span class="hljs-comment">// colLim 列的限制，1的位置不能放皇后，0的位置可以</span><span class="hljs-comment">// leftDiaLim 左斜线的限制，1的位置不能放皇后，0的位置可以</span><span class="hljs-comment">// rightDiaLim 右斜线的限制，1的位置不能放皇后，0的位置可以</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">process2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> limit, </span></span><span class="hljs-function"><span class="hljs-params">      <span class="hljs-keyword">int</span> colLim, </span></span><span class="hljs-function"><span class="hljs-params">      <span class="hljs-keyword">int</span> leftDiaLim,</span></span><span class="hljs-function"><span class="hljs-params">      <span class="hljs-keyword">int</span> rightDiaLim)</span> </span>&#123;   <span class="hljs-keyword">if</span> (colLim == limit) &#123; <span class="hljs-comment">// base case</span>      <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;   &#125;   <span class="hljs-comment">// 所有候选皇后的位置，都在pos上</span>   <span class="hljs-comment">// colLim | leftDiaLim | rightDiaLim -&gt; 总限制</span>   <span class="hljs-comment">// ~(colLim | leftDiaLim | rightDiaLim)右边为1可摆，但前面都是1</span>   <span class="hljs-comment">// limit &amp; 让左侧变为0，也可以让左移超边界的1限制变0，防止干扰</span>   <span class="hljs-keyword">int</span> pos = limit &amp; (~(colLim | leftDiaLim | rightDiaLim));   <span class="hljs-keyword">int</span> mostRightOne = <span class="hljs-number">0</span>;   <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;   <span class="hljs-comment">// pos为0 表示没有位置放了</span>   <span class="hljs-keyword">while</span> (pos != <span class="hljs-number">0</span>) &#123;      <span class="hljs-comment">// 找最右边的1</span>      mostRightOne = pos &amp; (~pos + <span class="hljs-number">1</span>);      pos = pos - mostRightOne;      res += process2(limit,             colLim | mostRightOne,            (leftDiaLim | mostRightOne) &lt;&lt; <span class="hljs-number">1</span>,            (rightDiaLim | mostRightOne) &gt;&gt;&gt; <span class="hljs-number">1</span>);   &#125;   <span class="hljs-keyword">return</span> res;&#125;</code></pre><p>![如何找到能放皇后的位置，且代表1] (<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201218140919.png" alt="image-20201218140916545">)</p><h3 id="如果要输出怎么办？"><a href="#如果要输出怎么办？" class="headerlink" title="如果要输出怎么办？"></a>如果要输出怎么办？</h3><p>leetcode原题：</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;List&lt;String&gt;&gt; solveNQueens(<span class="hljs-keyword">int</span> n) &#123;        <span class="hljs-keyword">char</span>[][] chess = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[n][n];        <span class="hljs-comment">//初始化数组</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)                chess[i][j] = <span class="hljs-string">&#x27;.&#x27;</span>;        List&lt;List&lt;String&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        solve(res, chess, <span class="hljs-number">0</span>);        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(List&lt;List&lt;String&gt;&gt; res, <span class="hljs-keyword">char</span>[][] chess, <span class="hljs-keyword">int</span> row)</span> </span>&#123;        <span class="hljs-keyword">if</span> (row == chess.length) &#123;            System.out.println(chess.length);            res.add(construct(chess));            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> col = <span class="hljs-number">0</span>; col &lt; chess.length; col++) &#123;            <span class="hljs-keyword">if</span> (valid(chess, row, col)) &#123;                chess[row][col] = <span class="hljs-string">&#x27;Q&#x27;</span>;                solve(res, chess, row + <span class="hljs-number">1</span>);                chess[row][col] = <span class="hljs-string">&#x27;.&#x27;</span>;            &#125;        &#125;    &#125;    <span class="hljs-comment">//row表示第几行，col表示第几列</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">valid</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] chess, <span class="hljs-keyword">int</span> row, <span class="hljs-keyword">int</span> col)</span> </span>&#123;        <span class="hljs-comment">//判断当前列有没有皇后,因为他是一行一行往下走的，</span>        <span class="hljs-comment">//我们只需要检查走过的行数即可，通俗一点就是判断当前</span>        <span class="hljs-comment">//坐标位置的上面有没有皇后</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; row; i++) &#123;            <span class="hljs-keyword">if</span> (chess[i][col] == <span class="hljs-string">&#x27;Q&#x27;</span>) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;        &#125;        <span class="hljs-comment">//判断当前坐标的右上角有没有皇后</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = row - <span class="hljs-number">1</span>, j = col + <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &lt; chess.length; i--, j++) &#123;            <span class="hljs-keyword">if</span> (chess[i][j] == <span class="hljs-string">&#x27;Q&#x27;</span>) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;        &#125;        <span class="hljs-comment">//判断当前坐标的左上角有没有皇后</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = row - <span class="hljs-number">1</span>, j = col - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span>; i--, j--) &#123;            <span class="hljs-keyword">if</span> (chess[i][j] == <span class="hljs-string">&#x27;Q&#x27;</span>) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-comment">//把数组转为list</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List&lt;String&gt; <span class="hljs-title">construct</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] chess)</span> </span>&#123;        List&lt;String&gt; path = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; chess.length; i++) &#123;            path.add(<span class="hljs-keyword">new</span> String(chess[i]));        &#125;        <span class="hljs-keyword">return</span> path;    &#125;&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201218151905.png" alt="暴力递归存在的问题"></p><p>有很多重复过程</p><p>你可以用一个数组，记录数列前几项，类似于 <strong>缓存</strong> 。</p><h2 id="暴力到动态规划-题目一"><a href="#暴力到动态规划-题目一" class="headerlink" title="暴力到动态规划(题目一)"></a>暴力到动态规划(题目一)</h2><p>假设有排成一行的N个位置，记为1<del>N，N 一定大于或等于 2<br>开始时机器人在其中的M位置上(M 一定是 1</del>N 中的一个)<br>如果机器人来到1位置，那么下一步只能往右来到2位置；<br>如果机器人来到N位置，那么下一步只能往左来到 N-1 位置；<br>如果机器人来到中间位置，那么下一步可以往左走或者往右走；<br>规定机器人必须走 K 步，最终能来到P位置(P也是1~N中的一个)的方法有多少种<br>给定四个参数 N、M、K、P，返回方法数。</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201219132935.png" alt="流程"></p><blockquote><p>暴力代码</p></blockquote><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">ways1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> N, <span class="hljs-keyword">int</span> M, <span class="hljs-keyword">int</span> K, <span class="hljs-keyword">int</span> P)</span> </span>&#123;   <span class="hljs-comment">// 参数无效直接返回0</span>   <span class="hljs-keyword">if</span> (N &lt; <span class="hljs-number">2</span> || K &lt; <span class="hljs-number">1</span> || M &lt; <span class="hljs-number">1</span> || M &gt; N || P &lt; <span class="hljs-number">1</span> || P &gt; N) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;   &#125;   <span class="hljs-comment">// 总共N个位置，从M点出发，还剩K步，返回最终能达到P的方法数</span>   <span class="hljs-keyword">return</span> walk(N, M, K, P);&#125;<span class="hljs-comment">// N : 位置为1 ~ N，固定参数</span><span class="hljs-comment">// cur : 当前在cur位置，可变参数</span><span class="hljs-comment">// rest : 还剩res步没有走，可变参数</span><span class="hljs-comment">// P : 最终目标位置是P，固定参数</span><span class="hljs-comment">// 该函数的含义：只能在1~N这些位置上移动，当前在cur位置，走完rest步之后，停在P位置的方法数作为返回值返回</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">walk</span><span class="hljs-params">(<span class="hljs-keyword">int</span> N, <span class="hljs-keyword">int</span> cur, <span class="hljs-keyword">int</span> rest, <span class="hljs-keyword">int</span> P)</span> </span>&#123;   <span class="hljs-comment">// 如果没有剩余步数了，当前的cur位置就是最后的位置</span>   <span class="hljs-comment">// 如果最后的位置停在P上，那么之前做的移动是有效的</span>   <span class="hljs-comment">// 如果最后的位置没在P上，那么之前做的移动是无效的</span>   <span class="hljs-keyword">if</span> (rest == <span class="hljs-number">0</span>) &#123;      <span class="hljs-keyword">return</span> cur == P ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;   &#125;   <span class="hljs-comment">// 如果还有rest步要走，而当前的cur位置在1位置上，那么当前这步只能从1走向2</span>   <span class="hljs-comment">// 后续的过程就是，来到2位置上，还剩rest-1步要走</span>   <span class="hljs-keyword">if</span> (cur == <span class="hljs-number">1</span>) &#123;      <span class="hljs-keyword">return</span> walk(N, <span class="hljs-number">2</span>, rest - <span class="hljs-number">1</span>, P);   &#125;   <span class="hljs-comment">// 如果还有rest步要走，而当前的cur位置在N位置上，那么当前这步只能从N走向N-1</span>   <span class="hljs-comment">// 后续的过程就是，来到N-1位置上，还剩rest-1步要走</span>   <span class="hljs-keyword">if</span> (cur == N) &#123;      <span class="hljs-keyword">return</span> walk(N, N - <span class="hljs-number">1</span>, rest - <span class="hljs-number">1</span>, P);   &#125;   <span class="hljs-comment">// 如果还有rest步要走，而当前的cur位置在中间位置上，那么当前这步可以走向左，也可以走向右</span>   <span class="hljs-comment">// 走向左之后，后续的过程就是，来到cur-1位置上，还剩rest-1步要走</span>   <span class="hljs-comment">// 走向右之后，后续的过程就是，来到cur+1位置上，还剩rest-1步要走</span>   <span class="hljs-comment">// 走向左、走向右是截然不同的方法，所以总方法数要都算上</span>   <span class="hljs-keyword">return</span> walk(N, cur + <span class="hljs-number">1</span>, rest - <span class="hljs-number">1</span>, P) + walk(N, cur - <span class="hljs-number">1</span>, rest - <span class="hljs-number">1</span>, P);&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201219150216.png" alt="有重复过程"></p><blockquote><p>缓存式(记忆化搜索) 动态规划代码</p></blockquote><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">waysCache</span><span class="hljs-params">(<span class="hljs-keyword">int</span> N, <span class="hljs-keyword">int</span> M, <span class="hljs-keyword">int</span> K, <span class="hljs-keyword">int</span> P)</span> </span>&#123;   <span class="hljs-keyword">if</span> (N &lt; <span class="hljs-number">2</span> || K &lt; <span class="hljs-number">1</span> || M &lt; <span class="hljs-number">1</span> || M &gt; N || P &lt; <span class="hljs-number">1</span> || P &gt; N) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;   &#125;   <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[N + <span class="hljs-number">1</span>][K + <span class="hljs-number">1</span>];   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> row = <span class="hljs-number">0</span>; row &lt;= N; row++)&#123;      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> col = <span class="hljs-number">0</span>; col &lt;= N; col++)&#123;         dp[row][col] = -<span class="hljs-number">1</span>;      &#125;   &#125;   <span class="hljs-keyword">return</span> walkCache(N, M, K, P, dp);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">walkCache</span><span class="hljs-params">(<span class="hljs-keyword">int</span> N, <span class="hljs-keyword">int</span> cur, <span class="hljs-keyword">int</span> rest, <span class="hljs-keyword">int</span> P, <span class="hljs-keyword">int</span>[][] dp)</span> </span>&#123;   <span class="hljs-keyword">if</span> (dp[cur][rest] != -<span class="hljs-number">1</span>)&#123;      <span class="hljs-keyword">return</span> d[cur][rest];   &#125;      <span class="hljs-keyword">if</span> (rest == <span class="hljs-number">0</span>) &#123;      dp[cur][rest] = cur == P ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;      <span class="hljs-keyword">return</span> dp[cur][rest];   &#125;   <span class="hljs-keyword">if</span> (cur == <span class="hljs-number">1</span>) &#123;      dp[cur][rest] = walkCache(N, <span class="hljs-number">2</span>, rest - <span class="hljs-number">1</span>, P, dp);      <span class="hljs-keyword">return</span> dp[cur][rest];   &#125;   <span class="hljs-keyword">if</span> (cur == N) &#123;      dp[cur][rest] = walkCache(N, N - <span class="hljs-number">1</span>, rest - <span class="hljs-number">1</span>, P, dp);      <span class="hljs-keyword">return</span> dp[cur][rest]   &#125;   dp[cur][rest] =  walkCache(N, cur + <span class="hljs-number">1</span>, rest - <span class="hljs-number">1</span>, P, dp) + walkCache(N, cur - <span class="hljs-number">1</span>, rest - <span class="hljs-number">1</span>, P, dp);   <span class="hljs-keyword">return</span> dp[cur][rest];&#125;</code></pre><blockquote><p>依赖关系猜想</p></blockquote><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201219152445.png" alt="依赖过程"></p><p>可见每个普通位置都依赖左上和左下，由下方暴力代码猜想而来：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201219152543.png" alt="暴力代码依赖性"></p><p>最后直接靠 <strong>依赖</strong> 就能得到结果：</p><p>![依赖]（<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201219152752.png" alt="image-20201219152743937"></p><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><blockquote><p>暴力递归中有重复运算过程，才建议改为动态规划</p></blockquote><h2 id="什么暴力递归可以继续优化？"><a href="#什么暴力递归可以继续优化？" class="headerlink" title="什么暴力递归可以继续优化？"></a>什么暴力递归可以继续优化？</h2><p>有重复调用同一个子问题的解，这种递归可以优化<br>如果每一个子问题都是不同的解，无法优化也不用优化</p><h2 id="暴力递归和动态规划的关系"><a href="#暴力递归和动态规划的关系" class="headerlink" title="暴力递归和动态规划的关系"></a>暴力递归和动态规划的关系</h2><p>某一个暴力递归，有解的重复调用，就可以把这个暴力递归优化成动态规划</p><p>任何动态规划问题，都一定对应着某一个有解的重复调用的暴力递归</p><p>但不是所有的暴力递归，都一定对应着动态规划</p><h2 id="面试题和动态规划的关系"><a href="#面试题和动态规划的关系" class="headerlink" title="面试题和动态规划的关系"></a>面试题和动态规划的关系</h2><p>解决一个问题，可能有很多尝试方法</p><p>可能在很多尝试方法中，又有若干个尝试方法有动态规划的方式</p><p>一个问题   可能有   若干种动态规划的解法</p><h2 id="如何找到某个问题的动态规划方式？"><a href="#如何找到某个问题的动态规划方式？" class="headerlink" title="如何找到某个问题的动态规划方式？"></a>如何找到某个问题的动态规划方式？</h2><p>1）设计暴力递归：重要原则+4种常见尝试模型！重点！</p><p>2）分析有没有重复解：套路解决</p><p>3）用记忆化搜索 -&gt; 用严格表结构实现动态规划：套路解决</p><p>4）看看能否继续优化：套路解决</p><h2 id="面试中设计暴力递归过程的原则"><a href="#面试中设计暴力递归过程的原则" class="headerlink" title="面试中设计暴力递归过程的原则"></a>面试中设计暴力递归过程的原则</h2><p>1）每一个可变参数的类型，一定不要比int类型更加复杂</p><p>​   一个int可变参数，dp一维表；</p><p>​   两个int可变参数，dp二维表；</p><p>​   ……</p><p>2）原则1）可以违反，让类型突破到一维线性结构，那必须是单一可变参数（如贴纸拼接问题用到字符串）</p><p>3）如果发现原则1）被违反，但不违反原则2），只需要做到记忆化搜索即可（如贴纸拼接问题不写dp）</p><p>4）可变参数的个数，能少则少</p><h2 id="常见的4种尝试模型"><a href="#常见的4种尝试模型" class="headerlink" title="常见的4种尝试模型"></a>常见的4种尝试模型</h2><p>1）从左往右的尝试模型</p><p>2）范围上的尝试模型</p><p>3）多样本位置全对应的尝试模型</p><p>4）寻找业务限制的尝试模型</p><h2 id="暴力递归到动态规划的套路"><a href="#暴力递归到动态规划的套路" class="headerlink" title="暴力递归到动态规划的套路"></a>暴力递归到动态规划的套路</h2><p>1）你已经有了一个不违反原则的暴力递归，而且的确存在解的重复调用<br>2）找到哪些参数的变化会影响返回值，对每一个列出变化范围<br>3）参数间的所有的组合数量，意味着表大小<br>4）记忆化搜索的方法就是傻缓存，非常容易得到<br>5）规定好严格表的大小，分析位置的依赖顺序，然后从基础填写到最终解<br>6）对于有枚举行为的决策过程，进一步优化</p><h2 id="知道了面试中设计暴力递归过程的原则，然后呢？"><a href="#知道了面试中设计暴力递归过程的原则，然后呢？" class="headerlink" title="知道了面试中设计暴力递归过程的原则，然后呢？"></a>知道了面试中设计暴力递归过程的原则，然后呢？</h2><p>一定要逼自己找到不违反原则情况下的暴力尝试！</p><p>如果你找到的暴力尝试，不符合原则，马上舍弃！找新的！</p><p>如果某个题目突破了设计原则，一定极难极难，面试中出现概率低于5%！</p><h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201220141419.png" alt="暴力代码"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201220141827.png" alt="例子"></p><p>选1,2不选3和选3不选1,2最后都会再算一遍f(3, 17)</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201220142425.png" alt="初始位置"></p><p>函数调用(0, bag) 即(0, restMax)</p><p>由暴力递归得 rest&lt;0,无效；index == w.len, 为0</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201220143712.png" alt="更改过程"></p><p>code:</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">dpWay</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] w, <span class="hljs-keyword">int</span>[] v, <span class="hljs-keyword">int</span> bag)</span> </span>&#123;   <span class="hljs-keyword">int</span> N = w.length;   <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[N + <span class="hljs-number">1</span>][bag + <span class="hljs-number">1</span>];   <span class="hljs-comment">// dp[N][...] = 0,本来初始化就为0</span>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> index = N - <span class="hljs-number">1</span>; index &gt;= <span class="hljs-number">0</span>; index--) &#123;      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> rest = <span class="hljs-number">1</span>; rest &lt;= bag; rest++) &#123;         dp[index][rest] = dp[index + <span class="hljs-number">1</span>][rest];         <span class="hljs-keyword">if</span> (rest &gt;= w[index]) &#123;            dp[index][rest] = Math.max(dp[index][rest], v[index] + dp[index + <span class="hljs-number">1</span>][rest - w[index]]);         &#125;      &#125;   &#125;   <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][bag];&#125;</code></pre><h2 id="数字转化字符串问题"><a href="#数字转化字符串问题" class="headerlink" title="数字转化字符串问题"></a>数字转化字符串问题</h2><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201220145024.png" alt="原code"></p><p>搭框架</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201220145312.png" alt="框架"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201220145223.png" alt="return"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201220145438.png" alt="填"></p><p>code:</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">dpWays</span><span class="hljs-params">(String s)</span> </span>&#123;   <span class="hljs-keyword">if</span> (s == <span class="hljs-keyword">null</span> || s.length() == <span class="hljs-number">0</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;   &#125;   <span class="hljs-keyword">char</span>[] str = s.toCharArray();   <span class="hljs-keyword">int</span> N = str.length;   <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[N + <span class="hljs-number">1</span>];   dp[N] = <span class="hljs-number">1</span>;   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = N - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;      <span class="hljs-keyword">if</span> (str[i] == <span class="hljs-string">&#x27;0&#x27;</span>) &#123;         dp[i] = <span class="hljs-number">0</span>;      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (str[i] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;         dp[i] = dp[i + <span class="hljs-number">1</span>];         <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span> &lt; N) &#123;            dp[i] += dp[i + <span class="hljs-number">2</span>];         &#125;      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (str[i] == <span class="hljs-string">&#x27;2&#x27;</span>) &#123;         dp[i] = dp[i + <span class="hljs-number">1</span>];          <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span> &lt; str.length &amp;&amp; (str[i + <span class="hljs-number">1</span>] &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; str[i + <span class="hljs-number">1</span>] &lt;= <span class="hljs-string">&#x27;6&#x27;</span>)) &#123;            dp[i] += dp[i + <span class="hljs-number">2</span>];         &#125;      &#125; <span class="hljs-keyword">else</span> &#123;         dp[i] = dp[i + <span class="hljs-number">1</span>];      &#125;   &#125;   <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>];&#125;</code></pre><h2 id="AB取卡牌问题"><a href="#AB取卡牌问题" class="headerlink" title="AB取卡牌问题"></a>AB取卡牌问题</h2><p>原code:</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201220150438.png" alt="image-20201220150436084"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201220151842.png" alt="由暴力递归得"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201220152133.png" alt="由暴力递归得到关系图"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201220152246.png" alt="依赖推出"></p><p>code:</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">windp</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;   <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length == <span class="hljs-number">0</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;   &#125;   <span class="hljs-keyword">int</span> N = arr.length;   <span class="hljs-keyword">int</span>[][] f = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[N][N];   <span class="hljs-keyword">int</span>[][] s = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[N][N];   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;      f[i][i] = arr[i];   &#125;   <span class="hljs-comment">// 0,0 右下方移动</span>   <span class="hljs-comment">// 0,1</span>   <span class="hljs-comment">// 0,2</span>   <span class="hljs-comment">// 0,N-1</span>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> col = <span class="hljs-number">1</span>; col &lt; N; col++) &#123;      <span class="hljs-comment">// 对角线出发位置(0,col)</span>      <span class="hljs-keyword">int</span> L = <span class="hljs-number">0</span>;      <span class="hljs-keyword">int</span> R = col;      <span class="hljs-keyword">while</span> (L &lt; N &amp;&amp; R &lt; N) &#123;         f[L][R] = Math.max(arr[L] + s[L + <span class="hljs-number">1</span>][R], arr[R] + s[L][R - <span class="hljs-number">1</span>]);         s[L][R] = Math.min(f[L + <span class="hljs-number">1</span>][R], f[L][R - <span class="hljs-number">1</span>]);         L++;         R++;      &#125;   &#125;   <span class="hljs-keyword">return</span> Math.max(f[<span class="hljs-number">0</span>][N - <span class="hljs-number">1</span>], s[<span class="hljs-number">0</span>][N - <span class="hljs-number">1</span>]);&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201220153643.png" alt="动态规划"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201220154023.png" alt="动态规划时间复杂度"></p><blockquote><p>对于记忆化搜索：</p></blockquote><p>如果一个问题依赖的子状态是有限个，不用枚举，时间复杂度和经典动态规划是一致的。</p><p>如果有枚举问题，应该改为经典动态规划。</p><h2 id="货币数组问题"><a href="#货币数组问题" class="headerlink" title="货币数组问题"></a>货币数组问题</h2><p>一个arr中都是正数，无重复值，arr中对应货币面值，给你一个num，用arr中组成num的方法数。</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201220154742.png" alt="问题"></p><p>递归定义：f(i, rest) 表示arr[i]之后的面值随意使用，搞定rest</p><pre><code class="hljs java"><span class="hljs-comment">// arr中都是正数且无重复值，返回组成aim的方法数</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">ways</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> aim)</span> </span>&#123;   <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length == <span class="hljs-number">0</span> || aim &lt; <span class="hljs-number">0</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;   &#125;   <span class="hljs-keyword">return</span> process(arr, <span class="hljs-number">0</span>, aim);&#125;<span class="hljs-comment">// 如果自由使用arr[index...]的面值，组成rest这么多钱，返回方法数 （1 , 6）</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">process</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> rest)</span> </span>&#123;   <span class="hljs-comment">// 下面的if在process中保证了rest不会小于0</span>     <span class="hljs-comment">//if (rest &lt;0)&#123;</span>   <span class="hljs-comment">//   return 0;</span>   <span class="hljs-comment">//&#125;</span>   <span class="hljs-keyword">if</span> (index == arr.length) &#123; <span class="hljs-comment">// 无面值的时候</span>      <span class="hljs-keyword">return</span> rest == <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;   &#125;   <span class="hljs-comment">// 有面值的时候</span>   <span class="hljs-keyword">int</span> ways = <span class="hljs-number">0</span>;   <span class="hljs-comment">// arr[index] 当钱面值</span>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> zhang = <span class="hljs-number">0</span>; zhang * arr[index] &lt;= rest; zhang++) &#123;      ways += process(arr, index + <span class="hljs-number">1</span>, rest - zhang * arr[index]);   &#125;   <span class="hljs-keyword">return</span> ways;&#125;</code></pre><blockquote><p>记忆划搜索</p></blockquote><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201220164211.png" alt="code"></p><blockquote><p>经典动态规划</p></blockquote><p>普通由记忆化搜索改的动态规划：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201220172428.png" alt="普通方法"></p><p> <strong>有枚举行为</strong> </p><p>再次查看依赖关系：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201220173132.png" alt="依赖关系"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201220173312.png" alt="依赖"></p><p>星号值依赖b、c…. </p><p>问号值依赖a、b、c…..</p><p>但求问好值，要先求星号值，优化后就是当前 = 左边 加 下面</p><p>优化的dp：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">waysdp</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> aim)</span> </span>&#123;   <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length == <span class="hljs-number">0</span> || aim &lt; <span class="hljs-number">0</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;   &#125;   <span class="hljs-keyword">int</span> N = arr.length;   <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[N + <span class="hljs-number">1</span>][aim + <span class="hljs-number">1</span>];   dp[N][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = N - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123; <span class="hljs-comment">// 大顺序 从下往上</span>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> rest = <span class="hljs-number">0</span>; rest &lt;= aim; rest++) &#123;         dp[i][rest] = dp[i + <span class="hljs-number">1</span>][rest];         <span class="hljs-keyword">if</span> (rest - arr[i] &gt;= <span class="hljs-number">0</span>) &#123;            <span class="hljs-comment">// 加左 加下</span>            dp[i][rest] += dp[i][rest - arr[i]];         &#125;      &#125;   &#125;   <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][aim];&#125;</code></pre><p>如果所有钞票都是百位数，建议记忆化搜索，因为dp是细粒度的记录（比如上述rest循环中，rest &lt;= aim 对每个都遍历）。</p><h2 id="贴纸字符串问题-题目二"><a href="#贴纸字符串问题-题目二" class="headerlink" title="贴纸字符串问题(题目二)"></a>贴纸字符串问题(题目二)</h2><p>给定一个字符串str，给定一个字符串类型的数组arr。<br>arr里的每一个字符串，代表一张贴纸，你可以把单个字符剪开使用，目的是拼出str来。<br>返回需要至少多少张贴纸可以完成这个任务。<br>例子：str= “babac”，arr = {“ba”,”c”,”abcd”}<br>至少需要两张贴纸”ba”和”abcd”，因为使用这两张贴纸，把每一个字符单独剪开，含有2个a、2个b、1个c。是可以拼出str的。所以返回2。</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201221085330.png" alt="暴力枚举"></p><blockquote><p>解题思路一</p></blockquote><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201221085853.png" alt="暴力法"></p><p>还需要 <strong>过滤</strong> 判断字符是否全在arr，也要 <strong>过滤</strong> 没有出现在rest中的字符，被arr选中，无限递归。</p><p>用二维数组存储贴纸</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201221090644.png" alt="存储格式"></p><p>“baabk”代表第一个贴纸，则arr[0]表示完整字符串，index0表示a出现的次数。</p><p>Code1:</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minStickers1</span><span class="hljs-params">(String[] stickers, String target)</span> </span>&#123;   <span class="hljs-keyword">int</span> n = stickers.length;   <span class="hljs-keyword">int</span>[][] map = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n][<span class="hljs-number">26</span>];   <span class="hljs-comment">// 傻缓存</span>   HashMap&lt;String, Integer&gt; dp = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();   <span class="hljs-comment">// 生成每张贴纸的词频统计</span>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;      <span class="hljs-keyword">char</span>[] str = stickers[i].toCharArray();      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : str) &#123;         map[i][c - <span class="hljs-string">&#x27;a&#x27;</span>]++;      &#125;   &#125;   dp.put(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-number">0</span>);   <span class="hljs-keyword">return</span> process1(dp, map, target);&#125;<span class="hljs-comment">// dp 傻缓存，如果t已经算过了，直接返回dp中的值</span><span class="hljs-comment">// t 剩余的目标</span><span class="hljs-comment">// 0..N每一个字符串所含字符的词频统计</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">process1</span><span class="hljs-params">(HashMap&lt;String, Integer&gt; dp, <span class="hljs-keyword">int</span>[][] map, String rest)</span> </span>&#123;   <span class="hljs-keyword">if</span> (dp.containsKey(rest)) &#123;      <span class="hljs-keyword">return</span> dp.get(rest);   &#125;   <span class="hljs-keyword">int</span> ans = Integer.MAX_VALUE; <span class="hljs-comment">// 使用贴纸数</span>   <span class="hljs-keyword">int</span> n = map.length; <span class="hljs-comment">// n种贴纸</span>   <span class="hljs-comment">// rest词频统计</span>   <span class="hljs-keyword">int</span>[] tmap = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">26</span>];   <span class="hljs-keyword">char</span>[] target = rest.toCharArray();   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : target) &#123;      tmap[c - <span class="hljs-string">&#x27;a&#x27;</span>]++;   &#125;   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;      <span class="hljs-comment">// 找到第一个共同字符词频</span>      <span class="hljs-keyword">if</span> (map[i][target[<span class="hljs-number">0</span>] - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-number">0</span>) &#123;         <span class="hljs-keyword">continue</span>;      &#125;      StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();      <span class="hljs-comment">// 来到第i个贴纸，j枚举从贴纸里面的变化</span>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">26</span>; j++) &#123;         <span class="hljs-comment">// 关于j这个字符，target词频数目大于0</span>         <span class="hljs-keyword">if</span> (tmap[j] &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// j这个字符是target需要的</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; Math.max(<span class="hljs-number">0</span>, tmap[j] - map[i][j]); k++) &#123;               <span class="hljs-comment">// 剪掉贴纸该字符的词频，还剩余多少，存到StringBuilder里面</span>               sb.append((<span class="hljs-keyword">char</span>) (<span class="hljs-string">&#x27;a&#x27;</span> + j));            &#125;         &#125;      &#125;      String s = sb.toString();      <span class="hljs-keyword">int</span> tmp = process1(dp, map, s);      <span class="hljs-keyword">if</span> (tmp != -<span class="hljs-number">1</span>) &#123;         ans = Math.min(ans, <span class="hljs-number">1</span> + tmp);      &#125;   &#125;   dp.put(rest, ans == Integer.MAX_VALUE ? -<span class="hljs-number">1</span> : ans);   <span class="hljs-keyword">return</span> dp.get(rest);&#125;</code></pre><blockquote><p>解题思路二</p></blockquote><p>每次选择不选择全部，先把第一个贴纸用N张，再第二张….类似于货币数组问题</p><p> <strong>不推荐</strong> 可变参数多，可变参数少的， <strong>缓存</strong> 命中率高。</p><h2 id="两个字符串的最长公共子序列问题（第三种模型）"><a href="#两个字符串的最长公共子序列问题（第三种模型）" class="headerlink" title="两个字符串的最长公共子序列问题（第三种模型）"></a>两个字符串的最长公共子序列问题（第三种模型）</h2><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201221121850.png" alt="猜想"></p><p>我们首先认为 dp[i] [j]为str1[0 ~ i]和str2[0 ~ j]的最长公共子序列</p><p>最后求 <strong>右下角</strong></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201221123945.png" alt="求解过程"></p><p>取str1的第一个和后面依次对比</p><p>更改测试用例str2为 12dea3f</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201221124306.png" alt="结果"></p><p>因为str1只拿出一个字符，只要出现了a，后面全是 1</p><p>再改第一列</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201221124459.png" alt="第一列"></p><blockquote><p>第一种情况</p></blockquote><p>既不以str1[i]结尾也不以str2[j]结尾，与i，j无关</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201221124659.png" alt="可能1"></p><p>就是str[i-1] [j-1], 来自于左上角。</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201221125134.png" alt="对应"></p><p> <strong>dp[i - 1] [j - 1]</strong> </p><blockquote><p>第二种情况</p></blockquote><p>以str1[i]结尾但不以str2[j]结尾</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201221125249.png" alt="例子"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201221125350.png" alt="结果"></p><p> <strong>dp[i] [j - 1]</strong></p><blockquote><p>第三种情况</p></blockquote><p>不以str1[i]结尾但以str2[j]结尾</p><p> <strong>dp[i - 1] [j ]</strong></p><blockquote><p>第四种情况</p></blockquote><p>以str1[i]结尾又以str2[j]结尾</p><p>可能条件只有 str1[i] == str2[j]</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201221125724.png" alt="结果"></p><p> <strong>1 + dp[i - 1] [j - 1]</strong></p><p>code:</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lcse</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] str1, <span class="hljs-keyword">char</span>[] str2)</span> </span>&#123;   <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[str1.length][str2.length];   <span class="hljs-comment">// 第一个字符是否相等</span>   dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = str1[<span class="hljs-number">0</span>] == str2[<span class="hljs-number">0</span>] ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;   <span class="hljs-comment">// 做第0列</span>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; str1.length; i++) &#123;      dp[i][<span class="hljs-number">0</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], str1[i] == str2[<span class="hljs-number">0</span>] ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>);   &#125;   <span class="hljs-comment">// 做第0行</span>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; str2.length; j++) &#123;      dp[<span class="hljs-number">0</span>][j] = Math.max(dp[<span class="hljs-number">0</span>][j - <span class="hljs-number">1</span>], str1[<span class="hljs-number">0</span>] == str2[j] ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>);   &#125;   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; str1.length; i++) &#123;      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; str2.length; j++) &#123;         dp[i][j] = Math.max(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]);         <span class="hljs-comment">// 最后在i也在j</span>         <span class="hljs-keyword">if</span> (str1[i] == str2[j]) &#123;            dp[i][j] = Math.max(dp[i][j], dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>);            <span class="hljs-comment">// 既不在i也不在j</span>         &#125;<span class="hljs-keyword">else</span> &#123;            dp[i][j] = Math.max(dp[i][j], dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]);         &#125;      &#125;   &#125;   <span class="hljs-keyword">return</span> dp[str1.length - <span class="hljs-number">1</span>][str2.length - <span class="hljs-number">1</span>];&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201221130629.png" alt="结果"></p><p>可能性2一定比1大，所以else是可以取出的</p><h2 id="咖啡刷杯子问题（第四种模型）"><a href="#咖啡刷杯子问题（第四种模型）" class="headerlink" title="咖啡刷杯子问题（第四种模型）"></a>咖啡刷杯子问题（第四种模型）</h2><p>给定一个数组，代表每个人喝完咖啡准备刷杯子的时间<br>只有一台咖啡机，一次只能洗一个杯子，时间耗费a，洗完才能洗下一杯<br>每个咖啡杯也可以自己挥发干净，时间耗费b，咖啡杯可以并行挥发<br>返回让所有咖啡杯变干净的最早完成时间<br>三个参数：int[] arr、int a、int b</p><pre><code class="hljs java"><span class="hljs-comment">// a 洗咖啡机所需时间</span><span class="hljs-comment">// b 自然挥发时间</span><span class="hljs-comment">// drinks每一个员工喝完咖啡时间</span><span class="hljs-comment">// drinks[0...index - 1] 已经洗完</span><span class="hljs-comment">// washLine机器什么时候可用</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">process</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] drinks, <span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> washLine)</span> </span>&#123;   <span class="hljs-keyword">if</span> (index == drinks.length - <span class="hljs-number">1</span>) &#123;      <span class="hljs-keyword">return</span> Math.min(            <span class="hljs-comment">// （咖啡机有空时间点 和 我喝完时间点） 的最大值 + 机器洗完</span>            Math.max(washLine, drinks[index]) + a,            <span class="hljs-comment">// 喝完时间点 + 挥发完时间</span>            drinks[index] + b);   &#125;   <span class="hljs-comment">// wash是我当前的咖啡杯，洗完的时间</span>   <span class="hljs-keyword">int</span> wash = Math.max(washLine, drinks[index]) + a;   <span class="hljs-comment">// 让index + 1以及后面所有咖啡杯变干净的最早时间</span>   <span class="hljs-keyword">int</span> next1 = process(drinks, a, b, index + <span class="hljs-number">1</span>, wash);   <span class="hljs-comment">// 既要自己洗完 也要其他都洗完 才能整体都完</span>   <span class="hljs-keyword">int</span> p1 = Math.max(wash, next1);   <span class="hljs-comment">// 去挥发</span>   <span class="hljs-keyword">int</span> dry = drinks[index] + b;   <span class="hljs-keyword">int</span> next2 = process(drinks, a, b, index + <span class="hljs-number">1</span>, washLine);   <span class="hljs-keyword">int</span> p2 = Math.max(dry, next2);   <span class="hljs-keyword">return</span> Math.min(p1, p2);&#125;</code></pre><p>改为动态规划：</p><p>int washLine寻求最夸张的值（全洗）</p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201221144225.png" alt="初始化dp" style="zoom:50%;" /><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201221144423.png" alt="定数"></p>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring Cloud 学习笔记</title>
    <link href="/2020/11/18/Spring%20Cloud%20%E5%AD%A6%E4%B9%A0/"/>
    <url>/2020/11/18/Spring%20Cloud%20%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Spring-Cloud-初识"><a href="#Spring-Cloud-初识" class="headerlink" title="Spring Cloud 初识"></a>Spring Cloud 初识</h1><h2 id="谈谈微服务"><a href="#谈谈微服务" class="headerlink" title="谈谈微服务"></a>谈谈微服务</h2><blockquote><p>微服务是什么？</p></blockquote><h3 id="1、单体阶段"><a href="#1、单体阶段" class="headerlink" title="1、单体阶段"></a>1、单体阶段</h3><blockquote><p>下列开篇引用自 <a href="https://www.jianshu.com/p/7293b148028f">简书</a></p></blockquote><p>​    相对的，要理解什么是<strong>微服务</strong>，那么可以先理解什么是<strong>单体应用</strong>，在没有提出微服务的概念的“远古”年代，一个软件应用，往往会将应用所有功能都开发和打包在一起，那时候的一个B/S应用架构往往是这样的：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/imgimage-20201119161928480.png" alt="B/S"></p><p>但是，当用户访问量变大导致一台服务器无法支撑时怎么办呢？加服务器加负载均衡，架构就变成这样了：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/imgimage-20201119161940457.png" alt="B/S+负载均衡"></p><p>后面发现把静态文件独立出来，通过CDN等手段进行加速，可以提升应用的整体相应，单体应用的架构就变成：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/imgimage-20201119161950668.png" alt="B/S+前后端分离"></p><p>上面3中架构都还是单体应用，只是在<strong>部署方面</strong>进行了优化，所以避免不了单体应用的根本的缺点：</p><ul><li><p>代码<strong>臃肿</strong>，应用启动时间长；（代码超过1G的项目都有！）</p></li><li><p>回归<strong>测试周期长</strong>，修复一个小小bug可能都需要对所有关键业务进行回归测试。</p></li><li><p>应用<strong>容错性差</strong>，某个小小功能的程序错误可能导致整个系统宕机；</p></li><li><p>伸缩困难，单体应用扩展性能时只能整个应用进行扩展，造成计算资源浪费。</p></li><li><p>开发协作困难，一个大型应用系统，可能几十个甚至上百个开发人员，大家都在维护一套代码的话，代码merge复杂度急剧增加。</p></li></ul><h3 id="2、微服务阶段"><a href="#2、微服务阶段" class="headerlink" title="2、微服务阶段"></a>2、微服务阶段</h3><blockquote><p>微服务的出现就是因为原来单体应用架构已经无法满足当前互联网产品的技术需求。</p></blockquote><p>什么样的服务才算微服务呢？</p><ul><li><p><strong>单一职责的</strong>。一个微服务应该都是单一职责的，这才是“微”的体现，一个微服务解决一个业务问题（注意是一个业务问题而不是一个接口）。</p></li><li><p><strong>面向服务的</strong>。将自己的业务能力封装并对外提供服务，这是继承SOA的核心思想，一个微服务本身也可能使用到其它微服务的能力。<br> <strong>我觉得满足以上两点就可以认为典型的微服务。</strong></p></li></ul><h3 id="3、微服务典型架构"><a href="#3、微服务典型架构" class="headerlink" title="3、微服务典型架构"></a>3、微服务典型架构</h3><blockquote><p>微服务架构，核心是为了解决应用微服务化之后的服务治理问题。</p></blockquote><p>​    应用微服务化之后，首先遇到的第一个问题就是<strong>服务发现问题</strong>，一个微服务如何发现其他微服务呢？最简单的方式就是每个微服务里面配置其他微服务的地址，但是当微服务数量众多的时候，这样做明显不现实。所以需要使用到微服务架构中的一个最重要的组件：<strong>服务注册中心</strong>，所有服务都注册到<strong>服务注册中心</strong>，同时也可以从服务注册中心获取当前可用的服务清单：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/imgimage-20201119161902129.png" alt="服务注册中心"></p><p>​    解决服务发现问题后，接着需要解决微服务分布式部署带来的第二个问题：<strong>服务配置管理的问题</strong>。当服务数量超过一定程度之后，如果需要在每个服务里面分别维护每一个服务的配置文件，运维人员估计要哭了。那么，就需要用到微服务架构里面第二个重要的组件：<strong>配置中心</strong>，微服务架构就变成下面这样了：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/imgimage-20201119162034804.png" alt="配置中心"></p><p>​    以上应用内部的服务治理，当<strong>客户端或外部应用调用服务</strong>的时候怎么处理呢？服务A可能有多个节点，服务A、服务B和服务C的服务地址都不同，服务授权验证在哪里做？这时，就需要使用到<strong>服务网关</strong>提供统一的服务入口，最终形成典型微服务架构：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/imgimage-20201119162157483.png" alt="典型微服务架构"></p><p>​    上面是一个典型的微服务架构，当然微服务的服务治理还涉及很多内容，比如：</p><ul><li>通过熔断、限流等机制保证高可用；</li><li>微服务之间调用的负载均衡；</li><li>分布式事务（2PC、3PC、TCC、LCN等）；</li><li>服务调用链跟踪等等。</li></ul><h2 id="Spring-Cloud-gt-微服务框架"><a href="#Spring-Cloud-gt-微服务框架" class="headerlink" title="Spring Cloud -&gt; 微服务框架"></a>Spring Cloud -&gt; 微服务框架</h2><blockquote><p>由此，Spring Cloud=分布式微服务架构的一站式解决方案，是多种微服务架构落地技术的集合体，俗称微服务全家桶。</p></blockquote><p><strong>“COORDINATE ANYTHING:DISTRIBUTED SYSTEMS SIMPLIFIED”</strong></p><pre><code> `Spring Cloud` 就是微服务系统架构的一站式解决方案，在平时我们构建微服务的过程中需要做如 **服务发现注册** 、**配置中心** 、**消息总线** 、**负载均衡** 、**断路器** 、**数据监控** 等操作，而 Spring Cloud 为我们提供了一套简易的编程模型，使我们能在 Spring Boot 的基础上轻松地实现微服务项目的构建。</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/imgimage-20201119163743535.png" alt="spring cloud 蕴含技术栈"></p><h3 id="1、Spring-Cloud版本选型"><a href="#1、Spring-Cloud版本选型" class="headerlink" title="1、Spring Cloud版本选型"></a>1、Spring Cloud版本选型</h3><blockquote><p>SpringCloud采用了英国伦敦地铁站的名称来命名, 并由地铁站名称字母A-Z依次类推的形式来发布迭代版本。</p></blockquote><p>​    SpringCloud是一个由许多子项目组成的综合项目, 各子项目有不同的发布节奏, 为了管理SpringCloud与各个子项目的版本依赖关系, 发布了一个清单, 其中包括了某个SpringCloud版本对应的子项目版本. 为了避免SpringCloud版本号与子项目版本号混淆, <strong>SpringCloud版本采用了名称而非版本号的命名, 这些版本的名字采用了伦敦地铁站的名字, 根据字母表的顺序来对应版本时间顺序</strong>. 例如Angel是第一个版本, Brixton是第二个版本. 当SpringCloud的发布内容积累到临界点或者一个重大BUG被解决后, 会发布一个”service releases”版本, 简称SRX版本, 比如Greenwich.SR2就是SpringCloud发布的Greenwich版本的第二个SRX版本.</p><table><thead><tr><th align="left">Release Train</th><th align="left">Boot Version</th></tr></thead><tbody><tr><td align="left">2020.0.x aka Ilford</td><td align="left">2.4.x</td></tr><tr><td align="left"><a href="https://github.com/spring-projects/spring-cloud/wiki/Spring-Cloud-Hoxton-Release-Notes">Hoxton</a></td><td align="left">2.2.x, 2.3.x (Starting with SR5)</td></tr><tr><td align="left"><a href="https://github.com/spring-projects/spring-cloud/wiki/Spring-Cloud-Greenwich-Release-Notes">Greenwich</a></td><td align="left">2.1.x</td></tr><tr><td align="left"><a href="https://github.com/spring-projects/spring-cloud/wiki/Spring-Cloud-Finchley-Release-Notes">Finchley</a></td><td align="left">2.0.x</td></tr><tr><td align="left"><a href="https://github.com/spring-projects/spring-cloud/wiki/Spring-Cloud-Edgware-Release-Notes">Edgware</a></td><td align="left">1.5.x</td></tr><tr><td align="left"><a href="https://github.com/spring-projects/spring-cloud/wiki/Spring-Cloud-Dalston-Release-Notes">Dalston</a></td><td align="left">1.5.x</td></tr></tbody></table><blockquote><p> [spring官网][<a href="https://spring.io/projects/spring-cloud]%E6%9F%A5%E7%9C%8B%E7%89%88%E6%9C%AC%E9%80%89%E5%9E%8B[json][https://start.spring.io/actuator/info]">https://spring.io/projects/spring-cloud]查看版本选型[json][https://start.spring.io/actuator/info]</a></p></blockquote><h3 id="2、学习技术选型"><a href="#2、学习技术选型" class="headerlink" title="2、学习技术选型"></a>2、学习技术选型</h3><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/imgimage-20201119170031804.png" alt="技术版本选择" style="zoom:33%;" /><h3 id="3、Spring-Cloud组件停更升级以及替换"><a href="#3、Spring-Cloud组件停更升级以及替换" class="headerlink" title="3、Spring Cloud组件停更升级以及替换"></a>3、Spring Cloud组件停更升级以及替换</h3><p>​    1,服务注册中心,Eureka停用,zookeeper, Consul, Cloud Alibaba Nacos</p><p>​    2,服务调用,Ribbon准备停更,代替为LoadBalance</p><p>​    3,服务调用2,Feign改为OpenFeign</p><p>​    4,服务降级,Hystrix停更,改为resilence4j,Cloud Alibaba sentienl</p><p>​    5.服务网关,Zuul改为gateway    </p><p>​    6,服务配置Config改为Cloud Alibaba Nacos</p><p>​    7,服务总线Bus改为Cloud Alibaba Nacos</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/imgimage-20201119172251583.png" alt="cloud 技术更新情况"></p><h3 id="4、学习文档"><a href="#4、学习文档" class="headerlink" title="4、学习文档"></a>4、学习文档</h3><blockquote><p><a href="https://cloud.spring.io/spring-cloud-static/Hoxton.SR1/reference/htmlsingle/">spring cloud</a>        <a href="https://www.bookstack.cn/read/spring-cloud-docs/docs-index.md">中文</a> HSR1.</p><p><a href="https://docs.spring.io/spring-boot/docs/2.2.2.RELEASE/reference/htmlsingle/">spring boot</a>        2.2.2.</p></blockquote><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="1、关于dependencyManagement"><a href="#1、关于dependencyManagement" class="headerlink" title="1、关于dependencyManagement"></a>1、关于dependencyManagement</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/imgimage-20201119183455723.png" alt="dependencyManagement详解"></p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/imgimage-20201119183718866.png" alt="maven跳过单元测试" style="zoom:67%;" /><h3 id="2、构建cloud-provider-payment8001工程实现微服务提供者"><a href="#2、构建cloud-provider-payment8001工程实现微服务提供者" class="headerlink" title="2、构建cloud-provider-payment8001工程实现微服务提供者"></a>2、构建cloud-provider-payment8001工程实现微服务提供者</h3><p>由于cloud学习, 对于Spring Boot操作不过多阐述.该Module中主要提供create和get方法操作</p><pre><code class="hljs java"><span class="hljs-meta">@NoArgsConstructor</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Payment</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;    <span class="hljs-keyword">private</span> Long id;    <span class="hljs-keyword">private</span> String serial;&#125;</code></pre><p>相应dao、service层不过多阐述.</p><p>controller层业务代码:</p><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-meta">@Slf4j</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PaymentController</span> </span>&#123;    <span class="hljs-meta">@Resource</span>    <span class="hljs-keyword">private</span> PaymentService paymentService;    <span class="hljs-meta">@PostMapping(value = &quot;/payment/create&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> CommonResult <span class="hljs-title">create</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> Payment payment)</span> </span>&#123;        <span class="hljs-keyword">int</span> resultRows = paymentService.create(payment);        log.info(<span class="hljs-string">&quot;******插入结果:&quot;</span> + resultRows);        <span class="hljs-keyword">if</span> (resultRows &gt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CommonResult(<span class="hljs-number">200</span>, <span class="hljs-string">&quot;插入数据库成功&quot;</span>, resultRows);        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CommonResult(<span class="hljs-number">444</span>, <span class="hljs-string">&quot;插入数据库失败&quot;</span>);        &#125;    &#125;    <span class="hljs-meta">@GetMapping(value = &quot;/payment/get/&#123;id&#125;&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> CommonResult <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Long id)</span> </span>&#123;        Payment payment = paymentService.getPaymentById(id);        log.info(<span class="hljs-string">&quot;******查询结果:&quot;</span> + payment);        <span class="hljs-keyword">if</span> (payment != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CommonResult(<span class="hljs-number">200</span>, <span class="hljs-string">&quot;查询数据库成功&quot;</span>, payment);        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CommonResult(<span class="hljs-number">444</span>, <span class="hljs-string">&quot;查询数据库失败&quot;</span> + id);        &#125;    &#125;&#125;</code></pre><h3 id="3、构建cloud-consumer-order80工程实现客户端消费者"><a href="#3、构建cloud-consumer-order80工程实现客户端消费者" class="headerlink" title="3、构建cloud-consumer-order80工程实现客户端消费者"></a>3、构建cloud-consumer-order80工程实现客户端消费者</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201121174959.png" alt="项目结构"></p><p>​    因为这里是消费者类, 主要是消费, 那么就没有service和dao, 需要调用pay模块的方法, 并且这里还没有微服务的远程调用, 那么如果要调用另外一个模块, 则需要使用基本的api调用.这里我们使用RestTemplate使得微服务消费者80调用微服务提供者8001.</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201121175514.png" alt="RestTemplate功能和使用"></p><p>对应注入:</p><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApplicationContextConfig</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> RestTemplate <span class="hljs-title">getRestTemplate</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RestTemplate();    &#125;&#125;</code></pre><p>controller层业务代码:</p><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-meta">@Slf4j</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderController</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String PAYMENT_URL = <span class="hljs-string">&quot;http://localhost:8001&quot;</span>;    <span class="hljs-meta">@Resource</span>    <span class="hljs-keyword">private</span> RestTemplate restTemplate;    <span class="hljs-meta">@GetMapping(&quot;/consumer/payment/create&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> CommonResult&lt;Payment&gt; <span class="hljs-title">create</span><span class="hljs-params">(Payment payment)</span></span>&#123;        <span class="hljs-keyword">return</span> restTemplate.postForObject(PAYMENT_URL + <span class="hljs-string">&quot;/payment/create&quot;</span>, payment, CommonResult.class);    &#125;    <span class="hljs-meta">@GetMapping(&quot;/consumer/payment/get/&#123;id&#125;&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> CommonResult&lt;Payment&gt; <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Long id)</span></span>&#123;        <span class="hljs-keyword">return</span> restTemplate.getForObject(PAYMENT_URL + <span class="hljs-string">&quot;/payment/get/&quot;</span> + id, CommonResult.class);    &#125;&#125;</code></pre><h3 id="4、entity实体类放入cloud-api-commons中"><a href="#4、entity实体类放入cloud-api-commons中" class="headerlink" title="4、entity实体类放入cloud-api-commons中"></a>4、entity实体类放入cloud-api-commons中</h3><p>其他工程加入即可</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.study.springcloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>cloud-api-commons<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;project.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><h1 id="服务注册与发现"><a href="#服务注册与发现" class="headerlink" title="服务注册与发现"></a>服务注册与发现</h1><h2 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h2><h3 id="1、Eureka基础知识"><a href="#1、Eureka基础知识" class="headerlink" title="1、Eureka基础知识"></a>1、Eureka基础知识</h3><p>​    前面我们没有服务注册中心, 也可以服务间调用,为什么还要服务注册?</p><p>​    当服务很多时, 单靠代码手动管理是很麻烦的, 需要一个公共组件, 统一管理多服务, 包括服务是否正常运行等.Eureka用于<strong>服务注册</strong>, 目前官网<strong>已经停止更新</strong>.</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201121194357.png" alt="什么是服务治理?"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201121194553.png" alt="什么是服务注册与发现"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201121195221.png" alt="Eureka两个组件"></p><h3 id="2、单机版Eureka构建"><a href="#2、单机版Eureka构建" class="headerlink" title="2、单机版Eureka构建"></a>2、单机版Eureka构建</h3><pre><code>#### a、 POM依赖</code></pre><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- eureka-server --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><h4 id="b、yaml配置"><a href="#b、yaml配置" class="headerlink" title="b、yaml配置"></a>b、yaml配置</h4><pre><code class="hljs yaml"><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">7001</span><span class="hljs-attr">eureka:</span>  <span class="hljs-attr">instance:</span>    <span class="hljs-attr">hostname:</span> <span class="hljs-string">localhost</span> <span class="hljs-comment">#eureka服务端的实例名称</span>  <span class="hljs-attr">client:</span>    <span class="hljs-comment">#false表示不向注册中心注册自己。</span>    <span class="hljs-attr">register-with-eureka:</span> <span class="hljs-literal">false</span>    <span class="hljs-comment">#false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务</span>    <span class="hljs-attr">fetch-registry:</span> <span class="hljs-literal">false</span>    <span class="hljs-attr">service-url:</span>      <span class="hljs-comment">#设置与Eureka Server交互的地址查询服务和注册服务都需要依赖这个地址。</span>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/</span></code></pre><h4 id="c、主启动类"><a href="#c、主启动类" class="headerlink" title="c、主启动类"></a>c、主启动类</h4><pre><code class="hljs java"><span class="hljs-meta">@EnableEurekaServer</span></code></pre><p>启动访问<a href="http://localhost:7001/">http://localhost:7001/</a></p><h4 id="d、服务入驻"><a href="#d、服务入驻" class="headerlink" title="d、服务入驻"></a>d、服务入驻</h4><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--eureka client--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>​    添加至cloud-provider-payment8001</p><p>修改yaml配置文件</p><pre><code class="hljs yaml"><span class="hljs-attr">eureka:</span>  <span class="hljs-attr">client:</span>    <span class="hljs-comment">#表示是否将自己注册进EurekaServer 默认为true</span>    <span class="hljs-attr">register-with-eureka:</span> <span class="hljs-literal">true</span>    <span class="hljs-comment">#是否从EurekaServer抓取已有的注册信息，默认为true。单节点无所谓，集群必须true才能配合ribbon负载均衡</span>    <span class="hljs-attr">fetch-registry:</span> <span class="hljs-literal">true</span>    <span class="hljs-attr">service-url:</span>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://localhost:7001/eureka</span></code></pre><p>主启动类添加</p><pre><code class="hljs java"><span class="hljs-meta">@EnableEurekaClient</span></code></pre><p>对于cloud-consumer-order80工程一样处理</p><h4 id="e、测试"><a href="#e、测试" class="headerlink" title="e、测试"></a>e、测试</h4><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201121202144.png" alt="测试"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201121202649.png" alt="测试"></p><blockquote><p>好家伙 我直接好家伙 已经开始卡了</p></blockquote><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201121203224.png" alt="内存占用"></p><h3 id="番外-“-eureka”到底是什么"><a href="#番外-“-eureka”到底是什么" class="headerlink" title="番外: “/eureka”到底是什么?"></a>番外: “/eureka”到底是什么?</h3><blockquote><p> 部署eureka集群时defaultZone中为什么必须包含路径/eureka？<a href="https://www.cnblogs.com/StarkBrothers/archive/2004/01/13/11974026.html">引用</a></p></blockquote><p>​    待深入了解中…..</p><h3 id="3、集群版Eureka构建"><a href="#3、集群版Eureka构建" class="headerlink" title="3、集群版Eureka构建"></a>3、集群版Eureka构建</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201121205728.png" alt="集群Eureka"></p><p>1,就是pay模块启动时,注册自己,并且自身信息也放入eureka<br>2.order模块,首先也注册自己,放入信息,当要调用pay时,先从eureka拿到pay的调用地址<br>3.通过HttpClient调用并且还会缓存一份到本地,每30秒更新一次 </p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201121210043.png" alt="题"></p><h4 id="A、注册原理"><a href="#A、注册原理" class="headerlink" title="A、注册原理"></a>A、注册原理</h4><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201121210334.png" alt="互相注册, 相互守望" style="zoom:67%;" /><h5 id="a、创建"><a href="#a、创建" class="headerlink" title="a、创建"></a>a、创建</h5><h5 id="b、POM引入-写YML"><a href="#b、POM引入-写YML" class="headerlink" title="b、POM引入 写YML"></a>b、POM引入 写YML</h5><p>7001改yaml:</p><pre><code class="hljs yaml"><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">7001</span><span class="hljs-attr">eureka:</span>  <span class="hljs-attr">instance:</span>    <span class="hljs-attr">hostname:</span> <span class="hljs-string">eureka7001.com</span> <span class="hljs-comment">#eureka服务端的实例名称</span>  <span class="hljs-attr">client:</span>    <span class="hljs-comment">#false表示不向注册中心注册自己。</span>    <span class="hljs-attr">register-with-eureka:</span> <span class="hljs-literal">false</span>    <span class="hljs-comment">#false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务</span>    <span class="hljs-attr">fetch-registry:</span> <span class="hljs-literal">false</span>    <span class="hljs-attr">service-url:</span>      <span class="hljs-comment">#设置与Eureka Server交互的地址查询服务和注册服务都需要依赖这个地址。</span>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://eureka7002.com:7002/eureka/</span></code></pre><p>7002:改yaml</p><pre><code class="hljs yaml"><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">7002</span><span class="hljs-attr">eureka:</span>  <span class="hljs-attr">instance:</span>    <span class="hljs-attr">hostname:</span> <span class="hljs-string">eureka7002.com</span> <span class="hljs-comment">#eureka服务端的实例名称</span>  <span class="hljs-attr">client:</span>    <span class="hljs-comment">#false表示不向注册中心注册自己。</span>    <span class="hljs-attr">register-with-eureka:</span> <span class="hljs-literal">false</span>    <span class="hljs-comment">#false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务</span>    <span class="hljs-attr">fetch-registry:</span> <span class="hljs-literal">false</span>    <span class="hljs-attr">service-url:</span>      <span class="hljs-comment">#设置与Eureka Server交互的地址查询服务和注册服务都需要依赖这个地址。</span>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://eureka7001.com:7001/eureka/</span></code></pre><h5 id="c、修改Hosts配置文件模拟集群"><a href="#c、修改Hosts配置文件模拟集群" class="headerlink" title="c、修改Hosts配置文件模拟集群"></a>c、修改Hosts配置文件模拟集群</h5><p>sudo vim /etc/hosts</p><p>#eureka<br>127.0.0.1       eureka7001.com<br>127.0.0.1       eureka7002.com</p><h5 id="d、写主启动类"><a href="#d、写主启动类" class="headerlink" title="d、写主启动类"></a>d、写主启动类</h5><h5 id="e、测试-1"><a href="#e、测试-1" class="headerlink" title="e、测试"></a>e、测试</h5><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201121212034.png" alt="测试成功" style="zoom: 50%;" /><h4 id="B、订单支付微服务入驻Eureka集群"><a href="#B、订单支付微服务入驻Eureka集群" class="headerlink" title="B、订单支付微服务入驻Eureka集群"></a>B、订单支付微服务入驻Eureka集群</h4><pre><code class="hljs yaml"><span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka</span> <span class="hljs-comment">#集群版</span></code></pre><p>修改yaml文件即可, 测试:</p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201121212825.png" alt="test" style="zoom: 33%;" /><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201121212948.png" alt="服务无影响" style="zoom:33%;" /><h3 id="4、将支付微服务集群配置"><a href="#4、将支付微服务集群配置" class="headerlink" title="4、将支付微服务集群配置"></a>4、将支付微服务集群配置</h3><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201121220116.png" alt="集群图" style="zoom: 25%;" /><h4 id="a、复制粘贴8001，改端口"><a href="#a、复制粘贴8001，改端口" class="headerlink" title="a、复制粘贴8001，改端口"></a>a、复制粘贴8001，改端口</h4><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201121214455.png" alt="eureka显示"></p><h4 id="b、修改80消费者controller调用时候的url"><a href="#b、修改80消费者controller调用时候的url" class="headerlink" title="b、修改80消费者controller调用时候的url"></a>b、修改80消费者controller调用时候的url</h4><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-meta">@Slf4j</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderController</span> </span>&#123;    <span class="hljs-comment">// private static final String PAYMENT_URL = &quot;http://localhost:8001&quot;;</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String PAYMENT_URL = <span class="hljs-string">&quot;http://CLOUD-PAYMENT-SERVICE&quot;</span>;    <span class="hljs-meta">@Resource</span>    <span class="hljs-keyword">private</span> RestTemplate restTemplate;    <span class="hljs-meta">@GetMapping(&quot;/consumer/payment/create&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> CommonResult&lt;Payment&gt; <span class="hljs-title">create</span><span class="hljs-params">(Payment payment)</span></span>&#123;        <span class="hljs-keyword">return</span> restTemplate.postForObject(PAYMENT_URL + <span class="hljs-string">&quot;/payment/create&quot;</span>, payment, CommonResult.class);    &#125;    <span class="hljs-meta">@GetMapping(&quot;/consumer/payment/get/&#123;id&#125;&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> CommonResult&lt;Payment&gt; <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Long id)</span></span>&#123;        <span class="hljs-keyword">return</span> restTemplate.getForObject(PAYMENT_URL + <span class="hljs-string">&quot;/payment/get/&quot;</span> + id, CommonResult.class);    &#125;&#125;</code></pre><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201121214634.png" alt="8001与8002服务均启动" style="zoom:50%;" /><h4 id="c、开启负载均衡注解"><a href="#c、开启负载均衡注解" class="headerlink" title="c、开启负载均衡注解"></a>c、开启负载均衡注解</h4><p>需要让RestTemplate开启负载均衡注解, 还可以指定负载均衡算法, 默认<strong>轮询</strong>, 各自一次</p><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApplicationContextConfig</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-meta">@LoadBalanced</span> <span class="hljs-comment">// 负载均衡</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> RestTemplate <span class="hljs-title">getRestTemplate</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RestTemplate();    &#125;&#125;</code></pre><h4 id="d、修改服务主机名和ip在eureka的web上显示"><a href="#d、修改服务主机名和ip在eureka的web上显示" class="headerlink" title="d、修改服务主机名和ip在eureka的web上显示"></a>d、修改服务主机名和ip在eureka的web上显示</h4><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201121221649.png" alt="yaml"></p><h3 id="5、服务发现Discovery"><a href="#5、服务发现Discovery" class="headerlink" title="5、服务发现Discovery"></a>5、服务发现Discovery</h3><p>对于注册进Eureka里的微服务, 可以通过服务发现来获得该服务的信息</p><p>以Payment8001为模版:</p><h4 id="a、修改cloud-provider-payment8001的Controller"><a href="#a、修改cloud-provider-payment8001的Controller" class="headerlink" title="a、修改cloud-provider-payment8001的Controller"></a>a、修改cloud-provider-payment8001的Controller</h4><pre><code class="hljs java"><span class="hljs-meta">@Resource</span><span class="hljs-keyword">private</span> DiscoveryClient discoveryClient;</code></pre><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(value = &quot;/payment/discovery&quot;)</span><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">discovery</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// 得到服务信息</span>    List&lt;String&gt; services = discoveryClient.getServices();    <span class="hljs-keyword">for</span> (String service : services) &#123;        log.info(<span class="hljs-string">&quot;*****element:&quot;</span>+service);    &#125;    List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances(<span class="hljs-string">&quot;cloud-payment-service&quot;</span>);    <span class="hljs-keyword">for</span> (ServiceInstance instance : instances) &#123;        log.info(<span class="hljs-string">&quot;*****id:&quot;</span>+instance.getServiceId());        log.info(<span class="hljs-string">&quot;*****host:&quot;</span>+instance.getHost());        log.info(<span class="hljs-string">&quot;*****port:&quot;</span>+instance.getPort());        log.info(<span class="hljs-string">&quot;*****uri:&quot;</span>+instance.getUri());    &#125;        <span class="hljs-keyword">return</span> discoveryClient;</code></pre><h4 id="b、-修改主启动类"><a href="#b、-修改主启动类" class="headerlink" title="b、 修改主启动类"></a>b、 修改主启动类</h4><pre><code class="hljs java"><span class="hljs-meta">@EnableDiscoveryClient</span></code></pre><h4 id="c、测试"><a href="#c、测试" class="headerlink" title="c、测试"></a>c、测试</h4><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201121222843.png" alt="test" style="zoom: 50%;" /><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201121223049.png" alt="log" style="zoom: 50%;" /><h3 id="6、Eureka自我保护"><a href="#6、Eureka自我保护" class="headerlink" title="6、Eureka自我保护"></a>6、Eureka自我保护</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201121223452.png" alt="eureka提示"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201121224343.png" alt="保护概念"></p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201123140710.png" alt="心跳包" style="zoom:67%;" /><h3 id="7、Eureka自我保护关闭"><a href="#7、Eureka自我保护关闭" class="headerlink" title="7、Eureka自我保护关闭"></a>7、Eureka自我保护关闭</h3><blockquote><p>一般生产环境中不会禁止自我保护</p></blockquote><pre><code class="hljs yaml"><span class="hljs-comment"># 服务端配置</span><span class="hljs-attr">eureka:</span>   <span class="hljs-attr">server:</span>    <span class="hljs-comment"># 关闭自我保护 </span>    <span class="hljs-attr">enable-self-preservation:</span> <span class="hljs-literal">false</span>    <span class="hljs-comment"># 接受心跳包时间间隔</span>    <span class="hljs-attr">eviction-interval-timer-in-ms:</span> <span class="hljs-number">2000</span></code></pre><pre><code class="hljs yaml"><span class="hljs-comment"># 客户端配置</span><span class="hljs-comment"># 心跳检测和续约时间</span><span class="hljs-attr">instance:</span>  <span class="hljs-comment"># Eureka客户端向服务端发送心跳的时间间隔, 单位为秒(默认30s)</span>  <span class="hljs-attr">lease-renewal-interval-in-seconds:</span> <span class="hljs-number">30</span>  <span class="hljs-comment"># Eureka服务端收到最后一次心跳等待服务时间上限, 默认90s, 超时则剔除服务</span>  <span class="hljs-attr">lease-expiration-duration-in-seconds:</span> <span class="hljs-number">90</span></code></pre><h3 id="8、Eureka停更"><a href="#8、Eureka停更" class="headerlink" title="8、Eureka停更"></a>8、Eureka停更</h3><blockquote><p><a href="https://github.com/Netflix/eureka/wiki">官网</a></p></blockquote><h2 id="Zookeeper-替换Eureka-服务注册与发现"><a href="#Zookeeper-替换Eureka-服务注册与发现" class="headerlink" title="Zookeeper(替换Eureka) 服务注册与发现"></a>Zookeeper(替换Eureka) 服务注册与发现</h2><blockquote><p>zookeeper是一个分布式协调工具，可以实现注册中心功能</p></blockquote><h3 id="1、-安装zookeeper-cloud-provider-payment8004入驻"><a href="#1、-安装zookeeper-cloud-provider-payment8004入驻" class="headerlink" title="1、 安装zookeeper(cloud-provider-payment8004入驻)"></a>1、 安装zookeeper(cloud-provider-payment8004入驻)</h3><h4 id="a、在aliyun服务器安装zookeeper并关闭防火墙（aliyun开了kafka-2181被kafka自己的zookeeper占用-改用自己mac开启zookeeper）"><a href="#a、在aliyun服务器安装zookeeper并关闭防火墙（aliyun开了kafka-2181被kafka自己的zookeeper占用-改用自己mac开启zookeeper）" class="headerlink" title="a、在aliyun服务器安装zookeeper并关闭防火墙（aliyun开了kafka 2181被kafka自己的zookeeper占用 改用自己mac开启zookeeper）"></a>a、在aliyun服务器安装zookeeper并关闭防火墙（aliyun开了kafka 2181被kafka自己的zookeeper占用 改用自己mac开启zookeeper）</h4><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201123143814.png" alt="服务器" style="zoom:50%;" /><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201123152949.png" alt="mymac" style="zoom:50%;" /><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201123153358.png" alt="进入zkCli" style="zoom:50%;" /><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201123153134.png" alt="防火墙关闭" style="zoom:50%;" /><blockquote><p>ifconfig | grep “inet “ | grep -v 127.0.0.1 mac查看自己ip </p></blockquote><h4 id="b、构建cloud-provider-payment8004工程"><a href="#b、构建cloud-provider-payment8004工程" class="headerlink" title="b、构建cloud-provider-payment8004工程"></a>b、构建cloud-provider-payment8004工程</h4><p>POM.xml:</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-zookeeper-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>yaml:</p><pre><code class="hljs yaml"><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">8004</span><span class="hljs-attr">spring:</span>  <span class="hljs-attr">application:</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">cloud-payment-service</span>  <span class="hljs-attr">cloud:</span>    <span class="hljs-attr">zookeeper:</span>      <span class="hljs-attr">connect-string:</span> <span class="hljs-number">101.37</span><span class="hljs-number">.162</span><span class="hljs-number">.1</span><span class="hljs-string">:2181</span></code></pre><p>主启动类:</p><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-meta">@EnableDiscoveryClient</span> <span class="hljs-comment">// 该注解用于向consul或者zookeeper作为注册中心时注册服务</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PaymentMain8004</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(PaymentMain8004.class, args);    &#125;&#125;</code></pre><p>Controller:</p><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-meta">@Slf4j</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PaymentController</span> </span>&#123;    <span class="hljs-meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span>    <span class="hljs-keyword">private</span> String serverPort;    <span class="hljs-meta">@RequestMapping(value = &quot;/payment/zk&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">zk</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;zookeeper:&quot;</span> + serverPort + UUID.randomUUID().toString();    &#125;&#125;</code></pre><p>修改pom:</p><blockquote><p>解决jar包不一致问题</p></blockquote><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--SpringBoot整合Zookeeper客户端--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-zookeeper-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span>        <span class="hljs-comment">&lt;!--先排除自带的zookeeper3.5.3--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.zookeeper<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>zookeeper<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!--添加zookeeper3.4.14版本--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.zookeeper<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>zookeeper<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.4.14<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201123153935.png" alt="测试结果"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201123154156.png" alt="zookeeper前后变化"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201123154124.png" alt="客户端访问结果"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201123154249.png" alt="结果"></p><h3 id="2、思考"><a href="#2、思考" class="headerlink" title="2、思考"></a>2、思考</h3><p>我们把Zookeeper ls到底并get</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201123154610.png" alt="疑问"></p><p>得到一份json字符串并解析:</p><pre><code class="hljs json">&#123;  <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;cloud-payment-service&quot;</span>,  <span class="hljs-attr">&quot;id&quot;</span>: <span class="hljs-string">&quot;ccf0aff6-d8d8-4730-acca-b035c7b424a4&quot;</span>,  <span class="hljs-attr">&quot;address&quot;</span>: <span class="hljs-string">&quot;10.240.8.173&quot;</span>,  <span class="hljs-attr">&quot;port&quot;</span>: <span class="hljs-number">8004</span>,  <span class="hljs-attr">&quot;sslPort&quot;</span>: <span class="hljs-literal">null</span>,  <span class="hljs-attr">&quot;payload&quot;</span>: &#123;    <span class="hljs-attr">&quot;@class&quot;</span>: <span class="hljs-string">&quot;org.springframework.cloud.zookeeper.discovery.ZookeeperInstance&quot;</span>,    <span class="hljs-attr">&quot;id&quot;</span>: <span class="hljs-string">&quot;application-1&quot;</span>,    <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;cloud-payment-service&quot;</span>,    <span class="hljs-attr">&quot;metadata&quot;</span>: &#123;&#125;  &#125;,  <span class="hljs-attr">&quot;registrationTimeUTC&quot;</span>: <span class="hljs-number">1606116992809</span>,  <span class="hljs-attr">&quot;serviceType&quot;</span>: <span class="hljs-string">&quot;DYNAMIC&quot;</span>,  <span class="hljs-attr">&quot;uriSpec&quot;</span>: &#123;    <span class="hljs-attr">&quot;parts&quot;</span>: [      &#123;        <span class="hljs-attr">&quot;value&quot;</span>: <span class="hljs-string">&quot;scheme&quot;</span>,        <span class="hljs-attr">&quot;variable&quot;</span>: <span class="hljs-literal">true</span>      &#125;,      &#123;        <span class="hljs-attr">&quot;value&quot;</span>: <span class="hljs-string">&quot;://&quot;</span>,        <span class="hljs-attr">&quot;variable&quot;</span>: <span class="hljs-literal">false</span>      &#125;,      &#123;        <span class="hljs-attr">&quot;value&quot;</span>: <span class="hljs-string">&quot;address&quot;</span>,        <span class="hljs-attr">&quot;variable&quot;</span>: <span class="hljs-literal">true</span>      &#125;,      &#123;        <span class="hljs-attr">&quot;value&quot;</span>: <span class="hljs-string">&quot;:&quot;</span>,        <span class="hljs-attr">&quot;variable&quot;</span>: <span class="hljs-literal">false</span>      &#125;,      &#123;        <span class="hljs-attr">&quot;value&quot;</span>: <span class="hljs-string">&quot;port&quot;</span>,        <span class="hljs-attr">&quot;variable&quot;</span>: <span class="hljs-literal">true</span>      &#125;    ]  &#125;&#125;</code></pre><h4 id="a、是临时节点还是持久节点"><a href="#a、是临时节点还是持久节点" class="headerlink" title="a、是临时节点还是持久节点?"></a>a、是临时节点还是持久节点?</h4><blockquote><p>我们在zk上注册的node是临时节点, 当我们的服务一定时间内没有发送心跳, 那么zk就会将这个服务的node删除(只需停掉8004 再查看zk结点)</p></blockquote><h3 id="3、cloud-consumerzk-order80-入驻-zookeeper"><a href="#3、cloud-consumerzk-order80-入驻-zookeeper" class="headerlink" title="3、cloud-consumerzk-order80 入驻 zookeeper"></a>3、cloud-consumerzk-order80 入驻 zookeeper</h3><h4 id="a、构建cloud-consumerzk-order80工程"><a href="#a、构建cloud-consumerzk-order80工程" class="headerlink" title="a、构建cloud-consumerzk-order80工程"></a>a、构建cloud-consumerzk-order80工程</h4><p>POM.xml:如cloud-provider-payment8004一致</p><p>yaml:</p><pre><code class="hljs yaml"><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">80</span><span class="hljs-attr">spring:</span>  <span class="hljs-attr">application:</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">cloud-orderzk-service</span>  <span class="hljs-attr">cloud:</span>    <span class="hljs-attr">zookeeper:</span>      <span class="hljs-attr">connect-string:</span> <span class="hljs-number">10.240</span><span class="hljs-number">.8</span><span class="hljs-number">.173</span><span class="hljs-string">:2181</span></code></pre><p>controller:</p><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderController</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String PAYMENT_URL = <span class="hljs-string">&quot;http://cloud-payment-service&quot;</span>;    <span class="hljs-meta">@Resource</span>    <span class="hljs-keyword">private</span> RestTemplate restTemplate;    <span class="hljs-meta">@GetMapping(&quot;/consumer/payment/zk&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">zk</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> restTemplate.getForObject(PAYMENT_URL + <span class="hljs-string">&quot;/payment/zk&quot;</span>, String.class);    &#125;&#125;</code></pre><h4 id="b、测试"><a href="#b、测试" class="headerlink" title="b、测试"></a>b、测试</h4><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201123161555.png" alt="成功"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201123161638.png" alt="zk"></p><h2 id="Consul"><a href="#Consul" class="headerlink" title="Consul"></a>Consul</h2><blockquote><p>Go语言开发 <a href="https://www.consul.io/intro/index.html">官网</a></p></blockquote><h3 id="1、Consul简介"><a href="#1、Consul简介" class="headerlink" title="1、Consul简介:"></a>1、Consul简介:</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201123162351.png" alt="简介"></p><blockquote><p>Consul能干嘛? <a href="https://www.consul.io/downloads.html">去哪下</a> <a href="https://www.springcloud.cc/spring-cloud-consul.html">怎么玩</a></p></blockquote><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201123162747.png" alt="用途"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201123162632.png" alt="用途"></p><h3 id="2、安装运行"><a href="#2、安装运行" class="headerlink" title="2、安装运行"></a>2、安装运行</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201123171136.png" alt="consul"></p><p>把consul文件复制到/usr/local/bin目录下.</p><blockquote><p>consul agent -dev启用 / Ctrl-C（中断信号）正常停止代理</p></blockquote><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201123171658.png" alt="8500端口"></p><h3 id="3、新建Module支付服务cloud-providerconsul-payment8006"><a href="#3、新建Module支付服务cloud-providerconsul-payment8006" class="headerlink" title="3、新建Module支付服务cloud-providerconsul-payment8006"></a>3、新建Module支付服务cloud-providerconsul-payment8006</h3><p>Pom.xml:</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--SpringCloud consul-server--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-consul-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>yaml:</p><pre><code class="hljs yaml"><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">8006</span><span class="hljs-attr">spring:</span>  <span class="hljs-attr">application:</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">cloud-payment-service</span>  <span class="hljs-attr">cloud:</span>    <span class="hljs-attr">consul:</span>      <span class="hljs-attr">host:</span> <span class="hljs-string">localhost</span>      <span class="hljs-attr">port:</span> <span class="hljs-number">8500</span>      <span class="hljs-attr">discovery:</span>        <span class="hljs-comment">#hostname: 127.0.0.1</span>        <span class="hljs-attr">service-name:</span> <span class="hljs-string">$&#123;spring.application.name&#125;</span></code></pre><p>Controller:</p><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-meta">@Slf4j</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PaymentController</span> </span>&#123;    <span class="hljs-meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span>    <span class="hljs-keyword">private</span> String serverPort;    <span class="hljs-meta">@RequestMapping(value = &quot;/payment/consul&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">consul</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;consul:&quot;</span> + serverPort + UUID.randomUUID().toString();    &#125;&#125;</code></pre><p>测试:</p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201123191757.png" alt="测试" style="zoom:50%;" /><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201123192023.png" alt="test"></p><h3 id="4、新建Module消费服务cloud-consumerconsul-order80"><a href="#4、新建Module消费服务cloud-consumerconsul-order80" class="headerlink" title="4、新建Module消费服务cloud-consumerconsul-order80"></a>4、新建Module消费服务cloud-consumerconsul-order80</h3><p>​   pom与8006一致</p><p>​   yml:</p><pre><code class="hljs yaml"><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">80</span><span class="hljs-attr">spring:</span>  <span class="hljs-attr">application:</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">cloud-order-service</span>  <span class="hljs-attr">cloud:</span>    <span class="hljs-attr">consul:</span>      <span class="hljs-attr">host:</span> <span class="hljs-string">localhost</span>      <span class="hljs-attr">port:</span> <span class="hljs-number">8500</span>      <span class="hljs-attr">discovery:</span>        <span class="hljs-comment">#hostname: 127.0.0.1</span>        <span class="hljs-attr">service-name:</span> <span class="hljs-string">$&#123;spring.application.name&#125;</span></code></pre><p>Controller:</p><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderController</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String PAYMENT_URL = <span class="hljs-string">&quot;http://cloud-payment-service&quot;</span>;    <span class="hljs-meta">@Resource</span>    <span class="hljs-keyword">private</span> RestTemplate restTemplate;    <span class="hljs-meta">@GetMapping(&quot;/consumer/payment/consul&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">consul</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> restTemplate.getForObject(PAYMENT_URL + <span class="hljs-string">&quot;/payment/consul&quot;</span>, String.class);    &#125;&#125;</code></pre><p>测试:</p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201123192730.png" alt="test" style="zoom: 50%;" /><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201123192817.png" alt="consul test"></p><h2 id="三个注册中心异同点"><a href="#三个注册中心异同点" class="headerlink" title="三个注册中心异同点"></a>三个注册中心异同点</h2><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201123193015.png" alt="异同点"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201123193225.png" alt="CAP"></p><blockquote><p>AP:</p></blockquote><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201123194018.png" alt="AP"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201123194054.png" alt="CP"></p><h1 id="服务调用"><a href="#服务调用" class="headerlink" title="服务调用"></a>服务调用</h1><h2 id="Ribbon-负载均衡"><a href="#Ribbon-负载均衡" class="headerlink" title="Ribbon 负载均衡"></a>Ribbon 负载均衡</h2><blockquote><p>ribbon是什么？<a href="https://github.com/Netflix/ribbon/wiki/Getting-Started">官网</a></p></blockquote><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201123195235.png" alt="ribbon概述"></p><blockquote><p>Ribbon也已经进入维护, 几乎不更新了, 但Spring推出的LoadBalance暂未能替代ribbon</p></blockquote><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201123195707.png" alt="负载均衡?"></p><h3 id="1、LB（负载均衡）区别"><a href="#1、LB（负载均衡）区别" class="headerlink" title="1、LB（负载均衡）区别"></a>1、LB（负载均衡）区别</h3><h4 id="a、集中式LB"><a href="#a、集中式LB" class="headerlink" title="a、集中式LB"></a>a、集中式LB</h4><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201123195916.png" alt="集中式LB"></p><h4 id="、进程内LB"><a href="#、进程内LB" class="headerlink" title="、进程内LB"></a>、进程内LB</h4><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201123195958.png" alt="进程内LB"></p><blockquote><p>前面我们使用了80通过轮询负载访问8001/8002, 一句话:负载均衡+RestTemplate调用</p></blockquote><h3 id="2、调用演示"><a href="#2、调用演示" class="headerlink" title="2、调用演示"></a>2、调用演示</h3><blockquote><p>Ribbon其实就是一个软负载均衡的客户端组件，他可以和其他所需请求的客户端结合使用，和eureka结合只是其中的一个实例。</p></blockquote><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201123201157.png" alt="ribbon工作"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201123201226.png" alt="策略"></p><h4 id="a、Eureka自动引入"><a href="#a、Eureka自动引入" class="headerlink" title="a、Eureka自动引入"></a>a、Eureka自动引入</h4><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p><strong>Eureka新版本继承了Ribbon</strong></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201123201540.png" alt="pom依赖"></p><h4 id="b、手动加入"><a href="#b、手动加入" class="headerlink" title="b、手动加入"></a>b、手动加入</h4><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201123201718.png" alt="手动"></p><h4 id="c、二说RestTemplate的使用"><a href="#c、二说RestTemplate的使用" class="headerlink" title="c、二说RestTemplate的使用"></a>c、二说RestTemplate的使用</h4><blockquote><p>ForObject与ForEntity区别     <a href="https://docs.spring.io/spring-framework/docs/5.2.2.RELEASE/javadoc-api/org/springframework/web/client/RestTemplate.html">官网</a> </p></blockquote><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/consumer/payment/get/&#123;id&#125;&quot;)</span><span class="hljs-function"><span class="hljs-keyword">public</span> CommonResult&lt;Payment&gt; <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Long id)</span></span>&#123;    <span class="hljs-comment">// 返回对象为响应体中数据转化成的对象，基本上可以理解为Json</span>    <span class="hljs-keyword">return</span> restTemplate.getForObject(PAYMENT_URL + <span class="hljs-string">&quot;/payment/get/&quot;</span> + id, CommonResult.class);&#125;<span class="hljs-meta">@GetMapping(&quot;/consumer/payment/getForEntity/&#123;id&#125;&quot;)</span><span class="hljs-function"><span class="hljs-keyword">public</span> CommonResult&lt;Payment&gt; <span class="hljs-title">getForEntity</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Long id)</span></span>&#123;    <span class="hljs-comment">// 返回对象为ResponseEntity对象，包含了响应中的一些重要信息，比如响应头、状态码、响应体等</span>    ResponseEntity&lt;CommonResult&gt; entity = restTemplate.getForEntity(PAYMENT_URL + <span class="hljs-string">&quot;/payment/get/&quot;</span> + id, CommonResult.class);    <span class="hljs-keyword">if</span> (entity.getStatusCode().is2xxSuccessful())&#123;        <span class="hljs-keyword">return</span> entity.getBody();    &#125;<span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CommonResult&lt;&gt;(<span class="hljs-number">444</span>, <span class="hljs-string">&quot;失败&quot;</span>);    &#125;&#125;</code></pre><pre><code class="hljs java">RestTemplate的:        xxxForObject()方法,返回的是响应体中的数据    xxxForEntity()方法.返回的是entity对象,这个对象不仅仅包含响应体数据,还包含响应体信息(状态码等)</code></pre><h3 id="3、Ribbon核心组件IRule"><a href="#3、Ribbon核心组件IRule" class="headerlink" title="3、Ribbon核心组件IRule"></a>3、Ribbon核心组件IRule</h3><blockquote><p>IRule:根据特定算法从服务列表中选取一个要访问的服务</p></blockquote><h4 id="a、IRule接口关系"><a href="#a、IRule接口关系" class="headerlink" title="a、IRule接口关系"></a>a、IRule接口关系</h4><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201123203451.png" alt="接口"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201123203612.png" alt="各个算法"></p><h4 id="b、如何替换？"><a href="#b、如何替换？" class="headerlink" title="b、如何替换？"></a>b、如何替换？</h4><p>修改cloud-consumer-order80:</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201125101402.png" alt="说明"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201125101630.png" alt="说明"></p><p>在myrule下添加MySelfRule类</p><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MySelfRule</span> </span>&#123;        <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> IRule <span class="hljs-title">myRule</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RandomRule();    &#125;&#125;</code></pre><p>主启动类添加:</p><pre><code class="hljs java"><span class="hljs-meta">@RibbonClient</span></code></pre><pre><code class="hljs java"><span class="hljs-meta">@RibbonClient(name = &quot;CLOUD-PAYMENT-SERVICE&quot;, configuration = MySelfRule.class)</span></code></pre><h3 id="4、负载均衡算法"><a href="#4、负载均衡算法" class="headerlink" title="4、负载均衡算法"></a>4、负载均衡算法</h3><h4 id="a、轮询原理"><a href="#a、轮询原理" class="headerlink" title="a、轮询原理"></a>a、轮询原理</h4><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201125103222.png" alt="原理"></p><h4 id="b、轮询源码分析"><a href="#b、轮询源码分析" class="headerlink" title="b、轮询源码分析"></a>b、轮询源码分析</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RoundRobinRule</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractLoadBalancerRule</span> </span>&#123;    <span class="hljs-comment">// ... 省略</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RoundRobinRule</span><span class="hljs-params">()</span> </span>&#123;        nextServerCyclicCounter = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">0</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Server <span class="hljs-title">choose</span><span class="hljs-params">(ILoadBalancer lb, Object key)</span> </span>&#123;        <span class="hljs-keyword">if</span> (lb == <span class="hljs-keyword">null</span>) &#123;            log.warn(<span class="hljs-string">&quot;no load balancer&quot;</span>);            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        Server server = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (server == <span class="hljs-keyword">null</span> &amp;&amp; count++ &lt; <span class="hljs-number">10</span>) &#123;            <span class="hljs-comment">// Reachable, 获得状态为UP的Server</span>            List&lt;Server&gt; reachableServers = lb.getReachableServers();            List&lt;Server&gt; allServers = lb.getAllServers();            <span class="hljs-keyword">int</span> upCount = reachableServers.size();            <span class="hljs-comment">// 获取Server数</span>            <span class="hljs-keyword">int</span> serverCount = allServers.size();            <span class="hljs-keyword">if</span> ((upCount == <span class="hljs-number">0</span>) || (serverCount == <span class="hljs-number">0</span>)) &#123;                log.warn(<span class="hljs-string">&quot;No up servers available from load balancer: &quot;</span> + lb);                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;            &#125;            <span class="hljs-keyword">int</span> nextServerIndex = incrementAndGetModulo(serverCount);            server = allServers.get(nextServerIndex);            <span class="hljs-keyword">if</span> (server == <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-comment">/* Transient. */</span>                Thread.yield();                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-keyword">if</span> (server.isAlive() &amp;&amp; (server.isReadyToServe())) &#123;                <span class="hljs-keyword">return</span> (server);            &#125;            <span class="hljs-comment">// Next.</span>            server = <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-keyword">if</span> (count &gt;= <span class="hljs-number">10</span>) &#123;            log.warn(<span class="hljs-string">&quot;No available alive servers after 10 tries from load balancer: &quot;</span>                    + lb);        &#125;        <span class="hljs-keyword">return</span> server;    &#125;        <span class="hljs-comment">// 自旋锁 </span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">incrementAndGetModulo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> modulo)</span> </span>&#123;        <span class="hljs-keyword">for</span> (;;) &#123;            <span class="hljs-keyword">int</span> current = nextServerCyclicCounter.get();            <span class="hljs-comment">// 开始 0 + 1</span>            <span class="hljs-keyword">int</span> next = (current + <span class="hljs-number">1</span>) % modulo;            <span class="hljs-comment">// CAS 比较并交换</span>            <span class="hljs-keyword">if</span> (nextServerCyclicCounter.compareAndSet(current, next))                <span class="hljs-keyword">return</span> next;        &#125;    &#125;&#125;</code></pre><h4 id="d、手写轮询算法"><a href="#d、手写轮询算法" class="headerlink" title="d、手写轮询算法"></a>d、手写轮询算法</h4><blockquote><p>学完JUC再续…</p></blockquote><p>// TODO</p><h2 id="OpenFeign服务接口调用"><a href="#OpenFeign服务接口调用" class="headerlink" title="OpenFeign服务接口调用"></a>OpenFeign服务接口调用</h2><h3 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h3><blockquote><p>Feign是一个声明式的web服务客户端，让编写web服务客户端变得非常容易，只需创建一个接口并在接口上添加注解即可 <a href="https://github.com/spring-cloud/spring-cloud-openfeign">官网</a></p></blockquote><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201125111325.png" alt="概念"></p><blockquote><p>能干什么？</p></blockquote><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201125111350.png" alt="用途"></p><blockquote><p>就是A要调用B,Feign就是在A中创建一个一模一样的B对外提供服务的的接口,我们调用这个接口,就可以服务到B</p></blockquote><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201125112301.png" alt="区别"></p><h3 id="2、使用"><a href="#2、使用" class="headerlink" title="2、使用"></a>2、使用</h3><blockquote><p>之前的服务间调用, 我们使用的是ribbon+RestTemplate, 现在改为使用Feign, 继承了Ribbon, 默认仍是轮询</p></blockquote><h4 id="a、创建cloud-consumer-feign-order80工程"><a href="#a、创建cloud-consumer-feign-order80工程" class="headerlink" title="a、创建cloud-consumer-feign-order80工程"></a>a、创建cloud-consumer-feign-order80工程</h4><p>Pom:</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- openfeign --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>yaml:</p><pre><code class="hljs yaml"><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">80</span><span class="hljs-attr">eureka:</span>  <span class="hljs-attr">client:</span>    <span class="hljs-attr">register-with-eureka:</span> <span class="hljs-literal">false</span>    <span class="hljs-attr">service-url:</span>      <span class="hljs-comment">#defaultZone: http://localhost:7001/eureka</span>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka</span></code></pre><p>主启动类:</p><pre><code class="hljs java"><span class="hljs-meta">@EnableFeignClients</span> <span class="hljs-comment">// 使用Feign, 激活并开启</span></code></pre><h4 id="b、新建PaymentFeignService接口并新增注解-FeignClient"><a href="#b、新建PaymentFeignService接口并新增注解-FeignClient" class="headerlink" title="b、新建PaymentFeignService接口并新增注解@FeignClient:"></a>b、新建PaymentFeignService接口并新增注解@FeignClient:</h4><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-meta">@FeignClient(name = &quot;CLOUD-PAYMENT-SERVICE&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">PaymentFeignService</span> </span>&#123;        <span class="hljs-meta">@GetMapping(&quot;/payment/get/&#123;id&#125;&quot;)</span>    <span class="hljs-function">CommonResult&lt;Payment&gt; <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(value = &quot;id&quot;)</span> Long id)</span></span>;    &#125;</code></pre><h4 id="c、写controller"><a href="#c、写controller" class="headerlink" title="c、写controller"></a>c、写controller</h4><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-meta">@Slf4j</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderController</span> </span>&#123;        <span class="hljs-meta">@Resource</span>    <span class="hljs-keyword">private</span> PaymentFeignService paymentFeignService;        <span class="hljs-meta">@GetMapping(&quot;/consumer/payment/get/&#123;id&#125;&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> CommonResult&lt;Payment&gt; <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(value = &quot;id&quot;)</span> Long id)</span></span>&#123;        <span class="hljs-keyword">return</span> paymentFeignService.get(id);    &#125;&#125;</code></pre><blockquote><p>注: <a href="https://www.cnblogs.com/huhuixin/p/7797850.html">Feign PathVariable annotation was empty on param 0.</a>报错, 需要在@PathVariable中添加Value = “”</p></blockquote><blockquote><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span>  <span class="hljs-attr">application:</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">CLOUD-PAYMENT-SERVICE</span><span class="hljs-comment"># name与用到的地方务必统一大小写 c + shift + u</span></code></pre></blockquote><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201125140748.png" alt="总览"></p><h3 id="3、OpenFeign超时控制"><a href="#3、OpenFeign超时控制" class="headerlink" title="3、OpenFeign超时控制"></a>3、OpenFeign超时控制</h3><blockquote><p>消费调用服务, 一定会存在一种<strong>超时现象</strong>, OpenFeign默认等待一秒钟, 超过后报错</p></blockquote><h4 id="a、在PaymentController中添加timeout接口"><a href="#a、在PaymentController中添加timeout接口" class="headerlink" title="a、在PaymentController中添加timeout接口"></a>a、在PaymentController中添加timeout接口</h4><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-meta">@Slf4j</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PaymentController</span> </span>&#123;    <span class="hljs-meta">@GetMapping(&quot;/payment/timeout&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">timeout</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">try</span> &#123;            TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        <span class="hljs-keyword">return</span> serverPort;    &#125;&#125;</code></pre><h4 id="b、在PaymentFeignService添加"><a href="#b、在PaymentFeignService添加" class="headerlink" title="b、在PaymentFeignService添加"></a>b、在PaymentFeignService添加</h4><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-meta">@FeignClient(value = &quot;cloud-payment-service&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">PaymentFeignService</span> </span>&#123;    <span class="hljs-meta">@GetMapping(&quot;/payment/timeout&quot;)</span>    <span class="hljs-function">String <span class="hljs-title">timeout</span><span class="hljs-params">()</span></span>;&#125;</code></pre><h4 id="c、OrderController中添加"><a href="#c、OrderController中添加" class="headerlink" title="c、OrderController中添加"></a>c、OrderController中添加</h4><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-meta">@Slf4j</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderController</span> </span>&#123;    <span class="hljs-meta">@GetMapping(&quot;/consumer/payment/timeout&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">timeout</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> paymentFeignService.timeout();    &#125;&#125;</code></pre><p>​           <img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201125142929.png" alt="测试结果"></p><h4 id="d、超时控制"><a href="#d、超时控制" class="headerlink" title="d、超时控制"></a>d、超时控制</h4><pre><code class="hljs yaml"><span class="hljs-attr">ribbon:</span>  <span class="hljs-comment"># 建立连接时间</span>  <span class="hljs-attr">ReadTimeout:</span> <span class="hljs-number">5000</span>  <span class="hljs-comment"># 连接后从服务器读取到可用资源时间</span>  <span class="hljs-attr">ConnectTimeout:</span> <span class="hljs-number">5000</span></code></pre><p>​       <img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201125143321.png" alt="测试结果"></p><h3 id="4、日志增强"><a href="#4、日志增强" class="headerlink" title="4、日志增强"></a>4、日志增强</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201125143432.png" alt="openfeign日志"></p><p>写config:</p><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FeignConfig</span> </span>&#123;        <span class="hljs-meta">@Bean</span>    Logger.<span class="hljs-function">Level <span class="hljs-title">feignLoggerLevel</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> Logger.Level.FULL;    &#125;&#125;</code></pre><p>yaml开启:</p><pre><code class="hljs yaml"><span class="hljs-attr">logging:</span>  <span class="hljs-attr">level:</span>     <span class="hljs-attr">com.qiuke.springcloud.service.PaymentFeignService:</span> <span class="hljs-string">debug</span></code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201125144229.png" alt="日志"></p><h1 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a>服务降级</h1><h2 id="Hystrix-断路器"><a href="#Hystrix-断路器" class="headerlink" title="Hystrix 断路器"></a>Hystrix 断路器</h2><h3 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h3><h4 id="a、分布式面临的问题"><a href="#a、分布式面临的问题" class="headerlink" title="a、分布式面临的问题"></a>a、分布式面临的问题</h4><blockquote><p>复杂分布式体系结构中的应用程序有数十个依赖关系, 每个依赖关系在某个时候将不可避免的失败</p></blockquote><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201125144953.png" alt="问题"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201125145028.png" alt="服务雪崩"></p><h4 id="b、Hystrix是什么？"><a href="#b、Hystrix是什么？" class="headerlink" title="b、Hystrix是什么？"></a>b、Hystrix是什么？</h4><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201125145348.png" alt="概念"></p><blockquote><p>功能: 服务降级、服务熔断、接近实时的监控   <a href="https://github.com/Netflix/Hystrix/wiki/How-To-Use">官网</a>   <a href="https://github.com/Netflix/Hystrix">停更进维</a></p></blockquote><h4 id="c、名词概念"><a href="#c、名词概念" class="headerlink" title="c、名词概念"></a>c、名词概念</h4><blockquote><p>服务降级 (fallback)</p></blockquote><p><strong>服务器忙，请稍候再试，不让客户端等待并立刻返回一个友好提示，fallback</strong></p><p>哪些情况会触发降级？</p><ul><li>程序运行异常</li><li>超时</li><li>服务熔断触发服务降级</li><li>线程池/信号量打满也会导致服务降级</li></ul><blockquote><p>服务熔断 (break)</p></blockquote><blockquote><p>服务限流 (flowlimit)</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>Spring Cloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
