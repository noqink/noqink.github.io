<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>设计模式</title>
    <link href="/2020/12/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2020/12/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="设计模式七大原则"><a href="#设计模式七大原则" class="headerlink" title="设计模式七大原则"></a>设计模式七大原则</h1><h2 id="设计模式的目的"><a href="#设计模式的目的" class="headerlink" title="设计模式的目的"></a>设计模式的目的</h2><blockquote><p>编写软件过程中, 程序员面临着来自 <strong><em>耦合性</em></strong>, <strong><em>内聚性</em></strong>, 以及 <strong><em>可维护性</em></strong>, <strong><em>可扩展性</em></strong>, <strong><em>重用性</em></strong>, <strong><em>灵活性</em></strong> 等多方面的挑战, 设计模式是为了让 <strong><em>程序(软件)</em></strong>具有更好的:</p></blockquote><ol><li><p> 代码重用性 (即:相同功能的代码，不用多次编写)</p></li><li><p> 可读性 (即:编程规范性, 便于其他程序员的阅读和理解)</p></li><li><p> 可扩展性 (即:当需要增加新的功能时，非常的方便，称为可维护)</p></li><li><p> 可靠性 (即:当我们增加新的功能后，对原来的功能没有影响)</p></li><li><p>使程序呈现 <strong><em>高内聚，低耦合</em></strong>的特性</p><p> <strong>分享金句</strong>: </p><p>设计模式包含了面向对象的精髓，“懂了设计模式，你就懂了面向对象分析和设计(OOA/D)的精要”</p><p>Scott Mayers 在其巨著《Effective C++》就曾经说过:C++老手和 C++新手的区别就是前者手背上有很多伤疤</p></li></ol><h2 id="设计模式七大原则-1"><a href="#设计模式七大原则-1" class="headerlink" title="设计模式七大原则"></a>设计模式七大原则</h2><blockquote><p>设计模式原则，其实就是 <strong><em>程序员在编程时，应当遵守的原则</em></strong>，也是各种设计模式的基础(即:设计模式为什么这样设计的依据)</p></blockquote><p>设计模式常用的七大原则有:</p><ol><li><p>单一职责原则</p></li><li><p>接口隔离原则</p></li><li><p>依赖倒转(倒置)原则 </p></li><li><p>里氏替换原则</p></li><li><p>开闭原则</p></li><li><p>迪米特法则</p></li><li><p>合成复用原则</p></li></ol><h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>​        对类来说的，即一个类应该 <strong><em>只负责一项职责</em></strong>。如类 A 负责两个不同职责:职责 1，职责 2。当职责 1 需求变更 而改变 A 时，可能造成职责 2 执行错误，所以需要将类 A 的 <strong><em>粒度分解</em></strong>为 A1，A2</p><h4 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h4><p>以交通工具案例讲解</p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201201195254.png" alt="test" style="zoom:50%;" /><p>//  交通工具类<br>// 方式 1<br>// 1)在方式 1 的 run 方法中，违反了 <strong><em>单一职责原则</em></strong><br>// 2)解决的方案非常的简单，根据交通工具运行方法不同，分解成不同类即可</p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201201195739.png" alt="解耦后" style="zoom:50%;" /><p>// 方案 2 的分析<br>// 1. 遵守单一职责原则<br>// 2. 但是这样做的改动很大，即将类分解，同时修改客户端 </p><p> 改进:直接修改 Vehicle 类，改动的代码会比较少=&gt;方案 3</p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201201200149.png" alt="方案3" style="zoom:50%;" /><p>​    // 方式 3 的分析</p><p>​    //  1. 这种修改方法没有对原来的类做大的修改，只是增加方法<br>   //   2. 这里虽然没有在类这个级别上遵守单一职责原则，但是在方法级别上，仍然是遵守单一职责</p><pre><code>#### 单一职责原则注意事项和细节</code></pre><blockquote><p>  方法数量足够少，可以在方法级别保持单一职责原则</p></blockquote><ol><li> 降低类的复杂度，一个类只负责一项职责。</li><li> 提高类的可读性，可维护性</li><li> 降低变更引起的风险</li><li> 通常情况下，*<strong>我们应当遵守单一职责原则***，只有 *</strong>逻辑足够简单，才可以在代码级违反单一职责原则***;只有类中方法数量足够少，可以在方法级别保持单一职责原则</li></ol><h3 id="接口隔离原则-Interface-Segregation-Principle"><a href="#接口隔离原则-Interface-Segregation-Principle" class="headerlink" title="接口隔离原则(Interface Segregation Principle)"></a>接口隔离原则(Interface Segregation Principle)</h3><h4 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h4><ol><li><p>客户端不应该依赖它不需要的接口，即 <strong>一个类对另一个类的依赖应该建立在最小的接口</strong>上</p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201201201726.png" alt="接口隔离原则" style="zoom: 50%;" /></li></ol><p>B、D代表实现</p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201201203605.png" alt="接口实现" style="zoom:50%;" /><p>​    3.     类A通过接口Interface1依赖类B，类C通过接口Interface1依赖类D，如果接口Interface1对于类A和类C</p><p>来说不是最小接口，那么类 B 和类 D 必须去实现他们不需要的方法。 </p><p>​    4.    按隔离原则应当这样处理:</p><p>​    将接口  **Interface1 拆分为独立的几个接口(这里我们拆分成 3 个接口)**，类 A 和类 C 分别与他们需要的接口建立 依赖关系。也就是采用接口隔离原则</p><h4 id="应用实例-1"><a href="#应用实例-1" class="headerlink" title="应用实例"></a>应用实例</h4><ol><li>实现方案1+分析说明</li></ol><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Interface1</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operation1</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operation2</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operation3</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operation4</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operation5</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Interface1</span></span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation1</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;B&quot;</span> + <span class="hljs-number">1</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation2</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;B&quot;</span> + <span class="hljs-number">2</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation3</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;B&quot;</span> + <span class="hljs-number">3</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation4</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;B&quot;</span> + <span class="hljs-number">4</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation5</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;B&quot;</span> + <span class="hljs-number">5</span>);    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">D</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Interface1</span></span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation1</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;D&quot;</span> + <span class="hljs-number">1</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation2</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;D&quot;</span> + <span class="hljs-number">2</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation3</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;D&quot;</span> + <span class="hljs-number">3</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation4</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;D&quot;</span> + <span class="hljs-number">4</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation5</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;D&quot;</span> + <span class="hljs-number">5</span>);    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123; <span class="hljs-comment">// A类通过接口Interface1 依赖(使用)B类 但是只会用到1,2,3方法</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">depend1</span><span class="hljs-params">(Interface1 i)</span> </span>&#123;        i.operation1();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">depend2</span><span class="hljs-params">(Interface1 i)</span> </span>&#123;        i.operation2();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">depend3</span><span class="hljs-params">(Interface1 i)</span> </span>&#123;        i.operation3();    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> </span>&#123; <span class="hljs-comment">// C类通过接口Interface1 依赖(使用)D类 但是只会用到1,4,5方法</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">depend1</span><span class="hljs-params">(Interface1 i)</span> </span>&#123;        i.operation1();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">depend4</span><span class="hljs-params">(Interface1 i)</span> </span>&#123;        i.operation4();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">depend5</span><span class="hljs-params">(Interface1 i)</span> </span>&#123;        i.operation5();    &#125;&#125;</code></pre><h4 id="应传统方法的问题和使用接口隔离原则改进"><a href="#应传统方法的问题和使用接口隔离原则改进" class="headerlink" title="应传统方法的问题和使用接口隔离原则改进"></a>应传统方法的问题和使用接口隔离原则改进</h4><ol><li><p>类A通过接口Interface1依赖类B，类C通过接口Interface1依赖类D，如果接口Interface1对于类A和类C</p><p>来说不是最小接口，那么类 B 和类 D 必须去实现他们不需要的方法</p></li><li><p>将接口 <strong>Interface1</strong>拆分为独立的几个接口，类A和类C分别与他们需要的接口建立依赖关系。也就是采用接口 隔离原则</p><p>接口Interface1中出现的方法，根据实际情况拆分为三个接口</p></li></ol><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201201204019.png" alt="原理" style="zoom:50%;" /><img src="../../Library/Application Support/typora-user-images/image-20201201204856491.png" alt="解耦后" style="zoom:50%;" /><pre><code class="hljs java"><span class="hljs-comment">// 接口 1</span><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Interface1</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operation1</span><span class="hljs-params">()</span></span>; &#125;<span class="hljs-comment">// 接口 2</span><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Interface2</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operation2</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operation3</span><span class="hljs-params">()</span></span>; &#125;<span class="hljs-comment">// 接口 3</span><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Interface3</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operation4</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operation5</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Interface1</span>, <span class="hljs-title">Interface2</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation1</span><span class="hljs-params">()</span> </span>&#123; System.out.println(<span class="hljs-string">&quot;B 1&quot;</span>);&#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation2</span><span class="hljs-params">()</span> </span>&#123; System.out.println(<span class="hljs-string">&quot;B 1&quot;</span>);&#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation3</span><span class="hljs-params">()</span> </span>&#123; System.out.println(<span class="hljs-string">&quot;B 3&quot;</span>);&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">D</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Interface1</span>, <span class="hljs-title">Interface3</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation1</span><span class="hljs-params">()</span> </span>&#123; System.out.println(<span class="hljs-string">&quot;D 1&quot;</span>);&#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation4</span><span class="hljs-params">()</span> </span>&#123; System.out.println(<span class="hljs-string">&quot;D 4&quot;</span>);&#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation5</span><span class="hljs-params">()</span> </span>&#123; System.out.println(<span class="hljs-string">&quot;D 5&quot;</span>);&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123; <span class="hljs-comment">// A 类通过接口 Interface1,Interface2 依赖(使用) B 类，但是只会用到 1,2,3 方法 public void depend1(Interface1 i) &#123;</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">depend1</span><span class="hljs-params">(Interface1 i)</span> </span>&#123; i.operation1(); &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">depend2</span><span class="hljs-params">(Interface2 i)</span> </span>&#123; i.operation2(); &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">depend3</span><span class="hljs-params">(Interface2 i)</span> </span>&#123; i.operation3(); &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> </span>&#123; <span class="hljs-comment">// C 类通过接口 Interface1,Interface3 依赖(使用) D 类，但是只会用到 1,4,5 方法 public void depend1(Interface1 i) &#123;</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">depend1</span><span class="hljs-params">(Interface1 i)</span> </span>&#123; i.operation1(); &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">depend4</span><span class="hljs-params">(Interface3 i)</span> </span>&#123; i.operation4(); &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">depend5</span><span class="hljs-params">(Interface3 i)</span> </span>&#123; i.operation5(); &#125;&#125;</code></pre><pre><code class="hljs java">A a = <span class="hljs-keyword">new</span> A();a.depend1(<span class="hljs-keyword">new</span> B()); <span class="hljs-comment">// A类通过接口去依赖B类</span>a.depend2(<span class="hljs-keyword">new</span> B());a.depend3(<span class="hljs-keyword">new</span> B());C c = <span class="hljs-keyword">new</span> C();c.depend1(<span class="hljs-keyword">new</span> D()); <span class="hljs-comment">// C类通过接口去依赖D类</span>c.depend4(<span class="hljs-keyword">new</span> D());c.depend5(<span class="hljs-keyword">new</span> D());</code></pre><h3 id="依赖倒转原则-Dependence-Inversion-Principle"><a href="#依赖倒转原则-Dependence-Inversion-Principle" class="headerlink" title="依赖倒转原则(Dependence Inversion Principle)"></a>依赖倒转原则(Dependence Inversion Principle)</h3><h4 id="基本介绍-2"><a href="#基本介绍-2" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>依赖倒转原则(Dependence Inversion Principle)是指:</p><ol><li><p> 高层模块不应该依赖低层模块，二者都应该依赖其抽象(抽象类、接口都可以)</p></li><li><p> <strong><em>抽象不应该依赖细节，细节应该依赖抽象</em></strong></p></li><li><p> 依赖倒转(倒置)的中心思想是 <strong><em>面向接口编程</em></strong></p></li><li><p> 依赖倒转原则是基于这样的设计理念:相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架 构比以细节为基础的架构要稳定的多。在 java 中，抽象指的是接口或抽象类，细节就是具体的实现类</p></li><li><p>使用 <strong><em>接口或抽象类</em></strong>的目的是制定好 <strong><em>规范</em></strong>，而不涉及任何具体的操作，把 <strong><em>展现细节的任务交给他们的实现类</em></strong>去完成</p><h4 id="应用实例-2"><a href="#应用实例-2" class="headerlink" title="应用实例"></a>应用实例</h4></li></ol><p>请编程完成 Person 接收消息 的功能。</p><ol><li>实现方案1+分析说明</li></ol><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DependecyInversion1</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Person person = <span class="hljs-keyword">new</span> Person();        person.receive(<span class="hljs-keyword">new</span> Email());    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Email</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getInfo</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;电子邮件信息: hello,world&quot;</span>; &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receive</span><span class="hljs-params">(Email email )</span> </span>&#123; System.out.println(email.getInfo()); &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-comment">//  方式 1 分析</span><span class="hljs-number">1.</span> 简单，比较容易想到<span class="hljs-number">2.</span> 如果我们获取的对象是 微信，短信等等，则新增类，同时 Perons 也要增加相应的接收方法<span class="hljs-number">3.</span> 解决思路:引入一个抽象的接口 IReceiver, 表示接收者, 这样 Person 类与接口 IReceiver 发生依赖</code></pre><ol start="2"><li>实现方案2+分析说明</li></ol><pre><code class="hljs java"><span class="hljs-comment">// 定义接口</span><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IReceiver</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getInfo</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EmailImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IReceiver</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getInfo</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;电子邮件信息: hello,world&quot;</span>;    &#125;&#125;<span class="hljs-comment">//增加微信</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WeiXin</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IReceiver</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getInfo</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;微信信息: hello,ok&quot;</span>;    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PersonNew</span> </span>&#123;    <span class="hljs-comment">//这里我们是对接口的依赖</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receive</span><span class="hljs-params">(IReceiver receiver )</span> </span>&#123;        System.out.println(receiver.getInfo());    &#125;&#125;</code></pre><h4 id="依赖关系传递的三种方式和应用案例"><a href="#依赖关系传递的三种方式和应用案例" class="headerlink" title="依赖关系传递的三种方式和应用案例"></a>依赖关系传递的三种方式和应用案例</h4><blockquote><p>接口传递</p></blockquote><pre><code class="hljs java"><span class="hljs-comment">// 方式1：通过接口传递实现依赖</span><span class="hljs-comment">// 开关的接口</span><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IOpenAndClose</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">open</span><span class="hljs-params">(ITV tv)</span></span>; <span class="hljs-comment">//抽象方法，接收接口</span>&#125;<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ITV</span> </span>&#123; <span class="hljs-comment">//ITV接口</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">play</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OpenAndClose</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IOpenAndClose</span></span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">open</span><span class="hljs-params">(ITV tv)</span></span>&#123;   tv.play();   &#125;&#125;<span class="hljs-comment">// 如何使用?</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChangHong</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ITV</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">play</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;打开changhong TV&quot;</span>);    &#125;&#125;<span class="hljs-comment">// 使用</span>ChangHong changHong = <span class="hljs-keyword">new</span> ChangHong();OpenAndClose openAndClose = <span class="hljs-keyword">new</span> OpenAndClose();openAndClose.open(changHong);</code></pre><blockquote><p>构造方法传递 </p></blockquote><pre><code class="hljs java"><span class="hljs-comment">// 方式2：通过构造方法依赖传递</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IOpenAndClose</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">open</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//抽象方法</span> &#125; <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ITV</span> </span>&#123; <span class="hljs-comment">//ITV接口</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">play</span><span class="hljs-params">()</span></span>; &#125; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OpenAndClose</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IOpenAndClose</span></span>&#123;   <span class="hljs-keyword">public</span> ITV tv;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">OpenAndClose</span><span class="hljs-params">(ITV tv)</span></span>&#123; <span class="hljs-comment">//构造器</span>      <span class="hljs-keyword">this</span>.tv = tv;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">open</span><span class="hljs-params">()</span></span>&#123;   <span class="hljs-keyword">this</span>.tv.play();   &#125; &#125;<span class="hljs-comment">// 如何使用？</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChangHong</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ITV</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">play</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;打开changhong TV&quot;</span>);    &#125;&#125;<span class="hljs-comment">// 使用：</span>ChangHong changHong = <span class="hljs-keyword">new</span> ChangHong();OpenAndClose openAndClose = <span class="hljs-keyword">new</span> OpenAndClose(changHong);openAndClose.open();</code></pre><blockquote><p>setter 方式传递</p></blockquote><pre><code class="hljs java"><span class="hljs-comment">// 方式3：setter方法实现</span><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IOpenAndClose</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">open</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 抽象方法</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setTv</span><span class="hljs-params">(ITV tv)</span></span>;&#125;<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ITV</span> </span>&#123; <span class="hljs-comment">// ITV接口</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">play</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OpenAndClose</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IOpenAndClose</span> </span>&#123;   <span class="hljs-keyword">private</span> ITV tv;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setTv</span><span class="hljs-params">(ITV tv)</span> </span>&#123;      <span class="hljs-keyword">this</span>.tv = tv;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">open</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">this</span>.tv.play();   &#125;&#125;<span class="hljs-comment">// 如何使用？</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChangHong</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ITV</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">play</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;打开changhong TV&quot;</span>);    &#125;&#125;        ChangHong changHong = <span class="hljs-keyword">new</span> ChangHong();        OpenAndClose openAndClose = <span class="hljs-keyword">new</span> OpenAndClose();        openAndClose.setTv(changHong);        openAndClose.open();</code></pre><h4 id="依赖倒转原则的注意事项和细节"><a href="#依赖倒转原则的注意事项和细节" class="headerlink" title="依赖倒转原则的注意事项和细节"></a>依赖倒转原则的注意事项和细节</h4><ol><li>  低层模块尽量都要有抽象类或接口，或者两者都有，程序稳定性更好.</li><li>   <strong><em>变量的声明类型尽量是抽象类或接口</em></strong>, 这样我们的变量引用和实际对象间，就存在一个 <strong><em>缓冲层</em></strong>，利于程序扩展和优化</li><li>  继承时遵循 <strong><em>里氏替换</em></strong>原则</li></ol><h3 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h3><h4 id="OO-中的继承性的思考和说明"><a href="#OO-中的继承性的思考和说明" class="headerlink" title="OO 中的继承性的思考和说明"></a>OO 中的继承性的思考和说明</h4><ol><li>继承包含这样一层含义: <strong>父类中凡是已经实现好的方法，实际上是在设定规范和契约</strong>，虽然它不强制要求所有 的子类必须遵循这些契约，但是如果子类对这些已经实现的方法任意修改，就会对整个继承体系造成破坏。</li><li> <strong>继承在给程序设计带来便利的同时，也带来了弊端</strong>。比如使用继承会给程序带来 <strong>侵入性</strong>，程序的可移植性降低， <strong>增加对象间的耦合性</strong>，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且 父类修改后，所有涉及到子类的功能都有可能产生故障</li><li>问题提出: <strong>在编程中，如何正确的使用继承?</strong> =&gt;  <strong>里氏替换原则</strong></li></ol><h4 id="基本介绍-3"><a href="#基本介绍-3" class="headerlink" title="基本介绍"></a>基本介绍</h4><ol><li>里氏替换原则(LiskovSubstitutionPrinciple)在1988年，由麻省理工学院的以为姓里的女士提出的。</li><li>如果对每个类型为T1的对象o1，都有类型为T2的对象o2，使得以T1定义的所有程序P在所有的对象o1都 代换成 o2 时，程序 P 的行为没有发生变化，那么类型 T2 是类型 T1 的子类型。换句话说， <strong><em>所有引用基类的地 方必须能透明地使用其子类的对象</em></strong>。</li><li>在使用继承时，遵循里氏替换原则，在 <strong><em>子类中尽量不要重写父类的方法</em></strong>。</li><li>里氏替换原则告诉我们，继承实际上让两个类耦合性增强了，在适当的情况下，可以通过 <strong><em>聚合，组合，依赖</em></strong>来解决问题。</li></ol><h4 id="一个程序引出的问题和思考"><a href="#一个程序引出的问题和思考" class="headerlink" title="一个程序引出的问题和思考"></a>一个程序引出的问题和思考</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Liskov1</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        A a = <span class="hljs-keyword">new</span> A();        System.out.println(<span class="hljs-string">&quot;11-3=&quot;</span> + a.func1(<span class="hljs-number">11</span>, <span class="hljs-number">3</span>));        System.out.println(<span class="hljs-string">&quot;1-8=&quot;</span> + a.func1(<span class="hljs-number">1</span>, <span class="hljs-number">8</span>));        System.out.println(<span class="hljs-string">&quot;-----------------------&quot;</span>);        B b = <span class="hljs-keyword">new</span> B();        System.out.println(<span class="hljs-string">&quot;11-3=&quot;</span> + b.func1(<span class="hljs-number">11</span>, <span class="hljs-number">3</span>));<span class="hljs-comment">//这里本意是求出 11-3</span>        System.out.println(<span class="hljs-string">&quot;1-8=&quot;</span> + b.func1(<span class="hljs-number">1</span>, <span class="hljs-number">8</span>));        <span class="hljs-comment">// 1-8</span>        System.out.println(<span class="hljs-string">&quot;11+3+9=&quot;</span> + b.func2(<span class="hljs-number">11</span>, <span class="hljs-number">3</span>));    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;    <span class="hljs-comment">// 返回两个数的差</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">func1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num1, <span class="hljs-keyword">int</span> num2)</span> </span>&#123; <span class="hljs-keyword">return</span> num1 - num2; &#125;&#125;<span class="hljs-comment">// B 类继承了 A</span><span class="hljs-comment">// 增加了一个新功能:完成两个数相加,然后和 9 求和</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> </span>&#123;    <span class="hljs-comment">//这里，重写了 A 类的方法, 可能是无意识</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">func1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123; <span class="hljs-keyword">return</span> a + b; &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">func2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123; <span class="hljs-keyword">return</span> func1(a, b) + <span class="hljs-number">9</span>; &#125;&#125;</code></pre><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><ol><li><p>我们发现原来运行正常的相减功能发生了错误。原因就是 <strong><em>类B无意中重写了父类的方法，造成原有功能出现错误</em></strong>。在实际编程中，我们常常会通过重写父类的方法完成新的功能，这样写起来虽然简单，但整个继承体系的复用性会比较差。特别是运行多态比较频繁的时候</p></li><li><p>通用的做法是: <strong><em>原来的父类和子类都继承一个更通俗的基类，原有的继承关系去掉，采用依赖，聚合，组合等 关系代替</em></strong>.</p></li></ol><pre><code class="hljs java"><span class="hljs-comment">//创建一个更加基础的基类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span> </span>&#123;    <span class="hljs-comment">//把更加基础的方法和成员写到 Base 类</span>&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Base</span></span>&#123;    <span class="hljs-comment">// 返回两个数的差</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">func1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num1, <span class="hljs-keyword">int</span> num2)</span> </span>&#123; <span class="hljs-keyword">return</span> num1 - num2; &#125;&#125;<span class="hljs-comment">// 增加了一个新功能:完成两个数相加,然后和 9 求和</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Base</span> </span>&#123;    <span class="hljs-comment">//如果 B 需要使用 A 类的方法,使用组合关系</span>    <span class="hljs-keyword">private</span> A a = <span class="hljs-keyword">new</span> A();    <span class="hljs-comment">//我们仍然想使用 A 的方法</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">func3</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.a.func1(a, b)&#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">func1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123; <span class="hljs-keyword">return</span> a + b; &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">func2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123; <span class="hljs-keyword">return</span> func1(a, b) + <span class="hljs-number">9</span>; &#125;&#125;</code></pre><h3 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h3><h4 id="基本介绍-4"><a href="#基本介绍-4" class="headerlink" title="基本介绍"></a>基本介绍</h4><ol><li><p>开闭原则(OpenClosedPrinciple)是编程中 <strong><em>最基础、最重要</em></strong>的设计原则</p></li><li><p> 一个软件实体如类，模块和函数应该对 <strong><em>扩展开放(对提供方)，对修改关闭(对使用方)</em></strong>。用抽象构建框架，用实</p></li></ol><p>现扩展细节。</p><ol start="3"><li><p> 当软件需要变化时，尽量 <strong>通过扩展</strong>软件实体的行为来实现变化，而不是 <strong>通过修改</strong>已有的代码来实现变化。</p></li><li><p>编程中遵循其它原则，以及使用设计模式的目的就是遵循开闭原则。</p></li></ol><h4 id="应用实例-3"><a href="#应用实例-3" class="headerlink" title="应用实例"></a>应用实例</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ocp</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        GraphicEditor graphicEditor = <span class="hljs-keyword">new</span> GraphicEditor();        graphicEditor.drawShape(<span class="hljs-keyword">new</span> Rectangle());        graphicEditor.drawShape(<span class="hljs-keyword">new</span> Circle());        graphicEditor.drawShape(<span class="hljs-keyword">new</span> Triangle());    &#125;&#125;<span class="hljs-comment">//绘图类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GraphicEditor</span> </span>&#123;    <span class="hljs-comment">//接受Shape对象 根据m_type绘制图像</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">drawShape</span><span class="hljs-params">(Shape s)</span> </span>&#123;        <span class="hljs-keyword">if</span> (s.m_type == <span class="hljs-number">1</span>)            drawRectangle(s);        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s.m_type == <span class="hljs-number">2</span>)            drawCircle(s);    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">drawRectangle</span><span class="hljs-params">(Shape r)</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot; 矩形 &quot;</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">drawCircle</span><span class="hljs-params">(Shape r)</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot; 圆形 &quot;</span>);    &#125;&#125;<span class="hljs-comment">//Shape类 基类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Shape</span> </span>&#123;    <span class="hljs-keyword">int</span> m_type;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Shape</span> </span>&#123;    Rectangle() &#123;        <span class="hljs-keyword">super</span>.m_type = <span class="hljs-number">1</span>;    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Shape</span> </span>&#123;    Circle() &#123;        <span class="hljs-keyword">super</span>.m_type = <span class="hljs-number">2</span>;    &#125;&#125;</code></pre><p> 问题出在, 如果要新增一个, 需要修改许多:</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Triangle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Shape</span> </span>&#123;    Triangle() &#123;        <span class="hljs-keyword">super</span>.m_type = <span class="hljs-number">3</span>;    &#125;&#125;<span class="hljs-comment">// 如果新增 则需要</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">drawTriangle</span><span class="hljs-params">(Shape r)</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;  &quot;</span>);    &#125;<span class="hljs-comment">// 还需要</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">drawShape</span><span class="hljs-params">(Shape s)</span> </span>&#123;        <span class="hljs-keyword">if</span> (s.m_type == <span class="hljs-number">1</span>)            drawRectangle(s);        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s.m_type == <span class="hljs-number">2</span>)            drawCircle(s);        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s.m_type == <span class="hljs-number">3</span>)            drawTriangle(s);&#125;</code></pre><ol><li><p>优点是比较好理解，简单易操作。</p></li><li><p>缺点是 <strong>违反了设计模式的ocp原则</strong>，即对扩展开放(提供方)，对修改关闭(使用方)。即当我们给类增加新功能的时候，尽量不修改代码，或者尽可能少修改代码.</p></li><li><p>比如我们这时要新增加一个图形种类三角形，我们需要做如上修改，修改的地方较多</p></li></ol><h4 id="改进的思路分析"><a href="#改进的思路分析" class="headerlink" title="改进的思路分析"></a>改进的思路分析</h4><p>思路:把创建 <strong>Shape</strong> 类做成抽象类，并提供一个抽象的 <strong>draw</strong> 方法，让子类去实现即可，这样我们有新的图形 种类时，只需要让新的图形类继承 Shape，并实现 draw 方法即可，使用方的代码就不需要修 -&gt; 满足了开闭原则</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ocp</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        GraphicEditor graphicEditor = <span class="hljs-keyword">new</span> GraphicEditor();        graphicEditor.drawShape(<span class="hljs-keyword">new</span> Rectangle());        graphicEditor.drawShape(<span class="hljs-keyword">new</span> Circle());        graphicEditor.drawShape(<span class="hljs-keyword">new</span> Triangle());        graphicEditor.drawShape(<span class="hljs-keyword">new</span> OtherGraphic());    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GraphicEditor</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">drawShape</span><span class="hljs-params">(Shape s)</span> </span>&#123;        s.draw();    &#125;&#125;<span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Shape</span> </span>&#123;    <span class="hljs-keyword">int</span> m_type;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Shape</span> </span>&#123;    Rectangle() &#123;        <span class="hljs-keyword">super</span>.m_type = <span class="hljs-number">1</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot; 矩形 &quot;</span>);    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Shape</span> </span>&#123;    Circle() &#123;        <span class="hljs-keyword">super</span>.m_type = <span class="hljs-number">2</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot; 圆形 &quot;</span>);    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Triangle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Shape</span> </span>&#123;    Triangle() &#123;        <span class="hljs-keyword">super</span>.m_type = <span class="hljs-number">3</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// TODO Auto-generated method stub</span>        System.out.println(<span class="hljs-string">&quot; 三角形 &quot;</span>);    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OtherGraphic</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Shape</span> </span>&#123;    OtherGraphic() &#123;        <span class="hljs-keyword">super</span>.m_type = <span class="hljs-number">4</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// TODO Auto-generated method stub</span>        System.out.println(<span class="hljs-string">&quot; 其他 &quot;</span>);    &#125;&#125;</code></pre><h3 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h3><h4 id="基本介绍-5"><a href="#基本介绍-5" class="headerlink" title="基本介绍"></a>基本介绍</h4><ol><li>一个对象应该对其他对象 <strong>保持最少的了解</strong></li><li>类与类关系越密切，耦合度越大</li><li>迪米特法则(DemeterPrinciple)又叫 <strong>最少知道原则</strong>，即一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类不管多么复杂，都尽量 <strong>将逻辑封装在类的内部</strong>。对外除了提供的 public 方法，不对外泄露任何信息</li><li>迪米特法则还有个更简单的定义: <strong>只与直接的朋友通信</strong></li><li>直接的朋友:每个对象都会与其他对象有 <strong>耦合关系</strong>，只要两个对象之间有耦合关系，我们就说这两个对象之间 是朋友关系。耦合的方式很多，依赖，关联，组合，聚合等。其中，我们称出现 <strong>成员变量，方法参数，方法返 回值中的类</strong>为直接的朋友，而出现在 <strong>局部变量中的类不是直接的朋友</strong>。也就是说，陌生的类最好不要以局部变 量的形式出现在类的内部。</li></ol><h4 id="应用实例-4"><a href="#应用实例-4" class="headerlink" title="应用实例"></a>应用实例</h4><ol><li><p>有一个学校，下属有各个学院和总部，现要求打印出学校总部员工ID和学院员工的id </p></li><li><p>编程实现上面的功能, 看代码演示</p></li><li><p>代码演示</p></li></ol><pre><code class="hljs java"><span class="hljs-comment">//迪米特法则</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demeter1</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SchoolManager schoolManager = <span class="hljs-keyword">new</span> SchoolManager();        schoolManager.printAllEmployee(<span class="hljs-keyword">new</span> CollegeManager());    &#125;&#125;<span class="hljs-comment">// 学校总部员工</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span> </span>&#123;    <span class="hljs-keyword">private</span> String id;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(String id)</span> </span>&#123;        <span class="hljs-keyword">this</span>.id = id;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> id;    &#125;&#125;<span class="hljs-comment">// 学院员工</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CollegeEmployee</span> </span>&#123;    <span class="hljs-keyword">private</span> String id;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(String id)</span> </span>&#123;        <span class="hljs-keyword">this</span>.id = id;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> id;    &#125;&#125;<span class="hljs-comment">// 管理学院员工类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CollegeManager</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;CollegeEmployee&gt; <span class="hljs-title">getAllEmployee</span><span class="hljs-params">()</span> </span>&#123;        List&lt;CollegeEmployee&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;CollegeEmployee&gt;();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;            CollegeEmployee emp = <span class="hljs-keyword">new</span> CollegeEmployee();            emp.setId(<span class="hljs-string">&quot;学校员工id= &quot;</span> + i);            list.add(emp);        &#125;        <span class="hljs-keyword">return</span> list;    &#125;&#125;<span class="hljs-comment">// 管理学校员工类</span><span class="hljs-comment">//分析 SchoolManager 类的直接朋友类有哪些 Employee、CollegeManager </span><span class="hljs-comment">//CollegeEmployee 不是 直接朋友 而是一个陌生类，这样违背了 迪米特法则</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SchoolManager</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Employee&gt; <span class="hljs-title">getAllEmployee</span><span class="hljs-params">()</span> </span>&#123;        List&lt;Employee&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Employee&gt;();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;            Employee emp = <span class="hljs-keyword">new</span> Employee();            emp.setId(<span class="hljs-string">&quot;学院员工id= &quot;</span> + i);            list.add(emp);        &#125;        <span class="hljs-keyword">return</span> list;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printAllEmployee</span><span class="hljs-params">(CollegeManager sub)</span> </span>&#123;                <span class="hljs-comment">//分析问题</span>                <span class="hljs-comment">//1. 这里的 CollegeEmployee 不是 SchoolManager 的直接朋友 </span>        <span class="hljs-comment">//2. CollegeEmployee 是以局部变量方式出现在 SchoolManager</span>        <span class="hljs-comment">//3. 违反了 迪米特法则</span>        List&lt;CollegeEmployee&gt; list1 = sub.getAllEmployee();        System.out.println(<span class="hljs-string">&quot;------------学院总部------------&quot;</span>);        <span class="hljs-keyword">for</span> (CollegeEmployee e : list1) &#123;            System.out.println(e.getId());        &#125;        List&lt;Employee&gt; list2 = <span class="hljs-keyword">this</span>.getAllEmployee();        System.out.println(<span class="hljs-string">&quot;------------学校总部------------&quot;</span>);        <span class="hljs-keyword">for</span> (Employee e : list2) &#123;            System.out.println(e.getId());        &#125;    &#125;&#125;</code></pre><h4 id="应用实例改进"><a href="#应用实例改进" class="headerlink" title="应用实例改进"></a>应用实例改进</h4><ol><li><p>前面设计的问题在于SchoolManager中，<strong>CollegeEmployee</strong>类并不是<strong>SchoolManager</strong>类的直接朋友(分析) </p></li><li><p>按照迪米特法则，应该避免类中出现这样非直接朋友关系的耦合</p></li></ol><pre><code class="hljs java"><span class="hljs-comment">//迪米特法则</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demeter1</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SchoolManager schoolManager = <span class="hljs-keyword">new</span> SchoolManager();        schoolManager.printAllEmployee(<span class="hljs-keyword">new</span> CollegeManager());    &#125;&#125;<span class="hljs-comment">// 学校总部员工</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span> </span>&#123;    <span class="hljs-keyword">private</span> String id;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(String id)</span> </span>&#123;        <span class="hljs-keyword">this</span>.id = id;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> id;    &#125;&#125;<span class="hljs-comment">// 学院员工</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CollegeEmployee</span> </span>&#123;    <span class="hljs-keyword">private</span> String id;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(String id)</span> </span>&#123;        <span class="hljs-keyword">this</span>.id = id;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> id;    &#125;&#125;<span class="hljs-comment">// 管理学院员工类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CollegeManager</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;CollegeEmployee&gt; <span class="hljs-title">getAllEmployee</span><span class="hljs-params">()</span> </span>&#123;        List&lt;CollegeEmployee&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;CollegeEmployee&gt;();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;            CollegeEmployee emp = <span class="hljs-keyword">new</span> CollegeEmployee();            emp.setId(<span class="hljs-string">&quot;学校员工id= &quot;</span> + i);            list.add(emp);        &#125;        <span class="hljs-keyword">return</span> list;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printAllCollegeEmployee</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-comment">// 将输出转移到CollegeManager类中</span>        List&lt;CollegeEmployee&gt; list1 = <span class="hljs-keyword">this</span>.getAllEmployee();        System.out.println(<span class="hljs-string">&quot;------------学院总部------------&quot;</span>);        <span class="hljs-keyword">for</span> (CollegeEmployee e : list1) &#123;            System.out.println(e.getId());        &#125;    &#125;&#125;<span class="hljs-comment">// 管理学校员工类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SchoolManager</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Employee&gt; <span class="hljs-title">getAllEmployee</span><span class="hljs-params">()</span> </span>&#123;        List&lt;Employee&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Employee&gt;();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;            Employee emp = <span class="hljs-keyword">new</span> Employee();            emp.setId(<span class="hljs-string">&quot;学院员工id= &quot;</span> + i);            list.add(emp);        &#125;        <span class="hljs-keyword">return</span> list;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printAllEmployee</span><span class="hljs-params">(CollegeManager sub)</span> </span>&#123;        <span class="hljs-comment">// 将输出转移到CollegeManager类中</span>        sub.printAllCollegeEmployee();        List&lt;Employee&gt; list2 = <span class="hljs-keyword">this</span>.getAllEmployee();        System.out.println(<span class="hljs-string">&quot;------------学校总部------------&quot;</span>);        <span class="hljs-keyword">for</span> (Employee e : list2) &#123;            System.out.println(e.getId());        &#125;    &#125;&#125;</code></pre><h4 id="迪米特法则注意事项和细节"><a href="#迪米特法则注意事项和细节" class="headerlink" title="迪米特法则注意事项和细节"></a>迪米特法则注意事项和细节</h4><ol><li>迪米特法则的核心是 <strong>降低类之间的耦合</strong></li><li>但是注意:由于每个类都减少了不必要的依赖，因此迪米特法则 <strong>只是要求降低类间(对象间)耦合关系，并不是要求完全没有依赖关系</strong></li></ol><h3 id="合成复用原则-Composite-Reuse-Principle"><a href="#合成复用原则-Composite-Reuse-Principle" class="headerlink" title="合成复用原则(Composite Reuse Principle)"></a>合成复用原则(Composite Reuse Principle)</h3><h4 id="基本介绍-6"><a href="#基本介绍-6" class="headerlink" title="基本介绍"></a>基本介绍</h4><blockquote><p>原则是尽量使用合成/聚合的方式，而不是使用继承</p></blockquote><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201202110642.png" alt="不使用继承" style="zoom:50%;" /><h4 id="设计原则核心思想"><a href="#设计原则核心思想" class="headerlink" title="设计原则核心思想"></a>设计原则核心思想</h4><ol><li><p>找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。 </p></li><li><p>针对 <strong>接口编程</strong>，而不是针对实现编程。</p></li><li><p>为了交互对象之间的 <strong>松耦合设计而努力</strong></p></li></ol><h2 id="UML-基本介绍"><a href="#UML-基本介绍" class="headerlink" title="UML 基本介绍"></a>UML 基本介绍</h2><ul><li><p>UML——Unified modeling language UML (统一建模语言)，是一种用于软件系统分析和设计的语言工具，它用 于帮助软件开发人员进行思考和记录思路的结果</p></li><li><p>UML 本身是一套符号的规定，就像数学符号和化学符号一样，这些符号用于描述软件模型中的各个元素和他 们之间的关系，比如类、接口、实现、泛化、依赖、组合、聚合等，如右图:</p></li></ul><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201202111756.png" alt="test" style="zoom:50%;" /><h3 id="类图—依赖关系-Dependence"><a href="#类图—依赖关系-Dependence" class="headerlink" title="类图—依赖关系(Dependence)"></a>类图—依赖关系(Dependence)</h3><blockquote><p>只要是在类中用到了对方，那么他们之间就存在依赖关系。如果没有对方，连编绎都通过不了。</p></blockquote><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201202112951.png" alt="依赖"></p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201202113519.png" alt="依赖关系" style="zoom:50%;" /><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PersonServiceBean</span> </span>&#123;<span class="hljs-keyword">private</span> PersonDao personDao;<span class="hljs-comment">//类 public void save(Person person)&#123;&#125;</span><span class="hljs-function"><span class="hljs-keyword">public</span> IDCard <span class="hljs-title">getIDCard</span><span class="hljs-params">(Integer personid)</span></span>&#123;&#125; <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">modify</span><span class="hljs-params">()</span></span>&#123;Department department = <span class="hljs-keyword">new</span> Department(); &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PersonDao</span></span>&#123;&#125; <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IDCard</span></span>&#123;&#125; <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;&#125; <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Department</span></span>&#123;&#125;</code></pre><pre><code class="hljs plain">1) 类中用到了对方2) 如果是类的成员属性 3) 如果是方法的返回类型 4) 是方法接收的参数类型 5) 方法中使用到</code></pre><h3 id="类图—泛化关系-generalization"><a href="#类图—泛化关系-generalization" class="headerlink" title="类图—泛化关系(generalization)"></a>类图—泛化关系(generalization)</h3><blockquote><p>泛化关系实际上就是继承关系，他是依赖关系的特例</p></blockquote><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201202113350.png" alt="依赖关系" style="zoom:50%;" /><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201202113543.png" alt="泛化关系" style="zoom:50%;" /><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DaoSupport</span></span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">save</span><span class="hljs-params">(Object entity)</span></span>&#123; &#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delete</span><span class="hljs-params">(Object id)</span></span>&#123;&#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PersonServiceBean</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Daosupport</span></span>&#123; &#125;</code></pre><pre><code class="hljs dns"><span class="hljs-number">1</span>) 泛化关系实际上就是继承关系<span class="hljs-number">2</span>) 如果<span class="hljs-keyword">A</span>类继承了B类，我们就说<span class="hljs-keyword">A</span>和B存在泛化关系</code></pre><h3 id="类图—实现关系-Implementation"><a href="#类图—实现关系-Implementation" class="headerlink" title="类图—实现关系(Implementation)"></a>类图—实现关系(Implementation)</h3><p>实现关系实际上就是 <strong>A</strong> 类实现 <strong>B</strong> 接口，他是 <strong>依赖关系的特例</strong></p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201202113728.png" alt="实现关系" style="zoom:50%;" /><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201202113745.png" alt="实现关系" style="zoom:50%;" /><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">PersonService</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delete</span><span class="hljs-params">(Interger id)</span></span>;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PersonServiceBean</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">PersonService</span> </span>&#123; <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delete</span><span class="hljs-params">(Interger id)</span></span>&#123;&#125;&#125;</code></pre><h3 id="类图—关联关系-Association"><a href="#类图—关联关系-Association" class="headerlink" title="类图—关联关系(Association)"></a>类图—关联关系(Association)</h3><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201202113841.png" alt="关联关系" style="zoom:67%;" /><h3 id="类图—聚合关系-Aggregation"><a href="#类图—聚合关系-Aggregation" class="headerlink" title="类图—聚合关系(Aggregation)"></a>类图—聚合关系(Aggregation)</h3><h4 id="基本介绍-7"><a href="#基本介绍-7" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>聚合关系(Aggregation)表示的是整体和部分的关系，整体与部分可以分开。聚合关系是关联关系的特例，所以他具有 <strong>关联的导航性与多重性</strong>。</p><p>如:一台电脑由键盘(keyboard)、显示器(monitor)，鼠标等组成;组成电脑的各个配件是可以从电脑上分离出来 的，使用带空心菱形的实线来表示:</p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201202114201.png" alt="聚合" style="zoom:50%;" /><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201202114230.png" alt="聚合" style="zoom:50%;" /><h3 id="类图—组合关系-Composition"><a href="#类图—组合关系-Composition" class="headerlink" title="类图—组合关系(Composition)"></a>类图—组合关系(Composition)</h3><h4 id="基本介绍-8"><a href="#基本介绍-8" class="headerlink" title="基本介绍"></a>基本介绍</h4><blockquote><p>组合关系:也是整体与部分的关系，但是整体与部分 <strong><em>不可以分开</em></strong>。</p></blockquote><p>再看一个案例:在程序中我们定义实体:Person 与 IDCard、Head, 那么 Head 和 Person 就是 组合，IDCard 和 Person 就是聚合。</p><p>但是如果在程序中 Person 实体中定义了对 IDCard 进行级联删除，即删除 Person 时连同 IDCard 一起删除，那 么 IDCard 和 Person 就是组合了.</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;    <span class="hljs-keyword">private</span> IDCard card;     <span class="hljs-keyword">private</span> Head head = <span class="hljs-keyword">new</span> Head(); <span class="hljs-comment">// 注意区别</span>&#125;</code></pre><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201202114443.png" alt="组合" style="zoom:50%;" /><p>如果把聚合案例代码改成:</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Computer</span> </span>&#123;<span class="hljs-keyword">private</span> Mouse mouse = <span class="hljs-keyword">new</span> Mouse(); <span class="hljs-comment">//鼠标可以和 computer 不能分离 </span><span class="hljs-keyword">private</span> Moniter moniter = <span class="hljs-keyword">new</span> Moniter();<span class="hljs-comment">//显示器可以和 Computer 不能分离</span>&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java并发编程 学习笔记</title>
    <link href="/2020/11/27/Java%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    <url>/2020/11/27/Java%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="1、进程与线程"><a href="#1、进程与线程" class="headerlink" title="1、进程与线程"></a>1、进程与线程</h2><h3 id="1-1、概念"><a href="#1-1、概念" class="headerlink" title="1.1、概念"></a>1.1、概念</h3><blockquote><p> 进程</p></blockquote><ul><li>程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至 CPU，数据加载至内存。在 指令运行过程中还需要用到磁盘、网络等设备。进程就是用来加载指令、管理内存、管理 IO 的 </li><li>当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。 </li><li>进程就可以视为程序的一个实例。大部分程序可以同时运行多个实例进程(例如记事本、画图、浏览器 等)，也有的程序只能启动一个实例进程(例如网易云音乐、360 安全卫士等)</li></ul><blockquote><p>线程</p></blockquote><ul><li>一个进程之内可以分为一到多个线程。 </li><li>一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给 CPU 执行</li><li>Java 中，线程作为最小调度单位，进程作为资源分配的最小单位。 在 windows 中进程是不活动的，只是作为线程的容器</li></ul><blockquote><p>二者对比</p></blockquote><ul><li><p>进程基本上相互独立的，而线程存在于进程内，是进程的一个子集</p></li><li><p>进程拥有共享的资源，如内存空间等，供其内部的线程共享</p></li><li><p>进程间通信较为复杂</p><ul><li>同一台计算机的进程通信称为 IPC(Inter-process communication) </li><li>不同计算机之间的进程通信，需要通过网络，并遵守共同的协议，例如 HTTP</li></ul></li><li><p>线程通信相对简单，因为它们共享进程内的内存，一个例子是多个线程可以访问同一个共享变量</p></li><li><p>线程更轻量，线程上下文切换成本一般上要比进程上下文切换低</p></li></ul><h3 id="1-2-并行与并发"><a href="#1-2-并行与并发" class="headerlink" title="1.2 并行与并发"></a>1.2 并行与并发</h3><blockquote><p>并发</p></blockquote><p>单核 cpu 下，线程实际还是 <strong><em>串行执行</em></strong> 的。操作系统中有一个组件叫做 <strong><em>任务调度器</em></strong>，将 cpu 的时间片(windows 下时间片最小约为 15 毫秒)分给不同的程序使用，只是由于 cpu 在线程间(时间片很短)的切换非常快，人类感 觉是 同时运行的 。总结为一句话就是: <strong><em>微观串行，宏观并行</em></strong> ，</p><p>一般会将这种 <strong><em>线程轮流使用 CPU</em></strong> 的做法称为 <strong><em>并发</em></strong>， concurrent</p><table><thead><tr><th align="center">CPU</th><th>时间片1</th><th>时间片2</th><th>时间片3</th><th>时间片4</th></tr></thead><tbody><tr><td align="center">core</td><td>线程1</td><td>线程2</td><td>线程3</td><td>线程4</td></tr></tbody></table><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201127140415.png" alt="执行" style="zoom:33%;" /><blockquote><p>并行</p></blockquote><p>多核 cpu下，每个 核(core) 都可以调度运行线程，这时候线程可以是并行的。</p><table><thead><tr><th align="center">CPU</th><th>时间片1</th><th>时间片2</th><th>时间片3</th><th>时间片4</th></tr></thead><tbody><tr><td align="center">Core1</td><td>线程1</td><td>线程1</td><td>线程3</td><td>线程3</td></tr><tr><td align="center">Core2</td><td>线程2</td><td>线程4</td><td>线程2</td><td>线程4</td></tr></tbody></table><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201127140834.png" alt="执行" style="zoom:33%;" /><p>引用 Rob Pike (golang 创始人)的一段描述: </p><ul><li><p><strong>并发(concurrent)是同一时间应对(dealing with)多件事情的能力</strong></p></li><li><p><strong>并行(parallel)是同一时间动手做(doing)多件事情的能力</strong></p></li></ul><blockquote><p>例子</p></blockquote><ul><li><p>家庭主妇做饭、打扫卫生、给孩子喂奶，她一个人轮流交替做这多件事，这时就是并发</p></li><li><p>家庭主妇雇了个保姆，她们一起这些事，这时既有并发，也有并行(这时会产生竞争，例如锅只有一口，一<br>  个人用锅时，另一个人就得等待)</p></li><li><p>雇了3个保姆，一个专做饭、一个专打扫卫生、一个专喂奶，互不干扰，这时是并行</p></li></ul><h3 id="1-3、应用"><a href="#1-3、应用" class="headerlink" title="1.3、应用"></a>1.3、应用</h3><blockquote><p>应用之异步调用(案例1)</p></blockquote><p>以调用方角度来讲，如果</p><ul><li>需要等待结果返回，才能继续运行就是同步</li><li>不需要等待结果返回，就能继续运行就是异步</li></ul><ol><li>设计<br>多线程可以让方法执行变为异步的(即不要巴巴干等着)比如说读取磁盘文件时，假设读取操作花费了 5 秒钟，如</li></ol><p>果没有线程调度机制，这 5 秒 cpu 什么都做不了，其它代码都得暂停…</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201127144136.png" alt="同步"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201127144618.png" alt="异步"></p><ol start="2"><li>结论</li></ol><ul><li>比如在项目中，视频文件需要转换格式等操作比较费时，这时开一个新线程处理视频转换，避免阻塞主线程 - </li><li>tomcat 的异步 servlet 也是类似的目的，让用户线程处理耗时较长的操作，避免阻塞 tomcat 的工作线程 </li><li>ui 程序中，开线程进行其他操作，避免阻塞 ui 线程</li></ul><blockquote><p>应用之提高效率(案例1)</p></blockquote><p>充分利用多核 cpu 的优势，提高运行效率。想象下面的场景，执行 3 个计算，最后将计算结果汇总。</p><pre><code class="hljs crmsh">计算 <span class="hljs-number">1</span> 花费 <span class="hljs-number">10</span> <span class="hljs-keyword">ms</span> <span class="hljs-title"></span><span class="hljs-title">计算 2</span> 花费 <span class="hljs-number">11</span> <span class="hljs-keyword">ms</span> <span class="hljs-title"></span><span class="hljs-title">计算 3</span> 花费 <span class="hljs-number">9</span> <span class="hljs-keyword">ms</span> <span class="hljs-title"></span><span class="hljs-title">汇总需要 1</span> ms</code></pre><ul><li>如果是串行执行，那么总共花费的时间是 10 + 11 + 9 + 1 = 31ms</li><li> 但如果是四核 cpu，各个核心分别使用线程 1 执行计算 1，线程 2 执行计算 2，线程 3 执行计算 3，那么 3 个 线程是并行的，花费时间只取决于最长的那个线程运行的时间，即 11ms 最后加上汇总时间只会花费 12ms</li></ul><p><strong><em>注意</em></strong>:<strong><em>需要在多核 cpu 才能提高效率，单核仍然时是轮流执行</em></strong></p><hr><h4 id="1-3、效率案例"><a href="#1-3、效率案例" class="headerlink" title="1.3、效率案例"></a>1.3、效率案例</h4><blockquote><p>// TODO JMH测试</p></blockquote><p>1)设计代码:</p><pre><code class="hljs java"><span class="hljs-meta">@Fork(1)</span><span class="hljs-meta">@BenchmarkMode(Mode.AverageTime)</span><span class="hljs-meta">@Warmup(iterations=3)</span><span class="hljs-meta">@Measurement(iterations=5)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBenchmark</span> </span>&#123;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] ARRAY = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">1000_000_00</span>];    <span class="hljs-keyword">static</span> &#123;        Arrays.fill(ARRAY, <span class="hljs-number">1</span>);    &#125;    <span class="hljs-meta">@Benchmark</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">c</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-keyword">int</span>[] array = ARRAY;        FutureTask&lt;Integer&gt; t1 = <span class="hljs-keyword">new</span> FutureTask&lt;&gt;(()-&gt;&#123;            <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">250_000_00</span>;i++) &#123;                sum += array[<span class="hljs-number">0</span>+i];            &#125;            <span class="hljs-keyword">return</span> sum;        &#125;);        FutureTask&lt;Integer&gt; t2 = <span class="hljs-keyword">new</span> FutureTask&lt;&gt;(()-&gt;&#123;            <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">250_000_00</span>;i++) &#123;                sum += array[<span class="hljs-number">250_000_00</span>+i];            &#125;            <span class="hljs-keyword">return</span> sum;        &#125;);        FutureTask&lt;Integer&gt; t3 = <span class="hljs-keyword">new</span> FutureTask&lt;&gt;(()-&gt;&#123;            <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">250_000_00</span>;i++) &#123;                sum += array[<span class="hljs-number">500_000_00</span>+i];            &#125;            <span class="hljs-keyword">return</span> sum;        &#125;);        FutureTask&lt;Integer&gt; t4 = <span class="hljs-keyword">new</span> FutureTask&lt;&gt;(()-&gt;&#123;            <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">250_000_00</span>;i++) &#123;                sum += array[<span class="hljs-number">750_000_00</span>+i];            &#125;            <span class="hljs-keyword">return</span> sum;        &#125;);        <span class="hljs-keyword">new</span> Thread(t1).start();        <span class="hljs-keyword">new</span> Thread(t2).start();        <span class="hljs-keyword">new</span> Thread(t3).start();        <span class="hljs-keyword">new</span> Thread(t4).start();        <span class="hljs-keyword">return</span> t1.get() + t2.get() + t3.get()+ t4.get();    &#125;    <span class="hljs-meta">@Benchmark</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">d</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-keyword">int</span>[] array = ARRAY;        FutureTask&lt;Integer&gt; t1 = <span class="hljs-keyword">new</span> FutureTask&lt;&gt;(()-&gt;&#123;            <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000_000_00</span>;i++) &#123;                sum += array[<span class="hljs-number">0</span>+i];            &#125;            <span class="hljs-keyword">return</span> sum;        &#125;);        <span class="hljs-keyword">new</span> Thread(t1).start();        <span class="hljs-keyword">return</span> t1.get();    &#125;&#125;</code></pre><p>测试结果:</p><blockquote><p>多核</p></blockquote><pre><code class="hljs apache"><span class="hljs-attribute">Benchmark</span> Mode Samples Score Score error Units <span class="hljs-attribute">o</span>.s.MyBenchmark.c avgt <span class="hljs-number">5</span> <span class="hljs-number">0</span>.<span class="hljs-number">020</span> <span class="hljs-number">0</span>.<span class="hljs-number">001</span> s/op <span class="hljs-attribute">o</span>.s.MyBenchmark.d avgt <span class="hljs-number">5</span> <span class="hljs-number">0</span>.<span class="hljs-number">043</span> <span class="hljs-number">0</span>.<span class="hljs-number">003</span> s/op</code></pre><blockquote><p>单核</p></blockquote><pre><code class="hljs apache"><span class="hljs-attribute">Benchmark</span> Mode Samples Score Score error Units <span class="hljs-attribute">o</span>.s.MyBenchmark.c avgt <span class="hljs-number">5</span> <span class="hljs-number">0</span>.<span class="hljs-number">061</span> <span class="hljs-number">0</span>.<span class="hljs-number">060</span> s/op <span class="hljs-attribute">o</span>.s.MyBenchmark.d avgt <span class="hljs-number">5</span> <span class="hljs-number">0</span>.<span class="hljs-number">064</span> <span class="hljs-number">0</span>.<span class="hljs-number">071</span> s/op</code></pre><p>2)结论:</p><ul><li><p>单核 cpu 下，多线程不能实际提高程序运行效率，只是为了能够在不同的任务之间切换，不同线程轮流使用 cpu ，不至于一个线程总占用 cpu，别的线程没法干活</p></li><li><p>多核 cpu 可以并行跑多个线程，但能否提高程序运行效率还是要分情况的</p><ul><li>有些任务，经过精心设计，将任务拆分，并行执行，当然可以提高程序的运行效率。但不是所有计算任<br> 务都能拆分(参考后文的 <strong><em>【阿姆达尔定律】</em></strong>)</li><li> 也不是所有任务都需要拆分，任务的目的如果不同，谈拆分和效率没啥意义</li></ul></li><li><p>IO 操作不占用 cpu，只是我们一般拷贝文件使用的是 <strong><em>【阻塞 IO】</em></strong>，这时相当于线程虽然不用 cpu，但需要一 直等待 IO 结束，没能充分利用线程。所以才有后面的 <strong><em>【非阻塞 IO】</em></strong>和 <strong><em>【异步 IO】</em></strong>优化</p></li></ul><h2 id="2、Java-线程"><a href="#2、Java-线程" class="headerlink" title="2、Java 线程"></a>2、Java 线程</h2><h3 id="2-1、创建和运行线程"><a href="#2-1、创建和运行线程" class="headerlink" title="2.1、创建和运行线程"></a>2.1、创建和运行线程</h3><h4 id="方法一-直接使用Thread"><a href="#方法一-直接使用Thread" class="headerlink" title="方法一, 直接使用Thread"></a>方法一, 直接使用Thread</h4><pre><code class="hljs java"><span class="hljs-comment">// 创建线程对象</span>Thread t = <span class="hljs-keyword">new</span> Thread()&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 要执行的任务</span>    &#125;&#125;;t.setName(<span class="hljs-string">&quot;t0&quot;</span>);<span class="hljs-comment">// 启动线程</span>t.start();</code></pre><p>例如:</p><pre><code class="hljs java"><span class="hljs-comment">// 构造方法的参数是给线程指定名字，推荐 </span>Thread t1 = <span class="hljs-keyword">new</span> Thread(<span class="hljs-string">&quot;t1&quot;</span>)&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        log.info(<span class="hljs-string">&quot;hello&quot;</span>);    &#125;&#125;;t1.start();</code></pre><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201127161656.png" alt="test" style="zoom:50%;" /><h4 id="方法二-使用Runnable配合thread"><a href="#方法二-使用Runnable配合thread" class="headerlink" title="方法二, 使用Runnable配合thread"></a>方法二, 使用Runnable配合thread</h4><p>把【线程】和【任务】(要执行的代码)分开</p><ul><li>Thread 代表线程</li><li>Runnable 可运行的任务(线程要执行的代码)</li></ul><pre><code class="hljs java">Runnable runnable = <span class="hljs-keyword">new</span> Runnable() &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 要执行的任务</span>        log.debug(<span class="hljs-string">&quot;running&quot;</span>);    &#125;&#125;;<span class="hljs-comment">// 创建线程对象</span>Thread t = <span class="hljs-keyword">new</span> Thread(runnable, <span class="hljs-string">&quot;t2&quot;</span>);<span class="hljs-comment">// 启动线程</span>t.start();</code></pre><pre><code class="hljs css">16<span class="hljs-selector-pseudo">:22</span><span class="hljs-selector-pseudo">:02</span> <span class="hljs-selector-attr">[t2]</span> <span class="hljs-selector-tag">c</span><span class="hljs-selector-class">.Test</span> <span class="hljs-selector-tag">-</span> <span class="hljs-selector-tag">running</span></code></pre><h4 id="lambda精简代码"><a href="#lambda精简代码" class="headerlink" title="lambda精简代码"></a>lambda精简代码</h4><blockquote><p>JDK中只有一个抽象方法的接口会加一个 @FunctionalInterface 注解，可被lambda表达式简化</p></blockquote><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201127162415.png" alt="注解" style="zoom:33%;" /><pre><code class="hljs java">Runnable r2 = () -&gt; &#123;log.debug(<span class="hljs-string">&quot;running&quot;</span>);&#125;;Thread t2 = <span class="hljs-keyword">new</span> Thread(r2, <span class="hljs-string">&quot;t2&quot;</span>);t2.start();Runnable r3 = () -&gt; log.debug(<span class="hljs-string">&quot;running&quot;</span>);Thread t3 = <span class="hljs-keyword">new</span> Thread(r3, <span class="hljs-string">&quot;t3&quot;</span>);t3.start();Thread t4 = <span class="hljs-keyword">new</span> Thread(()-&gt;log.debug(<span class="hljs-string">&quot;running&quot;</span>), <span class="hljs-string">&quot;t4&quot;</span>);        t4.start();</code></pre><h4 id="原理之-Thread-与-Runnable-的关系"><a href="#原理之-Thread-与-Runnable-的关系" class="headerlink" title="原理之 Thread 与 Runnable 的关系"></a>原理之 Thread 与 Runnable 的关系</h4><p>1.跟随Thread(Runnable target)源码</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Thread</span><span class="hljs-params">(Runnable target)</span> </span>&#123;    init(<span class="hljs-keyword">null</span>, target, <span class="hljs-string">&quot;Thread-&quot;</span> + nextThreadNum(), <span class="hljs-number">0</span>);&#125;</code></pre><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-comment">// 对于Runnable创建Thread, 最终target(Runnable)在run方法中被调到, 优先采用Runnable对象的run方法</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">if</span> (target != <span class="hljs-keyword">null</span>) &#123;        target.run();    &#125;&#125;<span class="hljs-comment">// 而对于未采用Runnable, 直接创建的Thread子类对象, 重写了Thread中的run()方法, 最终执行子类中的run()方法</span>Thread t = <span class="hljs-keyword">new</span> Thread()&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 要执行的任务</span>    &#125;&#125;;</code></pre><blockquote><p>小结</p></blockquote><ul><li><p>方法1 是把线程和任务合并在了一起，方法2 是把线程和任务分开了 </p></li><li><p>用 Runnable 更容易与线程池等高级 API 配合</p></li><li><p>用 Runnable 让任务类脱离了 Thread 继承体系，更灵活</p><p> java中组合由于继承!</p></li></ul><h4 id="方法三-FutureTask配合Thread"><a href="#方法三-FutureTask配合Thread" class="headerlink" title="方法三, FutureTask配合Thread"></a>方法三, FutureTask配合Thread</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">RunnableFuture</span>&lt;<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Runnable</span>, <span class="hljs-title">Future</span>&lt;<span class="hljs-title">V</span>&gt; </span><span class="hljs-class">  // 说明能返回运行结果</span></code></pre><blockquote><p> FutureTask 能够接收 Callable 类型的参数，用来处理有返回结果的情况</p></blockquote><pre><code class="hljs java">FutureTask&lt;Integer&gt; task1 = <span class="hljs-keyword">new</span> FutureTask(<span class="hljs-keyword">new</span> Callable() &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        log.debug(<span class="hljs-string">&quot;running&quot;</span>);        Thread.sleep(<span class="hljs-number">3000</span>);        <span class="hljs-keyword">return</span> <span class="hljs-number">200</span>;    &#125;&#125;);Thread t5 = <span class="hljs-keyword">new</span> Thread(task1, <span class="hljs-string">&quot;t_task1&quot;</span>);t5.start();log.debug(<span class="hljs-string">&quot;&#123;&#125;,&quot;</span>, task1.get());<span class="hljs-comment">// 等待task返回结果</span>FutureTask&lt;Integer&gt; task2 = <span class="hljs-keyword">new</span> FutureTask(()-&gt;log.debug(<span class="hljs-string">&quot;running&quot;</span>), <span class="hljs-number">200</span>);<span class="hljs-keyword">new</span> Thread(task2, <span class="hljs-string">&quot;t_task2&quot;</span>).start();log.debug(<span class="hljs-string">&quot;&#123;&#125;,&quot;</span>, task2.get());</code></pre><pre><code class="hljs css">17<span class="hljs-selector-pseudo">:19</span><span class="hljs-selector-pseudo">:44</span> <span class="hljs-selector-attr">[t_task1]</span> <span class="hljs-selector-tag">c</span><span class="hljs-selector-class">.Test</span> <span class="hljs-selector-tag">-</span> <span class="hljs-selector-tag">running</span>17<span class="hljs-selector-pseudo">:19</span><span class="hljs-selector-pseudo">:47</span> <span class="hljs-selector-attr">[main]</span> <span class="hljs-selector-tag">c</span><span class="hljs-selector-class">.Test</span> <span class="hljs-selector-tag">-</span> 200,17<span class="hljs-selector-pseudo">:19</span><span class="hljs-selector-pseudo">:47</span> <span class="hljs-selector-attr">[t_task2]</span> <span class="hljs-selector-tag">c</span><span class="hljs-selector-class">.Test</span> <span class="hljs-selector-tag">-</span> <span class="hljs-selector-tag">running</span>17<span class="hljs-selector-pseudo">:19</span><span class="hljs-selector-pseudo">:47</span> <span class="hljs-selector-attr">[main]</span> <span class="hljs-selector-tag">c</span><span class="hljs-selector-class">.Test</span> <span class="hljs-selector-tag">-</span> 200,</code></pre><h3 id="2-2-观察多个线程同时运行"><a href="#2-2-观察多个线程同时运行" class="headerlink" title="2.2 观察多个线程同时运行"></a>2.2 观察多个线程同时运行</h3><pre><code class="hljs java"><span class="hljs-keyword">new</span> Thread(() -&gt; &#123;    <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;        log.debug(<span class="hljs-string">&quot;running...&quot;</span>);    &#125;&#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();<span class="hljs-keyword">new</span> Thread(()-&gt;&#123;    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>)&#123;        log.debug(<span class="hljs-string">&quot;running...&quot;</span>);    &#125;&#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();</code></pre><p>主要是理解:</p><ul><li>交替执行</li><li>谁先谁后，不由我们控制</li></ul><p>由底层任务调度器控制</p><h3 id="2-3-查看进程线程的方法"><a href="#2-3-查看进程线程的方法" class="headerlink" title="2.3 查看进程线程的方法"></a>2.3 查看进程线程的方法</h3><blockquote><p>windows</p></blockquote><ul><li><p>任务管理器可以查看进程和线程数，也可以用来杀死进程</p></li><li><p>tasklist 查看进程</p></li><li><p>taskkill 杀死进程</p></li></ul><blockquote><p>linux</p></blockquote><ul><li><p>ps -fe 查看所有进程</p></li><li><p>ps -fT -p <PID> 查看某个进程(PID)的所有线程 kill 杀死进程</p></li><li><p>top 按大写 H 切换是否显示线程</p></li><li><p>top -H -p <PID> 查看某个进程(PID)的所有线程</p></li></ul><blockquote><p>Java</p></blockquote><ul><li> jps 命令查看所有 Java 进程</li><li> jstack <PID> 查看某个 Java 进程(PID)的所有线程状态</li><li> jconsole 来查看某个 Java 进程中线程的运行情况(图形界面)</li></ul><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201127172857.png" alt="test" style="zoom:50%;" /><p>jconsole 远程监控配置 </p><ul><li>需要以如下方式运行你的 java 类</li></ul><pre><code class="hljs java"><span class="hljs-comment">//输入linux 根据选择true/false</span>java -Djava.rmi.server.hostname=`ip地址` -Dcom.sun.management.jmxremote - Dcom.sun.management.jmxremote.port=`连接端口` -Dcom.sun.management.jmxremote.ssl=是否安全连接 - Dcom.sun.management.jmxremote.authenticate=是否认证 java类</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201127174348.png" alt="连接"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201127174536.png" alt="线程"></p><h3 id="2-4-线程运行原理"><a href="#2-4-线程运行原理" class="headerlink" title="2.4 线程运行原理"></a>2.4 线程运行原理</h3><h4 id="栈与栈帧"><a href="#栈与栈帧" class="headerlink" title="栈与栈帧"></a>栈与栈帧</h4><blockquote><p>Java Virtual Machine Stacks (Java 虚拟机栈)</p><p>我们都知道 JVM 中由堆、栈、方法区所组成，其中栈内存是给谁用的呢?其实就是线程，每个线程启动后，虚拟 机就会为其分配一块栈内存。</p></blockquote><ul><li>每个栈由多个栈帧(Frame)组成，对应着每次方法调用时所占用的内存 </li><li>每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法</li></ul><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestFrames</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Thread t1 = <span class="hljs-keyword">new</span> Thread()&#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                method1(<span class="hljs-number">20</span>);            &#125;        &#125;;        t1.setName(<span class="hljs-string">&quot;t1&quot;</span>);        t1.start();        method1(<span class="hljs-number">10</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;        <span class="hljs-keyword">int</span> y = x + <span class="hljs-number">1</span>;        Object m = method2();        System.out.println(m);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title">method2</span><span class="hljs-params">()</span> </span>&#123;        Object n = <span class="hljs-keyword">new</span> Object();        <span class="hljs-keyword">return</span> n;    &#125;&#125;</code></pre><p>debug:</p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201127175404.png" alt="为主方法分配的栈帧" style="zoom:50%;" /><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201127175543.png" alt="开辟method1栈帧" style="zoom:50%;" /><blockquote><p>里面有参数信息, 局部变量信息</p></blockquote><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201127175648.png" alt="参数存放于局部变量表中"></p><blockquote><p>这些参数都存在于 <strong><em>局部变量表</em></strong>中</p></blockquote><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201127175800.png" alt="栈结构很明显"></p><h4 id="栈帧图解"><a href="#栈帧图解" class="headerlink" title="栈帧图解"></a>栈帧图解</h4><blockquote><p>当我们运行TestFrames时发生了什么?</p></blockquote><pre><code class="hljs less">首先执行 类加载 把<span class="hljs-selector-tag">TestFrames</span>字节码加载到<span class="hljs-selector-tag">Java</span>虚拟机中(放入方法区)类加载完成后<span class="hljs-selector-tag">Java</span>虚拟机启动一个名称为<span class="hljs-selector-tag">main</span>的主线程, 并分配一块栈内存, 线程再交给任务调度器执行线程栈中有一个程序计数器组件, 记录了当前该执行哪行代码栈帧中的局部变量表(栈帧创建时就会分配, 非边运行边分配, 但赋值是边运行边执行的)包含当前方法局部变量和方法参数返回地址对应退出地址,</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201127181557.png" alt="执行method2之前"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201127181744.png" alt="继续执行"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201127181939.png" alt="执行完method2"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201127182209.png" alt="执行完method2后, 栈帧消失"></p><p>之后同样出栈并根据返回地址返回, 继续执行下面的代码</p><h4 id="多线程栈与栈帧原理"><a href="#多线程栈与栈帧原理" class="headerlink" title="多线程栈与栈帧原理"></a>多线程栈与栈帧原理</h4><blockquote><p>把Debug模式改成Thread</p></blockquote><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201127182651.png" alt="debug" style="zoom:50%;" /><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201127182814.png" alt="主线程栈内存"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201127182912.png" alt="t1线程栈内存"></p><h4 id="线程的上下文切换-Thread-Context-Switch"><a href="#线程的上下文切换-Thread-Context-Switch" class="headerlink" title="线程的上下文切换(Thread Context Switch)"></a>线程的上下文切换(Thread Context Switch)</h4><blockquote><p>当任务调度器把时间片分配给每个线程运行的时候, 每个线程的时间片用完后把cpu使用权交给其他线程, 此时就会发生上下文切换</p></blockquote><p>因为以下一些原因导致 cpu 不再执行当前的线程，转而执行另一个线程的代码</p><ul><li>线程的 cpu 时间片用完</li><li> 垃圾回收  (<strong>会暂停当前所有的工作线程, 让垃圾回收线程回收垃圾</strong>)</li><li> 有更高优先级的线程需要运行</li><li> 线程自己调用了 sleep、yield、wait、join、park、synchronized、lock 等方法</li></ul><p>当 Context Switch 发生时，需要由操作系统保存当前线程的状态（ <strong>比如执行到第n行代码时间片结束，要记录n，否则下次再次轮到该线程，cpu不知道该从哪执行</strong>），并恢复另一个线程的状态，Java 中对应的概念 就是 <strong><em>程序计数器(Program Counter Register)</em></strong>，它的作用是记住 <strong><em>下一条 jvm 指令的执行地址</em></strong>，是线程 <strong><em>私有</em></strong>的</p><ul><li><p>状态包括 <strong><em>程序计数器</em></strong>、 <strong><em>虚拟机栈中每个栈帧的信息</em></strong>，如 <strong><em>局部变量</em></strong>、 <strong><em>操作数栈</em></strong>、 <strong><em>返回地址</em></strong>等 </p></li><li><p>Context Switch 频繁发生会影响性能</p><blockquote><p>假如运行到return n;的时候时间片结束</p></blockquote><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201127184513.png" alt="图解"></p><blockquote><p>加入t1执行完后</p></blockquote><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201127184706.png" alt="t1执行完后, main重新开始执行"></p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构与算法基础回顾笔记</title>
    <link href="/2020/11/25/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/"/>
    <url>/2020/11/25/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<blockquote><p>跟左神重学！</p></blockquote><h1 id="认识复杂度、对数器、二分法与异或运算"><a href="#认识复杂度、对数器、二分法与异或运算" class="headerlink" title="认识复杂度、对数器、二分法与异或运算"></a>认识复杂度、对数器、二分法与异或运算</h1><h2 id="认识复杂度"><a href="#认识复杂度" class="headerlink" title="认识复杂度"></a>认识复杂度</h2><blockquote><p>评估算法优劣的核心指标是什么？</p></blockquote><ul><li><p>时间复杂度（流程决定）</p></li><li><p>额外空间复杂度（流程决定）</p></li><li><p>常数项时间（实现细节决定）</p></li></ul><h3 id="1、什么是时间复杂度？时间复杂度怎么估算？"><a href="#1、什么是时间复杂度？时间复杂度怎么估算？" class="headerlink" title="1、什么是时间复杂度？时间复杂度怎么估算？"></a>1、什么是时间复杂度？时间复杂度怎么估算？</h3><ul><li>常数时间的操作</li><li>确定算法流程的总操作数量与样本数量之间的表达式关系</li><li>只看表达式最高阶项的部分</li></ul><h3 id="2、何为常数时间的操作？"><a href="#2、何为常数时间的操作？" class="headerlink" title="2、何为常数时间的操作？"></a>2、何为常数时间的操作？</h3><blockquote><p>如果一个操作的执行时间不以具体样本量为转移，每次执行时间都是固定时间。称这样的操作为常数时间的操作。如取Array[0]与取Array[1000000]花费时间一致， 不以数据量转移。</p></blockquote><p><strong>常见的常数时间的操作</strong></p><ul><li>常见的算术运算（+、-、*、/、% 等）</li><li>常见的位运算（&gt;&gt;(带符号右移)、&gt;&gt;&gt;(不带符号右移)、&lt;&lt;、|、&amp;、^等）</li><li>赋值、比较、自增、自减操作等</li><li>数组寻址操作</li></ul><p>总之，执行时间固定的操作都是常数时间的操作。<br>反之，执行时间不固定的操作，都不是常数时间的操作。</p><p><strong>如何确定算法流程的总操作数量与样本数量之间的表达式关系？</strong></p><p>​    1，想象该算法流程所处理的数据状况，要按照 <strong><em>最差</em></strong>情况来。</p><p>​    2，把整个流程彻底拆分为一个个 <strong><em>基本动作</em></strong>，保证每个动作都是 <strong><em>常数时间</em></strong>的操作。</p><p>​    3，如果数据量为N，看看基本动作的数量和N是什么关系。</p><h3 id="3、如何确定算法流程的时间复杂度？"><a href="#3、如何确定算法流程的时间复杂度？" class="headerlink" title="3、如何确定算法流程的时间复杂度？"></a>3、如何确定算法流程的时间复杂度？</h3><blockquote><p>当完成了表达式的建立，只要把最高阶项留下即可。低阶项都去掉，高阶项的系数也去掉。<br>记为：<strong>O(忽略掉系数的高阶项)</strong></p></blockquote><p>通过三个具体的例子，来实践一把时间复杂度的估算</p><h4 id="a、选择排序"><a href="#a、选择排序" class="headerlink" title="a、选择排序"></a>a、选择排序</h4><p>过程：<br>arr[0～N-1]范围上，找到最小值所在的位置，然后把最小值交换到0位置。<br>arr[1～N-1]范围上，找到最小值所在的位置，然后把最小值交换到1位置。<br>arr[2～N-1]范围上，找到最小值所在的位置，然后把最小值交换到2位置。<br>…<br>arr[N-1～N-1]范围上，找到最小值位置，然后把最小值交换到N-1位置。</p><p>估算：<br>很明显，如果arr长度为N，每一步常数操作的数量，如等差数列一般<br>所以，总的常数操作数量 = a*(N^2) + b*N + c (a、b、c都是常数)</p><p>所以选择排序的时间复杂度为 **O(N^2)**。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">selectionSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;   <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length &lt; <span class="hljs-number">2</span>) &#123;      <span class="hljs-keyword">return</span>;   &#125;   <span class="hljs-comment">// 0～n-1</span>   <span class="hljs-comment">// 1～n-1</span>   <span class="hljs-comment">// 2～n-1</span>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length - <span class="hljs-number">1</span>; i++) &#123; <span class="hljs-comment">// i ~ N-1</span>      <span class="hljs-comment">// 最小值在哪个位置上  i～n-1</span>      <span class="hljs-keyword">int</span> minIndex = i;      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; arr.length; j++) &#123; <span class="hljs-comment">// i ~ N-1 上找最小值的下标 </span>         minIndex = arr[j] &lt; arr[minIndex] ? j : minIndex;      &#125;      swap(arr, i, minIndex);   &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;   <span class="hljs-keyword">int</span> tmp = arr[i];   arr[i] = arr[j];   arr[j] = tmp;&#125;</code></pre><h4 id="b、冒泡排序"><a href="#b、冒泡排序" class="headerlink" title="b、冒泡排序"></a>b、冒泡排序</h4><p>过程：<br>在arr[0～N-1]范围上：<br>arr[0]和arr[1]，谁大谁来到1位置；arr[1]和arr[2]，谁大谁来到2位置…arr[N-2]和arr[N-1]，谁大谁来到N-1位置</p><p>在arr[0～N-2]范围上，重复上面的过程，但最后一步是arr[N-3]和arr[N-2]，谁大谁来到N-2位置<br>在arr[0～N-3]范围上，重复上面的过程，但最后一步是arr[N-4]和arr[N-3]，谁大谁来到N-3位置<br>…<br>最后在arr[0～1]范围上，重复上面的过程，但最后一步是arr[0]和arr[1]，谁大谁来到1位置</p><p>估算：<br>很明显，如果arr长度为N，每一步常数操作的数量，依然如等差数列一般<br>所以，总的常数操作数量 = a*(N^2) + b*N + c (a、b、c都是常数)</p><p>所以冒泡排序的时间复杂度为O(N^2)。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bubbleSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span></span>&#123;        <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length &lt; <span class="hljs-number">2</span>)&#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = arr.length - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--)&#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++)&#123;                <span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>])&#123;                    swap(arr, j, j+<span class="hljs-number">1</span>);                &#125;            &#125;        &#125;    &#125;    <span class="hljs-comment">// 交换arr的i和j位置上的值</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;        arr[i] = arr[i] ^ arr[j];        arr[j] = arr[i] ^ arr[j];        arr[i] = arr[i] ^ arr[j];    &#125;</code></pre><h4 id="c、插入排序"><a href="#c、插入排序" class="headerlink" title="c、插入排序"></a>c、插入排序</h4><p>过程：<br>想让arr[0<del>0]上有序，这个范围只有一个数，当然是有序的。<br>想让arr[0</del>1]上有序，所以从arr[1]开始往前看，如果arr[1]&lt;arr[0]，就交换。否则什么也不做。<br>想让arr[0<del>i]上有序，所以从arr[i]开始往前看，arr[i]这个数不停向左移动，一直移动到左边的数字不再比自己大，停止移动。<br>最后一步，想让arr[0</del>N-1]上有序， arr[N-1]这个数不停向左移动，一直移动到左边的数字不再比自己大，停止移动。</p><p>估算时发现这个算法流程的复杂程度，会因为数据状况的不同而不同。</p><pre><code class="hljs mathematica">如果某个算法流程的复杂程度会根据数据状况的不同而不同，那么你必须要按照最差情况来估计。很明显，在最差情况下，如果<span class="hljs-variable">arr</span>长度为<span class="hljs-built_in">N</span>，插入排序的每一步常数操作的数量，还是如等差数列一般所以，总的常数操作数量 <span class="hljs-operator">=</span> <span class="hljs-variable">a</span><span class="hljs-operator">*</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-operator">^</span><span class="hljs-number">2</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">+</span> <span class="hljs-variable">b</span><span class="hljs-operator">*</span><span class="hljs-built_in">N</span> <span class="hljs-operator">+</span> <span class="hljs-variable">c</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">a</span>、<span class="hljs-variable">b</span>、<span class="hljs-variable">c</span>都是常数<span class="hljs-punctuation">)</span>所以插入排序排序的时间复杂度为<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-operator">^</span><span class="hljs-number">2</span><span class="hljs-punctuation">)</span>。</code></pre><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertionSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;   <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length &lt; <span class="hljs-number">2</span>) &#123;      <span class="hljs-keyword">return</span>;   &#125;   <span class="hljs-comment">// 0~0 有序的</span>   <span class="hljs-comment">// 0~i 想有序</span>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; arr.length; i++) &#123; <span class="hljs-comment">// 0 ~ i 做到有序</span>            <span class="hljs-comment">// arr[i]往前看，一直交换到合适的位置停止</span>      <span class="hljs-comment">// ...(&lt;=)  ?       &lt;- i</span>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[j] &gt; arr[j + <span class="hljs-number">1</span>]; j--) &#123;         swap(arr, j, j + <span class="hljs-number">1</span>);      &#125;   &#125;&#125;<span class="hljs-comment">// i和j是一个位置的话，会出错</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;   arr[i] = arr[i] ^ arr[j];   arr[j] = arr[i] ^ arr[j];   arr[i] = arr[i] ^ arr[j];&#125;</code></pre><blockquote><p>注意</p></blockquote><ul><li><p>算法的过程，和具体的语言是无关的。</p></li><li><p>想分析一个算法流程的时间复杂度的前提，是对该流程非常熟悉</p></li><li><p>一定要确保在拆分算法流程时，拆分出来的所有行为都是常数时间的操作。这意味着你写算法时，对自己的用过的每一个系统api，都非常的熟悉。否则会影响你对时间复杂度的估算。</p><hr><pre><code class="hljs mathematica">排名从好到差：<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-number">1</span><span class="hljs-punctuation">)</span>   <span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-variable">logN</span><span class="hljs-punctuation">)</span>   <span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-punctuation">)</span>   <span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-operator">*</span><span class="hljs-variable">logN</span><span class="hljs-punctuation">)</span>   <span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-operator">^</span><span class="hljs-number">2</span><span class="hljs-punctuation">)</span>   <span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-operator">^</span><span class="hljs-number">3</span><span class="hljs-punctuation">)</span>   …   <span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-operator">^</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-number">2</span><span class="hljs-operator">^</span><span class="hljs-built_in">N</span><span class="hljs-punctuation">)</span>   <span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-number">3</span><span class="hljs-operator">^</span><span class="hljs-built_in">N</span><span class="hljs-punctuation">)</span>   …   <span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">K</span><span class="hljs-operator">^</span><span class="hljs-built_in">N</span><span class="hljs-punctuation">)</span><span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-operator">!</span><span class="hljs-punctuation">)</span></code></pre></li></ul><h3 id="4、时间复杂度的意义"><a href="#4、时间复杂度的意义" class="headerlink" title="4、时间复杂度的意义"></a>4、时间复杂度的意义</h3><p>抹掉了好多东西，只剩下了一个 <strong><em>最高阶项</em></strong>啊…</p><p>那这个东西有什么意义呢？</p><p>时间复杂度的意义在于：</p><p>当我们要处理的样本量很大很大时，我们会发现*<strong>低阶项是什么不是最重要的 **<em>；每一项的系数是什么，不是最重要的。</em></strong>真正重要的就是最高阶项是什么***。</p><p>这就是时间复杂度的意义，它是衡量算法流程的复杂程度的一种指标，该指标只与 <strong><em>数据量</em></strong>有关，与 <strong><em>过程之外的优化</em></strong>无关。</p><h3 id="5、额外空间复杂度"><a href="#5、额外空间复杂度" class="headerlink" title="5、额外空间复杂度"></a>5、额外空间复杂度</h3><p>你要实现一个算法流程，在实现算法流程的过程中，你需要开辟一些空间来支持你的算法流程。</p><p>作为 <strong><em>输入参数</em></strong>的空间，不算额外空间。<br>作为 <strong><em>输出结果</em></strong>的空间，也不算额外空间。</p><p>因为这些都是必要的、和现实目标有关的。所以都不算。<br>但除此之外，你的流程如果还需要开辟空间才能让你的流程继续下去。这部分空间就是额外空间。<br>如果你的流程只需要开辟有限几个变量，额外空间复杂度就是O(1)。</p><h3 id="6、算法流程的常数项"><a href="#6、算法流程的常数项" class="headerlink" title="6、算法流程的常数项"></a>6、算法流程的常数项</h3><p>我们会发现，时间复杂度这个指标，是忽略低阶项和所有常数系数的。<br>难道同样时间复杂度的流程，在实际运行时候就一样的好吗？<br>当然不是。</p><p>时间复杂度只是一个很重要的指标而已。如果两个时间复杂度一样的算法，你还要去在时间上拼优劣，就进入到拼常数时间的阶段，简称 <strong><em>拼常数项</em></strong>。</p><blockquote><p>算法流程的常数项的比拼方式</p></blockquote><p> <strong><em>放弃理论分析，生成随机数据直接测</em></strong>。</p><p>为什么不去理论分析？<br>不是不能纯分析，而是没必要。因为不同常数时间的操作，虽然都是固定时间，但还是有快慢之分的。</p><p>比如，位运算的常数时间原小于算术运算的常数时间，这两个运算的常数时间又远小于数组寻址的时间。<br>所以如果纯理论分析，往往会需要非常多的分析过程。都已经到了具体细节的程度，莫不如交给实验数据好了。</p><h3 id="7、面试、比赛、刷题中，一个问题的最优解是什么意思？"><a href="#7、面试、比赛、刷题中，一个问题的最优解是什么意思？" class="headerlink" title="7、面试、比赛、刷题中，一个问题的最优解是什么意思？"></a>7、面试、比赛、刷题中，一个问题的最优解是什么意思？</h3><p>一般情况下，认为解决一个问题的算法流程，在 <strong><em>时间复杂度</em></strong>的指标上，一定要尽可能的 <strong><em>低</em></strong>，先满足了时间复杂度最低这个指标之后，使用最少的 <strong><em>空间</em></strong>的算法流程，叫这个问题的最优解。</p><p>一般说起最优解都是 <strong><em>忽略掉常数项</em></strong>这个因素的，因为这个因素只决定了实现层次的优化和考虑，而和怎么解决整个问题的思想无关。</p><h2 id="对数器"><a href="#对数器" class="headerlink" title="对数器"></a>对数器</h2><h3 id="1、什么是对数器"><a href="#1、什么是对数器" class="headerlink" title="1、什么是对数器"></a>1、什么是对数器</h3><blockquote><p>认识对数器</p></blockquote><p>1，你想要测的方法a<br>2，实现复杂度不好但是容易实现的方法b<br>3，实现一个随机样本产生器<br>4，把方法a和方法b跑相同的随机样本，看看得到的结果是否一样<br>5，如果有一个随机样本使得比对结果不一致，打印样本进行人工干预，改对方法a和方法b<br>6，当样本数量很多时比对测试依然正确，可以确定方法a已经正确。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] generateRandomArray(<span class="hljs-keyword">int</span> maxSize, <span class="hljs-keyword">int</span> maxValue) &#123;   <span class="hljs-comment">// Math.random() -&gt;  [0,1) 所有的小数，等概率返回一个</span>   <span class="hljs-comment">// Math.random() * N -&gt; [0,N) 所有小数，等概率返回一个</span>   <span class="hljs-comment">// (int)(Math.random() * N) -&gt; [0,N-1] 所有的整数，等概率返回一个</span>   <span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[(<span class="hljs-keyword">int</span>) ((maxSize + <span class="hljs-number">1</span>) * Math.random())]; <span class="hljs-comment">// 长度随机 </span>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;      <span class="hljs-comment">// [-?,+?]</span>      arr[i] = (<span class="hljs-keyword">int</span>) ((maxValue + <span class="hljs-number">1</span>) * Math.random())             - (<span class="hljs-keyword">int</span>) (maxValue * Math.random());   &#125;   <span class="hljs-keyword">return</span> arr;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">comparator</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;Arrays.sort(arr);&#125;<span class="hljs-comment">// for copy</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] copyArray(<span class="hljs-keyword">int</span>[] arr) &#123;<span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;<span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[arr.length];<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;res[i] = arr[i];&#125;<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-comment">// for compare</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEqual</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr1, <span class="hljs-keyword">int</span>[] arr2)</span> </span>&#123;<span class="hljs-keyword">if</span> ((arr1 == <span class="hljs-keyword">null</span> &amp;&amp; arr2 != <span class="hljs-keyword">null</span>) || (arr1 != <span class="hljs-keyword">null</span> &amp;&amp; arr2 == <span class="hljs-keyword">null</span>)) &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;&#125;<span class="hljs-keyword">if</span> (arr1 == <span class="hljs-keyword">null</span> &amp;&amp; arr2 == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;&#125;<span class="hljs-keyword">if</span> (arr1.length != arr2.length) &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr1.length; i++) &#123;<span class="hljs-keyword">if</span> (arr1[i] != arr2[i]) &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-comment">// for test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;   <span class="hljs-keyword">int</span> testTime = <span class="hljs-number">500000</span>;   <span class="hljs-keyword">int</span> maxSize = <span class="hljs-number">100</span>; <span class="hljs-comment">// 随机数组的长度0～100</span>   <span class="hljs-keyword">int</span> maxValue = <span class="hljs-number">100</span>;<span class="hljs-comment">// 值：-100～100</span>   <span class="hljs-keyword">boolean</span> succeed = <span class="hljs-keyword">true</span>;   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; testTime; i++) &#123;      <span class="hljs-keyword">int</span>[] arr1 = generateRandomArray(maxSize, maxValue);      <span class="hljs-keyword">int</span>[] arr2 = copyArray(arr1);      insertionSort(arr1);      comparator(arr2);      <span class="hljs-keyword">if</span> (!isEqual(arr1, arr2)) &#123;         <span class="hljs-comment">// 打印arr1</span>         <span class="hljs-comment">// 打印arr2</span>         succeed = <span class="hljs-keyword">false</span>;         <span class="hljs-keyword">break</span>;      &#125;   &#125;   System.out.println(succeed ? <span class="hljs-string">&quot;Nice!&quot;</span> : <span class="hljs-string">&quot;Fucking fucked!&quot;</span>);   <span class="hljs-keyword">int</span>[] arr = generateRandomArray(maxSize, maxValue);   printArray(arr);   insertionSort(arr);   printArray(arr);&#125;</code></pre><h2 id="认识二分法"><a href="#认识二分法" class="headerlink" title="认识二分法"></a>认识二分法</h2><blockquote><p> 经常见到的类型是在一个有序数组上，开展二分搜索，但有序真的是所有问题求解时使用二分的必要条件吗？<br>不！<br>只要能正确构建左右两侧的淘汰逻辑，你就可以二分。</p></blockquote><h3 id="1、在一个有序数组中，找某个数是否存在"><a href="#1、在一个有序数组中，找某个数是否存在" class="headerlink" title="1、在一个有序数组中，找某个数是否存在"></a>1、在一个有序数组中，找某个数是否存在</h3><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">exist</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] sortedArr, <span class="hljs-keyword">int</span> num)</span> </span>&#123;   <span class="hljs-keyword">if</span> (sortedArr == <span class="hljs-keyword">null</span> || sortedArr.length == <span class="hljs-number">0</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;   &#125;   <span class="hljs-keyword">int</span> L = <span class="hljs-number">0</span>;   <span class="hljs-keyword">int</span> R = sortedArr.length - <span class="hljs-number">1</span>;   <span class="hljs-keyword">int</span> mid = <span class="hljs-number">0</span>;   <span class="hljs-comment">// L..R</span>   <span class="hljs-keyword">while</span> (L &lt; R) &#123;      <span class="hljs-comment">// 防L R 因数值过大 相加后溢出</span>      mid = L + ((R - L) &gt;&gt; <span class="hljs-number">1</span>); <span class="hljs-comment">// mid = (L + R) / 2</span>      <span class="hljs-keyword">if</span> (sortedArr[mid] == num) &#123;         <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sortedArr[mid] &gt; num) &#123;         R = mid - <span class="hljs-number">1</span>;      &#125; <span class="hljs-keyword">else</span> &#123;         L = mid + <span class="hljs-number">1</span>;      &#125;   &#125;   <span class="hljs-keyword">return</span> sortedArr[L] == num;&#125;</code></pre><h3 id="2、在一个有序数组中，找-gt-某个数最左侧的位置"><a href="#2、在一个有序数组中，找-gt-某个数最左侧的位置" class="headerlink" title="2、在一个有序数组中，找&gt;=某个数最左侧的位置"></a>2、在一个有序数组中，找&gt;=某个数最左侧的位置</h3><pre><code class="hljs java"><span class="hljs-comment">// 在arr上，找满足&gt;=value的最左位置</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">nearestIndex</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> value)</span></span>&#123;    <span class="hljs-keyword">int</span> L = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> R = arr.length - <span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> index = -<span class="hljs-number">1</span>; <span class="hljs-comment">// 记录最左的对号</span>    <span class="hljs-keyword">while</span> (L &lt;= R)&#123;        <span class="hljs-keyword">int</span> mid = L + ((R - L) &gt;&gt; <span class="hljs-number">1</span>);        <span class="hljs-keyword">if</span> (arr[mid] &gt;= value) &#123;            index = mid;            R = mid - <span class="hljs-number">1</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            L = mid + <span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> index;&#125;</code></pre><h3 id="3、-在一个有序数组中，找-lt-某个数最右侧的位置"><a href="#3、-在一个有序数组中，找-lt-某个数最右侧的位置" class="headerlink" title="3、 在一个有序数组中，找&lt;=某个数最右侧的位置"></a>3、 在一个有序数组中，找&lt;=某个数最右侧的位置</h3><pre><code class="hljs java"><span class="hljs-comment">// 在arr上，找满足&lt;=value的最右位置</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">nearestIndex</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> value)</span> </span>&#123;    <span class="hljs-keyword">int</span> L = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> R = arr.length - <span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> index = -<span class="hljs-number">1</span>; <span class="hljs-comment">// 记录最右的对号</span>    <span class="hljs-keyword">while</span> (L &lt;= R) &#123;        <span class="hljs-keyword">int</span> mid = L + ((R - L) &gt;&gt; <span class="hljs-number">1</span>);        <span class="hljs-keyword">if</span> (arr[mid] &lt;= value) &#123;            index = mid;            L = mid + <span class="hljs-number">1</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            R = mid - <span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> index;&#125;</code></pre><h3 id="4、-局部最小值问题"><a href="#4、-局部最小值问题" class="headerlink" title="4、 局部最小值问题"></a>4、 局部最小值问题</h3><blockquote><ol><li>arr[0]&lt;arr[1]</li><li>Arr[len-1]&lt;Arr[len-2]</li><li>arr[i-1]&lt;arr[i]&lt;arr[i+1]</li></ol></blockquote><p>arr无序, 任意两个相邻数不相等, 只需返回一个局部最小位置:</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getLessIndex</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;   <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length == <span class="hljs-number">0</span>) &#123;      <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">// no exist</span>   &#125;   <span class="hljs-keyword">if</span> (arr.length == <span class="hljs-number">1</span> || arr[<span class="hljs-number">0</span>] &lt; arr[<span class="hljs-number">1</span>]) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;   &#125;   <span class="hljs-keyword">if</span> (arr[arr.length - <span class="hljs-number">1</span>] &lt; arr[arr.length - <span class="hljs-number">2</span>]) &#123;      <span class="hljs-keyword">return</span> arr.length - <span class="hljs-number">1</span>;   &#125;   <span class="hljs-keyword">int</span> left = <span class="hljs-number">1</span>;   <span class="hljs-keyword">int</span> right = arr.length - <span class="hljs-number">2</span>;   <span class="hljs-keyword">int</span> mid = <span class="hljs-number">0</span>;   <span class="hljs-keyword">while</span> (left &lt; right) &#123;      mid = (left + right) / <span class="hljs-number">2</span>;      <span class="hljs-keyword">if</span> (arr[mid] &gt; arr[mid - <span class="hljs-number">1</span>]) &#123;         right = mid - <span class="hljs-number">1</span>;      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[mid] &gt; arr[mid + <span class="hljs-number">1</span>]) &#123;         left = mid + <span class="hljs-number">1</span>;      &#125; <span class="hljs-keyword">else</span> &#123;         <span class="hljs-keyword">return</span> mid;      &#125;   &#125;   <span class="hljs-keyword">return</span> left;&#125;</code></pre><h2 id="认识异或运算"><a href="#认识异或运算" class="headerlink" title="认识异或运算"></a>认识异或运算</h2><h3 id="1、如何记住"><a href="#1、如何记住" class="headerlink" title="1、如何记住"></a>1、如何记住</h3><p>异或运算：相同为0，不同为1<br>同或运算：相同以1，不同为0</p><blockquote><p>能长时间记住的概率接近0%</p><p>所以，异或运算就记成无进位相加！ </p></blockquote><h3 id="2、异或运算的性质"><a href="#2、异或运算的性质" class="headerlink" title="2、异或运算的性质"></a>2、异或运算的性质</h3><p>0^N == N      N^N == 0<br>异或运算满足交换律和结合率</p><p>上面的两个性质用无进位相加来理解就非常的容易</p><h3 id="3、如何不用额外变量交换两个数"><a href="#3、如何不用额外变量交换两个数" class="headerlink" title="3、如何不用额外变量交换两个数"></a>3、如何不用额外变量交换两个数</h3><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;    arr[i] = arr[i] ^ arr[j];    arr[j] = arr[i] ^ arr[j];    arr[i] = arr[i] ^ arr[j];&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201125212731.png" alt="结构"></p><blockquote><p>注意:     i和j是一个位置的话，会出错，指向的内存要求是不一样的，各自独立的。</p></blockquote><h3 id="4、一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这种数"><a href="#4、一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这种数" class="headerlink" title="4、一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这种数"></a>4、一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这种数</h3><pre><code class="hljs java"><span class="hljs-comment">// arr中，只有一种数，出现奇数次</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printOddTimesNum1</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;   <span class="hljs-keyword">int</span> eor = <span class="hljs-number">0</span>;   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;      eor ^= arr[i];   &#125;   System.out.println(eor);&#125;</code></pre><h3 id="5、怎么把一个int类型的数，提取出最右侧的1来"><a href="#5、怎么把一个int类型的数，提取出最右侧的1来" class="headerlink" title="5、怎么把一个int类型的数，提取出最右侧的1来"></a>5、怎么把一个int类型的数，提取出最右侧的1来</h3><p>N &amp; ((~N)+1)</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img9SF_F0USXR87N%TE$HW3L80.png" alt="1"></p><h3 id="6、一个数组中有两种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这两种数"><a href="#6、一个数组中有两种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这两种数" class="headerlink" title="6、一个数组中有两种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这两种数"></a>6、一个数组中有两种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这两种数</h3><pre><code class="hljs java"><span class="hljs-comment">// arr中，有两种数，出现奇数次</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printOddTimesNum2</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;   <span class="hljs-keyword">int</span> eor = <span class="hljs-number">0</span>;   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;      eor ^= arr[i];   &#125;   <span class="hljs-comment">// eor = a ^ b</span>   <span class="hljs-comment">// eor != 0</span>   <span class="hljs-comment">// eor必然有一个位置上是1</span>   <span class="hljs-keyword">int</span> rightOne = eor &amp; (~eor + <span class="hljs-number">1</span>); <span class="hljs-comment">// 提取出最右的1</span>   <span class="hljs-keyword">int</span> onlyOne = <span class="hljs-number">0</span>; <span class="hljs-comment">// eor&#x27;</span>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; arr.length;i++) &#123;      <span class="hljs-keyword">if</span> ((arr[i] &amp; rightOne) != <span class="hljs-number">0</span>) &#123;         onlyOne ^= arr[i];      &#125;   &#125;   System.out.println(onlyOne + <span class="hljs-string">&quot; &quot;</span> + (eor ^ onlyOne));&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201125220723.png" alt="图解"></p><h1 id="链表结构、栈、队列、递归行为、哈希表"><a href="#链表结构、栈、队列、递归行为、哈希表" class="headerlink" title="链表结构、栈、队列、递归行为、哈希表"></a>链表结构、栈、队列、递归行为、哈希表</h1><h2 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h2><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> value;    <span class="hljs-keyword">public</span> Node next;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span> </span>&#123;        <span class="hljs-keyword">this</span>.value = data;    &#125;&#125;</code></pre><h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DoubleNode</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> value;    <span class="hljs-keyword">public</span> DoubleNode last;    <span class="hljs-keyword">public</span> DoubleNode next;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DoubleNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span> </span>&#123;        <span class="hljs-keyword">this</span>.value = data;    &#125;&#125;</code></pre><h2 id="单向链表和双向链表最简单的练习"><a href="#单向链表和双向链表最简单的练习" class="headerlink" title="单向链表和双向链表最简单的练习"></a>单向链表和双向链表最简单的练习</h2><blockquote><p> 链表相关的问题几乎都是coding问题</p></blockquote><ul><li><p>单链表和双链表如何反转</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">reverseLinkedList</span><span class="hljs-params">(Node head)</span> </span>&#123;   Node pre = <span class="hljs-keyword">null</span>;   Node next = <span class="hljs-keyword">null</span>;   <span class="hljs-keyword">while</span> (head != <span class="hljs-keyword">null</span>) &#123;      next = head.next; <span class="hljs-comment">// 记录head下一个</span>      head.next = pre; <span class="hljs-comment">// 让head指向pre</span>      pre = head; <span class="hljs-comment">// 记录初始head</span>      head = next;<span class="hljs-comment">// head跳到下一个</span>   &#125;   <span class="hljs-keyword">return</span> pre;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> DoubleNode <span class="hljs-title">reverseDoubleList</span><span class="hljs-params">(DoubleNode head)</span></span>&#123;    DoubleNode pre = <span class="hljs-keyword">null</span>;    DoubleNode next = <span class="hljs-keyword">null</span>;    <span class="hljs-keyword">while</span> (head != <span class="hljs-keyword">null</span>)&#123;        next = head.next;        head.next = pre;        head.last = next;        pre = head;        head = next;    &#125;    <span class="hljs-keyword">return</span> pre;&#125;</code></pre></li><li><p>把给定值都删除</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">removeValue</span><span class="hljs-params">(Node head, <span class="hljs-keyword">int</span> num)</span></span>&#123;    <span class="hljs-comment">// 先找到值不是value的结点，作为头结点</span>    <span class="hljs-keyword">while</span> (head != <span class="hljs-keyword">null</span>)&#123;        <span class="hljs-keyword">if</span> (head.value != num)&#123;            <span class="hljs-keyword">break</span>;        &#125;        head = head.next;    &#125;    <span class="hljs-comment">// 找到后, 删除后面的</span>    Node pre = head; <span class="hljs-comment">// 记录上一个不等于num的位置</span>    Node cur = head; <span class="hljs-comment">// cur作为条件, 每次跳一次, 遍历链表</span>    <span class="hljs-keyword">while</span> (cur != <span class="hljs-keyword">null</span>)&#123;        <span class="hljs-keyword">if</span> (cur.value == num)&#123;            pre.next = cur.next;        &#125;<span class="hljs-keyword">else</span> &#123;            pre = cur;        &#125;        cur = cur.next;    &#125;    <span class="hljs-keyword">return</span> head;&#125;</code></pre></li></ul><p>这里就是熟悉结构。链表还有哪些常见面试题，后续有专门系统学习。</p><h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h2><blockquote><p>逻辑概念<br>栈：数据先进后出，犹如弹匣<br>队列：数据先进先出，好似排队</p></blockquote><h2 id="栈和队列的实际实现"><a href="#栈和队列的实际实现" class="headerlink" title="栈和队列的实际实现"></a>栈和队列的实际实现</h2><ul><li><p>双向链表实现</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;    <span class="hljs-keyword">public</span> T value;    <span class="hljs-keyword">public</span> Node&lt;T&gt; last;    <span class="hljs-keyword">public</span> Node&lt;T&gt; next;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(T data)</span> </span>&#123;        <span class="hljs-keyword">this</span>.value = data;    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DoubleEndsQueue</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;    <span class="hljs-keyword">public</span> Node&lt;T&gt; head;    <span class="hljs-keyword">public</span> Node&lt;T&gt; tail;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addFromHead</span><span class="hljs-params">(T value)</span> </span>&#123;        Node&lt;T&gt; cur = <span class="hljs-keyword">new</span> Node&lt;&gt;(value);        <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>)&#123;            head = cur;            tail = cur;        &#125;<span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// 改变结点</span>            cur.next =  head;            head.last = cur;            <span class="hljs-comment">// 变更新的头结点</span>            head = cur;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addFromBottom</span><span class="hljs-params">(T value)</span> </span>&#123;        Node&lt;T&gt; cur = <span class="hljs-keyword">new</span> Node&lt;&gt;(value);        <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>)&#123;            head = cur;            tail = cur;        &#125;<span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// 改变结点</span>            cur.last = tail;            tail.next = cur;            tail = cur;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">popFromHead</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        Node&lt;T&gt; cur = head;        <span class="hljs-keyword">if</span> (head == tail)&#123;            head = <span class="hljs-keyword">null</span>;            tail = <span class="hljs-keyword">null</span>;        &#125;<span class="hljs-keyword">else</span> &#123;            head = head.next;            cur.next = <span class="hljs-keyword">null</span>;            head.last = <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-keyword">return</span> cur.value;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">popFromBottom</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        Node&lt;T&gt; cur = tail;        <span class="hljs-keyword">if</span> (head == tail)&#123;            head = <span class="hljs-keyword">null</span>;            tail = <span class="hljs-keyword">null</span>;        &#125;<span class="hljs-keyword">else</span> &#123;            tail = tail.last;            tail.next = <span class="hljs-keyword">null</span>;            cur.last = <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-keyword">return</span> cur.value;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> head == <span class="hljs-keyword">null</span>;    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyStack</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;    <span class="hljs-keyword">private</span> DoubleEndsQueue&lt;T&gt; queue;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyStack</span><span class="hljs-params">()</span> </span>&#123;        queue = <span class="hljs-keyword">new</span> DoubleEndsQueue&lt;&gt;();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(T value)</span></span>&#123;        queue.addFromHead(value);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> queue.popFromHead();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> queue.isEmpty();    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyQueue</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;    <span class="hljs-keyword">private</span> DoubleEndsQueue&lt;T&gt; queue;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyQueue</span><span class="hljs-params">()</span> </span>&#123;        queue = <span class="hljs-keyword">new</span> DoubleEndsQueue&lt;&gt;();    &#125;    <span class="hljs-comment">// 出push</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(T value)</span></span>&#123;        queue.addFromHead(value);    &#125;    <span class="hljs-comment">// 进poll</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">poll</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> queue.popFromBottom();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> queue.isEmpty();    &#125;&#125;</code></pre></li><li><p>数组实现</p><blockquote><p>数组实现栈</p></blockquote></li></ul><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayStack</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span>[] a;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size;<span class="hljs-comment">//栈数组的大小</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> top;<span class="hljs-comment">//栈顶</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayStack</span><span class="hljs-params">(<span class="hljs-keyword">int</span> maxSize)</span> </span>&#123;        <span class="hljs-keyword">this</span>.size = maxSize;        <span class="hljs-keyword">this</span>.a = <span class="hljs-keyword">new</span> <span class="hljs-keyword">long</span>[size];        <span class="hljs-keyword">this</span>.top = -<span class="hljs-number">1</span>;<span class="hljs-comment">//表示空栈</span>    &#125;    <span class="hljs-comment">//入栈</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">long</span> value)</span></span>&#123;        <span class="hljs-keyword">if</span>(isFull())&#123;            System.out.println(<span class="hljs-string">&quot;栈已经满！&quot;</span>);            <span class="hljs-keyword">return</span>;        &#125;        a[++top] = value;    &#125;    <span class="hljs-comment">//返回栈顶内容，但是不删除</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">peek</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">if</span>(isEmpty())&#123;            System.out.println(<span class="hljs-string">&quot;栈中没有数据！&quot;</span>);        &#125;        System.out.println(a[top]);    &#125;    <span class="hljs-comment">//弹出栈顶内容，删除</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">if</span>(isEmpty())&#123;            System.out.println(<span class="hljs-string">&quot;栈中没有数据！&quot;</span>);            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">return</span> a[top--];    &#125;    <span class="hljs-comment">//size栈的大小</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> top + <span class="hljs-number">1</span>;    &#125;    <span class="hljs-comment">//是否为空</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> (top == -<span class="hljs-number">1</span>);    &#125;    <span class="hljs-comment">//是否满了</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isFull</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> (top == size - <span class="hljs-number">1</span>);    &#125;    <span class="hljs-comment">//显示</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span></span>&#123;        System.out.print(<span class="hljs-string">&quot;[&quot;</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = top; i &gt;=<span class="hljs-number">0</span> ; i--) &#123;            System.out.print(a[i]);            <span class="hljs-keyword">if</span>(i!=<span class="hljs-number">0</span>)&#123;                System.out.print(<span class="hljs-string">&quot;,&quot;</span>);            &#125;        &#125;        System.out.println(<span class="hljs-string">&quot;]&quot;</span>);    &#125;&#125;</code></pre><blockquote><p>数组实现队列</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyQueue</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] arr;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> pushi;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> polli;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> limit;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyQueue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> limit)</span> </span>&#123;        <span class="hljs-keyword">this</span>.arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[limit];        <span class="hljs-keyword">this</span>.pushi = <span class="hljs-number">0</span>;        <span class="hljs-keyword">this</span>.polli = <span class="hljs-number">0</span>;        <span class="hljs-keyword">this</span>.size = <span class="hljs-number">0</span>;        <span class="hljs-keyword">this</span>.limit = limit;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;        <span class="hljs-keyword">if</span> (size == limit)&#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;栈满了，不能再加了&quot;</span>);        &#125;        size++;        arr[pushi] = value;        pushi = nextIndex(pushi);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">poll</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (size == <span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;栈空了，不能再拿了&quot;</span>);        &#125;        size--;        <span class="hljs-keyword">int</span> ans = arr[polli];        polli = nextIndex(polli);        <span class="hljs-keyword">return</span> ans;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> size == <span class="hljs-number">0</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">nextIndex</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>&#123;        <span class="hljs-keyword">return</span> i &lt; limit - <span class="hljs-number">1</span> ? i + <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;    &#125;&#125;</code></pre><h2 id="栈和队列的常见面试题"><a href="#栈和队列的常见面试题" class="headerlink" title="栈和队列的常见面试题"></a>栈和队列的常见面试题</h2><h3 id="1、实现一个特殊的栈，在基本功能的基础上，再实现返回栈中最小元素的功能"><a href="#1、实现一个特殊的栈，在基本功能的基础上，再实现返回栈中最小元素的功能" class="headerlink" title="1、实现一个特殊的栈，在基本功能的基础上，再实现返回栈中最小元素的功能"></a>1、实现一个特殊的栈，在基本功能的基础上，再实现返回栈中最小元素的功能</h3><blockquote><p>1）pop、push、getMin操作的时间复杂度都是 O(1)。 </p><p>2）设计的栈类型可以使用现成的栈结构。</p></blockquote><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201128160516.png" alt="实现"></p><p> <strong>当前数和最小栈栈顶做比较, 谁小加谁</strong>,  弹出一起弹出 —–&gt; MyStack2</p><p> <strong>当前数和最小栈栈顶做比较, 只有小于最小栈栈顶才压入</strong>,弹出如果Data Peek = Min Peek, 一起弹出 —–&gt; MyStack1</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 想要压入的数比最小栈大 不压入, 小于等于压入</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyStack1</span> </span>&#123;    <span class="hljs-keyword">private</span> Stack&lt;Integer&gt; stackData;    <span class="hljs-keyword">private</span> Stack&lt;Integer&gt; stackMin;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyStack1</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">this</span>.stackData = <span class="hljs-keyword">new</span> Stack&lt;Integer&gt;();        <span class="hljs-keyword">this</span>.stackMin = <span class="hljs-keyword">new</span> Stack&lt;Integer&gt;();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> newNum)</span> </span>&#123;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.stackMin.isEmpty()) &#123;            <span class="hljs-keyword">this</span>.stackMin.push(newNum);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (newNum &lt;= <span class="hljs-keyword">this</span>.getmin()) &#123;            <span class="hljs-keyword">this</span>.stackMin.push(newNum);        &#125;        <span class="hljs-keyword">this</span>.stackData.push(newNum);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 弹出如果Data栈弹出的数等于最小栈栈顶则弹出</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.stackData.isEmpty()) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;Your stack is empty.&quot;</span>);        &#125;        <span class="hljs-keyword">int</span> value = <span class="hljs-keyword">this</span>.stackData.pop();        <span class="hljs-keyword">if</span> (value == <span class="hljs-keyword">this</span>.getmin()) &#123;            <span class="hljs-keyword">this</span>.stackMin.pop();        &#125;        <span class="hljs-keyword">return</span> value;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getmin</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.stackMin.isEmpty()) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;Your stack is empty.&quot;</span>);        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.stackMin.peek();    &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 想要压入的数比最小栈大 重复压入最小栈栈顶</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyStack2</span> </span>&#123;    <span class="hljs-keyword">private</span> Stack&lt;Integer&gt; stackData;    <span class="hljs-keyword">private</span> Stack&lt;Integer&gt; stackMin;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyStack2</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">this</span>.stackData = <span class="hljs-keyword">new</span> Stack&lt;Integer&gt;();        <span class="hljs-keyword">this</span>.stackMin = <span class="hljs-keyword">new</span> Stack&lt;Integer&gt;();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> newNum)</span></span>&#123;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.stackMin.isEmpty())&#123;            <span class="hljs-comment">// 如果最小栈没有元素 直接压入</span>            <span class="hljs-keyword">this</span>.stackMin.push(newNum);        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (newNum &lt; <span class="hljs-keyword">this</span>.getMin())&#123;            <span class="hljs-comment">// 如果最小栈栈顶小于newNum</span>            <span class="hljs-keyword">this</span>.stackMin.push(newNum);        &#125;<span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// 如果最小栈栈顶大于newNum, 重复压入栈顶元素</span>            <span class="hljs-keyword">int</span> minNum = <span class="hljs-keyword">this</span>.getMin();            <span class="hljs-keyword">this</span>.stackMin.push(minNum);        &#125;        <span class="hljs-keyword">this</span>.stackData.push(newNum);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.stackData.isEmpty()) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;Your stack is empty.&quot;</span>);        &#125;        <span class="hljs-keyword">this</span>.stackMin.pop();        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.stackData.pop();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMin</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.stackMin.isEmpty())&#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;Your stack is empty.&quot;</span>);        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.stackMin.peek();    &#125;&#125;</code></pre><h3 id="2、栈与队列互相实现"><a href="#2、栈与队列互相实现" class="headerlink" title="2、栈与队列互相实现"></a>2、栈与队列互相实现</h3><blockquote><p>1）如何用栈结构实现队列结构</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TwoStacksQueue</span> </span>&#123;        <span class="hljs-keyword">public</span> Stack&lt;Integer&gt; stackPush;        <span class="hljs-keyword">public</span> Stack&lt;Integer&gt; stackPop;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TwoStacksQueue</span><span class="hljs-params">()</span> </span>&#123;            stackPush = <span class="hljs-keyword">new</span> Stack&lt;Integer&gt;();            stackPop = <span class="hljs-keyword">new</span> Stack&lt;Integer&gt;();        &#125;        <span class="hljs-comment">// push栈向pop栈倒入数据</span>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pushToPop</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">if</span> (stackPop.empty())&#123;                <span class="hljs-keyword">while</span> (!stackPush.empty())&#123;                    stackPop.push(stackPush.pop());                &#125;            &#125;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pushInt)</span></span>&#123;            stackPush.push(pushInt);<span class="hljs-comment">//            pushToPop();</span>        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">poll</span><span class="hljs-params">()</span></span>&#123;            <span class="hljs-keyword">if</span> (stackPop.empty() &amp;&amp; stackPush.empty()) &#123;                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;Queue is empty!&quot;</span>);            &#125;            pushToPop();            <span class="hljs-keyword">return</span> stackPop.pop();        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">peek</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">if</span> (stackPop.empty() &amp;&amp; stackPush.empty()) &#123;                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;Queue is empty!&quot;</span>);            &#125;            pushToPop();            <span class="hljs-keyword">return</span> stackPop.peek();        &#125;    &#125;</code></pre><blockquote><p>2）如何用队列结构实现栈结构</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TwoQueueStack</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;    <span class="hljs-keyword">public</span> Queue&lt;T&gt; queue;    <span class="hljs-keyword">public</span> Queue&lt;T&gt; help;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TwoQueueStack</span><span class="hljs-params">()</span> </span>&#123;        queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        help = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(T value)</span></span>&#123; queue.offer(value);&#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">poll</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">while</span> (queue.size() &gt; <span class="hljs-number">1</span>)&#123;            help.offer(queue.poll());        &#125;        T ans = queue.poll();        Queue&lt;T&gt; temp = queue;        queue = help;        help = temp;        <span class="hljs-keyword">return</span> ans;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">peek</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">while</span> (queue.size() &gt; <span class="hljs-number">1</span>)&#123;            help.offer(queue.poll());        &#125;        T ans = queue.peek();        Queue&lt;T&gt; temp = queue;        queue = help;        help = temp;        queue.offer(ans);        <span class="hljs-keyword">return</span> ans;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> queue.isEmpty();    &#125;&#125;</code></pre><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><blockquote><p>怎么从思想上理解递归</p></blockquote><p>求数组arr[L..R]中的最大值，怎么用递归方法实现。</p><p>1）将[L..R]范围分成左右两半。左：[L..Mid]  右[Mid+1..R]<br>2）左部分求最大值，右部分求最大值<br>3） [L..R]范围上的最大值，是max{左部分最大值，右部分最大值}</p><p>注意：2）是个递归过程，当范围上只有一个数，就可以不用再递归了</p><pre><code class="hljs java"><span class="hljs-comment">// 求arr中的最大值</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMax</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;    <span class="hljs-keyword">return</span> process(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>);&#125;<span class="hljs-comment">// arr[L..R]范围上求最大值  L ... R   N</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">process</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R)</span> </span>&#123;    <span class="hljs-keyword">if</span> (L == R) &#123; <span class="hljs-comment">// arr[L..R]范围上只有一个数，直接返回，base case</span>        <span class="hljs-keyword">return</span> arr[L];    &#125;    <span class="hljs-keyword">int</span> mid = L + ((R - L) &gt;&gt; <span class="hljs-number">1</span>); <span class="hljs-comment">// 中点    1</span>    <span class="hljs-keyword">int</span> leftMax = process(arr, L, mid);    <span class="hljs-keyword">int</span> rightMax = process(arr, mid + <span class="hljs-number">1</span>, R);    <span class="hljs-keyword">return</span> Math.max(leftMax, rightMax);&#125;</code></pre><h3 id="递归的脑图和实际实现"><a href="#递归的脑图和实际实现" class="headerlink" title="递归的脑图和实际实现"></a>递归的脑图和实际实现</h3><p>对于新手来说，把调用的过程画出结构图是必须的，这有利于分析递归</p><p>递归并不是玄学，递归底层是利用系统栈来实现的</p><p>任何递归函数都一定可以改成非递归</p><h3 id="Master公式"><a href="#Master公式" class="headerlink" title="Master公式"></a>Master公式</h3><blockquote><p>形如T(N) = a * T(N/b) + O(N^d)(其中的a、b、d都是常数)的递归函数，可以直接通过Master公式来确定时间复杂度, a次子问题规模(总问题是子问题的b倍规模)</p></blockquote><p>以b为底, logb(a)</p><p>如果 log(b,a) &lt; d，复杂度为O(N^d)<br>如果 log(b,a) &gt; d，复杂度为O(N^log(b,a))<br>如果 log(b,a) == d，复杂度为O(N^d  * logN)</p><p>上述算法中, 把数组分成两份, 每份1/2, 其他时间复杂度为O(1)</p><p>T(N) = 2 * T(N/2) + O(N^0) 即O(N), 与从左往右遍历一遍是一样的</p><p>如果左边2/3, 右边也2/3, 也是两份, 其他再打印一次, 时间复杂度为O(n)</p><p>T(N) = 2 * T(N/(3/2)) + O(N^1)</p><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>1)哈希表在使用层面上可以理解为一种集合结构<br>2)如果只有key，没有伴随数据value，可以使用 <strong><em>HashSet</em></strong>结构<br>3)如果既有key，又有伴随数据value，可以使用 <strong><em>HashMap</em></strong>结构<br>4) <strong><em>有无伴随数据，是HashMap和HashSet唯一的区别，实际结构是一回事</em></strong><br>5)使用哈希表增(put)、删(remove)、改(put)和查(get)的操作，可以认为时间复杂度为 O(1)，但是 <strong><em>常数时间</em></strong>比较大<br>6)放入哈希表的东西，如果是基础类型， <strong><em>内部按值传递</em></strong>，内存占用是这个东西的大小 </p><pre><code class="hljs java"><span class="hljs-keyword">int</span> a = <span class="hljs-number">100000</span>;<span class="hljs-keyword">int</span> b = <span class="hljs-number">100000</span>;<span class="hljs-comment">// 不关心内存区域, 只关心对应的值</span>System.out.println(a == b);Integer c = <span class="hljs-number">100000</span>;Integer d = <span class="hljs-number">100000</span>;<span class="hljs-comment">// 关心内存区域</span>System.out.println(c.equals(d));Integer e = <span class="hljs-number">127</span>;  <span class="hljs-comment">//  - 128  ~  127 true, 按值传递</span>Integer f = <span class="hljs-number">127</span>;System.out.println(e == f);<span class="hljs-comment">// 但是在哈希表中, 基础类型, 内部都按值传递</span></code></pre><p>7)放入哈希表的东西，如果不是基础类型， <strong><em>内部按引用传递</em></strong>，内存占用是8字节</p><pre><code class="hljs java">HashMap&lt;Node, String&gt; map2 = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();Node node1 = <span class="hljs-keyword">new</span> Node(<span class="hljs-number">1</span>);Node node2 = node1;map2.put(node1, <span class="hljs-string">&quot;我是node1&quot;</span>);map2.put(node2, <span class="hljs-string">&quot;我是node1&quot;</span>);System.out.println(map2.size());<span class="hljs-comment">// 结果为 1</span></code></pre><pre><code class="hljs java">HashMap&lt;Node, String&gt; map2 = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();Node node1 = <span class="hljs-keyword">new</span> Node(<span class="hljs-number">1</span>);Node node2 = <span class="hljs-keyword">new</span> Node(<span class="hljs-number">2</span>);map2.put(node1, <span class="hljs-string">&quot;我是node1&quot;</span>);map2.put(node2, <span class="hljs-string">&quot;我是node1&quot;</span>);System.out.println(map2.size());<span class="hljs-comment">// 结果为 2</span></code></pre><pre><code class="hljs processing">即如果<span class="hljs-keyword">HashMap</span>&lt;<span class="hljs-keyword">String</span>, <span class="hljs-keyword">String</span>&gt; <span class="hljs-built_in">map</span> = <span class="hljs-keyword">new</span> <span class="hljs-keyword">HashMap</span>&lt;&gt;();<span class="hljs-built_in">key</span>和value都传<span class="hljs-number">100</span>位数据, 最终数据占用为 <span class="hljs-number">4</span> * <span class="hljs-number">100</span> * <span class="hljs-number">2</span>但如果<span class="hljs-keyword">HashMap</span>&lt;Node, Node&gt; map2 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">HashMap</span>&lt;&gt;();<span class="hljs-built_in">key</span>和value都传<span class="hljs-number">20</span>g数据, <span class="hljs-built_in">map</span>中只存内存地址<span class="hljs-number">8</span>字节, <span class="hljs-number">4</span> * <span class="hljs-number">8</span> * <span class="hljs-number">2</span>字节大小完成操作</code></pre><h2 id="有序表-TreeMap-O-logN"><a href="#有序表-TreeMap-O-logN" class="headerlink" title="有序表(TreeMap) O(logN)"></a>有序表(TreeMap) O(logN)</h2><p>1)有序表在使用层面上可以理解为一种集合结构<br>2)如果只有key，没有伴随数据value，可以使用TreeSet结构<br>3)如果既有key，又有伴随数据value，可以使用TreeMap结构<br>4)有无伴随数据，是TreeSet和TreeMap唯一的区别，底层的实际结构是一回事<br>5) <strong><em>有序表把key按照顺序组织起来，而哈希表完全不组织</em></strong></p><pre><code class="hljs java">System.out.println(treeMap.firstKey());System.out.println(treeMap.lastKey());<span class="hljs-comment">// &lt;= 4</span>System.out.println(treeMap.floorKey(<span class="hljs-number">4</span>));<span class="hljs-comment">// &gt;= 4</span>System.out.println(treeMap.ceilingKey(<span class="hljs-number">4</span>));</code></pre><ol start="6"><li><strong><em>红黑树</em></strong>、 <strong><em>AVL树</em></strong>、 <strong><em>size-balance-tree</em></strong>和 <strong><em>跳表</em></strong>等都属于 <strong><em>有序表</em></strong>结构，只是底层具体实现不同</li><li>放入如果是基础类型，内部按值传递，内存占用就是这个东西的大小</li><li>放入如果不是基础类型，内部按引用传递，内存占用是8字节</li><li>不管是什么底层具体实现，只要是有序表，都有以下固定的基本功能和固定的时间复杂度 </li></ol><blockquote><p>Api</p></blockquote><p>1)void put(K key, V value)<br>将一个(key，value)记录加入到表中，或者将key的记录 更新成value。<br>2)V get(K key)<br>根据给定的key，查询value并返回。<br>3)void remove(K key)<br>移除key的记录。<br>4)boolean containsKey(K key)<br>询问是否有关于key的记录。</p><p>5)K firstKey()<br>返回所有键值的排序结果中，最小的那个。6)K lastKey()<br>返回所有键值的排序结果中，最大的那个。7)K floorKey(K key)<br>返回&lt;= key 离key最近的那个<br>8)K ceilingKey(K key）<br>返回&gt;= key 离key最近的那个</p><blockquote><p>哈希表在使用时，增删改查时间复杂度都是O(1)<br>有序表在使用时，比哈希表功能多，时间复杂度都是O(logN)</p></blockquote><h1 id="归并排序与随机快排"><a href="#归并排序与随机快排" class="headerlink" title="归并排序与随机快排"></a>归并排序与随机快排</h1><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><blockquote><p>1）整体是递归，左边排好序+右边排好序+merge让整体有序</p></blockquote><p>例子: [3, 1, 2, 4]</p><p>主函数: f(0, 3) </p><p>运行后process(0,1) 再 process(2, 3) 再merge</p><p>而运行process(0,1) 需要process(0,0)再process(1,1)再merge</p><p>运行process(2, 3)需要process(2, 2)再process(3, 3)再merge</p><h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><pre><code class="hljs java"><span class="hljs-comment">// 递归方法实现</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mergeSort1</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span></span>&#123;    <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length &lt; <span class="hljs-number">2</span>) &#123;        <span class="hljs-keyword">return</span>;    &#125;    process(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>);&#125;<span class="hljs-comment">// 让arr L - R范围变成有序</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R)</span></span>&#123;    <span class="hljs-keyword">if</span> (L == R)&#123; <span class="hljs-comment">// base case</span>        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">int</span> mid = L + (( R - L ) &gt;&gt; <span class="hljs-number">2</span>);    process(arr, L, mid);    process(arr, mid + <span class="hljs-number">1</span>, R);    merge(arr, L, mid, R);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span>  <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> M, <span class="hljs-keyword">int</span> R)</span></span>&#123;    <span class="hljs-keyword">int</span>[] help = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[R - L + <span class="hljs-number">1</span>];    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; <span class="hljs-comment">// help数组的指针</span>    <span class="hljs-keyword">int</span> p1 = L; <span class="hljs-comment">// 左部分指针</span>    <span class="hljs-keyword">int</span> p2 = M + <span class="hljs-number">1</span>; <span class="hljs-comment">// 又部分指针</span>    <span class="hljs-keyword">while</span> (p1 &lt;= M &amp;&amp; p2 &lt;= R)&#123;        help[i++] = arr[p1] &lt;= arr[p2] ? arr[p1++] : arr[p2++];    &#125;    <span class="hljs-comment">// 要么p1越界, 要么p2越界</span>    <span class="hljs-keyword">while</span> (p1 &lt;= M)&#123;        help[i++] = arr[p1++];    &#125;    <span class="hljs-keyword">while</span> (p2 &lt;= R)&#123;        help[i++] = arr[p2++];    &#125;    <span class="hljs-comment">// 把help的值赋值回去</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; help.length ; j++) &#123;        arr[L + i] = help[i];    &#125;&#125;</code></pre><h3 id="非递归实现"><a href="#非递归实现" class="headerlink" title="非递归实现"></a>非递归实现</h3><p>例子[2, 3, 1, 4, 5, 6]</p><p>初始k = 1, 每个最小原子单元, 即每个数自我有序,</p><p>K &lt;&lt; 2, 每两个一组进行merge, 变成[2, 3, 1, 4, 5, 6]</p><p>K &lt;&lt; 2, 每四个一组进行merge, 不够则凑一组[1, 2, 3, 4, 5, 6]</p><p>直到k &gt;= N</p><pre><code class="hljs java"><span class="hljs-comment">// 非递归方法实现</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mergeSort2</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;   <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length &lt; <span class="hljs-number">2</span>) &#123;      <span class="hljs-keyword">return</span>;   &#125;   <span class="hljs-keyword">int</span> N = arr.length;   <span class="hljs-keyword">int</span> mergeSize = <span class="hljs-number">1</span>;<span class="hljs-comment">// 一组是两倍的mergeSize, 当前有序的左组长度</span>   <span class="hljs-keyword">while</span> (mergeSize &lt; N) &#123;      <span class="hljs-keyword">int</span> L = <span class="hljs-number">0</span>;      <span class="hljs-keyword">while</span> (L &lt; N) &#123;         <span class="hljs-comment">// L...M 左组(mergeSize大小)</span>         <span class="hljs-comment">// 求中间</span>         <span class="hljs-keyword">int</span> M = L + mergeSize - <span class="hljs-number">1</span>;         <span class="hljs-keyword">if</span> (M &gt;= N) &#123;            <span class="hljs-keyword">break</span>;         &#125;         <span class="hljs-comment">// L...M   M+1...R</span>         <span class="hljs-comment">// 右组可能凑不齐mergeSize个</span>         <span class="hljs-comment">// 求右边</span>         <span class="hljs-keyword">int</span> R = Math.min(M + mergeSize, N - <span class="hljs-number">1</span>);         merge(arr, L, M, R);         <span class="hljs-comment">// 算下一次左边</span>         L = R + <span class="hljs-number">1</span>;      &#125;            <span class="hljs-comment">// 防止溢出</span>      <span class="hljs-keyword">if</span> (mergeSize &gt; N / <span class="hljs-number">2</span>) &#123;         <span class="hljs-keyword">break</span>;      &#125;      mergeSize &lt;&lt;= <span class="hljs-number">1</span>;   &#125;&#125;</code></pre><h3 id="利用master公式来求解时间复杂度"><a href="#利用master公式来求解时间复杂度" class="headerlink" title="利用master公式来求解时间复杂度"></a>利用master公式来求解时间复杂度</h3><pre><code class="hljs mathematica"><span class="hljs-variable">T</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span><span class="hljs-operator">*</span><span class="hljs-variable">T</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-operator">/</span><span class="hljs-number">2</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">+</span> <span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-operator">^</span><span class="hljs-number">1</span><span class="hljs-punctuation">)</span>根据<span class="hljs-variable">master</span>可知时间复杂度为<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-operator">*</span><span class="hljs-variable">logN</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">(</span>非递归分析<span class="hljs-operator">:</span>每次<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span> <span class="hljs-number">2</span><span class="hljs-operator">,</span> <span class="hljs-number">4</span><span class="hljs-operator">,</span> <span class="hljs-number">8</span><span class="hljs-operator">,</span> <span class="hljs-number">16</span> <span class="hljs-operator">....</span> <span class="hljs-built_in">N</span> <span class="hljs-operator">,</span> <span class="hljs-built_in">Log</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-punctuation">)</span>次<span class="hljs-operator">,</span> 所以<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-operator">*</span><span class="hljs-variable">logN</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">)</span><span class="hljs-variable">merge</span>过程需要辅助数组，所以额外空间复杂度为<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-punctuation">)</span>归并排序的实质是把比较行为变成了有序信息并传递，比<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-operator">^</span><span class="hljs-number">2</span><span class="hljs-punctuation">)</span>的排序快<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-operator">^</span><span class="hljs-number">2</span><span class="hljs-punctuation">)</span>在无限浪费比较行为<span class="hljs-operator">,</span> 例如选择排序<span class="hljs-operator">,</span> 每次都与后面比较大小</code></pre><h3 id="用常见面试题再深入理解一下归并排序的精髓"><a href="#用常见面试题再深入理解一下归并排序的精髓" class="headerlink" title="用常见面试题再深入理解一下归并排序的精髓"></a>用常见面试题再深入理解一下归并排序的精髓</h3><blockquote><p> 在一个数组中，一个数左边比它小的数的总和，叫数的小和，所有数的小和累加起来，叫数组小和。求数组小和。</p></blockquote><p>例子： [1,3,4,2,5]<br>1左边比1小的数：没有<br>3左边比3小的数：1<br>4左边比4小的数：1、3<br>2左边比2小的数：1<br>5左边比5小的数：1、3、4、 2<br>所以数组的小和为1+1+3+1+1+3+4+2=16 </p><p>每次merge时, 两个指针对应的数比较大小, 如果小, 则计算另外一个指针包括当前位置以后的有多少个比对方大的数字.</p><pre><code class="hljs css">例子:<span class="hljs-selector-attr">[1,3,4,2,5]</span> 分为<span class="hljs-selector-attr">[1,3]</span>和<span class="hljs-selector-attr">[4,2,5]</span><span class="hljs-selector-attr">[1]</span> <span class="hljs-selector-attr">[3]</span><span class="hljs-selector-tag">merge</span>时, 1比3小, 1个1<span class="hljs-selector-attr">[4,2,5]</span>分为<span class="hljs-selector-attr">[4]</span>,<span class="hljs-selector-attr">[2, 5]</span><span class="hljs-selector-attr">[4]</span><span class="hljs-selector-tag">merge</span>, <span class="hljs-selector-tag">return</span> 0<span class="hljs-selector-attr">[2, 5]</span><span class="hljs-selector-tag">merge</span>时候, 2比5小, 1个2<span class="hljs-selector-attr">[4]</span>与<span class="hljs-selector-attr">[2,5]</span><span class="hljs-selector-tag">merge</span>时候, 左指针初始4, 右指针初始2, 4 &gt; 2, <span class="hljs-selector-tag">help</span>数组放入2, 右指针右移4 &lt; 5, 1个4,<span class="hljs-selector-tag">help</span>数组放入4,越界,放入5<span class="hljs-selector-attr">[1,3]</span>和<span class="hljs-selector-attr">[2,4,5]</span><span class="hljs-selector-tag">merge</span>, 1&lt;2, 3个1, 3&lt;4, 2个3结束4个1, 1个2, 2个3, 1个4,</code></pre><blockquote><p>其实就是在左指针与右指针对比时, 加上右指针开始个大于左指针数(利用右边有序)的左指针当前数</p><p>result += arr[p1] &lt; arr[p2] ? arr[p1] * (R - p2 + 1) : 0;</p><p>也可以解决降序对的问题</p><p>只要纠结右边有多少个数比左边大这类的问题，都可以用归并</p></blockquote><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">smallNum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[])</span></span>&#123;    <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length &lt; <span class="hljs-number">2</span>)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">return</span> process(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">process</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R)</span></span>&#123;    <span class="hljs-keyword">if</span> (L == R)&#123;        <span class="hljs-comment">// 只有一个数, 右组都没有</span>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">int</span> mid = L + ((R - L) &gt;&gt; <span class="hljs-number">2</span>);    <span class="hljs-keyword">return</span> process(arr, L, mid) + process(arr, mid + <span class="hljs-number">1</span>, R) + merge(arr, L, mid, R);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> mid, <span class="hljs-keyword">int</span> R)</span></span>&#123;    <span class="hljs-keyword">int</span> help[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[R - L + <span class="hljs-number">1</span>];    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> p1 = L;    <span class="hljs-keyword">int</span> p2 = mid + <span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> result = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (p1 &lt;= mid &amp;&amp; p2 &lt;= R)&#123;        result += arr[p1] &lt; arr[p2] ? arr[p1] * (R - p2 + <span class="hljs-number">1</span>) : <span class="hljs-number">0</span>;        help[i++] = arr[p1] &lt; arr[p2] ? arr[p1++] : arr[p2++];    &#125;    <span class="hljs-keyword">while</span> (p1 &lt;= mid)&#123;        help[i++] = arr[p1++];    &#125;    <span class="hljs-keyword">while</span> (p2 &lt;= R)&#123;        help[i++] = arr[p2++];    &#125;    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; help.length; i++) &#123;        arr[L + i] = help[i];    &#125;    <span class="hljs-keyword">return</span> result;&#125;</code></pre><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="Partition过程"><a href="#Partition过程" class="headerlink" title="Partition过程"></a>Partition过程</h3><blockquote><p>给定一个数组arr，和一个整数num。请把小于等于num的数放在数组的左边，大于num的数放在数组的右边。<br>要求额外空间复杂度O(1)，时间复杂度O(N) </p></blockquote><p>设置一个 <strong><em>小于等于区</em></strong>, 设初始位置 -1, </p><ol><li><p>[i]&lt;=num,当前数和小于等于区下一个位置交换, 小于等于区右扩, i++</p></li><li><p>[i]&gt;num, i++</p></li></ol><p>例子: [5, 3, 7, 2] num = 3</p><p>一开始小于等于区位置 -1, i=0, i[0]=5 &gt; 3, i++, 跳到3, 3&lt;=num, 与小于等于区下一个数即i[0]交换</p><p>变成[3, 5, 7, 2]小于等于区右扩, 初始位置为0, 逐步下去</p><pre><code class="hljs java"><span class="hljs-comment">// 以arr[R]做划分值</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R)</span> </span>&#123;   <span class="hljs-keyword">if</span> (L &gt; R) &#123;      <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;   &#125;   <span class="hljs-keyword">if</span> (L == R) &#123;      <span class="hljs-keyword">return</span> L;   &#125;   <span class="hljs-keyword">int</span> lessEqual = L - <span class="hljs-number">1</span>;   <span class="hljs-keyword">int</span> index = L;   <span class="hljs-keyword">while</span> (index &lt; R) &#123;      <span class="hljs-keyword">if</span> (arr[index] &lt;= arr[R]) &#123;         swap(arr, index, ++lessEqual);      &#125;      index++;   &#125;   swap(arr, ++lessEqual, R);   <span class="hljs-keyword">return</span> lessEqual;&#125;</code></pre><h3 id="荷兰国旗问题"><a href="#荷兰国旗问题" class="headerlink" title="荷兰国旗问题"></a>荷兰国旗问题</h3><blockquote><p>给定一个数组arr，和一个整数num。请把小于num的数放在数组的左边，等于num的数放在中间，大于num的数放在数组的右边。</p><p>要求额外空间复杂度O(1)，时间复杂度O(N)  </p></blockquote><p>设置一个 <strong><em>小于区</em></strong>,设初始位置 -1 ;  设置一个 <strong><em>大于区</em></strong>,设初始位置 length -1</p><ol><li><p>[i] == num, i++</p></li><li><p>[i] &lt; num, [i] 与小于区下一个交换, 小于区右扩, i++</p></li><li><p>[i] &gt; num, [i] 与大于区左一个交换, 大于区左扩, i <strong><em>停在原地</em></strong></p></li></ol><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201129162221.png" alt="流程图"></p><p>i与大于区边界撞上的时候停</p><pre><code class="hljs java"><span class="hljs-comment">// arr[L...R] 玩荷兰国旗问题的划分，以arr[R]做划分值</span><span class="hljs-comment">//  &lt;arr[R]  ==arr[R]  &gt; arr[R]</span><span class="hljs-comment">// 返回等于区域范围</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] netherlandsFlag(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R) &#123;   <span class="hljs-keyword">if</span> (L &gt; R) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123; -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span> &#125;;   &#125;   <span class="hljs-keyword">if</span> (L == R) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123; L, R &#125;;   &#125;   <span class="hljs-keyword">int</span> less = L - <span class="hljs-number">1</span>; <span class="hljs-comment">// &lt; 区 右边界</span>   <span class="hljs-keyword">int</span> more = R;     <span class="hljs-comment">// &gt; 区 左边界</span>   <span class="hljs-keyword">int</span> index = L;   <span class="hljs-keyword">while</span> (index &lt; more) &#123;      <span class="hljs-keyword">if</span> (arr[index] == arr[R]) &#123;         index++;      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[index] &lt; arr[R]) &#123;         swap(arr, index++, ++less);      &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// &gt;</span>         swap(arr, index, --more);      &#125;   &#125;   <span class="hljs-comment">// L...Less 小于区 less+1...more-1 等于区 more...R-1 大于区  R没动过</span>   <span class="hljs-comment">// 交换后</span>   <span class="hljs-comment">// L...Less 小于区 less+1.....more 等于区 more+1...R 大于区</span>   swap(arr, more, R);   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123; less + <span class="hljs-number">1</span>, more &#125;;&#125;</code></pre><h2 id="快速排序1-0"><a href="#快速排序1-0" class="headerlink" title="快速排序1.0"></a>快速排序1.0</h2><p>在arr[L..R]范围上，进行快速排序的过程：<br>1）用arr[R]对该范围做partition，&lt;= arr[R]的数在左部分并且保证arr[R]最后来到左部分小于区的最后一个位置，记为M； &lt;= arr[R]的数在右部分（arr[M+1..R]）,此时X就已经排好序了<br>2）对arr[L..M-1]进行快速排序(递归)<br>3）对arr[M+1..R]进行快速排序(递归)<br>因为每一次partition都会搞定一个数的位置且不会再变动，所以排序能完成</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quickSort1</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;   <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length &lt; <span class="hljs-number">2</span>) &#123;      <span class="hljs-keyword">return</span>;   &#125;   process1(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process1</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R)</span> </span>&#123;   <span class="hljs-keyword">if</span> (L &gt;= R) &#123;      <span class="hljs-keyword">return</span>;   &#125;   <span class="hljs-comment">// L..R partition arr[R]  [   &lt;=arr[R]   arr[R]    &gt;arr[R]  ]</span>   <span class="hljs-keyword">int</span> M = partition(arr, L, R);   process1(arr, L, M - <span class="hljs-number">1</span>);   process1(arr, M + <span class="hljs-number">1</span>, R);&#125;</code></pre><h2 id="快速排序2-0"><a href="#快速排序2-0" class="headerlink" title="快速排序2.0"></a>快速排序2.0</h2><p>在arr[L..R]范围上，进行快速排序的过程：<br>1）用arr[R]对该范围做partition，&lt; arr[R]的数在左部分，== arr[R]的数中间，&gt;arr[R]的数在右部分。假设== arr[R]的数所在范围是[a,b]<br>2）对arr[L..a-1]进行快速排序(递归)<br>3）对arr[b+1..R]进行快速排序(递归)<br>因为每一次partition都会搞定一批数的位置且不会再变动，所以排序能完成</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quickSort2</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;   <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length &lt; <span class="hljs-number">2</span>) &#123;      <span class="hljs-keyword">return</span>;   &#125;   process2(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process2</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R)</span> </span>&#123;   <span class="hljs-keyword">if</span> (L &gt;= R) &#123;      <span class="hljs-keyword">return</span>;   &#125;   <span class="hljs-keyword">int</span>[] equalArea = netherlandsFlag(arr, L, R);   process2(arr, L, equalArea[<span class="hljs-number">0</span>] - <span class="hljs-number">1</span>);   process2(arr, equalArea[<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>, R);&#125;</code></pre><h2 id="快速排序1-0和2-0的时间复杂度分析"><a href="#快速排序1-0和2-0的时间复杂度分析" class="headerlink" title="快速排序1.0和2.0的时间复杂度分析"></a>快速排序1.0和2.0的时间复杂度分析</h2><blockquote><p>数组已经有序的时候就是复杂度最高的时候<br>时间复杂度O(N^2)</p></blockquote><h2 id="快速排序3-0-随机快排-荷兰国旗技巧优化"><a href="#快速排序3-0-随机快排-荷兰国旗技巧优化" class="headerlink" title="快速排序3.0(随机快排+荷兰国旗技巧优化)"></a>快速排序3.0(随机快排+荷兰国旗技巧优化)</h2><p>在arr[L..R]范围上，进行快速排序的过程：<br>1）在这个范围上，随机选一个数记为num，<br>1）用num对该范围做partition，&lt; num的数在左部分，== num的数中间，&gt;num的数在右部分。假设== num的数所在范围是[a,b]<br>2）对arr[L..a-1]进行快速排序(递归)<br>3）对arr[b+1..R]进行快速排序(递归)<br>因为每一次partition都会搞定一批数的位置且不会再变动，所以排序能完成</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quickSort3</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;   <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length &lt; <span class="hljs-number">2</span>) &#123;      <span class="hljs-keyword">return</span>;   &#125;   process3(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process3</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R)</span> </span>&#123;   <span class="hljs-keyword">if</span> (L &gt;= R) &#123;      <span class="hljs-keyword">return</span>;   &#125;   <span class="hljs-comment">// 1、2拿arr[R]做划分值</span>   <span class="hljs-comment">// 3 随机选一个i, 人为放到arr[R], 再以arr[R]做划分值</span>   swap(arr, L + (<span class="hljs-keyword">int</span>) (Math.random() * (R - L + <span class="hljs-number">1</span>)), R);   <span class="hljs-keyword">int</span>[] equalArea = netherlandsFlag(arr, L, R);   process3(arr, L, equalArea[<span class="hljs-number">0</span>] - <span class="hljs-number">1</span>);   process3(arr, equalArea[<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>, R);&#125;</code></pre><pre><code class="hljs apache"><span class="hljs-attribute">1</span>）通过分析知道，划分值越靠近中间，性能越好；越靠近两边，性能越差<span class="hljs-attribute">2</span>）随机选一个数进行划分的目的就是让好情况和差情况都变成概率事件<span class="hljs-attribute">3</span>）把每一种情况都列出来，会有每种情况下的时间复杂度，但概率都是<span class="hljs-number">1</span>/N<span class="hljs-attribute">4</span>）那么所有情况都考虑，时间复杂度就是这种概率模型下的长期期望！</code></pre><p> *<strong>时间复杂度O(N<em>logN)，额外空间复杂度O(logN)都是这么来的。</em></strong></p><h1 id="比较器与堆"><a href="#比较器与堆" class="headerlink" title="比较器与堆"></a>比较器与堆</h1><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><h3 id="堆的实现"><a href="#堆的实现" class="headerlink" title="堆的实现"></a>堆的实现</h3><p>堆结构</p><p>1）堆结构就是用数组实现的完全二叉树结构</p><blockquote><p>完全二叉树是什么</p></blockquote><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201201131244.png" alt="完全二叉树"></p><blockquote><p>结点从左至右变满, 一个结点也是, 两个结点, 第二个结点在左边也是</p></blockquote><p>堆可以从数组arr[0]开始, 也可以从arr[1]开始, 为什么会出现从arr[1]开始的情况？</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201201131532.png" alt="arr[1]开始的堆"></p><p><strong>如图所示, 如果堆从arr[1]开始增加, 子结点以及父节点的运算都可以用位运算, 位运算就是快！</strong></p><p>2）完全二叉树中如果每棵子树的最大值都在顶部就是大根堆</p><blockquote><p>头结点为头的树, 最大值为头结点</p></blockquote><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201201131811.png" alt="大根堆"></p><p>3）完全二叉树中如果每棵子树的最小值都在顶部就是小根堆</p><blockquote><p>头结点为头的树, 最小值为头结点</p></blockquote><p>4）堆结构的heapInsert与heapify操作</p><blockquote><p>heapInsert: 数放入数组后, 与父节点比较, 如果数更大, 交换, 直到换到根结点</p></blockquote><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span></span>&#123;    <span class="hljs-keyword">if</span> (heapSize &gt; limit)&#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;heap is full!&quot;</span>);    &#125;    heap[heapSize] = value;    heapInsert(heap, heapSize++);&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 把默认最后加进来的数往上提</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> arr</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> index</span><span class="hljs-comment"> * arr[index] &gt; arr[(index - 1) / 2]已经包含两个条件</span><span class="hljs-comment"> * 1)arr[index] 不比arr[index父]大, 停</span><span class="hljs-comment"> * 2)index = 0, 停</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">heapInsert</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> index)</span></span>&#123;    <span class="hljs-keyword">while</span> (arr[index] &gt; arr[(index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>])&#123;        swap(arr, index, (index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>);        index = (index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;    &#125;&#125;</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201201133318.png" alt="heapInsert"></p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 删除堆的最大值并返回, 重组堆</span><span class="hljs-comment"> * 用最后的值去顶替arr[0]</span><span class="hljs-comment"> * 再往下交换, 找到左孩子与右孩子之间更大的数, 如果更小, 则交换</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> ans = heap[<span class="hljs-number">0</span>];    <span class="hljs-comment">// -- heapSize, 之后的数据进入无效区</span>    swap(heap, <span class="hljs-number">0</span>, -- heapSize);    heapify(heap, <span class="hljs-number">0</span>, heapSize);    <span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-comment">// 从index的位置往下看, 不断的下沉</span><span class="hljs-comment">// 1) 孩子都不比我大 停; 2) 已经没孩子了, 停</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">heapify</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> heapSize)</span></span>&#123;    <span class="hljs-keyword">int</span> left = index * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;    <span class="hljs-comment">// 左孩子不越界就肯定有孩子</span>    <span class="hljs-keyword">while</span> (left &lt; heapSize)&#123;        <span class="hljs-comment">// 再判断有没有右孩子</span>        <span class="hljs-comment">// 右孩子更大的条件是: 有右孩子 &amp;&amp; 右孩子大于左孩子</span>        <span class="hljs-keyword">int</span> largest = left + <span class="hljs-number">1</span> &lt; heapSize &amp;&amp; arr[left + <span class="hljs-number">1</span>] &gt; arr[left] ? left + <span class="hljs-number">1</span> : left;        largest = arr[largest] &gt; arr[index] ? largest : index;        <span class="hljs-comment">// 如果index更大, 则不用下坠</span>        <span class="hljs-keyword">if</span> (largest == index)&#123;            <span class="hljs-keyword">break</span>;        &#125;        swap(arr, index, largest);        index = largest;        left = index * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;    &#125;&#125;</code></pre><p>5）堆结构的增大和减少<br>6）优先级队列结构，就是堆结构(小根堆)</p><pre><code class="hljs java">PriorityQueue&lt;Integer&gt; heap = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;(<span class="hljs-keyword">new</span> MyComp());</code></pre><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><blockquote><p>先把数组数据变为大根堆结构, 再每次arr[0]与堆最后一个结点互换, 必定会把Max丢到最后, 再heapify</p></blockquote><pre><code class="hljs java"><span class="hljs-comment">// 堆排序额外空间复杂度O(1)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">heapSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;        <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length &lt; <span class="hljs-number">2</span>) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">// O(N*logN)</span><span class="hljs-comment">//    for (int i = 0; i &lt; arr.length; i++) &#123; // O(N)</span><span class="hljs-comment">//       heapInsert(arr, i); // O(logN)</span><span class="hljs-comment">//    &#125;</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = arr.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;            heapify(arr, i, arr.length);        &#125;        <span class="hljs-keyword">int</span> heapSize = arr.length;        swap(arr, <span class="hljs-number">0</span>, --heapSize);        <span class="hljs-comment">// O(N*logN)</span>        <span class="hljs-keyword">while</span> (heapSize &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// O(N)</span>            heapify(arr, <span class="hljs-number">0</span>, heapSize); <span class="hljs-comment">// O(logN)</span>            swap(arr, <span class="hljs-number">0</span>, --heapSize); <span class="hljs-comment">// O(1)</span>        &#125;    &#125;    <span class="hljs-comment">// arr[index]刚来的数，往上</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">heapInsert</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> index)</span> </span>&#123;        <span class="hljs-keyword">while</span> (arr[index] &gt; arr[(index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>]) &#123;            swap(arr, index, (index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>);            index = (index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;        &#125;    &#125;    <span class="hljs-comment">// arr[index]位置的数，能否往下移动</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">heapify</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> heapSize)</span> </span>&#123;        <span class="hljs-keyword">int</span> left = index * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>; <span class="hljs-comment">// 左孩子的下标</span>        <span class="hljs-keyword">while</span> (left &lt; heapSize) &#123; <span class="hljs-comment">// 下方还有孩子的时候</span>            <span class="hljs-comment">// 两个孩子中，谁的值大，把下标给largest</span>            <span class="hljs-comment">// 1）只有左孩子，left -&gt; largest</span>            <span class="hljs-comment">// 2) 同时有左孩子和右孩子，右孩子的值&lt;= 左孩子的值，left -&gt; largest</span>            <span class="hljs-comment">// 3) 同时有左孩子和右孩子并且右孩子的值&gt; 左孩子的值， right -&gt; largest</span>            <span class="hljs-keyword">int</span> largest = left + <span class="hljs-number">1</span> &lt; heapSize &amp;&amp; arr[left + <span class="hljs-number">1</span>] &gt; arr[left] ? left + <span class="hljs-number">1</span> : left;            <span class="hljs-comment">// 父和较大的孩子之间，谁的值大，把下标给largest</span>            largest = arr[largest] &gt; arr[index] ? largest : index;            <span class="hljs-keyword">if</span> (largest == index) &#123;                <span class="hljs-keyword">break</span>;            &#125;            swap(arr, largest, index);            index = largest;            left = index * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;        &#125;    &#125;</code></pre><pre><code class="hljs mathematica"><span class="hljs-number">1</span>，先让整个数组都变成大根堆结构，建立堆的过程<span class="hljs-operator">:</span>     <span class="hljs-number">1</span><span class="hljs-punctuation">)</span>从上到下的方法，时间复杂度为<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-operator">*</span><span class="hljs-variable">logN</span><span class="hljs-punctuation">)</span>     <span class="hljs-number">2</span><span class="hljs-punctuation">)</span>从下到上的方法，时间复杂度为<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-punctuation">)</span> <span class="hljs-number">2</span>，把堆的最大值和堆末尾的值交换，然后减少堆的大小之后，再去调整堆，一直周而复始，时间复杂度为<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-operator">*</span><span class="hljs-variable">logN</span><span class="hljs-punctuation">)</span> <span class="hljs-number">3</span>，堆的大小减小成<span class="hljs-number">0</span>之后，排序完成</code></pre><blockquote><p>堆排序优化</p></blockquote><pre><code class="hljs java"><span class="hljs-comment">// O(N*logN)</span><span class="hljs-comment">// 给定数据的数组,一个一个插入都可以</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123; <span class="hljs-comment">// O(N)</span>   heapInsert(arr, i); <span class="hljs-comment">// O(logN)</span>&#125;      <span class="hljs-comment">// O(N)</span><span class="hljs-comment">// 一定要给定数据数组, 一个一个插入无法使用</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = arr.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;   heapify(arr, i, arr.length);&#125;</code></pre><p>一个O(N*logN), 一个O(N)</p><p>怎么证明?</p><p>对于从数组最后开始heapify来说, 一颗N结点的树, 最后一层结点应该为N/2, 往上依次为N/4, N/8</p><p>最后一层只有”看”的操作, 倒数第二层有”看”和至多一次”换”的操作, 倒数第三层有”看”和至多两次”换”的操作</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201201135242.png" alt="堆排序优化"></p><h2 id="堆问题"><a href="#堆问题" class="headerlink" title="堆问题"></a>堆问题</h2><blockquote><p>已知一个几乎有序的数组。几乎有序是指，如果把数组排好顺序的话，每个元素移动的距离一定不超过k，并且k相对于数组长度来说是比较小的。<br>请选择一个合适的排序策略，对这个数组进行排序。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/11/19/hello-world/"/>
    <url>/2020/11/19/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="hljs bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="hljs bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="hljs bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Spring Cloud 学习笔记</title>
    <link href="/2020/11/18/Spring%20Cloud%20%E5%AD%A6%E4%B9%A0/"/>
    <url>/2020/11/18/Spring%20Cloud%20%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring-Cloud-初识"><a href="#Spring-Cloud-初识" class="headerlink" title="Spring Cloud 初识"></a>Spring Cloud 初识</h1><h2 id="谈谈微服务"><a href="#谈谈微服务" class="headerlink" title="谈谈微服务"></a>谈谈微服务</h2><blockquote><p>微服务是什么？</p></blockquote><h3 id="1、单体阶段"><a href="#1、单体阶段" class="headerlink" title="1、单体阶段"></a>1、单体阶段</h3><blockquote><p>下列开篇引用自 <a href="https://www.jianshu.com/p/7293b148028f">简书</a></p></blockquote><p>​    相对的，要理解什么是<strong>微服务</strong>，那么可以先理解什么是<strong>单体应用</strong>，在没有提出微服务的概念的“远古”年代，一个软件应用，往往会将应用所有功能都开发和打包在一起，那时候的一个B/S应用架构往往是这样的：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/imgimage-20201119161928480.png" alt="B/S"></p><p>但是，当用户访问量变大导致一台服务器无法支撑时怎么办呢？加服务器加负载均衡，架构就变成这样了：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/imgimage-20201119161940457.png" alt="B/S+负载均衡"></p><p>后面发现把静态文件独立出来，通过CDN等手段进行加速，可以提升应用的整体相应，单体应用的架构就变成：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/imgimage-20201119161950668.png" alt="B/S+前后端分离"></p><p>上面3中架构都还是单体应用，只是在<strong>部署方面</strong>进行了优化，所以避免不了单体应用的根本的缺点：</p><ul><li><p>代码<strong>臃肿</strong>，应用启动时间长；（代码超过1G的项目都有！）</p></li><li><p>回归<strong>测试周期长</strong>，修复一个小小bug可能都需要对所有关键业务进行回归测试。</p></li><li><p>应用<strong>容错性差</strong>，某个小小功能的程序错误可能导致整个系统宕机；</p></li><li><p>伸缩困难，单体应用扩展性能时只能整个应用进行扩展，造成计算资源浪费。</p></li><li><p>开发协作困难，一个大型应用系统，可能几十个甚至上百个开发人员，大家都在维护一套代码的话，代码merge复杂度急剧增加。</p></li></ul><h3 id="2、微服务阶段"><a href="#2、微服务阶段" class="headerlink" title="2、微服务阶段"></a>2、微服务阶段</h3><blockquote><p>微服务的出现就是因为原来单体应用架构已经无法满足当前互联网产品的技术需求。</p></blockquote><p>什么样的服务才算微服务呢？</p><ul><li><p><strong>单一职责的</strong>。一个微服务应该都是单一职责的，这才是“微”的体现，一个微服务解决一个业务问题（注意是一个业务问题而不是一个接口）。</p></li><li><p><strong>面向服务的</strong>。将自己的业务能力封装并对外提供服务，这是继承SOA的核心思想，一个微服务本身也可能使用到其它微服务的能力。<br> <strong>我觉得满足以上两点就可以认为典型的微服务。</strong></p></li></ul><h3 id="3、微服务典型架构"><a href="#3、微服务典型架构" class="headerlink" title="3、微服务典型架构"></a>3、微服务典型架构</h3><blockquote><p>微服务架构，核心是为了解决应用微服务化之后的服务治理问题。</p></blockquote><p>​    应用微服务化之后，首先遇到的第一个问题就是<strong>服务发现问题</strong>，一个微服务如何发现其他微服务呢？最简单的方式就是每个微服务里面配置其他微服务的地址，但是当微服务数量众多的时候，这样做明显不现实。所以需要使用到微服务架构中的一个最重要的组件：<strong>服务注册中心</strong>，所有服务都注册到<strong>服务注册中心</strong>，同时也可以从服务注册中心获取当前可用的服务清单：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/imgimage-20201119161902129.png" alt="服务注册中心"></p><p>​    解决服务发现问题后，接着需要解决微服务分布式部署带来的第二个问题：<strong>服务配置管理的问题</strong>。当服务数量超过一定程度之后，如果需要在每个服务里面分别维护每一个服务的配置文件，运维人员估计要哭了。那么，就需要用到微服务架构里面第二个重要的组件：<strong>配置中心</strong>，微服务架构就变成下面这样了：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/imgimage-20201119162034804.png" alt="配置中心"></p><p>​    以上应用内部的服务治理，当<strong>客户端或外部应用调用服务</strong>的时候怎么处理呢？服务A可能有多个节点，服务A、服务B和服务C的服务地址都不同，服务授权验证在哪里做？这时，就需要使用到<strong>服务网关</strong>提供统一的服务入口，最终形成典型微服务架构：</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/imgimage-20201119162157483.png" alt="典型微服务架构"></p><p>​    上面是一个典型的微服务架构，当然微服务的服务治理还涉及很多内容，比如：</p><ul><li>通过熔断、限流等机制保证高可用；</li><li>微服务之间调用的负载均衡；</li><li>分布式事务（2PC、3PC、TCC、LCN等）；</li><li>服务调用链跟踪等等。</li></ul><h2 id="Spring-Cloud-gt-微服务框架"><a href="#Spring-Cloud-gt-微服务框架" class="headerlink" title="Spring Cloud -&gt; 微服务框架"></a>Spring Cloud -&gt; 微服务框架</h2><blockquote><p>由此，Spring Cloud=分布式微服务架构的一站式解决方案，是多种微服务架构落地技术的集合体，俗称微服务全家桶。</p></blockquote><p><strong>“COORDINATE ANYTHING:DISTRIBUTED SYSTEMS SIMPLIFIED”</strong></p><pre><code> `Spring Cloud` 就是微服务系统架构的一站式解决方案，在平时我们构建微服务的过程中需要做如 **服务发现注册** 、**配置中心** 、**消息总线** 、**负载均衡** 、**断路器** 、**数据监控** 等操作，而 Spring Cloud 为我们提供了一套简易的编程模型，使我们能在 Spring Boot 的基础上轻松地实现微服务项目的构建。</code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/imgimage-20201119163743535.png" alt="spring cloud 蕴含技术栈"></p><h3 id="1、Spring-Cloud版本选型"><a href="#1、Spring-Cloud版本选型" class="headerlink" title="1、Spring Cloud版本选型"></a>1、Spring Cloud版本选型</h3><blockquote><p>SpringCloud采用了英国伦敦地铁站的名称来命名, 并由地铁站名称字母A-Z依次类推的形式来发布迭代版本。</p></blockquote><p>​    SpringCloud是一个由许多子项目组成的综合项目, 各子项目有不同的发布节奏, 为了管理SpringCloud与各个子项目的版本依赖关系, 发布了一个清单, 其中包括了某个SpringCloud版本对应的子项目版本. 为了避免SpringCloud版本号与子项目版本号混淆, <strong>SpringCloud版本采用了名称而非版本号的命名, 这些版本的名字采用了伦敦地铁站的名字, 根据字母表的顺序来对应版本时间顺序</strong>. 例如Angel是第一个版本, Brixton是第二个版本. 当SpringCloud的发布内容积累到临界点或者一个重大BUG被解决后, 会发布一个”service releases”版本, 简称SRX版本, 比如Greenwich.SR2就是SpringCloud发布的Greenwich版本的第二个SRX版本.</p><table><thead><tr><th align="left">Release Train</th><th align="left">Boot Version</th></tr></thead><tbody><tr><td align="left">2020.0.x aka Ilford</td><td align="left">2.4.x</td></tr><tr><td align="left"><a href="https://github.com/spring-projects/spring-cloud/wiki/Spring-Cloud-Hoxton-Release-Notes">Hoxton</a></td><td align="left">2.2.x, 2.3.x (Starting with SR5)</td></tr><tr><td align="left"><a href="https://github.com/spring-projects/spring-cloud/wiki/Spring-Cloud-Greenwich-Release-Notes">Greenwich</a></td><td align="left">2.1.x</td></tr><tr><td align="left"><a href="https://github.com/spring-projects/spring-cloud/wiki/Spring-Cloud-Finchley-Release-Notes">Finchley</a></td><td align="left">2.0.x</td></tr><tr><td align="left"><a href="https://github.com/spring-projects/spring-cloud/wiki/Spring-Cloud-Edgware-Release-Notes">Edgware</a></td><td align="left">1.5.x</td></tr><tr><td align="left"><a href="https://github.com/spring-projects/spring-cloud/wiki/Spring-Cloud-Dalston-Release-Notes">Dalston</a></td><td align="left">1.5.x</td></tr></tbody></table><blockquote><p> [spring官网][<a href="https://spring.io/projects/spring-cloud]%E6%9F%A5%E7%9C%8B%E7%89%88%E6%9C%AC%E9%80%89%E5%9E%8B[json][https://start.spring.io/actuator/info]">https://spring.io/projects/spring-cloud]查看版本选型[json][https://start.spring.io/actuator/info]</a></p></blockquote><h3 id="2、学习技术选型"><a href="#2、学习技术选型" class="headerlink" title="2、学习技术选型"></a>2、学习技术选型</h3><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/imgimage-20201119170031804.png" alt="技术版本选择" style="zoom:33%;" /><h3 id="3、Spring-Cloud组件停更升级以及替换"><a href="#3、Spring-Cloud组件停更升级以及替换" class="headerlink" title="3、Spring Cloud组件停更升级以及替换"></a>3、Spring Cloud组件停更升级以及替换</h3><p>​    1,服务注册中心,Eureka停用,zookeeper, Consul, Cloud Alibaba Nacos</p><p>​    2,服务调用,Ribbon准备停更,代替为LoadBalance</p><p>​    3,服务调用2,Feign改为OpenFeign</p><p>​    4,服务降级,Hystrix停更,改为resilence4j,Cloud Alibaba sentienl</p><p>​    5.服务网关,Zuul改为gateway    </p><p>​    6,服务配置Config改为Cloud Alibaba Nacos</p><p>​    7,服务总线Bus改为Cloud Alibaba Nacos</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/imgimage-20201119172251583.png" alt="cloud 技术更新情况"></p><h3 id="4、学习文档"><a href="#4、学习文档" class="headerlink" title="4、学习文档"></a>4、学习文档</h3><blockquote><p><a href="https://cloud.spring.io/spring-cloud-static/Hoxton.SR1/reference/htmlsingle/">spring cloud</a>        <a href="https://www.bookstack.cn/read/spring-cloud-docs/docs-index.md">中文</a> HSR1.</p><p><a href="https://docs.spring.io/spring-boot/docs/2.2.2.RELEASE/reference/htmlsingle/">spring boot</a>        2.2.2.</p></blockquote><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="1、关于dependencyManagement"><a href="#1、关于dependencyManagement" class="headerlink" title="1、关于dependencyManagement"></a>1、关于dependencyManagement</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/imgimage-20201119183455723.png" alt="dependencyManagement详解"></p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/imgimage-20201119183718866.png" alt="maven跳过单元测试" style="zoom:67%;" /><h3 id="2、构建cloud-provider-payment8001工程实现微服务提供者"><a href="#2、构建cloud-provider-payment8001工程实现微服务提供者" class="headerlink" title="2、构建cloud-provider-payment8001工程实现微服务提供者"></a>2、构建cloud-provider-payment8001工程实现微服务提供者</h3><p>由于cloud学习, 对于Spring Boot操作不过多阐述.该Module中主要提供create和get方法操作</p><pre><code class="hljs java"><span class="hljs-meta">@NoArgsConstructor</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Payment</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;    <span class="hljs-keyword">private</span> Long id;    <span class="hljs-keyword">private</span> String serial;&#125;</code></pre><p>相应dao、service层不过多阐述.</p><p>controller层业务代码:</p><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-meta">@Slf4j</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PaymentController</span> </span>&#123;    <span class="hljs-meta">@Resource</span>    <span class="hljs-keyword">private</span> PaymentService paymentService;    <span class="hljs-meta">@PostMapping(value = &quot;/payment/create&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> CommonResult <span class="hljs-title">create</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> Payment payment)</span> </span>&#123;        <span class="hljs-keyword">int</span> resultRows = paymentService.create(payment);        log.info(<span class="hljs-string">&quot;******插入结果:&quot;</span> + resultRows);        <span class="hljs-keyword">if</span> (resultRows &gt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CommonResult(<span class="hljs-number">200</span>, <span class="hljs-string">&quot;插入数据库成功&quot;</span>, resultRows);        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CommonResult(<span class="hljs-number">444</span>, <span class="hljs-string">&quot;插入数据库失败&quot;</span>);        &#125;    &#125;    <span class="hljs-meta">@GetMapping(value = &quot;/payment/get/&#123;id&#125;&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> CommonResult <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Long id)</span> </span>&#123;        Payment payment = paymentService.getPaymentById(id);        log.info(<span class="hljs-string">&quot;******查询结果:&quot;</span> + payment);        <span class="hljs-keyword">if</span> (payment != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CommonResult(<span class="hljs-number">200</span>, <span class="hljs-string">&quot;查询数据库成功&quot;</span>, payment);        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CommonResult(<span class="hljs-number">444</span>, <span class="hljs-string">&quot;查询数据库失败&quot;</span> + id);        &#125;    &#125;&#125;</code></pre><h3 id="3、构建cloud-consumer-order80工程实现客户端消费者"><a href="#3、构建cloud-consumer-order80工程实现客户端消费者" class="headerlink" title="3、构建cloud-consumer-order80工程实现客户端消费者"></a>3、构建cloud-consumer-order80工程实现客户端消费者</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201121174959.png" alt="项目结构"></p><p>​    因为这里是消费者类, 主要是消费, 那么就没有service和dao, 需要调用pay模块的方法, 并且这里还没有微服务的远程调用, 那么如果要调用另外一个模块, 则需要使用基本的api调用.这里我们使用RestTemplate使得微服务消费者80调用微服务提供者8001.</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201121175514.png" alt="RestTemplate功能和使用"></p><p>对应注入:</p><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApplicationContextConfig</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> RestTemplate <span class="hljs-title">getRestTemplate</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RestTemplate();    &#125;&#125;</code></pre><p>controller层业务代码:</p><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-meta">@Slf4j</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderController</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String PAYMENT_URL = <span class="hljs-string">&quot;http://localhost:8001&quot;</span>;    <span class="hljs-meta">@Resource</span>    <span class="hljs-keyword">private</span> RestTemplate restTemplate;    <span class="hljs-meta">@GetMapping(&quot;/consumer/payment/create&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> CommonResult&lt;Payment&gt; <span class="hljs-title">create</span><span class="hljs-params">(Payment payment)</span></span>&#123;        <span class="hljs-keyword">return</span> restTemplate.postForObject(PAYMENT_URL + <span class="hljs-string">&quot;/payment/create&quot;</span>, payment, CommonResult.class);    &#125;    <span class="hljs-meta">@GetMapping(&quot;/consumer/payment/get/&#123;id&#125;&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> CommonResult&lt;Payment&gt; <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Long id)</span></span>&#123;        <span class="hljs-keyword">return</span> restTemplate.getForObject(PAYMENT_URL + <span class="hljs-string">&quot;/payment/get/&quot;</span> + id, CommonResult.class);    &#125;&#125;</code></pre><h3 id="4、entity实体类放入cloud-api-commons中"><a href="#4、entity实体类放入cloud-api-commons中" class="headerlink" title="4、entity实体类放入cloud-api-commons中"></a>4、entity实体类放入cloud-api-commons中</h3><p>其他工程加入即可</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.study.springcloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>cloud-api-commons<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;project.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><h1 id="服务注册与发现"><a href="#服务注册与发现" class="headerlink" title="服务注册与发现"></a>服务注册与发现</h1><h2 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h2><h3 id="1、Eureka基础知识"><a href="#1、Eureka基础知识" class="headerlink" title="1、Eureka基础知识"></a>1、Eureka基础知识</h3><p>​    前面我们没有服务注册中心, 也可以服务间调用,为什么还要服务注册?</p><p>​    当服务很多时, 单靠代码手动管理是很麻烦的, 需要一个公共组件, 统一管理多服务, 包括服务是否正常运行等.Eureka用于<strong>服务注册</strong>, 目前官网<strong>已经停止更新</strong>.</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201121194357.png" alt="什么是服务治理?"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201121194553.png" alt="什么是服务注册与发现"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201121195221.png" alt="Eureka两个组件"></p><h3 id="2、单机版Eureka构建"><a href="#2、单机版Eureka构建" class="headerlink" title="2、单机版Eureka构建"></a>2、单机版Eureka构建</h3><pre><code>#### a、 POM依赖</code></pre><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- eureka-server --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><h4 id="b、yaml配置"><a href="#b、yaml配置" class="headerlink" title="b、yaml配置"></a>b、yaml配置</h4><pre><code class="hljs yaml"><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">7001</span><span class="hljs-attr">eureka:</span>  <span class="hljs-attr">instance:</span>    <span class="hljs-attr">hostname:</span> <span class="hljs-string">localhost</span> <span class="hljs-comment">#eureka服务端的实例名称</span>  <span class="hljs-attr">client:</span>    <span class="hljs-comment">#false表示不向注册中心注册自己。</span>    <span class="hljs-attr">register-with-eureka:</span> <span class="hljs-literal">false</span>    <span class="hljs-comment">#false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务</span>    <span class="hljs-attr">fetch-registry:</span> <span class="hljs-literal">false</span>    <span class="hljs-attr">service-url:</span>      <span class="hljs-comment">#设置与Eureka Server交互的地址查询服务和注册服务都需要依赖这个地址。</span>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/</span></code></pre><h4 id="c、主启动类"><a href="#c、主启动类" class="headerlink" title="c、主启动类"></a>c、主启动类</h4><pre><code class="hljs java"><span class="hljs-meta">@EnableEurekaServer</span></code></pre><p>启动访问<a href="http://localhost:7001/">http://localhost:7001/</a></p><h4 id="d、服务入驻"><a href="#d、服务入驻" class="headerlink" title="d、服务入驻"></a>d、服务入驻</h4><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--eureka client--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>​    添加至cloud-provider-payment8001</p><p>修改yaml配置文件</p><pre><code class="hljs yaml"><span class="hljs-attr">eureka:</span>  <span class="hljs-attr">client:</span>    <span class="hljs-comment">#表示是否将自己注册进EurekaServer 默认为true</span>    <span class="hljs-attr">register-with-eureka:</span> <span class="hljs-literal">true</span>    <span class="hljs-comment">#是否从EurekaServer抓取已有的注册信息，默认为true。单节点无所谓，集群必须true才能配合ribbon负载均衡</span>    <span class="hljs-attr">fetch-registry:</span> <span class="hljs-literal">true</span>    <span class="hljs-attr">service-url:</span>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://localhost:7001/eureka</span></code></pre><p>主启动类添加</p><pre><code class="hljs java"><span class="hljs-meta">@EnableEurekaClient</span></code></pre><p>对于cloud-consumer-order80工程一样处理</p><h4 id="e、测试"><a href="#e、测试" class="headerlink" title="e、测试"></a>e、测试</h4><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201121202144.png" alt="测试"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201121202649.png" alt="测试"></p><blockquote><p>好家伙 我直接好家伙 已经开始卡了</p></blockquote><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201121203224.png" alt="内存占用"></p><h3 id="番外-“-eureka”到底是什么"><a href="#番外-“-eureka”到底是什么" class="headerlink" title="番外: “/eureka”到底是什么?"></a>番外: “/eureka”到底是什么?</h3><blockquote><p> 部署eureka集群时defaultZone中为什么必须包含路径/eureka？<a href="https://www.cnblogs.com/StarkBrothers/archive/2004/01/13/11974026.html">引用</a></p></blockquote><p>​    待深入了解中…..</p><h3 id="3、集群版Eureka构建"><a href="#3、集群版Eureka构建" class="headerlink" title="3、集群版Eureka构建"></a>3、集群版Eureka构建</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201121205728.png" alt="集群Eureka"></p><p>1,就是pay模块启动时,注册自己,并且自身信息也放入eureka<br>2.order模块,首先也注册自己,放入信息,当要调用pay时,先从eureka拿到pay的调用地址<br>3.通过HttpClient调用并且还会缓存一份到本地,每30秒更新一次 </p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201121210043.png" alt="题"></p><h4 id="A、注册原理"><a href="#A、注册原理" class="headerlink" title="A、注册原理"></a>A、注册原理</h4><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201121210334.png" alt="互相注册, 相互守望" style="zoom:67%;" /><h5 id="a、创建"><a href="#a、创建" class="headerlink" title="a、创建"></a>a、创建</h5><h5 id="b、POM引入-写YML"><a href="#b、POM引入-写YML" class="headerlink" title="b、POM引入 写YML"></a>b、POM引入 写YML</h5><p>7001改yaml:</p><pre><code class="hljs yaml"><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">7001</span><span class="hljs-attr">eureka:</span>  <span class="hljs-attr">instance:</span>    <span class="hljs-attr">hostname:</span> <span class="hljs-string">eureka7001.com</span> <span class="hljs-comment">#eureka服务端的实例名称</span>  <span class="hljs-attr">client:</span>    <span class="hljs-comment">#false表示不向注册中心注册自己。</span>    <span class="hljs-attr">register-with-eureka:</span> <span class="hljs-literal">false</span>    <span class="hljs-comment">#false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务</span>    <span class="hljs-attr">fetch-registry:</span> <span class="hljs-literal">false</span>    <span class="hljs-attr">service-url:</span>      <span class="hljs-comment">#设置与Eureka Server交互的地址查询服务和注册服务都需要依赖这个地址。</span>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://eureka7002.com:7002/eureka/</span></code></pre><p>7002:改yaml</p><pre><code class="hljs yaml"><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">7002</span><span class="hljs-attr">eureka:</span>  <span class="hljs-attr">instance:</span>    <span class="hljs-attr">hostname:</span> <span class="hljs-string">eureka7002.com</span> <span class="hljs-comment">#eureka服务端的实例名称</span>  <span class="hljs-attr">client:</span>    <span class="hljs-comment">#false表示不向注册中心注册自己。</span>    <span class="hljs-attr">register-with-eureka:</span> <span class="hljs-literal">false</span>    <span class="hljs-comment">#false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务</span>    <span class="hljs-attr">fetch-registry:</span> <span class="hljs-literal">false</span>    <span class="hljs-attr">service-url:</span>      <span class="hljs-comment">#设置与Eureka Server交互的地址查询服务和注册服务都需要依赖这个地址。</span>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://eureka7001.com:7001/eureka/</span></code></pre><h5 id="c、修改Hosts配置文件模拟集群"><a href="#c、修改Hosts配置文件模拟集群" class="headerlink" title="c、修改Hosts配置文件模拟集群"></a>c、修改Hosts配置文件模拟集群</h5><p>sudo vim /etc/hosts</p><p>#eureka<br>127.0.0.1       eureka7001.com<br>127.0.0.1       eureka7002.com</p><h5 id="d、写主启动类"><a href="#d、写主启动类" class="headerlink" title="d、写主启动类"></a>d、写主启动类</h5><h5 id="e、测试-1"><a href="#e、测试-1" class="headerlink" title="e、测试"></a>e、测试</h5><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201121212034.png" alt="测试成功" style="zoom: 50%;" /><h4 id="B、订单支付微服务入驻Eureka集群"><a href="#B、订单支付微服务入驻Eureka集群" class="headerlink" title="B、订单支付微服务入驻Eureka集群"></a>B、订单支付微服务入驻Eureka集群</h4><pre><code class="hljs yaml"><span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka</span> <span class="hljs-comment">#集群版</span></code></pre><p>修改yaml文件即可, 测试:</p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201121212825.png" alt="test" style="zoom: 33%;" /><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201121212948.png" alt="服务无影响" style="zoom:33%;" /><h3 id="4、将支付微服务集群配置"><a href="#4、将支付微服务集群配置" class="headerlink" title="4、将支付微服务集群配置"></a>4、将支付微服务集群配置</h3><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201121220116.png" alt="集群图" style="zoom: 25%;" /><h4 id="a、复制粘贴8001，改端口"><a href="#a、复制粘贴8001，改端口" class="headerlink" title="a、复制粘贴8001，改端口"></a>a、复制粘贴8001，改端口</h4><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201121214455.png" alt="eureka显示"></p><h4 id="b、修改80消费者controller调用时候的url"><a href="#b、修改80消费者controller调用时候的url" class="headerlink" title="b、修改80消费者controller调用时候的url"></a>b、修改80消费者controller调用时候的url</h4><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-meta">@Slf4j</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderController</span> </span>&#123;    <span class="hljs-comment">// private static final String PAYMENT_URL = &quot;http://localhost:8001&quot;;</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String PAYMENT_URL = <span class="hljs-string">&quot;http://CLOUD-PAYMENT-SERVICE&quot;</span>;    <span class="hljs-meta">@Resource</span>    <span class="hljs-keyword">private</span> RestTemplate restTemplate;    <span class="hljs-meta">@GetMapping(&quot;/consumer/payment/create&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> CommonResult&lt;Payment&gt; <span class="hljs-title">create</span><span class="hljs-params">(Payment payment)</span></span>&#123;        <span class="hljs-keyword">return</span> restTemplate.postForObject(PAYMENT_URL + <span class="hljs-string">&quot;/payment/create&quot;</span>, payment, CommonResult.class);    &#125;    <span class="hljs-meta">@GetMapping(&quot;/consumer/payment/get/&#123;id&#125;&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> CommonResult&lt;Payment&gt; <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Long id)</span></span>&#123;        <span class="hljs-keyword">return</span> restTemplate.getForObject(PAYMENT_URL + <span class="hljs-string">&quot;/payment/get/&quot;</span> + id, CommonResult.class);    &#125;&#125;</code></pre><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201121214634.png" alt="8001与8002服务均启动" style="zoom:50%;" /><h4 id="c、开启负载均衡注解"><a href="#c、开启负载均衡注解" class="headerlink" title="c、开启负载均衡注解"></a>c、开启负载均衡注解</h4><p>需要让RestTemplate开启负载均衡注解, 还可以指定负载均衡算法, 默认<strong>轮询</strong>, 各自一次</p><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApplicationContextConfig</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-meta">@LoadBalanced</span> <span class="hljs-comment">// 负载均衡</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> RestTemplate <span class="hljs-title">getRestTemplate</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RestTemplate();    &#125;&#125;</code></pre><h4 id="d、修改服务主机名和ip在eureka的web上显示"><a href="#d、修改服务主机名和ip在eureka的web上显示" class="headerlink" title="d、修改服务主机名和ip在eureka的web上显示"></a>d、修改服务主机名和ip在eureka的web上显示</h4><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201121221649.png" alt="yaml"></p><h3 id="5、服务发现Discovery"><a href="#5、服务发现Discovery" class="headerlink" title="5、服务发现Discovery"></a>5、服务发现Discovery</h3><p>对于注册进Eureka里的微服务, 可以通过服务发现来获得该服务的信息</p><p>以Payment8001为模版:</p><h4 id="a、修改cloud-provider-payment8001的Controller"><a href="#a、修改cloud-provider-payment8001的Controller" class="headerlink" title="a、修改cloud-provider-payment8001的Controller"></a>a、修改cloud-provider-payment8001的Controller</h4><pre><code class="hljs java"><span class="hljs-meta">@Resource</span><span class="hljs-keyword">private</span> DiscoveryClient discoveryClient;</code></pre><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(value = &quot;/payment/discovery&quot;)</span><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">discovery</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// 得到服务信息</span>    List&lt;String&gt; services = discoveryClient.getServices();    <span class="hljs-keyword">for</span> (String service : services) &#123;        log.info(<span class="hljs-string">&quot;*****element:&quot;</span>+service);    &#125;    List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances(<span class="hljs-string">&quot;cloud-payment-service&quot;</span>);    <span class="hljs-keyword">for</span> (ServiceInstance instance : instances) &#123;        log.info(<span class="hljs-string">&quot;*****id:&quot;</span>+instance.getServiceId());        log.info(<span class="hljs-string">&quot;*****host:&quot;</span>+instance.getHost());        log.info(<span class="hljs-string">&quot;*****port:&quot;</span>+instance.getPort());        log.info(<span class="hljs-string">&quot;*****uri:&quot;</span>+instance.getUri());    &#125;        <span class="hljs-keyword">return</span> discoveryClient;</code></pre><h4 id="b、-修改主启动类"><a href="#b、-修改主启动类" class="headerlink" title="b、 修改主启动类"></a>b、 修改主启动类</h4><pre><code class="hljs java"><span class="hljs-meta">@EnableDiscoveryClient</span></code></pre><h4 id="c、测试"><a href="#c、测试" class="headerlink" title="c、测试"></a>c、测试</h4><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201121222843.png" alt="test" style="zoom: 50%;" /><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201121223049.png" alt="log" style="zoom: 50%;" /><h3 id="6、Eureka自我保护"><a href="#6、Eureka自我保护" class="headerlink" title="6、Eureka自我保护"></a>6、Eureka自我保护</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201121223452.png" alt="eureka提示"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201121224343.png" alt="保护概念"></p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201123140710.png" alt="心跳包" style="zoom:67%;" /><h3 id="7、Eureka自我保护关闭"><a href="#7、Eureka自我保护关闭" class="headerlink" title="7、Eureka自我保护关闭"></a>7、Eureka自我保护关闭</h3><blockquote><p>一般生产环境中不会禁止自我保护</p></blockquote><pre><code class="hljs yaml"><span class="hljs-comment"># 服务端配置</span><span class="hljs-attr">eureka:</span>   <span class="hljs-attr">server:</span>    <span class="hljs-comment"># 关闭自我保护 </span>    <span class="hljs-attr">enable-self-preservation:</span> <span class="hljs-literal">false</span>    <span class="hljs-comment"># 接受心跳包时间间隔</span>    <span class="hljs-attr">eviction-interval-timer-in-ms:</span> <span class="hljs-number">2000</span></code></pre><pre><code class="hljs yaml"><span class="hljs-comment"># 客户端配置</span><span class="hljs-comment"># 心跳检测和续约时间</span><span class="hljs-attr">instance:</span>  <span class="hljs-comment"># Eureka客户端向服务端发送心跳的时间间隔, 单位为秒(默认30s)</span>  <span class="hljs-attr">lease-renewal-interval-in-seconds:</span> <span class="hljs-number">30</span>  <span class="hljs-comment"># Eureka服务端收到最后一次心跳等待服务时间上限, 默认90s, 超时则剔除服务</span>  <span class="hljs-attr">lease-expiration-duration-in-seconds:</span> <span class="hljs-number">90</span></code></pre><h3 id="8、Eureka停更"><a href="#8、Eureka停更" class="headerlink" title="8、Eureka停更"></a>8、Eureka停更</h3><blockquote><p><a href="https://github.com/Netflix/eureka/wiki">官网</a></p></blockquote><h2 id="Zookeeper-替换Eureka-服务注册与发现"><a href="#Zookeeper-替换Eureka-服务注册与发现" class="headerlink" title="Zookeeper(替换Eureka) 服务注册与发现"></a>Zookeeper(替换Eureka) 服务注册与发现</h2><blockquote><p>zookeeper是一个分布式协调工具，可以实现注册中心功能</p></blockquote><h3 id="1、-安装zookeeper-cloud-provider-payment8004入驻"><a href="#1、-安装zookeeper-cloud-provider-payment8004入驻" class="headerlink" title="1、 安装zookeeper(cloud-provider-payment8004入驻)"></a>1、 安装zookeeper(cloud-provider-payment8004入驻)</h3><h4 id="a、在aliyun服务器安装zookeeper并关闭防火墙（aliyun开了kafka-2181被kafka自己的zookeeper占用-改用自己mac开启zookeeper）"><a href="#a、在aliyun服务器安装zookeeper并关闭防火墙（aliyun开了kafka-2181被kafka自己的zookeeper占用-改用自己mac开启zookeeper）" class="headerlink" title="a、在aliyun服务器安装zookeeper并关闭防火墙（aliyun开了kafka 2181被kafka自己的zookeeper占用 改用自己mac开启zookeeper）"></a>a、在aliyun服务器安装zookeeper并关闭防火墙（aliyun开了kafka 2181被kafka自己的zookeeper占用 改用自己mac开启zookeeper）</h4><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201123143814.png" alt="服务器" style="zoom:50%;" /><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201123152949.png" alt="mymac" style="zoom:50%;" /><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201123153358.png" alt="进入zkCli" style="zoom:50%;" /><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201123153134.png" alt="防火墙关闭" style="zoom:50%;" /><blockquote><p>ifconfig | grep “inet “ | grep -v 127.0.0.1 mac查看自己ip </p></blockquote><h4 id="b、构建cloud-provider-payment8004工程"><a href="#b、构建cloud-provider-payment8004工程" class="headerlink" title="b、构建cloud-provider-payment8004工程"></a>b、构建cloud-provider-payment8004工程</h4><p>POM.xml:</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-zookeeper-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>yaml:</p><pre><code class="hljs yaml"><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">8004</span><span class="hljs-attr">spring:</span>  <span class="hljs-attr">application:</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">cloud-payment-service</span>  <span class="hljs-attr">cloud:</span>    <span class="hljs-attr">zookeeper:</span>      <span class="hljs-attr">connect-string:</span> <span class="hljs-number">101.37</span><span class="hljs-number">.162</span><span class="hljs-number">.1</span><span class="hljs-string">:2181</span></code></pre><p>主启动类:</p><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-meta">@EnableDiscoveryClient</span> <span class="hljs-comment">// 该注解用于向consul或者zookeeper作为注册中心时注册服务</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PaymentMain8004</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(PaymentMain8004.class, args);    &#125;&#125;</code></pre><p>Controller:</p><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-meta">@Slf4j</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PaymentController</span> </span>&#123;    <span class="hljs-meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span>    <span class="hljs-keyword">private</span> String serverPort;    <span class="hljs-meta">@RequestMapping(value = &quot;/payment/zk&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">zk</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;zookeeper:&quot;</span> + serverPort + UUID.randomUUID().toString();    &#125;&#125;</code></pre><p>修改pom:</p><blockquote><p>解决jar包不一致问题</p></blockquote><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--SpringBoot整合Zookeeper客户端--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-zookeeper-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span>        <span class="hljs-comment">&lt;!--先排除自带的zookeeper3.5.3--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.zookeeper<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>zookeeper<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!--添加zookeeper3.4.14版本--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.zookeeper<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>zookeeper<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.4.14<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201123153935.png" alt="测试结果"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201123154156.png" alt="zookeeper前后变化"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201123154124.png" alt="客户端访问结果"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201123154249.png" alt="结果"></p><h3 id="2、思考"><a href="#2、思考" class="headerlink" title="2、思考"></a>2、思考</h3><p>我们把Zookeeper ls到底并get</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201123154610.png" alt="疑问"></p><p>得到一份json字符串并解析:</p><pre><code class="hljs json">&#123;  <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;cloud-payment-service&quot;</span>,  <span class="hljs-attr">&quot;id&quot;</span>: <span class="hljs-string">&quot;ccf0aff6-d8d8-4730-acca-b035c7b424a4&quot;</span>,  <span class="hljs-attr">&quot;address&quot;</span>: <span class="hljs-string">&quot;10.240.8.173&quot;</span>,  <span class="hljs-attr">&quot;port&quot;</span>: <span class="hljs-number">8004</span>,  <span class="hljs-attr">&quot;sslPort&quot;</span>: <span class="hljs-literal">null</span>,  <span class="hljs-attr">&quot;payload&quot;</span>: &#123;    <span class="hljs-attr">&quot;@class&quot;</span>: <span class="hljs-string">&quot;org.springframework.cloud.zookeeper.discovery.ZookeeperInstance&quot;</span>,    <span class="hljs-attr">&quot;id&quot;</span>: <span class="hljs-string">&quot;application-1&quot;</span>,    <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;cloud-payment-service&quot;</span>,    <span class="hljs-attr">&quot;metadata&quot;</span>: &#123;&#125;  &#125;,  <span class="hljs-attr">&quot;registrationTimeUTC&quot;</span>: <span class="hljs-number">1606116992809</span>,  <span class="hljs-attr">&quot;serviceType&quot;</span>: <span class="hljs-string">&quot;DYNAMIC&quot;</span>,  <span class="hljs-attr">&quot;uriSpec&quot;</span>: &#123;    <span class="hljs-attr">&quot;parts&quot;</span>: [      &#123;        <span class="hljs-attr">&quot;value&quot;</span>: <span class="hljs-string">&quot;scheme&quot;</span>,        <span class="hljs-attr">&quot;variable&quot;</span>: <span class="hljs-literal">true</span>      &#125;,      &#123;        <span class="hljs-attr">&quot;value&quot;</span>: <span class="hljs-string">&quot;://&quot;</span>,        <span class="hljs-attr">&quot;variable&quot;</span>: <span class="hljs-literal">false</span>      &#125;,      &#123;        <span class="hljs-attr">&quot;value&quot;</span>: <span class="hljs-string">&quot;address&quot;</span>,        <span class="hljs-attr">&quot;variable&quot;</span>: <span class="hljs-literal">true</span>      &#125;,      &#123;        <span class="hljs-attr">&quot;value&quot;</span>: <span class="hljs-string">&quot;:&quot;</span>,        <span class="hljs-attr">&quot;variable&quot;</span>: <span class="hljs-literal">false</span>      &#125;,      &#123;        <span class="hljs-attr">&quot;value&quot;</span>: <span class="hljs-string">&quot;port&quot;</span>,        <span class="hljs-attr">&quot;variable&quot;</span>: <span class="hljs-literal">true</span>      &#125;    ]  &#125;&#125;</code></pre><h4 id="a、是临时节点还是持久节点"><a href="#a、是临时节点还是持久节点" class="headerlink" title="a、是临时节点还是持久节点?"></a>a、是临时节点还是持久节点?</h4><blockquote><p>我们在zk上注册的node是临时节点, 当我们的服务一定时间内没有发送心跳, 那么zk就会将这个服务的node删除(只需停掉8004 再查看zk结点)</p></blockquote><h3 id="3、cloud-consumerzk-order80-入驻-zookeeper"><a href="#3、cloud-consumerzk-order80-入驻-zookeeper" class="headerlink" title="3、cloud-consumerzk-order80 入驻 zookeeper"></a>3、cloud-consumerzk-order80 入驻 zookeeper</h3><h4 id="a、构建cloud-consumerzk-order80工程"><a href="#a、构建cloud-consumerzk-order80工程" class="headerlink" title="a、构建cloud-consumerzk-order80工程"></a>a、构建cloud-consumerzk-order80工程</h4><p>POM.xml:如cloud-provider-payment8004一致</p><p>yaml:</p><pre><code class="hljs yaml"><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">80</span><span class="hljs-attr">spring:</span>  <span class="hljs-attr">application:</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">cloud-orderzk-service</span>  <span class="hljs-attr">cloud:</span>    <span class="hljs-attr">zookeeper:</span>      <span class="hljs-attr">connect-string:</span> <span class="hljs-number">10.240</span><span class="hljs-number">.8</span><span class="hljs-number">.173</span><span class="hljs-string">:2181</span></code></pre><p>controller:</p><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderController</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String PAYMENT_URL = <span class="hljs-string">&quot;http://cloud-payment-service&quot;</span>;    <span class="hljs-meta">@Resource</span>    <span class="hljs-keyword">private</span> RestTemplate restTemplate;    <span class="hljs-meta">@GetMapping(&quot;/consumer/payment/zk&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">zk</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> restTemplate.getForObject(PAYMENT_URL + <span class="hljs-string">&quot;/payment/zk&quot;</span>, String.class);    &#125;&#125;</code></pre><h4 id="b、测试"><a href="#b、测试" class="headerlink" title="b、测试"></a>b、测试</h4><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201123161555.png" alt="成功"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201123161638.png" alt="zk"></p><h2 id="Consul"><a href="#Consul" class="headerlink" title="Consul"></a>Consul</h2><blockquote><p>Go语言开发 <a href="https://www.consul.io/intro/index.html">官网</a></p></blockquote><h3 id="1、Consul简介"><a href="#1、Consul简介" class="headerlink" title="1、Consul简介:"></a>1、Consul简介:</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201123162351.png" alt="简介"></p><blockquote><p>Consul能干嘛? <a href="https://www.consul.io/downloads.html">去哪下</a> <a href="https://www.springcloud.cc/spring-cloud-consul.html">怎么玩</a></p></blockquote><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201123162747.png" alt="用途"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201123162632.png" alt="用途"></p><h3 id="2、安装运行"><a href="#2、安装运行" class="headerlink" title="2、安装运行"></a>2、安装运行</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201123171136.png" alt="consul"></p><p>把consul文件复制到/usr/local/bin目录下.</p><blockquote><p>consul agent -dev启用 / Ctrl-C（中断信号）正常停止代理</p></blockquote><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201123171658.png" alt="8500端口"></p><h3 id="3、新建Module支付服务cloud-providerconsul-payment8006"><a href="#3、新建Module支付服务cloud-providerconsul-payment8006" class="headerlink" title="3、新建Module支付服务cloud-providerconsul-payment8006"></a>3、新建Module支付服务cloud-providerconsul-payment8006</h3><p>Pom.xml:</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--SpringCloud consul-server--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-consul-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>yaml:</p><pre><code class="hljs yaml"><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">8006</span><span class="hljs-attr">spring:</span>  <span class="hljs-attr">application:</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">cloud-payment-service</span>  <span class="hljs-attr">cloud:</span>    <span class="hljs-attr">consul:</span>      <span class="hljs-attr">host:</span> <span class="hljs-string">localhost</span>      <span class="hljs-attr">port:</span> <span class="hljs-number">8500</span>      <span class="hljs-attr">discovery:</span>        <span class="hljs-comment">#hostname: 127.0.0.1</span>        <span class="hljs-attr">service-name:</span> <span class="hljs-string">$&#123;spring.application.name&#125;</span></code></pre><p>Controller:</p><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-meta">@Slf4j</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PaymentController</span> </span>&#123;    <span class="hljs-meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span>    <span class="hljs-keyword">private</span> String serverPort;    <span class="hljs-meta">@RequestMapping(value = &quot;/payment/consul&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">consul</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;consul:&quot;</span> + serverPort + UUID.randomUUID().toString();    &#125;&#125;</code></pre><p>测试:</p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201123191757.png" alt="测试" style="zoom:50%;" /><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201123192023.png" alt="test"></p><h3 id="4、新建Module消费服务cloud-consumerconsul-order80"><a href="#4、新建Module消费服务cloud-consumerconsul-order80" class="headerlink" title="4、新建Module消费服务cloud-consumerconsul-order80"></a>4、新建Module消费服务cloud-consumerconsul-order80</h3><p>​   pom与8006一致</p><p>​   yml:</p><pre><code class="hljs yaml"><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">80</span><span class="hljs-attr">spring:</span>  <span class="hljs-attr">application:</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">cloud-order-service</span>  <span class="hljs-attr">cloud:</span>    <span class="hljs-attr">consul:</span>      <span class="hljs-attr">host:</span> <span class="hljs-string">localhost</span>      <span class="hljs-attr">port:</span> <span class="hljs-number">8500</span>      <span class="hljs-attr">discovery:</span>        <span class="hljs-comment">#hostname: 127.0.0.1</span>        <span class="hljs-attr">service-name:</span> <span class="hljs-string">$&#123;spring.application.name&#125;</span></code></pre><p>Controller:</p><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderController</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String PAYMENT_URL = <span class="hljs-string">&quot;http://cloud-payment-service&quot;</span>;    <span class="hljs-meta">@Resource</span>    <span class="hljs-keyword">private</span> RestTemplate restTemplate;    <span class="hljs-meta">@GetMapping(&quot;/consumer/payment/consul&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">consul</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> restTemplate.getForObject(PAYMENT_URL + <span class="hljs-string">&quot;/payment/consul&quot;</span>, String.class);    &#125;&#125;</code></pre><p>测试:</p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201123192730.png" alt="test" style="zoom: 50%;" /><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201123192817.png" alt="consul test"></p><h2 id="三个注册中心异同点"><a href="#三个注册中心异同点" class="headerlink" title="三个注册中心异同点"></a>三个注册中心异同点</h2><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201123193015.png" alt="异同点"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201123193225.png" alt="CAP"></p><blockquote><p>AP:</p></blockquote><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201123194018.png" alt="AP"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201123194054.png" alt="CP"></p><h1 id="服务调用"><a href="#服务调用" class="headerlink" title="服务调用"></a>服务调用</h1><h2 id="Ribbon-负载均衡"><a href="#Ribbon-负载均衡" class="headerlink" title="Ribbon 负载均衡"></a>Ribbon 负载均衡</h2><blockquote><p>ribbon是什么？<a href="https://github.com/Netflix/ribbon/wiki/Getting-Started">官网</a></p></blockquote><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201123195235.png" alt="ribbon概述"></p><blockquote><p>Ribbon也已经进入维护, 几乎不更新了, 但Spring推出的LoadBalance暂未能替代ribbon</p></blockquote><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201123195707.png" alt="负载均衡?"></p><h3 id="1、LB（负载均衡）区别"><a href="#1、LB（负载均衡）区别" class="headerlink" title="1、LB（负载均衡）区别"></a>1、LB（负载均衡）区别</h3><h4 id="a、集中式LB"><a href="#a、集中式LB" class="headerlink" title="a、集中式LB"></a>a、集中式LB</h4><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201123195916.png" alt="集中式LB"></p><h4 id="、进程内LB"><a href="#、进程内LB" class="headerlink" title="、进程内LB"></a>、进程内LB</h4><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201123195958.png" alt="进程内LB"></p><blockquote><p>前面我们使用了80通过轮询负载访问8001/8002, 一句话:负载均衡+RestTemplate调用</p></blockquote><h3 id="2、调用演示"><a href="#2、调用演示" class="headerlink" title="2、调用演示"></a>2、调用演示</h3><blockquote><p>Ribbon其实就是一个软负载均衡的客户端组件，他可以和其他所需请求的客户端结合使用，和eureka结合只是其中的一个实例。</p></blockquote><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201123201157.png" alt="ribbon工作"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201123201226.png" alt="策略"></p><h4 id="a、Eureka自动引入"><a href="#a、Eureka自动引入" class="headerlink" title="a、Eureka自动引入"></a>a、Eureka自动引入</h4><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p><strong>Eureka新版本继承了Ribbon</strong></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201123201540.png" alt="pom依赖"></p><h4 id="b、手动加入"><a href="#b、手动加入" class="headerlink" title="b、手动加入"></a>b、手动加入</h4><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201123201718.png" alt="手动"></p><h4 id="c、二说RestTemplate的使用"><a href="#c、二说RestTemplate的使用" class="headerlink" title="c、二说RestTemplate的使用"></a>c、二说RestTemplate的使用</h4><blockquote><p>ForObject与ForEntity区别     <a href="https://docs.spring.io/spring-framework/docs/5.2.2.RELEASE/javadoc-api/org/springframework/web/client/RestTemplate.html">官网</a> </p></blockquote><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/consumer/payment/get/&#123;id&#125;&quot;)</span><span class="hljs-function"><span class="hljs-keyword">public</span> CommonResult&lt;Payment&gt; <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Long id)</span></span>&#123;    <span class="hljs-comment">// 返回对象为响应体中数据转化成的对象，基本上可以理解为Json</span>    <span class="hljs-keyword">return</span> restTemplate.getForObject(PAYMENT_URL + <span class="hljs-string">&quot;/payment/get/&quot;</span> + id, CommonResult.class);&#125;<span class="hljs-meta">@GetMapping(&quot;/consumer/payment/getForEntity/&#123;id&#125;&quot;)</span><span class="hljs-function"><span class="hljs-keyword">public</span> CommonResult&lt;Payment&gt; <span class="hljs-title">getForEntity</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Long id)</span></span>&#123;    <span class="hljs-comment">// 返回对象为ResponseEntity对象，包含了响应中的一些重要信息，比如响应头、状态码、响应体等</span>    ResponseEntity&lt;CommonResult&gt; entity = restTemplate.getForEntity(PAYMENT_URL + <span class="hljs-string">&quot;/payment/get/&quot;</span> + id, CommonResult.class);    <span class="hljs-keyword">if</span> (entity.getStatusCode().is2xxSuccessful())&#123;        <span class="hljs-keyword">return</span> entity.getBody();    &#125;<span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CommonResult&lt;&gt;(<span class="hljs-number">444</span>, <span class="hljs-string">&quot;失败&quot;</span>);    &#125;&#125;</code></pre><pre><code class="hljs java">RestTemplate的:        xxxForObject()方法,返回的是响应体中的数据    xxxForEntity()方法.返回的是entity对象,这个对象不仅仅包含响应体数据,还包含响应体信息(状态码等)</code></pre><h3 id="3、Ribbon核心组件IRule"><a href="#3、Ribbon核心组件IRule" class="headerlink" title="3、Ribbon核心组件IRule"></a>3、Ribbon核心组件IRule</h3><blockquote><p>IRule:根据特定算法从服务列表中选取一个要访问的服务</p></blockquote><h4 id="a、IRule接口关系"><a href="#a、IRule接口关系" class="headerlink" title="a、IRule接口关系"></a>a、IRule接口关系</h4><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201123203451.png" alt="接口"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201123203612.png" alt="各个算法"></p><h4 id="b、如何替换？"><a href="#b、如何替换？" class="headerlink" title="b、如何替换？"></a>b、如何替换？</h4><p>修改cloud-consumer-order80:</p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201125101402.png" alt="说明"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201125101630.png" alt="说明"></p><p>在myrule下添加MySelfRule类</p><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MySelfRule</span> </span>&#123;        <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> IRule <span class="hljs-title">myRule</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RandomRule();    &#125;&#125;</code></pre><p>主启动类添加:</p><pre><code class="hljs java"><span class="hljs-meta">@RibbonClient</span></code></pre><pre><code class="hljs java"><span class="hljs-meta">@RibbonClient(name = &quot;CLOUD-PAYMENT-SERVICE&quot;, configuration = MySelfRule.class)</span></code></pre><h3 id="4、负载均衡算法"><a href="#4、负载均衡算法" class="headerlink" title="4、负载均衡算法"></a>4、负载均衡算法</h3><h4 id="a、轮询原理"><a href="#a、轮询原理" class="headerlink" title="a、轮询原理"></a>a、轮询原理</h4><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201125103222.png" alt="原理"></p><h4 id="b、轮询源码分析"><a href="#b、轮询源码分析" class="headerlink" title="b、轮询源码分析"></a>b、轮询源码分析</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RoundRobinRule</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractLoadBalancerRule</span> </span>&#123;    <span class="hljs-comment">// ... 省略</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RoundRobinRule</span><span class="hljs-params">()</span> </span>&#123;        nextServerCyclicCounter = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">0</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Server <span class="hljs-title">choose</span><span class="hljs-params">(ILoadBalancer lb, Object key)</span> </span>&#123;        <span class="hljs-keyword">if</span> (lb == <span class="hljs-keyword">null</span>) &#123;            log.warn(<span class="hljs-string">&quot;no load balancer&quot;</span>);            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        Server server = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (server == <span class="hljs-keyword">null</span> &amp;&amp; count++ &lt; <span class="hljs-number">10</span>) &#123;            <span class="hljs-comment">// Reachable, 获得状态为UP的Server</span>            List&lt;Server&gt; reachableServers = lb.getReachableServers();            List&lt;Server&gt; allServers = lb.getAllServers();            <span class="hljs-keyword">int</span> upCount = reachableServers.size();            <span class="hljs-comment">// 获取Server数</span>            <span class="hljs-keyword">int</span> serverCount = allServers.size();            <span class="hljs-keyword">if</span> ((upCount == <span class="hljs-number">0</span>) || (serverCount == <span class="hljs-number">0</span>)) &#123;                log.warn(<span class="hljs-string">&quot;No up servers available from load balancer: &quot;</span> + lb);                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;            &#125;            <span class="hljs-keyword">int</span> nextServerIndex = incrementAndGetModulo(serverCount);            server = allServers.get(nextServerIndex);            <span class="hljs-keyword">if</span> (server == <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-comment">/* Transient. */</span>                Thread.yield();                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-keyword">if</span> (server.isAlive() &amp;&amp; (server.isReadyToServe())) &#123;                <span class="hljs-keyword">return</span> (server);            &#125;            <span class="hljs-comment">// Next.</span>            server = <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-keyword">if</span> (count &gt;= <span class="hljs-number">10</span>) &#123;            log.warn(<span class="hljs-string">&quot;No available alive servers after 10 tries from load balancer: &quot;</span>                    + lb);        &#125;        <span class="hljs-keyword">return</span> server;    &#125;        <span class="hljs-comment">// 自旋锁 </span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">incrementAndGetModulo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> modulo)</span> </span>&#123;        <span class="hljs-keyword">for</span> (;;) &#123;            <span class="hljs-keyword">int</span> current = nextServerCyclicCounter.get();            <span class="hljs-comment">// 开始 0 + 1</span>            <span class="hljs-keyword">int</span> next = (current + <span class="hljs-number">1</span>) % modulo;            <span class="hljs-comment">// CAS 比较并交换</span>            <span class="hljs-keyword">if</span> (nextServerCyclicCounter.compareAndSet(current, next))                <span class="hljs-keyword">return</span> next;        &#125;    &#125;&#125;</code></pre><h4 id="d、手写轮询算法"><a href="#d、手写轮询算法" class="headerlink" title="d、手写轮询算法"></a>d、手写轮询算法</h4><blockquote><p>学完JUC再续…</p></blockquote><p>// TODO</p><h2 id="OpenFeign服务接口调用"><a href="#OpenFeign服务接口调用" class="headerlink" title="OpenFeign服务接口调用"></a>OpenFeign服务接口调用</h2><h3 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h3><blockquote><p>Feign是一个声明式的web服务客户端，让编写web服务客户端变得非常容易，只需创建一个接口并在接口上添加注解即可 <a href="https://github.com/spring-cloud/spring-cloud-openfeign">官网</a></p></blockquote><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201125111325.png" alt="概念"></p><blockquote><p>能干什么？</p></blockquote><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201125111350.png" alt="用途"></p><blockquote><p>就是A要调用B,Feign就是在A中创建一个一模一样的B对外提供服务的的接口,我们调用这个接口,就可以服务到B</p></blockquote><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201125112301.png" alt="区别"></p><h3 id="2、使用"><a href="#2、使用" class="headerlink" title="2、使用"></a>2、使用</h3><blockquote><p>之前的服务间调用, 我们使用的是ribbon+RestTemplate, 现在改为使用Feign, 继承了Ribbon, 默认仍是轮询</p></blockquote><h4 id="a、创建cloud-consumer-feign-order80工程"><a href="#a、创建cloud-consumer-feign-order80工程" class="headerlink" title="a、创建cloud-consumer-feign-order80工程"></a>a、创建cloud-consumer-feign-order80工程</h4><p>Pom:</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- openfeign --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>yaml:</p><pre><code class="hljs yaml"><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">80</span><span class="hljs-attr">eureka:</span>  <span class="hljs-attr">client:</span>    <span class="hljs-attr">register-with-eureka:</span> <span class="hljs-literal">false</span>    <span class="hljs-attr">service-url:</span>      <span class="hljs-comment">#defaultZone: http://localhost:7001/eureka</span>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka</span></code></pre><p>主启动类:</p><pre><code class="hljs java"><span class="hljs-meta">@EnableFeignClients</span> <span class="hljs-comment">// 使用Feign, 激活并开启</span></code></pre><h4 id="b、新建PaymentFeignService接口并新增注解-FeignClient"><a href="#b、新建PaymentFeignService接口并新增注解-FeignClient" class="headerlink" title="b、新建PaymentFeignService接口并新增注解@FeignClient:"></a>b、新建PaymentFeignService接口并新增注解@FeignClient:</h4><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-meta">@FeignClient(name = &quot;CLOUD-PAYMENT-SERVICE&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">PaymentFeignService</span> </span>&#123;        <span class="hljs-meta">@GetMapping(&quot;/payment/get/&#123;id&#125;&quot;)</span>    <span class="hljs-function">CommonResult&lt;Payment&gt; <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(value = &quot;id&quot;)</span> Long id)</span></span>;    &#125;</code></pre><h4 id="c、写controller"><a href="#c、写controller" class="headerlink" title="c、写controller"></a>c、写controller</h4><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-meta">@Slf4j</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderController</span> </span>&#123;        <span class="hljs-meta">@Resource</span>    <span class="hljs-keyword">private</span> PaymentFeignService paymentFeignService;        <span class="hljs-meta">@GetMapping(&quot;/consumer/payment/get/&#123;id&#125;&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> CommonResult&lt;Payment&gt; <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(value = &quot;id&quot;)</span> Long id)</span></span>&#123;        <span class="hljs-keyword">return</span> paymentFeignService.get(id);    &#125;&#125;</code></pre><blockquote><p>注: <a href="https://www.cnblogs.com/huhuixin/p/7797850.html">Feign PathVariable annotation was empty on param 0.</a>报错, 需要在@PathVariable中添加Value = “”</p></blockquote><blockquote><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span>  <span class="hljs-attr">application:</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">CLOUD-PAYMENT-SERVICE</span><span class="hljs-comment"># name与用到的地方务必统一大小写 c + shift + u</span></code></pre></blockquote><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201125140748.png" alt="总览"></p><h3 id="3、OpenFeign超时控制"><a href="#3、OpenFeign超时控制" class="headerlink" title="3、OpenFeign超时控制"></a>3、OpenFeign超时控制</h3><blockquote><p>消费调用服务, 一定会存在一种<strong>超时现象</strong>, OpenFeign默认等待一秒钟, 超过后报错</p></blockquote><h4 id="a、在PaymentController中添加timeout接口"><a href="#a、在PaymentController中添加timeout接口" class="headerlink" title="a、在PaymentController中添加timeout接口"></a>a、在PaymentController中添加timeout接口</h4><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-meta">@Slf4j</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PaymentController</span> </span>&#123;    <span class="hljs-meta">@GetMapping(&quot;/payment/timeout&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">timeout</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">try</span> &#123;            TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        <span class="hljs-keyword">return</span> serverPort;    &#125;&#125;</code></pre><h4 id="b、在PaymentFeignService添加"><a href="#b、在PaymentFeignService添加" class="headerlink" title="b、在PaymentFeignService添加"></a>b、在PaymentFeignService添加</h4><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-meta">@FeignClient(value = &quot;cloud-payment-service&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">PaymentFeignService</span> </span>&#123;    <span class="hljs-meta">@GetMapping(&quot;/payment/timeout&quot;)</span>    <span class="hljs-function">String <span class="hljs-title">timeout</span><span class="hljs-params">()</span></span>;&#125;</code></pre><h4 id="c、OrderController中添加"><a href="#c、OrderController中添加" class="headerlink" title="c、OrderController中添加"></a>c、OrderController中添加</h4><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-meta">@Slf4j</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderController</span> </span>&#123;    <span class="hljs-meta">@GetMapping(&quot;/consumer/payment/timeout&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">timeout</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> paymentFeignService.timeout();    &#125;&#125;</code></pre><p>​           <img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201125142929.png" alt="测试结果"></p><h4 id="d、超时控制"><a href="#d、超时控制" class="headerlink" title="d、超时控制"></a>d、超时控制</h4><pre><code class="hljs yaml"><span class="hljs-attr">ribbon:</span>  <span class="hljs-comment"># 建立连接时间</span>  <span class="hljs-attr">ReadTimeout:</span> <span class="hljs-number">5000</span>  <span class="hljs-comment"># 连接后从服务器读取到可用资源时间</span>  <span class="hljs-attr">ConnectTimeout:</span> <span class="hljs-number">5000</span></code></pre><p>​       <img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201125143321.png" alt="测试结果"></p><h3 id="4、日志增强"><a href="#4、日志增强" class="headerlink" title="4、日志增强"></a>4、日志增强</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201125143432.png" alt="openfeign日志"></p><p>写config:</p><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FeignConfig</span> </span>&#123;        <span class="hljs-meta">@Bean</span>    Logger.<span class="hljs-function">Level <span class="hljs-title">feignLoggerLevel</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> Logger.Level.FULL;    &#125;&#125;</code></pre><p>yaml开启:</p><pre><code class="hljs yaml"><span class="hljs-attr">logging:</span>  <span class="hljs-attr">level:</span>     <span class="hljs-attr">com.qiuke.springcloud.service.PaymentFeignService:</span> <span class="hljs-string">debug</span></code></pre><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201125144229.png" alt="日志"></p><h1 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a>服务降级</h1><h2 id="Hystrix-断路器"><a href="#Hystrix-断路器" class="headerlink" title="Hystrix 断路器"></a>Hystrix 断路器</h2><h3 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h3><h4 id="a、分布式面临的问题"><a href="#a、分布式面临的问题" class="headerlink" title="a、分布式面临的问题"></a>a、分布式面临的问题</h4><blockquote><p>复杂分布式体系结构中的应用程序有数十个依赖关系, 每个依赖关系在某个时候将不可避免的失败</p></blockquote><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201125144953.png" alt="问题"></p><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201125145028.png" alt="服务雪崩"></p><h4 id="b、Hystrix是什么？"><a href="#b、Hystrix是什么？" class="headerlink" title="b、Hystrix是什么？"></a>b、Hystrix是什么？</h4><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201125145348.png" alt="概念"></p><blockquote><p>功能: 服务降级、服务熔断、接近实时的监控   <a href="https://github.com/Netflix/Hystrix/wiki/How-To-Use">官网</a>   <a href="https://github.com/Netflix/Hystrix">停更进维</a></p></blockquote><h4 id="c、名词概念"><a href="#c、名词概念" class="headerlink" title="c、名词概念"></a>c、名词概念</h4><blockquote><p>服务降级 (fallback)</p></blockquote><p><strong>服务器忙，请稍候再试，不让客户端等待并立刻返回一个友好提示，fallback</strong></p><p>哪些情况会触发降级？</p><ul><li>程序运行异常</li><li>超时</li><li>服务熔断触发服务降级</li><li>线程池/信号量打满也会导致服务降级</li></ul><blockquote><p>服务熔断 (break)</p></blockquote><blockquote><p>服务限流 (flowlimit)</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>Spring Cloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
