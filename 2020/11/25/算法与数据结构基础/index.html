

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/imgfavicon.jpg">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  <title>数据结构与算法基础回顾笔记 - Blog</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.1.2/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.5","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"copy_btn":true,"image_zoom":{"enable":true},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.2.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Fluid</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax=true
         style="background: url('https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/imgdefault.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="数据结构与算法基础回顾笔记">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2020-11-25 16:08" pubdate>
        2020年11月25日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      27.7k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      395
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">数据结构与算法基础回顾笔记</h1>
            
            <div class="markdown-body">
              <blockquote>
<p>跟左神重学！</p>
</blockquote>
<h1 id="认识复杂度、对数器、二分法与异或运算"><a href="#认识复杂度、对数器、二分法与异或运算" class="headerlink" title="认识复杂度、对数器、二分法与异或运算"></a>认识复杂度、对数器、二分法与异或运算</h1><h2 id="认识复杂度"><a href="#认识复杂度" class="headerlink" title="认识复杂度"></a>认识复杂度</h2><blockquote>
<p>评估算法优劣的核心指标是什么？</p>
</blockquote>
<ul>
<li><p>时间复杂度（流程决定）</p>
</li>
<li><p>额外空间复杂度（流程决定）</p>
</li>
<li><p>常数项时间（实现细节决定）</p>
</li>
</ul>
<h3 id="1、什么是时间复杂度？时间复杂度怎么估算？"><a href="#1、什么是时间复杂度？时间复杂度怎么估算？" class="headerlink" title="1、什么是时间复杂度？时间复杂度怎么估算？"></a>1、什么是时间复杂度？时间复杂度怎么估算？</h3><ul>
<li>常数时间的操作</li>
<li>确定算法流程的总操作数量与样本数量之间的表达式关系</li>
<li>只看表达式最高阶项的部分</li>
</ul>
<h3 id="2、何为常数时间的操作？"><a href="#2、何为常数时间的操作？" class="headerlink" title="2、何为常数时间的操作？"></a>2、何为常数时间的操作？</h3><blockquote>
<p>如果一个操作的执行时间不以具体样本量为转移，每次执行时间都是固定时间。称这样的操作为常数时间的操作。如取Array[0]与取Array[1000000]花费时间一致， 不以数据量转移。</p>
</blockquote>
<p><strong>常见的常数时间的操作</strong></p>
<ul>
<li>常见的算术运算（+、-、*、/、% 等）</li>
<li>常见的位运算（&gt;&gt;(带符号右移)、&gt;&gt;&gt;(不带符号右移)、&lt;&lt;、|、&amp;、^等）</li>
<li>赋值、比较、自增、自减操作等</li>
<li>数组寻址操作</li>
</ul>
<p>总之，执行时间固定的操作都是常数时间的操作。<br>反之，执行时间不固定的操作，都不是常数时间的操作。</p>
<p><strong>如何确定算法流程的总操作数量与样本数量之间的表达式关系？</strong></p>
<p>​    1，想象该算法流程所处理的数据状况，要按照 <strong><em>最差</em></strong>情况来。</p>
<p>​    2，把整个流程彻底拆分为一个个 <strong><em>基本动作</em></strong>，保证每个动作都是 <strong><em>常数时间</em></strong>的操作。</p>
<p>​    3，如果数据量为N，看看基本动作的数量和N是什么关系。</p>
<h3 id="3、如何确定算法流程的时间复杂度？"><a href="#3、如何确定算法流程的时间复杂度？" class="headerlink" title="3、如何确定算法流程的时间复杂度？"></a>3、如何确定算法流程的时间复杂度？</h3><blockquote>
<p>当完成了表达式的建立，只要把最高阶项留下即可。低阶项都去掉，高阶项的系数也去掉。<br>记为：<strong>O(忽略掉系数的高阶项)</strong></p>
</blockquote>
<p>通过三个具体的例子，来实践一把时间复杂度的估算</p>
<h4 id="a、选择排序"><a href="#a、选择排序" class="headerlink" title="a、选择排序"></a>a、选择排序</h4><p>过程：<br>arr[0～N-1]范围上，找到最小值所在的位置，然后把最小值交换到0位置。<br>arr[1～N-1]范围上，找到最小值所在的位置，然后把最小值交换到1位置。<br>arr[2～N-1]范围上，找到最小值所在的位置，然后把最小值交换到2位置。<br>…<br>arr[N-1～N-1]范围上，找到最小值位置，然后把最小值交换到N-1位置。</p>
<p>估算：<br>很明显，如果arr长度为N，每一步常数操作的数量，如等差数列一般<br>所以，总的常数操作数量 = a*(N^2) + b*N + c (a、b、c都是常数)</p>
<p>所以选择排序的时间复杂度为 **O(N^2)**。</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">selectionSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length &lt; <span class="hljs-number">2</span>) &#123;
      <span class="hljs-keyword">return</span>;
   &#125;
   <span class="hljs-comment">// 0～n-1</span>
   <span class="hljs-comment">// 1～n-1</span>
   <span class="hljs-comment">// 2～n-1</span>
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length - <span class="hljs-number">1</span>; i++) &#123; <span class="hljs-comment">// i ~ N-1</span>
      <span class="hljs-comment">// 最小值在哪个位置上  i～n-1</span>
      <span class="hljs-keyword">int</span> minIndex = i;
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; arr.length; j++) &#123; <span class="hljs-comment">// i ~ N-1 上找最小值的下标 </span>
         minIndex = arr[j] &lt; arr[minIndex] ? j : minIndex;
      &#125;
      swap(arr, i, minIndex);
   &#125;
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;
   <span class="hljs-keyword">int</span> tmp = arr[i];
   arr[i] = arr[j];
   arr[j] = tmp;
&#125;</code></pre>

<h4 id="b、冒泡排序"><a href="#b、冒泡排序" class="headerlink" title="b、冒泡排序"></a>b、冒泡排序</h4><p>过程：<br>在arr[0～N-1]范围上：<br>arr[0]和arr[1]，谁大谁来到1位置；arr[1]和arr[2]，谁大谁来到2位置…arr[N-2]和arr[N-1]，谁大谁来到N-1位置</p>
<p>在arr[0～N-2]范围上，重复上面的过程，但最后一步是arr[N-3]和arr[N-2]，谁大谁来到N-2位置<br>在arr[0～N-3]范围上，重复上面的过程，但最后一步是arr[N-4]和arr[N-3]，谁大谁来到N-3位置<br>…<br>最后在arr[0～1]范围上，重复上面的过程，但最后一步是arr[0]和arr[1]，谁大谁来到1位置</p>
<p>估算：<br>很明显，如果arr长度为N，每一步常数操作的数量，依然如等差数列一般<br>所以，总的常数操作数量 = a*(N^2) + b*N + c (a、b、c都是常数)</p>
<p>所以冒泡排序的时间复杂度为O(N^2)。</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bubbleSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span></span>&#123;
        <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length &lt; <span class="hljs-number">2</span>)&#123;
            <span class="hljs-keyword">return</span>;
        &#125;

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = arr.length - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--)&#123;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++)&#123;
                <span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>])&#123;
                    swap(arr, j, j+<span class="hljs-number">1</span>);
                &#125;
            &#125;
        &#125;
    &#125;
    <span class="hljs-comment">// 交换arr的i和j位置上的值</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;
        arr[i] = arr[i] ^ arr[j];
        arr[j] = arr[i] ^ arr[j];
        arr[i] = arr[i] ^ arr[j];
    &#125;</code></pre>

<h4 id="c、插入排序"><a href="#c、插入排序" class="headerlink" title="c、插入排序"></a>c、插入排序</h4><p>过程：<br>想让arr[0<del>0]上有序，这个范围只有一个数，当然是有序的。<br>想让arr[0</del>1]上有序，所以从arr[1]开始往前看，如果arr[1]&lt;arr[0]，就交换。否则什么也不做。<br>想让arr[0<del>i]上有序，所以从arr[i]开始往前看，arr[i]这个数不停向左移动，一直移动到左边的数字不再比自己大，停止移动。<br>最后一步，想让arr[0</del>N-1]上有序， arr[N-1]这个数不停向左移动，一直移动到左边的数字不再比自己大，停止移动。</p>
<p>估算时发现这个算法流程的复杂程度，会因为数据状况的不同而不同。</p>
<pre><code class="hljs mathematica">
如果某个算法流程的复杂程度会根据数据状况的不同而不同，那么你必须要按照最差情况来估计。

很明显，在最差情况下，如果<span class="hljs-variable">arr</span>长度为<span class="hljs-built_in">N</span>，插入排序的每一步常数操作的数量，还是如等差数列一般

所以，总的常数操作数量 <span class="hljs-operator">=</span> <span class="hljs-variable">a</span><span class="hljs-operator">*</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-operator">^</span><span class="hljs-number">2</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">+</span> <span class="hljs-variable">b</span><span class="hljs-operator">*</span><span class="hljs-built_in">N</span> <span class="hljs-operator">+</span> <span class="hljs-variable">c</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">a</span>、<span class="hljs-variable">b</span>、<span class="hljs-variable">c</span>都是常数<span class="hljs-punctuation">)</span>

所以插入排序排序的时间复杂度为<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-operator">^</span><span class="hljs-number">2</span><span class="hljs-punctuation">)</span>。

</code></pre>

<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertionSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length &lt; <span class="hljs-number">2</span>) &#123;
      <span class="hljs-keyword">return</span>;
   &#125;
   <span class="hljs-comment">// 0~0 有序的</span>
   <span class="hljs-comment">// 0~i 想有序</span>
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; arr.length; i++) &#123; <span class="hljs-comment">// 0 ~ i 做到有序</span>
      
      <span class="hljs-comment">// arr[i]往前看，一直交换到合适的位置停止</span>
      <span class="hljs-comment">// ...(&lt;=)  ?       &lt;- i</span>
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[j] &gt; arr[j + <span class="hljs-number">1</span>]; j--) &#123;
         swap(arr, j, j + <span class="hljs-number">1</span>);
      &#125;
   &#125;
&#125;

<span class="hljs-comment">// i和j是一个位置的话，会出错</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;
   arr[i] = arr[i] ^ arr[j];
   arr[j] = arr[i] ^ arr[j];
   arr[i] = arr[i] ^ arr[j];
&#125;</code></pre>

<blockquote>
<p>注意</p>
</blockquote>
<ul>
<li><p>算法的过程，和具体的语言是无关的。</p>
</li>
<li><p>想分析一个算法流程的时间复杂度的前提，是对该流程非常熟悉</p>
</li>
<li><p>一定要确保在拆分算法流程时，拆分出来的所有行为都是常数时间的操作。这意味着你写算法时，对自己的用过的每一个系统api，都非常的熟悉。否则会影响你对时间复杂度的估算。</p>
<hr>
<pre><code class="hljs mathematica">排名从好到差：
<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-number">1</span><span class="hljs-punctuation">)</span>   
<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-variable">logN</span><span class="hljs-punctuation">)</span>   
<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-punctuation">)</span>   
<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-operator">*</span><span class="hljs-variable">logN</span><span class="hljs-punctuation">)</span>   
<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-operator">^</span><span class="hljs-number">2</span><span class="hljs-punctuation">)</span>   <span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-operator">^</span><span class="hljs-number">3</span><span class="hljs-punctuation">)</span>   …   <span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-operator">^</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span>
<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-number">2</span><span class="hljs-operator">^</span><span class="hljs-built_in">N</span><span class="hljs-punctuation">)</span>   <span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-number">3</span><span class="hljs-operator">^</span><span class="hljs-built_in">N</span><span class="hljs-punctuation">)</span>   …   <span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">K</span><span class="hljs-operator">^</span><span class="hljs-built_in">N</span><span class="hljs-punctuation">)</span>
<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-operator">!</span><span class="hljs-punctuation">)</span></code></pre>



</li>
</ul>
<h3 id="4、时间复杂度的意义"><a href="#4、时间复杂度的意义" class="headerlink" title="4、时间复杂度的意义"></a>4、时间复杂度的意义</h3><p>抹掉了好多东西，只剩下了一个 <strong><em>最高阶项</em></strong>啊…</p>
<p>那这个东西有什么意义呢？</p>
<p>时间复杂度的意义在于：</p>
<p>当我们要处理的样本量很大很大时，我们会发现*<strong>低阶项是什么不是最重要的 **<em>；每一项的系数是什么，不是最重要的。</em></strong>真正重要的就是最高阶项是什么***。</p>
<p>这就是时间复杂度的意义，它是衡量算法流程的复杂程度的一种指标，该指标只与 <strong><em>数据量</em></strong>有关，与 <strong><em>过程之外的优化</em></strong>无关。</p>
<h3 id="5、额外空间复杂度"><a href="#5、额外空间复杂度" class="headerlink" title="5、额外空间复杂度"></a>5、额外空间复杂度</h3><p>你要实现一个算法流程，在实现算法流程的过程中，你需要开辟一些空间来支持你的算法流程。</p>
<p>作为 <strong><em>输入参数</em></strong>的空间，不算额外空间。<br>作为 <strong><em>输出结果</em></strong>的空间，也不算额外空间。</p>
<p>因为这些都是必要的、和现实目标有关的。所以都不算。<br>但除此之外，你的流程如果还需要开辟空间才能让你的流程继续下去。这部分空间就是额外空间。<br>如果你的流程只需要开辟有限几个变量，额外空间复杂度就是O(1)。</p>
<h3 id="6、算法流程的常数项"><a href="#6、算法流程的常数项" class="headerlink" title="6、算法流程的常数项"></a>6、算法流程的常数项</h3><p>我们会发现，时间复杂度这个指标，是忽略低阶项和所有常数系数的。<br>难道同样时间复杂度的流程，在实际运行时候就一样的好吗？<br>当然不是。</p>
<p>时间复杂度只是一个很重要的指标而已。如果两个时间复杂度一样的算法，你还要去在时间上拼优劣，就进入到拼常数时间的阶段，简称 <strong><em>拼常数项</em></strong>。</p>
<blockquote>
<p>算法流程的常数项的比拼方式</p>
</blockquote>
<p> <strong><em>放弃理论分析，生成随机数据直接测</em></strong>。</p>
<p>为什么不去理论分析？<br>不是不能纯分析，而是没必要。因为不同常数时间的操作，虽然都是固定时间，但还是有快慢之分的。</p>
<p>比如，位运算的常数时间原小于算术运算的常数时间，这两个运算的常数时间又远小于数组寻址的时间。<br>所以如果纯理论分析，往往会需要非常多的分析过程。都已经到了具体细节的程度，莫不如交给实验数据好了。</p>
<h3 id="7、面试、比赛、刷题中，一个问题的最优解是什么意思？"><a href="#7、面试、比赛、刷题中，一个问题的最优解是什么意思？" class="headerlink" title="7、面试、比赛、刷题中，一个问题的最优解是什么意思？"></a>7、面试、比赛、刷题中，一个问题的最优解是什么意思？</h3><p>一般情况下，认为解决一个问题的算法流程，在 <strong><em>时间复杂度</em></strong>的指标上，一定要尽可能的 <strong><em>低</em></strong>，先满足了时间复杂度最低这个指标之后，使用最少的 <strong><em>空间</em></strong>的算法流程，叫这个问题的最优解。</p>
<p>一般说起最优解都是 <strong><em>忽略掉常数项</em></strong>这个因素的，因为这个因素只决定了实现层次的优化和考虑，而和怎么解决整个问题的思想无关。</p>
<h2 id="对数器"><a href="#对数器" class="headerlink" title="对数器"></a>对数器</h2><h3 id="1、什么是对数器"><a href="#1、什么是对数器" class="headerlink" title="1、什么是对数器"></a>1、什么是对数器</h3><blockquote>
<p>认识对数器</p>
</blockquote>
<p>1，你想要测的方法a<br>2，实现复杂度不好但是容易实现的方法b<br>3，实现一个随机样本产生器<br>4，把方法a和方法b跑相同的随机样本，看看得到的结果是否一样<br>5，如果有一个随机样本使得比对结果不一致，打印样本进行人工干预，改对方法a和方法b<br>6，当样本数量很多时比对测试依然正确，可以确定方法a已经正确。</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] generateRandomArray(<span class="hljs-keyword">int</span> maxSize, <span class="hljs-keyword">int</span> maxValue) &#123;
   <span class="hljs-comment">// Math.random() -&gt;  [0,1) 所有的小数，等概率返回一个</span>
   <span class="hljs-comment">// Math.random() * N -&gt; [0,N) 所有小数，等概率返回一个</span>
   <span class="hljs-comment">// (int)(Math.random() * N) -&gt; [0,N-1] 所有的整数，等概率返回一个</span>
   <span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[(<span class="hljs-keyword">int</span>) ((maxSize + <span class="hljs-number">1</span>) * Math.random())]; <span class="hljs-comment">// 长度随机 </span>
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;
      <span class="hljs-comment">// [-?,+?]</span>
      arr[i] = (<span class="hljs-keyword">int</span>) ((maxValue + <span class="hljs-number">1</span>) * Math.random()) 
            - (<span class="hljs-keyword">int</span>) (maxValue * Math.random());
   &#125;
   <span class="hljs-keyword">return</span> arr;
&#125;
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">comparator</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;
		Arrays.sort(arr);
	&#125;
<span class="hljs-comment">// for copy</span>
	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] copyArray(<span class="hljs-keyword">int</span>[] arr) &#123;
		<span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span>) &#123;
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
		&#125;
		<span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[arr.length];
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;
			res[i] = arr[i];
		&#125;
		<span class="hljs-keyword">return</span> res;
	&#125;

	<span class="hljs-comment">// for compare</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEqual</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr1, <span class="hljs-keyword">int</span>[] arr2)</span> </span>&#123;
		<span class="hljs-keyword">if</span> ((arr1 == <span class="hljs-keyword">null</span> &amp;&amp; arr2 != <span class="hljs-keyword">null</span>) || (arr1 != <span class="hljs-keyword">null</span> &amp;&amp; arr2 == <span class="hljs-keyword">null</span>)) &#123;
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
		&#125;
		<span class="hljs-keyword">if</span> (arr1 == <span class="hljs-keyword">null</span> &amp;&amp; arr2 == <span class="hljs-keyword">null</span>) &#123;
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
		&#125;
		<span class="hljs-keyword">if</span> (arr1.length != arr2.length) &#123;
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
		&#125;
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr1.length; i++) &#123;
			<span class="hljs-keyword">if</span> (arr1[i] != arr2[i]) &#123;
				<span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
			&#125;
		&#125;
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
	&#125;</code></pre>

<pre><code class="hljs java"><span class="hljs-comment">// for test</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
   <span class="hljs-keyword">int</span> testTime = <span class="hljs-number">500000</span>;
   <span class="hljs-keyword">int</span> maxSize = <span class="hljs-number">100</span>; <span class="hljs-comment">// 随机数组的长度0～100</span>
   <span class="hljs-keyword">int</span> maxValue = <span class="hljs-number">100</span>;<span class="hljs-comment">// 值：-100～100</span>
   <span class="hljs-keyword">boolean</span> succeed = <span class="hljs-keyword">true</span>;
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; testTime; i++) &#123;
      <span class="hljs-keyword">int</span>[] arr1 = generateRandomArray(maxSize, maxValue);
      <span class="hljs-keyword">int</span>[] arr2 = copyArray(arr1);
      insertionSort(arr1);
      comparator(arr2);
      <span class="hljs-keyword">if</span> (!isEqual(arr1, arr2)) &#123;
         <span class="hljs-comment">// 打印arr1</span>
         <span class="hljs-comment">// 打印arr2</span>
         succeed = <span class="hljs-keyword">false</span>;
         <span class="hljs-keyword">break</span>;
      &#125;
   &#125;
   System.out.println(succeed ? <span class="hljs-string">&quot;Nice!&quot;</span> : <span class="hljs-string">&quot;Fucking fucked!&quot;</span>);

   <span class="hljs-keyword">int</span>[] arr = generateRandomArray(maxSize, maxValue);
   printArray(arr);
   insertionSort(arr);
   printArray(arr);
&#125;</code></pre>

<h2 id="认识二分法"><a href="#认识二分法" class="headerlink" title="认识二分法"></a>认识二分法</h2><blockquote>
<p> 经常见到的类型是在一个有序数组上，开展二分搜索，但有序真的是所有问题求解时使用二分的必要条件吗？<br>不！<br>只要能正确构建左右两侧的淘汰逻辑，你就可以二分。</p>
</blockquote>
<h3 id="1、在一个有序数组中，找某个数是否存在"><a href="#1、在一个有序数组中，找某个数是否存在" class="headerlink" title="1、在一个有序数组中，找某个数是否存在"></a>1、在一个有序数组中，找某个数是否存在</h3><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">exist</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] sortedArr, <span class="hljs-keyword">int</span> num)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (sortedArr == <span class="hljs-keyword">null</span> || sortedArr.length == <span class="hljs-number">0</span>) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
   &#125;
   <span class="hljs-keyword">int</span> L = <span class="hljs-number">0</span>;
   <span class="hljs-keyword">int</span> R = sortedArr.length - <span class="hljs-number">1</span>;
   <span class="hljs-keyword">int</span> mid = <span class="hljs-number">0</span>;
   <span class="hljs-comment">// L..R</span>
   <span class="hljs-keyword">while</span> (L &lt; R) &#123;
      <span class="hljs-comment">// 防L R 因数值过大 相加后溢出</span>
      mid = L + ((R - L) &gt;&gt; <span class="hljs-number">1</span>); <span class="hljs-comment">// mid = (L + R) / 2</span>
      <span class="hljs-keyword">if</span> (sortedArr[mid] == num) &#123;
         <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sortedArr[mid] &gt; num) &#123;
         R = mid - <span class="hljs-number">1</span>;
      &#125; <span class="hljs-keyword">else</span> &#123;
         L = mid + <span class="hljs-number">1</span>;
      &#125;
   &#125;
   <span class="hljs-keyword">return</span> sortedArr[L] == num;
&#125;</code></pre>

<h3 id="2、在一个有序数组中，找-gt-某个数最左侧的位置"><a href="#2、在一个有序数组中，找-gt-某个数最左侧的位置" class="headerlink" title="2、在一个有序数组中，找&gt;=某个数最左侧的位置"></a>2、在一个有序数组中，找&gt;=某个数最左侧的位置</h3><pre><code class="hljs java"><span class="hljs-comment">// 在arr上，找满足&gt;=value的最左位置</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">nearestIndex</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> value)</span></span>&#123;
    <span class="hljs-keyword">int</span> L = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> R = arr.length - <span class="hljs-number">1</span>;
    <span class="hljs-keyword">int</span> index = -<span class="hljs-number">1</span>; <span class="hljs-comment">// 记录最左的对号</span>
    <span class="hljs-keyword">while</span> (L &lt;= R)&#123;
        <span class="hljs-keyword">int</span> mid = L + ((R - L) &gt;&gt; <span class="hljs-number">1</span>);
        <span class="hljs-keyword">if</span> (arr[mid] &gt;= value) &#123;
            index = mid;
            R = mid - <span class="hljs-number">1</span>;
        &#125; <span class="hljs-keyword">else</span> &#123;
            L = mid + <span class="hljs-number">1</span>;
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> index;
&#125;</code></pre>

<h3 id="3、-在一个有序数组中，找-lt-某个数最右侧的位置"><a href="#3、-在一个有序数组中，找-lt-某个数最右侧的位置" class="headerlink" title="3、 在一个有序数组中，找&lt;=某个数最右侧的位置"></a>3、 在一个有序数组中，找&lt;=某个数最右侧的位置</h3><pre><code class="hljs java"><span class="hljs-comment">// 在arr上，找满足&lt;=value的最右位置</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">nearestIndex</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> value)</span> </span>&#123;
    <span class="hljs-keyword">int</span> L = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> R = arr.length - <span class="hljs-number">1</span>;
    <span class="hljs-keyword">int</span> index = -<span class="hljs-number">1</span>; <span class="hljs-comment">// 记录最右的对号</span>
    <span class="hljs-keyword">while</span> (L &lt;= R) &#123;
        <span class="hljs-keyword">int</span> mid = L + ((R - L) &gt;&gt; <span class="hljs-number">1</span>);
        <span class="hljs-keyword">if</span> (arr[mid] &lt;= value) &#123;
            index = mid;
            L = mid + <span class="hljs-number">1</span>;
        &#125; <span class="hljs-keyword">else</span> &#123;
            R = mid - <span class="hljs-number">1</span>;
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> index;
&#125;</code></pre>

<h3 id="4、-局部最小值问题"><a href="#4、-局部最小值问题" class="headerlink" title="4、 局部最小值问题"></a>4、 局部最小值问题</h3><blockquote>
<ol>
<li>arr[0]&lt;arr[1]</li>
<li>Arr[len-1]&lt;Arr[len-2]</li>
<li>arr[i-1]&lt;arr[i]&lt;arr[i+1]</li>
</ol>
</blockquote>
<p>arr无序, 任意两个相邻数不相等, 只需返回一个局部最小位置:</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getLessIndex</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length == <span class="hljs-number">0</span>) &#123;
      <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">// no exist</span>
   &#125;
   <span class="hljs-keyword">if</span> (arr.length == <span class="hljs-number">1</span> || arr[<span class="hljs-number">0</span>] &lt; arr[<span class="hljs-number">1</span>]) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
   &#125;
   <span class="hljs-keyword">if</span> (arr[arr.length - <span class="hljs-number">1</span>] &lt; arr[arr.length - <span class="hljs-number">2</span>]) &#123;
      <span class="hljs-keyword">return</span> arr.length - <span class="hljs-number">1</span>;
   &#125;
   <span class="hljs-keyword">int</span> left = <span class="hljs-number">1</span>;
   <span class="hljs-keyword">int</span> right = arr.length - <span class="hljs-number">2</span>;
   <span class="hljs-keyword">int</span> mid = <span class="hljs-number">0</span>;
   <span class="hljs-keyword">while</span> (left &lt; right) &#123;
      mid = (left + right) / <span class="hljs-number">2</span>;
      <span class="hljs-keyword">if</span> (arr[mid] &gt; arr[mid - <span class="hljs-number">1</span>]) &#123;
         right = mid - <span class="hljs-number">1</span>;
      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[mid] &gt; arr[mid + <span class="hljs-number">1</span>]) &#123;
         left = mid + <span class="hljs-number">1</span>;
      &#125; <span class="hljs-keyword">else</span> &#123;
         <span class="hljs-keyword">return</span> mid;
      &#125;
   &#125;
   <span class="hljs-keyword">return</span> left;
&#125;</code></pre>

<h2 id="认识异或运算"><a href="#认识异或运算" class="headerlink" title="认识异或运算"></a>认识异或运算</h2><h3 id="1、如何记住"><a href="#1、如何记住" class="headerlink" title="1、如何记住"></a>1、如何记住</h3><p>异或运算：相同为0，不同为1<br>同或运算：相同以1，不同为0</p>
<blockquote>
<p>能长时间记住的概率接近0%</p>
<p>所以，异或运算就记成无进位相加！ </p>
</blockquote>
<h3 id="2、异或运算的性质"><a href="#2、异或运算的性质" class="headerlink" title="2、异或运算的性质"></a>2、异或运算的性质</h3><p>0^N == N      N^N == 0<br>异或运算满足交换律和结合率</p>
<p>上面的两个性质用无进位相加来理解就非常的容易</p>
<h3 id="3、如何不用额外变量交换两个数"><a href="#3、如何不用额外变量交换两个数" class="headerlink" title="3、如何不用额外变量交换两个数"></a>3、如何不用额外变量交换两个数</h3><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;
    arr[i] = arr[i] ^ arr[j];
    arr[j] = arr[i] ^ arr[j];
    arr[i] = arr[i] ^ arr[j];
&#125;</code></pre>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201125212731.png" srcset="/img/loading.gif" alt="结构"></p>
<blockquote>
<p>注意:     i和j是一个位置的话，会出错，指向的内存要求是不一样的，各自独立的。</p>
</blockquote>
<h3 id="4、一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这种数"><a href="#4、一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这种数" class="headerlink" title="4、一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这种数"></a>4、一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这种数</h3><pre><code class="hljs java"><span class="hljs-comment">// arr中，只有一种数，出现奇数次</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printOddTimesNum1</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;
   <span class="hljs-keyword">int</span> eor = <span class="hljs-number">0</span>;
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;
      eor ^= arr[i];
   &#125;
   System.out.println(eor);
&#125;</code></pre>

<h3 id="5、怎么把一个int类型的数，提取出最右侧的1来"><a href="#5、怎么把一个int类型的数，提取出最右侧的1来" class="headerlink" title="5、怎么把一个int类型的数，提取出最右侧的1来"></a>5、怎么把一个int类型的数，提取出最右侧的1来</h3><p>N &amp; ((~N)+1)</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img9SF_F0USXR87N%TE$HW3L80.png" srcset="/img/loading.gif" alt="1"></p>
<h3 id="6、一个数组中有两种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这两种数"><a href="#6、一个数组中有两种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这两种数" class="headerlink" title="6、一个数组中有两种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这两种数"></a>6、一个数组中有两种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这两种数</h3><pre><code class="hljs java"><span class="hljs-comment">// arr中，有两种数，出现奇数次</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printOddTimesNum2</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;
   <span class="hljs-keyword">int</span> eor = <span class="hljs-number">0</span>;
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;
      eor ^= arr[i];
   &#125;
   <span class="hljs-comment">// eor = a ^ b</span>
   <span class="hljs-comment">// eor != 0</span>
   <span class="hljs-comment">// eor必然有一个位置上是1</span>
   <span class="hljs-keyword">int</span> rightOne = eor &amp; (~eor + <span class="hljs-number">1</span>); <span class="hljs-comment">// 提取出最右的1</span>
   <span class="hljs-keyword">int</span> onlyOne = <span class="hljs-number">0</span>; <span class="hljs-comment">// eor&#x27;</span>
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; arr.length;i++) &#123;
      <span class="hljs-keyword">if</span> ((arr[i] &amp; rightOne) != <span class="hljs-number">0</span>) &#123;
         onlyOne ^= arr[i];
      &#125;
   &#125;
   System.out.println(onlyOne + <span class="hljs-string">&quot; &quot;</span> + (eor ^ onlyOne));
&#125;</code></pre>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201125220723.png" srcset="/img/loading.gif" alt="图解"></p>
<h1 id="链表结构、栈、队列、递归行为、哈希表"><a href="#链表结构、栈、队列、递归行为、哈希表" class="headerlink" title="链表结构、栈、队列、递归行为、哈希表"></a>链表结构、栈、队列、递归行为、哈希表</h1><h2 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h2><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> value;
    <span class="hljs-keyword">public</span> Node next;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.value = data;
    &#125;
&#125;</code></pre>

<h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DoubleNode</span> </span>&#123;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> value;
    <span class="hljs-keyword">public</span> DoubleNode last;
    <span class="hljs-keyword">public</span> DoubleNode next;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DoubleNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.value = data;
    &#125;
&#125;</code></pre>

<h2 id="单向链表和双向链表最简单的练习"><a href="#单向链表和双向链表最简单的练习" class="headerlink" title="单向链表和双向链表最简单的练习"></a>单向链表和双向链表最简单的练习</h2><blockquote>
<p> 链表相关的问题几乎都是coding问题</p>
</blockquote>
<ul>
<li><p>单链表和双链表如何反转</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">reverseLinkedList</span><span class="hljs-params">(Node head)</span> </span>&#123;
   Node pre = <span class="hljs-keyword">null</span>;
   Node next = <span class="hljs-keyword">null</span>;
   <span class="hljs-keyword">while</span> (head != <span class="hljs-keyword">null</span>) &#123;
      next = head.next; <span class="hljs-comment">// 记录head下一个</span>
      head.next = pre; <span class="hljs-comment">// 让head指向pre</span>
      pre = head; <span class="hljs-comment">// 记录初始head</span>
      head = next;<span class="hljs-comment">// head跳到下一个</span>
   &#125;
   <span class="hljs-keyword">return</span> pre;
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> DoubleNode <span class="hljs-title">reverseDoubleList</span><span class="hljs-params">(DoubleNode head)</span></span>&#123;
    DoubleNode pre = <span class="hljs-keyword">null</span>;
    DoubleNode next = <span class="hljs-keyword">null</span>;
    <span class="hljs-keyword">while</span> (head != <span class="hljs-keyword">null</span>)&#123;
        next = head.next;
        head.next = pre;
        head.last = next;
        pre = head;
        head = next;
    &#125;
    <span class="hljs-keyword">return</span> pre;
&#125;</code></pre>
</li>
<li><p>把给定值都删除</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">removeValue</span><span class="hljs-params">(Node head, <span class="hljs-keyword">int</span> num)</span></span>&#123;
    <span class="hljs-comment">// 先找到值不是value的结点，作为头结点</span>
    <span class="hljs-keyword">while</span> (head != <span class="hljs-keyword">null</span>)&#123;
        <span class="hljs-keyword">if</span> (head.value != num)&#123;
            <span class="hljs-keyword">break</span>;
        &#125;
        head = head.next;
    &#125;

    <span class="hljs-comment">// 找到后, 删除后面的</span>
    Node pre = head; <span class="hljs-comment">// 记录上一个不等于num的位置</span>
    Node cur = head; <span class="hljs-comment">// cur作为条件, 每次跳一次, 遍历链表</span>
    <span class="hljs-keyword">while</span> (cur != <span class="hljs-keyword">null</span>)&#123;
        <span class="hljs-keyword">if</span> (cur.value == num)&#123;
            pre.next = cur.next;
        &#125;<span class="hljs-keyword">else</span> &#123;
            pre = cur;
        &#125;
        cur = cur.next;
    &#125;
    <span class="hljs-keyword">return</span> head;
&#125;</code></pre>

</li>
</ul>
<p>这里就是熟悉结构。链表还有哪些常见面试题，后续有专门系统学习。</p>
<h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h2><blockquote>
<p>逻辑概念<br>栈：数据先进后出，犹如弹匣<br>队列：数据先进先出，好似排队</p>
</blockquote>
<h2 id="栈和队列的实际实现"><a href="#栈和队列的实际实现" class="headerlink" title="栈和队列的实际实现"></a>栈和队列的实际实现</h2><ul>
<li><p>双向链表实现</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;
    <span class="hljs-keyword">public</span> T value;
    <span class="hljs-keyword">public</span> Node&lt;T&gt; last;
    <span class="hljs-keyword">public</span> Node&lt;T&gt; next;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(T data)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.value = data;
    &#125;
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DoubleEndsQueue</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;

    <span class="hljs-keyword">public</span> Node&lt;T&gt; head;
    <span class="hljs-keyword">public</span> Node&lt;T&gt; tail;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addFromHead</span><span class="hljs-params">(T value)</span> </span>&#123;
        Node&lt;T&gt; cur = <span class="hljs-keyword">new</span> Node&lt;&gt;(value);
        <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>)&#123;
            head = cur;
            tail = cur;
        &#125;<span class="hljs-keyword">else</span> &#123;
            <span class="hljs-comment">// 改变结点</span>
            cur.next =  head;
            head.last = cur;
            <span class="hljs-comment">// 变更新的头结点</span>
            head = cur;
        &#125;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addFromBottom</span><span class="hljs-params">(T value)</span> </span>&#123;
        Node&lt;T&gt; cur = <span class="hljs-keyword">new</span> Node&lt;&gt;(value);
        <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>)&#123;
            head = cur;
            tail = cur;
        &#125;<span class="hljs-keyword">else</span> &#123;
            <span class="hljs-comment">// 改变结点</span>
            cur.last = tail;
            tail.next = cur;
            tail = cur;
        &#125;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">popFromHead</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>)&#123;
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
        &#125;
        Node&lt;T&gt; cur = head;
        <span class="hljs-keyword">if</span> (head == tail)&#123;
            head = <span class="hljs-keyword">null</span>;
            tail = <span class="hljs-keyword">null</span>;
        &#125;<span class="hljs-keyword">else</span> &#123;
            head = head.next;
            cur.next = <span class="hljs-keyword">null</span>;
            head.last = <span class="hljs-keyword">null</span>;
        &#125;
        <span class="hljs-keyword">return</span> cur.value;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">popFromBottom</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>)&#123;
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
        &#125;
        Node&lt;T&gt; cur = tail;
        <span class="hljs-keyword">if</span> (head == tail)&#123;
            head = <span class="hljs-keyword">null</span>;
            tail = <span class="hljs-keyword">null</span>;
        &#125;<span class="hljs-keyword">else</span> &#123;
            tail = tail.last;
            tail.next = <span class="hljs-keyword">null</span>;
            cur.last = <span class="hljs-keyword">null</span>;
        &#125;
        <span class="hljs-keyword">return</span> cur.value;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> head == <span class="hljs-keyword">null</span>;
    &#125;
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyStack</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;
    <span class="hljs-keyword">private</span> DoubleEndsQueue&lt;T&gt; queue;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyStack</span><span class="hljs-params">()</span> </span>&#123;
        queue = <span class="hljs-keyword">new</span> DoubleEndsQueue&lt;&gt;();
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(T value)</span></span>&#123;
        queue.addFromHead(value);
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>&#123;
        <span class="hljs-keyword">return</span> queue.popFromHead();
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span></span>&#123;
        <span class="hljs-keyword">return</span> queue.isEmpty();
    &#125;
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyQueue</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;
    <span class="hljs-keyword">private</span> DoubleEndsQueue&lt;T&gt; queue;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyQueue</span><span class="hljs-params">()</span> </span>&#123;
        queue = <span class="hljs-keyword">new</span> DoubleEndsQueue&lt;&gt;();
    &#125;

    <span class="hljs-comment">// 出push</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(T value)</span></span>&#123;
        queue.addFromHead(value);
    &#125;

    <span class="hljs-comment">// 进poll</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">poll</span><span class="hljs-params">()</span></span>&#123;
        <span class="hljs-keyword">return</span> queue.popFromBottom();
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span></span>&#123;
        <span class="hljs-keyword">return</span> queue.isEmpty();
    &#125;
&#125;</code></pre>
</li>
<li><p>数组实现</p>
<blockquote>
<p>数组实现栈</p>
</blockquote>
</li>
</ul>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayStack</span> </span>&#123;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span>[] a;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size;<span class="hljs-comment">//栈数组的大小</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> top;<span class="hljs-comment">//栈顶</span>

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayStack</span><span class="hljs-params">(<span class="hljs-keyword">int</span> maxSize)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.size = maxSize;
        <span class="hljs-keyword">this</span>.a = <span class="hljs-keyword">new</span> <span class="hljs-keyword">long</span>[size];
        <span class="hljs-keyword">this</span>.top = -<span class="hljs-number">1</span>;<span class="hljs-comment">//表示空栈</span>
    &#125;

    <span class="hljs-comment">//入栈</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">long</span> value)</span></span>&#123;
        <span class="hljs-keyword">if</span>(isFull())&#123;
            System.out.println(<span class="hljs-string">&quot;栈已经满！&quot;</span>);
            <span class="hljs-keyword">return</span>;
        &#125;
        a[++top] = value;
    &#125;

    <span class="hljs-comment">//返回栈顶内容，但是不删除</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">peek</span><span class="hljs-params">()</span></span>&#123;
        <span class="hljs-keyword">if</span>(isEmpty())&#123;
            System.out.println(<span class="hljs-string">&quot;栈中没有数据！&quot;</span>);
        &#125;
        System.out.println(a[top]);
    &#125;

    <span class="hljs-comment">//弹出栈顶内容，删除</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>&#123;
        <span class="hljs-keyword">if</span>(isEmpty())&#123;
            System.out.println(<span class="hljs-string">&quot;栈中没有数据！&quot;</span>);
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        &#125;
        <span class="hljs-keyword">return</span> a[top--];
    &#125;

    <span class="hljs-comment">//size栈的大小</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span></span>&#123;
        <span class="hljs-keyword">return</span> top + <span class="hljs-number">1</span>;
    &#125;

    <span class="hljs-comment">//是否为空</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> (top == -<span class="hljs-number">1</span>);
    &#125;

    <span class="hljs-comment">//是否满了</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isFull</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> (top == size - <span class="hljs-number">1</span>);
    &#125;

    <span class="hljs-comment">//显示</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span></span>&#123;
        System.out.print(<span class="hljs-string">&quot;[&quot;</span>);
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = top; i &gt;=<span class="hljs-number">0</span> ; i--) &#123;
            System.out.print(a[i]);
            <span class="hljs-keyword">if</span>(i!=<span class="hljs-number">0</span>)&#123;
                System.out.print(<span class="hljs-string">&quot;,&quot;</span>);
            &#125;
        &#125;
        System.out.println(<span class="hljs-string">&quot;]&quot;</span>);
    &#125;
&#125;</code></pre>

<blockquote>
<p>数组实现队列</p>
</blockquote>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyQueue</span> </span>&#123;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] arr;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> pushi;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> polli;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> limit;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyQueue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> limit)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[limit];
        <span class="hljs-keyword">this</span>.pushi = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">this</span>.polli = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">this</span>.size = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">this</span>.limit = limit;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (size == limit)&#123;
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;栈满了，不能再加了&quot;</span>);
        &#125;
        size++;
        arr[pushi] = value;
        pushi = nextIndex(pushi);
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">poll</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">if</span> (size == <span class="hljs-number">0</span>)&#123;
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;栈空了，不能再拿了&quot;</span>);
        &#125;
        size--;
        <span class="hljs-keyword">int</span> ans = arr[polli];
        polli = nextIndex(polli);
        <span class="hljs-keyword">return</span> ans;
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> size == <span class="hljs-number">0</span>;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">nextIndex</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>&#123;
        <span class="hljs-keyword">return</span> i &lt; limit - <span class="hljs-number">1</span> ? i + <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;
    &#125;
&#125;</code></pre>

<h2 id="栈和队列的常见面试题"><a href="#栈和队列的常见面试题" class="headerlink" title="栈和队列的常见面试题"></a>栈和队列的常见面试题</h2><h3 id="1、实现一个特殊的栈，在基本功能的基础上，再实现返回栈中最小元素的功能"><a href="#1、实现一个特殊的栈，在基本功能的基础上，再实现返回栈中最小元素的功能" class="headerlink" title="1、实现一个特殊的栈，在基本功能的基础上，再实现返回栈中最小元素的功能"></a>1、实现一个特殊的栈，在基本功能的基础上，再实现返回栈中最小元素的功能</h3><blockquote>
<p>1）pop、push、getMin操作的时间复杂度都是 O(1)。 </p>
<p>2）设计的栈类型可以使用现成的栈结构。</p>
</blockquote>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201128160516.png" srcset="/img/loading.gif" alt="实现"></p>
<p> <strong>当前数和最小栈栈顶做比较, 谁小加谁</strong>,  弹出一起弹出 —–&gt; MyStack2</p>
<p> <strong>当前数和最小栈栈顶做比较, 只有小于最小栈栈顶才压入</strong>,弹出如果Data Peek = Min Peek, 一起弹出 —–&gt; MyStack1</p>
<pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 想要压入的数比最小栈大 不压入, 小于等于压入</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyStack1</span> </span>&#123;
    <span class="hljs-keyword">private</span> Stack&lt;Integer&gt; stackData;
    <span class="hljs-keyword">private</span> Stack&lt;Integer&gt; stackMin;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyStack1</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">this</span>.stackData = <span class="hljs-keyword">new</span> Stack&lt;Integer&gt;();
        <span class="hljs-keyword">this</span>.stackMin = <span class="hljs-keyword">new</span> Stack&lt;Integer&gt;();
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> newNum)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.stackMin.isEmpty()) &#123;
            <span class="hljs-keyword">this</span>.stackMin.push(newNum);
        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (newNum &lt;= <span class="hljs-keyword">this</span>.getmin()) &#123;
            <span class="hljs-keyword">this</span>.stackMin.push(newNum);
        &#125;
        <span class="hljs-keyword">this</span>.stackData.push(newNum);
    &#125;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 弹出如果Data栈弹出的数等于最小栈栈顶则弹出</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.stackData.isEmpty()) &#123;
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;Your stack is empty.&quot;</span>);
        &#125;
        <span class="hljs-keyword">int</span> value = <span class="hljs-keyword">this</span>.stackData.pop();
        <span class="hljs-keyword">if</span> (value == <span class="hljs-keyword">this</span>.getmin()) &#123;
            <span class="hljs-keyword">this</span>.stackMin.pop();
        &#125;
        <span class="hljs-keyword">return</span> value;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getmin</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.stackMin.isEmpty()) &#123;
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;Your stack is empty.&quot;</span>);
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.stackMin.peek();
    &#125;
&#125;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 想要压入的数比最小栈大 重复压入最小栈栈顶</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyStack2</span> </span>&#123;
    <span class="hljs-keyword">private</span> Stack&lt;Integer&gt; stackData;
    <span class="hljs-keyword">private</span> Stack&lt;Integer&gt; stackMin;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyStack2</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">this</span>.stackData = <span class="hljs-keyword">new</span> Stack&lt;Integer&gt;();
        <span class="hljs-keyword">this</span>.stackMin = <span class="hljs-keyword">new</span> Stack&lt;Integer&gt;();
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> newNum)</span></span>&#123;
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.stackMin.isEmpty())&#123;
            <span class="hljs-comment">// 如果最小栈没有元素 直接压入</span>
            <span class="hljs-keyword">this</span>.stackMin.push(newNum);
        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (newNum &lt; <span class="hljs-keyword">this</span>.getMin())&#123;
            <span class="hljs-comment">// 如果最小栈栈顶小于newNum</span>
            <span class="hljs-keyword">this</span>.stackMin.push(newNum);
        &#125;<span class="hljs-keyword">else</span> &#123;
            <span class="hljs-comment">// 如果最小栈栈顶大于newNum, 重复压入栈顶元素</span>
            <span class="hljs-keyword">int</span> minNum = <span class="hljs-keyword">this</span>.getMin();
            <span class="hljs-keyword">this</span>.stackMin.push(minNum);
        &#125;
        <span class="hljs-keyword">this</span>.stackData.push(newNum);
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.stackData.isEmpty()) &#123;
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;Your stack is empty.&quot;</span>);
        &#125;
        <span class="hljs-keyword">this</span>.stackMin.pop();
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.stackData.pop();
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMin</span><span class="hljs-params">()</span></span>&#123;
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.stackMin.isEmpty())&#123;
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;Your stack is empty.&quot;</span>);
        &#125;

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.stackMin.peek();
    &#125;
&#125;</code></pre>

<h3 id="2、栈与队列互相实现"><a href="#2、栈与队列互相实现" class="headerlink" title="2、栈与队列互相实现"></a>2、栈与队列互相实现</h3><blockquote>
<p>1）如何用栈结构实现队列结构</p>
</blockquote>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TwoStacksQueue</span> </span>&#123;
        <span class="hljs-keyword">public</span> Stack&lt;Integer&gt; stackPush;
        <span class="hljs-keyword">public</span> Stack&lt;Integer&gt; stackPop;

        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TwoStacksQueue</span><span class="hljs-params">()</span> </span>&#123;
            stackPush = <span class="hljs-keyword">new</span> Stack&lt;Integer&gt;();
            stackPop = <span class="hljs-keyword">new</span> Stack&lt;Integer&gt;();
        &#125;

        <span class="hljs-comment">// push栈向pop栈倒入数据</span>
        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pushToPop</span><span class="hljs-params">()</span> </span>&#123;
            <span class="hljs-keyword">if</span> (stackPop.empty())&#123;
                <span class="hljs-keyword">while</span> (!stackPush.empty())&#123;
                    stackPop.push(stackPush.pop());
                &#125;
            &#125;
        &#125;

        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pushInt)</span></span>&#123;
            stackPush.push(pushInt);
<span class="hljs-comment">//            pushToPop();</span>
        &#125;

        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">poll</span><span class="hljs-params">()</span></span>&#123;
            <span class="hljs-keyword">if</span> (stackPop.empty() &amp;&amp; stackPush.empty()) &#123;
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;Queue is empty!&quot;</span>);
            &#125;
            pushToPop();
            <span class="hljs-keyword">return</span> stackPop.pop();
        &#125;

        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">peek</span><span class="hljs-params">()</span> </span>&#123;
            <span class="hljs-keyword">if</span> (stackPop.empty() &amp;&amp; stackPush.empty()) &#123;
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;Queue is empty!&quot;</span>);
            &#125;
            pushToPop();
            <span class="hljs-keyword">return</span> stackPop.peek();
        &#125;
    &#125;</code></pre>

<blockquote>
<p>2）如何用队列结构实现栈结构</p>
</blockquote>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TwoQueueStack</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;
    <span class="hljs-keyword">public</span> Queue&lt;T&gt; queue;
    <span class="hljs-keyword">public</span> Queue&lt;T&gt; help;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TwoQueueStack</span><span class="hljs-params">()</span> </span>&#123;
        queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();
        help = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(T value)</span></span>&#123; queue.offer(value);&#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">poll</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">while</span> (queue.size() &gt; <span class="hljs-number">1</span>)&#123;
            help.offer(queue.poll());
        &#125;
        T ans = queue.poll();
        Queue&lt;T&gt; temp = queue;
        queue = help;
        help = temp;
        <span class="hljs-keyword">return</span> ans;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">peek</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">while</span> (queue.size() &gt; <span class="hljs-number">1</span>)&#123;
            help.offer(queue.poll());
        &#125;
        T ans = queue.peek();
        Queue&lt;T&gt; temp = queue;
        queue = help;
        help = temp;
        queue.offer(ans);
        <span class="hljs-keyword">return</span> ans;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> queue.isEmpty();
    &#125;
&#125;</code></pre>

<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><blockquote>
<p>怎么从思想上理解递归</p>
</blockquote>
<p>求数组arr[L..R]中的最大值，怎么用递归方法实现。</p>
<p>1）将[L..R]范围分成左右两半。左：[L..Mid]  右[Mid+1..R]<br>2）左部分求最大值，右部分求最大值<br>3） [L..R]范围上的最大值，是max{左部分最大值，右部分最大值}</p>
<p>注意：2）是个递归过程，当范围上只有一个数，就可以不用再递归了</p>
<pre><code class="hljs java"><span class="hljs-comment">// 求arr中的最大值</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMax</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;
    <span class="hljs-keyword">return</span> process(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>);
&#125;

<span class="hljs-comment">// arr[L..R]范围上求最大值  L ... R   N</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">process</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R)</span> </span>&#123;
    <span class="hljs-keyword">if</span> (L == R) &#123; <span class="hljs-comment">// arr[L..R]范围上只有一个数，直接返回，base case</span>
        <span class="hljs-keyword">return</span> arr[L];
    &#125;
    <span class="hljs-keyword">int</span> mid = L + ((R - L) &gt;&gt; <span class="hljs-number">1</span>); <span class="hljs-comment">// 中点    1</span>
    <span class="hljs-keyword">int</span> leftMax = process(arr, L, mid);
    <span class="hljs-keyword">int</span> rightMax = process(arr, mid + <span class="hljs-number">1</span>, R);
    <span class="hljs-keyword">return</span> Math.max(leftMax, rightMax);
&#125;</code></pre>



<h3 id="递归的脑图和实际实现"><a href="#递归的脑图和实际实现" class="headerlink" title="递归的脑图和实际实现"></a>递归的脑图和实际实现</h3><p>对于新手来说，把调用的过程画出结构图是必须的，这有利于分析递归</p>
<p>递归并不是玄学，递归底层是利用系统栈来实现的</p>
<p>任何递归函数都一定可以改成非递归</p>
<h3 id="Master公式"><a href="#Master公式" class="headerlink" title="Master公式"></a>Master公式</h3><blockquote>
<p>形如T(N) = a * T(N/b) + O(N^d)(其中的a、b、d都是常数)的递归函数，可以直接通过Master公式来确定时间复杂度, a次子问题规模(总问题是子问题的b倍规模)</p>
</blockquote>
<p>以b为底, logb(a)</p>
<p>如果 log(b,a) &lt; d，复杂度为O(N^d)<br>如果 log(b,a) &gt; d，复杂度为O(N^log(b,a))<br>如果 log(b,a) == d，复杂度为O(N^d  * logN)</p>
<p>上述算法中, 把数组分成两份, 每份1/2, 其他时间复杂度为O(1)</p>
<p>T(N) = 2 * T(N/2) + O(N^0) 即O(N), 与从左往右遍历一遍是一样的</p>
<p>如果左边2/3, 右边也2/3, 也是两份, 其他再打印一次, 时间复杂度为O(n)</p>
<p>T(N) = 2 * T(N/(3/2)) + O(N^1)</p>
<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>1)哈希表在使用层面上可以理解为一种集合结构<br>2)如果只有key，没有伴随数据value，可以使用 <strong><em>HashSet</em></strong>结构<br>3)如果既有key，又有伴随数据value，可以使用 <strong><em>HashMap</em></strong>结构<br>4) <strong><em>有无伴随数据，是HashMap和HashSet唯一的区别，实际结构是一回事</em></strong><br>5)使用哈希表增(put)、删(remove)、改(put)和查(get)的操作，可以认为时间复杂度为 O(1)，但是 <strong><em>常数时间</em></strong>比较大<br>6)放入哈希表的东西，如果是基础类型， <strong><em>内部按值传递</em></strong>，内存占用是这个东西的大小 </p>
<pre><code class="hljs java"><span class="hljs-keyword">int</span> a = <span class="hljs-number">100000</span>;
<span class="hljs-keyword">int</span> b = <span class="hljs-number">100000</span>;
<span class="hljs-comment">// 不关心内存区域, 只关心对应的值</span>
System.out.println(a == b);
Integer c = <span class="hljs-number">100000</span>;
Integer d = <span class="hljs-number">100000</span>;
<span class="hljs-comment">// 关心内存区域</span>
System.out.println(c.equals(d));
Integer e = <span class="hljs-number">127</span>;  <span class="hljs-comment">//  - 128  ~  127 true, 按值传递</span>
Integer f = <span class="hljs-number">127</span>;
System.out.println(e == f);

<span class="hljs-comment">// 但是在哈希表中, 基础类型, 内部都按值传递</span></code></pre>



<p>7)放入哈希表的东西，如果不是基础类型， <strong><em>内部按引用传递</em></strong>，内存占用是8字节</p>
<pre><code class="hljs java">HashMap&lt;Node, String&gt; map2 = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
Node node1 = <span class="hljs-keyword">new</span> Node(<span class="hljs-number">1</span>);
Node node2 = node1;
map2.put(node1, <span class="hljs-string">&quot;我是node1&quot;</span>);
map2.put(node2, <span class="hljs-string">&quot;我是node1&quot;</span>);
System.out.println(map2.size());
<span class="hljs-comment">// 结果为 1</span></code></pre>

<pre><code class="hljs java">HashMap&lt;Node, String&gt; map2 = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
Node node1 = <span class="hljs-keyword">new</span> Node(<span class="hljs-number">1</span>);
Node node2 = <span class="hljs-keyword">new</span> Node(<span class="hljs-number">2</span>);
map2.put(node1, <span class="hljs-string">&quot;我是node1&quot;</span>);
map2.put(node2, <span class="hljs-string">&quot;我是node1&quot;</span>);
System.out.println(map2.size());
<span class="hljs-comment">// 结果为 2</span></code></pre>



<pre><code class="hljs processing">即如果<span class="hljs-keyword">HashMap</span>&lt;<span class="hljs-keyword">String</span>, <span class="hljs-keyword">String</span>&gt; <span class="hljs-built_in">map</span> = <span class="hljs-keyword">new</span> <span class="hljs-keyword">HashMap</span>&lt;&gt;();
<span class="hljs-built_in">key</span>和value都传<span class="hljs-number">100</span>位数据, 最终数据占用为 <span class="hljs-number">4</span> * <span class="hljs-number">100</span> * <span class="hljs-number">2</span>
但如果<span class="hljs-keyword">HashMap</span>&lt;Node, Node&gt; map2 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">HashMap</span>&lt;&gt;();
<span class="hljs-built_in">key</span>和value都传<span class="hljs-number">20</span>g数据, <span class="hljs-built_in">map</span>中只存内存地址<span class="hljs-number">8</span>字节, <span class="hljs-number">4</span> * <span class="hljs-number">8</span> * <span class="hljs-number">2</span>字节大小完成操作</code></pre>



<h2 id="有序表-TreeMap-O-logN"><a href="#有序表-TreeMap-O-logN" class="headerlink" title="有序表(TreeMap) O(logN)"></a>有序表(TreeMap) O(logN)</h2><p>1)有序表在使用层面上可以理解为一种集合结构<br>2)如果只有key，没有伴随数据value，可以使用TreeSet结构<br>3)如果既有key，又有伴随数据value，可以使用TreeMap结构<br>4)有无伴随数据，是TreeSet和TreeMap唯一的区别，底层的实际结构是一回事<br>5) <strong><em>有序表把key按照顺序组织起来，而哈希表完全不组织</em></strong></p>
<pre><code class="hljs java">System.out.println(treeMap.firstKey());
System.out.println(treeMap.lastKey());

<span class="hljs-comment">// &lt;= 4</span>
System.out.println(treeMap.floorKey(<span class="hljs-number">4</span>));
<span class="hljs-comment">// &gt;= 4</span>
System.out.println(treeMap.ceilingKey(<span class="hljs-number">4</span>));</code></pre>

<ol start="6">
<li><strong><em>红黑树</em></strong>、 <strong><em>AVL树</em></strong>、 <strong><em>size-balance-tree</em></strong>和 <strong><em>跳表</em></strong>等都属于 <strong><em>有序表</em></strong>结构，只是底层具体实现不同</li>
<li>放入如果是基础类型，内部按值传递，内存占用就是这个东西的大小</li>
<li>放入如果不是基础类型，内部按引用传递，内存占用是8字节</li>
<li>不管是什么底层具体实现，只要是有序表，都有以下固定的基本功能和固定的时间复杂度 </li>
</ol>
<blockquote>
<p>Api</p>
</blockquote>
<p>1)void put(K key, V value)<br>将一个(key，value)记录加入到表中，或者将key的记录 更新成value。<br>2)V get(K key)<br>根据给定的key，查询value并返回。<br>3)void remove(K key)<br>移除key的记录。<br>4)boolean containsKey(K key)<br>询问是否有关于key的记录。</p>
<p>5)K firstKey()<br>返回所有键值的排序结果中，最小的那个。6)K lastKey()<br>返回所有键值的排序结果中，最大的那个。7)K floorKey(K key)<br>返回&lt;= key 离key最近的那个<br>8)K ceilingKey(K key）<br>返回&gt;= key 离key最近的那个</p>
<blockquote>
<p>哈希表在使用时，增删改查时间复杂度都是O(1)<br>有序表在使用时，比哈希表功能多，时间复杂度都是O(logN)</p>
</blockquote>
<h1 id="归并排序与随机快排"><a href="#归并排序与随机快排" class="headerlink" title="归并排序与随机快排"></a>归并排序与随机快排</h1><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><blockquote>
<p>1）整体是递归，左边排好序+右边排好序+merge让整体有序</p>
</blockquote>
<p>例子: [3, 1, 2, 4]</p>
<p>主函数: f(0, 3) </p>
<p>运行后process(0,1) 再 process(2, 3) 再merge</p>
<p>而运行process(0,1) 需要process(0,0)再process(1,1)再merge</p>
<p>运行process(2, 3)需要process(2, 2)再process(3, 3)再merge</p>
<h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><pre><code class="hljs java"><span class="hljs-comment">// 递归方法实现</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mergeSort1</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span></span>&#123;
    <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length &lt; <span class="hljs-number">2</span>) &#123;
        <span class="hljs-keyword">return</span>;
    &#125;

    process(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>);
&#125;
<span class="hljs-comment">// 让arr L - R范围变成有序</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R)</span></span>&#123;
    <span class="hljs-keyword">if</span> (L == R)&#123; <span class="hljs-comment">// base case</span>
        <span class="hljs-keyword">return</span>;
    &#125;
    <span class="hljs-keyword">int</span> mid = L + (( R - L ) &gt;&gt; <span class="hljs-number">2</span>);
    process(arr, L, mid);
    process(arr, mid + <span class="hljs-number">1</span>, R);
    merge(arr, L, mid, R);
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span>  <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> M, <span class="hljs-keyword">int</span> R)</span></span>&#123;
    <span class="hljs-keyword">int</span>[] help = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[R - L + <span class="hljs-number">1</span>];
    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; <span class="hljs-comment">// help数组的指针</span>
    <span class="hljs-keyword">int</span> p1 = L; <span class="hljs-comment">// 左部分指针</span>
    <span class="hljs-keyword">int</span> p2 = M + <span class="hljs-number">1</span>; <span class="hljs-comment">// 又部分指针</span>

    <span class="hljs-keyword">while</span> (p1 &lt;= M &amp;&amp; p2 &lt;= R)&#123;
        help[i++] = arr[p1] &lt;= arr[p2] ? arr[p1++] : arr[p2++];
    &#125;
    <span class="hljs-comment">// 要么p1越界, 要么p2越界</span>
    <span class="hljs-keyword">while</span> (p1 &lt;= M)&#123;
        help[i++] = arr[p1++];
    &#125;
    <span class="hljs-keyword">while</span> (p2 &lt;= R)&#123;
        help[i++] = arr[p2++];
    &#125;

    <span class="hljs-comment">// 把help的值赋值回去</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; help.length ; j++) &#123;
        arr[L + i] = help[i];
    &#125;
&#125;</code></pre>

<h3 id="非递归实现"><a href="#非递归实现" class="headerlink" title="非递归实现"></a>非递归实现</h3><p>例子[2, 3, 1, 4, 5, 6]</p>
<p>初始k = 1, 每个最小原子单元, 即每个数自我有序,</p>
<p>K &lt;&lt; 2, 每两个一组进行merge, 变成[2, 3, 1, 4, 5, 6]</p>
<p>K &lt;&lt; 2, 每四个一组进行merge, 不够则凑一组[1, 2, 3, 4, 5, 6]</p>
<p>直到k &gt;= N</p>
<pre><code class="hljs java"><span class="hljs-comment">// 非递归方法实现</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mergeSort2</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length &lt; <span class="hljs-number">2</span>) &#123;
      <span class="hljs-keyword">return</span>;
   &#125;
   <span class="hljs-keyword">int</span> N = arr.length;
   <span class="hljs-keyword">int</span> mergeSize = <span class="hljs-number">1</span>;<span class="hljs-comment">// 一组是两倍的mergeSize, 当前有序的左组长度</span>
   <span class="hljs-keyword">while</span> (mergeSize &lt; N) &#123;
      <span class="hljs-keyword">int</span> L = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">while</span> (L &lt; N) &#123;
         <span class="hljs-comment">// L...M 左组(mergeSize大小)</span>
         <span class="hljs-comment">// 求中间</span>
         <span class="hljs-keyword">int</span> M = L + mergeSize - <span class="hljs-number">1</span>;
         <span class="hljs-keyword">if</span> (M &gt;= N) &#123;
            <span class="hljs-keyword">break</span>;
         &#125;
         <span class="hljs-comment">// L...M   M+1...R</span>
         <span class="hljs-comment">// 右组可能凑不齐mergeSize个</span>
         <span class="hljs-comment">// 求右边</span>
         <span class="hljs-keyword">int</span> R = Math.min(M + mergeSize, N - <span class="hljs-number">1</span>);
         merge(arr, L, M, R);
         <span class="hljs-comment">// 算下一次左边</span>
         L = R + <span class="hljs-number">1</span>;
      &#125;
      
      <span class="hljs-comment">// 防止溢出</span>
      <span class="hljs-keyword">if</span> (mergeSize &gt; N / <span class="hljs-number">2</span>) &#123;
         <span class="hljs-keyword">break</span>;
      &#125;
      mergeSize &lt;&lt;= <span class="hljs-number">1</span>;
   &#125;
&#125;</code></pre>

<h3 id="利用master公式来求解时间复杂度"><a href="#利用master公式来求解时间复杂度" class="headerlink" title="利用master公式来求解时间复杂度"></a>利用master公式来求解时间复杂度</h3><pre><code class="hljs mathematica"><span class="hljs-variable">T</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span><span class="hljs-operator">*</span><span class="hljs-variable">T</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-operator">/</span><span class="hljs-number">2</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">+</span> <span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-operator">^</span><span class="hljs-number">1</span><span class="hljs-punctuation">)</span>

根据<span class="hljs-variable">master</span>可知时间复杂度为<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-operator">*</span><span class="hljs-variable">logN</span><span class="hljs-punctuation">)</span>
<span class="hljs-punctuation">(</span>非递归分析<span class="hljs-operator">:</span>每次<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span> <span class="hljs-number">2</span><span class="hljs-operator">,</span> <span class="hljs-number">4</span><span class="hljs-operator">,</span> <span class="hljs-number">8</span><span class="hljs-operator">,</span> <span class="hljs-number">16</span> <span class="hljs-operator">....</span> <span class="hljs-built_in">N</span> <span class="hljs-operator">,</span> <span class="hljs-built_in">Log</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-punctuation">)</span>次<span class="hljs-operator">,</span> 所以<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-operator">*</span><span class="hljs-variable">logN</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">)</span>
<span class="hljs-variable">merge</span>过程需要辅助数组，所以额外空间复杂度为<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-punctuation">)</span>

归并排序的实质是把比较行为变成了有序信息并传递，比<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-operator">^</span><span class="hljs-number">2</span><span class="hljs-punctuation">)</span>的排序快

<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-operator">^</span><span class="hljs-number">2</span><span class="hljs-punctuation">)</span>在无限浪费比较行为<span class="hljs-operator">,</span> 例如选择排序<span class="hljs-operator">,</span> 每次都与后面比较大小</code></pre>



<h3 id="用常见面试题再深入理解一下归并排序的精髓"><a href="#用常见面试题再深入理解一下归并排序的精髓" class="headerlink" title="用常见面试题再深入理解一下归并排序的精髓"></a>用常见面试题再深入理解一下归并排序的精髓</h3><blockquote>
<p> 在一个数组中，一个数左边比它小的数的总和，叫数的小和，所有数的小和累加起来，叫数组小和。求数组小和。</p>
</blockquote>
<p>例子： [1,3,4,2,5]<br>1左边比1小的数：没有<br>3左边比3小的数：1<br>4左边比4小的数：1、3<br>2左边比2小的数：1<br>5左边比5小的数：1、3、4、 2<br>所以数组的小和为1+1+3+1+1+3+4+2=16 </p>
<p>每次merge时, 两个指针对应的数比较大小, 如果小, 则计算另外一个指针包括当前位置以后的有多少个比对方大的数字.</p>
<pre><code class="hljs css">例子:
<span class="hljs-selector-attr">[1,3,4,2,5]</span> 分为<span class="hljs-selector-attr">[1,3]</span>和<span class="hljs-selector-attr">[4,2,5]</span>
<span class="hljs-selector-attr">[1]</span> <span class="hljs-selector-attr">[3]</span><span class="hljs-selector-tag">merge</span>时, 1比3小, 1个1
<span class="hljs-selector-attr">[4,2,5]</span>分为<span class="hljs-selector-attr">[4]</span>,<span class="hljs-selector-attr">[2, 5]</span>
<span class="hljs-selector-attr">[4]</span><span class="hljs-selector-tag">merge</span>, <span class="hljs-selector-tag">return</span> 0
<span class="hljs-selector-attr">[2, 5]</span><span class="hljs-selector-tag">merge</span>时候, 2比5小, 1个2
<span class="hljs-selector-attr">[4]</span>与<span class="hljs-selector-attr">[2,5]</span><span class="hljs-selector-tag">merge</span>时候, 左指针初始4, 右指针初始2, 4 &gt; 2, <span class="hljs-selector-tag">help</span>数组放入2, 右指针右移
4 &lt; 5, 1个4,<span class="hljs-selector-tag">help</span>数组放入4,越界,放入5
<span class="hljs-selector-attr">[1,3]</span>和<span class="hljs-selector-attr">[2,4,5]</span><span class="hljs-selector-tag">merge</span>, 1&lt;2, 3个1, 3&lt;4, 2个3
结束4个1, 1个2, 2个3, 1个4,</code></pre>

<blockquote>
<p>其实就是在左指针与右指针对比时, 加上右指针开始个大于左指针数(利用右边有序)的左指针当前数</p>
<p>result += arr[p1] &lt; arr[p2] ? arr[p1] * (R - p2 + 1) : 0;</p>
<p>也可以解决降序对的问题</p>
<p>只要纠结右边有多少个数比左边大这类的问题，都可以用归并</p>
</blockquote>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">smallNum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[])</span></span>&#123;
    <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length &lt; <span class="hljs-number">2</span>)&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    &#125;

    <span class="hljs-keyword">return</span> process(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>);
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">process</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R)</span></span>&#123;
    <span class="hljs-keyword">if</span> (L == R)&#123;
        <span class="hljs-comment">// 只有一个数, 右组都没有</span>
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    &#125;

    <span class="hljs-keyword">int</span> mid = L + ((R - L) &gt;&gt; <span class="hljs-number">2</span>);
    <span class="hljs-keyword">return</span> process(arr, L, mid) + process(arr, mid + <span class="hljs-number">1</span>, R) + merge(arr, L, mid, R);
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> mid, <span class="hljs-keyword">int</span> R)</span></span>&#123;
    <span class="hljs-keyword">int</span> help[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[R - L + <span class="hljs-number">1</span>];
    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> p1 = L;
    <span class="hljs-keyword">int</span> p2 = mid + <span class="hljs-number">1</span>;
    <span class="hljs-keyword">int</span> result = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">while</span> (p1 &lt;= mid &amp;&amp; p2 &lt;= R)&#123;
        result += arr[p1] &lt; arr[p2] ? arr[p1] * (R - p2 + <span class="hljs-number">1</span>) : <span class="hljs-number">0</span>;
        help[i++] = arr[p1] &lt; arr[p2] ? arr[p1++] : arr[p2++];
    &#125;
    <span class="hljs-keyword">while</span> (p1 &lt;= mid)&#123;
        help[i++] = arr[p1++];
    &#125;
    <span class="hljs-keyword">while</span> (p2 &lt;= R)&#123;
        help[i++] = arr[p2++];
    &#125;
    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; help.length; i++) &#123;
        arr[L + i] = help[i];
    &#125;
    <span class="hljs-keyword">return</span> result;
&#125;</code></pre>

<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="Partition过程"><a href="#Partition过程" class="headerlink" title="Partition过程"></a>Partition过程</h3><blockquote>
<p>给定一个数组arr，和一个整数num。请把小于等于num的数放在数组的左边，大于num的数放在数组的右边。<br>要求额外空间复杂度O(1)，时间复杂度O(N) </p>
</blockquote>
<p>设置一个 <strong><em>小于等于区</em></strong>, 设初始位置 -1, </p>
<ol>
<li><p>[i]&lt;=num,当前数和小于等于区下一个位置交换, 小于等于区右扩, i++</p>
</li>
<li><p>[i]&gt;num, i++</p>
</li>
</ol>
<p>例子: [5, 3, 7, 2] num = 3</p>
<p>一开始小于等于区位置 -1, i=0, i[0]=5 &gt; 3, i++, 跳到3, 3&lt;=num, 与小于等于区下一个数即i[0]交换</p>
<p>变成[3, 5, 7, 2]小于等于区右扩, 初始位置为0, 逐步下去</p>
<pre><code class="hljs java"><span class="hljs-comment">// 以arr[R]做划分值</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (L &gt; R) &#123;
      <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
   &#125;
   <span class="hljs-keyword">if</span> (L == R) &#123;
      <span class="hljs-keyword">return</span> L;
   &#125;
   <span class="hljs-keyword">int</span> lessEqual = L - <span class="hljs-number">1</span>;
   <span class="hljs-keyword">int</span> index = L;
   <span class="hljs-keyword">while</span> (index &lt; R) &#123;
      <span class="hljs-keyword">if</span> (arr[index] &lt;= arr[R]) &#123;
         swap(arr, index, ++lessEqual);
      &#125;
      index++;
   &#125;
   swap(arr, ++lessEqual, R);
   <span class="hljs-keyword">return</span> lessEqual;
&#125;</code></pre>

<h3 id="荷兰国旗问题"><a href="#荷兰国旗问题" class="headerlink" title="荷兰国旗问题"></a>荷兰国旗问题</h3><blockquote>
<p>给定一个数组arr，和一个整数num。请把小于num的数放在数组的左边，等于num的数放在中间，大于num的数放在数组的右边。</p>
<p>要求额外空间复杂度O(1)，时间复杂度O(N)  </p>
</blockquote>
<p>设置一个 <strong><em>小于区</em></strong>,设初始位置 -1 ;  设置一个 <strong><em>大于区</em></strong>,设初始位置 length -1</p>
<ol>
<li><p>[i] == num, i++</p>
</li>
<li><p>[i] &lt; num, [i] 与小于区下一个交换, 小于区右扩, i++</p>
</li>
<li><p>[i] &gt; num, [i] 与大于区左一个交换, 大于区左扩, i <strong><em>停在原地</em></strong></p>
</li>
</ol>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201129162221.png" srcset="/img/loading.gif" alt="流程图"></p>
<p>i与大于区边界撞上的时候停</p>
<pre><code class="hljs java"><span class="hljs-comment">// arr[L...R] 玩荷兰国旗问题的划分，以arr[R]做划分值</span>
<span class="hljs-comment">//  &lt;arr[R]  ==arr[R]  &gt; arr[R]</span>
<span class="hljs-comment">// 返回等于区域范围</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] netherlandsFlag(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R) &#123;
   <span class="hljs-keyword">if</span> (L &gt; R) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123; -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span> &#125;;
   &#125;
   <span class="hljs-keyword">if</span> (L == R) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123; L, R &#125;;
   &#125;
   <span class="hljs-keyword">int</span> less = L - <span class="hljs-number">1</span>; <span class="hljs-comment">// &lt; 区 右边界</span>
   <span class="hljs-keyword">int</span> more = R;     <span class="hljs-comment">// &gt; 区 左边界</span>
   <span class="hljs-keyword">int</span> index = L;
   <span class="hljs-keyword">while</span> (index &lt; more) &#123;
      <span class="hljs-keyword">if</span> (arr[index] == arr[R]) &#123;
         index++;
      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[index] &lt; arr[R]) &#123;
         swap(arr, index++, ++less);
      &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// &gt;</span>
         swap(arr, index, --more);
      &#125;
   &#125;
   <span class="hljs-comment">// L...Less 小于区 less+1...more-1 等于区 more...R-1 大于区  R没动过</span>
   <span class="hljs-comment">// 交换后</span>
   <span class="hljs-comment">// L...Less 小于区 less+1.....more 等于区 more+1...R 大于区</span>
   swap(arr, more, R);
   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123; less + <span class="hljs-number">1</span>, more &#125;;
&#125;</code></pre>

<h2 id="快速排序1-0"><a href="#快速排序1-0" class="headerlink" title="快速排序1.0"></a>快速排序1.0</h2><p>在arr[L..R]范围上，进行快速排序的过程：<br>1）用arr[R]对该范围做partition，&lt;= arr[R]的数在左部分并且保证arr[R]最后来到左部分小于区的最后一个位置，记为M； &lt;= arr[R]的数在右部分（arr[M+1..R]）,此时X就已经排好序了<br>2）对arr[L..M-1]进行快速排序(递归)<br>3）对arr[M+1..R]进行快速排序(递归)<br>因为每一次partition都会搞定一个数的位置且不会再变动，所以排序能完成</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quickSort1</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length &lt; <span class="hljs-number">2</span>) &#123;
      <span class="hljs-keyword">return</span>;
   &#125;
   process1(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>);
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process1</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (L &gt;= R) &#123;
      <span class="hljs-keyword">return</span>;
   &#125;
   <span class="hljs-comment">// L..R partition arr[R]  [   &lt;=arr[R]   arr[R]    &gt;arr[R]  ]</span>
   <span class="hljs-keyword">int</span> M = partition(arr, L, R);
   process1(arr, L, M - <span class="hljs-number">1</span>);
   process1(arr, M + <span class="hljs-number">1</span>, R);
&#125;</code></pre>



<h2 id="快速排序2-0"><a href="#快速排序2-0" class="headerlink" title="快速排序2.0"></a>快速排序2.0</h2><p>在arr[L..R]范围上，进行快速排序的过程：<br>1）用arr[R]对该范围做partition，&lt; arr[R]的数在左部分，== arr[R]的数中间，&gt;arr[R]的数在右部分。假设== arr[R]的数所在范围是[a,b]<br>2）对arr[L..a-1]进行快速排序(递归)<br>3）对arr[b+1..R]进行快速排序(递归)<br>因为每一次partition都会搞定一批数的位置且不会再变动，所以排序能完成</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quickSort2</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length &lt; <span class="hljs-number">2</span>) &#123;
      <span class="hljs-keyword">return</span>;
   &#125;
   process2(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>);
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process2</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (L &gt;= R) &#123;
      <span class="hljs-keyword">return</span>;
   &#125;
   <span class="hljs-keyword">int</span>[] equalArea = netherlandsFlag(arr, L, R);
   process2(arr, L, equalArea[<span class="hljs-number">0</span>] - <span class="hljs-number">1</span>);
   process2(arr, equalArea[<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>, R);
&#125;</code></pre>

<h2 id="快速排序1-0和2-0的时间复杂度分析"><a href="#快速排序1-0和2-0的时间复杂度分析" class="headerlink" title="快速排序1.0和2.0的时间复杂度分析"></a>快速排序1.0和2.0的时间复杂度分析</h2><blockquote>
<p>数组已经有序的时候就是复杂度最高的时候<br>时间复杂度O(N^2)</p>
</blockquote>
<h2 id="快速排序3-0-随机快排-荷兰国旗技巧优化"><a href="#快速排序3-0-随机快排-荷兰国旗技巧优化" class="headerlink" title="快速排序3.0(随机快排+荷兰国旗技巧优化)"></a>快速排序3.0(随机快排+荷兰国旗技巧优化)</h2><p>在arr[L..R]范围上，进行快速排序的过程：<br>1）在这个范围上，随机选一个数记为num，<br>1）用num对该范围做partition，&lt; num的数在左部分，== num的数中间，&gt;num的数在右部分。假设== num的数所在范围是[a,b]<br>2）对arr[L..a-1]进行快速排序(递归)<br>3）对arr[b+1..R]进行快速排序(递归)<br>因为每一次partition都会搞定一批数的位置且不会再变动，所以排序能完成</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quickSort3</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length &lt; <span class="hljs-number">2</span>) &#123;
      <span class="hljs-keyword">return</span>;
   &#125;
   process3(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>);
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process3</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (L &gt;= R) &#123;
      <span class="hljs-keyword">return</span>;
   &#125;
   <span class="hljs-comment">// 1、2拿arr[R]做划分值</span>
   <span class="hljs-comment">// 3 随机选一个i, 人为放到arr[R], 再以arr[R]做划分值</span>
   swap(arr, L + (<span class="hljs-keyword">int</span>) (Math.random() * (R - L + <span class="hljs-number">1</span>)), R);
   <span class="hljs-keyword">int</span>[] equalArea = netherlandsFlag(arr, L, R);
   process3(arr, L, equalArea[<span class="hljs-number">0</span>] - <span class="hljs-number">1</span>);
   process3(arr, equalArea[<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>, R);
&#125;</code></pre>

<pre><code class="hljs apache"><span class="hljs-attribute">1</span>）通过分析知道，划分值越靠近中间，性能越好；越靠近两边，性能越差
<span class="hljs-attribute">2</span>）随机选一个数进行划分的目的就是让好情况和差情况都变成概率事件
<span class="hljs-attribute">3</span>）把每一种情况都列出来，会有每种情况下的时间复杂度，但概率都是<span class="hljs-number">1</span>/N
<span class="hljs-attribute">4</span>）那么所有情况都考虑，时间复杂度就是这种概率模型下的长期期望！</code></pre>


<p> *<strong>时间复杂度O(N<em>logN)，额外空间复杂度O(logN)都是这么来的。</em></strong></p>
<h1 id="比较器与堆"><a href="#比较器与堆" class="headerlink" title="比较器与堆"></a>比较器与堆</h1><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><h3 id="堆的实现"><a href="#堆的实现" class="headerlink" title="堆的实现"></a>堆的实现</h3><p>堆结构</p>
<p>1）堆结构就是用数组实现的完全二叉树结构</p>
<blockquote>
<p>完全二叉树是什么</p>
</blockquote>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201201131244.png" srcset="/img/loading.gif" alt="完全二叉树"></p>
<blockquote>
<p>结点从左至右变满, 一个结点也是, 两个结点, 第二个结点在左边也是</p>
</blockquote>
<p>堆可以从数组arr[0]开始, 也可以从arr[1]开始, 为什么会出现从arr[1]开始的情况？</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201201131532.png" srcset="/img/loading.gif" alt="arr[1]开始的堆"></p>
<p><strong>如图所示, 如果堆从arr[1]开始增加, 子结点以及父节点的运算都可以用位运算, 位运算就是快！</strong></p>
<p>2）完全二叉树中如果每棵子树的最大值都在顶部就是大根堆</p>
<blockquote>
<p>头结点为头的树, 最大值为头结点</p>
</blockquote>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201201131811.png" srcset="/img/loading.gif" alt="大根堆"></p>
<p>3）完全二叉树中如果每棵子树的最小值都在顶部就是小根堆</p>
<blockquote>
<p>头结点为头的树, 最小值为头结点</p>
</blockquote>
<p>4）堆结构的heapInsert与heapify操作</p>
<blockquote>
<p>heapInsert: 数放入数组后, 与父节点比较, 如果数更大, 交换, 直到换到根结点</p>
</blockquote>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span></span>&#123;
    <span class="hljs-keyword">if</span> (heapSize &gt; limit)&#123;
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;heap is full!&quot;</span>);
    &#125;
    heap[heapSize] = value;
    heapInsert(heap, heapSize++);
&#125;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 把默认最后加进来的数往上提</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@param</span> arr</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@param</span> index</span>
<span class="hljs-comment"> * arr[index] &gt; arr[(index - 1) / 2]已经包含两个条件</span>
<span class="hljs-comment"> * 1)arr[index] 不比arr[index父]大, 停</span>
<span class="hljs-comment"> * 2)index = 0, 停</span>
<span class="hljs-comment"> */</span>
<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">heapInsert</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> index)</span></span>&#123;
    <span class="hljs-keyword">while</span> (arr[index] &gt; arr[(index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>])&#123;
        swap(arr, index, (index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>);
        index = (index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;
    &#125;
&#125;</code></pre>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201201133318.png" srcset="/img/loading.gif" alt="heapInsert"></p>
<pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 删除堆的最大值并返回, 重组堆</span>
<span class="hljs-comment"> * 用最后的值去顶替arr[0]</span>
<span class="hljs-comment"> * 再往下交换, 找到左孩子与右孩子之间更大的数, 如果更小, 则交换</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span>
<span class="hljs-comment"> */</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>&#123;
    <span class="hljs-keyword">int</span> ans = heap[<span class="hljs-number">0</span>];
    <span class="hljs-comment">// -- heapSize, 之后的数据进入无效区</span>
    swap(heap, <span class="hljs-number">0</span>, -- heapSize);
    heapify(heap, <span class="hljs-number">0</span>, heapSize);
    <span class="hljs-keyword">return</span> ans;
&#125;

<span class="hljs-comment">// 从index的位置往下看, 不断的下沉</span>
<span class="hljs-comment">// 1) 孩子都不比我大 停; 2) 已经没孩子了, 停</span>
<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">heapify</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> heapSize)</span></span>&#123;
    <span class="hljs-keyword">int</span> left = index * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;
    <span class="hljs-comment">// 左孩子不越界就肯定有孩子</span>
    <span class="hljs-keyword">while</span> (left &lt; heapSize)&#123;
        <span class="hljs-comment">// 再判断有没有右孩子</span>
        <span class="hljs-comment">// 右孩子更大的条件是: 有右孩子 &amp;&amp; 右孩子大于左孩子</span>
        <span class="hljs-keyword">int</span> largest = left + <span class="hljs-number">1</span> &lt; heapSize &amp;&amp; arr[left + <span class="hljs-number">1</span>] &gt; arr[left] ? left + <span class="hljs-number">1</span> : left;
        largest = arr[largest] &gt; arr[index] ? largest : index;
        <span class="hljs-comment">// 如果index更大, 则不用下坠</span>
        <span class="hljs-keyword">if</span> (largest == index)&#123;
            <span class="hljs-keyword">break</span>;
        &#125;
        swap(arr, index, largest);
        index = largest;
        left = index * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;
    &#125;
&#125;</code></pre>

<p>5）堆结构的增大和减少<br>6）优先级队列结构，就是堆结构(小根堆)</p>
<pre><code class="hljs java">PriorityQueue&lt;Integer&gt; heap = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;(<span class="hljs-keyword">new</span> MyComp());</code></pre>

<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><blockquote>
<p>先把数组数据变为大根堆结构, 再每次arr[0]与堆最后一个结点互换, 必定会把Max丢到最后, 再heapify</p>
</blockquote>
<pre><code class="hljs java"><span class="hljs-comment">// 堆排序额外空间复杂度O(1)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">heapSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length &lt; <span class="hljs-number">2</span>) &#123;
            <span class="hljs-keyword">return</span>;
        &#125;
        <span class="hljs-comment">// O(N*logN)</span>
<span class="hljs-comment">//    for (int i = 0; i &lt; arr.length; i++) &#123; // O(N)</span>
<span class="hljs-comment">//       heapInsert(arr, i); // O(logN)</span>
<span class="hljs-comment">//    &#125;</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = arr.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;
            heapify(arr, i, arr.length);
        &#125;
        <span class="hljs-keyword">int</span> heapSize = arr.length;
        swap(arr, <span class="hljs-number">0</span>, --heapSize);
        <span class="hljs-comment">// O(N*logN)</span>
        <span class="hljs-keyword">while</span> (heapSize &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// O(N)</span>
            heapify(arr, <span class="hljs-number">0</span>, heapSize); <span class="hljs-comment">// O(logN)</span>
            swap(arr, <span class="hljs-number">0</span>, --heapSize); <span class="hljs-comment">// O(1)</span>
        &#125;
    &#125;

    <span class="hljs-comment">// arr[index]刚来的数，往上</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">heapInsert</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> index)</span> </span>&#123;
        <span class="hljs-keyword">while</span> (arr[index] &gt; arr[(index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>]) &#123;
            swap(arr, index, (index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>);
            index = (index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;
        &#125;
    &#125;

    <span class="hljs-comment">// arr[index]位置的数，能否往下移动</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">heapify</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> heapSize)</span> </span>&#123;
        <span class="hljs-keyword">int</span> left = index * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>; <span class="hljs-comment">// 左孩子的下标</span>
        <span class="hljs-keyword">while</span> (left &lt; heapSize) &#123; <span class="hljs-comment">// 下方还有孩子的时候</span>
            <span class="hljs-comment">// 两个孩子中，谁的值大，把下标给largest</span>
            <span class="hljs-comment">// 1）只有左孩子，left -&gt; largest</span>
            <span class="hljs-comment">// 2) 同时有左孩子和右孩子，右孩子的值&lt;= 左孩子的值，left -&gt; largest</span>
            <span class="hljs-comment">// 3) 同时有左孩子和右孩子并且右孩子的值&gt; 左孩子的值， right -&gt; largest</span>
            <span class="hljs-keyword">int</span> largest = left + <span class="hljs-number">1</span> &lt; heapSize &amp;&amp; arr[left + <span class="hljs-number">1</span>] &gt; arr[left] ? left + <span class="hljs-number">1</span> : left;
            <span class="hljs-comment">// 父和较大的孩子之间，谁的值大，把下标给largest</span>
            largest = arr[largest] &gt; arr[index] ? largest : index;
            <span class="hljs-keyword">if</span> (largest == index) &#123;
                <span class="hljs-keyword">break</span>;
            &#125;
            swap(arr, largest, index);
            index = largest;
            left = index * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;
        &#125;
    &#125;</code></pre>

<pre><code class="hljs mathematica"><span class="hljs-number">1</span>，先让整个数组都变成大根堆结构，建立堆的过程<span class="hljs-operator">:</span> 
    <span class="hljs-number">1</span><span class="hljs-punctuation">)</span>从上到下的方法，时间复杂度为<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-operator">*</span><span class="hljs-variable">logN</span><span class="hljs-punctuation">)</span> 
    <span class="hljs-number">2</span><span class="hljs-punctuation">)</span>从下到上的方法，时间复杂度为<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-punctuation">)</span> 
<span class="hljs-number">2</span>，把堆的最大值和堆末尾的值交换，然后减少堆的大小之后，再去调整堆，一直周而复始，时间复杂度为<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-operator">*</span><span class="hljs-variable">logN</span><span class="hljs-punctuation">)</span> 
<span class="hljs-number">3</span>，堆的大小减小成<span class="hljs-number">0</span>之后，排序完成</code></pre>



<blockquote>
<p>堆排序优化</p>
</blockquote>
<pre><code class="hljs java"><span class="hljs-comment">// O(N*logN)</span>
<span class="hljs-comment">// 给定数据的数组,一个一个插入都可以</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123; <span class="hljs-comment">// O(N)</span>
   heapInsert(arr, i); <span class="hljs-comment">// O(logN)</span>
&#125;
      
<span class="hljs-comment">// O(N)</span>
<span class="hljs-comment">// 一定要给定数据数组, 一个一个插入无法使用</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = arr.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;
   heapify(arr, i, arr.length);
&#125;</code></pre>

<p>一个O(N*logN), 一个O(N)</p>
<p>怎么证明?</p>
<p>对于从数组最后开始heapify来说, 一颗N结点的树, 最后一层结点应该为N/2, 往上依次为N/4, N/8</p>
<p>最后一层只有”看”的操作, 倒数第二层有”看”和至多一次”换”的操作, 倒数第三层有”看”和至多两次”换”的操作</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201201135242.png" srcset="/img/loading.gif" alt="堆排序优化"></p>
<h2 id="堆问题"><a href="#堆问题" class="headerlink" title="堆问题"></a>堆问题</h2><blockquote>
<p>已知一个几乎有序的数组。几乎有序是指，如果把数组排好顺序的话，每个元素移动的距离一定不超过k，并且k相对于数组长度来说是比较小的。<br>请选择一个合适的排序策略，对这个数组进行排序。</p>
</blockquote>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201207140824.png" srcset="/img/loading.gif" alt="流程"></p>
<p>把前k+1个数放入小根堆, 例如0,1,2,3,4,5位置数放入小根堆, 0～5的数才可能来到0位置, 每排好一次序, 把最小值弹出放到0位置, 再把6位置放入小根堆, 再弹最小值…</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sortedArrDistanceLessK</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> k)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span>) &#123;
      <span class="hljs-keyword">return</span>;
   &#125;
   <span class="hljs-comment">// 默认小根堆</span>
   PriorityQueue&lt;Integer&gt; heap = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;();
   <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;
   <span class="hljs-comment">// 0...K-1</span>
   <span class="hljs-keyword">for</span> (; index &lt;= Math.min(arr.length - <span class="hljs-number">1</span>, k - <span class="hljs-number">1</span>); index++) &#123;
      heap.add(arr[index]);
   &#125;
   <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;
   <span class="hljs-comment">// 先加后弹</span>
   <span class="hljs-keyword">for</span> (; index &lt; arr.length; i++, index++) &#123;
      heap.add(arr[index]);
      arr[i] = heap.poll();
   &#125;
   <span class="hljs-comment">// 没有数可以加了 只弹</span>
   <span class="hljs-keyword">while</span> (!heap.isEmpty()) &#123;
      arr[i++] = heap.poll();
   &#125;
&#125;</code></pre>

<p>O(N*logK), 前提是k小于数组长度, 每次加减logk, N次则乘</p>
<h2 id="比较器"><a href="#比较器" class="headerlink" title="比较器"></a>比较器</h2><blockquote>
<p>目前都是基于 <strong>比较</strong> 的排序, 只要告诉两个样本如何比较大小就足够</p>
</blockquote>
<p>1)比较器的实质就是 **重载比较运算符 **</p>
<p>2)比较器可以很好的应用在 <strong>特殊标准的排序</strong>上 </p>
<p>3)比较器可以很好的应用在 <strong>根据特殊标准排序的结构</strong>上</p>
<p>4)写代码变得异常容易，还用于 <strong>范型编程</strong></p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;
   <span class="hljs-keyword">public</span> String name;
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> id;
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> age;

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> id, <span class="hljs-keyword">int</span> age)</span> </span>&#123;
      <span class="hljs-keyword">this</span>.name = name;
      <span class="hljs-keyword">this</span>.id = id;
      <span class="hljs-keyword">this</span>.age = age;
   &#125;
&#125;</code></pre>

<blockquote>
<p>comp(T o1, T o2) 返回负数o1放前, 正数o2放前</p>
</blockquote>
<pre><code class="hljs java">Student student1 = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-number">2</span>, <span class="hljs-number">20</span>);
Student student2 = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-number">3</span>, <span class="hljs-number">21</span>);
Student student3 = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">22</span>);

Student[] students = <span class="hljs-keyword">new</span> Student[] &#123; student1, student2, student3 &#125;;</code></pre>



<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IdAscendingComparator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparator</span>&lt;<span class="hljs-title">Student</span>&gt; </span>&#123;

   <span class="hljs-comment">// 返回负数的时候，第一个参数排在前面</span>
   <span class="hljs-comment">// 返回正数的时候，第二个参数排在前面</span>
   <span class="hljs-comment">// 返回0的时候，谁在前面无所谓</span>
   <span class="hljs-meta">@Override</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Student o1, Student o2)</span> </span>&#123;
      <span class="hljs-keyword">return</span> o1.id - o2.id;
   &#125;
&#125;
Arrays.sort(students, <span class="hljs-keyword">new</span> IdAscendingComparator());
<span class="hljs-comment">// id升序</span></code></pre>



<pre><code class="hljs java"><span class="hljs-comment">// 先按照id排序，id小的，放前面；</span>
<span class="hljs-comment">// id一样，age大的，前面；</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IdInAgeDe</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparator</span>&lt;<span class="hljs-title">Student</span>&gt; </span>&#123;

   <span class="hljs-meta">@Override</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Student o1, Student o2)</span> </span>&#123;
      <span class="hljs-keyword">return</span> o1.id != o2.id ? o1.id - o2.id  : (  o2.age - o1.age  );
   &#125;
<span class="hljs-comment">// 更复杂的比较器</span>
&#125;</code></pre>



<h3 id="应用在根据特殊标准排序的结构上"><a href="#应用在根据特殊标准排序的结构上" class="headerlink" title="应用在根据特殊标准排序的结构上"></a>应用在根据特殊标准排序的结构上</h3><pre><code class="hljs java">PriorityQueue&lt;Student&gt; minHeapBasedId
        = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;(<span class="hljs-keyword">new</span> AgeAscendingComparator());
minHeapBasedId.add(student1);
minHeapBasedId.add(student2);
minHeapBasedId.add(student3);
<span class="hljs-keyword">while</span> (!minHeapBasedId.isEmpty()) &#123;
    Student student = minHeapBasedId.poll();
    System.out.println(<span class="hljs-string">&quot;Name : &quot;</span> + student.name + <span class="hljs-string">&quot;, Id : &quot;</span> + student.id + <span class="hljs-string">&quot;, Age : &quot;</span> + student.age);
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AgeAscendingComparator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparator</span>&lt;<span class="hljs-title">Student</span>&gt; </span>&#123;
        <span class="hljs-meta">@Override</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Student o1, Student o2)</span> </span>&#123;
            <span class="hljs-keyword">return</span> o1.age - o2.age;
        &#125;
&#125;</code></pre>

<p>结果:</p>
<pre><code class="hljs asciidoc">
===========================
Name : A, Id : 2, Age : 20
Name : B, Id : 3, Age : 21
Name : C, Id : 1, Age : 22
===========================</code></pre>



<h2 id="语言提供的堆结构-vs-手写的堆结构"><a href="#语言提供的堆结构-vs-手写的堆结构" class="headerlink" title="语言提供的堆结构 vs 手写的堆结构"></a>语言提供的堆结构 vs 手写的堆结构</h2><p>取决于，你有没有动态改信息的需求！</p>
<p>语言提供的堆结构，如果你动态改数据，不保证依然有序</p>
<p>手写堆结构，因为增加了对象的位置表，所以能够满足动态改信息的需求</p>
<blockquote>
<p>例子</p>
</blockquote>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> classNo;
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> age;
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> id;

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(<span class="hljs-keyword">int</span> c, <span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> i)</span> </span>&#123;
      classNo = c;
      age = a;
      id = i;
   &#125;
&#125;</code></pre>

<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StudentComparator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparator</span>&lt;<span class="hljs-title">Student</span>&gt; </span>&#123;
   <span class="hljs-meta">@Override</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Student o1, Student o2)</span> </span>&#123;
      <span class="hljs-keyword">return</span> o1.age - o2.age;
   &#125;
&#125;</code></pre>

<pre><code class="hljs java">PriorityQueue&lt;Student&gt; heap = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;(<span class="hljs-keyword">new</span> StudentComparator());
heap.add(s1);
heap.add(s2);
heap.add(s3);
heap.add(s4);
heap.add(s5);
heap.add(s6);
<span class="hljs-keyword">while</span> (!heap.isEmpty()) &#123;
   Student cur = heap.poll();
   System.out.println(cur.classNo + <span class="hljs-string">&quot;,&quot;</span> + cur.age + <span class="hljs-string">&quot;,&quot;</span> + cur.id);
&#125;

System.out.println(<span class="hljs-string">&quot;===============&quot;</span>);</code></pre>

<pre><code class="hljs asciidoc">
6,10,33333
1,14,66666
3,20,44444
2,50,11111
1,60,22222
7,72,55555
===============</code></pre>

<pre><code class="hljs java">s1 = <span class="hljs-keyword">new</span> Student(<span class="hljs-number">2</span>, <span class="hljs-number">50</span>, <span class="hljs-number">11111</span>);
s2 = <span class="hljs-keyword">new</span> Student(<span class="hljs-number">1</span>, <span class="hljs-number">60</span>, <span class="hljs-number">22222</span>);
s3 = <span class="hljs-keyword">new</span> Student(<span class="hljs-number">6</span>, <span class="hljs-number">10</span>, <span class="hljs-number">33333</span>);
s4 = <span class="hljs-keyword">new</span> Student(<span class="hljs-number">3</span>, <span class="hljs-number">20</span>, <span class="hljs-number">44444</span>);
s5 = <span class="hljs-keyword">new</span> Student(<span class="hljs-number">7</span>, <span class="hljs-number">72</span>, <span class="hljs-number">55555</span>);
s6 = <span class="hljs-keyword">new</span> Student(<span class="hljs-number">1</span>, <span class="hljs-number">14</span>, <span class="hljs-number">66666</span>);

heap = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;(<span class="hljs-keyword">new</span> StudentComparator());

heap.add(s1);
heap.add(s2);
heap.add(s3);
heap.add(s4);
heap.add(s5);
heap.add(s6);
<span class="hljs-comment">// 加进去后 动态改已经加入堆里面的东西</span>
s2.age = <span class="hljs-number">6</span>;
s4.age = <span class="hljs-number">12</span>;
s5.age = <span class="hljs-number">10</span>;
s6.age = <span class="hljs-number">84</span>;

<span class="hljs-keyword">while</span> (!heap.isEmpty()) &#123;
    Student cur = heap.poll();
    System.out.println(cur.classNo + <span class="hljs-string">&quot;,&quot;</span> + cur.age + <span class="hljs-string">&quot;,&quot;</span> + cur.id);
&#125;</code></pre>

<pre><code class="hljs asciidoc">6,10,33333
3,12,44444
1,6,22222
7,10,55555
2,50,11111
1,84,66666
===============</code></pre>

<blockquote>
<p>自己设计某一个值会发生变化的堆</p>
</blockquote>
<pre><code class="hljs java"><span class="hljs-comment">// 堆</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyHeap</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;
    <span class="hljs-comment">// 没有 T[], 动态数组实现</span>
    <span class="hljs-keyword">private</span> ArrayList&lt;T&gt; heap;
    <span class="hljs-comment">// 记录在堆上的位置</span>
    <span class="hljs-keyword">private</span> HashMap&lt;T, Integer&gt; indexMap;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> heapSize;
    <span class="hljs-keyword">private</span> Comparator&lt;? <span class="hljs-keyword">super</span> T&gt; comparator;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyHeap</span><span class="hljs-params">(Comparator&lt;? <span class="hljs-keyword">super</span> T&gt; com)</span> </span>&#123;
        heap = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
        indexMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
        heapSize = <span class="hljs-number">0</span>;
        comparator = com;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> heapSize == <span class="hljs-number">0</span>;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> heapSize;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">contains</span><span class="hljs-params">(T key)</span> </span>&#123;
        <span class="hljs-keyword">return</span> indexMap.containsKey(key);
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(T value)</span> </span>&#123;
        heap.add(value);
        indexMap.put(value, heapSize);
        heapInsert(heapSize++);
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;
        T ans = heap.get(<span class="hljs-number">0</span>);
        <span class="hljs-keyword">int</span> end = heapSize - <span class="hljs-number">1</span>;
        swap(<span class="hljs-number">0</span>, end);
        heap.remove(end);
        indexMap.remove(ans);
        heapify(<span class="hljs-number">0</span>, --heapSize);
        <span class="hljs-keyword">return</span> ans;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">resign</span><span class="hljs-params">(T value)</span> </span>&#123;
        <span class="hljs-keyword">int</span> valueIndex = indexMap.get(value);
        <span class="hljs-comment">// 只会中一个逻辑</span>
        heapInsert(valueIndex);
        heapify(valueIndex, heapSize);
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">heapInsert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;
        <span class="hljs-keyword">while</span> (comparator.compare(heap.get(index), heap.get((index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>)) &lt; <span class="hljs-number">0</span>) &#123;
            swap(index, (index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>);
            index = (index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;
        &#125;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">heapify</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> heapSize)</span> </span>&#123;
        <span class="hljs-keyword">int</span> left = index * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;
        <span class="hljs-keyword">while</span> (left &lt; heapSize) &#123;
            <span class="hljs-keyword">int</span> largest = left + <span class="hljs-number">1</span> &lt; heapSize &amp;&amp; (comparator.compare(heap.get(left + <span class="hljs-number">1</span>), heap.get(left)) &lt; <span class="hljs-number">0</span>)
                    ? left + <span class="hljs-number">1</span>
                    : left;
            largest = comparator.compare(heap.get(largest), heap.get(index)) &lt; <span class="hljs-number">0</span> ? largest : index;
            <span class="hljs-keyword">if</span> (largest == index) &#123;
                <span class="hljs-keyword">break</span>;
            &#125;
            swap(largest, index);
            index = largest;
            left = index * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;
        &#125;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;
        T o1 = heap.get(i);
        T o2 = heap.get(j);
        heap.set(i, o2);
        heap.set(j, o1);
        indexMap.put(o1, j);
        indexMap.put(o2, i);
    &#125;

&#125;</code></pre>



<h1 id="trie、桶排序、排序总结"><a href="#trie、桶排序、排序总结" class="headerlink" title="trie、桶排序、排序总结"></a>trie、桶排序、排序总结</h1><h2 id="前缀树"><a href="#前缀树" class="headerlink" title="前缀树"></a>前缀树</h2><p>1）单个字符串中，字符从前到后的加到一棵多叉树上<br>2）字符放在路上，节点上有专属的数据项（常见的是pass和end值）<br>3）所有样本都这样添加，如果没有路就新建，如有路就复用<br>4）沿途节点的pass值增加1，每个字符串结束时来到的节点end值增加1</p>
<p>可以完成前缀相关的查询</p>
<blockquote>
<p>例子</p>
</blockquote>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201207154038.png" srcset="/img/loading.gif" alt="test1"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201207154211.png" srcset="/img/loading.gif" alt="test2"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201207154255.png" srcset="/img/loading.gif" alt="test3"></p>
<p>所有字符串字符数量为 <strong>N</strong>, </p>
<p>新建树代价为 <strong>O(N)</strong>, </p>
<p>可以找”ab”插入多少次(找ab顺下去b的e值)  <strong>O(N)</strong>, </p>
<p>或者以”a”为前缀的有多少个字符串(找a的p值)  <strong>O(N)</strong></p>
<blockquote>
<p>代码(方式一) <strong>固定数组实现</strong></p>
</blockquote>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node1</span> </span>&#123;
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> pass;
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> end;
   <span class="hljs-keyword">public</span> Node1[] nexts;

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node1</span><span class="hljs-params">()</span> </span>&#123;
      pass = <span class="hljs-number">0</span>;
      end = <span class="hljs-number">0</span>;
      <span class="hljs-comment">// 如何标记存在与否</span>
      <span class="hljs-comment">// nexts[0] -&gt; a</span>
      <span class="hljs-comment">// nexts[1] -&gt; b</span>
      <span class="hljs-comment">// ..     -&gt; ..</span>
      <span class="hljs-comment">// nexts[25]-&gt; z</span>
      <span class="hljs-comment">// nexts[i]== null, i方向的路不存在</span>
      <span class="hljs-comment">// nexts[i]!= null, i方向的路存在</span>
      nexts = <span class="hljs-keyword">new</span> Node1[<span class="hljs-number">26</span>];<span class="hljs-comment">// a — z</span>
   &#125;
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Trie1</span> </span>&#123;
   <span class="hljs-keyword">private</span> Node1 root;

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Trie1</span><span class="hljs-params">()</span> </span>&#123;
      root = <span class="hljs-keyword">new</span> Node1();
   &#125;

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(String word)</span> </span>&#123;
      <span class="hljs-keyword">if</span> (word == <span class="hljs-keyword">null</span>) &#123;
         <span class="hljs-keyword">return</span>;
      &#125;
      <span class="hljs-keyword">char</span>[] chs = word.toCharArray();
      Node1 node = root;
      node.pass++;
      <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;<span class="hljs-comment">// 路</span>
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; chs.length; i++) &#123; <span class="hljs-comment">// 从左往右遍历字符</span>
         index = chs[i] - <span class="hljs-string">&#x27;a&#x27;</span>; <span class="hljs-comment">// 由字符，对应成走向哪条路</span>
         <span class="hljs-keyword">if</span> (node.nexts[index] == <span class="hljs-keyword">null</span>) &#123;
            node.nexts[index] = <span class="hljs-keyword">new</span> Node1();
         &#125;
         node = node.nexts[index];
         node.pass++;
      &#125;
      node.end++;
   &#125;
   <span class="hljs-comment">// 沿途p--, 最后e--</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delete</span><span class="hljs-params">(String word)</span> </span>&#123;
      <span class="hljs-keyword">if</span> (search(word) != <span class="hljs-number">0</span>) &#123;
         <span class="hljs-keyword">char</span>[] chs = word.toCharArray();
         Node1 node = root;
         node.pass--;
         <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;
         <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; chs.length; i++) &#123;
            index = chs[i] - <span class="hljs-string">&#x27;a&#x27;</span>;
            <span class="hljs-comment">// 只要有p变成0，以后肯定都不会经过了</span>
            <span class="hljs-keyword">if</span> (--node.nexts[index].pass == <span class="hljs-number">0</span>) &#123;
               node.nexts[index] = <span class="hljs-keyword">null</span>;
               <span class="hljs-comment">// 直接让jvm释放</span>
               <span class="hljs-comment">// c++需要遍历后续手动释放</span>
               <span class="hljs-keyword">return</span>;
            &#125;
            node = node.nexts[index];
         &#125;
         node.end--;
      &#125;
   &#125;

   <span class="hljs-comment">// word这个单词之前加入过几次</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(String word)</span> </span>&#123;
      <span class="hljs-keyword">if</span> (word == <span class="hljs-keyword">null</span>) &#123;
         <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
      &#125;
      <span class="hljs-keyword">char</span>[] chs = word.toCharArray();
      Node1 node = root;
      <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; chs.length; i++) &#123;
         index = chs[i] - <span class="hljs-string">&#x27;a&#x27;</span>;
         <span class="hljs-keyword">if</span> (node.nexts[index] == <span class="hljs-keyword">null</span>) &#123;
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
         &#125;
         node = node.nexts[index];
      &#125;
      <span class="hljs-keyword">return</span> node.end;
   &#125;

   <span class="hljs-comment">// 所有加入的字符串中，有几个是以pre这个字符串作为前缀的</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">prefixNumber</span><span class="hljs-params">(String pre)</span> </span>&#123;
      <span class="hljs-keyword">if</span> (pre == <span class="hljs-keyword">null</span>) &#123;
         <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
      &#125;
      <span class="hljs-keyword">char</span>[] chs = pre.toCharArray();
      Node1 node = root;
      <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; chs.length; i++) &#123;
         index = chs[i] - <span class="hljs-string">&#x27;a&#x27;</span>;
         <span class="hljs-keyword">if</span> (node.nexts[index] == <span class="hljs-keyword">null</span>) &#123;
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
         &#125;
         node = node.nexts[index];
      &#125;
      <span class="hljs-keyword">return</span> node.pass;
   &#125;
&#125;</code></pre>



<blockquote>
<p>代码(方式二)  <strong>哈希表实现</strong>:字符种类变多!</p>
</blockquote>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node2</span> </span>&#123;
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> pass;
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> end;
   <span class="hljs-comment">// ASCII码值, 下一个结点</span>
   <span class="hljs-keyword">public</span> HashMap&lt;Integer, Node2&gt; nexts;

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node2</span><span class="hljs-params">()</span> </span>&#123;
      pass = <span class="hljs-number">0</span>;
      end = <span class="hljs-number">0</span>;
      nexts = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
   &#125;
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Trie2</span> </span>&#123;
   <span class="hljs-keyword">private</span> Node2 root;

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Trie2</span><span class="hljs-params">()</span> </span>&#123;
      root = <span class="hljs-keyword">new</span> Node2();
   &#125;

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(String word)</span> </span>&#123;
      <span class="hljs-keyword">if</span> (word == <span class="hljs-keyword">null</span>) &#123;
         <span class="hljs-keyword">return</span>;
      &#125;
      <span class="hljs-keyword">char</span>[] chs = word.toCharArray();
      Node2 node = root;
      node.pass++;
      <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; chs.length; i++) &#123;
         index = (<span class="hljs-keyword">int</span>) chs[i];
         <span class="hljs-keyword">if</span> (!node.nexts.containsKey(index)) &#123;
            node.nexts.put(index, <span class="hljs-keyword">new</span> Node2());
         &#125;
         node = node.nexts.get(index);
         node.pass++;
      &#125;
      node.end++;
   &#125;

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delete</span><span class="hljs-params">(String word)</span> </span>&#123;
      <span class="hljs-keyword">if</span> (search(word) != <span class="hljs-number">0</span>) &#123;
         <span class="hljs-keyword">char</span>[] chs = word.toCharArray();
         Node2 node = root;
         node.pass--;
         <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;
         <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; chs.length; i++) &#123;
            index = (<span class="hljs-keyword">int</span>) chs[i];
            <span class="hljs-keyword">if</span> (--node.nexts.get(index).pass == <span class="hljs-number">0</span>) &#123;
               node.nexts.remove(index);
               <span class="hljs-keyword">return</span>;
            &#125;
            node = node.nexts.get(index);
         &#125;
         node.end--;
      &#125;
   &#125;

   <span class="hljs-comment">// word这个单词之前加入过几次</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(String word)</span> </span>&#123;
      <span class="hljs-keyword">if</span> (word == <span class="hljs-keyword">null</span>) &#123;
         <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
      &#125;
      <span class="hljs-keyword">char</span>[] chs = word.toCharArray();
      Node2 node = root;
      <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; chs.length; i++) &#123;
         index = (<span class="hljs-keyword">int</span>) chs[i];
         <span class="hljs-keyword">if</span> (!node.nexts.containsKey(index)) &#123;
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
         &#125;
         node = node.nexts.get(index);
      &#125;
      <span class="hljs-keyword">return</span> node.end;
   &#125;

   <span class="hljs-comment">// 所有加入的字符串中，有几个是以pre这个字符串作为前缀的</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">prefixNumber</span><span class="hljs-params">(String pre)</span> </span>&#123;
      <span class="hljs-keyword">if</span> (pre == <span class="hljs-keyword">null</span>) &#123;
         <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
      &#125;
      <span class="hljs-keyword">char</span>[] chs = pre.toCharArray();
      Node2 node = root;
      <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; chs.length; i++) &#123;
         index = (<span class="hljs-keyword">int</span>) chs[i];
         <span class="hljs-keyword">if</span> (!node.nexts.containsKey(index)) &#123;
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
         &#125;
         node = node.nexts.get(index);
      &#125;
      <span class="hljs-keyword">return</span> node.pass;
   &#125;
&#125;</code></pre>



<h2 id="不基于比较的排序"><a href="#不基于比较的排序" class="headerlink" title="不基于比较的排序"></a>不基于比较的排序</h2><p>桶排序思想下的排序：**计数排序 &amp; 基数排序 **</p>
<p>1)桶排序思想下的排序都是 <strong>不基于比较的排序</strong></p>
<ol start="2">
<li><strong>时间复杂度为O(N)，额外空间负载度O(M)</strong>:无法确定</li>
</ol>
<p>3)应用范围有限， <strong>需要样本的数据状况</strong> 满足桶的划分,  <strong>强相关</strong></p>
<blockquote>
<p>区别</p>
</blockquote>
<p>1）一般来讲，计数排序要求，样本是 <strong>整数</strong>，且 <strong>范围比较窄</strong></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201207164502.png" srcset="/img/loading.gif" alt="计数排序"></p>
<p>例子:[]里数据为年龄, 年龄不会超过200, 准备一个[0-200]的桶, 记录arr的数, 有就加一, 再遍历桶</p>
<p>2）一般来讲，基数排序要求，样本是 <strong>10进制的正整数</strong></p>
<p>例子:</p>
<p>[100,17,29,13,5,27]</p>
<p>找到最大值100, 补齐位数变成[100,017,029,013,005,027]</p>
<p>准备一个桶 0,1,2,3,4,5,6,7,8,9, 每一个桶 <strong>队列</strong>, 先进先出</p>
<p>[100,017,029,013,005,027]根据个位数入桶, 再倒出来, 由于队列, 先进先出</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201207165238.png" srcset="/img/loading.gif" alt="第一次排序后"></p>
<p>再根据十位数字入桶, 再倒出来, 由于队列, 先进先出</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201207165457.png" srcset="/img/loading.gif" alt="第二次后"></p>
<p>再根据百位数字入桶, 再倒出来, 由于队列, 先进先出</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201207165615.png" srcset="/img/loading.gif" alt="第三次排序后"></p>
<p> <strong>一旦要求稍有升级，改写代价增加是显而易见的！</strong></p>
<h3 id="计数排序代码"><a href="#计数排序代码" class="headerlink" title="计数排序代码"></a>计数排序代码</h3><pre><code class="hljs JAVA"><span class="hljs-comment">// only for 0~200 value</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">countSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length &lt; <span class="hljs-number">2</span>) &#123;
      <span class="hljs-keyword">return</span>;
   &#125;
   <span class="hljs-keyword">int</span> max = Integer.MIN_VALUE;
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;
      max = Math.max(max, arr[i]);
   &#125;
   <span class="hljs-keyword">int</span>[] bucket = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[max + <span class="hljs-number">1</span>];
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;
      bucket[arr[i]]++;
   &#125;
   <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; bucket.length; j++) &#123;
      <span class="hljs-keyword">while</span> (bucket[j]-- &gt; <span class="hljs-number">0</span>) &#123;
         arr[i++] = j;
      &#125;
   &#125;
&#125;</code></pre>

<h3 id="基数排序代码-O-N-log10为底max"><a href="#基数排序代码-O-N-log10为底max" class="headerlink" title="基数排序代码 O(N*log10为底max)"></a>基数排序代码 O(N*log10为底max)</h3><pre><code class="hljs Java"><span class="hljs-comment">// only for no-negative value</span>
<span class="hljs-comment">// 非负</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">radixSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length &lt; <span class="hljs-number">2</span>) &#123;
      <span class="hljs-keyword">return</span>;
   &#125;
   radixSort(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>, maxbits(arr));
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxbits</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;
   <span class="hljs-keyword">int</span> max = Integer.MIN_VALUE;
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;
      max = Math.max(max, arr[i]);
   &#125;
   <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;
   <span class="hljs-keyword">while</span> (max != <span class="hljs-number">0</span>) &#123;
      res++;
      max /= <span class="hljs-number">10</span>;
   &#125;
   <span class="hljs-keyword">return</span> res;
&#125;

<span class="hljs-comment">// arr[l..r]排序  ,  digit(最大值位数)</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">radixSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R, <span class="hljs-keyword">int</span> digit)</span> </span>&#123;
   <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> radix = <span class="hljs-number">10</span>; <span class="hljs-comment">// 以十为基底</span>
   <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;
   <span class="hljs-comment">// 有多少个数准备多少个辅助空间</span>
   <span class="hljs-keyword">int</span>[] help = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[R - L + <span class="hljs-number">1</span>];
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> d = <span class="hljs-number">1</span>; d &lt;= digit; d++) &#123; <span class="hljs-comment">// 有多少位就进出几次</span>
      <span class="hljs-comment">// 10个空间</span>
       <span class="hljs-comment">// count[0] 当前位(d位)是0的数字有多少个</span>
      <span class="hljs-comment">// count[1] 当前位(d位)是(0和1)的数字有多少个</span>
      <span class="hljs-comment">// count[2] 当前位(d位)是(0、1和2)的数字有多少个</span>
      <span class="hljs-comment">// count[i] 当前位(d位)是(0~i)的数字有多少个</span>
      <span class="hljs-keyword">int</span>[] count = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[radix]; <span class="hljs-comment">// count[0..9]</span>
      <span class="hljs-keyword">for</span> (i = L; i &lt;= R; i++) &#123;
         <span class="hljs-comment">// 取出Digit位数上的数 </span>
         <span class="hljs-comment">// 103 1 3</span>
         <span class="hljs-comment">// 202 1 2</span>
         j = getDigit(arr[i], d);
         count[j]++;
      &#125;
      <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; radix; i++) &#123;
         <span class="hljs-comment">// count自己变成count&#x27;</span>
         count[i] = count[i] + count[i - <span class="hljs-number">1</span>];
      &#125;
      <span class="hljs-keyword">for</span> (i = R; i &gt;= L; i--) &#123;
         j = getDigit(arr[i], d);
         help[count[j] - <span class="hljs-number">1</span>] = arr[i];
         count[j]--;
      &#125;
      <span class="hljs-keyword">for</span> (i = L, j = <span class="hljs-number">0</span>; i &lt;= R; i++, j++) &#123;
         arr[i] = help[j];
      &#125;
   &#125;
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getDigit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> d)</span> </span>&#123;
   <span class="hljs-keyword">return</span> ((x / ((<span class="hljs-keyword">int</span>) Math.pow(<span class="hljs-number">10</span>, d - <span class="hljs-number">1</span>))) % <span class="hljs-number">10</span>);
&#125;</code></pre>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201207172931.png" srcset="/img/loading.gif" alt="基数排序解析"></p>
<p>准备count数组为10长度，下标0 - 9</p>
<p>先对比个位数大小，分别放入对应count数组，count转化为count’词频数组，代表小于等于索引i的数有多少个</p>
<p>再从 <strong>右往左遍历</strong>数组（正常来说从左往右时302应该在队列末尾最后出队），开辟最大个数（小于等于9的数字有五个）的help数组，从右往左遍历时候302个位下标为2，小于等于2的有四个，所以可能放在第0 - 第3个数字，但因为从右往左遍历，302应该在2号桶最后倒出来， 所以302放help[3]，count’的词频减1，41应该在1号桶最后倒出来，个位数小于等于1有两个，所以放help[1]，202放剩下的2最后，小于等于2变成三个，所以help[2]….</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201207173538.png" srcset="/img/loading.gif" alt="只用数组模拟入桶出桶行为"></p>
<h1 id="排序算法的稳定性及总结"><a href="#排序算法的稳定性及总结" class="headerlink" title="排序算法的稳定性及总结"></a>排序算法的稳定性及总结</h1><h2 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h2><p>稳定性是指同样大小的样本再 <strong>排序之后不会改变相对次序</strong></p>
<ul>
<li>第一个1还在第一个, 第二个2还在第二个</li>
</ul>
<p>对 <strong>基础类型</strong> 来说，稳定性毫无意义</p>
<ul>
<li>不用区分是第几个1</li>
</ul>
<p>对 <strong>非基础类型</strong> (引用)来说，稳定性有重要意义</p>
<ul>
<li>班级号、年龄的学生类，第一回按照所有学生年龄从小到大排序，基于此再按照班级号从小到大排序</li>
<li>如果 <strong>具有稳定性</strong> : [一班年纪小, 一班年纪大, 二班年纪小, 三班年纪大…]</li>
<li>即可选择 价格最低和好评最高 -&gt; 物美价廉</li>
</ul>
<p>有些排序算法可以实现成稳定的，而有些排序算法无论如何都实现不成稳定的</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​             时间复杂度 额外空间复杂度   稳定性<br>选择排序    O(N^2)          O(1)            无<br>冒泡排序    O(N^2)          O(1)            有<br>插入排序    O(N^2)          O(1)            有<br>归并排序    O(NlogN)         O(N)           有<br>随机快排    O(NlogN)         O(logN)        无<br>堆排序      O(NlogN)        O(1)           无<br>= = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =<br>计数排序    O(N)      O(M)    有<br>基数排序    O(N)      O(N)    有</p>
<ul>
<li><p><strong>选择排序</strong> 问题</p>
<p>[5,5,5,5,1,5,5,5,5] 直接第一个5位置放到1位置交换，5位置被破坏</p>
</li>
<li><p><strong>冒泡排序</strong> </p>
<p>相等时候不交换，稳定性就不会被破坏</p>
</li>
<li><p><strong>插入排序</strong> </p>
<p>面对相等时，不替换，稳定性也不会被破坏</p>
</li>
<li><p><strong>归并排序</strong></p>
<p>面对相等时，先拷贝左边的，稳定性也不会被破坏</p>
<p>但如果解决逆序对等问题先拷贝右边则会出现问题</p>
</li>
<li><p><strong>随机快排</strong></p>
<p>Partition过程无法做稳定</p>
<p>小于等于区下一个数交换，交换的会是等于区的数字，数字的位置就会被破坏</p>
</li>
<li><p><strong>堆排序</strong></p>
<p>变成大根堆的时候, 3，3，3，3遇到4后有很多个3的位置会改变</p>
</li>
</ul>
<blockquote>
<p>总结</p>
</blockquote>
<pre><code class="hljs mathematica"><span class="hljs-number">1</span>）不基于比较的排序，对样本数据有严格要求，不易改写
<span class="hljs-number">2</span>）基于比较的排序，只要规定好两个样本怎么比大小就可以直接复用
<span class="hljs-number">3</span>）基于比较的排序，时间复杂度的极限是<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-operator">*</span><span class="hljs-variable">logN</span><span class="hljs-punctuation">)</span>
<span class="hljs-number">4</span>）时间复杂度<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-operator">*</span><span class="hljs-variable">logN</span><span class="hljs-punctuation">)</span>、额外空间复杂度低于<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-punctuation">)</span>、且稳定的基于比较的排序是不存在的。
<span class="hljs-number">5</span>）为了绝对的速度选快排（常数时间最少）、为了省空间选堆排、为了稳定性选归并</code></pre>



<h2 id="常见的坑"><a href="#常见的坑" class="headerlink" title="常见的坑"></a>常见的坑</h2><ul>
<li>归并排序的额外空间复杂度可以变成O(1)，“ <strong>归并排序 内部缓存法</strong> ”，但是将变得 <strong>不再稳定</strong>。</li>
<li>“ <strong>原地归并排序</strong> “ 是垃圾贴，会让时间复杂度变成O(N^2) </li>
<li>快速排序稳定性改进，“01 stable sort”，但是会对 <strong>样本数据要求更多</strong>。</li>
</ul>
<ul>
<li><p>在整型数组中，请把奇数放在数组左边，偶数放在数组右边，要求所有奇数之间原始的相对次序不变，所有偶数之间原始相对次序不变。</p>
<p>要求：时间复杂度做到O(N)，额外空间复杂度做到O(1)</p>
<p>**这是一个 0,1标准的Partition **(原始小于等于和大于分界，此问题奇数偶数分界), 而Partition过程无法做到稳定性</p>
</li>
</ul>
<p>系统函数：先反射，判定是引用传递还是值传递，引用归并，值传递快排</p>
<h1 id="链表问题"><a href="#链表问题" class="headerlink" title="链表问题"></a>链表问题</h1><blockquote>
<p> 面试时链表解题的 <strong>方法论</strong></p>
</blockquote>
<p>1)对于笔试，不用太在乎空间复杂度，一切为了时间复杂度</p>
<p>2)对于面试，时间复杂度依然放在第一位，但是一定要找到空间最省的方法</p>
<h2 id="链表面试题常用数据结构和技巧"><a href="#链表面试题常用数据结构和技巧" class="headerlink" title="链表面试题常用数据结构和技巧"></a>链表面试题常用数据结构和技巧</h2><p>1）使用容器(哈希表、数组等)</p>
<p>2）快慢指针 </p>
<h2 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h2><p>1）输入链表头节点，奇数长度返回中点，偶数长度返回上中点</p>
<p>1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt;5 找到3, 1 -&gt; 2 -&gt; 3 -&gt; 4  找到2</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">midOrUpMidNode</span><span class="hljs-params">(Node head)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span> || head.next == <span class="hljs-keyword">null</span> || head.next.next == <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">return</span> head;
   &#125;
   <span class="hljs-comment">// 链表 &gt;= 三个结点</span>
   Node slow = head.next;
   Node fast = head.next.next;
   <span class="hljs-keyword">while</span> (fast.next != <span class="hljs-keyword">null</span> &amp;&amp; fast.next.next != <span class="hljs-keyword">null</span>) &#123;
      slow = slow.next;
      fast = fast.next.next;
   &#125;
   <span class="hljs-keyword">return</span> slow;
&#125;</code></pre>

<p>2）输入链表头节点，奇数长度返回中点，偶数长度返回下中点</p>
<p>1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt;5 找到3,  1 -&gt; 2 -&gt; 3 -&gt; 4  找到3</p>
<p>3）输入链表头节点，奇数长度返回中点前一个，偶数长度返回上中点前一个</p>
<p>4）输入链表头节点，奇数长度返回中点前一个，偶数长度返回下中点前一个</p>
<h2 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h2><h3 id="给定一个单链表的头节点head，请判断该链表是否为回文结构。"><a href="#给定一个单链表的头节点head，请判断该链表是否为回文结构。" class="headerlink" title="给定一个单链表的头节点head，请判断该链表是否为回文结构。"></a>给定一个单链表的头节点head，请判断该链表是否为回文结构。</h3><p>1）栈方法特别简单（笔试用）</p>
<ul>
<li><p><strong>栈实现</strong></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201208150841.png" srcset="/img/loading.gif" alt="栈"></p>
<p>把链表value全放栈中，再弹出一个一个对比。</p>
<p>Code:</p>
<pre><code class="hljs java"><span class="hljs-comment">// need n extra space</span>
<span class="hljs-comment">// stack</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPalindrome1</span><span class="hljs-params">(Node head)</span> </span>&#123;
   Stack&lt;Node&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;Node&gt;();
   Node cur = head;
   <span class="hljs-keyword">while</span> (cur != <span class="hljs-keyword">null</span>) &#123;
      stack.push(cur);
      cur = cur.next;
   &#125;
   <span class="hljs-keyword">while</span> (head != <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">if</span> (head.value != stack.pop().value) &#123;
         <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
      &#125;
      head = head.next;
   &#125;
   <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
&#125;</code></pre>
</li>
<li><p><strong>栈实现2</strong></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201208151246.png" srcset="/img/loading.gif" alt="快慢指针定位"></p>
<p>快慢指针定位到中点的位置, 奇数唯一中点偶数上中点, 把右半部分加到栈中, 弹出与head一一对比</p>
<pre><code class="hljs java"><span class="hljs-comment">// need n/2 extra space</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPalindrome2</span><span class="hljs-params">(Node head)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span> || head.next == <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
   &#125;
   Node right = head.next;
   Node cur = head;
   <span class="hljs-keyword">while</span> (cur.next != <span class="hljs-keyword">null</span> &amp;&amp; cur.next.next != <span class="hljs-keyword">null</span>) &#123;
      right = right.next;
      cur = cur.next.next;
   &#125;
   Stack&lt;Node&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;Node&gt;();
   <span class="hljs-keyword">while</span> (right != <span class="hljs-keyword">null</span>) &#123;
      stack.push(right);
      right = right.next;
   &#125;
   <span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;
      <span class="hljs-keyword">if</span> (head.value != stack.pop().value) &#123;
         <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
      &#125;
      head = head.next;
   &#125;
   <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
&#125;</code></pre>



</li>
</ul>
<p>2）改原链表的方法就需要注意边界了（面试用）</p>
<p>​ <img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201208151959.png" srcset="/img/loading.gif" alt="原链表"></p>
<p>变化为-&gt;</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201208152030.png" srcset="/img/loading.gif" alt="变化后"></p>
<p>再L与R对比, 直到比到S, 最后再变回链表位置即可。</p>
<p>这样的 <strong>额外空间复杂度为 O(1);</strong></p>
<p>code:</p>
<pre><code class="hljs java"><span class="hljs-comment">// need O(1) extra space</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPalindrome3</span><span class="hljs-params">(Node head)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span> || head.next == <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
   &#125;
   Node n1 = head; <span class="hljs-comment">// slow</span>
   Node n2 = head; <span class="hljs-comment">// fast</span>
   <span class="hljs-keyword">while</span> (n2.next != <span class="hljs-keyword">null</span> &amp;&amp; n2.next.next != <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// find mid node</span>
      n1 = n1.next; <span class="hljs-comment">// n1 -&gt; mid</span>
      n2 = n2.next.next; <span class="hljs-comment">// n2 -&gt; end</span>
   &#125;
   n2 = n1.next; <span class="hljs-comment">// n2 -&gt; right part first node</span>
   n1.next = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// mid.next -&gt; null</span>
   Node n3 = <span class="hljs-keyword">null</span>;
   <span class="hljs-keyword">while</span> (n2 != <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// right part convert</span>
      n3 = n2.next; <span class="hljs-comment">// n3 -&gt; save next node</span>
      n2.next = n1; <span class="hljs-comment">// next of right node convert</span>
      n1 = n2; <span class="hljs-comment">// n1 move</span>
      n2 = n3; <span class="hljs-comment">// n2 move</span>
   &#125;
   n3 = n1; <span class="hljs-comment">// n3 -&gt; save last node</span>
   n2 = head;<span class="hljs-comment">// n2 -&gt; left first node</span>
   <span class="hljs-keyword">boolean</span> res = <span class="hljs-keyword">true</span>;
   <span class="hljs-keyword">while</span> (n1 != <span class="hljs-keyword">null</span> &amp;&amp; n2 != <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// check palindrome</span>
      <span class="hljs-keyword">if</span> (n1.value != n2.value) &#123;
         res = <span class="hljs-keyword">false</span>;
         <span class="hljs-keyword">break</span>;
      &#125;
      n1 = n1.next; <span class="hljs-comment">// left to mid</span>
      n2 = n2.next; <span class="hljs-comment">// right to mid</span>
   &#125;
   n1 = n3.next;
   n3.next = <span class="hljs-keyword">null</span>;
   <span class="hljs-keyword">while</span> (n1 != <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// recover list</span>
      n2 = n1.next;
      n1.next = n3;
      n3 = n1;
      n1 = n2;
   &#125;
   <span class="hljs-keyword">return</span> res;
&#125;</code></pre>



<h3 id="将单向链表按某值划分成左边小、中间相等、右边大的形式"><a href="#将单向链表按某值划分成左边小、中间相等、右边大的形式" class="headerlink" title="将单向链表按某值划分成左边小、中间相等、右边大的形式"></a>将单向链表按某值划分成左边小、中间相等、右边大的形式</h3><p>1）把链表放入数组里，在数组上做partition（笔试用）( <strong>不稳定</strong> )</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">listPartition1</span><span class="hljs-params">(Node head, <span class="hljs-keyword">int</span> pivot)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">return</span> head;
   &#125;
   Node cur = head;
   <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;
   <span class="hljs-keyword">while</span> (cur != <span class="hljs-keyword">null</span>) &#123;
      i++;
      cur = cur.next;
   &#125;
   Node[] nodeArr = <span class="hljs-keyword">new</span> Node[i];
   i = <span class="hljs-number">0</span>;
   cur = head;
   <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i != nodeArr.length; i++) &#123;
      nodeArr[i] = cur;
      cur = cur.next;
   &#125;
   arrPartition(nodeArr, pivot);
   <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i != nodeArr.length; i++) &#123;
      nodeArr[i - <span class="hljs-number">1</span>].next = nodeArr[i];
   &#125;
   nodeArr[i - <span class="hljs-number">1</span>].next = <span class="hljs-keyword">null</span>;
   <span class="hljs-keyword">return</span> nodeArr[<span class="hljs-number">0</span>];
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">arrPartition</span><span class="hljs-params">(Node[] nodeArr, <span class="hljs-keyword">int</span> pivot)</span> </span>&#123;
   <span class="hljs-keyword">int</span> small = -<span class="hljs-number">1</span>;
   <span class="hljs-keyword">int</span> big = nodeArr.length;
   <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;
   <span class="hljs-keyword">while</span> (index != big) &#123;
      <span class="hljs-keyword">if</span> (nodeArr[index].value &lt; pivot) &#123;
         swap(nodeArr, ++small, index++);
      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nodeArr[index].value == pivot) &#123;
         index++;
      &#125; <span class="hljs-keyword">else</span> &#123;
         swap(nodeArr, --big, index);
      &#125;
   &#125;
&#125;</code></pre>



<p>2）分成小、中、大三部分，再把各个部分之间串起来（面试用）</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201208161643.png" srcset="/img/loading.gif" alt="六个变量"></p>
<p>设置六个变量，分别为小于区头尾结点，大于区头尾结点，等于区头尾结点。</p>
<p>依次遍历，例如遍历4结点，bH、bT = 4，4结点断开。2也是，发至sH和sT=2，3发至eH和eT=3。</p>
<p>来到5时，要发到大于区，5串到4下面，bH=4，让bT指向5但5变成bT。</p>
<p>来到6时，bT指向6并让bT找到6的位置。</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201208162538.png" srcset="/img/loading.gif" alt="流程"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201208162652.png" srcset="/img/loading.gif" alt="流程2"></p>
<p>每一步O(1),整体O(N); 且是 <strong>稳定的</strong></p>
<p>code:</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">listPartition2</span><span class="hljs-params">(Node head, <span class="hljs-keyword">int</span> pivot)</span> </span>&#123;
   Node sH = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// small head</span>
   Node sT = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// small tail</span>
   Node eH = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// equal head</span>
   Node eT = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// equal tail</span>
   Node mH = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// big head</span>
   Node mT = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// big tail</span>
   Node next = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// save next node</span>
   <span class="hljs-comment">// every node distributed to three lists</span>
   <span class="hljs-keyword">while</span> (head != <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-comment">// 记录head.next 后面结点next是要销毁的</span>
      next = head.next;
      head.next = <span class="hljs-keyword">null</span>;
      <span class="hljs-keyword">if</span> (head.value &lt; pivot) &#123;
         <span class="hljs-keyword">if</span> (sH == <span class="hljs-keyword">null</span>) &#123;
            sH = head;
            sT = head;
         &#125; <span class="hljs-keyword">else</span> &#123;
            sT.next = head;
            sT = head;
         &#125;
      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (head.value == pivot) &#123;
         <span class="hljs-keyword">if</span> (eH == <span class="hljs-keyword">null</span>) &#123;
            eH = head;
            eT = head;
         &#125; <span class="hljs-keyword">else</span> &#123;
            eT.next = head;
            eT = head;
         &#125;
      &#125; <span class="hljs-keyword">else</span> &#123;
         <span class="hljs-keyword">if</span> (mH == <span class="hljs-keyword">null</span>) &#123;
            mH = head;
            mT = head;
         &#125; <span class="hljs-keyword">else</span> &#123;
            mT.next = head;
            mT = head;
         &#125;
      &#125;
      head = next;
   &#125;
   <span class="hljs-comment">// small and equal reconnect</span>
   <span class="hljs-keyword">if</span> (sT != <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// 如果有小于区域</span>
      sT.next = eH;
      eT = eT == <span class="hljs-keyword">null</span> ? sT : eT; <span class="hljs-comment">// 下一步，谁去连大于区域的头，谁就变成eT</span>
   &#125;
   <span class="hljs-comment">// 上面的if，不管跑了没有，et</span>
   <span class="hljs-comment">// all reconnect</span>
   <span class="hljs-keyword">if</span> (eT != <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// 如果小于区域和等于区域，不是都没有</span>
      eT.next = mH;
   &#125;
   <span class="hljs-keyword">return</span> sH != <span class="hljs-keyword">null</span> ? sH : (eH != <span class="hljs-keyword">null</span> ? eH : mH);
&#125;</code></pre>



<h3 id="一种特殊的单链表节点类-random"><a href="#一种特殊的单链表节点类-random" class="headerlink" title="一种特殊的单链表节点类 random"></a>一种特殊的单链表节点类 random</h3><blockquote>
<p> 一种特殊的单链表节点类描述如下</p>
</blockquote>
<pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123; 
<span class="hljs-keyword">int</span> value; 
Node next; 
Node rand; 
Node(<span class="hljs-keyword">int</span> val) &#123; value = val; &#125; 
&#125;</code></pre>

<p>rand指针是单链表节点结构中新增的指针，rand可能指向链表中的任意一个节点，也可能指向null。<br>给定一个由Node节点类型组成的无环单链表的头节点 head，请实现一个函数完成这个链表的复制，并返回复制的新链表的头节点。<br> <strong>【要求】</strong><br> **时间复杂度O(N)，额外空间复杂度O(1) **</p>
<ul>
<li><p>哈希表</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">copyListWithRand1</span><span class="hljs-params">(Node head)</span> </span>&#123;
   HashMap&lt;Node, Node&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;Node, Node&gt;();
   Node cur = head;
   <span class="hljs-keyword">while</span> (cur != <span class="hljs-keyword">null</span>) &#123;
      map.put(cur, <span class="hljs-keyword">new</span> Node(cur.value));
      cur = cur.next;
   &#125;
   cur = head;
   <span class="hljs-keyword">while</span> (cur != <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-comment">// cur 老          (key)</span>
      <span class="hljs-comment">// map.get(cur) 新 (value)</span>
      map.get(cur).next = map.get(cur.next);
      map.get(cur).rand = map.get(cur.rand);
      cur = cur.next;
   &#125;
   <span class="hljs-keyword">return</span> map.get(head);
&#125;</code></pre>



</li>
</ul>
<ul>
<li><p>不用哈希表</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201208175756.png" srcset="/img/loading.gif" alt="克隆, 放置后面"></p>
<p>一次拿出一对:</p>
<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201208175936.png" srcset="/img/loading.gif" alt="如何克隆？" style="zoom:50%;" />



</li>
</ul>
<p>  我们通过1找到1的random 3，又因为3’就在3后面，所以可以直接3.next找到并与1’连接</p>
<p>  最后分离</p>
<p>  code:</p>
  <pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">copyListWithRand2</span><span class="hljs-params">(Node head)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
   &#125;
   Node cur = head;
   Node next = <span class="hljs-keyword">null</span>;
   <span class="hljs-comment">// copy node and link to every node</span>
   <span class="hljs-comment">// 1 -&gt; 2</span>
   <span class="hljs-comment">// 1 -&gt; 1&#x27; -&gt; 2</span>
   <span class="hljs-keyword">while</span> (cur != <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-comment">// cur 老</span>
      <span class="hljs-comment">// next表示 老 的下一个</span>
      next = cur.next;
      cur.next = <span class="hljs-keyword">new</span> Node(cur.value);
      cur.next.next = next;
      cur = next;
   &#125;
   cur = head;
   Node curCopy = <span class="hljs-keyword">null</span>;
   <span class="hljs-comment">// set copy node rand</span>
   <span class="hljs-comment">// 1 -&gt; 1&#x27; -&gt; 2 -&gt; 2&#x27;</span>
   <span class="hljs-keyword">while</span> (cur != <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-comment">// cur 老</span>
      <span class="hljs-comment">// cur.next  新 copy</span>
      next = cur.next.next;
      curCopy = cur.next;
      <span class="hljs-comment">// 老的rand的下一个(插入进来的)</span>
      curCopy.rand = cur.rand != <span class="hljs-keyword">null</span> ? cur.rand.next : <span class="hljs-keyword">null</span>;
      cur = next;
   &#125;
   Node res = head.next;
   cur = head;
   <span class="hljs-comment">// split</span>
   <span class="hljs-keyword">while</span> (cur != <span class="hljs-keyword">null</span>) &#123;
      next = cur.next.next;
      curCopy = cur.next;
      cur.next = next;
      curCopy.next = next != <span class="hljs-keyword">null</span> ? next.next : <span class="hljs-keyword">null</span>;
      cur = next;
   &#125;
   <span class="hljs-keyword">return</span> res;
&#125;</code></pre>

<p>  不能边设置边断链： <strong>如果后面指向前面，前面已经和自己的 ‘ 断连了，.next已经没有用</strong></p>
<h3 id="与约瑟夫环问题相同的噩梦（相交）"><a href="#与约瑟夫环问题相同的噩梦（相交）" class="headerlink" title="与约瑟夫环问题相同的噩梦（相交）"></a>与约瑟夫环问题相同的噩梦（相交）</h3><p>给定两个可能有环也可能无环的单链表，头节点head1和head2。请实现一个函数，如果两个链表相交，请返回相交的 第一个节点。如果不相交，返回null </p>
<p>相交就是地址共用相同部分！</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201208182234.png" srcset="/img/loading.gif" alt="相交"></p>
<p>【要求】<br> <strong>如果两个链表长度之和为N，时间复杂度请达到O(N)，额外空间复杂度 请达到O(1)。</strong></p>
<blockquote>
<p>先设计 Node f(head) 返回 <strong>入环第一个结点</strong></p>
</blockquote>
<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201208182419.png" srcset="/img/loading.gif" alt="入环结点" style="zoom:50%;" />

<p>如果整个是环，就是head</p>
<p> <strong>一个链表只有一个next指针，进了环，是不能出来的。</strong></p>
<p>可以用set<Node> 先查有没有在set里，查到第一个在的就是入环结点，没有环一定走到空上。</p>
<ul>
<li><p>不用set:</p>
<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201208183357.png" srcset="/img/loading.gif" alt="流程" style="zoom:50%;" />

<p>一开始slow和fast指针从head开始出发，slow走一步，fast走两步；</p>
<p>一直这样走下去，slow和fast一定会在同一个地方，当到达同一个地方时： <strong>证明一定有环</strong></p>
<p>slow不变位置，fast回到开头，fast变成一次走一步，slow也继续一次走一步，</p>
<p>当slow和fast再次相交时，这个点就是 <strong>第一个入环点</strong>。</p>
<p>code：</p>
<pre><code class="hljs java"><span class="hljs-comment">// 找到链表第一个入环节点，如果无环，返回null</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">getLoopNode</span><span class="hljs-params">(Node head)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span> || head.next == <span class="hljs-keyword">null</span> || head.next.next == <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
   &#125;
   <span class="hljs-comment">// n1 慢  n2 快</span>
   Node n1 = head.next; <span class="hljs-comment">// n1 -&gt; slow</span>
   Node n2 = head.next.next; <span class="hljs-comment">// n2 -&gt; fast</span>
   <span class="hljs-keyword">while</span> (n1 != n2) &#123;
      <span class="hljs-keyword">if</span> (n2.next == <span class="hljs-keyword">null</span> || n2.next.next == <span class="hljs-keyword">null</span>) &#123;
         <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
      &#125;
      n2 = n2.next.next;
      n1 = n1.next;
   &#125;
   n2 = head; <span class="hljs-comment">// n2 -&gt; walk again from head</span>
   <span class="hljs-keyword">while</span> (n1 != n2) &#123;
      n1 = n1.next;
      n2 = n2.next;
   &#125;
   <span class="hljs-keyword">return</span> n1;
&#125;</code></pre>



</li>
</ul>
<blockquote>
<p>问题解决</p>
</blockquote>
<ol>
<li>如果 <strong>两个无环链表相交</strong>，相交后为全部相交部分。</li>
</ol>
<ul>
<li><p>用set</p>
<p>把一个链表全部注册进去，对第二个链表逐步遍历直到找到第一个相交。</p>
</li>
<li><p>不用set</p>
<p>假设第一个链表100个，第二个链表80个，两个都找到其最后一个结点（即下一个结点为null的结点），分别为end1和end2。</p>
<ul>
<li>判断 end1 是否等于 end2 ，如果不等于， 不相交。</li>
<li>如果 end1 等于 end2， 链表1走（100-80）= 20步，从这里开始链表二也开始走，两个链表肯定会走到第一个相遇的地方。</li>
</ul>
<p>Code:</p>
<pre><code class="hljs java"><span class="hljs-comment">// 如果两个链表都无环，返回第一个相交节点，如果不想交，返回null</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">noLoop</span><span class="hljs-params">(Node head1, Node head2)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (head1 == <span class="hljs-keyword">null</span> || head2 == <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
   &#125;
   Node cur1 = head1;
   Node cur2 = head2;
   <span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>;
   <span class="hljs-keyword">while</span> (cur1.next != <span class="hljs-keyword">null</span>) &#123;
      n++;
      cur1 = cur1.next;
   &#125;
   <span class="hljs-keyword">while</span> (cur2.next != <span class="hljs-keyword">null</span>) &#123;
      n--;
      cur2 = cur2.next;
   &#125;
   <span class="hljs-comment">// n = cur1.len - cur2.len</span>
   <span class="hljs-keyword">if</span> (cur1 != cur2) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
   &#125;
   <span class="hljs-comment">// n  :  链表1长度减去链表2长度的值</span>
   cur1 = n &gt; <span class="hljs-number">0</span> ? head1 : head2; <span class="hljs-comment">// 谁长，谁的头变成cur1</span>
   cur2 = cur1 == head1 ? head2 : head1; <span class="hljs-comment">// 谁短，谁的头变成cur2</span>
   n = Math.abs(n);
   <span class="hljs-comment">// 长链表先走</span>
   <span class="hljs-keyword">while</span> (n != <span class="hljs-number">0</span>) &#123;
      n--;
      cur1 = cur1.next;
   &#125;
   <span class="hljs-comment">// 一起走 走到相交点</span>
   <span class="hljs-keyword">while</span> (cur1 != cur2) &#123;
      cur1 = cur1.next;
      cur2 = cur2.next;
   &#125;
   <span class="hljs-keyword">return</span> cur1;
&#125;</code></pre>



</li>
</ul>
<ol start="2">
<li>如果 <strong>两个有环链表相交</strong>，一定是 <strong>共用这个环的</strong></li>
</ol>
<p>​ <img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201208190644.png" srcset="/img/loading.gif" alt="三种情况"></p>
<ul>
<li>没有相交部分<ul>
<li>让loop1往下走，如果在 <strong>遇见自己之前一直没碰到loop2</strong>。</li>
</ul>
</li>
<li>入环结点相同<ul>
<li>loop1和loop2不等于空且相同</li>
<li>不用再看环，把入环点作为尾结点，就变成了两个无环单链表相交问题</li>
</ul>
</li>
<li>入环结点不同<ul>
<li> 让loop1往下走，如果在 <strong>遇见自己之前一直碰到了loop2</strong>。</li>
</ul>
</li>
</ul>
<ol start="3">
<li>如果 <strong>一个有环一个无环</strong>， <strong>不可能相交</strong>。</li>
</ol>
<p>​ 因为是单链表。</p>
<pre><code class="hljs java"><span class="hljs-comment">// 两个有环链表，返回第一个相交节点，如果不想交返回null</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">bothLoop</span><span class="hljs-params">(Node head1, Node loop1, Node head2, Node loop2)</span> </span>&#123;
   Node cur1 = <span class="hljs-keyword">null</span>;
   Node cur2 = <span class="hljs-keyword">null</span>;
   <span class="hljs-keyword">if</span> (loop1 == loop2) &#123;
      <span class="hljs-comment">// 解决无环问题，只不过end变为loop</span>
      cur1 = head1;
      cur2 = head2;
      <span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">while</span> (cur1 != loop1) &#123;
         n++;
         cur1 = cur1.next;
      &#125;
      <span class="hljs-keyword">while</span> (cur2 != loop2) &#123;
         n--;
         cur2 = cur2.next;
      &#125;
      cur1 = n &gt; <span class="hljs-number">0</span> ? head1 : head2;
      cur2 = cur1 == head1 ? head2 : head1;
      n = Math.abs(n);
      <span class="hljs-keyword">while</span> (n != <span class="hljs-number">0</span>) &#123;
         n--;
         cur1 = cur1.next;
      &#125;
      <span class="hljs-keyword">while</span> (cur1 != cur2) &#123;
         cur1 = cur1.next;
         cur2 = cur2.next;
      &#125;
      <span class="hljs-keyword">return</span> cur1;
   &#125; <span class="hljs-keyword">else</span> &#123;
      cur1 = loop1.next;
      <span class="hljs-keyword">while</span> (cur1 != loop1) &#123;
         <span class="hljs-keyword">if</span> (cur1 == loop2) &#123;
            <span class="hljs-keyword">return</span> loop1;
         &#125;
         cur1 = cur1.next;
      &#125;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
   &#125;
&#125;</code></pre>

<p>最后总结：</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">getIntersectNode</span><span class="hljs-params">(Node head1, Node head2)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (head1 == <span class="hljs-keyword">null</span> || head2 == <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
   &#125;
   Node loop1 = getLoopNode(head1);
   Node loop2 = getLoopNode(head2);
   <span class="hljs-keyword">if</span> (loop1 == <span class="hljs-keyword">null</span> &amp;&amp; loop2 == <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">return</span> noLoop(head1, head2);
   &#125;
   <span class="hljs-keyword">if</span> (loop1 != <span class="hljs-keyword">null</span> &amp;&amp; loop2 != <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">return</span> bothLoop(head1, loop1, head2, loop2);
   &#125;
   <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
&#125;</code></pre>



<h3 id="能不能不给单链表的头节点，只给想要删除的节点，就能做到在链表上把这个点删掉？"><a href="#能不能不给单链表的头节点，只给想要删除的节点，就能做到在链表上把这个点删掉？" class="headerlink" title="能不能不给单链表的头节点，只给想要删除的节点，就能做到在链表上把这个点删掉？"></a>能不能不给单链表的头节点，只给想要删除的节点，就能做到在链表上把这个点删掉？</h3><p>把下一个值赋给当前结点，当前结点跳到下下个。</p>
<p>1）但 <strong>实际上没有删除 “自己”，只是替代了内容！</strong></p>
<p>2）如果不再是简单的结点问题，而是服务器问题， <strong>拷贝</strong>会变成一件很困难的事情！</p>
<p>3） <strong>绝对无法删除链表最后一个结点的！</strong>没有办法改前一个结点的走向。NULL是一个特定系统区域，去调析构函数是没有用的！</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201208192831.png" srcset="/img/loading.gif" alt="test代码"></p>
<blockquote>
<p>为什么不行？</p>
</blockquote>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201208192918.png" srcset="/img/loading.gif" alt="原因"></p>
<p>c = null;只是让c没有指向Node(3), 但Node(2)还是指向Node(3)了！</p>
<h1 id="二叉树的基本算法"><a href="#二叉树的基本算法" class="headerlink" title="二叉树的基本算法"></a>二叉树的基本算法</h1><blockquote>
<p>结构描述：</p>
</blockquote>
<pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;
  V value;
  Node left;
  Node right;
&#125;</code></pre>

<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> value;
   <span class="hljs-keyword">public</span> Node left;
   <span class="hljs-keyword">public</span> Node right;

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v)</span> </span>&#123;
      value = v;
   &#125;
&#125;</code></pre>



<h2 id="二叉树的先序、中序、后序遍历"><a href="#二叉树的先序、中序、后序遍历" class="headerlink" title="二叉树的先序、中序、后序遍历"></a>二叉树的先序、中序、后序遍历</h2><p>​ <img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201209164047.png" srcset="/img/loading.gif" alt="如图"></p>
<ul>
<li><p>先序：任何子树的处理顺序都是，先头节点、再左子树、然后右子树</p>
<pre><code class="hljs java"><span class="hljs-comment">// 先序打印所有结点</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pre</span><span class="hljs-params">(Node head)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">return</span>;
   &#125;
   System.out.println(head.value);
   pre(head.left);
   pre(head.right);
&#125;</code></pre>

<p>​ </p>
</li>
<li><p>中序：任何子树的处理顺序都是，先左子树、再头节点、然后右子树</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">in</span><span class="hljs-params">(Node head)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">return</span>;
   &#125;
   in(head.left);
   System.out.println(head.value);
   in(head.right);
&#125;</code></pre>



</li>
</ul>
<ul>
<li><p>后序：任何子树的处理顺序都是，先左子树、再右子树、然后头节点</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pos</span><span class="hljs-params">(Node head)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">return</span>;
   &#125;
   pos(head.left);
   pos(head.right);
   System.out.println(head.value);
&#125;</code></pre>



</li>
</ul>
<h3 id="递归的本质是-递归序"><a href="#递归的本质是-递归序" class="headerlink" title="递归的本质是  递归序"></a>递归的本质是  <strong>递归序</strong></h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201209170646.png" srcset="/img/loading.gif" alt="流程"></p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(Node head)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">return</span>;
   &#125;
   <span class="hljs-comment">// 先序</span>
   f(head.left);
   <span class="hljs-comment">// 中序</span>
   f(head.right);
   <span class="hljs-comment">// 后序</span>
&#125;</code></pre>

<p>对于这样的代码，一定会 <strong>访问(返回)</strong> 三次：</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201209170852.png" srcset="/img/loading.gif" alt="每一个结点都会到达三次"></p>
<p>先序就是每一次第一次到达了就打印：</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201209171028.png" srcset="/img/loading.gif" alt="第一次到达打印就是先序"></p>
<p>先序，中序，后序只是 <strong>递归序的结果</strong>。</p>
<p>所以在树上做动态规划的前提就是 <strong>每一个结点都会到此，走左边再回来，走右边再回来。</strong></p>
<p>让一个东西来到 <strong>此地三次！</strong></p>
<ul>
<li>理解递归序</li>
<li>先序、中序、后序都可以在递归序的基础上加工出来</li>
<li>第一次到达一个节点就打印就是先序、第二次打印即中序、第三次即后序</li>
</ul>
<h3 id="非递归方式实现二叉树的先序、中序、后序遍历"><a href="#非递归方式实现二叉树的先序、中序、后序遍历" class="headerlink" title="非递归方式实现二叉树的先序、中序、后序遍历"></a>非递归方式实现二叉树的先序、中序、后序遍历</h3><ul>
<li><p>任何递归函数都可以改成非递归</p>
</li>
<li><p>非递归实现先序遍历</p>
<pre><code class="hljs java"><span class="hljs-comment">// 先序遍历</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pre</span><span class="hljs-params">(Node head)</span> </span>&#123;
   System.out.print(<span class="hljs-string">&quot;pre-order: &quot;</span>);
   <span class="hljs-keyword">if</span> (head != <span class="hljs-keyword">null</span>) &#123;
      Stack&lt;Node&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;Node&gt;();
      stack.add(head);
      <span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;
         head = stack.pop();
         System.out.print(head.value + <span class="hljs-string">&quot; &quot;</span>);
         <span class="hljs-keyword">if</span> (head.right != <span class="hljs-keyword">null</span>) &#123;
            stack.push(head.right);
         &#125;
         <span class="hljs-keyword">if</span> (head.left != <span class="hljs-keyword">null</span>) &#123;
            stack.push(head.left);
         &#125;
      &#125;
   &#125;
   System.out.println();
&#125;</code></pre>

<ul>
<li><p>先放头结点，弹出就打印</p>
</li>
<li><p>弹出打印后，如果有右孩子，先压入右孩子</p>
</li>
<li><p>如果有左孩子，再压入右孩子</p>
</li>
<li><p>例如对上面的树，先压入1，弹出1，压入3、2，弹出2，压入5、4，弹出4，弹出5，弹出3，压入7、6，弹出6、7</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>非递归实现后序遍历</p>
<ul>
<li><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201209172717.png" srcset="/img/loading.gif" alt="流程与先序相反"></p>
</li>
<li><p> 如果上述，先压左再压入右， 头左右就会变成头右左，正好是后序的相反。</p>
</li>
</ul>
<p>Code:</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pos1</span><span class="hljs-params">(Node head)</span> </span>&#123;
   System.out.print(<span class="hljs-string">&quot;pos-order: &quot;</span>);
   <span class="hljs-keyword">if</span> (head != <span class="hljs-keyword">null</span>) &#123;
      Stack&lt;Node&gt; s1 = <span class="hljs-keyword">new</span> Stack&lt;Node&gt;();
      Stack&lt;Node&gt; s2 = <span class="hljs-keyword">new</span> Stack&lt;Node&gt;();
      s1.push(head);
      <span class="hljs-keyword">while</span> (!s1.isEmpty()) &#123;
         head = s1.pop();
         <span class="hljs-comment">// 转移到s2里面，先序这里是直接打印</span>
         s2.push(head);
         <span class="hljs-comment">// 先压左</span>
         <span class="hljs-keyword">if</span> (head.left != <span class="hljs-keyword">null</span>) &#123;
            s1.push(head.left);
         &#125;
         <span class="hljs-keyword">if</span> (head.right != <span class="hljs-keyword">null</span>) &#123;
            s1.push(head.right);
         &#125;
      &#125;
      <span class="hljs-keyword">while</span> (!s2.isEmpty()) &#123;
         System.out.print(s2.pop().value + <span class="hljs-string">&quot; &quot;</span>);
      &#125;
   &#125;
   System.out.println();
&#125;</code></pre>
</li>
<li><p>非递归实现后序遍历（方法二）</p>
<ul>
<li><p>死亡代码</p>
</li>
<li><p>左边到最底下，弹出一个往上管右边，右边再找左边最底下，直到把左边处理完再处理右边再处理自己。</p>
</li>
</ul>
</li>
</ul>
  <pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pos2</span><span class="hljs-params">(Node h)</span> </span>&#123;
   System.out.print(<span class="hljs-string">&quot;pos-order: &quot;</span>);
   <span class="hljs-keyword">if</span> (h != <span class="hljs-keyword">null</span>) &#123;
      Stack&lt;Node&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;Node&gt;();
      stack.push(h);
      Node c = <span class="hljs-keyword">null</span>;
      <span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;
         c = stack.peek();
         <span class="hljs-comment">// 左树没处理先处理左树</span>
         <span class="hljs-keyword">if</span> (c.left != <span class="hljs-keyword">null</span> &amp;&amp; h != c.left &amp;&amp; h != c.right) &#123;
            stack.push(c.left);
         <span class="hljs-comment">// 右树没处理先处理右树</span>
         &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c.right != <span class="hljs-keyword">null</span> &amp;&amp; h != c.right) &#123;
            stack.push(c.right);
         <span class="hljs-comment">// 该处理自己了</span>
         &#125; <span class="hljs-keyword">else</span> &#123;
            System.out.print(stack.pop().value + <span class="hljs-string">&quot; &quot;</span>);
            <span class="hljs-comment">// h跟踪上次打印的结点</span>
            h = c;
         &#125;
      &#125;
   &#125;
   System.out.println();
&#125;</code></pre>



<ul>
<li><p>非递归实现中序遍历</p>
<ul>
<li><p>整条左边界依次入栈</p>
</li>
<li><p>第一条逻辑无法再命中，就弹出结点并打印，然后来到弹出结点的右树上继续执行条件一</p>
</li>
<li><p>如上面的树，左边界全入栈，栈顶 - &gt; 栈底以此为 4,2,1，不能再命中了，弹出4，来到4的右孩子且为Null，弹出2，来到2的右孩子且为5，压入5，弹出5，来到5的右孩子且为Null，弹出1，来到1的右孩子3，3、6依此入栈，弹出6，来到6的右孩子且为Null，弹出3，来到3的右孩子且为7，弹出7。</p>
<pre><code class="hljs java"><span class="hljs-comment">// 左头无限分解</span>
<span class="hljs-comment">// 左边左头分解，右边也左头分解</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">in</span><span class="hljs-params">(Node head)</span> </span>&#123;
    System.out.print(<span class="hljs-string">&quot;in-order: &quot;</span>);
    <span class="hljs-keyword">if</span> (head != <span class="hljs-keyword">null</span>) &#123;
      Stack&lt;Node&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;Node&gt;();
      <span class="hljs-keyword">while</span> (!stack.isEmpty() || head != <span class="hljs-keyword">null</span>) &#123;
        <span class="hljs-comment">// 把左边全压入</span>
        <span class="hljs-keyword">if</span> (head != <span class="hljs-keyword">null</span>) &#123;
          stack.push(head);
          head = head.left;
        &#125; <span class="hljs-keyword">else</span> &#123;
          head = stack.pop();
          System.out.print(head.value + <span class="hljs-string">&quot; &quot;</span>);
          head = head.right;
        &#125;
      &#125;
    &#125;
    System.out.println();
  &#125;</code></pre>



</li>
</ul>
</li>
</ul>
<h2 id="实现二叉树的按层遍历"><a href="#实现二叉树的按层遍历" class="headerlink" title="实现二叉树的按层遍历"></a>实现二叉树的按层遍历</h2><ul>
<li><p>其实就是 <strong>宽度优先遍历</strong> ，用 <strong>队列</strong></p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">level</span><span class="hljs-params">(Node head)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">return</span>;
   &#125;
   Queue&lt;Node&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();
   queue.add(head);
   <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;
      Node cur = queue.poll();
      System.out.println(cur.value);
      <span class="hljs-keyword">if</span> (cur.left != <span class="hljs-keyword">null</span>) &#123;
         queue.add(cur.left);
      &#125;
      <span class="hljs-keyword">if</span> (cur.right != <span class="hljs-keyword">null</span>) &#123;
         queue.add(cur.right);
      &#125;
   &#125;
&#125;</code></pre>

<ul>
<li><p>先把头结点加入</p>
</li>
<li><p>开始循环，弹出打印，先加左再加右</p>
</li>
<li><p>1弹出，2、3进，2弹出，4、5进，3弹出，6、7进…..</p>
</li>
</ul>
</li>
</ul>
<h3 id="二叉树最大宽度"><a href="#二叉树最大宽度" class="headerlink" title="二叉树最大宽度"></a>二叉树最大宽度</h3><ul>
<li><p>可以通过设置 <strong>flag变量</strong> 的方式，来发现某一层的 <strong>结束</strong>（看题目）</p>
<p>如：找到二叉树最宽的一层，建议一个发现机制就行，发现结束就意味着开始。</p>
<pre><code class="hljs java"><span class="hljs-comment">// 寻找到二叉树最大宽度</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxWidthUseMap</span><span class="hljs-params">(Node head)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
   &#125;
   Queue&lt;Node&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();
   queue.add(head);
   <span class="hljs-comment">// key在哪一层</span>
   HashMap&lt;Node, Integer&gt; levelMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
   levelMap.put(head, <span class="hljs-number">1</span>);
   <span class="hljs-comment">// 当前正在统计哪一层的宽度</span>
   <span class="hljs-keyword">int</span> curLevel = <span class="hljs-number">1</span>;
   <span class="hljs-comment">// 当前正在统计层的宽度是多少</span>
   <span class="hljs-keyword">int</span> curLevelNodes = <span class="hljs-number">0</span>; <span class="hljs-comment">// 一律规定出来的时候加，初始为0</span>
   <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;
   <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;
      Node cur = queue.poll();
      <span class="hljs-comment">// 当前层级别</span>
      <span class="hljs-keyword">int</span> curNodeLevel = levelMap.get(cur);
      <span class="hljs-keyword">if</span> (cur.left != <span class="hljs-keyword">null</span>) &#123;
         levelMap.put(cur.left, curNodeLevel + <span class="hljs-number">1</span>);
         queue.add(cur.left);
      &#125;
      <span class="hljs-keyword">if</span> (cur.right != <span class="hljs-keyword">null</span>) &#123;
         levelMap.put(cur.right, curNodeLevel + <span class="hljs-number">1</span>);
         queue.add(cur.right);
      &#125;
      <span class="hljs-keyword">if</span> (curNodeLevel == curLevel) &#123;
         curLevelNodes++;
      &#125; <span class="hljs-keyword">else</span> &#123;
         max = Math.max(max, curLevelNodes);
         curLevel++;
         curLevelNodes = <span class="hljs-number">1</span>;
      &#125;
   &#125;
   <span class="hljs-comment">// 最后一层没有出发max机制</span>
   max = Math.max(max, curLevelNodes);
   <span class="hljs-keyword">return</span> max;
&#125;</code></pre>

<p>用map记录结点位置（每一个新层到来结算上一层的老层）</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201210083532.png" srcset="/img/loading.gif" alt="流程"></p>
</li>
</ul>
<ul>
<li><p>不用map寻找最大宽度机制：</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxWidthNoMap</span><span class="hljs-params">(Node head)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
   &#125;
   Queue&lt;Node&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();
   queue.add(head);
   <span class="hljs-comment">// 当前层最右结点是谁</span>
   Node curEnd = head;
   <span class="hljs-comment">// 如果有下一层，下一层最右结点是谁</span>
   Node nextEnd = <span class="hljs-keyword">null</span>;
   <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;
   <span class="hljs-keyword">int</span> curLevelNodes = <span class="hljs-number">0</span>; <span class="hljs-comment">// 当前层结点数</span>
   <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;
      Node cur = queue.poll();
      <span class="hljs-keyword">if</span> (cur.left != <span class="hljs-keyword">null</span>) &#123;
         queue.add(cur.left);
         nextEnd = cur.left;
      &#125;
      <span class="hljs-keyword">if</span> (cur.right != <span class="hljs-keyword">null</span>) &#123;
         queue.add(cur.right);
         nextEnd = cur.right;
      &#125;
      curLevelNodes++;
      <span class="hljs-comment">// 当前层结点是否为当前层最右结点</span>
      <span class="hljs-keyword">if</span> (cur == curEnd) &#123;
         max = Math.max(max, curLevelNodes);
         curLevelNodes = <span class="hljs-number">0</span>;
         curEnd = nextEnd;
      &#125;
   &#125;</code></pre>



</li>
</ul>
<h2 id="二叉树的序列化和反序列化"><a href="#二叉树的序列化和反序列化" class="headerlink" title="二叉树的序列化和反序列化"></a>二叉树的序列化和反序列化</h2><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201210085559.png" srcset="/img/loading.gif" alt="序列化"></p>
<h3 id="先序序列化"><a href="#先序序列化" class="headerlink" title="先序序列化"></a>先序序列化</h3><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Queue&lt;String&gt; <span class="hljs-title">preSerial</span><span class="hljs-params">(Node head)</span> </span>&#123;
   Queue&lt;String&gt; ans = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();
   pres(head, ans);
   <span class="hljs-keyword">return</span> ans;
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pres</span><span class="hljs-params">(Node head, Queue&lt;String&gt; ans)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;
      ans.add(<span class="hljs-keyword">null</span>);
   &#125; <span class="hljs-keyword">else</span> &#123;
      ans.add(String.valueOf(head.value));
      pres(head.left, ans);
      pres(head.right, ans);
   &#125;
&#125;</code></pre>



<h3 id="已知序列化好的队列，还原树"><a href="#已知序列化好的队列，还原树" class="headerlink" title="已知序列化好的队列，还原树"></a>已知序列化好的队列，还原树</h3><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">buildByPreQueue</span><span class="hljs-params">(Queue&lt;String&gt; prelist)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (prelist == <span class="hljs-keyword">null</span> || prelist.size() == <span class="hljs-number">0</span>) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
   &#125;
   <span class="hljs-keyword">return</span> preb(prelist);
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">preb</span><span class="hljs-params">(Queue&lt;String&gt; prelist)</span> </span>&#123;
   String value = prelist.poll();
   <span class="hljs-keyword">if</span> (value == <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
   &#125;
   Node head = <span class="hljs-keyword">new</span> Node(Integer.valueOf(value));
   head.left = preb(prelist);
   head.right = preb(prelist);
   <span class="hljs-keyword">return</span> head;
&#125;</code></pre>

<blockquote>
<p>中序、后序只需要改一下顺序就可以了</p>
</blockquote>
<h3 id="按层序列化"><a href="#按层序列化" class="headerlink" title="按层序列化"></a>按层序列化</h3><p>整体上就是 <strong>宽度优先遍历</strong></p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Queue&lt;String&gt; <span class="hljs-title">levelSerial</span><span class="hljs-params">(Node head)</span> </span>&#123;
   <span class="hljs-comment">// 序列化结果</span>
   Queue&lt;String&gt; ans = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();
   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;
      ans.add(<span class="hljs-keyword">null</span>);
   &#125; <span class="hljs-keyword">else</span> &#123;
      ans.add(String.valueOf(head.value));
      Queue&lt;Node&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;Node&gt;();
      queue.add(head);
      <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;
         head = queue.poll();
         <span class="hljs-keyword">if</span> (head.left != <span class="hljs-keyword">null</span>) &#123;
            <span class="hljs-comment">// 即序列化 也加队列</span>
            ans.add(String.valueOf(head.left.value));
            queue.add(head.left);
         &#125; <span class="hljs-keyword">else</span> &#123;
            <span class="hljs-comment">// 只序列化</span>
            ans.add(<span class="hljs-keyword">null</span>);
         &#125;
         <span class="hljs-keyword">if</span> (head.right != <span class="hljs-keyword">null</span>) &#123;
            ans.add(String.valueOf(head.right.value));
            queue.add(head.right);
         &#125; <span class="hljs-keyword">else</span> &#123;
            ans.add(<span class="hljs-keyword">null</span>);
         &#125;
      &#125;
   &#125;
   <span class="hljs-keyword">return</span> ans;
&#125;</code></pre>

<p>其实就是多了一个ans队列，把空补齐。层序遍历的时候只有一个queue，queue里面放的一定不为null，再弹出判断。序列化只是ans可以放null，自己另外准备的queue不放null进行层序遍历而已。</p>
<h3 id="按层反序列化"><a href="#按层反序列化" class="headerlink" title="按层反序列化"></a>按层反序列化</h3><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">buildByLevelQueue</span><span class="hljs-params">(Queue&lt;String&gt; levelList)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (levelList == <span class="hljs-keyword">null</span> || levelList.size() == <span class="hljs-number">0</span>) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
   &#125;
   Node head = generateNode(levelList.poll());
   Queue&lt;Node&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;Node&gt;();
   <span class="hljs-keyword">if</span> (head != <span class="hljs-keyword">null</span>) &#123;
      queue.add(head);
   &#125;
   Node node = <span class="hljs-keyword">null</span>;
   <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;
      node = queue.poll();
      node.left = generateNode(levelList.poll());
      node.right = generateNode(levelList.poll());
      <span class="hljs-keyword">if</span> (node.left != <span class="hljs-keyword">null</span>) &#123;
         queue.add(node.left);
      &#125;
      <span class="hljs-keyword">if</span> (node.right != <span class="hljs-keyword">null</span>) &#123;
         queue.add(node.right);
      &#125;
   &#125;
   <span class="hljs-keyword">return</span> head;
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">generateNode</span><span class="hljs-params">(String val)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (val == <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
   &#125;
   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Node(Integer.valueOf(val));
&#125;</code></pre>



<h2 id="设计一种打印树的方式"><a href="#设计一种打印树的方式" class="headerlink" title="设计一种打印树的方式"></a>设计一种打印树的方式</h2><blockquote>
<p>如何设计一个打印整棵树的打印函数?</p>
</blockquote>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201211094340.png" srcset="/img/loading.gif" alt="打印出来的效果"></p>
<p>Code:</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printTree</span><span class="hljs-params">(Node head)</span> </span>&#123;
   System.out.println(<span class="hljs-string">&quot;Binary Tree:&quot;</span>);
   printInOrder(head, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;H&quot;</span>, <span class="hljs-number">17</span>);
   System.out.println();
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printInOrder</span><span class="hljs-params">(Node head, <span class="hljs-keyword">int</span> height, String to, <span class="hljs-keyword">int</span> len)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">return</span>;
   &#125;
   printInOrder(head.right, height + <span class="hljs-number">1</span>, <span class="hljs-string">&quot;v&quot;</span>, len);
   String val = to + head.value + to;
   <span class="hljs-keyword">int</span> lenM = val.length();
   <span class="hljs-keyword">int</span> lenL = (len - lenM) / <span class="hljs-number">2</span>;
   <span class="hljs-keyword">int</span> lenR = len - lenM - lenL;
   val = getSpace(lenL) + val + getSpace(lenR);
   System.out.println(getSpace(height * len) + val);
   printInOrder(head.left, height + <span class="hljs-number">1</span>, <span class="hljs-string">&quot;^&quot;</span>, len);
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getSpace</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;
   String space = <span class="hljs-string">&quot; &quot;</span>;
   StringBuffer buf = <span class="hljs-keyword">new</span> StringBuffer(<span class="hljs-string">&quot;&quot;</span>);
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; num; i++) &#123;
      buf.append(space);
   &#125;
   <span class="hljs-keyword">return</span> buf.toString();
&#125;</code></pre>

<p>思路：</p>
<p>要打印上面的树，实际上就是按照 <strong>右头左</strong> 的顺序打印。</p>
<p> <strong>printInOrder</strong> 函数就是先打印右边，再头，再左边。</p>
<p>对于每个要打印的当前头部：height表示高度，to标识二叉树左右子树分支关系或头结点关系，len表示当前数字占用的距离。中间的打印头过程其实就是对当前头结点“渲染”了一下而已。</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201211095016.png" srcset="/img/loading.gif" alt="例子"></p>
<p>前面的空格数由层数决定，每个数字占17位，前后补气空格</p>
<h2 id="特殊二叉树返回该节点的后继节点"><a href="#特殊二叉树返回该节点的后继节点" class="headerlink" title="特殊二叉树返回该节点的后继节点"></a>特殊二叉树返回该节点的后继节点</h2><p>二叉树结构如下定义：</p>
<pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;
  V value;
  Node left;
  Node right;
  Node parent;
&#125;</code></pre>

<blockquote>
<p>后继结点定义</p>
</blockquote>
<p>后继结点是：<strong>中序遍历</strong> 中一个结点的下一个结点。 </p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201211095339.png" srcset="/img/loading.gif" alt="后继结点"></p>
<ul>
<li><p>思路一</p>
<p>因为有parent结点，所以可以一直往上找，找到头结点。再根据头结点 <strong>中序遍历</strong> ，最后根据 <strong>中序遍历</strong> 的结果找后继结点。 <strong>时间复杂度为 O(N)</strong></p>
</li>
</ul>
<ul>
<li><p>思路二</p>
<ul>
<li><p>假设当前结点距离后继结点距离为k，此方法 <strong>时间复杂度为O(K)</strong></p>
</li>
<li><p>对于 <strong>有右子树</strong> 的结点，其 <strong>后继结点就是右子树最左结点</strong> 。</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201211095756.png" srcset="/img/loading.gif" alt="有右树的情况"></p>
</li>
<li><p>对于 <strong>没有右子树</strong> 的结点，如果 <strong>我是我的父节点的右孩子</strong>  ，<strong>就一直往上找</strong> ，直到到达的结点为当前结点 <strong>父节点的左孩子</strong>，这个父节点就是后继结点。</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201211100108.png" srcset="/img/loading.gif" alt="后继"></p>
</li>
<li><p>由此可以定义: 如果 <strong>结点a左子树上的最右结点(最后打印的结点)为b</strong> ，则a为b的后继结点。</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201211100308.png" srcset="/img/loading.gif" alt="结论"></p>
</li>
<li><p>整棵树的最右结点的后继结点为空</p>
</li>
</ul>
<p>code:</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">getSuccessorNode</span><span class="hljs-params">(Node node)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (node == <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">return</span> node;
   &#125;
   <span class="hljs-keyword">if</span> (node.right != <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">return</span> getLeftMost(node.right);
   &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 无右子树</span>
      Node parent = node.parent;
      <span class="hljs-keyword">while</span> (parent != <span class="hljs-keyword">null</span> &amp;&amp; parent.left != node) &#123; <span class="hljs-comment">// 当前节点是其父亲节点右孩子</span>
         node = parent;
         parent = node.parent;
      &#125;
      <span class="hljs-keyword">return</span> parent;
   &#125;
&#125;

<span class="hljs-comment">// 找最左边</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">getLeftMost</span><span class="hljs-params">(Node node)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (node == <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">return</span> node;
   &#125;
   <span class="hljs-keyword">while</span> (node.left != <span class="hljs-keyword">null</span>) &#123;
      node = node.left;
   &#125;
   <span class="hljs-keyword">return</span> node;
&#125;</code></pre>

</li>
</ul>
<h3 id="前驱结点"><a href="#前驱结点" class="headerlink" title="前驱结点"></a>前驱结点</h3><p>正好相反，先找有无左子树，如果有，找左子树最右结点。</p>
<p>如果没有左子树，如果当前结点为父节点的左孩子，一直往上直到当前结点为父节点的右孩子。</p>
<h2 id="折痕问题"><a href="#折痕问题" class="headerlink" title="折痕问题"></a>折痕问题</h2><p>请把一段纸条竖着放在桌子上，然后从纸条的下边向上方对折1次，压出折痕后展开。此时折痕是凹下去的，即折痕突起的方向指向纸条的背面。 如果从纸条的下边向上方连续对折2次，压出折痕后展开，此时有三条折痕，从上到下依次是下折痕、下折痕和上折痕。 </p>
<p>给定一个输入参数N，代表纸条都从下边向上方连续对折N次。 请从上到下打印所有折痕的方向。<br>例如:N=1时，打印: down N=2时，打印: down down up </p>
<ul>
<li>实际对折，会发现：每次对折都会在当前折痕前面加一个down，后面加一个up。</li>
</ul>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201211101348.png" srcset="/img/loading.gif" alt="图解"></p>
<ul>
<li><p>所以实际上就是中序遍历</p>
<ul>
<li>如果用数组实现，N次折产生2的n次方-1个折痕，浪费空间。</li>
<li>新code:</li>
</ul>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printAllFolds</span><span class="hljs-params">(<span class="hljs-keyword">int</span> N)</span> </span>&#123;
   printProcess(<span class="hljs-number">1</span>, N, <span class="hljs-keyword">true</span>);
&#125;

<span class="hljs-comment">// 递归过程，来到了某一个节点，</span>
<span class="hljs-comment">// i是节点的层数，N一共的层数，down == true  凹    down == false 凸</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printProcess</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> N, <span class="hljs-keyword">boolean</span> down)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (i &gt; N) &#123;
      <span class="hljs-keyword">return</span>;
   &#125;
   printProcess(i + <span class="hljs-number">1</span>, N, <span class="hljs-keyword">true</span>);
   System.out.println(down ? <span class="hljs-string">&quot;凹 &quot;</span> : <span class="hljs-string">&quot;凸 &quot;</span>);
   printProcess(i + <span class="hljs-number">1</span>, N, <span class="hljs-keyword">false</span>);
&#125;</code></pre>

<ul>
<li>空间复杂度 O(N) 创建了N个i</li>
</ul>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201211101703.png" srcset="/img/loading.gif" alt="流程"></p>
</li>
</ul>
<h1 id="二叉树的递归套路"><a href="#二叉树的递归套路" class="headerlink" title="二叉树的递归套路"></a>二叉树的递归套路</h1><blockquote>
<p>本质是利用递归遍历二叉树的 <strong>便利性</strong> (会到每个结点 <strong>3次</strong> )</p>
</blockquote>
<p>潜意识：任何结点x为头的树，可以得到 <strong>左右子树信息</strong> ，并利用此信息求解过程。</p>
<p>1）假设以X节点为头，假设可以向X左树和X右树要任何信息</p>
<p>2）在上一步的假设下，讨论以X为头节点的树，得到答案的可能性（最重要）</p>
<p>3）列出所有可能性后，确定到底需要向左树和右树要什么样的信息</p>
<p>3）列出所有可能性后，确定到底需要向左树和右树要什么样的信息</p>
<p>4）把左树信息和右树信息求全集，就是任何一棵子树都需要返回的信息S</p>
<p>5）递归函数都返回S，每一棵子树都这么要求</p>
<p>6）写代码，在代码中考虑如何把左树的信息和右树信息整合出整棵树的信</p>
<h2 id="给定一棵二叉树的头节点head，返回这颗二叉树是不是平衡二叉树"><a href="#给定一棵二叉树的头节点head，返回这颗二叉树是不是平衡二叉树" class="headerlink" title="给定一棵二叉树的头节点head，返回这颗二叉树是不是平衡二叉树"></a>给定一棵二叉树的头节点head，返回这颗二叉树是不是平衡二叉树</h2><p>二叉树中每一颗子树，左数的 <strong>高度差</strong> 与右树的高度差不超过 1。</p>
<ol>
<li>左树平衡 2) 右树平衡 3) 左右树高度差不大于一            <strong>|左高 - 右高| &lt; 2</strong></li>
</ol>
<p>在能确定获取子树信息情况下列出可能性：要的信息： <strong>是否平衡， 高度多少</strong></p>
<p>求解过程就变成如何返回信息的过程：</p>
<p>平衡树info：</p>
<pre><code class="hljs java"><span class="hljs-comment">// 左树和右树要求一样的</span>
<span class="hljs-comment">// 信息返回的结构体</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Info</span> </span>&#123;
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> isBalaced;
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> height;

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Info</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> b, <span class="hljs-keyword">int</span> h)</span> </span>&#123;
      isBalaced = b;
      height = h;
   &#125;
&#125;</code></pre>

<p>code:</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isBalanced2</span><span class="hljs-params">(Node head)</span> </span>&#123;
   <span class="hljs-keyword">return</span> process2(head).isBalaced;
&#125;

<span class="hljs-comment">// 左树和右树要求一样的</span>
<span class="hljs-comment">// 信息返回的结构体</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Info</span> </span>&#123;
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> isBalaced;
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> height;

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Info</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> b, <span class="hljs-keyword">int</span> h)</span> </span>&#123;
      isBalaced = b;
      height = h;
   &#125;
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Info <span class="hljs-title">process2</span><span class="hljs-params">(Node head)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Info(<span class="hljs-keyword">true</span>, <span class="hljs-number">0</span>);
   &#125;
   Info leftInfo = process2(head.left);
   Info rightInfo = process2(head.right);
   <span class="hljs-keyword">int</span> height = Math.max(leftInfo.height, rightInfo.height) + <span class="hljs-number">1</span>;
   <span class="hljs-keyword">boolean</span> isBalanced = <span class="hljs-keyword">true</span>;
   <span class="hljs-keyword">if</span> (!leftInfo.isBalaced || !rightInfo.isBalaced || Math.abs(leftInfo.height - rightInfo.height) &gt; <span class="hljs-number">1</span>) &#123;
      isBalanced = <span class="hljs-keyword">false</span>;
   &#125;
   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Info(isBalanced, height);
&#125;</code></pre>



<h2 id="给定一棵二叉树的头节点head，任何两个节点之间都存在距离，返回整棵二叉树的最大距离"><a href="#给定一棵二叉树的头节点head，任何两个节点之间都存在距离，返回整棵二叉树的最大距离" class="headerlink" title="给定一棵二叉树的头节点head，任何两个节点之间都存在距离，返回整棵二叉树的最大距离"></a>给定一棵二叉树的头节点head，任何两个节点之间都存在距离，返回整棵二叉树的最大距离</h2><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201211104832.png" srcset="/img/loading.gif" alt="距离"></p>
<p>最大距离不是最左到最后！</p>
<ul>
<li>与x无关时，不跨过x，要么是左树最大距离，要么是右树最大距离。</li>
</ul>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201211105433.png" srcset="/img/loading.gif" alt="最大距离与x无关"></p>
<ul>
<li><p>与x有关时，最大距离会通过x，x左树上离他最远的点走到右树上离他最远的点，也就是左边高度，加自己一步，加右边高度。</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201211105622.png" srcset="/img/loading.gif" alt="有关"></p>
</li>
</ul>
<blockquote>
<p>所以info就需要包含 <strong>最大距离 和 高度</strong></p>
</blockquote>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Info</span> </span>&#123;
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> maxDistance;
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> height;

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Info</span><span class="hljs-params">(<span class="hljs-keyword">int</span> dis, <span class="hljs-keyword">int</span> h)</span> </span>&#123;
      maxDistance = dis;
      height = h;
   &#125;
&#125;</code></pre>

<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Info <span class="hljs-title">process</span><span class="hljs-params">(Node head)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Info(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
   &#125;
   Info leftInfo = process(head.left);
   Info rightInfo = process(head.right);
   <span class="hljs-keyword">int</span> height = Math.max(leftInfo.height, rightInfo.height) + <span class="hljs-number">1</span>;
   <span class="hljs-comment">// 返回的 (左子树和右子树最大距离)和(左子树高加上右子树高)的最大值</span>
   <span class="hljs-comment">// 距离只可能为左子树最大距离或者右子树最大距离或者左子树高度加上右子树高度</span>
   <span class="hljs-keyword">int</span> maxDistance = Math.max(Math.max(leftInfo.maxDistance, rightInfo.maxDistance),
         leftInfo.height + rightInfo.height + <span class="hljs-number">1</span>);
   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Info(maxDistance, height);
&#125;</code></pre>



<h2 id="给定一棵二叉树的头节点head，返回这颗二叉树中最大的二叉搜索子树的大小（结点的个数）"><a href="#给定一棵二叉树的头节点head，返回这颗二叉树中最大的二叉搜索子树的大小（结点的个数）" class="headerlink" title="给定一棵二叉树的头节点head，返回这颗二叉树中最大的二叉搜索子树的大小（结点的个数）"></a>给定一棵二叉树的头节点head，返回这颗二叉树中最大的二叉搜索子树的大小（结点的个数）</h2><p>搜索二叉树：整个树上没有重复值，左树值都小于父，右树值都大于父</p>
<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201211112015.png" srcset="/img/loading.gif" alt="搜索二叉" style="zoom:50%;" />

<ul>
<li><p>与x无关，就可能为左边子树或者右边子树</p>
</li>
<li><p>与x有关，三个条件，左树整体是搜索二叉树，右树整体是搜索二叉树，左树最大值小于x，右树最大值大于x</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201211113138.png" srcset="/img/loading.gif" alt="条件"></p>
</li>
</ul>
<ul>
<li>左树信息就变成<ul>
<li>左边最大子搜索树大小</li>
<li>是否为最大子搜索树</li>
<li>左树最大值</li>
</ul>
</li>
<li>右树信息就变成<ul>
<li>右边最大子搜索树大小</li>
<li>是否为最大子搜索树</li>
<li>右树最小值</li>
</ul>
</li>
</ul>
<blockquote>
<p>就要用到合并左右树信息</p>
</blockquote>
<pre><code class="hljs java"><span class="hljs-comment">// 对于任何子树都返回四个信息</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Info</span> </span>&#123;
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> isBST;
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> maxSubBSTSize;
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> min;
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> max;

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Info</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> is, <span class="hljs-keyword">int</span> size, <span class="hljs-keyword">int</span> mi, <span class="hljs-keyword">int</span> ma)</span> </span>&#123;
      isBST = is;
      maxSubBSTSize = size;
      min = mi;
      max = ma;
   &#125;
&#125;</code></pre>

<p>算法code：</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Info <span class="hljs-title">process</span><span class="hljs-params">(Node head)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
   &#125;
   Info leftInfo = process(head.left);
   Info rightInfo = process(head.right);
   <span class="hljs-keyword">int</span> min = head.value;
   <span class="hljs-keyword">int</span> max = head.value;
   <span class="hljs-keyword">int</span> maxSubBSTSize = <span class="hljs-number">0</span>;
   <span class="hljs-keyword">if</span> (leftInfo != <span class="hljs-keyword">null</span>) &#123;
      min = Math.min(min, leftInfo.min);
      max = Math.max(max, leftInfo.max);
      maxSubBSTSize = Math.max(maxSubBSTSize, leftInfo.maxSubBSTSize);
   &#125;
   <span class="hljs-keyword">if</span> (rightInfo != <span class="hljs-keyword">null</span>) &#123;
      min = Math.min(min, rightInfo.min);
      max = Math.max(max, rightInfo.max);
      maxSubBSTSize = Math.max(maxSubBSTSize, rightInfo.maxSubBSTSize);
   &#125;
   <span class="hljs-keyword">boolean</span> isBST = <span class="hljs-keyword">false</span>;
   <span class="hljs-comment">// 左树是搜索二叉树</span>
   <span class="hljs-comment">// 右树也是搜索二叉树</span>
   <span class="hljs-comment">// 左边max小于x，右边min大于x</span>
   <span class="hljs-keyword">if</span> ((leftInfo == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">true</span> : (leftInfo.isBST &amp;&amp; leftInfo.max &lt; head.value))
         &amp;&amp; (rightInfo == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">true</span> : (rightInfo.isBST &amp;&amp; rightInfo.min &gt; head.value))) &#123;
      isBST = <span class="hljs-keyword">true</span>;
      maxSubBSTSize = (leftInfo == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : leftInfo.maxSubBSTSize)
            + (rightInfo == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : rightInfo.maxSubBSTSize) + <span class="hljs-number">1</span>;
   &#125;
   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Info(isBST, maxSubBSTSize, min, max);
&#125;</code></pre>

<p>代码等价：</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201213132931.png" srcset="/img/loading.gif" alt="code"></p>
<h2 id="派对的最大快乐值"><a href="#派对的最大快乐值" class="headerlink" title="派对的最大快乐值"></a>派对的最大快乐值</h2><p>员工信息的定义如下:</p>
<pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span> </span>&#123;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> happy; <span class="hljs-comment">// 这名员工可以带来的快乐值</span>
    List&lt;Employee&gt; subordinates; <span class="hljs-comment">// 这名员工有哪些直接下级</span>
&#125;</code></pre>

<p>多叉树！</p>
<p>​   公司的每个员工都符合 Employee 类的描述。整个公司的人员结构可以看作是一棵标准的、 没有环的多叉树。树的头节点是公司唯一的老板。除老板之外的每个员工都有唯一的直接上级。 叶节点是没有任何下属的基层员工(subordinates列表为空)，除基层员工外，每个员工都有一个或多个直接下级。</p>
<p>这个公司现在要办party，你可以决定哪些员工来，哪些员工不来，规则：</p>
<ul>
<li>如果某个员工来了，那么这个 员工的所有直接下级都不能来</li>
<li>派对的整体快乐值是所有到场员工快乐值的累加</li>
<li>你的目标是让派对的整体快乐值尽量大</li>
<li>给定一棵多叉树的头节点boss，请返回派对的最大快乐值。</li>
</ul>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201213134214.png" srcset="/img/loading.gif" alt="情况分类"></p>
<ol>
<li><p>如果x来，则x的happy，a不来情况下整棵树的最大值，b不来情况下整棵树的最大值，c不来情况下整棵树的最大值</p>
</li>
<li><p>如果x不来，a、b、c不一定会发，应该求Max(a来情况下整棵树最大值，a不来情况下整棵树最大值)</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201213134923.png" srcset="/img/loading.gif" alt="x不来情况"></p>
</li>
<li><p>比较第一种和第二种情况</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Info</span> </span>&#123;
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> yes; <span class="hljs-comment">// 头结点来情况下整棵树最大值</span>
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> no; <span class="hljs-comment">// 头结点不来情况下整棵树最大值</span>

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Info</span><span class="hljs-params">(<span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> n)</span> </span>&#123;
      yes = y;
      no = n;
   &#125;
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Info <span class="hljs-title">process2</span><span class="hljs-params">(Employee x)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (x.nexts.isEmpty()) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Info(x.happy, <span class="hljs-number">0</span>);
   &#125;
   <span class="hljs-keyword">int</span> yes = x.happy;
   <span class="hljs-keyword">int</span> no = <span class="hljs-number">0</span>;
   <span class="hljs-keyword">for</span> (Employee next : x.nexts) &#123;
     <span class="hljs-comment">// 遍历孩子</span>
      Info nextInfo = process2(next);
     <span class="hljs-comment">// 父亲来的值加上子不来</span>
      yes += nextInfo.no;
     <span class="hljs-comment">// 父亲不来值加上子来或不来最大值</span>
      no += Math.max(nextInfo.yes, nextInfo.no);
   &#125;
   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Info(yes, no);
&#125;</code></pre>



</li>
</ol>
<h2 id="给定一棵二叉树的头节点head，返回这颗二叉树是不是满二叉树"><a href="#给定一棵二叉树的头节点head，返回这颗二叉树是不是满二叉树" class="headerlink" title="给定一棵二叉树的头节点head，返回这颗二叉树是不是满二叉树"></a>给定一棵二叉树的头节点head，返回这颗二叉树是不是满二叉树</h2><blockquote>
<p>2^L - 1 = N</p>
</blockquote>
<p>找出一棵树的高度和结点个数，组成info。</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Info</span> </span>&#123;
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> height; <span class="hljs-comment">// L</span>
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> nodes; <span class="hljs-comment">// N</span>

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Info</span><span class="hljs-params">(<span class="hljs-keyword">int</span> h, <span class="hljs-keyword">int</span> n)</span> </span>&#123;
      height = h;
      nodes = n;
   &#125;
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Info <span class="hljs-title">process</span><span class="hljs-params">(Node head)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Info(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
   &#125;
   Info leftInfo = process(head.left);
   Info rightInfo = process(head.right);
   <span class="hljs-keyword">int</span> height = Math.max(leftInfo.height, rightInfo.height) + <span class="hljs-number">1</span>;
   <span class="hljs-keyword">int</span> nodes = leftInfo.nodes + rightInfo.nodes + <span class="hljs-number">1</span>;
   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Info(height, nodes);
&#125;</code></pre>

<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isFull2</span><span class="hljs-params">(Node head)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
   &#125;
   Info all = process(head);
   <span class="hljs-keyword">return</span> (<span class="hljs-number">1</span> &lt;&lt; all.height) - <span class="hljs-number">1</span> == all.nodes;
&#125;</code></pre>



<h2 id="给定一棵二叉树的头节点head，返回这颗二叉树是不是搜索二叉树"><a href="#给定一棵二叉树的头节点head，返回这颗二叉树是不是搜索二叉树" class="headerlink" title="给定一棵二叉树的头节点head，返回这颗二叉树是不是搜索二叉树"></a>给定一棵二叉树的头节点head，返回这颗二叉树是不是搜索二叉树</h2><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Info</span> </span>&#123;
   <span class="hljs-keyword">boolean</span> isBST;
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> min;
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> max;

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Info</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> is, <span class="hljs-keyword">int</span> mi, <span class="hljs-keyword">int</span> ma)</span> </span>&#123;
      isBST = is;
      min = mi;
      max = ma;
   &#125;
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Info <span class="hljs-title">process</span><span class="hljs-params">(Node head)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
   &#125;
   Info leftInfo = process(head.left);
   Info rightInfo = process(head.right);
   <span class="hljs-keyword">int</span> min = head.value;
   <span class="hljs-keyword">int</span> max = head.value;
   <span class="hljs-keyword">if</span> (leftInfo != <span class="hljs-keyword">null</span>) &#123;
      min = Math.min(min, leftInfo.min);
      max = Math.max(max, leftInfo.max);
   &#125;
   <span class="hljs-keyword">if</span> (rightInfo != <span class="hljs-keyword">null</span>) &#123;
      min = Math.min(min, rightInfo.min);
      max = Math.max(max, rightInfo.max);
   &#125;
   <span class="hljs-keyword">boolean</span> isBST = <span class="hljs-keyword">false</span>;
   <span class="hljs-keyword">if</span> (
      (leftInfo == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">true</span> : (leftInfo.isBST &amp;&amp; leftInfo.max &lt; head.value))
      &amp;&amp;
       (rightInfo == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">true</span> : (rightInfo.isBST &amp;&amp; rightInfo.min &gt; head.value))
             ) &#123;
      isBST = <span class="hljs-keyword">true</span>;
   &#125;
   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Info(isBST, min, max);
&#125;</code></pre>



<h2 id="给定一棵二叉树的头节点head，返回这颗二叉树中最大的二叉搜索子树的头节点"><a href="#给定一棵二叉树的头节点head，返回这颗二叉树中最大的二叉搜索子树的头节点" class="headerlink" title="给定一棵二叉树的头节点head，返回这颗二叉树中最大的二叉搜索子树的头节点"></a>给定一棵二叉树的头节点head，返回这颗二叉树中最大的二叉搜索子树的头节点</h2><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Info</span> </span>&#123;
  <span class="hljs-comment">// 最大二叉搜索子树的头结点</span>
   <span class="hljs-keyword">public</span> Node maxSubBSTHead;
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> maxSubBSTSize;
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> min;
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> max;

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Info</span><span class="hljs-params">(Node h, <span class="hljs-keyword">int</span> size, <span class="hljs-keyword">int</span> mi, <span class="hljs-keyword">int</span> ma)</span> </span>&#123;
      maxSubBSTHead = h;
      maxSubBSTSize = size;
      min = mi;
      max = ma;
   &#125;
&#125;</code></pre>

<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Info <span class="hljs-title">process</span><span class="hljs-params">(Node head)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
   &#125;
   Info leftInfo = process(head.left);
   Info rightInfo = process(head.right);
   <span class="hljs-keyword">int</span> min = head.value;
   <span class="hljs-keyword">int</span> max = head.value;
   Node maxSubBSTHead = <span class="hljs-keyword">null</span>;
   <span class="hljs-keyword">int</span> maxSubBSTSize = <span class="hljs-number">0</span>;
   <span class="hljs-keyword">if</span> (leftInfo != <span class="hljs-keyword">null</span>) &#123;
      min = Math.min(min, leftInfo.min);
      max = Math.max(max, leftInfo.max);
      maxSubBSTHead = leftInfo.maxSubBSTHead;
      maxSubBSTSize = leftInfo.maxSubBSTSize;
   &#125;
   <span class="hljs-keyword">if</span> (rightInfo != <span class="hljs-keyword">null</span>) &#123;
      min = Math.min(min, rightInfo.min);
      max = Math.max(max, rightInfo.max);
      <span class="hljs-keyword">if</span> (rightInfo.maxSubBSTSize &gt; maxSubBSTSize) &#123;
         maxSubBSTHead = rightInfo.maxSubBSTHead;
         maxSubBSTSize = rightInfo.maxSubBSTSize;
      &#125;
   &#125;
   <span class="hljs-keyword">if</span> ((leftInfo == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">true</span> : (leftInfo.maxSubBSTHead == head.left &amp;&amp; leftInfo.max &lt; head.value))
         &amp;&amp; (rightInfo == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">true</span> : (rightInfo.maxSubBSTHead == head.right &amp;&amp; rightInfo.min &gt; head.value))) &#123;
      maxSubBSTHead = head;
      maxSubBSTSize = (leftInfo == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : leftInfo.maxSubBSTSize)
            + (rightInfo == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : rightInfo.maxSubBSTSize) + <span class="hljs-number">1</span>;
   &#125;
   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Info(maxSubBSTHead, maxSubBSTSize, min, max);
&#125;</code></pre>



<h2 id="给定一棵二叉树的头节点head，返回这颗二叉树中是不是完全二叉树"><a href="#给定一棵二叉树的头节点head，返回这颗二叉树中是不是完全二叉树" class="headerlink" title="给定一棵二叉树的头节点head，返回这颗二叉树中是不是完全二叉树"></a>给定一棵二叉树的头节点head，返回这颗二叉树中是不是完全二叉树</h2><p>要么满，要么从左到右依次变慢。</p>
<p>基本解法：宽度优先遍历</p>
<p>Code1:</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isCBT1</span><span class="hljs-params">(Node head)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
   &#125;
   LinkedList&lt;Node&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();
   <span class="hljs-comment">// 是否遇到过左右两个孩子不双全的节点</span>
   <span class="hljs-keyword">boolean</span> leaf = <span class="hljs-keyword">false</span>;
   Node l = <span class="hljs-keyword">null</span>;
   Node r = <span class="hljs-keyword">null</span>;
   queue.add(head);
   <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;
      head = queue.poll();
      l = head.left;
      r = head.right;
      <span class="hljs-keyword">if</span> (
      <span class="hljs-comment">// 如果遇到了不双全的节点之后，又发现当前节点不是叶节点</span>
      (leaf &amp;&amp; !(l == <span class="hljs-keyword">null</span> &amp;&amp; r == <span class="hljs-keyword">null</span>)) || (l == <span class="hljs-keyword">null</span> &amp;&amp; r != <span class="hljs-keyword">null</span>)) &#123;
         <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
      &#125;
      <span class="hljs-keyword">if</span> (l != <span class="hljs-keyword">null</span>) &#123;
         queue.add(l);
      &#125;
      <span class="hljs-keyword">if</span> (r != <span class="hljs-keyword">null</span>) &#123;
         queue.add(r);
      &#125;
      <span class="hljs-keyword">if</span> (l == <span class="hljs-keyword">null</span> || r == <span class="hljs-keyword">null</span>) &#123;
         leaf = <span class="hljs-keyword">true</span>;
      &#125;
   &#125;
   <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
&#125;</code></pre>



<ol>
<li><p>任何结点有右无左，肯定不是。</p>
</li>
<li><p>否则继续，遇到第一个左右孩子不双全的结点，后续遇到的左右结点都必须是叶结点。</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201213164434.png" srcset="/img/loading.gif" alt="流程"></p>
<p>条件2找到缺口，以下必须为叶子结点。</p>
</li>
</ol>
<p>Code2:</p>
<p>根据最后一个结点到哪了进行分类：</p>
<ol>
<li><p>满二叉树，无缺口 （左树满，右树满，高度一样）</p>
</li>
<li><p>有缺口，第一种缺口停左树 ，最后左边有（左完全二叉，右树满，左树高 - 右树高 = 1）</p>
</li>
<li><p>有缺口，左树填满，缺口还没到右边 （左树满，右树满，左树高度 - 右树高度 = 1）</p>
</li>
<li><p>有缺口，左树填满，右树最后左边有，（左树满，右树完全二叉， 左树高度 = 右树高度）</p>
</li>
</ol>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Info</span> </span>&#123;
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> isFull;
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> isCBT;
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> height;

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Info</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> full, <span class="hljs-keyword">boolean</span> cbt, <span class="hljs-keyword">int</span> h)</span> </span>&#123;
      isFull = full;
      isCBT = cbt;
      height = h;
   &#125;
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Info <span class="hljs-title">process</span><span class="hljs-params">(Node head)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Info(<span class="hljs-keyword">true</span>, <span class="hljs-keyword">true</span>, <span class="hljs-number">0</span>);
   &#125;
   Info leftInfo = process(head.left);
   Info rightInfo = process(head.right);
   <span class="hljs-keyword">int</span> height = Math.max(leftInfo.height, rightInfo.height) + <span class="hljs-number">1</span>;
   <span class="hljs-keyword">boolean</span> isFull = leftInfo.isFull &amp;&amp; rightInfo.isFull &amp;&amp; leftInfo.height == rightInfo.height;
   <span class="hljs-keyword">boolean</span> isCBT = <span class="hljs-keyword">false</span>;
   <span class="hljs-keyword">if</span> (isFull) &#123;
      isCBT = <span class="hljs-keyword">true</span>;
   &#125; <span class="hljs-keyword">else</span> &#123;
      <span class="hljs-keyword">if</span> (leftInfo.isCBT &amp;&amp; rightInfo.isCBT) &#123;
         <span class="hljs-keyword">if</span> (leftInfo.isCBT &amp;&amp; rightInfo.isFull &amp;&amp; leftInfo.height == rightInfo.height + <span class="hljs-number">1</span>) &#123;
            isCBT = <span class="hljs-keyword">true</span>;
         &#125;
         <span class="hljs-keyword">if</span> (leftInfo.isFull &amp;&amp; rightInfo.isFull &amp;&amp; leftInfo.height == rightInfo.height + <span class="hljs-number">1</span>) &#123;
            isCBT = <span class="hljs-keyword">true</span>;
         &#125;
         <span class="hljs-keyword">if</span> (leftInfo.isFull &amp;&amp; rightInfo.isCBT &amp;&amp; leftInfo.height == rightInfo.height) &#123;
            isCBT = <span class="hljs-keyword">true</span>;
         &#125;
      &#125;
   &#125;
   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Info(isFull, isCBT, height);
&#125;</code></pre>



<h2 id="给定一棵二叉树的头节点head，和另外两个节点a和b。返回a和b的最低公共祖先"><a href="#给定一棵二叉树的头节点head，和另外两个节点a和b。返回a和b的最低公共祖先" class="headerlink" title="给定一棵二叉树的头节点head，和另外两个节点a和b。返回a和b的最低公共祖先"></a>给定一棵二叉树的头节点head，和另外两个节点a和b。返回a和b的最低公共祖先</h2><p>不用套路：整棵树遍历过程中 <strong>生成一张表</strong>，记录父节点。</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201213171301.png" srcset="/img/loading.gif" alt="让Y往上找"></p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">lowestAncestor1</span><span class="hljs-params">(Node head, Node o1, Node o2)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
   &#125;
   HashMap&lt;Node, Node&gt; parentMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
   parentMap.put(head, <span class="hljs-keyword">null</span>);
   fillParentMap(head, parentMap);
   HashSet&lt;Node&gt; o1Set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();
   Node cur = o1;
   o1Set.add(cur);
   <span class="hljs-keyword">while</span> (parentMap.get(cur) != <span class="hljs-keyword">null</span>) &#123;
      cur = parentMap.get(cur);
      o1Set.add(cur);
   &#125;
   cur = o2;
   <span class="hljs-keyword">while</span> (!o1Set.contains(cur)) &#123;
      cur = parentMap.get(cur);
   &#125;
   <span class="hljs-keyword">return</span> cur;
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fillParentMap</span><span class="hljs-params">(Node head, HashMap&lt;Node, Node&gt; parentMap)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (head.left != <span class="hljs-keyword">null</span>) &#123;
      parentMap.put(head.left, head);
      fillParentMap(head.left, parentMap);
   &#125;
   <span class="hljs-keyword">if</span> (head.right != <span class="hljs-keyword">null</span>) &#123;
      parentMap.put(head.right, head);
      fillParentMap(head.right, parentMap);
   &#125;
&#125;</code></pre>

<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201213171603.png" srcset="/img/loading.gif" alt="流程" style="zoom:50%;" />

<p>记录e以上都有谁，f网上找，第一个找到的就是。</p>
<p>套路：</p>
<ol>
<li><p>01, 02没有在x上</p>
</li>
<li><p>01, 02只有一个在x上</p>
</li>
<li><p>01, 02都在x为头的树上 A:左树右树各一个，B:左树或者右树包含全</p>
</li>
<li><p>01, 02有一个为x</p>
</li>
</ol>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Info</span> </span>&#123;
   <span class="hljs-comment">// o1,o2最初交汇点</span>
   <span class="hljs-keyword">public</span> Node ans;
   <span class="hljs-comment">// 有无发现过o1</span>
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> findO1;
   <span class="hljs-comment">// 有无发现过o2</span>
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> findO2;

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Info</span><span class="hljs-params">(Node a, <span class="hljs-keyword">boolean</span> f1, <span class="hljs-keyword">boolean</span> f2)</span> </span>&#123;
      ans = a;
      findO1 = f1;
      findO2 = f2;
   &#125;
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Info <span class="hljs-title">process</span><span class="hljs-params">(Node head, Node o1, Node o2)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Info(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>);
   &#125;
   Info leftInfo = process(head.left, o1, o2);
   Info rightInfo = process(head.right, o1, o2);

   <span class="hljs-keyword">boolean</span> findO1 = head == o1 || leftInfo.findO1 || rightInfo.findO1;
   <span class="hljs-keyword">boolean</span> findO2 = head == o2 || leftInfo.findO2 || rightInfo.findO2;
  <span class="hljs-comment">// 找交汇点</span>
   Node ans = <span class="hljs-keyword">null</span>;
  <span class="hljs-comment">// 左树提前交汇了</span>
   <span class="hljs-keyword">if</span> (leftInfo.ans != <span class="hljs-keyword">null</span>) &#123;
      ans = leftInfo.ans;
   &#125;
  <span class="hljs-comment">// 右树提前交汇了</span>
   <span class="hljs-keyword">if</span> (rightInfo.ans != <span class="hljs-keyword">null</span>) &#123;
      ans = rightInfo.ans;
   &#125;
  <span class="hljs-comment">// head为交汇点</span>
   <span class="hljs-keyword">if</span> (ans == <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">if</span> (findO1 &amp;&amp; findO2) &#123;
         ans = head;
      &#125;
   &#125;
   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Info(ans, findO1, findO2);
&#125;</code></pre>



<h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><p>1）最 <strong>自然智慧</strong> 的算法</p>
<p>2）用一种局部最功利的标准，总是做出 <strong>在当前看来</strong> 是最好的选择</p>
<p>3）难点在于 <strong>证明局部最功利的标准可以得到全局最优解</strong></p>
<p>4）对于贪心算法的学习主要以增加阅历和经验为主</p>
<p> <strong>能得到最优解</strong> 的例子：一个数组中N个数，全是正数，第m个数 * arr[i] 得到分数，求分数最大最小。</p>
<p>​       排序后相乘就行了。</p>
<p> <strong>无法得到最优解</strong> 的例子：</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201214075537.png" srcset="/img/loading.gif" alt="例子"></p>
<p>贪心求解，每次拿最多数量的 1:</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201214075629.png" srcset="/img/loading.gif" alt="错误解"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201214075705.png" srcset="/img/loading.gif" alt="正确解"></p>
<h2 id="经典问题"><a href="#经典问题" class="headerlink" title="经典问题"></a>经典问题</h2><p>给定一个由字符串组成的 <strong>数组strs</strong> ，<br>必须把所有的字符串 <strong>拼接</strong> 起来，<br>返回所有可能的拼接结果中， <strong>字典序最小</strong>的结果</p>
<h3 id="字典序"><a href="#字典序" class="headerlink" title="字典序"></a>字典序</h3><blockquote>
<p>字典序</p>
</blockquote>
<ul>
<li>字符串长度一样认为字符串就是a-z的正数，即abc小于abk</li>
<li>字符串长度不一样时，短的补长，ac与b就是ac与b0，ac小于b</li>
</ul>
<p>java中compareTo方法就是比较字典序</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201214080633.png" srcset="/img/loading.gif" alt="按照字符串本身字典序排序"></p>
<p>再由字典序小的拼接到大的，并不是对的。</p>
<p> <strong>错误例子</strong> :</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201214080809.png" srcset="/img/loading.gif" alt="错误例子"></p>
<p>正确策略：</p>
<p>x拼接上y，对比y拼接上x的字典序</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201214081014.png" srcset="/img/loading.gif" alt="正确策略"></p>
<p> <strong>例如[b, ba] bab &lt; bba 所以ba放前</strong></p>
<h3 id="排序的传递性"><a href="#排序的传递性" class="headerlink" title="排序的传递性"></a>排序的传递性</h3><blockquote>
<p>排序的传递序，定义的排序是否一定会具有传递性？</p>
</blockquote>
<p>不一定！</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201214081443.png" srcset="/img/loading.gif" alt="没有传递性的例子"></p>
<p>这就如同 <strong>石头剪刀布</strong> 一样，甲乙对比，甲在前；….</p>
<p>如何证明刚才的排序是有传递性的？</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201214081633.png" srcset="/img/loading.gif" alt="传递性"></p>
<p>a.b &lt;= b.a a前，排好序后，在数组中，任何一个位置前.后都 &lt;= 后.前</p>
<blockquote>
<p>证明</p>
</blockquote>
<p>假设认为字符为26位进制，拼接这件事就可以变为数学移位并相加的运算。</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201214082243.png" srcset="/img/loading.gif" alt="移位并相加"></p>
<p>先认为字符串进位为函数m(b) 代表的意义为 K^b次方，b为字符串长度</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201214083309.png" srcset="/img/loading.gif" alt="证明"></p>
<p>中间部分共同含有ac，减掉，再共同除以b，再移动减法位置得到：</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201214083535.png" srcset="/img/loading.gif" alt="结果"></p>
<p>所以这个排序策略是有传递性的。</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201214084002.png" srcset="/img/loading.gif" alt="数学归纳法"></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyComparator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparator</span>&lt;<span class="hljs-title">String</span>&gt; </span>&#123;
   <span class="hljs-meta">@Override</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(String a, String b)</span> </span>&#123;
      <span class="hljs-keyword">return</span> (a + b).compareTo(b + a);
   &#125;
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">lowestString2</span><span class="hljs-params">(String[] strs)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (strs == <span class="hljs-keyword">null</span> || strs.length == <span class="hljs-number">0</span>) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;
   &#125;
   Arrays.sort(strs, <span class="hljs-keyword">new</span> MyComparator());
   String res = <span class="hljs-string">&quot;&quot;</span>;
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; strs.length; i++) &#123;
      res += strs[i];
   &#125;
   <span class="hljs-keyword">return</span> res;
&#125;</code></pre>



<h2 id="贪心算法求解的标准过程"><a href="#贪心算法求解的标准过程" class="headerlink" title="贪心算法求解的标准过程"></a>贪心算法求解的标准过程</h2><p>1，分析业务</p>
<p>2，根据业务逻辑找到 <strong>不同的贪心策略</strong></p>
<p>3，对于能 <strong>举出反例</strong> 的策略直接跳过，不能举出反例的策略要证明有效性</p>
<p>这往往是特别困难的，要求数学能力很高且不具有统一的技巧性</p>
<h2 id="贪心算法的解题套路"><a href="#贪心算法的解题套路" class="headerlink" title="贪心算法的解题套路"></a>贪心算法的解题套路</h2><p>1，实现一个不依靠贪心策略的解法X，可以用最暴力的尝试</p>
<p>2，脑补出贪心策略A、贪心策略B、贪心策略C…</p>
<p>3，用解法X和对数器，用实验的方式得知哪个贪心策略正确 </p>
<p>4， **不要去纠结贪心策略的证明 **</p>
<h2 id="贪心算法的解题套路实战"><a href="#贪心算法的解题套路实战" class="headerlink" title="贪心算法的解题套路实战"></a>贪心算法的解题套路实战</h2><h3 id="会议室题"><a href="#会议室题" class="headerlink" title="会议室题"></a>会议室题</h3><p>一些项目要占用一个会议室宣讲，会议室不能同时容纳两个项目的宣讲。<br>给你每一个项目 <strong>开始的时间和结束的时间</strong><br>你来安排宣讲的日程，要求会议室进行的宣讲的场次最多。<br>返回最多的宣讲场次。 </p>
<p> <strong>按会议结束时间早来贪，安排一个，把不能安排的打X，安排其他的</strong></p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">bestArrange2</span><span class="hljs-params">(Program[] programs)</span> </span>&#123;
   Arrays.sort(programs, <span class="hljs-keyword">new</span> ProgramComparator());
   <span class="hljs-keyword">int</span> timeLine = <span class="hljs-number">0</span>;
   <span class="hljs-keyword">int</span> result = <span class="hljs-number">0</span>;
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; programs.length; i++) &#123;
      <span class="hljs-keyword">if</span> (timeLine &lt;= programs[i].start) &#123;
         result++;
         timeLine = programs[i].end;
      &#125;
   &#125;
   <span class="hljs-keyword">return</span> result;
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProgramComparator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparator</span>&lt;<span class="hljs-title">Program</span>&gt; </span>&#123;

   <span class="hljs-meta">@Override</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Program o1, Program o2)</span> </span>&#123;
      <span class="hljs-keyword">return</span> o1.end - o2.end;
   &#125;

&#125;</code></pre>



<h3 id="点灯问题"><a href="#点灯问题" class="headerlink" title="点灯问题"></a>点灯问题</h3><p>给定一个字符串str，只由‘X’和‘.’两种字符构成。<br> <strong>‘X’表示墙，不能放灯，也不需要点亮</strong><br> <strong>‘.’表示居民点，可以放灯，需要点亮</strong><br>如果灯放在i位置，可以让i-1，i和i+1三个位置被点亮<br>返回如果点亮str中所有需要点亮的位置，至少需要几盏灯</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201214143040.png" srcset="/img/loading.gif" alt="贪心"></p>
<ul>
<li>i位置为x，跳下一个</li>
<li>i位置为点<ul>
<li>如果i+1为x，必须放，跳i+2</li>
<li>如果i+1为点，i+2为x，放一个，跳i+3</li>
<li>如果i+1为点，i+2为点，i+1放一个，跳i+3</li>
</ul>
</li>
</ul>
<p>总是在当前步做 <strong>最优决定</strong>。</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minLight2</span><span class="hljs-params">(String road)</span> </span>&#123;
   <span class="hljs-keyword">char</span>[] str = road.toCharArray();
   <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;
   <span class="hljs-keyword">int</span> light = <span class="hljs-number">0</span>;
   <span class="hljs-keyword">while</span> (index &lt; str.length) &#123;
      <span class="hljs-keyword">if</span> (str[index] == <span class="hljs-string">&#x27;X&#x27;</span>) &#123;
         index++;
      &#125; <span class="hljs-keyword">else</span> &#123;
         light++;
         <span class="hljs-keyword">if</span> (index + <span class="hljs-number">1</span> == str.length) &#123;
            <span class="hljs-keyword">break</span>;
         &#125; <span class="hljs-keyword">else</span> &#123;
            <span class="hljs-keyword">if</span> (str[index + <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;X&#x27;</span>) &#123;
               index = index + <span class="hljs-number">2</span>;
            &#125; <span class="hljs-keyword">else</span> &#123;
               index = index + <span class="hljs-number">3</span>;
            &#125;
         &#125;
      &#125;
   &#125;
   <span class="hljs-keyword">return</span> light;
&#125;</code></pre>



<h3 id="金块分割问题"><a href="#金块分割问题" class="headerlink" title="金块分割问题"></a>金块分割问题</h3><p>一块金条切成两半，是需要花费和长度数值一样的铜板的。<br>比如长度为20的金条，不管怎么切，都要花费20个铜板。 一群人想整分整块金条，怎么分最省铜板? </p>
<p>例如,给定数组{10,20,30}，代表一共三个人，整块金条长度为60，金条要分成10，20，30三个部分。</p>
<p>如果先把长度60的金条分成10和50，花费60; 再把长度50的金条分成20和30，花费50;一共花费110铜板。<br>但如果先把长度60的金条分成30和30，花费60;再把长度30金条分成10和20， 花费30;一共花费90铜板。<br>输入一个数组，返回分割的最小代价。 </p>
<blockquote>
<p>哈夫曼树</p>
</blockquote>
<p>堆和排序是贪心最常用手段</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201214145441.png" srcset="/img/loading.gif" alt="堆 哈夫曼树"></p>
<p>合成哈夫曼树就是从小根堆里面取两个合并再加入小根堆再合并….</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lessMoney2</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;
   PriorityQueue&lt;Integer&gt; pQ = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;();
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;
      pQ.add(arr[i]);
   &#125;
   <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;
   <span class="hljs-keyword">int</span> cur = <span class="hljs-number">0</span>;
   <span class="hljs-keyword">while</span> (pQ.size() &gt; <span class="hljs-number">1</span>) &#123;
      cur = pQ.poll() + pQ.poll();
      sum += cur;
      pQ.add(cur);
   &#125;
   <span class="hljs-keyword">return</span> sum;
&#125;</code></pre>





<h3 id="项目利益问题"><a href="#项目利益问题" class="headerlink" title="项目利益问题"></a>项目利益问题</h3><p>输入: 正数数组costs、正数数组profits、正数K、正数M<br>costs[i]表示i号项目的 <strong>花费</strong><br>profits[i]表示i号项目在扣除花费之后还能 <strong>挣到的钱(利润)</strong><br>K表示你只能串行的最多做k个项目<br>M表示你初始的资金<br>说明: 每做完一个项目，马上获得的收益，可以支持你去做下一个项目。不能并行的做项目。<br>输出：你最后获得的最大钱数。 </p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201214150806.png" srcset="/img/loading.gif" alt="解法"></p>
<ul>
<li>设置一个小根堆，按照花费排序，称为此时 <strong>被锁住的项目</strong></li>
<li>设置一个大根堆，按照利润排序，称为此事 <strong>被解锁的项目</strong></li>
<li>从小根堆里 <strong>弹出所有能被初始资金满足</strong> 的项目到大根堆，因为按照利润组织，挑选大根堆堆顶做。初始资金变为4。拿初始资金继续寻找小根堆里能满足的放入大根堆，挑选大根堆堆顶，改变资金…. </li>
</ul>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findMaximizedCapital</span><span class="hljs-params">(<span class="hljs-keyword">int</span> K, <span class="hljs-keyword">int</span> W, <span class="hljs-keyword">int</span>[] Profits, <span class="hljs-keyword">int</span>[] Capital)</span> </span>&#123;
   PriorityQueue&lt;Program&gt; minCostQ = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;(<span class="hljs-keyword">new</span> MinCostComparator());
   PriorityQueue&lt;Program&gt; maxProfitQ = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;(<span class="hljs-keyword">new</span> MaxProfitComparator());
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; Profits.length; i++) &#123;
      minCostQ.add(<span class="hljs-keyword">new</span> Program(Profits[i], Capital[i]));
   &#125;
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; K; i++) &#123;
      <span class="hljs-keyword">while</span> (!minCostQ.isEmpty() &amp;&amp; minCostQ.peek().c &lt;= W) &#123;
         maxProfitQ.add(minCostQ.poll());
      &#125;
      <span class="hljs-keyword">if</span> (maxProfitQ.isEmpty()) &#123;
         <span class="hljs-keyword">return</span> W;
      &#125;
      W += maxProfitQ.poll().p;
   &#125;
   <span class="hljs-keyword">return</span> W;
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span> </span>&#123;
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> p;
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> c;

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Program</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> c)</span> </span>&#123;
      <span class="hljs-keyword">this</span>.p = p;
      <span class="hljs-keyword">this</span>.c = c;
   &#125;
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MinCostComparator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparator</span>&lt;<span class="hljs-title">Program</span>&gt; </span>&#123;

   <span class="hljs-meta">@Override</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Program o1, Program o2)</span> </span>&#123;
      <span class="hljs-keyword">return</span> o1.c - o2.c;
   &#125;

&#125;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MaxProfitComparator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparator</span>&lt;<span class="hljs-title">Program</span>&gt; </span>&#123;

   <span class="hljs-meta">@Override</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Program o1, Program o2)</span> </span>&#123;
      <span class="hljs-keyword">return</span> o2.p - o1.p;
   &#125;

&#125;</code></pre>



<p> <strong>暴力解贪心真的很折磨</strong> </p>
<h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><h2 id="并查集code"><a href="#并查集code" class="headerlink" title="并查集code"></a>并查集code</h2><ol>
<li>有若干个样本a、b、c、d…类型假设是V</li>
<li>在并查集中一开始认为每个样本都在 <strong>单独的集合</strong> 里用户可以在任何时候调用如下两个方法：<pre><code>    **boolean isSameSet(V x, V y)** : 查询样本x和样本y是否属于一个集合
    **void union(V x, V y)** : 把x和y各自所在集合的所有样本合并成一个集合</code></pre>
</li>
<li> isSameSet和union方法的代价越低越好, 最好O(1)</li>
</ol>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201214153822.png" srcset="/img/loading.gif" alt="代表点"></p>
<p>结果若干union后，代表点不一样，就不是一个集合</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201214153934.png" srcset="/img/loading.gif" alt="union后"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201214154334.png" srcset="/img/loading.gif" alt="union操作"></p>
<p> <strong>小数量挂大数量，数量相等无所谓</strong> </p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201214154455.png" srcset="/img/loading.gif" alt="union操作完毕"></p>
<p>1）每个节点都有一条往上指的指针<br>2）节点a往上找到的头节点，叫做a所在集合的代表节点<br>3）查询x和y是否属于同一个集合，就是看看找到的代表节点是不是一个<br>4）把x和y各自所在集合的所有点合并成一个集合，只需要小集合的代表点挂在大集合的代表点的下方即可</p>
<p>code:</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">V</span>&gt; </span>&#123;
   V value;

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(V v)</span> </span>&#123;
      value = v;
   &#125;
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnionSet</span>&lt;<span class="hljs-title">V</span>&gt; </span>&#123;
   <span class="hljs-comment">// V -&gt; 结点 一一对应，建好后不会改动，记录对应关系</span>
   <span class="hljs-keyword">public</span> HashMap&lt;V, Node&lt;V&gt;&gt; nodes;
   <span class="hljs-keyword">public</span> HashMap&lt;Node&lt;V&gt;, Node&lt;V&gt;&gt; parents;
   <span class="hljs-comment">// 代表点才会有记录</span>
   <span class="hljs-keyword">public</span> HashMap&lt;Node&lt;V&gt;, Integer&gt; sizeMap;

   <span class="hljs-comment">// 初始化过程</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UnionSet</span><span class="hljs-params">(List&lt;V&gt; values)</span> </span>&#123;
      <span class="hljs-keyword">for</span> (V value : values) &#123;
         Node&lt;V&gt; node = <span class="hljs-keyword">new</span> Node&lt;&gt;(value);
         nodes.put(value, node);
         <span class="hljs-comment">// 一开始每个点都为代表点 指向自己</span>
         parents.put(node, node);
         sizeMap.put(node, <span class="hljs-number">1</span>);
      &#125;
   &#125;

   <span class="hljs-comment">// 从cur开始找，找到不能再往上找的代表点并返回</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> Node&lt;V&gt; <span class="hljs-title">findFather</span><span class="hljs-params">(Node&lt;V&gt; cur)</span> </span>&#123;
      Stack&lt;Node&lt;V&gt;&gt; path = <span class="hljs-keyword">new</span> Stack&lt;&gt;();
      <span class="hljs-keyword">while</span> (cur != parents.get(cur)) &#123;
         path.push(cur);
         cur = parents.get(cur);
      &#125;
      <span class="hljs-comment">// cur头节点</span>
      <span class="hljs-keyword">while</span> (!path.isEmpty()) &#123;
         parents.put(path.pop(), cur);
      &#125;
      <span class="hljs-keyword">return</span> cur;
   &#125;

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSameSet</span><span class="hljs-params">(V a, V b)</span> </span>&#123;
      <span class="hljs-keyword">if</span> (!nodes.containsKey(a) || !nodes.containsKey(b)) &#123;
         <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
      &#125;
      <span class="hljs-keyword">return</span> findFather(nodes.get(a)) == findFather(nodes.get(b));
   &#125;

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">union</span><span class="hljs-params">(V a, V b)</span> </span>&#123;
      <span class="hljs-keyword">if</span> (!nodes.containsKey(a) || !nodes.containsKey(b)) &#123;
         <span class="hljs-keyword">return</span>;
      &#125;
      Node&lt;V&gt; aHead = findFather(nodes.get(a));
      Node&lt;V&gt; bHead = findFather(nodes.get(b));
      <span class="hljs-keyword">if</span> (aHead != bHead) &#123;
         <span class="hljs-keyword">int</span> aSetSize = sizeMap.get(aHead);
         <span class="hljs-keyword">int</span> bSetSize = sizeMap.get(bHead);
         <span class="hljs-keyword">if</span> (aSetSize &gt;= bSetSize) &#123;
            parents.put(bHead, aHead);
            sizeMap.put(aHead, aSetSize + bSetSize);
            sizeMap.remove(bHead);
         &#125; <span class="hljs-keyword">else</span> &#123;
            parents.put(aHead, bHead);
            sizeMap.put(bHead, aSetSize + bSetSize);
            sizeMap.remove(aHead);
         &#125;
      &#125;
   &#125;
&#125;</code></pre>



<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201214155250.png" srcset="/img/loading.gif" alt="parent表和size表"></p>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>1）节点往上找代表点的过程，把沿途的链变成扁平的</p>
<p>2）小集合挂在大集合的下面</p>
<p>3）如果方法调用很频繁，那么单次调用的代价为O(1)，两个方法都如此</p>
<p>findFather()方法的优化:</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201214160644.png" srcset="/img/loading.gif" alt="打扁平"></p>
<p>将原来串联起来，改变成father全指向代表点</p>
<p>往上找的过程是该算法的瓶颈，让找的方法变为O(1)即可。</p>
<p>解释了为什么 <strong>小挂大</strong> ，也减少了 <strong>遍历链的高度</strong> </p>
<h2 id="复杂度计算"><a href="#复杂度计算" class="headerlink" title="复杂度计算"></a>复杂度计算</h2><p>N个结点 -&gt; N个集合</p>
<p>find <strong>方法越频繁，代价越低</strong>。</p>
<p>当调用次数到达 O(n)或超过，单次调用的代价为O(1)。</p>
<h2 id="题"><a href="#题" class="headerlink" title="题"></a>题</h2><p>学生类有三个String属性，身份证，b站id，githubid，任何一个属性有一组一样就算一个人。</p>
<p>一大堆实例中有几个独立出来的人。</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201214162132.png" srcset="/img/loading.gif" alt="例子"></p>
<p>所有实例进并查集，准备三张表，记录三个字段拥有者</p>
<p>当表中key相同时，并查集合并这两个实例。</p>
<p>最后看sizeMap的数。</p>
<p> <strong>解决连通性的利器</strong> </p>
<h2 id="并查集的应用"><a href="#并查集的应用" class="headerlink" title="并查集的应用"></a>并查集的应用</h2><p>解决两大块区域的合并问题</p>
<p>常用在图等领域中</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2020/11/27/Java%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">java并发编程 学习笔记</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/11/19/hello-world/">
                        <span class="hidden-mobile">Hello World</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":200})
    NProgress.start()
    document.addEventListener('DOMContentLoaded', function() {
      window.NProgress && window.NProgress.inc();
    })
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.staticfile.org/jquery/3.5.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.staticfile.org/tocbot/4.12.0/tocbot.min.js" ></script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>





  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      var inputArea = document.querySelector("#local-search-input");
      inputArea.onclick = function () {
        searchFunc(path, 'local-search-input', 'local-search-result');
        this.onclick = null
      }
    })()
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>



</body>
</html>
