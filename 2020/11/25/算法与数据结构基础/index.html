

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/imgfavicon.jpg">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  <title>数据结构与算法基础回顾笔记 - Blog</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.1.2/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.5","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"copy_btn":true,"image_zoom":{"enable":true},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.2.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Fluid</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax=true
         style="background: url('https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/imgdefault.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="数据结构与算法基础回顾笔记">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2020-11-25 16:08" pubdate>
        2020年11月25日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      19.6k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      280
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">数据结构与算法基础回顾笔记</h1>
            
            <div class="markdown-body">
              <blockquote>
<p>跟左神重学！</p>
</blockquote>
<h1 id="认识复杂度、对数器、二分法与异或运算"><a href="#认识复杂度、对数器、二分法与异或运算" class="headerlink" title="认识复杂度、对数器、二分法与异或运算"></a>认识复杂度、对数器、二分法与异或运算</h1><h2 id="认识复杂度"><a href="#认识复杂度" class="headerlink" title="认识复杂度"></a>认识复杂度</h2><blockquote>
<p>评估算法优劣的核心指标是什么？</p>
</blockquote>
<ul>
<li><p>时间复杂度（流程决定）</p>
</li>
<li><p>额外空间复杂度（流程决定）</p>
</li>
<li><p>常数项时间（实现细节决定）</p>
</li>
</ul>
<h3 id="1、什么是时间复杂度？时间复杂度怎么估算？"><a href="#1、什么是时间复杂度？时间复杂度怎么估算？" class="headerlink" title="1、什么是时间复杂度？时间复杂度怎么估算？"></a>1、什么是时间复杂度？时间复杂度怎么估算？</h3><ul>
<li>常数时间的操作</li>
<li>确定算法流程的总操作数量与样本数量之间的表达式关系</li>
<li>只看表达式最高阶项的部分</li>
</ul>
<h3 id="2、何为常数时间的操作？"><a href="#2、何为常数时间的操作？" class="headerlink" title="2、何为常数时间的操作？"></a>2、何为常数时间的操作？</h3><blockquote>
<p>如果一个操作的执行时间不以具体样本量为转移，每次执行时间都是固定时间。称这样的操作为常数时间的操作。如取Array[0]与取Array[1000000]花费时间一致， 不以数据量转移。</p>
</blockquote>
<p><strong>常见的常数时间的操作</strong></p>
<ul>
<li>常见的算术运算（+、-、*、/、% 等）</li>
<li>常见的位运算（&gt;&gt;(带符号右移)、&gt;&gt;&gt;(不带符号右移)、&lt;&lt;、|、&amp;、^等）</li>
<li>赋值、比较、自增、自减操作等</li>
<li>数组寻址操作</li>
</ul>
<p>总之，执行时间固定的操作都是常数时间的操作。<br>反之，执行时间不固定的操作，都不是常数时间的操作。</p>
<p><strong>如何确定算法流程的总操作数量与样本数量之间的表达式关系？</strong></p>
<p>​    1，想象该算法流程所处理的数据状况，要按照 <strong><em>最差</em></strong>情况来。</p>
<p>​    2，把整个流程彻底拆分为一个个 <strong><em>基本动作</em></strong>，保证每个动作都是 <strong><em>常数时间</em></strong>的操作。</p>
<p>​    3，如果数据量为N，看看基本动作的数量和N是什么关系。</p>
<h3 id="3、如何确定算法流程的时间复杂度？"><a href="#3、如何确定算法流程的时间复杂度？" class="headerlink" title="3、如何确定算法流程的时间复杂度？"></a>3、如何确定算法流程的时间复杂度？</h3><blockquote>
<p>当完成了表达式的建立，只要把最高阶项留下即可。低阶项都去掉，高阶项的系数也去掉。<br>记为：<strong>O(忽略掉系数的高阶项)</strong></p>
</blockquote>
<p>通过三个具体的例子，来实践一把时间复杂度的估算</p>
<h4 id="a、选择排序"><a href="#a、选择排序" class="headerlink" title="a、选择排序"></a>a、选择排序</h4><p>过程：<br>arr[0～N-1]范围上，找到最小值所在的位置，然后把最小值交换到0位置。<br>arr[1～N-1]范围上，找到最小值所在的位置，然后把最小值交换到1位置。<br>arr[2～N-1]范围上，找到最小值所在的位置，然后把最小值交换到2位置。<br>…<br>arr[N-1～N-1]范围上，找到最小值位置，然后把最小值交换到N-1位置。</p>
<p>估算：<br>很明显，如果arr长度为N，每一步常数操作的数量，如等差数列一般<br>所以，总的常数操作数量 = a*(N^2) + b*N + c (a、b、c都是常数)</p>
<p>所以选择排序的时间复杂度为 **O(N^2)**。</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">selectionSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length &lt; <span class="hljs-number">2</span>) &#123;
      <span class="hljs-keyword">return</span>;
   &#125;
   <span class="hljs-comment">// 0～n-1</span>
   <span class="hljs-comment">// 1～n-1</span>
   <span class="hljs-comment">// 2～n-1</span>
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length - <span class="hljs-number">1</span>; i++) &#123; <span class="hljs-comment">// i ~ N-1</span>
      <span class="hljs-comment">// 最小值在哪个位置上  i～n-1</span>
      <span class="hljs-keyword">int</span> minIndex = i;
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; arr.length; j++) &#123; <span class="hljs-comment">// i ~ N-1 上找最小值的下标 </span>
         minIndex = arr[j] &lt; arr[minIndex] ? j : minIndex;
      &#125;
      swap(arr, i, minIndex);
   &#125;
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;
   <span class="hljs-keyword">int</span> tmp = arr[i];
   arr[i] = arr[j];
   arr[j] = tmp;
&#125;</code></pre>

<h4 id="b、冒泡排序"><a href="#b、冒泡排序" class="headerlink" title="b、冒泡排序"></a>b、冒泡排序</h4><p>过程：<br>在arr[0～N-1]范围上：<br>arr[0]和arr[1]，谁大谁来到1位置；arr[1]和arr[2]，谁大谁来到2位置…arr[N-2]和arr[N-1]，谁大谁来到N-1位置</p>
<p>在arr[0～N-2]范围上，重复上面的过程，但最后一步是arr[N-3]和arr[N-2]，谁大谁来到N-2位置<br>在arr[0～N-3]范围上，重复上面的过程，但最后一步是arr[N-4]和arr[N-3]，谁大谁来到N-3位置<br>…<br>最后在arr[0～1]范围上，重复上面的过程，但最后一步是arr[0]和arr[1]，谁大谁来到1位置</p>
<p>估算：<br>很明显，如果arr长度为N，每一步常数操作的数量，依然如等差数列一般<br>所以，总的常数操作数量 = a*(N^2) + b*N + c (a、b、c都是常数)</p>
<p>所以冒泡排序的时间复杂度为O(N^2)。</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bubbleSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span></span>&#123;
        <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length &lt; <span class="hljs-number">2</span>)&#123;
            <span class="hljs-keyword">return</span>;
        &#125;

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = arr.length - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--)&#123;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++)&#123;
                <span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>])&#123;
                    swap(arr, j, j+<span class="hljs-number">1</span>);
                &#125;
            &#125;
        &#125;
    &#125;
    <span class="hljs-comment">// 交换arr的i和j位置上的值</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;
        arr[i] = arr[i] ^ arr[j];
        arr[j] = arr[i] ^ arr[j];
        arr[i] = arr[i] ^ arr[j];
    &#125;</code></pre>

<h4 id="c、插入排序"><a href="#c、插入排序" class="headerlink" title="c、插入排序"></a>c、插入排序</h4><p>过程：<br>想让arr[0<del>0]上有序，这个范围只有一个数，当然是有序的。<br>想让arr[0</del>1]上有序，所以从arr[1]开始往前看，如果arr[1]&lt;arr[0]，就交换。否则什么也不做。<br>想让arr[0<del>i]上有序，所以从arr[i]开始往前看，arr[i]这个数不停向左移动，一直移动到左边的数字不再比自己大，停止移动。<br>最后一步，想让arr[0</del>N-1]上有序， arr[N-1]这个数不停向左移动，一直移动到左边的数字不再比自己大，停止移动。</p>
<p>估算时发现这个算法流程的复杂程度，会因为数据状况的不同而不同。</p>
<pre><code class="hljs mathematica">
如果某个算法流程的复杂程度会根据数据状况的不同而不同，那么你必须要按照最差情况来估计。

很明显，在最差情况下，如果<span class="hljs-variable">arr</span>长度为<span class="hljs-built_in">N</span>，插入排序的每一步常数操作的数量，还是如等差数列一般

所以，总的常数操作数量 <span class="hljs-operator">=</span> <span class="hljs-variable">a</span><span class="hljs-operator">*</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-operator">^</span><span class="hljs-number">2</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">+</span> <span class="hljs-variable">b</span><span class="hljs-operator">*</span><span class="hljs-built_in">N</span> <span class="hljs-operator">+</span> <span class="hljs-variable">c</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">a</span>、<span class="hljs-variable">b</span>、<span class="hljs-variable">c</span>都是常数<span class="hljs-punctuation">)</span>

所以插入排序排序的时间复杂度为<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-operator">^</span><span class="hljs-number">2</span><span class="hljs-punctuation">)</span>。

</code></pre>

<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertionSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length &lt; <span class="hljs-number">2</span>) &#123;
      <span class="hljs-keyword">return</span>;
   &#125;
   <span class="hljs-comment">// 0~0 有序的</span>
   <span class="hljs-comment">// 0~i 想有序</span>
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; arr.length; i++) &#123; <span class="hljs-comment">// 0 ~ i 做到有序</span>
      
      <span class="hljs-comment">// arr[i]往前看，一直交换到合适的位置停止</span>
      <span class="hljs-comment">// ...(&lt;=)  ?       &lt;- i</span>
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[j] &gt; arr[j + <span class="hljs-number">1</span>]; j--) &#123;
         swap(arr, j, j + <span class="hljs-number">1</span>);
      &#125;
   &#125;
&#125;

<span class="hljs-comment">// i和j是一个位置的话，会出错</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;
   arr[i] = arr[i] ^ arr[j];
   arr[j] = arr[i] ^ arr[j];
   arr[i] = arr[i] ^ arr[j];
&#125;</code></pre>

<blockquote>
<p>注意</p>
</blockquote>
<ul>
<li><p>算法的过程，和具体的语言是无关的。</p>
</li>
<li><p>想分析一个算法流程的时间复杂度的前提，是对该流程非常熟悉</p>
</li>
<li><p>一定要确保在拆分算法流程时，拆分出来的所有行为都是常数时间的操作。这意味着你写算法时，对自己的用过的每一个系统api，都非常的熟悉。否则会影响你对时间复杂度的估算。</p>
<hr>
<pre><code class="hljs mathematica">排名从好到差：
<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-number">1</span><span class="hljs-punctuation">)</span>   
<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-variable">logN</span><span class="hljs-punctuation">)</span>   
<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-punctuation">)</span>   
<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-operator">*</span><span class="hljs-variable">logN</span><span class="hljs-punctuation">)</span>   
<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-operator">^</span><span class="hljs-number">2</span><span class="hljs-punctuation">)</span>   <span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-operator">^</span><span class="hljs-number">3</span><span class="hljs-punctuation">)</span>   …   <span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-operator">^</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span>
<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-number">2</span><span class="hljs-operator">^</span><span class="hljs-built_in">N</span><span class="hljs-punctuation">)</span>   <span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-number">3</span><span class="hljs-operator">^</span><span class="hljs-built_in">N</span><span class="hljs-punctuation">)</span>   …   <span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">K</span><span class="hljs-operator">^</span><span class="hljs-built_in">N</span><span class="hljs-punctuation">)</span>
<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-operator">!</span><span class="hljs-punctuation">)</span></code></pre>



</li>
</ul>
<h3 id="4、时间复杂度的意义"><a href="#4、时间复杂度的意义" class="headerlink" title="4、时间复杂度的意义"></a>4、时间复杂度的意义</h3><p>抹掉了好多东西，只剩下了一个 <strong><em>最高阶项</em></strong>啊…</p>
<p>那这个东西有什么意义呢？</p>
<p>时间复杂度的意义在于：</p>
<p>当我们要处理的样本量很大很大时，我们会发现*<strong>低阶项是什么不是最重要的 **<em>；每一项的系数是什么，不是最重要的。</em></strong>真正重要的就是最高阶项是什么***。</p>
<p>这就是时间复杂度的意义，它是衡量算法流程的复杂程度的一种指标，该指标只与 <strong><em>数据量</em></strong>有关，与 <strong><em>过程之外的优化</em></strong>无关。</p>
<h3 id="5、额外空间复杂度"><a href="#5、额外空间复杂度" class="headerlink" title="5、额外空间复杂度"></a>5、额外空间复杂度</h3><p>你要实现一个算法流程，在实现算法流程的过程中，你需要开辟一些空间来支持你的算法流程。</p>
<p>作为 <strong><em>输入参数</em></strong>的空间，不算额外空间。<br>作为 <strong><em>输出结果</em></strong>的空间，也不算额外空间。</p>
<p>因为这些都是必要的、和现实目标有关的。所以都不算。<br>但除此之外，你的流程如果还需要开辟空间才能让你的流程继续下去。这部分空间就是额外空间。<br>如果你的流程只需要开辟有限几个变量，额外空间复杂度就是O(1)。</p>
<h3 id="6、算法流程的常数项"><a href="#6、算法流程的常数项" class="headerlink" title="6、算法流程的常数项"></a>6、算法流程的常数项</h3><p>我们会发现，时间复杂度这个指标，是忽略低阶项和所有常数系数的。<br>难道同样时间复杂度的流程，在实际运行时候就一样的好吗？<br>当然不是。</p>
<p>时间复杂度只是一个很重要的指标而已。如果两个时间复杂度一样的算法，你还要去在时间上拼优劣，就进入到拼常数时间的阶段，简称 <strong><em>拼常数项</em></strong>。</p>
<blockquote>
<p>算法流程的常数项的比拼方式</p>
</blockquote>
<p> <strong><em>放弃理论分析，生成随机数据直接测</em></strong>。</p>
<p>为什么不去理论分析？<br>不是不能纯分析，而是没必要。因为不同常数时间的操作，虽然都是固定时间，但还是有快慢之分的。</p>
<p>比如，位运算的常数时间原小于算术运算的常数时间，这两个运算的常数时间又远小于数组寻址的时间。<br>所以如果纯理论分析，往往会需要非常多的分析过程。都已经到了具体细节的程度，莫不如交给实验数据好了。</p>
<h3 id="7、面试、比赛、刷题中，一个问题的最优解是什么意思？"><a href="#7、面试、比赛、刷题中，一个问题的最优解是什么意思？" class="headerlink" title="7、面试、比赛、刷题中，一个问题的最优解是什么意思？"></a>7、面试、比赛、刷题中，一个问题的最优解是什么意思？</h3><p>一般情况下，认为解决一个问题的算法流程，在 <strong><em>时间复杂度</em></strong>的指标上，一定要尽可能的 <strong><em>低</em></strong>，先满足了时间复杂度最低这个指标之后，使用最少的 <strong><em>空间</em></strong>的算法流程，叫这个问题的最优解。</p>
<p>一般说起最优解都是 <strong><em>忽略掉常数项</em></strong>这个因素的，因为这个因素只决定了实现层次的优化和考虑，而和怎么解决整个问题的思想无关。</p>
<h2 id="对数器"><a href="#对数器" class="headerlink" title="对数器"></a>对数器</h2><h3 id="1、什么是对数器"><a href="#1、什么是对数器" class="headerlink" title="1、什么是对数器"></a>1、什么是对数器</h3><blockquote>
<p>认识对数器</p>
</blockquote>
<p>1，你想要测的方法a<br>2，实现复杂度不好但是容易实现的方法b<br>3，实现一个随机样本产生器<br>4，把方法a和方法b跑相同的随机样本，看看得到的结果是否一样<br>5，如果有一个随机样本使得比对结果不一致，打印样本进行人工干预，改对方法a和方法b<br>6，当样本数量很多时比对测试依然正确，可以确定方法a已经正确。</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] generateRandomArray(<span class="hljs-keyword">int</span> maxSize, <span class="hljs-keyword">int</span> maxValue) &#123;
   <span class="hljs-comment">// Math.random() -&gt;  [0,1) 所有的小数，等概率返回一个</span>
   <span class="hljs-comment">// Math.random() * N -&gt; [0,N) 所有小数，等概率返回一个</span>
   <span class="hljs-comment">// (int)(Math.random() * N) -&gt; [0,N-1] 所有的整数，等概率返回一个</span>
   <span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[(<span class="hljs-keyword">int</span>) ((maxSize + <span class="hljs-number">1</span>) * Math.random())]; <span class="hljs-comment">// 长度随机 </span>
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;
      <span class="hljs-comment">// [-?,+?]</span>
      arr[i] = (<span class="hljs-keyword">int</span>) ((maxValue + <span class="hljs-number">1</span>) * Math.random()) 
            - (<span class="hljs-keyword">int</span>) (maxValue * Math.random());
   &#125;
   <span class="hljs-keyword">return</span> arr;
&#125;
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">comparator</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;
		Arrays.sort(arr);
	&#125;
<span class="hljs-comment">// for copy</span>
	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] copyArray(<span class="hljs-keyword">int</span>[] arr) &#123;
		<span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span>) &#123;
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
		&#125;
		<span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[arr.length];
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;
			res[i] = arr[i];
		&#125;
		<span class="hljs-keyword">return</span> res;
	&#125;

	<span class="hljs-comment">// for compare</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEqual</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr1, <span class="hljs-keyword">int</span>[] arr2)</span> </span>&#123;
		<span class="hljs-keyword">if</span> ((arr1 == <span class="hljs-keyword">null</span> &amp;&amp; arr2 != <span class="hljs-keyword">null</span>) || (arr1 != <span class="hljs-keyword">null</span> &amp;&amp; arr2 == <span class="hljs-keyword">null</span>)) &#123;
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
		&#125;
		<span class="hljs-keyword">if</span> (arr1 == <span class="hljs-keyword">null</span> &amp;&amp; arr2 == <span class="hljs-keyword">null</span>) &#123;
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
		&#125;
		<span class="hljs-keyword">if</span> (arr1.length != arr2.length) &#123;
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
		&#125;
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr1.length; i++) &#123;
			<span class="hljs-keyword">if</span> (arr1[i] != arr2[i]) &#123;
				<span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
			&#125;
		&#125;
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
	&#125;</code></pre>

<pre><code class="hljs java"><span class="hljs-comment">// for test</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
   <span class="hljs-keyword">int</span> testTime = <span class="hljs-number">500000</span>;
   <span class="hljs-keyword">int</span> maxSize = <span class="hljs-number">100</span>; <span class="hljs-comment">// 随机数组的长度0～100</span>
   <span class="hljs-keyword">int</span> maxValue = <span class="hljs-number">100</span>;<span class="hljs-comment">// 值：-100～100</span>
   <span class="hljs-keyword">boolean</span> succeed = <span class="hljs-keyword">true</span>;
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; testTime; i++) &#123;
      <span class="hljs-keyword">int</span>[] arr1 = generateRandomArray(maxSize, maxValue);
      <span class="hljs-keyword">int</span>[] arr2 = copyArray(arr1);
      insertionSort(arr1);
      comparator(arr2);
      <span class="hljs-keyword">if</span> (!isEqual(arr1, arr2)) &#123;
         <span class="hljs-comment">// 打印arr1</span>
         <span class="hljs-comment">// 打印arr2</span>
         succeed = <span class="hljs-keyword">false</span>;
         <span class="hljs-keyword">break</span>;
      &#125;
   &#125;
   System.out.println(succeed ? <span class="hljs-string">&quot;Nice!&quot;</span> : <span class="hljs-string">&quot;Fucking fucked!&quot;</span>);

   <span class="hljs-keyword">int</span>[] arr = generateRandomArray(maxSize, maxValue);
   printArray(arr);
   insertionSort(arr);
   printArray(arr);
&#125;</code></pre>

<h2 id="认识二分法"><a href="#认识二分法" class="headerlink" title="认识二分法"></a>认识二分法</h2><blockquote>
<p> 经常见到的类型是在一个有序数组上，开展二分搜索，但有序真的是所有问题求解时使用二分的必要条件吗？<br>不！<br>只要能正确构建左右两侧的淘汰逻辑，你就可以二分。</p>
</blockquote>
<h3 id="1、在一个有序数组中，找某个数是否存在"><a href="#1、在一个有序数组中，找某个数是否存在" class="headerlink" title="1、在一个有序数组中，找某个数是否存在"></a>1、在一个有序数组中，找某个数是否存在</h3><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">exist</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] sortedArr, <span class="hljs-keyword">int</span> num)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (sortedArr == <span class="hljs-keyword">null</span> || sortedArr.length == <span class="hljs-number">0</span>) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
   &#125;
   <span class="hljs-keyword">int</span> L = <span class="hljs-number">0</span>;
   <span class="hljs-keyword">int</span> R = sortedArr.length - <span class="hljs-number">1</span>;
   <span class="hljs-keyword">int</span> mid = <span class="hljs-number">0</span>;
   <span class="hljs-comment">// L..R</span>
   <span class="hljs-keyword">while</span> (L &lt; R) &#123;
      <span class="hljs-comment">// 防L R 因数值过大 相加后溢出</span>
      mid = L + ((R - L) &gt;&gt; <span class="hljs-number">1</span>); <span class="hljs-comment">// mid = (L + R) / 2</span>
      <span class="hljs-keyword">if</span> (sortedArr[mid] == num) &#123;
         <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sortedArr[mid] &gt; num) &#123;
         R = mid - <span class="hljs-number">1</span>;
      &#125; <span class="hljs-keyword">else</span> &#123;
         L = mid + <span class="hljs-number">1</span>;
      &#125;
   &#125;
   <span class="hljs-keyword">return</span> sortedArr[L] == num;
&#125;</code></pre>

<h3 id="2、在一个有序数组中，找-gt-某个数最左侧的位置"><a href="#2、在一个有序数组中，找-gt-某个数最左侧的位置" class="headerlink" title="2、在一个有序数组中，找&gt;=某个数最左侧的位置"></a>2、在一个有序数组中，找&gt;=某个数最左侧的位置</h3><pre><code class="hljs java"><span class="hljs-comment">// 在arr上，找满足&gt;=value的最左位置</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">nearestIndex</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> value)</span></span>&#123;
    <span class="hljs-keyword">int</span> L = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> R = arr.length - <span class="hljs-number">1</span>;
    <span class="hljs-keyword">int</span> index = -<span class="hljs-number">1</span>; <span class="hljs-comment">// 记录最左的对号</span>
    <span class="hljs-keyword">while</span> (L &lt;= R)&#123;
        <span class="hljs-keyword">int</span> mid = L + ((R - L) &gt;&gt; <span class="hljs-number">1</span>);
        <span class="hljs-keyword">if</span> (arr[mid] &gt;= value) &#123;
            index = mid;
            R = mid - <span class="hljs-number">1</span>;
        &#125; <span class="hljs-keyword">else</span> &#123;
            L = mid + <span class="hljs-number">1</span>;
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> index;
&#125;</code></pre>

<h3 id="3、-在一个有序数组中，找-lt-某个数最右侧的位置"><a href="#3、-在一个有序数组中，找-lt-某个数最右侧的位置" class="headerlink" title="3、 在一个有序数组中，找&lt;=某个数最右侧的位置"></a>3、 在一个有序数组中，找&lt;=某个数最右侧的位置</h3><pre><code class="hljs java"><span class="hljs-comment">// 在arr上，找满足&lt;=value的最右位置</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">nearestIndex</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> value)</span> </span>&#123;
    <span class="hljs-keyword">int</span> L = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> R = arr.length - <span class="hljs-number">1</span>;
    <span class="hljs-keyword">int</span> index = -<span class="hljs-number">1</span>; <span class="hljs-comment">// 记录最右的对号</span>
    <span class="hljs-keyword">while</span> (L &lt;= R) &#123;
        <span class="hljs-keyword">int</span> mid = L + ((R - L) &gt;&gt; <span class="hljs-number">1</span>);
        <span class="hljs-keyword">if</span> (arr[mid] &lt;= value) &#123;
            index = mid;
            L = mid + <span class="hljs-number">1</span>;
        &#125; <span class="hljs-keyword">else</span> &#123;
            R = mid - <span class="hljs-number">1</span>;
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> index;
&#125;</code></pre>

<h3 id="4、-局部最小值问题"><a href="#4、-局部最小值问题" class="headerlink" title="4、 局部最小值问题"></a>4、 局部最小值问题</h3><blockquote>
<ol>
<li>arr[0]&lt;arr[1]</li>
<li>Arr[len-1]&lt;Arr[len-2]</li>
<li>arr[i-1]&lt;arr[i]&lt;arr[i+1]</li>
</ol>
</blockquote>
<p>arr无序, 任意两个相邻数不相等, 只需返回一个局部最小位置:</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getLessIndex</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length == <span class="hljs-number">0</span>) &#123;
      <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">// no exist</span>
   &#125;
   <span class="hljs-keyword">if</span> (arr.length == <span class="hljs-number">1</span> || arr[<span class="hljs-number">0</span>] &lt; arr[<span class="hljs-number">1</span>]) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
   &#125;
   <span class="hljs-keyword">if</span> (arr[arr.length - <span class="hljs-number">1</span>] &lt; arr[arr.length - <span class="hljs-number">2</span>]) &#123;
      <span class="hljs-keyword">return</span> arr.length - <span class="hljs-number">1</span>;
   &#125;
   <span class="hljs-keyword">int</span> left = <span class="hljs-number">1</span>;
   <span class="hljs-keyword">int</span> right = arr.length - <span class="hljs-number">2</span>;
   <span class="hljs-keyword">int</span> mid = <span class="hljs-number">0</span>;
   <span class="hljs-keyword">while</span> (left &lt; right) &#123;
      mid = (left + right) / <span class="hljs-number">2</span>;
      <span class="hljs-keyword">if</span> (arr[mid] &gt; arr[mid - <span class="hljs-number">1</span>]) &#123;
         right = mid - <span class="hljs-number">1</span>;
      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[mid] &gt; arr[mid + <span class="hljs-number">1</span>]) &#123;
         left = mid + <span class="hljs-number">1</span>;
      &#125; <span class="hljs-keyword">else</span> &#123;
         <span class="hljs-keyword">return</span> mid;
      &#125;
   &#125;
   <span class="hljs-keyword">return</span> left;
&#125;</code></pre>

<h2 id="认识异或运算"><a href="#认识异或运算" class="headerlink" title="认识异或运算"></a>认识异或运算</h2><h3 id="1、如何记住"><a href="#1、如何记住" class="headerlink" title="1、如何记住"></a>1、如何记住</h3><p>异或运算：相同为0，不同为1<br>同或运算：相同以1，不同为0</p>
<blockquote>
<p>能长时间记住的概率接近0%</p>
<p>所以，异或运算就记成无进位相加！ </p>
</blockquote>
<h3 id="2、异或运算的性质"><a href="#2、异或运算的性质" class="headerlink" title="2、异或运算的性质"></a>2、异或运算的性质</h3><p>0^N == N      N^N == 0<br>异或运算满足交换律和结合率</p>
<p>上面的两个性质用无进位相加来理解就非常的容易</p>
<h3 id="3、如何不用额外变量交换两个数"><a href="#3、如何不用额外变量交换两个数" class="headerlink" title="3、如何不用额外变量交换两个数"></a>3、如何不用额外变量交换两个数</h3><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;
    arr[i] = arr[i] ^ arr[j];
    arr[j] = arr[i] ^ arr[j];
    arr[i] = arr[i] ^ arr[j];
&#125;</code></pre>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201125212731.png" srcset="/img/loading.gif" alt="结构"></p>
<blockquote>
<p>注意:     i和j是一个位置的话，会出错，指向的内存要求是不一样的，各自独立的。</p>
</blockquote>
<h3 id="4、一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这种数"><a href="#4、一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这种数" class="headerlink" title="4、一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这种数"></a>4、一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这种数</h3><pre><code class="hljs java"><span class="hljs-comment">// arr中，只有一种数，出现奇数次</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printOddTimesNum1</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;
   <span class="hljs-keyword">int</span> eor = <span class="hljs-number">0</span>;
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;
      eor ^= arr[i];
   &#125;
   System.out.println(eor);
&#125;</code></pre>

<h3 id="5、怎么把一个int类型的数，提取出最右侧的1来"><a href="#5、怎么把一个int类型的数，提取出最右侧的1来" class="headerlink" title="5、怎么把一个int类型的数，提取出最右侧的1来"></a>5、怎么把一个int类型的数，提取出最右侧的1来</h3><p>N &amp; ((~N)+1)</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img9SF_F0USXR87N%TE$HW3L80.png" srcset="/img/loading.gif" alt="1"></p>
<h3 id="6、一个数组中有两种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这两种数"><a href="#6、一个数组中有两种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这两种数" class="headerlink" title="6、一个数组中有两种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这两种数"></a>6、一个数组中有两种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这两种数</h3><pre><code class="hljs java"><span class="hljs-comment">// arr中，有两种数，出现奇数次</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printOddTimesNum2</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;
   <span class="hljs-keyword">int</span> eor = <span class="hljs-number">0</span>;
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;
      eor ^= arr[i];
   &#125;
   <span class="hljs-comment">// eor = a ^ b</span>
   <span class="hljs-comment">// eor != 0</span>
   <span class="hljs-comment">// eor必然有一个位置上是1</span>
   <span class="hljs-keyword">int</span> rightOne = eor &amp; (~eor + <span class="hljs-number">1</span>); <span class="hljs-comment">// 提取出最右的1</span>
   <span class="hljs-keyword">int</span> onlyOne = <span class="hljs-number">0</span>; <span class="hljs-comment">// eor&#x27;</span>
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; arr.length;i++) &#123;
      <span class="hljs-keyword">if</span> ((arr[i] &amp; rightOne) != <span class="hljs-number">0</span>) &#123;
         onlyOne ^= arr[i];
      &#125;
   &#125;
   System.out.println(onlyOne + <span class="hljs-string">&quot; &quot;</span> + (eor ^ onlyOne));
&#125;</code></pre>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201125220723.png" srcset="/img/loading.gif" alt="图解"></p>
<h1 id="链表结构、栈、队列、递归行为、哈希表"><a href="#链表结构、栈、队列、递归行为、哈希表" class="headerlink" title="链表结构、栈、队列、递归行为、哈希表"></a>链表结构、栈、队列、递归行为、哈希表</h1><h2 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h2><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> value;
    <span class="hljs-keyword">public</span> Node next;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.value = data;
    &#125;
&#125;</code></pre>

<h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DoubleNode</span> </span>&#123;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> value;
    <span class="hljs-keyword">public</span> DoubleNode last;
    <span class="hljs-keyword">public</span> DoubleNode next;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DoubleNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.value = data;
    &#125;
&#125;</code></pre>

<h2 id="单向链表和双向链表最简单的练习"><a href="#单向链表和双向链表最简单的练习" class="headerlink" title="单向链表和双向链表最简单的练习"></a>单向链表和双向链表最简单的练习</h2><blockquote>
<p> 链表相关的问题几乎都是coding问题</p>
</blockquote>
<ul>
<li><p>单链表和双链表如何反转</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">reverseLinkedList</span><span class="hljs-params">(Node head)</span> </span>&#123;
   Node pre = <span class="hljs-keyword">null</span>;
   Node next = <span class="hljs-keyword">null</span>;
   <span class="hljs-keyword">while</span> (head != <span class="hljs-keyword">null</span>) &#123;
      next = head.next; <span class="hljs-comment">// 记录head下一个</span>
      head.next = pre; <span class="hljs-comment">// 让head指向pre</span>
      pre = head; <span class="hljs-comment">// 记录初始head</span>
      head = next;<span class="hljs-comment">// head跳到下一个</span>
   &#125;
   <span class="hljs-keyword">return</span> pre;
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> DoubleNode <span class="hljs-title">reverseDoubleList</span><span class="hljs-params">(DoubleNode head)</span></span>&#123;
    DoubleNode pre = <span class="hljs-keyword">null</span>;
    DoubleNode next = <span class="hljs-keyword">null</span>;
    <span class="hljs-keyword">while</span> (head != <span class="hljs-keyword">null</span>)&#123;
        next = head.next;
        head.next = pre;
        head.last = next;
        pre = head;
        head = next;
    &#125;
    <span class="hljs-keyword">return</span> pre;
&#125;</code></pre>
</li>
<li><p>把给定值都删除</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">removeValue</span><span class="hljs-params">(Node head, <span class="hljs-keyword">int</span> num)</span></span>&#123;
    <span class="hljs-comment">// 先找到值不是value的结点，作为头结点</span>
    <span class="hljs-keyword">while</span> (head != <span class="hljs-keyword">null</span>)&#123;
        <span class="hljs-keyword">if</span> (head.value != num)&#123;
            <span class="hljs-keyword">break</span>;
        &#125;
        head = head.next;
    &#125;

    <span class="hljs-comment">// 找到后, 删除后面的</span>
    Node pre = head; <span class="hljs-comment">// 记录上一个不等于num的位置</span>
    Node cur = head; <span class="hljs-comment">// cur作为条件, 每次跳一次, 遍历链表</span>
    <span class="hljs-keyword">while</span> (cur != <span class="hljs-keyword">null</span>)&#123;
        <span class="hljs-keyword">if</span> (cur.value == num)&#123;
            pre.next = cur.next;
        &#125;<span class="hljs-keyword">else</span> &#123;
            pre = cur;
        &#125;
        cur = cur.next;
    &#125;
    <span class="hljs-keyword">return</span> head;
&#125;</code></pre>

</li>
</ul>
<p>这里就是熟悉结构。链表还有哪些常见面试题，后续有专门系统学习。</p>
<h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h2><blockquote>
<p>逻辑概念<br>栈：数据先进后出，犹如弹匣<br>队列：数据先进先出，好似排队</p>
</blockquote>
<h2 id="栈和队列的实际实现"><a href="#栈和队列的实际实现" class="headerlink" title="栈和队列的实际实现"></a>栈和队列的实际实现</h2><ul>
<li><p>双向链表实现</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;
    <span class="hljs-keyword">public</span> T value;
    <span class="hljs-keyword">public</span> Node&lt;T&gt; last;
    <span class="hljs-keyword">public</span> Node&lt;T&gt; next;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(T data)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.value = data;
    &#125;
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DoubleEndsQueue</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;

    <span class="hljs-keyword">public</span> Node&lt;T&gt; head;
    <span class="hljs-keyword">public</span> Node&lt;T&gt; tail;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addFromHead</span><span class="hljs-params">(T value)</span> </span>&#123;
        Node&lt;T&gt; cur = <span class="hljs-keyword">new</span> Node&lt;&gt;(value);
        <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>)&#123;
            head = cur;
            tail = cur;
        &#125;<span class="hljs-keyword">else</span> &#123;
            <span class="hljs-comment">// 改变结点</span>
            cur.next =  head;
            head.last = cur;
            <span class="hljs-comment">// 变更新的头结点</span>
            head = cur;
        &#125;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addFromBottom</span><span class="hljs-params">(T value)</span> </span>&#123;
        Node&lt;T&gt; cur = <span class="hljs-keyword">new</span> Node&lt;&gt;(value);
        <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>)&#123;
            head = cur;
            tail = cur;
        &#125;<span class="hljs-keyword">else</span> &#123;
            <span class="hljs-comment">// 改变结点</span>
            cur.last = tail;
            tail.next = cur;
            tail = cur;
        &#125;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">popFromHead</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>)&#123;
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
        &#125;
        Node&lt;T&gt; cur = head;
        <span class="hljs-keyword">if</span> (head == tail)&#123;
            head = <span class="hljs-keyword">null</span>;
            tail = <span class="hljs-keyword">null</span>;
        &#125;<span class="hljs-keyword">else</span> &#123;
            head = head.next;
            cur.next = <span class="hljs-keyword">null</span>;
            head.last = <span class="hljs-keyword">null</span>;
        &#125;
        <span class="hljs-keyword">return</span> cur.value;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">popFromBottom</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>)&#123;
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
        &#125;
        Node&lt;T&gt; cur = tail;
        <span class="hljs-keyword">if</span> (head == tail)&#123;
            head = <span class="hljs-keyword">null</span>;
            tail = <span class="hljs-keyword">null</span>;
        &#125;<span class="hljs-keyword">else</span> &#123;
            tail = tail.last;
            tail.next = <span class="hljs-keyword">null</span>;
            cur.last = <span class="hljs-keyword">null</span>;
        &#125;
        <span class="hljs-keyword">return</span> cur.value;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> head == <span class="hljs-keyword">null</span>;
    &#125;
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyStack</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;
    <span class="hljs-keyword">private</span> DoubleEndsQueue&lt;T&gt; queue;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyStack</span><span class="hljs-params">()</span> </span>&#123;
        queue = <span class="hljs-keyword">new</span> DoubleEndsQueue&lt;&gt;();
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(T value)</span></span>&#123;
        queue.addFromHead(value);
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>&#123;
        <span class="hljs-keyword">return</span> queue.popFromHead();
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span></span>&#123;
        <span class="hljs-keyword">return</span> queue.isEmpty();
    &#125;
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyQueue</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;
    <span class="hljs-keyword">private</span> DoubleEndsQueue&lt;T&gt; queue;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyQueue</span><span class="hljs-params">()</span> </span>&#123;
        queue = <span class="hljs-keyword">new</span> DoubleEndsQueue&lt;&gt;();
    &#125;

    <span class="hljs-comment">// 出push</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(T value)</span></span>&#123;
        queue.addFromHead(value);
    &#125;

    <span class="hljs-comment">// 进poll</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">poll</span><span class="hljs-params">()</span></span>&#123;
        <span class="hljs-keyword">return</span> queue.popFromBottom();
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span></span>&#123;
        <span class="hljs-keyword">return</span> queue.isEmpty();
    &#125;
&#125;</code></pre>
</li>
<li><p>数组实现</p>
<blockquote>
<p>数组实现栈</p>
</blockquote>
</li>
</ul>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayStack</span> </span>&#123;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span>[] a;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size;<span class="hljs-comment">//栈数组的大小</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> top;<span class="hljs-comment">//栈顶</span>

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayStack</span><span class="hljs-params">(<span class="hljs-keyword">int</span> maxSize)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.size = maxSize;
        <span class="hljs-keyword">this</span>.a = <span class="hljs-keyword">new</span> <span class="hljs-keyword">long</span>[size];
        <span class="hljs-keyword">this</span>.top = -<span class="hljs-number">1</span>;<span class="hljs-comment">//表示空栈</span>
    &#125;

    <span class="hljs-comment">//入栈</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">long</span> value)</span></span>&#123;
        <span class="hljs-keyword">if</span>(isFull())&#123;
            System.out.println(<span class="hljs-string">&quot;栈已经满！&quot;</span>);
            <span class="hljs-keyword">return</span>;
        &#125;
        a[++top] = value;
    &#125;

    <span class="hljs-comment">//返回栈顶内容，但是不删除</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">peek</span><span class="hljs-params">()</span></span>&#123;
        <span class="hljs-keyword">if</span>(isEmpty())&#123;
            System.out.println(<span class="hljs-string">&quot;栈中没有数据！&quot;</span>);
        &#125;
        System.out.println(a[top]);
    &#125;

    <span class="hljs-comment">//弹出栈顶内容，删除</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>&#123;
        <span class="hljs-keyword">if</span>(isEmpty())&#123;
            System.out.println(<span class="hljs-string">&quot;栈中没有数据！&quot;</span>);
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        &#125;
        <span class="hljs-keyword">return</span> a[top--];
    &#125;

    <span class="hljs-comment">//size栈的大小</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span></span>&#123;
        <span class="hljs-keyword">return</span> top + <span class="hljs-number">1</span>;
    &#125;

    <span class="hljs-comment">//是否为空</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> (top == -<span class="hljs-number">1</span>);
    &#125;

    <span class="hljs-comment">//是否满了</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isFull</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> (top == size - <span class="hljs-number">1</span>);
    &#125;

    <span class="hljs-comment">//显示</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span></span>&#123;
        System.out.print(<span class="hljs-string">&quot;[&quot;</span>);
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = top; i &gt;=<span class="hljs-number">0</span> ; i--) &#123;
            System.out.print(a[i]);
            <span class="hljs-keyword">if</span>(i!=<span class="hljs-number">0</span>)&#123;
                System.out.print(<span class="hljs-string">&quot;,&quot;</span>);
            &#125;
        &#125;
        System.out.println(<span class="hljs-string">&quot;]&quot;</span>);
    &#125;
&#125;</code></pre>

<blockquote>
<p>数组实现队列</p>
</blockquote>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyQueue</span> </span>&#123;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] arr;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> pushi;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> polli;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> limit;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyQueue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> limit)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[limit];
        <span class="hljs-keyword">this</span>.pushi = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">this</span>.polli = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">this</span>.size = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">this</span>.limit = limit;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (size == limit)&#123;
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;栈满了，不能再加了&quot;</span>);
        &#125;
        size++;
        arr[pushi] = value;
        pushi = nextIndex(pushi);
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">poll</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">if</span> (size == <span class="hljs-number">0</span>)&#123;
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;栈空了，不能再拿了&quot;</span>);
        &#125;
        size--;
        <span class="hljs-keyword">int</span> ans = arr[polli];
        polli = nextIndex(polli);
        <span class="hljs-keyword">return</span> ans;
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> size == <span class="hljs-number">0</span>;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">nextIndex</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>&#123;
        <span class="hljs-keyword">return</span> i &lt; limit - <span class="hljs-number">1</span> ? i + <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;
    &#125;
&#125;</code></pre>

<h2 id="栈和队列的常见面试题"><a href="#栈和队列的常见面试题" class="headerlink" title="栈和队列的常见面试题"></a>栈和队列的常见面试题</h2><h3 id="1、实现一个特殊的栈，在基本功能的基础上，再实现返回栈中最小元素的功能"><a href="#1、实现一个特殊的栈，在基本功能的基础上，再实现返回栈中最小元素的功能" class="headerlink" title="1、实现一个特殊的栈，在基本功能的基础上，再实现返回栈中最小元素的功能"></a>1、实现一个特殊的栈，在基本功能的基础上，再实现返回栈中最小元素的功能</h3><blockquote>
<p>1）pop、push、getMin操作的时间复杂度都是 O(1)。 </p>
<p>2）设计的栈类型可以使用现成的栈结构。</p>
</blockquote>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201128160516.png" srcset="/img/loading.gif" alt="实现"></p>
<p> <strong>当前数和最小栈栈顶做比较, 谁小加谁</strong>,  弹出一起弹出 —–&gt; MyStack2</p>
<p> <strong>当前数和最小栈栈顶做比较, 只有小于最小栈栈顶才压入</strong>,弹出如果Data Peek = Min Peek, 一起弹出 —–&gt; MyStack1</p>
<pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 想要压入的数比最小栈大 不压入, 小于等于压入</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyStack1</span> </span>&#123;
    <span class="hljs-keyword">private</span> Stack&lt;Integer&gt; stackData;
    <span class="hljs-keyword">private</span> Stack&lt;Integer&gt; stackMin;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyStack1</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">this</span>.stackData = <span class="hljs-keyword">new</span> Stack&lt;Integer&gt;();
        <span class="hljs-keyword">this</span>.stackMin = <span class="hljs-keyword">new</span> Stack&lt;Integer&gt;();
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> newNum)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.stackMin.isEmpty()) &#123;
            <span class="hljs-keyword">this</span>.stackMin.push(newNum);
        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (newNum &lt;= <span class="hljs-keyword">this</span>.getmin()) &#123;
            <span class="hljs-keyword">this</span>.stackMin.push(newNum);
        &#125;
        <span class="hljs-keyword">this</span>.stackData.push(newNum);
    &#125;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 弹出如果Data栈弹出的数等于最小栈栈顶则弹出</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.stackData.isEmpty()) &#123;
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;Your stack is empty.&quot;</span>);
        &#125;
        <span class="hljs-keyword">int</span> value = <span class="hljs-keyword">this</span>.stackData.pop();
        <span class="hljs-keyword">if</span> (value == <span class="hljs-keyword">this</span>.getmin()) &#123;
            <span class="hljs-keyword">this</span>.stackMin.pop();
        &#125;
        <span class="hljs-keyword">return</span> value;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getmin</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.stackMin.isEmpty()) &#123;
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;Your stack is empty.&quot;</span>);
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.stackMin.peek();
    &#125;
&#125;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 想要压入的数比最小栈大 重复压入最小栈栈顶</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyStack2</span> </span>&#123;
    <span class="hljs-keyword">private</span> Stack&lt;Integer&gt; stackData;
    <span class="hljs-keyword">private</span> Stack&lt;Integer&gt; stackMin;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyStack2</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">this</span>.stackData = <span class="hljs-keyword">new</span> Stack&lt;Integer&gt;();
        <span class="hljs-keyword">this</span>.stackMin = <span class="hljs-keyword">new</span> Stack&lt;Integer&gt;();
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> newNum)</span></span>&#123;
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.stackMin.isEmpty())&#123;
            <span class="hljs-comment">// 如果最小栈没有元素 直接压入</span>
            <span class="hljs-keyword">this</span>.stackMin.push(newNum);
        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (newNum &lt; <span class="hljs-keyword">this</span>.getMin())&#123;
            <span class="hljs-comment">// 如果最小栈栈顶小于newNum</span>
            <span class="hljs-keyword">this</span>.stackMin.push(newNum);
        &#125;<span class="hljs-keyword">else</span> &#123;
            <span class="hljs-comment">// 如果最小栈栈顶大于newNum, 重复压入栈顶元素</span>
            <span class="hljs-keyword">int</span> minNum = <span class="hljs-keyword">this</span>.getMin();
            <span class="hljs-keyword">this</span>.stackMin.push(minNum);
        &#125;
        <span class="hljs-keyword">this</span>.stackData.push(newNum);
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.stackData.isEmpty()) &#123;
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;Your stack is empty.&quot;</span>);
        &#125;
        <span class="hljs-keyword">this</span>.stackMin.pop();
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.stackData.pop();
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMin</span><span class="hljs-params">()</span></span>&#123;
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.stackMin.isEmpty())&#123;
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;Your stack is empty.&quot;</span>);
        &#125;

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.stackMin.peek();
    &#125;
&#125;</code></pre>

<h3 id="2、栈与队列互相实现"><a href="#2、栈与队列互相实现" class="headerlink" title="2、栈与队列互相实现"></a>2、栈与队列互相实现</h3><blockquote>
<p>1）如何用栈结构实现队列结构</p>
</blockquote>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TwoStacksQueue</span> </span>&#123;
        <span class="hljs-keyword">public</span> Stack&lt;Integer&gt; stackPush;
        <span class="hljs-keyword">public</span> Stack&lt;Integer&gt; stackPop;

        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TwoStacksQueue</span><span class="hljs-params">()</span> </span>&#123;
            stackPush = <span class="hljs-keyword">new</span> Stack&lt;Integer&gt;();
            stackPop = <span class="hljs-keyword">new</span> Stack&lt;Integer&gt;();
        &#125;

        <span class="hljs-comment">// push栈向pop栈倒入数据</span>
        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pushToPop</span><span class="hljs-params">()</span> </span>&#123;
            <span class="hljs-keyword">if</span> (stackPop.empty())&#123;
                <span class="hljs-keyword">while</span> (!stackPush.empty())&#123;
                    stackPop.push(stackPush.pop());
                &#125;
            &#125;
        &#125;

        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pushInt)</span></span>&#123;
            stackPush.push(pushInt);
<span class="hljs-comment">//            pushToPop();</span>
        &#125;

        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">poll</span><span class="hljs-params">()</span></span>&#123;
            <span class="hljs-keyword">if</span> (stackPop.empty() &amp;&amp; stackPush.empty()) &#123;
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;Queue is empty!&quot;</span>);
            &#125;
            pushToPop();
            <span class="hljs-keyword">return</span> stackPop.pop();
        &#125;

        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">peek</span><span class="hljs-params">()</span> </span>&#123;
            <span class="hljs-keyword">if</span> (stackPop.empty() &amp;&amp; stackPush.empty()) &#123;
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;Queue is empty!&quot;</span>);
            &#125;
            pushToPop();
            <span class="hljs-keyword">return</span> stackPop.peek();
        &#125;
    &#125;</code></pre>

<blockquote>
<p>2）如何用队列结构实现栈结构</p>
</blockquote>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TwoQueueStack</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;
    <span class="hljs-keyword">public</span> Queue&lt;T&gt; queue;
    <span class="hljs-keyword">public</span> Queue&lt;T&gt; help;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TwoQueueStack</span><span class="hljs-params">()</span> </span>&#123;
        queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();
        help = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(T value)</span></span>&#123; queue.offer(value);&#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">poll</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">while</span> (queue.size() &gt; <span class="hljs-number">1</span>)&#123;
            help.offer(queue.poll());
        &#125;
        T ans = queue.poll();
        Queue&lt;T&gt; temp = queue;
        queue = help;
        help = temp;
        <span class="hljs-keyword">return</span> ans;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">peek</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">while</span> (queue.size() &gt; <span class="hljs-number">1</span>)&#123;
            help.offer(queue.poll());
        &#125;
        T ans = queue.peek();
        Queue&lt;T&gt; temp = queue;
        queue = help;
        help = temp;
        queue.offer(ans);
        <span class="hljs-keyword">return</span> ans;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> queue.isEmpty();
    &#125;
&#125;</code></pre>

<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><blockquote>
<p>怎么从思想上理解递归</p>
</blockquote>
<p>求数组arr[L..R]中的最大值，怎么用递归方法实现。</p>
<p>1）将[L..R]范围分成左右两半。左：[L..Mid]  右[Mid+1..R]<br>2）左部分求最大值，右部分求最大值<br>3） [L..R]范围上的最大值，是max{左部分最大值，右部分最大值}</p>
<p>注意：2）是个递归过程，当范围上只有一个数，就可以不用再递归了</p>
<pre><code class="hljs java"><span class="hljs-comment">// 求arr中的最大值</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMax</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;
    <span class="hljs-keyword">return</span> process(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>);
&#125;

<span class="hljs-comment">// arr[L..R]范围上求最大值  L ... R   N</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">process</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R)</span> </span>&#123;
    <span class="hljs-keyword">if</span> (L == R) &#123; <span class="hljs-comment">// arr[L..R]范围上只有一个数，直接返回，base case</span>
        <span class="hljs-keyword">return</span> arr[L];
    &#125;
    <span class="hljs-keyword">int</span> mid = L + ((R - L) &gt;&gt; <span class="hljs-number">1</span>); <span class="hljs-comment">// 中点    1</span>
    <span class="hljs-keyword">int</span> leftMax = process(arr, L, mid);
    <span class="hljs-keyword">int</span> rightMax = process(arr, mid + <span class="hljs-number">1</span>, R);
    <span class="hljs-keyword">return</span> Math.max(leftMax, rightMax);
&#125;</code></pre>



<h3 id="递归的脑图和实际实现"><a href="#递归的脑图和实际实现" class="headerlink" title="递归的脑图和实际实现"></a>递归的脑图和实际实现</h3><p>对于新手来说，把调用的过程画出结构图是必须的，这有利于分析递归</p>
<p>递归并不是玄学，递归底层是利用系统栈来实现的</p>
<p>任何递归函数都一定可以改成非递归</p>
<h3 id="Master公式"><a href="#Master公式" class="headerlink" title="Master公式"></a>Master公式</h3><blockquote>
<p>形如T(N) = a * T(N/b) + O(N^d)(其中的a、b、d都是常数)的递归函数，可以直接通过Master公式来确定时间复杂度, a次子问题规模(总问题是子问题的b倍规模)</p>
</blockquote>
<p>以b为底, logb(a)</p>
<p>如果 log(b,a) &lt; d，复杂度为O(N^d)<br>如果 log(b,a) &gt; d，复杂度为O(N^log(b,a))<br>如果 log(b,a) == d，复杂度为O(N^d  * logN)</p>
<p>上述算法中, 把数组分成两份, 每份1/2, 其他时间复杂度为O(1)</p>
<p>T(N) = 2 * T(N/2) + O(N^0) 即O(N), 与从左往右遍历一遍是一样的</p>
<p>如果左边2/3, 右边也2/3, 也是两份, 其他再打印一次, 时间复杂度为O(n)</p>
<p>T(N) = 2 * T(N/(3/2)) + O(N^1)</p>
<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>1)哈希表在使用层面上可以理解为一种集合结构<br>2)如果只有key，没有伴随数据value，可以使用 <strong><em>HashSet</em></strong>结构<br>3)如果既有key，又有伴随数据value，可以使用 <strong><em>HashMap</em></strong>结构<br>4) <strong><em>有无伴随数据，是HashMap和HashSet唯一的区别，实际结构是一回事</em></strong><br>5)使用哈希表增(put)、删(remove)、改(put)和查(get)的操作，可以认为时间复杂度为 O(1)，但是 <strong><em>常数时间</em></strong>比较大<br>6)放入哈希表的东西，如果是基础类型， <strong><em>内部按值传递</em></strong>，内存占用是这个东西的大小 </p>
<pre><code class="hljs java"><span class="hljs-keyword">int</span> a = <span class="hljs-number">100000</span>;
<span class="hljs-keyword">int</span> b = <span class="hljs-number">100000</span>;
<span class="hljs-comment">// 不关心内存区域, 只关心对应的值</span>
System.out.println(a == b);
Integer c = <span class="hljs-number">100000</span>;
Integer d = <span class="hljs-number">100000</span>;
<span class="hljs-comment">// 关心内存区域</span>
System.out.println(c.equals(d));
Integer e = <span class="hljs-number">127</span>;  <span class="hljs-comment">//  - 128  ~  127 true, 按值传递</span>
Integer f = <span class="hljs-number">127</span>;
System.out.println(e == f);

<span class="hljs-comment">// 但是在哈希表中, 基础类型, 内部都按值传递</span></code></pre>



<p>7)放入哈希表的东西，如果不是基础类型， <strong><em>内部按引用传递</em></strong>，内存占用是8字节</p>
<pre><code class="hljs java">HashMap&lt;Node, String&gt; map2 = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
Node node1 = <span class="hljs-keyword">new</span> Node(<span class="hljs-number">1</span>);
Node node2 = node1;
map2.put(node1, <span class="hljs-string">&quot;我是node1&quot;</span>);
map2.put(node2, <span class="hljs-string">&quot;我是node1&quot;</span>);
System.out.println(map2.size());
<span class="hljs-comment">// 结果为 1</span></code></pre>

<pre><code class="hljs java">HashMap&lt;Node, String&gt; map2 = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
Node node1 = <span class="hljs-keyword">new</span> Node(<span class="hljs-number">1</span>);
Node node2 = <span class="hljs-keyword">new</span> Node(<span class="hljs-number">2</span>);
map2.put(node1, <span class="hljs-string">&quot;我是node1&quot;</span>);
map2.put(node2, <span class="hljs-string">&quot;我是node1&quot;</span>);
System.out.println(map2.size());
<span class="hljs-comment">// 结果为 2</span></code></pre>



<pre><code class="hljs processing">即如果<span class="hljs-keyword">HashMap</span>&lt;<span class="hljs-keyword">String</span>, <span class="hljs-keyword">String</span>&gt; <span class="hljs-built_in">map</span> = <span class="hljs-keyword">new</span> <span class="hljs-keyword">HashMap</span>&lt;&gt;();
<span class="hljs-built_in">key</span>和value都传<span class="hljs-number">100</span>位数据, 最终数据占用为 <span class="hljs-number">4</span> * <span class="hljs-number">100</span> * <span class="hljs-number">2</span>
但如果<span class="hljs-keyword">HashMap</span>&lt;Node, Node&gt; map2 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">HashMap</span>&lt;&gt;();
<span class="hljs-built_in">key</span>和value都传<span class="hljs-number">20</span>g数据, <span class="hljs-built_in">map</span>中只存内存地址<span class="hljs-number">8</span>字节, <span class="hljs-number">4</span> * <span class="hljs-number">8</span> * <span class="hljs-number">2</span>字节大小完成操作</code></pre>



<h2 id="有序表-TreeMap-O-logN"><a href="#有序表-TreeMap-O-logN" class="headerlink" title="有序表(TreeMap) O(logN)"></a>有序表(TreeMap) O(logN)</h2><p>1)有序表在使用层面上可以理解为一种集合结构<br>2)如果只有key，没有伴随数据value，可以使用TreeSet结构<br>3)如果既有key，又有伴随数据value，可以使用TreeMap结构<br>4)有无伴随数据，是TreeSet和TreeMap唯一的区别，底层的实际结构是一回事<br>5) <strong><em>有序表把key按照顺序组织起来，而哈希表完全不组织</em></strong></p>
<pre><code class="hljs java">System.out.println(treeMap.firstKey());
System.out.println(treeMap.lastKey());

<span class="hljs-comment">// &lt;= 4</span>
System.out.println(treeMap.floorKey(<span class="hljs-number">4</span>));
<span class="hljs-comment">// &gt;= 4</span>
System.out.println(treeMap.ceilingKey(<span class="hljs-number">4</span>));</code></pre>

<ol start="6">
<li><strong><em>红黑树</em></strong>、 <strong><em>AVL树</em></strong>、 <strong><em>size-balance-tree</em></strong>和 <strong><em>跳表</em></strong>等都属于 <strong><em>有序表</em></strong>结构，只是底层具体实现不同</li>
<li>放入如果是基础类型，内部按值传递，内存占用就是这个东西的大小</li>
<li>放入如果不是基础类型，内部按引用传递，内存占用是8字节</li>
<li>不管是什么底层具体实现，只要是有序表，都有以下固定的基本功能和固定的时间复杂度 </li>
</ol>
<blockquote>
<p>Api</p>
</blockquote>
<p>1)void put(K key, V value)<br>将一个(key，value)记录加入到表中，或者将key的记录 更新成value。<br>2)V get(K key)<br>根据给定的key，查询value并返回。<br>3)void remove(K key)<br>移除key的记录。<br>4)boolean containsKey(K key)<br>询问是否有关于key的记录。</p>
<p>5)K firstKey()<br>返回所有键值的排序结果中，最小的那个。6)K lastKey()<br>返回所有键值的排序结果中，最大的那个。7)K floorKey(K key)<br>返回&lt;= key 离key最近的那个<br>8)K ceilingKey(K key）<br>返回&gt;= key 离key最近的那个</p>
<blockquote>
<p>哈希表在使用时，增删改查时间复杂度都是O(1)<br>有序表在使用时，比哈希表功能多，时间复杂度都是O(logN)</p>
</blockquote>
<h1 id="归并排序与随机快排"><a href="#归并排序与随机快排" class="headerlink" title="归并排序与随机快排"></a>归并排序与随机快排</h1><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><blockquote>
<p>1）整体是递归，左边排好序+右边排好序+merge让整体有序</p>
</blockquote>
<p>例子: [3, 1, 2, 4]</p>
<p>主函数: f(0, 3) </p>
<p>运行后process(0,1) 再 process(2, 3) 再merge</p>
<p>而运行process(0,1) 需要process(0,0)再process(1,1)再merge</p>
<p>运行process(2, 3)需要process(2, 2)再process(3, 3)再merge</p>
<h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><pre><code class="hljs java"><span class="hljs-comment">// 递归方法实现</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mergeSort1</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span></span>&#123;
    <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length &lt; <span class="hljs-number">2</span>) &#123;
        <span class="hljs-keyword">return</span>;
    &#125;

    process(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>);
&#125;
<span class="hljs-comment">// 让arr L - R范围变成有序</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R)</span></span>&#123;
    <span class="hljs-keyword">if</span> (L == R)&#123; <span class="hljs-comment">// base case</span>
        <span class="hljs-keyword">return</span>;
    &#125;
    <span class="hljs-keyword">int</span> mid = L + (( R - L ) &gt;&gt; <span class="hljs-number">2</span>);
    process(arr, L, mid);
    process(arr, mid + <span class="hljs-number">1</span>, R);
    merge(arr, L, mid, R);
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span>  <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> M, <span class="hljs-keyword">int</span> R)</span></span>&#123;
    <span class="hljs-keyword">int</span>[] help = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[R - L + <span class="hljs-number">1</span>];
    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; <span class="hljs-comment">// help数组的指针</span>
    <span class="hljs-keyword">int</span> p1 = L; <span class="hljs-comment">// 左部分指针</span>
    <span class="hljs-keyword">int</span> p2 = M + <span class="hljs-number">1</span>; <span class="hljs-comment">// 又部分指针</span>

    <span class="hljs-keyword">while</span> (p1 &lt;= M &amp;&amp; p2 &lt;= R)&#123;
        help[i++] = arr[p1] &lt;= arr[p2] ? arr[p1++] : arr[p2++];
    &#125;
    <span class="hljs-comment">// 要么p1越界, 要么p2越界</span>
    <span class="hljs-keyword">while</span> (p1 &lt;= M)&#123;
        help[i++] = arr[p1++];
    &#125;
    <span class="hljs-keyword">while</span> (p2 &lt;= R)&#123;
        help[i++] = arr[p2++];
    &#125;

    <span class="hljs-comment">// 把help的值赋值回去</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; help.length ; j++) &#123;
        arr[L + i] = help[i];
    &#125;
&#125;</code></pre>

<h3 id="非递归实现"><a href="#非递归实现" class="headerlink" title="非递归实现"></a>非递归实现</h3><p>例子[2, 3, 1, 4, 5, 6]</p>
<p>初始k = 1, 每个最小原子单元, 即每个数自我有序,</p>
<p>K &lt;&lt; 2, 每两个一组进行merge, 变成[2, 3, 1, 4, 5, 6]</p>
<p>K &lt;&lt; 2, 每四个一组进行merge, 不够则凑一组[1, 2, 3, 4, 5, 6]</p>
<p>直到k &gt;= N</p>
<pre><code class="hljs java"><span class="hljs-comment">// 非递归方法实现</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mergeSort2</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length &lt; <span class="hljs-number">2</span>) &#123;
      <span class="hljs-keyword">return</span>;
   &#125;
   <span class="hljs-keyword">int</span> N = arr.length;
   <span class="hljs-keyword">int</span> mergeSize = <span class="hljs-number">1</span>;<span class="hljs-comment">// 一组是两倍的mergeSize, 当前有序的左组长度</span>
   <span class="hljs-keyword">while</span> (mergeSize &lt; N) &#123;
      <span class="hljs-keyword">int</span> L = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">while</span> (L &lt; N) &#123;
         <span class="hljs-comment">// L...M 左组(mergeSize大小)</span>
         <span class="hljs-comment">// 求中间</span>
         <span class="hljs-keyword">int</span> M = L + mergeSize - <span class="hljs-number">1</span>;
         <span class="hljs-keyword">if</span> (M &gt;= N) &#123;
            <span class="hljs-keyword">break</span>;
         &#125;
         <span class="hljs-comment">// L...M   M+1...R</span>
         <span class="hljs-comment">// 右组可能凑不齐mergeSize个</span>
         <span class="hljs-comment">// 求右边</span>
         <span class="hljs-keyword">int</span> R = Math.min(M + mergeSize, N - <span class="hljs-number">1</span>);
         merge(arr, L, M, R);
         <span class="hljs-comment">// 算下一次左边</span>
         L = R + <span class="hljs-number">1</span>;
      &#125;
      
      <span class="hljs-comment">// 防止溢出</span>
      <span class="hljs-keyword">if</span> (mergeSize &gt; N / <span class="hljs-number">2</span>) &#123;
         <span class="hljs-keyword">break</span>;
      &#125;
      mergeSize &lt;&lt;= <span class="hljs-number">1</span>;
   &#125;
&#125;</code></pre>

<h3 id="利用master公式来求解时间复杂度"><a href="#利用master公式来求解时间复杂度" class="headerlink" title="利用master公式来求解时间复杂度"></a>利用master公式来求解时间复杂度</h3><pre><code class="hljs mathematica"><span class="hljs-variable">T</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span><span class="hljs-operator">*</span><span class="hljs-variable">T</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-operator">/</span><span class="hljs-number">2</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">+</span> <span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-operator">^</span><span class="hljs-number">1</span><span class="hljs-punctuation">)</span>

根据<span class="hljs-variable">master</span>可知时间复杂度为<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-operator">*</span><span class="hljs-variable">logN</span><span class="hljs-punctuation">)</span>
<span class="hljs-punctuation">(</span>非递归分析<span class="hljs-operator">:</span>每次<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span> <span class="hljs-number">2</span><span class="hljs-operator">,</span> <span class="hljs-number">4</span><span class="hljs-operator">,</span> <span class="hljs-number">8</span><span class="hljs-operator">,</span> <span class="hljs-number">16</span> <span class="hljs-operator">....</span> <span class="hljs-built_in">N</span> <span class="hljs-operator">,</span> <span class="hljs-built_in">Log</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-punctuation">)</span>次<span class="hljs-operator">,</span> 所以<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-operator">*</span><span class="hljs-variable">logN</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">)</span>
<span class="hljs-variable">merge</span>过程需要辅助数组，所以额外空间复杂度为<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-punctuation">)</span>

归并排序的实质是把比较行为变成了有序信息并传递，比<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-operator">^</span><span class="hljs-number">2</span><span class="hljs-punctuation">)</span>的排序快

<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-operator">^</span><span class="hljs-number">2</span><span class="hljs-punctuation">)</span>在无限浪费比较行为<span class="hljs-operator">,</span> 例如选择排序<span class="hljs-operator">,</span> 每次都与后面比较大小</code></pre>



<h3 id="用常见面试题再深入理解一下归并排序的精髓"><a href="#用常见面试题再深入理解一下归并排序的精髓" class="headerlink" title="用常见面试题再深入理解一下归并排序的精髓"></a>用常见面试题再深入理解一下归并排序的精髓</h3><blockquote>
<p> 在一个数组中，一个数左边比它小的数的总和，叫数的小和，所有数的小和累加起来，叫数组小和。求数组小和。</p>
</blockquote>
<p>例子： [1,3,4,2,5]<br>1左边比1小的数：没有<br>3左边比3小的数：1<br>4左边比4小的数：1、3<br>2左边比2小的数：1<br>5左边比5小的数：1、3、4、 2<br>所以数组的小和为1+1+3+1+1+3+4+2=16 </p>
<p>每次merge时, 两个指针对应的数比较大小, 如果小, 则计算另外一个指针包括当前位置以后的有多少个比对方大的数字.</p>
<pre><code class="hljs css">例子:
<span class="hljs-selector-attr">[1,3,4,2,5]</span> 分为<span class="hljs-selector-attr">[1,3]</span>和<span class="hljs-selector-attr">[4,2,5]</span>
<span class="hljs-selector-attr">[1]</span> <span class="hljs-selector-attr">[3]</span><span class="hljs-selector-tag">merge</span>时, 1比3小, 1个1
<span class="hljs-selector-attr">[4,2,5]</span>分为<span class="hljs-selector-attr">[4]</span>,<span class="hljs-selector-attr">[2, 5]</span>
<span class="hljs-selector-attr">[4]</span><span class="hljs-selector-tag">merge</span>, <span class="hljs-selector-tag">return</span> 0
<span class="hljs-selector-attr">[2, 5]</span><span class="hljs-selector-tag">merge</span>时候, 2比5小, 1个2
<span class="hljs-selector-attr">[4]</span>与<span class="hljs-selector-attr">[2,5]</span><span class="hljs-selector-tag">merge</span>时候, 左指针初始4, 右指针初始2, 4 &gt; 2, <span class="hljs-selector-tag">help</span>数组放入2, 右指针右移
4 &lt; 5, 1个4,<span class="hljs-selector-tag">help</span>数组放入4,越界,放入5
<span class="hljs-selector-attr">[1,3]</span>和<span class="hljs-selector-attr">[2,4,5]</span><span class="hljs-selector-tag">merge</span>, 1&lt;2, 3个1, 3&lt;4, 2个3
结束4个1, 1个2, 2个3, 1个4,</code></pre>

<blockquote>
<p>其实就是在左指针与右指针对比时, 加上右指针开始个大于左指针数(利用右边有序)的左指针当前数</p>
<p>result += arr[p1] &lt; arr[p2] ? arr[p1] * (R - p2 + 1) : 0;</p>
<p>也可以解决降序对的问题</p>
<p>只要纠结右边有多少个数比左边大这类的问题，都可以用归并</p>
</blockquote>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">smallNum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[])</span></span>&#123;
    <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length &lt; <span class="hljs-number">2</span>)&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    &#125;

    <span class="hljs-keyword">return</span> process(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>);
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">process</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R)</span></span>&#123;
    <span class="hljs-keyword">if</span> (L == R)&#123;
        <span class="hljs-comment">// 只有一个数, 右组都没有</span>
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    &#125;

    <span class="hljs-keyword">int</span> mid = L + ((R - L) &gt;&gt; <span class="hljs-number">2</span>);
    <span class="hljs-keyword">return</span> process(arr, L, mid) + process(arr, mid + <span class="hljs-number">1</span>, R) + merge(arr, L, mid, R);
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> mid, <span class="hljs-keyword">int</span> R)</span></span>&#123;
    <span class="hljs-keyword">int</span> help[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[R - L + <span class="hljs-number">1</span>];
    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> p1 = L;
    <span class="hljs-keyword">int</span> p2 = mid + <span class="hljs-number">1</span>;
    <span class="hljs-keyword">int</span> result = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">while</span> (p1 &lt;= mid &amp;&amp; p2 &lt;= R)&#123;
        result += arr[p1] &lt; arr[p2] ? arr[p1] * (R - p2 + <span class="hljs-number">1</span>) : <span class="hljs-number">0</span>;
        help[i++] = arr[p1] &lt; arr[p2] ? arr[p1++] : arr[p2++];
    &#125;
    <span class="hljs-keyword">while</span> (p1 &lt;= mid)&#123;
        help[i++] = arr[p1++];
    &#125;
    <span class="hljs-keyword">while</span> (p2 &lt;= R)&#123;
        help[i++] = arr[p2++];
    &#125;
    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; help.length; i++) &#123;
        arr[L + i] = help[i];
    &#125;
    <span class="hljs-keyword">return</span> result;
&#125;</code></pre>

<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="Partition过程"><a href="#Partition过程" class="headerlink" title="Partition过程"></a>Partition过程</h3><blockquote>
<p>给定一个数组arr，和一个整数num。请把小于等于num的数放在数组的左边，大于num的数放在数组的右边。<br>要求额外空间复杂度O(1)，时间复杂度O(N) </p>
</blockquote>
<p>设置一个 <strong><em>小于等于区</em></strong>, 设初始位置 -1, </p>
<ol>
<li><p>[i]&lt;=num,当前数和小于等于区下一个位置交换, 小于等于区右扩, i++</p>
</li>
<li><p>[i]&gt;num, i++</p>
</li>
</ol>
<p>例子: [5, 3, 7, 2] num = 3</p>
<p>一开始小于等于区位置 -1, i=0, i[0]=5 &gt; 3, i++, 跳到3, 3&lt;=num, 与小于等于区下一个数即i[0]交换</p>
<p>变成[3, 5, 7, 2]小于等于区右扩, 初始位置为0, 逐步下去</p>
<pre><code class="hljs java"><span class="hljs-comment">// 以arr[R]做划分值</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (L &gt; R) &#123;
      <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
   &#125;
   <span class="hljs-keyword">if</span> (L == R) &#123;
      <span class="hljs-keyword">return</span> L;
   &#125;
   <span class="hljs-keyword">int</span> lessEqual = L - <span class="hljs-number">1</span>;
   <span class="hljs-keyword">int</span> index = L;
   <span class="hljs-keyword">while</span> (index &lt; R) &#123;
      <span class="hljs-keyword">if</span> (arr[index] &lt;= arr[R]) &#123;
         swap(arr, index, ++lessEqual);
      &#125;
      index++;
   &#125;
   swap(arr, ++lessEqual, R);
   <span class="hljs-keyword">return</span> lessEqual;
&#125;</code></pre>

<h3 id="荷兰国旗问题"><a href="#荷兰国旗问题" class="headerlink" title="荷兰国旗问题"></a>荷兰国旗问题</h3><blockquote>
<p>给定一个数组arr，和一个整数num。请把小于num的数放在数组的左边，等于num的数放在中间，大于num的数放在数组的右边。</p>
<p>要求额外空间复杂度O(1)，时间复杂度O(N)  </p>
</blockquote>
<p>设置一个 <strong><em>小于区</em></strong>,设初始位置 -1 ;  设置一个 <strong><em>大于区</em></strong>,设初始位置 length -1</p>
<ol>
<li><p>[i] == num, i++</p>
</li>
<li><p>[i] &lt; num, [i] 与小于区下一个交换, 小于区右扩, i++</p>
</li>
<li><p>[i] &gt; num, [i] 与大于区左一个交换, 大于区左扩, i <strong><em>停在原地</em></strong></p>
</li>
</ol>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201129162221.png" srcset="/img/loading.gif" alt="流程图"></p>
<p>i与大于区边界撞上的时候停</p>
<pre><code class="hljs java"><span class="hljs-comment">// arr[L...R] 玩荷兰国旗问题的划分，以arr[R]做划分值</span>
<span class="hljs-comment">//  &lt;arr[R]  ==arr[R]  &gt; arr[R]</span>
<span class="hljs-comment">// 返回等于区域范围</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] netherlandsFlag(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R) &#123;
   <span class="hljs-keyword">if</span> (L &gt; R) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123; -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span> &#125;;
   &#125;
   <span class="hljs-keyword">if</span> (L == R) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123; L, R &#125;;
   &#125;
   <span class="hljs-keyword">int</span> less = L - <span class="hljs-number">1</span>; <span class="hljs-comment">// &lt; 区 右边界</span>
   <span class="hljs-keyword">int</span> more = R;     <span class="hljs-comment">// &gt; 区 左边界</span>
   <span class="hljs-keyword">int</span> index = L;
   <span class="hljs-keyword">while</span> (index &lt; more) &#123;
      <span class="hljs-keyword">if</span> (arr[index] == arr[R]) &#123;
         index++;
      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[index] &lt; arr[R]) &#123;
         swap(arr, index++, ++less);
      &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// &gt;</span>
         swap(arr, index, --more);
      &#125;
   &#125;
   <span class="hljs-comment">// L...Less 小于区 less+1...more-1 等于区 more...R-1 大于区  R没动过</span>
   <span class="hljs-comment">// 交换后</span>
   <span class="hljs-comment">// L...Less 小于区 less+1.....more 等于区 more+1...R 大于区</span>
   swap(arr, more, R);
   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123; less + <span class="hljs-number">1</span>, more &#125;;
&#125;</code></pre>

<h2 id="快速排序1-0"><a href="#快速排序1-0" class="headerlink" title="快速排序1.0"></a>快速排序1.0</h2><p>在arr[L..R]范围上，进行快速排序的过程：<br>1）用arr[R]对该范围做partition，&lt;= arr[R]的数在左部分并且保证arr[R]最后来到左部分小于区的最后一个位置，记为M； &lt;= arr[R]的数在右部分（arr[M+1..R]）,此时X就已经排好序了<br>2）对arr[L..M-1]进行快速排序(递归)<br>3）对arr[M+1..R]进行快速排序(递归)<br>因为每一次partition都会搞定一个数的位置且不会再变动，所以排序能完成</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quickSort1</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length &lt; <span class="hljs-number">2</span>) &#123;
      <span class="hljs-keyword">return</span>;
   &#125;
   process1(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>);
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process1</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (L &gt;= R) &#123;
      <span class="hljs-keyword">return</span>;
   &#125;
   <span class="hljs-comment">// L..R partition arr[R]  [   &lt;=arr[R]   arr[R]    &gt;arr[R]  ]</span>
   <span class="hljs-keyword">int</span> M = partition(arr, L, R);
   process1(arr, L, M - <span class="hljs-number">1</span>);
   process1(arr, M + <span class="hljs-number">1</span>, R);
&#125;</code></pre>



<h2 id="快速排序2-0"><a href="#快速排序2-0" class="headerlink" title="快速排序2.0"></a>快速排序2.0</h2><p>在arr[L..R]范围上，进行快速排序的过程：<br>1）用arr[R]对该范围做partition，&lt; arr[R]的数在左部分，== arr[R]的数中间，&gt;arr[R]的数在右部分。假设== arr[R]的数所在范围是[a,b]<br>2）对arr[L..a-1]进行快速排序(递归)<br>3）对arr[b+1..R]进行快速排序(递归)<br>因为每一次partition都会搞定一批数的位置且不会再变动，所以排序能完成</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quickSort2</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length &lt; <span class="hljs-number">2</span>) &#123;
      <span class="hljs-keyword">return</span>;
   &#125;
   process2(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>);
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process2</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (L &gt;= R) &#123;
      <span class="hljs-keyword">return</span>;
   &#125;
   <span class="hljs-keyword">int</span>[] equalArea = netherlandsFlag(arr, L, R);
   process2(arr, L, equalArea[<span class="hljs-number">0</span>] - <span class="hljs-number">1</span>);
   process2(arr, equalArea[<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>, R);
&#125;</code></pre>

<h2 id="快速排序1-0和2-0的时间复杂度分析"><a href="#快速排序1-0和2-0的时间复杂度分析" class="headerlink" title="快速排序1.0和2.0的时间复杂度分析"></a>快速排序1.0和2.0的时间复杂度分析</h2><blockquote>
<p>数组已经有序的时候就是复杂度最高的时候<br>时间复杂度O(N^2)</p>
</blockquote>
<h2 id="快速排序3-0-随机快排-荷兰国旗技巧优化"><a href="#快速排序3-0-随机快排-荷兰国旗技巧优化" class="headerlink" title="快速排序3.0(随机快排+荷兰国旗技巧优化)"></a>快速排序3.0(随机快排+荷兰国旗技巧优化)</h2><p>在arr[L..R]范围上，进行快速排序的过程：<br>1）在这个范围上，随机选一个数记为num，<br>1）用num对该范围做partition，&lt; num的数在左部分，== num的数中间，&gt;num的数在右部分。假设== num的数所在范围是[a,b]<br>2）对arr[L..a-1]进行快速排序(递归)<br>3）对arr[b+1..R]进行快速排序(递归)<br>因为每一次partition都会搞定一批数的位置且不会再变动，所以排序能完成</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quickSort3</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length &lt; <span class="hljs-number">2</span>) &#123;
      <span class="hljs-keyword">return</span>;
   &#125;
   process3(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>);
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process3</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (L &gt;= R) &#123;
      <span class="hljs-keyword">return</span>;
   &#125;
   <span class="hljs-comment">// 1、2拿arr[R]做划分值</span>
   <span class="hljs-comment">// 3 随机选一个i, 人为放到arr[R], 再以arr[R]做划分值</span>
   swap(arr, L + (<span class="hljs-keyword">int</span>) (Math.random() * (R - L + <span class="hljs-number">1</span>)), R);
   <span class="hljs-keyword">int</span>[] equalArea = netherlandsFlag(arr, L, R);
   process3(arr, L, equalArea[<span class="hljs-number">0</span>] - <span class="hljs-number">1</span>);
   process3(arr, equalArea[<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>, R);
&#125;</code></pre>

<pre><code class="hljs apache"><span class="hljs-attribute">1</span>）通过分析知道，划分值越靠近中间，性能越好；越靠近两边，性能越差
<span class="hljs-attribute">2</span>）随机选一个数进行划分的目的就是让好情况和差情况都变成概率事件
<span class="hljs-attribute">3</span>）把每一种情况都列出来，会有每种情况下的时间复杂度，但概率都是<span class="hljs-number">1</span>/N
<span class="hljs-attribute">4</span>）那么所有情况都考虑，时间复杂度就是这种概率模型下的长期期望！</code></pre>


<p> *<strong>时间复杂度O(N<em>logN)，额外空间复杂度O(logN)都是这么来的。</em></strong></p>
<h1 id="比较器与堆"><a href="#比较器与堆" class="headerlink" title="比较器与堆"></a>比较器与堆</h1><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><h3 id="堆的实现"><a href="#堆的实现" class="headerlink" title="堆的实现"></a>堆的实现</h3><p>堆结构</p>
<p>1）堆结构就是用数组实现的完全二叉树结构</p>
<blockquote>
<p>完全二叉树是什么</p>
</blockquote>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201201131244.png" srcset="/img/loading.gif" alt="完全二叉树"></p>
<blockquote>
<p>结点从左至右变满, 一个结点也是, 两个结点, 第二个结点在左边也是</p>
</blockquote>
<p>堆可以从数组arr[0]开始, 也可以从arr[1]开始, 为什么会出现从arr[1]开始的情况？</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201201131532.png" srcset="/img/loading.gif" alt="arr[1]开始的堆"></p>
<p><strong>如图所示, 如果堆从arr[1]开始增加, 子结点以及父节点的运算都可以用位运算, 位运算就是快！</strong></p>
<p>2）完全二叉树中如果每棵子树的最大值都在顶部就是大根堆</p>
<blockquote>
<p>头结点为头的树, 最大值为头结点</p>
</blockquote>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201201131811.png" srcset="/img/loading.gif" alt="大根堆"></p>
<p>3）完全二叉树中如果每棵子树的最小值都在顶部就是小根堆</p>
<blockquote>
<p>头结点为头的树, 最小值为头结点</p>
</blockquote>
<p>4）堆结构的heapInsert与heapify操作</p>
<blockquote>
<p>heapInsert: 数放入数组后, 与父节点比较, 如果数更大, 交换, 直到换到根结点</p>
</blockquote>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span></span>&#123;
    <span class="hljs-keyword">if</span> (heapSize &gt; limit)&#123;
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;heap is full!&quot;</span>);
    &#125;
    heap[heapSize] = value;
    heapInsert(heap, heapSize++);
&#125;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 把默认最后加进来的数往上提</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@param</span> arr</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@param</span> index</span>
<span class="hljs-comment"> * arr[index] &gt; arr[(index - 1) / 2]已经包含两个条件</span>
<span class="hljs-comment"> * 1)arr[index] 不比arr[index父]大, 停</span>
<span class="hljs-comment"> * 2)index = 0, 停</span>
<span class="hljs-comment"> */</span>
<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">heapInsert</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> index)</span></span>&#123;
    <span class="hljs-keyword">while</span> (arr[index] &gt; arr[(index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>])&#123;
        swap(arr, index, (index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>);
        index = (index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;
    &#125;
&#125;</code></pre>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201201133318.png" srcset="/img/loading.gif" alt="heapInsert"></p>
<pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 删除堆的最大值并返回, 重组堆</span>
<span class="hljs-comment"> * 用最后的值去顶替arr[0]</span>
<span class="hljs-comment"> * 再往下交换, 找到左孩子与右孩子之间更大的数, 如果更小, 则交换</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span>
<span class="hljs-comment"> */</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>&#123;
    <span class="hljs-keyword">int</span> ans = heap[<span class="hljs-number">0</span>];
    <span class="hljs-comment">// -- heapSize, 之后的数据进入无效区</span>
    swap(heap, <span class="hljs-number">0</span>, -- heapSize);
    heapify(heap, <span class="hljs-number">0</span>, heapSize);
    <span class="hljs-keyword">return</span> ans;
&#125;

<span class="hljs-comment">// 从index的位置往下看, 不断的下沉</span>
<span class="hljs-comment">// 1) 孩子都不比我大 停; 2) 已经没孩子了, 停</span>
<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">heapify</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> heapSize)</span></span>&#123;
    <span class="hljs-keyword">int</span> left = index * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;
    <span class="hljs-comment">// 左孩子不越界就肯定有孩子</span>
    <span class="hljs-keyword">while</span> (left &lt; heapSize)&#123;
        <span class="hljs-comment">// 再判断有没有右孩子</span>
        <span class="hljs-comment">// 右孩子更大的条件是: 有右孩子 &amp;&amp; 右孩子大于左孩子</span>
        <span class="hljs-keyword">int</span> largest = left + <span class="hljs-number">1</span> &lt; heapSize &amp;&amp; arr[left + <span class="hljs-number">1</span>] &gt; arr[left] ? left + <span class="hljs-number">1</span> : left;
        largest = arr[largest] &gt; arr[index] ? largest : index;
        <span class="hljs-comment">// 如果index更大, 则不用下坠</span>
        <span class="hljs-keyword">if</span> (largest == index)&#123;
            <span class="hljs-keyword">break</span>;
        &#125;
        swap(arr, index, largest);
        index = largest;
        left = index * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;
    &#125;
&#125;</code></pre>

<p>5）堆结构的增大和减少<br>6）优先级队列结构，就是堆结构(小根堆)</p>
<pre><code class="hljs java">PriorityQueue&lt;Integer&gt; heap = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;(<span class="hljs-keyword">new</span> MyComp());</code></pre>

<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><blockquote>
<p>先把数组数据变为大根堆结构, 再每次arr[0]与堆最后一个结点互换, 必定会把Max丢到最后, 再heapify</p>
</blockquote>
<pre><code class="hljs java"><span class="hljs-comment">// 堆排序额外空间复杂度O(1)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">heapSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length &lt; <span class="hljs-number">2</span>) &#123;
            <span class="hljs-keyword">return</span>;
        &#125;
        <span class="hljs-comment">// O(N*logN)</span>
<span class="hljs-comment">//    for (int i = 0; i &lt; arr.length; i++) &#123; // O(N)</span>
<span class="hljs-comment">//       heapInsert(arr, i); // O(logN)</span>
<span class="hljs-comment">//    &#125;</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = arr.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;
            heapify(arr, i, arr.length);
        &#125;
        <span class="hljs-keyword">int</span> heapSize = arr.length;
        swap(arr, <span class="hljs-number">0</span>, --heapSize);
        <span class="hljs-comment">// O(N*logN)</span>
        <span class="hljs-keyword">while</span> (heapSize &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// O(N)</span>
            heapify(arr, <span class="hljs-number">0</span>, heapSize); <span class="hljs-comment">// O(logN)</span>
            swap(arr, <span class="hljs-number">0</span>, --heapSize); <span class="hljs-comment">// O(1)</span>
        &#125;
    &#125;

    <span class="hljs-comment">// arr[index]刚来的数，往上</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">heapInsert</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> index)</span> </span>&#123;
        <span class="hljs-keyword">while</span> (arr[index] &gt; arr[(index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>]) &#123;
            swap(arr, index, (index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>);
            index = (index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;
        &#125;
    &#125;

    <span class="hljs-comment">// arr[index]位置的数，能否往下移动</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">heapify</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> heapSize)</span> </span>&#123;
        <span class="hljs-keyword">int</span> left = index * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>; <span class="hljs-comment">// 左孩子的下标</span>
        <span class="hljs-keyword">while</span> (left &lt; heapSize) &#123; <span class="hljs-comment">// 下方还有孩子的时候</span>
            <span class="hljs-comment">// 两个孩子中，谁的值大，把下标给largest</span>
            <span class="hljs-comment">// 1）只有左孩子，left -&gt; largest</span>
            <span class="hljs-comment">// 2) 同时有左孩子和右孩子，右孩子的值&lt;= 左孩子的值，left -&gt; largest</span>
            <span class="hljs-comment">// 3) 同时有左孩子和右孩子并且右孩子的值&gt; 左孩子的值， right -&gt; largest</span>
            <span class="hljs-keyword">int</span> largest = left + <span class="hljs-number">1</span> &lt; heapSize &amp;&amp; arr[left + <span class="hljs-number">1</span>] &gt; arr[left] ? left + <span class="hljs-number">1</span> : left;
            <span class="hljs-comment">// 父和较大的孩子之间，谁的值大，把下标给largest</span>
            largest = arr[largest] &gt; arr[index] ? largest : index;
            <span class="hljs-keyword">if</span> (largest == index) &#123;
                <span class="hljs-keyword">break</span>;
            &#125;
            swap(arr, largest, index);
            index = largest;
            left = index * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;
        &#125;
    &#125;</code></pre>

<pre><code class="hljs mathematica"><span class="hljs-number">1</span>，先让整个数组都变成大根堆结构，建立堆的过程<span class="hljs-operator">:</span> 
    <span class="hljs-number">1</span><span class="hljs-punctuation">)</span>从上到下的方法，时间复杂度为<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-operator">*</span><span class="hljs-variable">logN</span><span class="hljs-punctuation">)</span> 
    <span class="hljs-number">2</span><span class="hljs-punctuation">)</span>从下到上的方法，时间复杂度为<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-punctuation">)</span> 
<span class="hljs-number">2</span>，把堆的最大值和堆末尾的值交换，然后减少堆的大小之后，再去调整堆，一直周而复始，时间复杂度为<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-operator">*</span><span class="hljs-variable">logN</span><span class="hljs-punctuation">)</span> 
<span class="hljs-number">3</span>，堆的大小减小成<span class="hljs-number">0</span>之后，排序完成</code></pre>



<blockquote>
<p>堆排序优化</p>
</blockquote>
<pre><code class="hljs java"><span class="hljs-comment">// O(N*logN)</span>
<span class="hljs-comment">// 给定数据的数组,一个一个插入都可以</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123; <span class="hljs-comment">// O(N)</span>
   heapInsert(arr, i); <span class="hljs-comment">// O(logN)</span>
&#125;
      
<span class="hljs-comment">// O(N)</span>
<span class="hljs-comment">// 一定要给定数据数组, 一个一个插入无法使用</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = arr.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;
   heapify(arr, i, arr.length);
&#125;</code></pre>

<p>一个O(N*logN), 一个O(N)</p>
<p>怎么证明?</p>
<p>对于从数组最后开始heapify来说, 一颗N结点的树, 最后一层结点应该为N/2, 往上依次为N/4, N/8</p>
<p>最后一层只有”看”的操作, 倒数第二层有”看”和至多一次”换”的操作, 倒数第三层有”看”和至多两次”换”的操作</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201201135242.png" srcset="/img/loading.gif" alt="堆排序优化"></p>
<h2 id="堆问题"><a href="#堆问题" class="headerlink" title="堆问题"></a>堆问题</h2><blockquote>
<p>已知一个几乎有序的数组。几乎有序是指，如果把数组排好顺序的话，每个元素移动的距离一定不超过k，并且k相对于数组长度来说是比较小的。<br>请选择一个合适的排序策略，对这个数组进行排序。</p>
</blockquote>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201207140824.png" srcset="/img/loading.gif" alt="流程"></p>
<p>把前k+1个数放入小根堆, 例如0,1,2,3,4,5位置数放入小根堆, 0～5的数才可能来到0位置, 每排好一次序, 把最小值弹出放到0位置, 再把6位置放入小根堆, 再弹最小值…</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sortedArrDistanceLessK</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> k)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span>) &#123;
      <span class="hljs-keyword">return</span>;
   &#125;
   <span class="hljs-comment">// 默认小根堆</span>
   PriorityQueue&lt;Integer&gt; heap = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;();
   <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;
   <span class="hljs-comment">// 0...K-1</span>
   <span class="hljs-keyword">for</span> (; index &lt;= Math.min(arr.length - <span class="hljs-number">1</span>, k - <span class="hljs-number">1</span>); index++) &#123;
      heap.add(arr[index]);
   &#125;
   <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;
   <span class="hljs-comment">// 先加后弹</span>
   <span class="hljs-keyword">for</span> (; index &lt; arr.length; i++, index++) &#123;
      heap.add(arr[index]);
      arr[i] = heap.poll();
   &#125;
   <span class="hljs-comment">// 没有数可以加了 只弹</span>
   <span class="hljs-keyword">while</span> (!heap.isEmpty()) &#123;
      arr[i++] = heap.poll();
   &#125;
&#125;</code></pre>

<p>O(N*logK), 前提是k小于数组长度, 每次加减logk, N次则乘</p>
<h2 id="比较器"><a href="#比较器" class="headerlink" title="比较器"></a>比较器</h2><blockquote>
<p>目前都是基于 <strong>比较</strong> 的排序, 只要告诉两个样本如何比较大小就足够</p>
</blockquote>
<p>1)比较器的实质就是 **重载比较运算符 **</p>
<p>2)比较器可以很好的应用在 <strong>特殊标准的排序</strong>上 </p>
<p>3)比较器可以很好的应用在 <strong>根据特殊标准排序的结构</strong>上</p>
<p>4)写代码变得异常容易，还用于 <strong>范型编程</strong></p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;
   <span class="hljs-keyword">public</span> String name;
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> id;
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> age;

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> id, <span class="hljs-keyword">int</span> age)</span> </span>&#123;
      <span class="hljs-keyword">this</span>.name = name;
      <span class="hljs-keyword">this</span>.id = id;
      <span class="hljs-keyword">this</span>.age = age;
   &#125;
&#125;</code></pre>

<blockquote>
<p>comp(T o1, T o2) 返回负数o1放前, 正数o2放前</p>
</blockquote>
<pre><code class="hljs java">Student student1 = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-number">2</span>, <span class="hljs-number">20</span>);
Student student2 = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-number">3</span>, <span class="hljs-number">21</span>);
Student student3 = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">22</span>);

Student[] students = <span class="hljs-keyword">new</span> Student[] &#123; student1, student2, student3 &#125;;</code></pre>



<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IdAscendingComparator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparator</span>&lt;<span class="hljs-title">Student</span>&gt; </span>&#123;

   <span class="hljs-comment">// 返回负数的时候，第一个参数排在前面</span>
   <span class="hljs-comment">// 返回正数的时候，第二个参数排在前面</span>
   <span class="hljs-comment">// 返回0的时候，谁在前面无所谓</span>
   <span class="hljs-meta">@Override</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Student o1, Student o2)</span> </span>&#123;
      <span class="hljs-keyword">return</span> o1.id - o2.id;
   &#125;
&#125;
Arrays.sort(students, <span class="hljs-keyword">new</span> IdAscendingComparator());
<span class="hljs-comment">// id升序</span></code></pre>



<pre><code class="hljs java"><span class="hljs-comment">// 先按照id排序，id小的，放前面；</span>
<span class="hljs-comment">// id一样，age大的，前面；</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IdInAgeDe</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparator</span>&lt;<span class="hljs-title">Student</span>&gt; </span>&#123;

   <span class="hljs-meta">@Override</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Student o1, Student o2)</span> </span>&#123;
      <span class="hljs-keyword">return</span> o1.id != o2.id ? o1.id - o2.id  : (  o2.age - o1.age  );
   &#125;
<span class="hljs-comment">// 更复杂的比较器</span>
&#125;</code></pre>



<h3 id="应用在根据特殊标准排序的结构上"><a href="#应用在根据特殊标准排序的结构上" class="headerlink" title="应用在根据特殊标准排序的结构上"></a>应用在根据特殊标准排序的结构上</h3><pre><code class="hljs java">PriorityQueue&lt;Student&gt; minHeapBasedId
        = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;(<span class="hljs-keyword">new</span> AgeAscendingComparator());
minHeapBasedId.add(student1);
minHeapBasedId.add(student2);
minHeapBasedId.add(student3);
<span class="hljs-keyword">while</span> (!minHeapBasedId.isEmpty()) &#123;
    Student student = minHeapBasedId.poll();
    System.out.println(<span class="hljs-string">&quot;Name : &quot;</span> + student.name + <span class="hljs-string">&quot;, Id : &quot;</span> + student.id + <span class="hljs-string">&quot;, Age : &quot;</span> + student.age);
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AgeAscendingComparator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparator</span>&lt;<span class="hljs-title">Student</span>&gt; </span>&#123;
        <span class="hljs-meta">@Override</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Student o1, Student o2)</span> </span>&#123;
            <span class="hljs-keyword">return</span> o1.age - o2.age;
        &#125;
&#125;</code></pre>

<p>结果:</p>
<pre><code class="hljs asciidoc">
===========================
Name : A, Id : 2, Age : 20
Name : B, Id : 3, Age : 21
Name : C, Id : 1, Age : 22
===========================</code></pre>



<h2 id="语言提供的堆结构-vs-手写的堆结构"><a href="#语言提供的堆结构-vs-手写的堆结构" class="headerlink" title="语言提供的堆结构 vs 手写的堆结构"></a>语言提供的堆结构 vs 手写的堆结构</h2><p>取决于，你有没有动态改信息的需求！</p>
<p>语言提供的堆结构，如果你动态改数据，不保证依然有序</p>
<p>手写堆结构，因为增加了对象的位置表，所以能够满足动态改信息的需求</p>
<blockquote>
<p>例子</p>
</blockquote>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> classNo;
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> age;
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> id;

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(<span class="hljs-keyword">int</span> c, <span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> i)</span> </span>&#123;
      classNo = c;
      age = a;
      id = i;
   &#125;
&#125;</code></pre>

<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StudentComparator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparator</span>&lt;<span class="hljs-title">Student</span>&gt; </span>&#123;
   <span class="hljs-meta">@Override</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Student o1, Student o2)</span> </span>&#123;
      <span class="hljs-keyword">return</span> o1.age - o2.age;
   &#125;
&#125;</code></pre>

<pre><code class="hljs java">PriorityQueue&lt;Student&gt; heap = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;(<span class="hljs-keyword">new</span> StudentComparator());
heap.add(s1);
heap.add(s2);
heap.add(s3);
heap.add(s4);
heap.add(s5);
heap.add(s6);
<span class="hljs-keyword">while</span> (!heap.isEmpty()) &#123;
   Student cur = heap.poll();
   System.out.println(cur.classNo + <span class="hljs-string">&quot;,&quot;</span> + cur.age + <span class="hljs-string">&quot;,&quot;</span> + cur.id);
&#125;

System.out.println(<span class="hljs-string">&quot;===============&quot;</span>);</code></pre>

<pre><code class="hljs asciidoc">
6,10,33333
1,14,66666
3,20,44444
2,50,11111
1,60,22222
7,72,55555
===============</code></pre>

<pre><code class="hljs java">s1 = <span class="hljs-keyword">new</span> Student(<span class="hljs-number">2</span>, <span class="hljs-number">50</span>, <span class="hljs-number">11111</span>);
s2 = <span class="hljs-keyword">new</span> Student(<span class="hljs-number">1</span>, <span class="hljs-number">60</span>, <span class="hljs-number">22222</span>);
s3 = <span class="hljs-keyword">new</span> Student(<span class="hljs-number">6</span>, <span class="hljs-number">10</span>, <span class="hljs-number">33333</span>);
s4 = <span class="hljs-keyword">new</span> Student(<span class="hljs-number">3</span>, <span class="hljs-number">20</span>, <span class="hljs-number">44444</span>);
s5 = <span class="hljs-keyword">new</span> Student(<span class="hljs-number">7</span>, <span class="hljs-number">72</span>, <span class="hljs-number">55555</span>);
s6 = <span class="hljs-keyword">new</span> Student(<span class="hljs-number">1</span>, <span class="hljs-number">14</span>, <span class="hljs-number">66666</span>);

heap = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;(<span class="hljs-keyword">new</span> StudentComparator());

heap.add(s1);
heap.add(s2);
heap.add(s3);
heap.add(s4);
heap.add(s5);
heap.add(s6);
<span class="hljs-comment">// 加进去后 动态改已经加入堆里面的东西</span>
s2.age = <span class="hljs-number">6</span>;
s4.age = <span class="hljs-number">12</span>;
s5.age = <span class="hljs-number">10</span>;
s6.age = <span class="hljs-number">84</span>;

<span class="hljs-keyword">while</span> (!heap.isEmpty()) &#123;
    Student cur = heap.poll();
    System.out.println(cur.classNo + <span class="hljs-string">&quot;,&quot;</span> + cur.age + <span class="hljs-string">&quot;,&quot;</span> + cur.id);
&#125;</code></pre>

<pre><code class="hljs asciidoc">6,10,33333
3,12,44444
1,6,22222
7,10,55555
2,50,11111
1,84,66666
===============</code></pre>

<blockquote>
<p>自己设计某一个值会发生变化的堆</p>
</blockquote>
<pre><code class="hljs java"><span class="hljs-comment">// 堆</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyHeap</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;
    <span class="hljs-comment">// 没有 T[], 动态数组实现</span>
    <span class="hljs-keyword">private</span> ArrayList&lt;T&gt; heap;
    <span class="hljs-comment">// 记录在堆上的位置</span>
    <span class="hljs-keyword">private</span> HashMap&lt;T, Integer&gt; indexMap;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> heapSize;
    <span class="hljs-keyword">private</span> Comparator&lt;? <span class="hljs-keyword">super</span> T&gt; comparator;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyHeap</span><span class="hljs-params">(Comparator&lt;? <span class="hljs-keyword">super</span> T&gt; com)</span> </span>&#123;
        heap = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
        indexMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
        heapSize = <span class="hljs-number">0</span>;
        comparator = com;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> heapSize == <span class="hljs-number">0</span>;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> heapSize;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">contains</span><span class="hljs-params">(T key)</span> </span>&#123;
        <span class="hljs-keyword">return</span> indexMap.containsKey(key);
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(T value)</span> </span>&#123;
        heap.add(value);
        indexMap.put(value, heapSize);
        heapInsert(heapSize++);
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;
        T ans = heap.get(<span class="hljs-number">0</span>);
        <span class="hljs-keyword">int</span> end = heapSize - <span class="hljs-number">1</span>;
        swap(<span class="hljs-number">0</span>, end);
        heap.remove(end);
        indexMap.remove(ans);
        heapify(<span class="hljs-number">0</span>, --heapSize);
        <span class="hljs-keyword">return</span> ans;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">resign</span><span class="hljs-params">(T value)</span> </span>&#123;
        <span class="hljs-keyword">int</span> valueIndex = indexMap.get(value);
        <span class="hljs-comment">// 只会中一个逻辑</span>
        heapInsert(valueIndex);
        heapify(valueIndex, heapSize);
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">heapInsert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;
        <span class="hljs-keyword">while</span> (comparator.compare(heap.get(index), heap.get((index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>)) &lt; <span class="hljs-number">0</span>) &#123;
            swap(index, (index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>);
            index = (index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;
        &#125;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">heapify</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> heapSize)</span> </span>&#123;
        <span class="hljs-keyword">int</span> left = index * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;
        <span class="hljs-keyword">while</span> (left &lt; heapSize) &#123;
            <span class="hljs-keyword">int</span> largest = left + <span class="hljs-number">1</span> &lt; heapSize &amp;&amp; (comparator.compare(heap.get(left + <span class="hljs-number">1</span>), heap.get(left)) &lt; <span class="hljs-number">0</span>)
                    ? left + <span class="hljs-number">1</span>
                    : left;
            largest = comparator.compare(heap.get(largest), heap.get(index)) &lt; <span class="hljs-number">0</span> ? largest : index;
            <span class="hljs-keyword">if</span> (largest == index) &#123;
                <span class="hljs-keyword">break</span>;
            &#125;
            swap(largest, index);
            index = largest;
            left = index * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;
        &#125;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;
        T o1 = heap.get(i);
        T o2 = heap.get(j);
        heap.set(i, o2);
        heap.set(j, o1);
        indexMap.put(o1, j);
        indexMap.put(o2, i);
    &#125;

&#125;</code></pre>



<h1 id="trie、桶排序、排序总结"><a href="#trie、桶排序、排序总结" class="headerlink" title="trie、桶排序、排序总结"></a>trie、桶排序、排序总结</h1><h2 id="前缀树"><a href="#前缀树" class="headerlink" title="前缀树"></a>前缀树</h2><p>1）单个字符串中，字符从前到后的加到一棵多叉树上<br>2）字符放在路上，节点上有专属的数据项（常见的是pass和end值）<br>3）所有样本都这样添加，如果没有路就新建，如有路就复用<br>4）沿途节点的pass值增加1，每个字符串结束时来到的节点end值增加1</p>
<p>可以完成前缀相关的查询</p>
<blockquote>
<p>例子</p>
</blockquote>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201207154038.png" srcset="/img/loading.gif" alt="test1"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201207154211.png" srcset="/img/loading.gif" alt="test2"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201207154255.png" srcset="/img/loading.gif" alt="test3"></p>
<p>所有字符串字符数量为 <strong>N</strong>, </p>
<p>新建树代价为 <strong>O(N)</strong>, </p>
<p>可以找”ab”插入多少次(找ab顺下去b的e值)  <strong>O(N)</strong>, </p>
<p>或者以”a”为前缀的有多少个字符串(找a的p值)  <strong>O(N)</strong></p>
<blockquote>
<p>代码(方式一) <strong>固定数组实现</strong></p>
</blockquote>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node1</span> </span>&#123;
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> pass;
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> end;
   <span class="hljs-keyword">public</span> Node1[] nexts;

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node1</span><span class="hljs-params">()</span> </span>&#123;
      pass = <span class="hljs-number">0</span>;
      end = <span class="hljs-number">0</span>;
      <span class="hljs-comment">// 如何标记存在与否</span>
      <span class="hljs-comment">// nexts[0] -&gt; a</span>
      <span class="hljs-comment">// nexts[1] -&gt; b</span>
      <span class="hljs-comment">// ..     -&gt; ..</span>
      <span class="hljs-comment">// nexts[25]-&gt; z</span>
      <span class="hljs-comment">// nexts[i]== null, i方向的路不存在</span>
      <span class="hljs-comment">// nexts[i]!= null, i方向的路存在</span>
      nexts = <span class="hljs-keyword">new</span> Node1[<span class="hljs-number">26</span>];<span class="hljs-comment">// a — z</span>
   &#125;
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Trie1</span> </span>&#123;
   <span class="hljs-keyword">private</span> Node1 root;

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Trie1</span><span class="hljs-params">()</span> </span>&#123;
      root = <span class="hljs-keyword">new</span> Node1();
   &#125;

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(String word)</span> </span>&#123;
      <span class="hljs-keyword">if</span> (word == <span class="hljs-keyword">null</span>) &#123;
         <span class="hljs-keyword">return</span>;
      &#125;
      <span class="hljs-keyword">char</span>[] chs = word.toCharArray();
      Node1 node = root;
      node.pass++;
      <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;<span class="hljs-comment">// 路</span>
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; chs.length; i++) &#123; <span class="hljs-comment">// 从左往右遍历字符</span>
         index = chs[i] - <span class="hljs-string">&#x27;a&#x27;</span>; <span class="hljs-comment">// 由字符，对应成走向哪条路</span>
         <span class="hljs-keyword">if</span> (node.nexts[index] == <span class="hljs-keyword">null</span>) &#123;
            node.nexts[index] = <span class="hljs-keyword">new</span> Node1();
         &#125;
         node = node.nexts[index];
         node.pass++;
      &#125;
      node.end++;
   &#125;
   <span class="hljs-comment">// 沿途p--, 最后e--</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delete</span><span class="hljs-params">(String word)</span> </span>&#123;
      <span class="hljs-keyword">if</span> (search(word) != <span class="hljs-number">0</span>) &#123;
         <span class="hljs-keyword">char</span>[] chs = word.toCharArray();
         Node1 node = root;
         node.pass--;
         <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;
         <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; chs.length; i++) &#123;
            index = chs[i] - <span class="hljs-string">&#x27;a&#x27;</span>;
            <span class="hljs-comment">// 只要有p变成0，以后肯定都不会经过了</span>
            <span class="hljs-keyword">if</span> (--node.nexts[index].pass == <span class="hljs-number">0</span>) &#123;
               node.nexts[index] = <span class="hljs-keyword">null</span>;
               <span class="hljs-comment">// 直接让jvm释放</span>
               <span class="hljs-comment">// c++需要遍历后续手动释放</span>
               <span class="hljs-keyword">return</span>;
            &#125;
            node = node.nexts[index];
         &#125;
         node.end--;
      &#125;
   &#125;

   <span class="hljs-comment">// word这个单词之前加入过几次</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(String word)</span> </span>&#123;
      <span class="hljs-keyword">if</span> (word == <span class="hljs-keyword">null</span>) &#123;
         <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
      &#125;
      <span class="hljs-keyword">char</span>[] chs = word.toCharArray();
      Node1 node = root;
      <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; chs.length; i++) &#123;
         index = chs[i] - <span class="hljs-string">&#x27;a&#x27;</span>;
         <span class="hljs-keyword">if</span> (node.nexts[index] == <span class="hljs-keyword">null</span>) &#123;
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
         &#125;
         node = node.nexts[index];
      &#125;
      <span class="hljs-keyword">return</span> node.end;
   &#125;

   <span class="hljs-comment">// 所有加入的字符串中，有几个是以pre这个字符串作为前缀的</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">prefixNumber</span><span class="hljs-params">(String pre)</span> </span>&#123;
      <span class="hljs-keyword">if</span> (pre == <span class="hljs-keyword">null</span>) &#123;
         <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
      &#125;
      <span class="hljs-keyword">char</span>[] chs = pre.toCharArray();
      Node1 node = root;
      <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; chs.length; i++) &#123;
         index = chs[i] - <span class="hljs-string">&#x27;a&#x27;</span>;
         <span class="hljs-keyword">if</span> (node.nexts[index] == <span class="hljs-keyword">null</span>) &#123;
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
         &#125;
         node = node.nexts[index];
      &#125;
      <span class="hljs-keyword">return</span> node.pass;
   &#125;
&#125;</code></pre>



<blockquote>
<p>代码(方式二)  <strong>哈希表实现</strong>:字符种类变多!</p>
</blockquote>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node2</span> </span>&#123;
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> pass;
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> end;
   <span class="hljs-comment">// ASCII码值, 下一个结点</span>
   <span class="hljs-keyword">public</span> HashMap&lt;Integer, Node2&gt; nexts;

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node2</span><span class="hljs-params">()</span> </span>&#123;
      pass = <span class="hljs-number">0</span>;
      end = <span class="hljs-number">0</span>;
      nexts = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
   &#125;
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Trie2</span> </span>&#123;
   <span class="hljs-keyword">private</span> Node2 root;

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Trie2</span><span class="hljs-params">()</span> </span>&#123;
      root = <span class="hljs-keyword">new</span> Node2();
   &#125;

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(String word)</span> </span>&#123;
      <span class="hljs-keyword">if</span> (word == <span class="hljs-keyword">null</span>) &#123;
         <span class="hljs-keyword">return</span>;
      &#125;
      <span class="hljs-keyword">char</span>[] chs = word.toCharArray();
      Node2 node = root;
      node.pass++;
      <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; chs.length; i++) &#123;
         index = (<span class="hljs-keyword">int</span>) chs[i];
         <span class="hljs-keyword">if</span> (!node.nexts.containsKey(index)) &#123;
            node.nexts.put(index, <span class="hljs-keyword">new</span> Node2());
         &#125;
         node = node.nexts.get(index);
         node.pass++;
      &#125;
      node.end++;
   &#125;

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delete</span><span class="hljs-params">(String word)</span> </span>&#123;
      <span class="hljs-keyword">if</span> (search(word) != <span class="hljs-number">0</span>) &#123;
         <span class="hljs-keyword">char</span>[] chs = word.toCharArray();
         Node2 node = root;
         node.pass--;
         <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;
         <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; chs.length; i++) &#123;
            index = (<span class="hljs-keyword">int</span>) chs[i];
            <span class="hljs-keyword">if</span> (--node.nexts.get(index).pass == <span class="hljs-number">0</span>) &#123;
               node.nexts.remove(index);
               <span class="hljs-keyword">return</span>;
            &#125;
            node = node.nexts.get(index);
         &#125;
         node.end--;
      &#125;
   &#125;

   <span class="hljs-comment">// word这个单词之前加入过几次</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(String word)</span> </span>&#123;
      <span class="hljs-keyword">if</span> (word == <span class="hljs-keyword">null</span>) &#123;
         <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
      &#125;
      <span class="hljs-keyword">char</span>[] chs = word.toCharArray();
      Node2 node = root;
      <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; chs.length; i++) &#123;
         index = (<span class="hljs-keyword">int</span>) chs[i];
         <span class="hljs-keyword">if</span> (!node.nexts.containsKey(index)) &#123;
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
         &#125;
         node = node.nexts.get(index);
      &#125;
      <span class="hljs-keyword">return</span> node.end;
   &#125;

   <span class="hljs-comment">// 所有加入的字符串中，有几个是以pre这个字符串作为前缀的</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">prefixNumber</span><span class="hljs-params">(String pre)</span> </span>&#123;
      <span class="hljs-keyword">if</span> (pre == <span class="hljs-keyword">null</span>) &#123;
         <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
      &#125;
      <span class="hljs-keyword">char</span>[] chs = pre.toCharArray();
      Node2 node = root;
      <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; chs.length; i++) &#123;
         index = (<span class="hljs-keyword">int</span>) chs[i];
         <span class="hljs-keyword">if</span> (!node.nexts.containsKey(index)) &#123;
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
         &#125;
         node = node.nexts.get(index);
      &#125;
      <span class="hljs-keyword">return</span> node.pass;
   &#125;
&#125;</code></pre>



<h2 id="不基于比较的排序"><a href="#不基于比较的排序" class="headerlink" title="不基于比较的排序"></a>不基于比较的排序</h2><p>桶排序思想下的排序：**计数排序 &amp; 基数排序 **</p>
<p>1)桶排序思想下的排序都是 <strong>不基于比较的排序</strong></p>
<ol start="2">
<li><strong>时间复杂度为O(N)，额外空间负载度O(M)</strong>:无法确定</li>
</ol>
<p>3)应用范围有限， <strong>需要样本的数据状况</strong> 满足桶的划分,  <strong>强相关</strong></p>
<blockquote>
<p>区别</p>
</blockquote>
<p>1）一般来讲，计数排序要求，样本是 <strong>整数</strong>，且 <strong>范围比较窄</strong></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201207164502.png" srcset="/img/loading.gif" alt="计数排序"></p>
<p>例子:[]里数据为年龄, 年龄不会超过200, 准备一个[0-200]的桶, 记录arr的数, 有就加一, 再遍历桶</p>
<p>2）一般来讲，基数排序要求，样本是 <strong>10进制的正整数</strong></p>
<p>例子:</p>
<p>[100,17,29,13,5,27]</p>
<p>找到最大值100, 补齐位数变成[100,017,029,013,005,027]</p>
<p>准备一个桶 0,1,2,3,4,5,6,7,8,9, 每一个桶 <strong>队列</strong>, 先进先出</p>
<p>[100,017,029,013,005,027]根据个位数入桶, 再倒出来, 由于队列, 先进先出</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201207165238.png" srcset="/img/loading.gif" alt="第一次排序后"></p>
<p>再根据十位数字入桶, 再倒出来, 由于队列, 先进先出</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201207165457.png" srcset="/img/loading.gif" alt="第二次后"></p>
<p>再根据百位数字入桶, 再倒出来, 由于队列, 先进先出</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201207165615.png" srcset="/img/loading.gif" alt="第三次排序后"></p>
<p> <strong>一旦要求稍有升级，改写代价增加是显而易见的！</strong></p>
<h3 id="计数排序代码"><a href="#计数排序代码" class="headerlink" title="计数排序代码"></a>计数排序代码</h3><pre><code class="hljs JAVA"><span class="hljs-comment">// only for 0~200 value</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">countSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length &lt; <span class="hljs-number">2</span>) &#123;
      <span class="hljs-keyword">return</span>;
   &#125;
   <span class="hljs-keyword">int</span> max = Integer.MIN_VALUE;
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;
      max = Math.max(max, arr[i]);
   &#125;
   <span class="hljs-keyword">int</span>[] bucket = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[max + <span class="hljs-number">1</span>];
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;
      bucket[arr[i]]++;
   &#125;
   <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; bucket.length; j++) &#123;
      <span class="hljs-keyword">while</span> (bucket[j]-- &gt; <span class="hljs-number">0</span>) &#123;
         arr[i++] = j;
      &#125;
   &#125;
&#125;</code></pre>

<h3 id="基数排序代码-O-N-log10为底max"><a href="#基数排序代码-O-N-log10为底max" class="headerlink" title="基数排序代码 O(N*log10为底max)"></a>基数排序代码 O(N*log10为底max)</h3><pre><code class="hljs Java"><span class="hljs-comment">// only for no-negative value</span>
<span class="hljs-comment">// 非负</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">radixSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length &lt; <span class="hljs-number">2</span>) &#123;
      <span class="hljs-keyword">return</span>;
   &#125;
   radixSort(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>, maxbits(arr));
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxbits</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;
   <span class="hljs-keyword">int</span> max = Integer.MIN_VALUE;
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;
      max = Math.max(max, arr[i]);
   &#125;
   <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;
   <span class="hljs-keyword">while</span> (max != <span class="hljs-number">0</span>) &#123;
      res++;
      max /= <span class="hljs-number">10</span>;
   &#125;
   <span class="hljs-keyword">return</span> res;
&#125;

<span class="hljs-comment">// arr[l..r]排序  ,  digit(最大值位数)</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">radixSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R, <span class="hljs-keyword">int</span> digit)</span> </span>&#123;
   <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> radix = <span class="hljs-number">10</span>; <span class="hljs-comment">// 以十为基底</span>
   <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;
   <span class="hljs-comment">// 有多少个数准备多少个辅助空间</span>
   <span class="hljs-keyword">int</span>[] help = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[R - L + <span class="hljs-number">1</span>];
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> d = <span class="hljs-number">1</span>; d &lt;= digit; d++) &#123; <span class="hljs-comment">// 有多少位就进出几次</span>
      <span class="hljs-comment">// 10个空间</span>
       <span class="hljs-comment">// count[0] 当前位(d位)是0的数字有多少个</span>
      <span class="hljs-comment">// count[1] 当前位(d位)是(0和1)的数字有多少个</span>
      <span class="hljs-comment">// count[2] 当前位(d位)是(0、1和2)的数字有多少个</span>
      <span class="hljs-comment">// count[i] 当前位(d位)是(0~i)的数字有多少个</span>
      <span class="hljs-keyword">int</span>[] count = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[radix]; <span class="hljs-comment">// count[0..9]</span>
      <span class="hljs-keyword">for</span> (i = L; i &lt;= R; i++) &#123;
         <span class="hljs-comment">// 取出Digit位数上的数 </span>
         <span class="hljs-comment">// 103 1 3</span>
         <span class="hljs-comment">// 202 1 2</span>
         j = getDigit(arr[i], d);
         count[j]++;
      &#125;
      <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; radix; i++) &#123;
         <span class="hljs-comment">// count自己变成count&#x27;</span>
         count[i] = count[i] + count[i - <span class="hljs-number">1</span>];
      &#125;
      <span class="hljs-keyword">for</span> (i = R; i &gt;= L; i--) &#123;
         j = getDigit(arr[i], d);
         help[count[j] - <span class="hljs-number">1</span>] = arr[i];
         count[j]--;
      &#125;
      <span class="hljs-keyword">for</span> (i = L, j = <span class="hljs-number">0</span>; i &lt;= R; i++, j++) &#123;
         arr[i] = help[j];
      &#125;
   &#125;
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getDigit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> d)</span> </span>&#123;
   <span class="hljs-keyword">return</span> ((x / ((<span class="hljs-keyword">int</span>) Math.pow(<span class="hljs-number">10</span>, d - <span class="hljs-number">1</span>))) % <span class="hljs-number">10</span>);
&#125;</code></pre>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201207172931.png" srcset="/img/loading.gif" alt="基数排序解析"></p>
<p>准备count数组为10长度，下标0 - 9</p>
<p>先对比个位数大小，分别放入对应count数组，count转化为count’词频数组，代表小于等于索引i的数有多少个</p>
<p>再从 <strong>右往左遍历</strong>数组（正常来说从左往右时302应该在队列末尾最后出队），开辟最大个数（小于等于9的数字有五个）的help数组，从右往左遍历时候302个位下标为2，小于等于2的有四个，所以可能放在第0 - 第3个数字，但因为从右往左遍历，302应该在2号桶最后倒出来， 所以302放help[3]，count’的词频减1，41应该在1号桶最后倒出来，个位数小于等于1有两个，所以放help[1]，202放剩下的2最后，小于等于2变成三个，所以help[2]….</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201207173538.png" srcset="/img/loading.gif" alt="只用数组模拟入桶出桶行为"></p>
<h1 id="排序算法的稳定性及总结"><a href="#排序算法的稳定性及总结" class="headerlink" title="排序算法的稳定性及总结"></a>排序算法的稳定性及总结</h1><h2 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h2><p>稳定性是指同样大小的样本再 <strong>排序之后不会改变相对次序</strong></p>
<ul>
<li>第一个1还在第一个, 第二个2还在第二个</li>
</ul>
<p>对 <strong>基础类型</strong> 来说，稳定性毫无意义</p>
<ul>
<li>不用区分是第几个1</li>
</ul>
<p>对 <strong>非基础类型</strong> (引用)来说，稳定性有重要意义</p>
<ul>
<li>班级号、年龄的学生类，第一回按照所有学生年龄从小到大排序，基于此再按照班级号从小到大排序</li>
<li>如果 <strong>具有稳定性</strong> : [一班年纪小, 一班年纪大, 二班年纪小, 三班年纪大…]</li>
<li>即可选择 价格最低和好评最高 -&gt; 物美价廉</li>
</ul>
<p>有些排序算法可以实现成稳定的，而有些排序算法无论如何都实现不成稳定的</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​             时间复杂度 额外空间复杂度   稳定性<br>选择排序    O(N^2)          O(1)            无<br>冒泡排序    O(N^2)          O(1)            有<br>插入排序    O(N^2)          O(1)            有<br>归并排序    O(NlogN)         O(N)           有<br>随机快排    O(NlogN)         O(logN)        无<br>堆排序      O(NlogN)        O(1)           无<br>= = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =<br>计数排序    O(N)      O(M)    有<br>基数排序    O(N)      O(N)    有</p>
<ul>
<li><p><strong>选择排序</strong> 问题</p>
<p>[5,5,5,5,1,5,5,5,5] 直接第一个5位置放到1位置交换，5位置被破坏</p>
</li>
<li><p><strong>冒泡排序</strong> </p>
<p>相等时候不交换，稳定性就不会被破坏</p>
</li>
<li><p><strong>插入排序</strong> </p>
<p>面对相等时，不替换，稳定性也不会被破坏</p>
</li>
<li><p><strong>归并排序</strong></p>
<p>面对相等时，先拷贝左边的，稳定性也不会被破坏</p>
<p>但如果解决逆序对等问题先拷贝右边则会出现问题</p>
</li>
<li><p><strong>随机快排</strong></p>
<p>Partition过程无法做稳定</p>
<p>小于等于区下一个数交换，交换的会是等于区的数字，数字的位置就会被破坏</p>
</li>
<li><p><strong>堆排序</strong></p>
<p>变成大根堆的时候, 3，3，3，3遇到4后有很多个3的位置会改变</p>
</li>
</ul>
<blockquote>
<p>总结</p>
</blockquote>
<pre><code class="hljs mathematica"><span class="hljs-number">1</span>）不基于比较的排序，对样本数据有严格要求，不易改写
<span class="hljs-number">2</span>）基于比较的排序，只要规定好两个样本怎么比大小就可以直接复用
<span class="hljs-number">3</span>）基于比较的排序，时间复杂度的极限是<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-operator">*</span><span class="hljs-variable">logN</span><span class="hljs-punctuation">)</span>
<span class="hljs-number">4</span>）时间复杂度<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-operator">*</span><span class="hljs-variable">logN</span><span class="hljs-punctuation">)</span>、额外空间复杂度低于<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-punctuation">)</span>、且稳定的基于比较的排序是不存在的。
<span class="hljs-number">5</span>）为了绝对的速度选快排（常数时间最少）、为了省空间选堆排、为了稳定性选归并</code></pre>



<h2 id="常见的坑"><a href="#常见的坑" class="headerlink" title="常见的坑"></a>常见的坑</h2><ul>
<li>归并排序的额外空间复杂度可以变成O(1)，“ <strong>归并排序 内部缓存法</strong> ”，但是将变得 <strong>不再稳定</strong>。</li>
<li>“ <strong>原地归并排序</strong> “ 是垃圾贴，会让时间复杂度变成O(N^2) </li>
<li>快速排序稳定性改进，“01 stable sort”，但是会对 <strong>样本数据要求更多</strong>。</li>
</ul>
<ul>
<li><p>在整型数组中，请把奇数放在数组左边，偶数放在数组右边，要求所有奇数之间原始的相对次序不变，所有偶数之间原始相对次序不变。</p>
<p>要求：时间复杂度做到O(N)，额外空间复杂度做到O(1)</p>
<p>**这是一个 0,1标准的Partition **(原始小于等于和大于分界，此问题奇数偶数分界), 而Partition过程无法做到稳定性</p>
</li>
</ul>
<p>系统函数：先反射，判定是引用传递还是值传递，引用归并，值传递快排</p>
<h1 id="链表问题"><a href="#链表问题" class="headerlink" title="链表问题"></a>链表问题</h1><blockquote>
<p> 面试时链表解题的 <strong>方法论</strong></p>
</blockquote>
<p>1)对于笔试，不用太在乎空间复杂度，一切为了时间复杂度</p>
<p>2)对于面试，时间复杂度依然放在第一位，但是一定要找到空间最省的方法</p>
<h2 id="链表面试题常用数据结构和技巧"><a href="#链表面试题常用数据结构和技巧" class="headerlink" title="链表面试题常用数据结构和技巧"></a>链表面试题常用数据结构和技巧</h2><p>1）使用容器(哈希表、数组等)</p>
<p>2）快慢指针 </p>
<h2 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h2><p>1）输入链表头节点，奇数长度返回中点，偶数长度返回上中点</p>
<p>1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt;5 找到3, 1 -&gt; 2 -&gt; 3 -&gt; 4  找到2</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">midOrUpMidNode</span><span class="hljs-params">(Node head)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span> || head.next == <span class="hljs-keyword">null</span> || head.next.next == <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">return</span> head;
   &#125;
   <span class="hljs-comment">// 链表 &gt;= 三个结点</span>
   Node slow = head.next;
   Node fast = head.next.next;
   <span class="hljs-keyword">while</span> (fast.next != <span class="hljs-keyword">null</span> &amp;&amp; fast.next.next != <span class="hljs-keyword">null</span>) &#123;
      slow = slow.next;
      fast = fast.next.next;
   &#125;
   <span class="hljs-keyword">return</span> slow;
&#125;</code></pre>

<p>2）输入链表头节点，奇数长度返回中点，偶数长度返回下中点</p>
<p>1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt;5 找到3,  1 -&gt; 2 -&gt; 3 -&gt; 4  找到3</p>
<p>3）输入链表头节点，奇数长度返回中点前一个，偶数长度返回上中点前一个</p>
<p>4）输入链表头节点，奇数长度返回中点前一个，偶数长度返回下中点前一个</p>
<h2 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h2><h3 id="给定一个单链表的头节点head，请判断该链表是否为回文结构。"><a href="#给定一个单链表的头节点head，请判断该链表是否为回文结构。" class="headerlink" title="给定一个单链表的头节点head，请判断该链表是否为回文结构。"></a>给定一个单链表的头节点head，请判断该链表是否为回文结构。</h3><p>1）栈方法特别简单（笔试用）</p>
<ul>
<li><p><strong>栈实现</strong></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201208150841.png" srcset="/img/loading.gif" alt="栈"></p>
<p>把链表value全放栈中，再弹出一个一个对比。</p>
<p>Code:</p>
<pre><code class="hljs java"><span class="hljs-comment">// need n extra space</span>
<span class="hljs-comment">// stack</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPalindrome1</span><span class="hljs-params">(Node head)</span> </span>&#123;
   Stack&lt;Node&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;Node&gt;();
   Node cur = head;
   <span class="hljs-keyword">while</span> (cur != <span class="hljs-keyword">null</span>) &#123;
      stack.push(cur);
      cur = cur.next;
   &#125;
   <span class="hljs-keyword">while</span> (head != <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">if</span> (head.value != stack.pop().value) &#123;
         <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
      &#125;
      head = head.next;
   &#125;
   <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
&#125;</code></pre>
</li>
<li><p><strong>栈实现2</strong></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201208151246.png" srcset="/img/loading.gif" alt="快慢指针定位"></p>
<p>快慢指针定位到中点的位置, 奇数唯一中点偶数上中点, 把右半部分加到栈中, 弹出与head一一对比</p>
<pre><code class="hljs java"><span class="hljs-comment">// need n/2 extra space</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPalindrome2</span><span class="hljs-params">(Node head)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span> || head.next == <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
   &#125;
   Node right = head.next;
   Node cur = head;
   <span class="hljs-keyword">while</span> (cur.next != <span class="hljs-keyword">null</span> &amp;&amp; cur.next.next != <span class="hljs-keyword">null</span>) &#123;
      right = right.next;
      cur = cur.next.next;
   &#125;
   Stack&lt;Node&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;Node&gt;();
   <span class="hljs-keyword">while</span> (right != <span class="hljs-keyword">null</span>) &#123;
      stack.push(right);
      right = right.next;
   &#125;
   <span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;
      <span class="hljs-keyword">if</span> (head.value != stack.pop().value) &#123;
         <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
      &#125;
      head = head.next;
   &#125;
   <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
&#125;</code></pre>



</li>
</ul>
<p>2）改原链表的方法就需要注意边界了（面试用）</p>
<p>​ <img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201208151959.png" srcset="/img/loading.gif" alt="原链表"></p>
<p>变化为-&gt;</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201208152030.png" srcset="/img/loading.gif" alt="变化后"></p>
<p>再L与R对比, 直到比到S, 最后再变回链表位置即可。</p>
<p>这样的 <strong>额外空间复杂度为 O(1);</strong></p>
<p>code:</p>
<pre><code class="hljs java"><span class="hljs-comment">// need O(1) extra space</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPalindrome3</span><span class="hljs-params">(Node head)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span> || head.next == <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
   &#125;
   Node n1 = head; <span class="hljs-comment">// slow</span>
   Node n2 = head; <span class="hljs-comment">// fast</span>
   <span class="hljs-keyword">while</span> (n2.next != <span class="hljs-keyword">null</span> &amp;&amp; n2.next.next != <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// find mid node</span>
      n1 = n1.next; <span class="hljs-comment">// n1 -&gt; mid</span>
      n2 = n2.next.next; <span class="hljs-comment">// n2 -&gt; end</span>
   &#125;
   n2 = n1.next; <span class="hljs-comment">// n2 -&gt; right part first node</span>
   n1.next = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// mid.next -&gt; null</span>
   Node n3 = <span class="hljs-keyword">null</span>;
   <span class="hljs-keyword">while</span> (n2 != <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// right part convert</span>
      n3 = n2.next; <span class="hljs-comment">// n3 -&gt; save next node</span>
      n2.next = n1; <span class="hljs-comment">// next of right node convert</span>
      n1 = n2; <span class="hljs-comment">// n1 move</span>
      n2 = n3; <span class="hljs-comment">// n2 move</span>
   &#125;
   n3 = n1; <span class="hljs-comment">// n3 -&gt; save last node</span>
   n2 = head;<span class="hljs-comment">// n2 -&gt; left first node</span>
   <span class="hljs-keyword">boolean</span> res = <span class="hljs-keyword">true</span>;
   <span class="hljs-keyword">while</span> (n1 != <span class="hljs-keyword">null</span> &amp;&amp; n2 != <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// check palindrome</span>
      <span class="hljs-keyword">if</span> (n1.value != n2.value) &#123;
         res = <span class="hljs-keyword">false</span>;
         <span class="hljs-keyword">break</span>;
      &#125;
      n1 = n1.next; <span class="hljs-comment">// left to mid</span>
      n2 = n2.next; <span class="hljs-comment">// right to mid</span>
   &#125;
   n1 = n3.next;
   n3.next = <span class="hljs-keyword">null</span>;
   <span class="hljs-keyword">while</span> (n1 != <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// recover list</span>
      n2 = n1.next;
      n1.next = n3;
      n3 = n1;
      n1 = n2;
   &#125;
   <span class="hljs-keyword">return</span> res;
&#125;</code></pre>



<h3 id="将单向链表按某值划分成左边小、中间相等、右边大的形式"><a href="#将单向链表按某值划分成左边小、中间相等、右边大的形式" class="headerlink" title="将单向链表按某值划分成左边小、中间相等、右边大的形式"></a>将单向链表按某值划分成左边小、中间相等、右边大的形式</h3><p>1）把链表放入数组里，在数组上做partition（笔试用）( <strong>不稳定</strong> )</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">listPartition1</span><span class="hljs-params">(Node head, <span class="hljs-keyword">int</span> pivot)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">return</span> head;
   &#125;
   Node cur = head;
   <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;
   <span class="hljs-keyword">while</span> (cur != <span class="hljs-keyword">null</span>) &#123;
      i++;
      cur = cur.next;
   &#125;
   Node[] nodeArr = <span class="hljs-keyword">new</span> Node[i];
   i = <span class="hljs-number">0</span>;
   cur = head;
   <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i != nodeArr.length; i++) &#123;
      nodeArr[i] = cur;
      cur = cur.next;
   &#125;
   arrPartition(nodeArr, pivot);
   <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i != nodeArr.length; i++) &#123;
      nodeArr[i - <span class="hljs-number">1</span>].next = nodeArr[i];
   &#125;
   nodeArr[i - <span class="hljs-number">1</span>].next = <span class="hljs-keyword">null</span>;
   <span class="hljs-keyword">return</span> nodeArr[<span class="hljs-number">0</span>];
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">arrPartition</span><span class="hljs-params">(Node[] nodeArr, <span class="hljs-keyword">int</span> pivot)</span> </span>&#123;
   <span class="hljs-keyword">int</span> small = -<span class="hljs-number">1</span>;
   <span class="hljs-keyword">int</span> big = nodeArr.length;
   <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;
   <span class="hljs-keyword">while</span> (index != big) &#123;
      <span class="hljs-keyword">if</span> (nodeArr[index].value &lt; pivot) &#123;
         swap(nodeArr, ++small, index++);
      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nodeArr[index].value == pivot) &#123;
         index++;
      &#125; <span class="hljs-keyword">else</span> &#123;
         swap(nodeArr, --big, index);
      &#125;
   &#125;
&#125;</code></pre>



<p>2）分成小、中、大三部分，再把各个部分之间串起来（面试用）</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201208161643.png" srcset="/img/loading.gif" alt="六个变量"></p>
<p>设置六个变量，分别为小于区头尾结点，大于区头尾结点，等于区头尾结点。</p>
<p>依次遍历，例如遍历4结点，bH、bT = 4，4结点断开。2也是，发至sH和sT=2，3发至eH和eT=3。</p>
<p>来到5时，要发到大于区，5串到4下面，bH=4，让bT指向5但5变成bT。</p>
<p>来到6时，bT指向6并让bT找到6的位置。</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201208162538.png" srcset="/img/loading.gif" alt="流程"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201208162652.png" srcset="/img/loading.gif" alt="流程2"></p>
<p>每一步O(1),整体O(N); 且是 <strong>稳定的</strong></p>
<p>code:</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">listPartition2</span><span class="hljs-params">(Node head, <span class="hljs-keyword">int</span> pivot)</span> </span>&#123;
   Node sH = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// small head</span>
   Node sT = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// small tail</span>
   Node eH = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// equal head</span>
   Node eT = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// equal tail</span>
   Node mH = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// big head</span>
   Node mT = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// big tail</span>
   Node next = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// save next node</span>
   <span class="hljs-comment">// every node distributed to three lists</span>
   <span class="hljs-keyword">while</span> (head != <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-comment">// 记录head.next 后面结点next是要销毁的</span>
      next = head.next;
      head.next = <span class="hljs-keyword">null</span>;
      <span class="hljs-keyword">if</span> (head.value &lt; pivot) &#123;
         <span class="hljs-keyword">if</span> (sH == <span class="hljs-keyword">null</span>) &#123;
            sH = head;
            sT = head;
         &#125; <span class="hljs-keyword">else</span> &#123;
            sT.next = head;
            sT = head;
         &#125;
      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (head.value == pivot) &#123;
         <span class="hljs-keyword">if</span> (eH == <span class="hljs-keyword">null</span>) &#123;
            eH = head;
            eT = head;
         &#125; <span class="hljs-keyword">else</span> &#123;
            eT.next = head;
            eT = head;
         &#125;
      &#125; <span class="hljs-keyword">else</span> &#123;
         <span class="hljs-keyword">if</span> (mH == <span class="hljs-keyword">null</span>) &#123;
            mH = head;
            mT = head;
         &#125; <span class="hljs-keyword">else</span> &#123;
            mT.next = head;
            mT = head;
         &#125;
      &#125;
      head = next;
   &#125;
   <span class="hljs-comment">// small and equal reconnect</span>
   <span class="hljs-keyword">if</span> (sT != <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// 如果有小于区域</span>
      sT.next = eH;
      eT = eT == <span class="hljs-keyword">null</span> ? sT : eT; <span class="hljs-comment">// 下一步，谁去连大于区域的头，谁就变成eT</span>
   &#125;
   <span class="hljs-comment">// 上面的if，不管跑了没有，et</span>
   <span class="hljs-comment">// all reconnect</span>
   <span class="hljs-keyword">if</span> (eT != <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// 如果小于区域和等于区域，不是都没有</span>
      eT.next = mH;
   &#125;
   <span class="hljs-keyword">return</span> sH != <span class="hljs-keyword">null</span> ? sH : (eH != <span class="hljs-keyword">null</span> ? eH : mH);
&#125;</code></pre>



<h3 id="一种特殊的单链表节点类-random"><a href="#一种特殊的单链表节点类-random" class="headerlink" title="一种特殊的单链表节点类 random"></a>一种特殊的单链表节点类 random</h3><blockquote>
<p> 一种特殊的单链表节点类描述如下</p>
</blockquote>
<pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123; 
<span class="hljs-keyword">int</span> value; 
Node next; 
Node rand; 
Node(<span class="hljs-keyword">int</span> val) &#123; value = val; &#125; 
&#125;</code></pre>

<p>rand指针是单链表节点结构中新增的指针，rand可能指向链表中的任意一个节点，也可能指向null。<br>给定一个由Node节点类型组成的无环单链表的头节点 head，请实现一个函数完成这个链表的复制，并返回复制的新链表的头节点。<br> <strong>【要求】</strong><br> **时间复杂度O(N)，额外空间复杂度O(1) **</p>
<ul>
<li><p>哈希表</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">copyListWithRand1</span><span class="hljs-params">(Node head)</span> </span>&#123;
   HashMap&lt;Node, Node&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;Node, Node&gt;();
   Node cur = head;
   <span class="hljs-keyword">while</span> (cur != <span class="hljs-keyword">null</span>) &#123;
      map.put(cur, <span class="hljs-keyword">new</span> Node(cur.value));
      cur = cur.next;
   &#125;
   cur = head;
   <span class="hljs-keyword">while</span> (cur != <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-comment">// cur 老          (key)</span>
      <span class="hljs-comment">// map.get(cur) 新 (value)</span>
      map.get(cur).next = map.get(cur.next);
      map.get(cur).rand = map.get(cur.rand);
      cur = cur.next;
   &#125;
   <span class="hljs-keyword">return</span> map.get(head);
&#125;</code></pre>



</li>
</ul>
<ul>
<li><p>不用哈希表</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201208175756.png" srcset="/img/loading.gif" alt="克隆, 放置后面"></p>
<p>一次拿出一对:</p>
<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201208175936.png" srcset="/img/loading.gif" alt="如何克隆？" style="zoom:50%;" />



</li>
</ul>
<p>  我们通过1找到1的random 3，又因为3’就在3后面，所以可以直接3.next找到并与1’连接</p>
<p>  最后分离</p>
<p>  code:</p>
  <pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">copyListWithRand2</span><span class="hljs-params">(Node head)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
   &#125;
   Node cur = head;
   Node next = <span class="hljs-keyword">null</span>;
   <span class="hljs-comment">// copy node and link to every node</span>
   <span class="hljs-comment">// 1 -&gt; 2</span>
   <span class="hljs-comment">// 1 -&gt; 1&#x27; -&gt; 2</span>
   <span class="hljs-keyword">while</span> (cur != <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-comment">// cur 老</span>
      <span class="hljs-comment">// next表示 老 的下一个</span>
      next = cur.next;
      cur.next = <span class="hljs-keyword">new</span> Node(cur.value);
      cur.next.next = next;
      cur = next;
   &#125;
   cur = head;
   Node curCopy = <span class="hljs-keyword">null</span>;
   <span class="hljs-comment">// set copy node rand</span>
   <span class="hljs-comment">// 1 -&gt; 1&#x27; -&gt; 2 -&gt; 2&#x27;</span>
   <span class="hljs-keyword">while</span> (cur != <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-comment">// cur 老</span>
      <span class="hljs-comment">// cur.next  新 copy</span>
      next = cur.next.next;
      curCopy = cur.next;
      <span class="hljs-comment">// 老的rand的下一个(插入进来的)</span>
      curCopy.rand = cur.rand != <span class="hljs-keyword">null</span> ? cur.rand.next : <span class="hljs-keyword">null</span>;
      cur = next;
   &#125;
   Node res = head.next;
   cur = head;
   <span class="hljs-comment">// split</span>
   <span class="hljs-keyword">while</span> (cur != <span class="hljs-keyword">null</span>) &#123;
      next = cur.next.next;
      curCopy = cur.next;
      cur.next = next;
      curCopy.next = next != <span class="hljs-keyword">null</span> ? next.next : <span class="hljs-keyword">null</span>;
      cur = next;
   &#125;
   <span class="hljs-keyword">return</span> res;
&#125;</code></pre>

<p>  不能边设置边断链： <strong>如果后面指向前面，前面已经和自己的 ‘ 断连了，.next已经没有用</strong></p>
<h3 id="与约瑟夫环问题相同的噩梦（相交）"><a href="#与约瑟夫环问题相同的噩梦（相交）" class="headerlink" title="与约瑟夫环问题相同的噩梦（相交）"></a>与约瑟夫环问题相同的噩梦（相交）</h3><p>给定两个可能有环也可能无环的单链表，头节点head1和head2。请实现一个函数，如果两个链表相交，请返回相交的 第一个节点。如果不相交，返回null </p>
<p>相交就是地址共用相同部分！</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201208182234.png" srcset="/img/loading.gif" alt="相交"></p>
<p>【要求】<br> <strong>如果两个链表长度之和为N，时间复杂度请达到O(N)，额外空间复杂度 请达到O(1)。</strong></p>
<blockquote>
<p>先设计 Node f(head) 返回 <strong>入环第一个结点</strong></p>
</blockquote>
<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201208182419.png" srcset="/img/loading.gif" alt="入环结点" style="zoom:50%;" />

<p>如果整个是环，就是head</p>
<p> <strong>一个链表只有一个next指针，进了环，是不能出来的。</strong></p>
<p>可以用set<Node> 先查有没有在set里，查到第一个在的就是入环结点，没有环一定走到空上。</p>
<ul>
<li><p>不用set:</p>
<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201208183357.png" srcset="/img/loading.gif" alt="流程" style="zoom:50%;" />

<p>一开始slow和fast指针从head开始出发，slow走一步，fast走两步；</p>
<p>一直这样走下去，slow和fast一定会在同一个地方，当到达同一个地方时： <strong>证明一定有环</strong></p>
<p>slow不变位置，fast回到开头，fast变成一次走一步，slow也继续一次走一步，</p>
<p>当slow和fast再次相交时，这个点就是 <strong>第一个入环点</strong>。</p>
<p>code：</p>
<pre><code class="hljs java"><span class="hljs-comment">// 找到链表第一个入环节点，如果无环，返回null</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">getLoopNode</span><span class="hljs-params">(Node head)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span> || head.next == <span class="hljs-keyword">null</span> || head.next.next == <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
   &#125;
   <span class="hljs-comment">// n1 慢  n2 快</span>
   Node n1 = head.next; <span class="hljs-comment">// n1 -&gt; slow</span>
   Node n2 = head.next.next; <span class="hljs-comment">// n2 -&gt; fast</span>
   <span class="hljs-keyword">while</span> (n1 != n2) &#123;
      <span class="hljs-keyword">if</span> (n2.next == <span class="hljs-keyword">null</span> || n2.next.next == <span class="hljs-keyword">null</span>) &#123;
         <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
      &#125;
      n2 = n2.next.next;
      n1 = n1.next;
   &#125;
   n2 = head; <span class="hljs-comment">// n2 -&gt; walk again from head</span>
   <span class="hljs-keyword">while</span> (n1 != n2) &#123;
      n1 = n1.next;
      n2 = n2.next;
   &#125;
   <span class="hljs-keyword">return</span> n1;
&#125;</code></pre>



</li>
</ul>
<blockquote>
<p>问题解决</p>
</blockquote>
<ol>
<li>如果 <strong>两个无环链表相交</strong>，相交后为全部相交部分。</li>
</ol>
<ul>
<li><p>用set</p>
<p>把一个链表全部注册进去，对第二个链表逐步遍历直到找到第一个相交。</p>
</li>
<li><p>不用set</p>
<p>假设第一个链表100个，第二个链表80个，两个都找到其最后一个结点（即下一个结点为null的结点），分别为end1和end2。</p>
<ul>
<li>判断 end1 是否等于 end2 ，如果不等于， 不相交。</li>
<li>如果 end1 等于 end2， 链表1走（100-80）= 20步，从这里开始链表二也开始走，两个链表肯定会走到第一个相遇的地方。</li>
</ul>
<p>Code:</p>
<pre><code class="hljs java"><span class="hljs-comment">// 如果两个链表都无环，返回第一个相交节点，如果不想交，返回null</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">noLoop</span><span class="hljs-params">(Node head1, Node head2)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (head1 == <span class="hljs-keyword">null</span> || head2 == <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
   &#125;
   Node cur1 = head1;
   Node cur2 = head2;
   <span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>;
   <span class="hljs-keyword">while</span> (cur1.next != <span class="hljs-keyword">null</span>) &#123;
      n++;
      cur1 = cur1.next;
   &#125;
   <span class="hljs-keyword">while</span> (cur2.next != <span class="hljs-keyword">null</span>) &#123;
      n--;
      cur2 = cur2.next;
   &#125;
   <span class="hljs-comment">// n = cur1.len - cur2.len</span>
   <span class="hljs-keyword">if</span> (cur1 != cur2) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
   &#125;
   <span class="hljs-comment">// n  :  链表1长度减去链表2长度的值</span>
   cur1 = n &gt; <span class="hljs-number">0</span> ? head1 : head2; <span class="hljs-comment">// 谁长，谁的头变成cur1</span>
   cur2 = cur1 == head1 ? head2 : head1; <span class="hljs-comment">// 谁短，谁的头变成cur2</span>
   n = Math.abs(n);
   <span class="hljs-comment">// 长链表先走</span>
   <span class="hljs-keyword">while</span> (n != <span class="hljs-number">0</span>) &#123;
      n--;
      cur1 = cur1.next;
   &#125;
   <span class="hljs-comment">// 一起走 走到相交点</span>
   <span class="hljs-keyword">while</span> (cur1 != cur2) &#123;
      cur1 = cur1.next;
      cur2 = cur2.next;
   &#125;
   <span class="hljs-keyword">return</span> cur1;
&#125;</code></pre>



</li>
</ul>
<ol start="2">
<li>如果 <strong>两个有环链表相交</strong>，一定是 <strong>共用这个环的</strong></li>
</ol>
<p>​ <img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201208190644.png" srcset="/img/loading.gif" alt="三种情况"></p>
<ul>
<li>没有相交部分<ul>
<li>让loop1往下走，如果在 <strong>遇见自己之前一直没碰到loop2</strong>。</li>
</ul>
</li>
<li>入环结点相同<ul>
<li>loop1和loop2不等于空且相同</li>
<li>不用再看环，把入环点作为尾结点，就变成了两个无环单链表相交问题</li>
</ul>
</li>
<li>入环结点不同<ul>
<li> 让loop1往下走，如果在 <strong>遇见自己之前一直碰到了loop2</strong>。</li>
</ul>
</li>
</ul>
<ol start="3">
<li>如果 <strong>一个有环一个无环</strong>， <strong>不可能相交</strong>。</li>
</ol>
<p>​ 因为是单链表。</p>
<pre><code class="hljs java"><span class="hljs-comment">// 两个有环链表，返回第一个相交节点，如果不想交返回null</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">bothLoop</span><span class="hljs-params">(Node head1, Node loop1, Node head2, Node loop2)</span> </span>&#123;
   Node cur1 = <span class="hljs-keyword">null</span>;
   Node cur2 = <span class="hljs-keyword">null</span>;
   <span class="hljs-keyword">if</span> (loop1 == loop2) &#123;
      <span class="hljs-comment">// 解决无环问题，只不过end变为loop</span>
      cur1 = head1;
      cur2 = head2;
      <span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">while</span> (cur1 != loop1) &#123;
         n++;
         cur1 = cur1.next;
      &#125;
      <span class="hljs-keyword">while</span> (cur2 != loop2) &#123;
         n--;
         cur2 = cur2.next;
      &#125;
      cur1 = n &gt; <span class="hljs-number">0</span> ? head1 : head2;
      cur2 = cur1 == head1 ? head2 : head1;
      n = Math.abs(n);
      <span class="hljs-keyword">while</span> (n != <span class="hljs-number">0</span>) &#123;
         n--;
         cur1 = cur1.next;
      &#125;
      <span class="hljs-keyword">while</span> (cur1 != cur2) &#123;
         cur1 = cur1.next;
         cur2 = cur2.next;
      &#125;
      <span class="hljs-keyword">return</span> cur1;
   &#125; <span class="hljs-keyword">else</span> &#123;
      cur1 = loop1.next;
      <span class="hljs-keyword">while</span> (cur1 != loop1) &#123;
         <span class="hljs-keyword">if</span> (cur1 == loop2) &#123;
            <span class="hljs-keyword">return</span> loop1;
         &#125;
         cur1 = cur1.next;
      &#125;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
   &#125;
&#125;</code></pre>

<p>最后总结：</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">getIntersectNode</span><span class="hljs-params">(Node head1, Node head2)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (head1 == <span class="hljs-keyword">null</span> || head2 == <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
   &#125;
   Node loop1 = getLoopNode(head1);
   Node loop2 = getLoopNode(head2);
   <span class="hljs-keyword">if</span> (loop1 == <span class="hljs-keyword">null</span> &amp;&amp; loop2 == <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">return</span> noLoop(head1, head2);
   &#125;
   <span class="hljs-keyword">if</span> (loop1 != <span class="hljs-keyword">null</span> &amp;&amp; loop2 != <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">return</span> bothLoop(head1, loop1, head2, loop2);
   &#125;
   <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
&#125;</code></pre>



<h3 id="能不能不给单链表的头节点，只给想要删除的节点，就能做到在链表上把这个点删掉？"><a href="#能不能不给单链表的头节点，只给想要删除的节点，就能做到在链表上把这个点删掉？" class="headerlink" title="能不能不给单链表的头节点，只给想要删除的节点，就能做到在链表上把这个点删掉？"></a>能不能不给单链表的头节点，只给想要删除的节点，就能做到在链表上把这个点删掉？</h3><p>把下一个值赋给当前结点，当前结点跳到下下个。</p>
<p>1）但 <strong>实际上没有删除 “自己”，只是替代了内容！</strong></p>
<p>2）如果不再是简单的结点问题，而是服务器问题， <strong>拷贝</strong>会变成一件很困难的事情！</p>
<p>3） <strong>绝对无法删除链表最后一个结点的！</strong>没有办法改前一个结点的走向。NULL是一个特定系统区域，去调析构函数是没有用的！</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201208192831.png" srcset="/img/loading.gif" alt="test代码"></p>
<blockquote>
<p>为什么不行？</p>
</blockquote>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201208192918.png" srcset="/img/loading.gif" alt="原因"></p>
<p>c = null;只是让c没有指向Node(3), 但Node(2)还是指向Node(3)了！</p>
<h1 id="二叉树的基本算法"><a href="#二叉树的基本算法" class="headerlink" title="二叉树的基本算法"></a>二叉树的基本算法</h1><blockquote>
<p>结构描述：</p>
</blockquote>
<pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;
  V value;
  Node left;
  Node right;
&#125;</code></pre>

<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> value;
   <span class="hljs-keyword">public</span> Node left;
   <span class="hljs-keyword">public</span> Node right;

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v)</span> </span>&#123;
      value = v;
   &#125;
&#125;</code></pre>



<h2 id="二叉树的先序、中序、后序遍历"><a href="#二叉树的先序、中序、后序遍历" class="headerlink" title="二叉树的先序、中序、后序遍历"></a>二叉树的先序、中序、后序遍历</h2><p>​ <img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201209164047.png" srcset="/img/loading.gif" alt="如图"></p>
<ul>
<li><p>先序：任何子树的处理顺序都是，先头节点、再左子树、然后右子树</p>
<pre><code class="hljs java"><span class="hljs-comment">// 先序打印所有结点</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pre</span><span class="hljs-params">(Node head)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">return</span>;
   &#125;
   System.out.println(head.value);
   pre(head.left);
   pre(head.right);
&#125;</code></pre>

<p>​ </p>
</li>
<li><p>中序：任何子树的处理顺序都是，先左子树、再头节点、然后右子树</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">in</span><span class="hljs-params">(Node head)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">return</span>;
   &#125;
   in(head.left);
   System.out.println(head.value);
   in(head.right);
&#125;</code></pre>



</li>
</ul>
<ul>
<li><p>后序：任何子树的处理顺序都是，先左子树、再右子树、然后头节点</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pos</span><span class="hljs-params">(Node head)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">return</span>;
   &#125;
   pos(head.left);
   pos(head.right);
   System.out.println(head.value);
&#125;</code></pre>



</li>
</ul>
<h3 id="递归的本质是-递归序"><a href="#递归的本质是-递归序" class="headerlink" title="递归的本质是  递归序"></a>递归的本质是  <strong>递归序</strong></h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201209170646.png" srcset="/img/loading.gif" alt="流程"></p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(Node head)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">return</span>;
   &#125;
   <span class="hljs-comment">// 先序</span>
   f(head.left);
   <span class="hljs-comment">// 中序</span>
   f(head.right);
   <span class="hljs-comment">// 后序</span>
&#125;</code></pre>

<p>对于这样的代码，一定会 <strong>访问(返回)</strong> 三次：</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201209170852.png" srcset="/img/loading.gif" alt="每一个结点都会到达三次"></p>
<p>先序就是每一次第一次到达了就打印：</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201209171028.png" srcset="/img/loading.gif" alt="第一次到达打印就是先序"></p>
<p>先序，中序，后序只是 <strong>递归序的结果</strong>。</p>
<p>所以在树上做动态规划的前提就是 <strong>每一个结点都会到此，走左边再回来，走右边再回来。</strong></p>
<p>让一个东西来到 <strong>此地三次！</strong></p>
<ul>
<li>理解递归序</li>
<li>先序、中序、后序都可以在递归序的基础上加工出来</li>
<li>第一次到达一个节点就打印就是先序、第二次打印即中序、第三次即后序</li>
</ul>
<h3 id="非递归方式实现二叉树的先序、中序、后序遍历"><a href="#非递归方式实现二叉树的先序、中序、后序遍历" class="headerlink" title="非递归方式实现二叉树的先序、中序、后序遍历"></a>非递归方式实现二叉树的先序、中序、后序遍历</h3><ul>
<li><p>任何递归函数都可以改成非递归</p>
</li>
<li><p>非递归实现先序遍历</p>
<pre><code class="hljs java"><span class="hljs-comment">// 先序遍历</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pre</span><span class="hljs-params">(Node head)</span> </span>&#123;
   System.out.print(<span class="hljs-string">&quot;pre-order: &quot;</span>);
   <span class="hljs-keyword">if</span> (head != <span class="hljs-keyword">null</span>) &#123;
      Stack&lt;Node&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;Node&gt;();
      stack.add(head);
      <span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;
         head = stack.pop();
         System.out.print(head.value + <span class="hljs-string">&quot; &quot;</span>);
         <span class="hljs-keyword">if</span> (head.right != <span class="hljs-keyword">null</span>) &#123;
            stack.push(head.right);
         &#125;
         <span class="hljs-keyword">if</span> (head.left != <span class="hljs-keyword">null</span>) &#123;
            stack.push(head.left);
         &#125;
      &#125;
   &#125;
   System.out.println();
&#125;</code></pre>

<ul>
<li><p>先放头结点，弹出就打印</p>
</li>
<li><p>弹出打印后，如果有右孩子，先压入右孩子</p>
</li>
<li><p>如果有左孩子，再压入右孩子</p>
</li>
<li><p>例如对上面的树，先压入1，弹出1，压入3、2，弹出2，压入5、4，弹出4，弹出5，弹出3，压入7、6，弹出6、7</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>非递归实现后序遍历</p>
<ul>
<li><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201209172717.png" srcset="/img/loading.gif" alt="流程与先序相反"></p>
</li>
<li><p> 如果上述，先压左再压入右， 头左右就会变成头右左，正好是后序的相反。</p>
</li>
</ul>
<p>Code:</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pos1</span><span class="hljs-params">(Node head)</span> </span>&#123;
   System.out.print(<span class="hljs-string">&quot;pos-order: &quot;</span>);
   <span class="hljs-keyword">if</span> (head != <span class="hljs-keyword">null</span>) &#123;
      Stack&lt;Node&gt; s1 = <span class="hljs-keyword">new</span> Stack&lt;Node&gt;();
      Stack&lt;Node&gt; s2 = <span class="hljs-keyword">new</span> Stack&lt;Node&gt;();
      s1.push(head);
      <span class="hljs-keyword">while</span> (!s1.isEmpty()) &#123;
         head = s1.pop();
         <span class="hljs-comment">// 转移到s2里面，先序这里是直接打印</span>
         s2.push(head);
         <span class="hljs-comment">// 先压左</span>
         <span class="hljs-keyword">if</span> (head.left != <span class="hljs-keyword">null</span>) &#123;
            s1.push(head.left);
         &#125;
         <span class="hljs-keyword">if</span> (head.right != <span class="hljs-keyword">null</span>) &#123;
            s1.push(head.right);
         &#125;
      &#125;
      <span class="hljs-keyword">while</span> (!s2.isEmpty()) &#123;
         System.out.print(s2.pop().value + <span class="hljs-string">&quot; &quot;</span>);
      &#125;
   &#125;
   System.out.println();
&#125;</code></pre>
</li>
<li><p>非递归实现后序遍历（方法二）</p>
<ul>
<li><p>死亡代码</p>
</li>
<li><p>左边到最底下，弹出一个往上管右边，右边再找左边最底下，直到把左边处理完再处理右边再处理自己。</p>
</li>
</ul>
</li>
</ul>
  <pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pos2</span><span class="hljs-params">(Node h)</span> </span>&#123;
   System.out.print(<span class="hljs-string">&quot;pos-order: &quot;</span>);
   <span class="hljs-keyword">if</span> (h != <span class="hljs-keyword">null</span>) &#123;
      Stack&lt;Node&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;Node&gt;();
      stack.push(h);
      Node c = <span class="hljs-keyword">null</span>;
      <span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;
         c = stack.peek();
         <span class="hljs-comment">// 左树没处理先处理左树</span>
         <span class="hljs-keyword">if</span> (c.left != <span class="hljs-keyword">null</span> &amp;&amp; h != c.left &amp;&amp; h != c.right) &#123;
            stack.push(c.left);
         <span class="hljs-comment">// 右树没处理先处理右树</span>
         &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c.right != <span class="hljs-keyword">null</span> &amp;&amp; h != c.right) &#123;
            stack.push(c.right);
         <span class="hljs-comment">// 该处理自己了</span>
         &#125; <span class="hljs-keyword">else</span> &#123;
            System.out.print(stack.pop().value + <span class="hljs-string">&quot; &quot;</span>);
            <span class="hljs-comment">// h跟踪上次打印的结点</span>
            h = c;
         &#125;
      &#125;
   &#125;
   System.out.println();
&#125;</code></pre>



<ul>
<li><p>非递归实现中序遍历</p>
<ul>
<li><p>整条左边界依次入栈</p>
</li>
<li><p>第一条逻辑无法再命中，就弹出结点并打印，然后来到弹出结点的右树上继续执行条件一</p>
</li>
<li><p>如上面的树，左边界全入栈，栈顶 - &gt; 栈底以此为 4,2,1，不能再命中了，弹出4，来到4的右孩子且为Null，弹出2，来到2的右孩子且为5，压入5，弹出5，来到5的右孩子且为Null，弹出1，来到1的右孩子3，3、6依此入栈，弹出6，来到6的右孩子且为Null，弹出3，来到3的右孩子且为7，弹出7。</p>
<pre><code class="hljs java"><span class="hljs-comment">// 左头无限分解</span>
<span class="hljs-comment">// 左边左头分解，右边也左头分解</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">in</span><span class="hljs-params">(Node head)</span> </span>&#123;
    System.out.print(<span class="hljs-string">&quot;in-order: &quot;</span>);
    <span class="hljs-keyword">if</span> (head != <span class="hljs-keyword">null</span>) &#123;
      Stack&lt;Node&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;Node&gt;();
      <span class="hljs-keyword">while</span> (!stack.isEmpty() || head != <span class="hljs-keyword">null</span>) &#123;
        <span class="hljs-comment">// 把左边全压入</span>
        <span class="hljs-keyword">if</span> (head != <span class="hljs-keyword">null</span>) &#123;
          stack.push(head);
          head = head.left;
        &#125; <span class="hljs-keyword">else</span> &#123;
          head = stack.pop();
          System.out.print(head.value + <span class="hljs-string">&quot; &quot;</span>);
          head = head.right;
        &#125;
      &#125;
    &#125;
    System.out.println();
  &#125;</code></pre>



</li>
</ul>
</li>
</ul>
<ul>
<li>自己设计压栈的来实现</li>
</ul>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2020/11/27/Java%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">java并发编程 学习笔记</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/11/19/hello-world/">
                        <span class="hidden-mobile">Hello World</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":200})
    NProgress.start()
    document.addEventListener('DOMContentLoaded', function() {
      window.NProgress && window.NProgress.inc();
    })
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.staticfile.org/jquery/3.5.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.staticfile.org/tocbot/4.12.0/tocbot.min.js" ></script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>





  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      var inputArea = document.querySelector("#local-search-input");
      inputArea.onclick = function () {
        searchFunc(path, 'local-search-input', 'local-search-result');
        this.onclick = null
      }
    })()
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>



</body>
</html>
