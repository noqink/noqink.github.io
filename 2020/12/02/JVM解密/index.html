

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/imgfavicon.jpg">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  <title>JVM解密 - Blog</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.1.2/styles/ocean.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.5","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"copy_btn":true,"image_zoom":{"enable":true},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.2.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Main</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax=true
         style="background: url('https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/imgdefault.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="JVM解密">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2020-12-02 20:16" pubdate>
        2020年12月2日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      27.2k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      358
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">JVM解密</h1>
            
            <div class="markdown-body">
              <h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><h2 id="什么是JVM"><a href="#什么是JVM" class="headerlink" title="什么是JVM?"></a>什么是JVM?</h2><blockquote>
<p>定义</p>
</blockquote>
<p>​ Java Virtual Machine - java 程序的运行环境(java 二进制字节码的运行环境)</p>
<blockquote>
<p>好处</p>
</blockquote>
<ul>
<li>一次编写，到处运行的一个基石</li>
<li>自动内存的管理机制，提供垃圾回收功能</li>
<li>数组下标越界的检查</li>
<li>实现多态</li>
</ul>
<blockquote>
<p>比较</p>
</blockquote>
<p>​ jvm jre jdk(java开发工具包):</p>
<p>​ <img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201202202613.png" srcset="/img/loading.gif" alt="区别" style="zoom:50%;" /></p>
<p>​ JVM去屏蔽java代码与底层操作系统的差异</p>
<blockquote>
<p>常见的JVM</p>
</blockquote>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201202203444.png" srcset="/img/loading.gif" alt="JVM种类"></p>
<h1 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h1><h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201202203747.png" srcset="/img/loading.gif" alt="整体架构"></p>
<div class="hljs"><pre><code class="hljs js">ClassLoader为类加载器，java源代码编译为java二进制字节码后通过类加载器加载到JVM里运行，类放在方法区，创建的实例、对象放在堆里，其间所用到的方法放入虚拟机栈、程序计数器以及本地方法栈，方法执行时每行代码由执行引擎解释器逐行执行，方法中的热点代码(频繁调用的代码)由JIT优化后执行，GC对堆中不再被引用的对象引用回收。与操作系统打交道则需要本地方法接口调用。</code></pre></div>

<h2 id="1、程序计数器"><a href="#1、程序计数器" class="headerlink" title="1、程序计数器"></a>1、程序计数器</h2><h3 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h3><blockquote>
<p>Program Counter Register 程序计数器(寄存器)</p>
</blockquote>
<h3 id="1-2-作用"><a href="#1-2-作用" class="headerlink" title="1.2 作用"></a>1.2 作用</h3><ul>
<li><p>作用:  记住下一条jvm指令的执行地址</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201202205624.png" srcset="/img/loading.gif" alt="执行流程"></p>
<p>​   java源代码被编译成为 <strong>二进制字节码, 左侧为jvm指令</strong>, 对所有平台都是一致的, 指令交给解释器翻译为机器码, 再交给cpu执行, 期间 <strong>程序计数器</strong>记录下一条指令地址, 物理上 <strong>程序计数器由寄存器实现</strong>, 是cpu上读取最快的单元</p>
</li>
<li><p>特点:  </p>
<ul>
<li><p><strong>线程私有的</strong></p>
<ul>
<li>CPU会为每个线程分配时间片，当当前线程的时间片使用完以后，CPU就会去执行另一个线程中的代码</li>
<li>程序计数器是 <strong>每个线程</strong> 所 <strong>私有</strong> 的，每个线程都有自己的程序计数器，当另一个线程的时间片用完，又返回来执行当前线程的代码时，通过程序计数器可以知道应该执行哪一句指令</li>
</ul>
</li>
<li><p> 唯一一个<strong>不会存在内存溢出</strong>的区</p>
</li>
</ul>
</li>
</ul>
<h2 id="2、虚拟机栈"><a href="#2、虚拟机栈" class="headerlink" title="2、虚拟机栈"></a>2、虚拟机栈</h2><h3 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h3><blockquote>
<p>Java Virtual Machine Stacks (Java 虚拟机栈)</p>
</blockquote>
<ul>
<li>每个 <strong>线程</strong> 运行需要的内存空间，称为 <strong>虚拟机栈</strong></li>
<li>每个栈由多个 <strong>栈帧</strong> 组成，对应着每次调用方法时所占用的内存</li>
<li>每个线程只能有 <strong>一个活动栈帧</strong> ，对应着 <strong>当前正在执行的方法</strong></li>
</ul>
<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201202210927.png" srcset="/img/loading.gif" alt="例子" style="zoom:50%;" />

<h3 id="2-2-演示"><a href="#2-2-演示" class="headerlink" title="2.2 演示"></a>2.2 演示</h3><p>代码：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo_01</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;
        method1();
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span> </span>&#123;
        method2(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">method2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;
        <span class="hljs-keyword">int</span> c =  a + b;
        <span class="hljs-keyword">return</span> c;
    &#125;
&#125;</code></pre></div>

<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201202211143.png" srcset="/img/loading.gif" alt="图样" style="zoom:50%;" />

<h3 id="2-3-栈问题"><a href="#2-3-栈问题" class="headerlink" title="2.3 栈问题"></a>2.3 栈问题</h3><ul>
<li><p>垃圾回收是否涉及 <strong>栈内存</strong>？</p>
<ul>
<li><p> <strong>不需要</strong>，因为虚拟机栈中是由一个个栈帧组成的，在方法执行完毕后，对应的 <strong>栈帧就会被弹出栈</strong>。所以无需通过垃圾回收机制去回收内存。</p>
</li>
<li><p>垃圾回收是对 <strong>堆内存</strong> 中的无用对象回收。</p>
</li>
</ul>
</li>
<li><p><strong>栈内存分配越大越好吗</strong>？</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/tools/java.html#GUID-3B1CE181-CD30-4178-9602-230B800D4FAE">引用</a></p>
</li>
<li><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201203182734.png" srcset="/img/loading.gif" alt="栈帧分配"></p>
</li>
<li><p>不是。因为 <strong>物理内存是一定的</strong>，栈内存越大，可以支持更多的递归调用，但是 <strong>可执行的线程数就会越少</strong>。</p>
</li>
</ul>
</li>
<li><p>方法内的局部变量是否是线程安全的？</p>
<ul>
<li><p>如果方法内 <strong>局部变量没有逃离方法的作用范围</strong>，则是 <strong>线程安全</strong>的</p>
</li>
<li><p>如果如果 <strong>局部变量引用了对象</strong>，并<strong>逃离了方法的作用范围</strong>，则需要考虑线程安全问题</p>
</li>
</ul>
</li>
</ul>
<p>  例子:</p>
  <div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 局部变量的线程安全问题</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo_01_18</span> </span>&#123;

    <span class="hljs-comment">// 多个线程同时执行此方法</span>
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m1</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;
            x++;
        &#125;
        System.out.println(x);
    &#125;
&#125;</code></pre></div>

<p>  x变量为方法内的局部变量，一个线程一个栈，每次方法调用都产生一个栈帧，分配局部变量。</p>
  <img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201203183431.png" srcset="/img/loading.gif" alt="局部变量" style="zoom: 33%;" />

<p>  现在每个线程都有一个私有的x变量，各自加五千互不干扰，最终都得出相同的结果。</p>
<p>   <strong>但如果x为 int static</strong> ，结果就不一样:</p>
  <img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201203183659.png" srcset="/img/loading.gif" alt="static" style="zoom:33%;" />



<p>​ 但如果例子为:</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 局部变量的线程安全问题</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo_01_17</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();
        sb.append(<span class="hljs-number">4</span>);
        sb.append(<span class="hljs-number">5</span>);
        sb.append(<span class="hljs-number">6</span>);
        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;
            m2(sb);
        &#125;).start();
    &#125;

    <span class="hljs-comment">// m1()不会产生线程安全问题，sb为局部变量，线程私有</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m1</span><span class="hljs-params">()</span> </span>&#123;
        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();
        sb.append(<span class="hljs-number">1</span>);
        sb.append(<span class="hljs-number">2</span>);
        sb.append(<span class="hljs-number">3</span>);
        System.out.println(sb.toString());
    &#125;
    <span class="hljs-comment">// m2()会产生线程安全问题，sb对多个线程是共享的(例如main函数里，main线程和新线程都在修改sb)</span>
    <span class="hljs-comment">// 不能用到StringBuilder，应该StringBuffer</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m2</span><span class="hljs-params">(StringBuilder sb)</span> </span>&#123;
        sb.append(<span class="hljs-number">1</span>);
        sb.append(<span class="hljs-number">2</span>);
        sb.append(<span class="hljs-number">3</span>);
        System.out.println(sb.toString());
    &#125;
    <span class="hljs-comment">// m3()会产生线程安全问题，sb被返回了</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> StringBuilder <span class="hljs-title">m3</span><span class="hljs-params">()</span> </span>&#123;
        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();
        sb.append(<span class="hljs-number">1</span>);
        sb.append(<span class="hljs-number">2</span>);
        sb.append(<span class="hljs-number">3</span>);
        <span class="hljs-keyword">return</span> sb;
    &#125;
&#125;</code></pre></div>



<h3 id="2-4-栈内存溢出问题"><a href="#2-4-栈内存溢出问题" class="headerlink" title="2.4 栈内存溢出问题"></a>2.4 栈内存溢出问题</h3><blockquote>
<p> <strong>Java.lang.stackOverflowError</strong> 栈内存溢出</p>
</blockquote>
<h4 id="发生原因"><a href="#发生原因" class="headerlink" title="发生原因"></a>发生原因</h4><ul>
<li><p>虚拟机栈中， <strong>栈帧过多</strong>（无限递归）</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 演示栈内存溢出 java.lang.StackOverflowError</span>
<span class="hljs-comment"> * -Xss256k</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo_01_2</span> </span>&#123;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> count;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        <span class="hljs-keyword">try</span> &#123;
            method1();
        &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;
            e.printStackTrace();
            System.out.println(count);
        &#125;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span> </span>&#123;
        count++;
        method1();
    &#125;
&#125;</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201203185104.png" srcset="/img/loading.gif" alt="次数"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201203185225.png" srcset="/img/loading.gif" alt="修改栈内存"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201203185256.png" srcset="/img/loading.gif" alt="结果"></p>
</li>
</ul>
<ul>
<li>每个栈帧 <strong>所占用过大</strong></li>
</ul>
<p>​ 引用的包导致栈溢出的例子:</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * json 数据转换</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo_01_19</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> JsonProcessingException </span>&#123;
        Dept d = <span class="hljs-keyword">new</span> Dept();
        d.setName(<span class="hljs-string">&quot;Market&quot;</span>);

        Emp e1 = <span class="hljs-keyword">new</span> Emp();
        e1.setName(<span class="hljs-string">&quot;zhang&quot;</span>);
        e1.setDept(d);

        Emp e2 = <span class="hljs-keyword">new</span> Emp();
        e2.setName(<span class="hljs-string">&quot;li&quot;</span>);
        e2.setDept(d);

        d.setEmps(Arrays.asList(e1, e2));

        <span class="hljs-comment">// &#123; name: &#x27;Market&#x27;, emps: [&#123; name:&#x27;zhang&#x27;, dept:&#123; name:&#x27;&#x27;, emps: [ &#123;&#125;]&#125; &#125;,] &#125;</span>
        ObjectMapper mapper = <span class="hljs-keyword">new</span> ObjectMapper();
        System.out.println(mapper.writeValueAsString(d));
    &#125;
&#125;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Emp</span> </span>&#123;
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-keyword">private</span> Dept dept;

    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> name;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.name = name;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> Dept <span class="hljs-title">getDept</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> dept;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setDept</span><span class="hljs-params">(Dept dept)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.dept = dept;
    &#125;
&#125;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dept</span> </span>&#123;
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-keyword">private</span> List&lt;Emp&gt; emps;

    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> name;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.name = name;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Emp&gt; <span class="hljs-title">getEmps</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> emps;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setEmps</span><span class="hljs-params">(List&lt;Emp&gt; emps)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.emps = emps;
    &#125;
&#125;</code></pre></div>

<p>Json转换时:{ name: ‘Market’, emps: [{ name:’zhang’, dept:{ name:’’, emps: [ {}]} },] }</p>
<p>解决方案:</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Emp</span> </span>&#123;
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-meta">@JsonIgnore</span>
    <span class="hljs-keyword">private</span> Dept dept;
    <span class="hljs-comment">// ....</span>
&#125;</code></pre></div>



<h3 id="2-5-线程运行诊断"><a href="#2-5-线程运行诊断" class="headerlink" title="2.5 线程运行诊断"></a>2.5 线程运行诊断</h3><h4 id="案例1-cpu占用过高"><a href="#案例1-cpu占用过高" class="headerlink" title="案例1: cpu占用过高"></a>案例1: cpu占用过高</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 演示 cpu 占用过高</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo_01_16</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">null</span>, () -&gt; &#123;
            System.out.println(<span class="hljs-string">&quot;1...&quot;</span>);
            <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;

            &#125;
        &#125;, <span class="hljs-string">&quot;thread1&quot;</span>).start();


        <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">null</span>, () -&gt; &#123;
            System.out.println(<span class="hljs-string">&quot;2...&quot;</span>);
            <span class="hljs-keyword">try</span> &#123;
                Thread.sleep(<span class="hljs-number">1000000L</span>);
            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;, <span class="hljs-string">&quot;thread2&quot;</span>).start();

        <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">null</span>, () -&gt; &#123;
            System.out.println(<span class="hljs-string">&quot;3...&quot;</span>);
            <span class="hljs-keyword">try</span> &#123;
                Thread.sleep(<span class="hljs-number">1000000L</span>);
            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;, <span class="hljs-string">&quot;thread3&quot;</span>).start();
    &#125;
&#125;</code></pre></div>

<p>此代码运行到linux环境下:</p>
<p>top命令:</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201203191313.png" srcset="/img/loading.gif" alt="top"></p>
<p> <strong>只能定位到进程，无法定位到线程</strong></p>
<p> <strong>ps H -eo pid, tid（线程id）, %cpu | grep 刚才通过top查到的进程号</strong></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201203191646.png" srcset="/img/loading.gif" alt="结果"></p>
<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201203191750.png" srcset="/img/loading.gif" alt="test" style="zoom: 50%;" />

<blockquote>
<p>总结</p>
</blockquote>
<ul>
<li><p>Linux环境下运行某些程序的时候，可能导致CPU的占用过高，这时需要定位占用CPU过高的线程</p>
<ul>
<li><p><strong>top</strong>命令，查看是哪个 <strong>进程</strong>占用CPU过高</p>
</li>
<li><p><strong>ps H -eo pid, tid（线程id）, %cpu | grep 刚才通过top查到的进程号</strong> 通过ps命令进一步查看是哪个线程占用CPU过高</p>
</li>
<li><p><strong>jstack 进程id</strong> 通过查看进程中的线程的nid，刚才通过ps命令看到的tid来 <strong>对比定位</strong>，注意jstack查找出的线程id是 <strong>16进制的</strong>， <strong>需要转换</strong></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201204100850.png" srcset="/img/loading.gif" alt="16进制"></p>
<p>32665的十六进制对应为7f99, 所以定位到线程thread1</p>
<p>下面提示第八行代码出现问题</p>
</li>
</ul>
</li>
</ul>
<h4 id="案例2-程序运行很长时间没有结果"><a href="#案例2-程序运行很长时间没有结果" class="headerlink" title="案例2: 程序运行很长时间没有结果"></a>案例2: 程序运行很长时间没有结果</h4><p>代码:</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 演示线程死锁</span>
<span class="hljs-comment"> */</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>&#123;&#125;;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span></span>&#123;&#125;;
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo_01_03</span> </span>&#123;
    <span class="hljs-keyword">static</span> A a = <span class="hljs-keyword">new</span> A();
    <span class="hljs-keyword">static</span> B b = <span class="hljs-keyword">new</span> B();


    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;
        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;
            <span class="hljs-keyword">synchronized</span> (a) &#123;
                <span class="hljs-keyword">try</span> &#123;
                    Thread.sleep(<span class="hljs-number">2000</span>);
                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
                <span class="hljs-keyword">synchronized</span> (b) &#123;
                    System.out.println(<span class="hljs-string">&quot;我获得了 a 和 b&quot;</span>);
                &#125;
            &#125;
        &#125;).start();
        Thread.sleep(<span class="hljs-number">1000</span>);
        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;
            <span class="hljs-keyword">synchronized</span> (b) &#123;
                <span class="hljs-keyword">synchronized</span> (a) &#123;
                    System.out.println(<span class="hljs-string">&quot;我获得了 a 和 b&quot;</span>);
                &#125;
            &#125;
        &#125;).start();
    &#125;

&#125;</code></pre></div>

<p>同样可以利用jstack来查询</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201204101456.png" srcset="/img/loading.gif" alt="结果"></p>
<h2 id="3、本地方法栈"><a href="#3、本地方法栈" class="headerlink" title="3、本地方法栈"></a>3、本地方法栈</h2><blockquote>
<p>java虚拟机调用本地方法时需要提供的内存空间</p>
</blockquote>
<p>本地方法: 一些带有 <strong>native关键字</strong>的方法就是需要JAVA去调用本地的 <strong>C或者C++方法</strong>，因为JAVA有时候没法直接和 <strong>操作系统底层</strong>交互，所以需要用到本地方法。</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201204102423.png" srcset="/img/loading.gif" alt="clone()"></p>
<h2 id="4、堆"><a href="#4、堆" class="headerlink" title="4、堆"></a>4、堆</h2><blockquote>
<p>堆和方法区是 <strong>线程共享</strong>的</p>
</blockquote>
<h3 id="4-1-定义"><a href="#4-1-定义" class="headerlink" title="4.1 定义"></a>4.1 定义</h3><ul>
<li>通过new关键字 <strong>创建的对象</strong>都会被放在堆内存</li>
</ul>
<h3 id="4-2-特点"><a href="#4-2-特点" class="headerlink" title="4.2 特点"></a>4.2 特点</h3><ul>
<li> <strong>所有线程共享</strong>，堆内存中的对象都需要<strong>考虑线程安全问题</strong></li>
<li>有垃圾回收机制</li>
</ul>
<h3 id="4-3-堆内存溢出问题"><a href="#4-3-堆内存溢出问题" class="headerlink" title="4.3 堆内存溢出问题"></a>4.3 堆内存溢出问题</h3><blockquote>
<p> <strong>java.lang.OutofMemoryError</strong> ：java heap space. 堆内存溢出</p>
</blockquote>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1_5</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">try</span> &#123;
            List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
            String a = <span class="hljs-string">&quot;hello&quot;</span>;
            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;
                list.add(a); <span class="hljs-comment">// hello, hellohello, hellohellohellohello ...</span>
                a = a + a;  <span class="hljs-comment">// hellohellohellohello</span>
                i++;
            &#125;
        &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;
            e.printStackTrace();
            System.out.println(i);
        &#125;
    &#125;
&#125;</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201204103052.png" srcset="/img/loading.gif" alt="结果"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201204103650.png" srcset="/img/loading.gif" alt="修改"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201204103719.png" srcset="/img/loading.gif" alt="结果"></p>
<h3 id="4-4-堆内存诊断"><a href="#4-4-堆内存诊断" class="headerlink" title="4.4 堆内存诊断"></a>4.4 堆内存诊断</h3><h4 id="jps-工具"><a href="#jps-工具" class="headerlink" title="jps 工具"></a>jps 工具</h4><ul>
<li>查看当前系统中有哪些 <strong>java进程</strong></li>
</ul>
<h4 id="jmap工具"><a href="#jmap工具" class="headerlink" title="jmap工具"></a>jmap工具</h4><ul>
<li>查看 <strong>某个时刻</strong> 堆内存占用情况 ( - heap pid)</li>
<li>Jdk 9以上 jhsdb jmap –heap –pid pid</li>
</ul>
<h4 id="jconsole工具"><a href="#jconsole工具" class="headerlink" title="jconsole工具"></a>jconsole工具</h4><ul>
<li><p>图形界面的，多功能的检测工具，可以 <strong>连续监测</strong></p>
<p>代码:</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1_4</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;
        System.out.println(<span class="hljs-string">&quot;1...&quot;</span>);
        Thread.sleep(<span class="hljs-number">30000</span>);
        <span class="hljs-keyword">byte</span>[] array = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">10</span>]; <span class="hljs-comment">// 10 Mb, 堆空间</span>
        System.out.println(<span class="hljs-string">&quot;2...&quot;</span>);
        Thread.sleep(<span class="hljs-number">30000</span>);
        array = <span class="hljs-keyword">null</span>;
        System.gc();
        System.out.println(<span class="hljs-string">&quot;3...&quot;</span>);
        Thread.sleep(<span class="hljs-number">1000000L</span>);
    &#125;
&#125;</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201204105859.png" srcset="/img/loading.gif" alt="检测"></p>
</li>
</ul>
<h3 id="案例-gc回收之后-内存占用仍然很高"><a href="#案例-gc回收之后-内存占用仍然很高" class="headerlink" title="案例: gc回收之后, 内存占用仍然很高"></a>案例: gc回收之后, 内存占用仍然很高</h3><p>​ 代码:</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 演示查看对象个数 堆转储 dump</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1_13</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;
        List&lt;Student&gt; students = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">200</span>; i++) &#123;
            students.add(<span class="hljs-keyword">new</span> Student());
<span class="hljs-comment">//            Student student = new Student();</span>
        &#125;
        Thread.sleep(<span class="hljs-number">1000000000L</span>);
    &#125;
&#125;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">byte</span>[] big = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>];
&#125;</code></pre></div>

<p>​ 执行完gc后, 内存占用还是很高:</p>
<p>​ <img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201204135214.png" srcset="/img/loading.gif" alt="执行完gc后"></p>
<h3 id="使用jvisualvm"><a href="#使用jvisualvm" class="headerlink" title="使用jvisualvm"></a>使用jvisualvm</h3><p>堆快照:</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201204135748.png" srcset="/img/loading.gif" alt="堆快照"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201204135854.png" srcset="/img/loading.gif" alt="查找堆"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201204140353.png" srcset="/img/loading.gif" alt="查到结果"></p>
<p>查到结果为Student对象中浪费空间, list一直未被回收, 内存占用高</p>
<h2 id="5、方法区"><a href="#5、方法区" class="headerlink" title="5、方法区"></a>5、方法区</h2><h3 id="5-1-定义"><a href="#5-1-定义" class="headerlink" title="5.1 定义"></a>5.1 定义</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201204142845.png" srcset="/img/loading.gif" alt="定义"></p>
<h3 id="5-2-结构"><a href="#5-2-结构" class="headerlink" title="5.2 结构"></a>5.2 结构</h3><p>​ <img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201204142945.png" srcset="/img/loading.gif" alt="结构"></p>
<p>​   元空间已经不由jvm管理内存了</p>
<h3 id="5-3-内存溢出"><a href="#5-3-内存溢出" class="headerlink" title="5.3 内存溢出"></a>5.3 内存溢出</h3><ul>
<li><p>1.8以后会导致 <strong>元空间</strong>内存溢出</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 演示元空间内存溢出 java.lang.OutOfMemoryError: Metaspace</span>
<span class="hljs-comment"> * -XX:MaxMetaspaceSize=8m</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1_8</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ClassLoader</span> </span>&#123; <span class="hljs-comment">// 可以用来加载类的二进制字节码</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">try</span> &#123;
            Demo1_8 test = <span class="hljs-keyword">new</span> Demo1_8();
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++, j++) &#123;
                <span class="hljs-comment">// ClassWriter 作用是生成类的二进制字节码</span>
                ClassWriter cw = <span class="hljs-keyword">new</span> ClassWriter(<span class="hljs-number">0</span>);
                <span class="hljs-comment">// 版本号， public， 类名, 包名, 父类， 接口</span>
                cw.visit(Opcodes.V1_8, Opcodes.ACC_PUBLIC, <span class="hljs-string">&quot;Class&quot;</span> + i, <span class="hljs-keyword">null</span>, <span class="hljs-string">&quot;java/lang/Object&quot;</span>, <span class="hljs-keyword">null</span>);
                <span class="hljs-comment">// 返回 byte[]</span>
                <span class="hljs-keyword">byte</span>[] code = cw.toByteArray();
                <span class="hljs-comment">// 执行了类的加载</span>
                test.defineClass(<span class="hljs-string">&quot;Class&quot;</span> + i, code, <span class="hljs-number">0</span>, code.length); <span class="hljs-comment">// Class 对象</span>
            &#125;
        &#125; <span class="hljs-keyword">finally</span> &#123;
            System.out.println(j);
        &#125;
    &#125;
&#125;</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201204143911.png" srcset="/img/loading.gif" alt="配置"></p>
<p>（元空间默认用系统内存，很难演示元空间溢出）</p>
<p>若改为8m:Error occurred during initialization of VM MaxMetaspaceSize is too small.</p>
<p>所以改为10m再次测试:          <img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201204144143.png" srcset="/img/loading.gif" alt="结果"></p>
</li>
</ul>
<ul>
<li><p>1.8以前会导致 <strong>永久代</strong>内存溢出</p>
<p>使用java1.6:</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201204144418.png" srcset="/img/loading.gif" alt="结果"></p>
</li>
</ul>
<h3 id="5-4-真实场景"><a href="#5-4-真实场景" class="headerlink" title="5.4 真实场景"></a>5.4 真实场景</h3><p>​ <img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201204145437.png" srcset="/img/loading.gif" alt="区别"></p>
<ul>
<li><p>Spring</p>
<ul>
<li><p><strong>cjlib</strong> 生成代理类, AOP核心</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201204145057.png" srcset="/img/loading.gif" alt="cjlib"></p>
<p>都有ClassWriter和ClassVisitor，都是 <strong>运行期间动态生成类的字节码，完成动态的类加载，代理技术广泛应用这种字节码动态生成技术</strong></p>
</li>
</ul>
</li>
<li><p>mybatis</p>
<ul>
<li> <strong>cjlib</strong> 生成Mapper接口的实现类</li>
</ul>
<p>所以使用这种框架, 是很容易产生 <strong>永久代溢出</strong> 的情况的！</p>
</li>
</ul>
<h3 id="5-5-常量池"><a href="#5-5-常量池" class="headerlink" title="5.5 常量池"></a>5.5 常量池</h3><p>常量池最初存在字节码文件，运行时被加载到运行时常量池（constant pool）</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// 运行先编译二进制字节码，包含了(类的基本信息、常量池、类的方法定义（包含了虚拟机指令）)</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorld</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;hello!&quot;</span>);
    &#125;
&#125;</code></pre></div>

<p>找到class文件:</p>
<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201204150212.png" srcset="/img/loading.gif" alt="class文件" style="zoom:50%;" />

<p>javap -v HelloWorld.class 进行反编译,并显示全部信息:</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201204150438.png" srcset="/img/loading.gif" alt="类的基本信息"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201204150537.png" srcset="/img/loading.gif" alt="常量池1"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201204150609.png" srcset="/img/loading.gif" alt="常量池2"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201204150719.png" srcset="/img/loading.gif" alt="无参构造方法"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201204150745.png" srcset="/img/loading.gif" alt="main方法"></p>
<p>0,3,5,8后为虚拟机指令, getstatic为获取 <strong>静态变量</strong> , 即得到sout, ldc加载参数(hello!), invokevirtual虚方法调用,调用println, return为结束</p>
<p>#2,#3,#4查表翻译:</p>
<div class="hljs"><pre><code class="hljs clean">根据#<span class="hljs-number">2</span>查到常量池的表 -&gt; Fieldref -&gt; #<span class="hljs-number">21.</span>#<span class="hljs-number">22</span>
#<span class="hljs-number">21</span> -&gt; Class -&gt; #<span class="hljs-number">28</span>
(说明要找java/lang/System类的成员变量)
#<span class="hljs-number">22</span> -&gt; #<span class="hljs-number">29</span> #<span class="hljs-number">30</span>
(说明要找java/lang/System类中out的变量, 类型为java/io/PrintStream)

根据#<span class="hljs-number">3</span>查到常量池的表 -&gt; #<span class="hljs-number">23</span>(String) -&gt; hello!(utf<span class="hljs-number">-8</span>) 加载进来

#<span class="hljs-number">4</span> -&gt; 方法调用Methodref -&gt; ....</code></pre></div>

<blockquote>
<p>常量池作用</p>
</blockquote>
<p> <strong>给指令提供一些常量符号, 根据常量符号查表找到, 虚拟机指令才可正常执行</strong></p>
<h3 id="5-6-运行时常量池"><a href="#5-6-运行时常量池" class="headerlink" title="5.6 运行时常量池"></a>5.6 运行时常量池</h3><ul>
<li>常量池<ul>
<li>就是一张表（如上图中的constant pool），虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量信息</li>
</ul>
</li>
<li>运行时常量池<ul>
<li>常量池是*.class文件中的，当该 <strong>类被加载以后</strong>，它的常量池信息就会 <strong>放入运行时常量池</strong>，并把里面的 <strong>符号地址变为真实地址</strong></li>
</ul>
</li>
</ul>
<h3 id="5-7-String-Table-（串池）"><a href="#5-7-String-Table-（串池）" class="headerlink" title="5.7 String Table （串池）"></a>5.7 String Table （串池）</h3><h4 id="字节码和常量池角度理解底层原理"><a href="#字节码和常量池角度理解底层原理" class="headerlink" title="字节码和常量池角度理解底层原理"></a>字节码和常量池角度理解底层原理</h4><p>测试代码：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
    String s1 = <span class="hljs-string">&quot;a&quot;</span>; <span class="hljs-comment">// 懒惰的</span>
    String s2 = <span class="hljs-string">&quot;b&quot;</span>;
    String s3 = <span class="hljs-string">&quot;ab&quot;</span>;
&#125;</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201225100606.png" srcset="/img/loading.gif" alt="进行编译"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201225100858.png" srcset="/img/loading.gif" alt="加载"></p>
<p>Ldc #n 从常量池n号位置加载对应信息（常量、对象引用）</p>
<p>astore_1 加载好的信息放入局部变量表编号1</p>
<p>常量池中的信息，都会被加载到运行时常量池中，但这是a b ab 仅是常量池中的符号， <strong>还没有成为java字符串</strong> ；</p>
<p>当执行到 ldc #2 时，会把符号 a 变为 “a” 字符串对象， <strong>并放入串池中</strong> （hashtable结构 不可扩容）</p>
<p>当执行到 ldc #3 时，会把符号 b 变为 “b” 字符串对象，并放入串池中</p>
<p>当执行到 ldc #4 时，会把符号 ab 变为 “ab” 字符串对象，并放入串池中</p>
<p>最终 <strong>StringTable [“a”, “b”, “ab”]</strong> </p>
<p> <strong>注意</strong> ：字符串对象的创建都是 <strong>懒惰的</strong> ，只有当运行到那一行字符串且在串池中不存在的时候（如 ldc #2）时，该字符串才会被创建并放入串池中。</p>
<div class="hljs"><pre><code class="hljs js">常量池中的信息，都会被加载到运行时常量池中， 这时 a b ab 都是常量池中的符号，还没有变为 java 字符串对象
执行到ldc #2 会把 a 符号变为 &quot;a&quot; 字符串对象，此时会准备一份空间为String table[] （哈希表,不可扩容）也就是串池，存入，然后去找，看看有没有取值相同的key

执行到ldc #3 会把 b 符号变为 &quot;b&quot; 字符串对象
执行到ldc #4 会把 ab 符号变为 &quot;ab&quot; 字符串对象

#懒惰的 用到了才会创建，用不到不会提前创建</code></pre></div>



<h4 id="字符串变量拼接"><a href="#字符串变量拼接" class="headerlink" title="字符串变量拼接"></a>字符串变量拼接</h4><p>修改代码：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
    String s1 = <span class="hljs-string">&quot;a&quot;</span>; <span class="hljs-comment">// 懒惰的 用到了才会创建，用不到不会提前创建</span>
    String s2 = <span class="hljs-string">&quot;b&quot;</span>;
    String s3 = <span class="hljs-string">&quot;ab&quot;</span>;
    String s4 = s1 + s2;
&#125;</code></pre></div>

<p>再次编译：</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201225102356.png" srcset="/img/loading.gif" alt="编译"></p>
<p>先创建一个 <strong>StringBuilder</strong> 对象，invokespecial调用方法， init为 <strong>构造方法，且无参</strong>，aload_1把s1加载进来，和astore_1相对，调用append方法，再aload_2，append方法，再调用toString方法，再存储astore_4</p>
<p>所以是会调用StringBuilder的toString()方法的，我们找到这个方法</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201225102830.png" srcset="/img/loading.gif" alt="toString"></p>
<div class="hljs"><pre><code class="hljs java">System.out.println(s3 == s4);
<span class="hljs-comment">// false</span></code></pre></div>

<p> s3值为ab，是串池中的一个对象，s4引用的是一个新的字符串对象，存在 <strong>堆</strong> 里面，new出来的。</p>
<p>通过拼接的方式来创建字符串的 <strong>过程</strong> 是：StringBuilder().append(“a”).append(“b”).toString()</p>
<p>最后的toString方法的返回值是一个 <strong>新的字符串</strong> ，但字符串的 <strong>值</strong> 和拼接的字符串一致，但是两个不同的字符串， <strong>一个存在于串池之中，一个存在于堆内存之中</strong> </p>
<h4 id="编译期优化"><a href="#编译期优化" class="headerlink" title="编译期优化"></a>编译期优化</h4><p>代码修改为</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
    String s1 = <span class="hljs-string">&quot;a&quot;</span>; <span class="hljs-comment">// 懒惰的 用到了才会创建，用不到不会提前创建</span>
    String s2 = <span class="hljs-string">&quot;b&quot;</span>;
    String s3 = <span class="hljs-string">&quot;ab&quot;</span>;
    String s4 = s1 + s2;<span class="hljs-comment">// new StringBuilder().append(&quot;a&quot;).append(&quot;b&quot;).toString()  new String(&quot;ab&quot;)</span>
    String s5 = <span class="hljs-string">&quot;a&quot;</span> + <span class="hljs-string">&quot;b&quot;</span>;
    System.out.println(s3 == s5);
&#125;
<span class="hljs-comment">// true</span></code></pre></div>

<p>编译后发现是直接去取值</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201225103458.png" srcset="/img/loading.gif" alt="取值"></p>
<p>直接引用串池中已有的对象</p>
<blockquote>
<p>原理</p>
</blockquote>
<p> <strong>javac 在编译期间的优化</strong> ，结果已经在编译期确定为ab，并在StringTable中查找。</p>
<ul>
<li>使用 <strong>拼接字符串常量</strong> 的方法来创建新的字符串时，因为 <strong>内容是常量，javac在编译期会进行优化，结果已在编译期确定为ab</strong> ，而创建ab的时候已经在串池中放入了“ab”，所以ab3直接从串池中获取值，所以进行的操作和 ab = “ab” 一致。</li>
<li>使用 <strong>拼接字符串变量</strong> 的方法来创建新的字符串时，因为内容是变量，只能 <strong>在运行期确定它的值，所以需要使用StringBuilder来创建</strong> </li>
</ul>
<h4 id="字符串延迟实例化"><a href="#字符串延迟实例化" class="headerlink" title="字符串延迟实例化"></a>字符串延迟实例化</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
    <span class="hljs-keyword">int</span> x = args.length;
    System.out.println(); <span class="hljs-comment">// 字符串个数 2275</span>

    System.out.print(<span class="hljs-string">&quot;1&quot;</span>);
    System.out.print(<span class="hljs-string">&quot;2&quot;</span>);
    System.out.print(<span class="hljs-string">&quot;3&quot;</span>);
    System.out.print(<span class="hljs-string">&quot;4&quot;</span>);
    System.out.print(<span class="hljs-string">&quot;5&quot;</span>);
    System.out.print(<span class="hljs-string">&quot;6&quot;</span>);
    System.out.print(<span class="hljs-string">&quot;7&quot;</span>);
    System.out.print(<span class="hljs-string">&quot;8&quot;</span>);
    System.out.print(<span class="hljs-string">&quot;9&quot;</span>);
    System.out.print(<span class="hljs-string">&quot;0&quot;</span>);
    System.out.print(<span class="hljs-string">&quot;1&quot;</span>); <span class="hljs-comment">// 字符串个数 2285</span>
    System.out.print(<span class="hljs-string">&quot;2&quot;</span>);
    System.out.print(<span class="hljs-string">&quot;3&quot;</span>);
    System.out.print(<span class="hljs-string">&quot;4&quot;</span>);
    System.out.print(<span class="hljs-string">&quot;5&quot;</span>);
    System.out.print(<span class="hljs-string">&quot;6&quot;</span>);
    System.out.print(<span class="hljs-string">&quot;7&quot;</span>);
    System.out.print(<span class="hljs-string">&quot;8&quot;</span>);
    System.out.print(<span class="hljs-string">&quot;9&quot;</span>);
    System.out.print(<span class="hljs-string">&quot;0&quot;</span>);
    System.out.print(x); <span class="hljs-comment">// 字符串个数</span>
&#125;</code></pre></div>

<p>用的IDEA memory工具查看</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201225110206.png" srcset="/img/loading.gif" alt="memory"></p>
<p>debug</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201225110250.png" srcset="/img/loading.gif" alt="memory"></p>
<p>正好十一个，再到后面，串池重复，String个数不增加</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201225110427.png" srcset="/img/loading.gif" alt="memory"></p>
<blockquote>
<p>总结</p>
</blockquote>
<p>StringTable特征：</p>
<p>用来放字符串对象且里面的 <strong>元素不重复</strong></p>
<ul>
<li>常量池中的字符串仅是符号，<code>第一次用到时才变为对象 </code></li>
<li>利用串池的机制，来 <code>避免重复创建字符串对象 </code></li>
<li>字符串 <code>变量拼接</code> 的原理是 <code>StringBuilder (1.8) </code> </li>
<li>字符串 <code>常量拼接</code> 的原理是 <code>编译期优化</code></li>
<li>可以使用 <strong>intern方法</strong> ，主动将串池中还没有的字符串对象放入串池中</li>
<li> <strong>注意</strong> ：无论是串池还是堆里面的字符串，<code>都是对象</code></li>
</ul>
<h4 id="intern方法"><a href="#intern方法" class="headerlink" title="intern方法"></a>intern方法</h4><blockquote>
<p>主动将串池中没有的串放入</p>
<p>1.8:</p>
<p>无论放入是否成功，都会返回 <strong>串池中</strong> 的字符串对象</p>
<p> <strong>注意</strong> ：此时如果调用intern方法成功，堆内存与串池中的字符串对象是同一个对象；如果失败，则不是同一个对象</p>
<p>1.6:</p>
<p>无论放入是否成功，都会返回 <strong>串池中</strong> 的字符串对象</p>
<p><strong>注意</strong>：此时无论调用intern方法成功与否，串池中的字符串对象和堆内存中的字符串对象 <strong>都不是同一个对象</strong> </p>
</blockquote>
<h5 id="intern-1-8"><a href="#intern-1-8" class="headerlink" title="intern 1.8"></a>intern 1.8</h5><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;

    <span class="hljs-comment">// a b都是常量，放在串池 两个 a b</span>
    <span class="hljs-comment">// new的String放在堆中 三个 a b ab 动态拼接的字符串开始都放在堆中，不在串池</span>
    String s = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;a&quot;</span>) + <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;b&quot;</span>);
    <span class="hljs-comment">// 堆  new String(&quot;a&quot;)   new String(&quot;b&quot;) new String(&quot;ab&quot;)</span>

    String s2 = s.intern();
    <span class="hljs-comment">// 将这个字符串对象尝试放入串池</span>
    <span class="hljs-comment">// 如果有则并不会放入</span>
    <span class="hljs-comment">// 如果没有则放入串池， 会把串池中的对象返回</span>
    System.out.println(s2 == <span class="hljs-string">&quot;ab&quot;</span>); <span class="hljs-comment">// ab用的上一步放入串池的</span>
    <span class="hljs-comment">// true</span>
    System.out.println(s == <span class="hljs-string">&quot;ab&quot;</span>); <span class="hljs-comment">// intern会将s尝试放入串池</span>
    <span class="hljs-comment">// true</span>
&#125;</code></pre></div>

<p>如果“ab”一开始就放入</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
    String x = <span class="hljs-string">&quot;ab&quot;</span>; <span class="hljs-comment">// ab放入串池</span>
    
    <span class="hljs-comment">// a b都是常量，放在串池 三个 a b ab</span>
    <span class="hljs-comment">// new的String放在堆中 三个 a b ab 动态拼接的字符串开始都放在堆中，不在串池</span>
    String s = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;a&quot;</span>) + <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;b&quot;</span>);
    <span class="hljs-comment">// 堆  new String(&quot;a&quot;)   new String(&quot;b&quot;) new String(&quot;ab&quot;)</span>

    String s2 = s.intern();
    <span class="hljs-comment">// 将这个字符串对象尝试放入串池</span>
    <span class="hljs-comment">// 如果有则并不会放入</span>
    <span class="hljs-comment">// 如果没有则放入串池， 会把串池中的对象返回</span>
    System.out.println(s2 == x); <span class="hljs-comment">// 拿串池返回的比</span>
    <span class="hljs-comment">// true</span>
    System.out.println(s == x); <span class="hljs-comment">// 拿堆的比，intern没有放入</span>
    <span class="hljs-comment">// false</span>
&#125;</code></pre></div>

<p>s.intern()，如果串池没有，s会放入；如果有，会返回串池中的对象</p>
<p>所以如果串池没有 s == “ab” ，s放入了，所以相等</p>
<p>但是如果串池有，s == x，s没有放入但返回了s2，所以s2 == x，但s != x</p>
<h5 id="intern-1-6"><a href="#intern-1-6" class="headerlink" title="intern 1.6"></a>intern 1.6</h5><p>代码：</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201225135149.png" srcset="/img/loading.gif" alt="code"></p>
<p>true和false</p>
<p>另外一种情况：</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201225135446.png" srcset="/img/loading.gif" alt="new code"></p>
<p>s.intern是拷贝，返回的串池中的ab，和s不是同一个对象</p>
<p>所以x、s2都是 <strong>串池中的ab</strong> ，s还是 <strong>堆里的对象</strong></p>
<p>还是true false</p>
<p>相同代码 1.8环境两个true</p>
<h5 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h5><ul>
<li>可以使用 intern 方法，主动将串池中还没有的字符串对象放入串池<ul>
<li>1.8 将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有则放入串池， 会把串 池中的对象返回</li>
<li>1.6 将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有会把此对象 <strong>复制一份， 放入串池</strong> ， 会把串池中的对象返回</li>
</ul>
</li>
</ul>
<h4 id="String-Table-面试题"><a href="#String-Table-面试题" class="headerlink" title="String Table 面试题"></a>String Table 面试题</h4><p>code：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        String s1 = <span class="hljs-string">&quot;a&quot;</span>;
        String s2 = <span class="hljs-string">&quot;b&quot;</span>;
        String s3 = <span class="hljs-string">&quot;a&quot;</span> + <span class="hljs-string">&quot;b&quot;</span>; <span class="hljs-comment">// ab</span>
        String s4 = s1 + s2;   <span class="hljs-comment">// init,apend,toString -&gt; new String(&quot;ab&quot;)</span>
        String s5 = <span class="hljs-string">&quot;ab&quot;</span>;
        String s6 = s4.intern();<span class="hljs-comment">// s4不会放入，还是堆上</span>


        System.out.println(s3 == s4); <span class="hljs-comment">// false</span>
        System.out.println(s3 == s5); <span class="hljs-comment">// true</span>
        System.out.println(s3 == s6); <span class="hljs-comment">// true</span>

        String x2 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;c&quot;</span>) + <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;d&quot;</span>); <span class="hljs-comment">// new String(&quot;cd&quot;)</span>
        String x1 = <span class="hljs-string">&quot;cd&quot;</span>;<span class="hljs-comment">// 串池</span>
        x2.intern();<span class="hljs-comment">// x2放入串池失败，堆中</span>
       
        System.out.println(x1 == x2); <span class="hljs-comment">// false</span>
    &#125;</code></pre></div>

<p>如果代码：</p>
<div class="hljs"><pre><code class="hljs java">String x2 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;c&quot;</span>) + <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;d&quot;</span>); <span class="hljs-comment">// new String(&quot;cd&quot;)</span>
        x2.intern(); <span class="hljs-comment">// x2放入串池</span>
        String x1 = <span class="hljs-string">&quot;cd&quot;</span>;

<span class="hljs-comment">// 问，如果调换了【最后两行代码】的位置呢，如果是jdk1.6呢</span>
        System.out.println(x1 == x2); <span class="hljs-comment">// 1.8 true 1.6 false</span>
    &#125;</code></pre></div>



<h4 id="StringTable-位置"><a href="#StringTable-位置" class="headerlink" title="StringTable 位置"></a>StringTable 位置</h4><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201225141334.png" srcset="/img/loading.gif" alt="位置"></p>
<p>原因：永久代内存回收效率很低，永久代需要 <strong>Full GC</strong> 才会触发 <strong>永久代垃圾回收</strong>，Full GC需要等到 <strong>老年代空间不足</strong> 才能触发，间接导致串池回收效率很低。</p>
<p>堆里面串池只需要 <strong>minor GC</strong> 就可以触发垃圾回收。</p>
<h5 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h5><p>1.6 环境下运行和1.8环境报错不同</p>
<p>code：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 演示 StringTable 位置</span>
<span class="hljs-comment"> * 在jdk8下设置 -Xmx10m -XX:-UseGCOverheadLimit</span>
<span class="hljs-comment"> * 在jdk6下设置 -XX:MaxPermSize=10m</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1_6</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;
        List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();
        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">260000</span>; j++) &#123;
                list.add(String.valueOf(j).intern());
                i++;
            &#125;
        &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;
            e.printStackTrace();
        &#125; <span class="hljs-keyword">finally</span> &#123;
            System.out.println(i);
        &#125;
    &#125;
&#125;</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201225142201.png" srcset="/img/loading.gif" alt="VM setting"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201225142737.png" srcset="/img/loading.gif" alt="堆错误"></p>
<p>如果是1.6</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201225143029.png" srcset="/img/loading.gif" alt="1.6"></p>
<p>显示永久代空间不足</p>
<p>如果只加-Xmx10m：</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201225143310.png" srcset="/img/loading.gif" alt="xmx10m"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201225143329.png" srcset="/img/loading.gif" alt="GC overhead"></p>
<p>后面的参数实际上是设置 <strong>GC limit开关</strong></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201225143455.png" srcset="/img/loading.gif" alt="开关"></p>
<p>加号表示开启，减号表示关闭</p>
<h4 id="String-Table-垃圾回收"><a href="#String-Table-垃圾回收" class="headerlink" title="String Table 垃圾回收"></a>String Table 垃圾回收</h4><p>字符串常量并不是永久的，也是会被GC回收的。</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 演示 StringTable 垃圾回收</span>
<span class="hljs-comment"> * 堆内存最大值       打印字符串表统计信息          打印GC信息</span>
<span class="hljs-comment"> * -Xmx10m -XX:+PrintStringTableStatistics -XX:+PrintGCDetails -verbose:gc</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1_7</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;
        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">100000</span>; j++) &#123; <span class="hljs-comment">// j=100, j=10000</span>
                String.valueOf(j).intern();
                i++;
            &#125;
        &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;
            e.printStackTrace();
        &#125; <span class="hljs-keyword">finally</span> &#123;
            System.out.println(i);
        &#125;

    &#125;
&#125;</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201225144248.png" srcset="/img/loading.gif" alt="JVM配置"></p>
<p>SymbolTable statistics: 符号表 也在常量池</p>
<p>StringTable statistics: 串池统计信息（哈希表实现）</p>
<p>哈希表：数组 + 链表， 数组个数称为桶（bucket），键值对：entries， literals（字符串常量对象个数）</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201225144722.png" srcset="/img/loading.gif" alt="结果"></p>
<p>如果删除循环</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201225144808.png" srcset="/img/loading.gif" alt="结果"></p>
<blockquote>
<p>为什么循环一万次 字符串常量数没有这么多产生</p>
</blockquote>
<p>进行了gc回收</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210309081832.png" srcset="/img/loading.gif" alt="gc"></p>
<h4 id="String-Table-性能调优"><a href="#String-Table-性能调优" class="headerlink" title="String Table 性能调优"></a>String Table 性能调优</h4><ul>
<li>jvm参数调优</li>
</ul>
<p>主要就是调整 桶 的个数</p>
<div class="hljs"><pre><code class="hljs java">-XX:StringTableSize=<span class="hljs-number">1009</span></code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210309082342.png" srcset="/img/loading.gif" alt="案例文件"></p>
<p>存储近48万单词</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210309082519.png" srcset="/img/loading.gif" alt="结果"></p>
<p>最终结果为毫秒</p>
<p>为什么这么快？</p>
<p>桶开的个数多 扩大了哈希分布 减少了哈希冲突 更好的效率</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210309082800.png" srcset="/img/loading.gif" alt="桶个数"></p>
<p>缩小桶大小会变慢</p>
<ul>
<li><p>考虑将字符串对象是否入池</p>
<p>intern方法</p>
</li>
</ul>
<p>code: 把单词十遍存入list</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210309084523.png" srcset="/img/loading.gif" alt="code"></p>
<p>运行后jvm显示</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210309084936.png" srcset="/img/loading.gif" alt="jvm"></p>
<p>如果listadd的时候 不用line.intern()</p>
<p>直接add的话</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210309085031.png" srcset="/img/loading.gif" alt="不用intern"></p>
<p>明显char[]的占用率变高 占用也变高很多</p>
<h2 id="6、-直接内存"><a href="#6、-直接内存" class="headerlink" title="6、 直接内存"></a>6、 直接内存</h2><p>直接内存并不属于JVM管理，而是属于 <strong>系统内存</strong> </p>
<p>也就是操作系统的内存</p>
<p> <strong><em>Direct Memory</em></strong> </p>
<ul>
<li>常见于 NIO 操作时，用于数据缓冲区 </li>
<li>分配回收成本较高，但读写性能高 </li>
<li>不受 JVM 内存回收管理</li>
</ul>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 演示 ByteBuffer 作用</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1_9</span> </span>&#123;
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String FROM = <span class="hljs-string">&quot;/Users/qiuke/Desktop/test1.mp4&quot;</span>;
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String TO = <span class="hljs-string">&quot;/Users/qiuke/Desktop/test2.mp4&quot;</span>;
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _1Mb = <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        <span class="hljs-comment">// 传统io方法</span>
        io(); <span class="hljs-comment">// io 用时</span>

        directBuffer(); <span class="hljs-comment">// directBuffer 用时：</span>
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">directBuffer</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">long</span> start = System.nanoTime();
        <span class="hljs-keyword">try</span> (FileChannel from = <span class="hljs-keyword">new</span> FileInputStream(FROM).getChannel();
             FileChannel to = <span class="hljs-keyword">new</span> FileOutputStream(TO).getChannel();
        ) &#123;
            ByteBuffer bb = ByteBuffer.allocateDirect(_1Mb);
            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;
                <span class="hljs-keyword">int</span> len = from.read(bb);
                <span class="hljs-keyword">if</span> (len == -<span class="hljs-number">1</span>) &#123;
                    <span class="hljs-keyword">break</span>;
                &#125;
                bb.flip();
                to.write(bb);
                bb.clear();
            &#125;
        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;
            e.printStackTrace();
        &#125;
        <span class="hljs-keyword">long</span> end = System.nanoTime();
        System.out.println(<span class="hljs-string">&quot;directBuffer 用时：&quot;</span> + (end - start) / <span class="hljs-number">1000_000.0</span>);
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">io</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">long</span> start = System.nanoTime();
        <span class="hljs-keyword">try</span> (FileInputStream from = <span class="hljs-keyword">new</span> FileInputStream(FROM);
             FileOutputStream to = <span class="hljs-keyword">new</span> FileOutputStream(TO);
        ) &#123;
            <span class="hljs-keyword">byte</span>[] buf = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[_1Mb];
            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;
                <span class="hljs-keyword">int</span> len = from.read(buf);
                <span class="hljs-keyword">if</span> (len == -<span class="hljs-number">1</span>) &#123;
                    <span class="hljs-keyword">break</span>;
                &#125;
                to.write(buf, <span class="hljs-number">0</span>, len);
            &#125;
        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;
            e.printStackTrace();
        &#125;
        <span class="hljs-keyword">long</span> end = System.nanoTime();
        System.out.println(<span class="hljs-string">&quot;io 用时：&quot;</span> + (end - start) / <span class="hljs-number">1000_000.0</span>);
    &#125;
&#125;</code></pre></div>



<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210309090747.png" srcset="/img/loading.gif" alt="结果"></p>
<h3 id="6-1-直接内存的基础使用"><a href="#6-1-直接内存的基础使用" class="headerlink" title="6.1 直接内存的基础使用"></a>6.1 直接内存的基础使用</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210309090918.png" srcset="/img/loading.gif" alt="原理"></p>
<p>java不具备调用磁盘读写的能力，要调用系统函数本地方法才能操控磁盘。</p>
<p>但由于两块缓冲区，需要读两份，效率低下；</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210316081400.png" srcset="/img/loading.gif" alt="direct"></p>
<div class="hljs"><pre><code class="hljs java">ByteBuffer bb = ByteBuffer.allocateDirect(_1Mb)</code></pre></div>

<p>Direct memory 系统和java代码都能直接访问；</p>
<h3 id="6-2-直接内存的垃圾回收"><a href="#6-2-直接内存的垃圾回收" class="headerlink" title="6.2 直接内存的垃圾回收"></a>6.2 直接内存的垃圾回收</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 演示直接内存溢出</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1_10</span> </span>&#123;
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> _100Mb = <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">100</span>;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        List&lt;ByteBuffer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;
                ByteBuffer byteBuffer = ByteBuffer.allocateDirect(_100Mb);
                list.add(byteBuffer);
                i++;
            &#125;
        &#125; <span class="hljs-keyword">finally</span> &#123;
            System.out.println(i);
        &#125;
        <span class="hljs-comment">// 方法区是jvm规范， jdk6 中对方法区的实现称为永久代</span>
        <span class="hljs-comment">//                  jdk8 对方法区的实现称为元空间</span>
    &#125;
&#125;</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210316081820.png" srcset="/img/loading.gif" alt="报错"></p>
<h3 id="6-3-直接内存的释放原理"><a href="#6-3-直接内存的释放原理" class="headerlink" title="6.3 直接内存的释放原理"></a>6.3 直接内存的释放原理</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 禁用显式回收对直接内存的影响</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1_26</span> </span>&#123;
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> _1Gb = <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;

    <span class="hljs-comment">/*</span>
<span class="hljs-comment">     * -XX:+DisableExplicitGC 显式的</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;
        ByteBuffer byteBuffer = ByteBuffer.allocateDirect(_1Gb);
        System.out.println(<span class="hljs-string">&quot;分配完毕...&quot;</span>);
        System.in.read();
        System.out.println(<span class="hljs-string">&quot;开始释放...&quot;</span>);
        byteBuffer = <span class="hljs-keyword">null</span>;
        System.gc(); <span class="hljs-comment">// 显式的垃圾回收，Full GC</span>
        System.in.read();
    &#125;
&#125;</code></pre></div>

<p>运行后</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210316082205.png" srcset="/img/loading.gif" alt="分配"></p>
<p>敲回车后</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210316082251.png" srcset="/img/loading.gif" alt="结束"></p>
<blockquote>
<p>为什么这里垃圾回收会直接导致直接内存被回收掉？</p>
</blockquote>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 直接内存分配的底层原理：Unsafe</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1_27</span> </span>&#123;
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> _1Gb = <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;
        Unsafe unsafe = getUnsafe();
        <span class="hljs-comment">// 分配内存 base返回的是直接内存的地址</span>
        <span class="hljs-keyword">long</span> base = unsafe.allocateMemory(_1Gb);
        unsafe.setMemory(base, _1Gb, (<span class="hljs-keyword">byte</span>) <span class="hljs-number">0</span>);
        System.in.read();

        <span class="hljs-comment">// 释放内存</span>
        unsafe.freeMemory(base);
        System.in.read();
    &#125;
    <span class="hljs-comment">// 反射得到unsafe对象</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Unsafe <span class="hljs-title">getUnsafe</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">try</span> &#123;
            Field f = Unsafe.class.getDeclaredField(<span class="hljs-string">&quot;theUnsafe&quot;</span>);
            f.setAccessible(<span class="hljs-keyword">true</span>);
            Unsafe unsafe = (Unsafe) f.get(<span class="hljs-keyword">null</span>);
            <span class="hljs-keyword">return</span> unsafe;
        &#125; <span class="hljs-keyword">catch</span> (NoSuchFieldException | IllegalAccessException e) &#123;
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);
        &#125;
    &#125;
&#125;</code></pre></div>

<p>直接内存的释放和分配由unsafe对象管理</p>
<p>再分析ByteBuffer源码：</p>
<p>在构造器里就直接构造了一个unsafe对象</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210316083002.png" srcset="/img/loading.gif" alt="unsafe"></p>
<blockquote>
<p>那直接内存又是如何自动释放的呢？</p>
</blockquote>
<ul>
<li>分配和回收原理<ul>
<li>使用了 Unsafe 对象完成直接内存的分配回收，并且回收需要主动调用 freeMemory 方法 </li>
<li>ByteBuffer 的实现类内部，使用了 Cleaner (虚引用)来监测 ByteBuffer 对象，一旦 ByteBuffer 对象被垃圾回收，那么就会由 ReferenceHandler 线程通过 Cleaner 的 clean 方法调 用 freeMemory 来释放直接内存</li>
</ul>
</li>
</ul>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210316083251.png" srcset="/img/loading.gif" alt="任务对象"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210316083323.png" srcset="/img/loading.gif" alt="任务对象实现的run方法"></p>
<p>将来还是得调用unsafe的方法释放内存</p>
<p>Cleaner是一个“虚引用”类型，当关联对象被回收时，回收被关联对象。</p>
<p>上段的源码中，this是指ByteBuffer对象，还是受到JVM管理的，当ByteBuffer被回收时，触发“虚引用”对象中的clean方法，执行任务对象中的run方法</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210316083629.png" srcset="/img/loading.gif" alt="clean"></p>
<p>并且clean不是在主线程被执行，后台有一个referencehandler线程检测“虚引用”对象，一旦虚引用对象所关联的实际对象被回收，他就会调用虚引用对象的clean方法，执行任务对象的run方法。</p>
<div class="hljs"><pre><code class="hljs java">-XX:+DisableExplicitGC 禁用显式的gc</code></pre></div>

<p>让System.gc无效，其是一种显示的代码方式的垃圾回收；是一种FullGC，处理时间很长，所以需要优化。</p>
<p>但会造成直接内存长时间占用；</p>
<p>所以直接内存使用多时，推荐用unsafe来管理直接内存。</p>
<h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><h2 id="1、如何判断对象可以回收"><a href="#1、如何判断对象可以回收" class="headerlink" title="1、如何判断对象可以回收"></a>1、如何判断对象可以回收</h2><h3 id="1-1-引用计数法"><a href="#1-1-引用计数法" class="headerlink" title="1.1 引用计数法"></a>1.1 引用计数法</h3><p>只要对象被引用，计数就加一，不再被引用，计数减一；为0的时候回收；</p>
<p><strong>弊端</strong> ：循环引用</p>
<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210316091521.png" srcset="/img/loading.gif" alt="循环引用" style="zoom:50%;" />

<p>虽然这两个对象都没在使用，但两个计数都是1，不能被回收；早期python使用该方法。</p>
<h3 id="1-2-可达性分析算法"><a href="#1-2-可达性分析算法" class="headerlink" title="1.2 可达性分析算法"></a>1.2 可达性分析算法</h3><p>确定 <strong>根对象</strong>  （肯定不能当成垃圾被垃圾回收的对象）</p>
<ul>
<li>JVM中的垃圾回收器通过 <strong>可达性分析</strong> 来探索所有存活的对象</li>
<li>扫描堆中的对象，看能否沿着 <code>GC Root对象</code>为起点的引用链找到该对象，如果<strong>找不到，则表示可以回收</strong></li>
<li>可以作为 <code>GC Root</code> 的对象<ul>
<li> <code>虚拟机栈（栈帧中的本地变量表）</code> 中引用的对象。　</li>
<li>方法区中 <code>类静态属性引用的对象</code> </li>
<li>方法区中 <code>常量引用的对象</code></li>
<li>本地方法栈中 <code>JNI（即一般说的Native方法）</code> 引用的对象</li>
</ul>
</li>
</ul>
<p>可以使用Memory Analyzer(MAT)来判断GC root</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210501162703.png" srcset="/img/loading.gif"></p>
<p>运行：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo2_2</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException, IOException </span>&#123;
        List&lt;Object&gt; list1 = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
        list1.add(<span class="hljs-string">&quot;a&quot;</span>);
        list1.add(<span class="hljs-string">&quot;b&quot;</span>);
        System.out.println(<span class="hljs-number">1</span>);
        System.in.read();

        list1 = <span class="hljs-keyword">null</span>;
        System.out.println(<span class="hljs-number">2</span>);
        System.in.read();
        System.out.println(<span class="hljs-string">&quot;end...&quot;</span>);
    &#125;
&#125;</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210501163707.png" srcset="/img/loading.gif"></p>
<p>第一个快找是list置为空之前：</p>
<p>让代码执行到2；</p>
<p>再次获取：</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210501163849.png" srcset="/img/loading.gif"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210501163955.png" srcset="/img/loading.gif"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210501164011.png" srcset="/img/loading.gif"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210501164117.png" srcset="/img/loading.gif"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210501164549.png" srcset="/img/loading.gif"></p>
<p>第二种：</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210501164653.png" srcset="/img/loading.gif"></p>
<p>jmap命令带了live参数，会执行一次垃圾回收，所以找不到new的ArrayList了</p>
<h3 id="1-3-四种引用"><a href="#1-3-四种引用" class="headerlink" title="1.3 四种引用"></a>1.3 四种引用</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210501164927.png" srcset="/img/loading.gif"></p>
<p>所有的 <code>实线</code> 为强引用</p>
<ul>
<li>强引用<ul>
<li>只有所有 <code>GC Roots 对象</code>  <strong>都不通过</strong> 【强引用】引用该对象，该对象才能被垃圾回收</li>
</ul>
</li>
<li>软引用（SoftReference）<ul>
<li> <strong>仅有软引用引用</strong> 该对象时，在垃圾回收后，内存仍不足时会再次出发垃圾回收，回收软引用对象</li>
<li>可以配合 <code>引用队列</code> 来 <strong>释放</strong> 软引用 <strong>自身</strong> </li>
</ul>
</li>
<li>弱引用（WeakReference）<ul>
<li> <strong>仅有弱引用引用</strong> 该对象时，在垃圾回收时，无论内存是否充足，都会回收弱引用对象</li>
<li>可以配合 <code>引用队列</code> 来 <strong>释放</strong> 弱引用 <strong>自身</strong> </li>
</ul>
</li>
<li>虚引用（PhantomReference）<ul>
<li><code>必须配合引用队列使用</code> ，主要配合 ByteBuffer 使用，被引用对象回收时，会将虚引用入队，<br>由 Reference Handler 线程调用虚引用相关方法释放直接内存</li>
<li>引用的一个体现是 <strong>释放直接内存所分配的内存</strong> ，当引用的对象ByteBuffer被垃圾回收以后，虚引用对象Cleaner就会被放入引用队列中，然后调用Cleaner的clean方法来释放直接内存</li>
</ul>
</li>
<li>终结器引用（FinalReference）<ul>
<li>无需手动编码，但其 <code>内部配合引用队列使用</code> ，在垃圾回收时，终结器引用入队（被引用对象暂时没有被回收），再由 <code>Finalizer 线程</code> 通过终结器引用找到被引用对象并调用它的 <code>finalize 方法</code> ，第二次 GC 时才能回收被引用对象。</li>
</ul>
</li>
</ul>
<h4 id="软引用例子"><a href="#软引用例子" class="headerlink" title="软引用例子"></a>软引用例子</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo2_3</span> </span>&#123;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _4MB = <span class="hljs-number">4</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;



    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;
        <span class="hljs-comment">/*List&lt;byte[]&gt; list = new ArrayList&lt;&gt;();</span>
<span class="hljs-comment">        for (int i = 0; i &lt; 5; i++) &#123;</span>
<span class="hljs-comment">            list.add(new byte[_4MB]);</span>
<span class="hljs-comment">        &#125;</span>
<span class="hljs-comment"></span>
<span class="hljs-comment">        System.in.read();*/</span>
        soft();


    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">soft</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-comment">// list --&gt; SoftReference --&gt; byte[]</span>

        List&lt;SoftReference&lt;<span class="hljs-keyword">byte</span>[]&gt;&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;
            SoftReference&lt;<span class="hljs-keyword">byte</span>[]&gt; ref = <span class="hljs-keyword">new</span> SoftReference&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[_4MB]);
            System.out.println(ref.get());
            list.add(ref);
            System.out.println(list.size());

        &#125;
        System.out.println(<span class="hljs-string">&quot;循环结束：&quot;</span> + list.size());
        <span class="hljs-keyword">for</span> (SoftReference&lt;<span class="hljs-keyword">byte</span>[]&gt; ref : list) &#123;
            System.out.println(ref.get());
        &#125;
    &#125;
&#125;</code></pre></div>

<p>一开始method1:</p>
<p>首先会设置一个堆内存的大小为 20m，然后运行 mehtod1 方法，会抛异常，堆内存不足，因为 mehtod1 中的 list 都是强引用。</p>
<p>随后修改弱引用：在 list 集合中存放了 软引用对象，当内存不足时，会触发 full gc，将软引用的对象回收。细节如图：</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210501170546.png" srcset="/img/loading.gif"></p>
<p>上面的代码中，当软引用引用的对象被回收了，但是软引用还存在，所以，一般软引用需要搭配一个引用队列一起使用。</p>
<div class="hljs"><pre><code class="hljs java">List&lt;SoftReference&lt;<span class="hljs-keyword">byte</span>[]&gt;&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();

<span class="hljs-comment">// 引用队列</span>
ReferenceQueue&lt;<span class="hljs-keyword">byte</span>[]&gt; queue = <span class="hljs-keyword">new</span> ReferenceQueue&lt;&gt;();

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;
    <span class="hljs-comment">// 关联了引用队列， 当软引用所关联的 byte[]被回收时，软引用自己会加入到 queue 中去</span>
    SoftReference&lt;<span class="hljs-keyword">byte</span>[]&gt; ref = <span class="hljs-keyword">new</span> SoftReference&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[_4MB], queue);
    System.out.println(ref.get());
    list.add(ref);
    System.out.println(list.size());
&#125;

<span class="hljs-comment">// 从队列中获取无用的 软引用对象，并移除</span>
Reference&lt;? extends <span class="hljs-keyword">byte</span>[]&gt; poll = queue.poll();
<span class="hljs-keyword">while</span>( poll != <span class="hljs-keyword">null</span>) &#123;
    list.remove(poll);
    poll = queue.poll();
&#125;

System.out.println(<span class="hljs-string">&quot;===========================&quot;</span>);
<span class="hljs-keyword">for</span> (SoftReference&lt;<span class="hljs-keyword">byte</span>[]&gt; reference : list) &#123;
    System.out.println(reference.get());
&#125;</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210501171044.png" srcset="/img/loading.gif"></p>
<p>弱引用例子类似</p>
<h2 id="2、-垃圾回收算法"><a href="#2、-垃圾回收算法" class="headerlink" title="2、 垃圾回收算法"></a>2、 垃圾回收算法</h2><h3 id="2-1-标记清除"><a href="#2-1-标记清除" class="headerlink" title="2.1 标记清除"></a>2.1 标记清除</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210501173124.png" srcset="/img/loading.gif"></p>
<p> <strong>定义</strong> ：标记清除算法顾名思义，是指在虚拟机执行垃圾回收的过程中，先采用 <code>标记算法</code> 确定可回收对象，然后垃圾收集器根据标识<code>清除</code>相应的内容，给堆内存腾出相应的空间</p>
<ul>
<li>这里的腾出内存空间并 <code>不是将内存空间的字节清0</code> ，而是 <strong>记录下这段内存的起始结束地址</strong> ，下次分配内存的时候，会直接 <strong>覆盖</strong> 这段内存</li>
</ul>
<p> <strong>缺点</strong> ： <strong>容易产生大量的内存碎片</strong> ，可能 <code>无法满足大对象的内存分配</code> ，一旦导致无法分配对象，那就会导致jvm启动gc，一旦启动gc，我们的应用程序就会暂停，这就导致应用的响应速度变慢</p>
<h3 id="2-2-标记整理"><a href="#2-2-标记整理" class="headerlink" title="2.2 标记整理"></a>2.2 标记整理</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210501173345.png" srcset="/img/loading.gif"></p>
<p>标记-整理 会将不被GC Root引用的对象回收，清楚其占用的内存空间。然后整理剩余的对象，可以有效避免因内存碎片而导致的问题，但是因为整体需要消耗一定的时间，所以 <code>效率较低</code></p>
<h3 id="2-3-复制"><a href="#2-3-复制" class="headerlink" title="2.3 复制"></a>2.3 复制</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210501173429.png" srcset="/img/loading.gif"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210501173512.png" srcset="/img/loading.gif"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210501173520.png" srcset="/img/loading.gif"></p>
<p>将内存分为等大小的两个区域，<code>FROM和TO</code>（TO中为空）。先将被GC Root引用的对象从FROM放入TO中，再回收不被GC Root引用的对象。<code>然后交换FROM和TO</code>。这样也可以避免内存碎片的问题，但是会 <code>占用双倍的内存空间</code>。</p>
<h2 id="3、分代垃圾回收"><a href="#3、分代垃圾回收" class="headerlink" title="3、分代垃圾回收"></a>3、分代垃圾回收</h2><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210501173654.png" srcset="/img/loading.gif"></p>
<h3 id="3-1-回收流程"><a href="#3-1-回收流程" class="headerlink" title="3.1 回收流程"></a>3.1 回收流程</h3><p>新创建的对象都被放在了 <strong>新生代的伊甸园</strong> 中</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210501174017.png" srcset="/img/loading.gif"></p>
<p>当伊甸园中的内存不足时，就会进行一次垃圾回收，这时的回收叫做 <strong>Minor GC</strong></p>
<p>Minor GC 会将 <strong>伊甸园和幸存区FROM</strong> 存活的对象 <strong>先</strong> 复制到  <strong>幸存区 TO</strong> 中， 并让其 <strong>寿命加1</strong> ，再 <strong>交换两个幸存区</strong> </p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210501174722.png" srcset="/img/loading.gif"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210501174732.png" srcset="/img/loading.gif"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210501174751.png" srcset="/img/loading.gif"></p>
<p>再次创建对象，若新生代的伊甸园又满了，则会 <strong>再次触发 Minor GC</strong> （会触发  <strong>stop the world</strong> ， 暂停其他用户线程，只让垃圾回收线程工作），这时不仅会回收伊甸园中的垃圾， <strong>还会回收幸存区中的垃圾</strong> ，再将活跃对象复制到幸存区TO中。回收以后会交换两个幸存区，并让幸存区中的对象 <strong>寿命加1</strong> </p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210501175545.png" srcset="/img/loading.gif"></p>
<p>如果幸存区中的对象的 <strong>寿命超过某个阈值</strong> （最大为15，4bit），就会被 <strong>放入老年代</strong> 中</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210501175125.png" srcset="/img/loading.gif"></p>
<p>如果新生代老年代中的内存都满了，就会先触发Minor GC，再触发 <strong>Full GC</strong> ，扫描 <strong>新生代和老年代中</strong> 所有不再使用的对象并回收 STW</p>
<h3 id="3-2-VM参数"><a href="#3-2-VM参数" class="headerlink" title="3.2 VM参数"></a>3.2 VM参数</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210501180051.png" srcset="/img/loading.gif"></p>
<h3 id="3-3-GC-分析"><a href="#3-3-GC-分析" class="headerlink" title="3.3 GC 分析"></a>3.3 GC 分析</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210501181000.png" srcset="/img/loading.gif"></p>
<p>当遇到一个<strong>较大的对象</strong>时，就算新生代的<strong>伊甸园</strong>为空，也<strong>无法容纳该对象</strong>时，会将该对象<strong>直接晋升为老年代</strong></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210501181231.png" srcset="/img/loading.gif"></p>
<p>误区：别的线程的OOM不会影响main线程的运行</p>
<h2 id="4、垃圾回收器"><a href="#4、垃圾回收器" class="headerlink" title="4、垃圾回收器"></a>4、垃圾回收器</h2><h3 id="4-1-相关概念"><a href="#4-1-相关概念" class="headerlink" title="4.1 相关概念"></a>4.1 相关概念</h3><p> <strong>并行收集</strong> ：指多条垃圾收集线程并行工作，但此时 <strong>用户线程仍处于等待状态</strong> 。</p>
<p> <strong>并发收集</strong> ：指用户线程与垃圾收集线程 <strong>同时工作</strong> （不一定是并行的可能会交替执行）。 <strong>用户程序在继续运行</strong> ，而垃圾收集程序运行在另一个CPU上</p>
<p> <strong>吞吐量</strong> ：即CPU用于 <strong>运行用户代码的时间</strong> 与CPU <strong>总消耗时间</strong> 的比值（吞吐量 = 运行用户代码时间 / ( 运行用户代码时间 + 垃圾收集时间 )），也就是。例如：虚拟机共运行100分钟，垃圾收集器花掉1分钟，那么吞吐量就是99%</p>
<h3 id="4-2-串行"><a href="#4-2-串行" class="headerlink" title="4.2 串行"></a>4.2 串行</h3><p>底层是单线程</p>
<ul>
<li>单线程</li>
<li>内存较小，个人电脑（CPU核数较少）</li>
</ul>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210501182119.png" srcset="/img/loading.gif"></p>
<p> <strong>安全点</strong> ：让其他线程都在这个点停下来，以免垃圾回收时移动对象地址，使得其他线程找不到被移动的对象</p>
<p>因为是串行的，所以只有一个垃圾回收线程。且在该线程执行回收工作时，其他线程进入 <strong>阻塞</strong> 状态</p>
<h4 id="Serial-收集器"><a href="#Serial-收集器" class="headerlink" title="Serial 收集器"></a>Serial 收集器</h4><p>Serial收集器是最基本的、发展历史最悠久的收集器</p>
<p> <strong>特点：</strong> 单线程、简单高效（与其他收集器的单线程相比），采用 <strong>复制算法</strong> 。对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程手机效率。收集器进行垃圾回收时，必须暂停其他所有的工作线程，直到它结束（Stop The World）</p>
<h4 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a>ParNew 收集器</h4><p>ParNew收集器其实就是Serial收集器的多线程版本</p>
<p> <strong>特点</strong> ：多线程、ParNew收集器默认开启的收集线程数与CPU的数量相同，在CPU非常多的环境中，可以使用-XX:ParallelGCThreads参数来限制垃圾收集的线程数。和Serial收集器一样存在Stop The World问题</p>
<h4 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h4><p>Serial Old是Serial收集器的老年代版本</p>
<p> <strong>特点</strong> ：同样是单线程收集器，采用 <strong>标记-整理算法</strong> </p>
<h3 id="4-3-吞吐量优先"><a href="#4-3-吞吐量优先" class="headerlink" title="4.3 吞吐量优先"></a>4.3 吞吐量优先</h3><ul>
<li>多线程</li>
<li>堆内存较大，多核CPU</li>
<li> <strong>单位时间内</strong> ，STW（stop the world，停掉其他所有工作线程）时间最短</li>
<li> <strong>JDK1.8默认使用</strong> 的垃圾回收器</li>
</ul>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210501183102.png" srcset="/img/loading.gif"></p>
<p>1和4 ：动态调整伊甸园和幸存区比例 和 gc线程大小</p>
<p>2和3：根据吞吐量目标尝试调整堆大小（1/1+ratio） 和 根据垃圾回收暂停时间目标调整堆大小</p>
<h4 id="Parallel-Scavenge-收集器"><a href="#Parallel-Scavenge-收集器" class="headerlink" title="Parallel Scavenge 收集器"></a>Parallel Scavenge 收集器</h4><p>与吞吐量关系密切，故也称为吞吐量优先收集器</p>
<p> <strong>特点</strong> ：属于新生代收集器也是采用 <strong>复制算法</strong> 的收集器（用到了新生代的幸存区），又是并行的多线程收集器（与ParNew收集器类似）</p>
<p>该收集器的目标是达到一个可控制的吞吐量。还有一个值得关注的点是： <strong>GC自适应调节策略</strong> （与ParNew收集器最重要的一个区别）</p>
<p> <strong>GC自适应调节策略</strong> ：Parallel Scavenge收集器可设置-XX:+UseAdptiveSizePolicy参数。当开关打开时 <strong>不需要</strong> 手动指定新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX:SurvivorRation）、晋升老年代的对象年龄（-XX:PretenureSizeThreshold）等，虚拟机会根据系统的运行状况收集性能监控信息，动态设置这些参数以提供最优的停顿时间和最高的吞吐量，这种调节方式称为GC的自适应调节策略。</p>
<p>Parallel Scavenge收集器使用两个参数控制吞吐量：</p>
<ul>
<li>XX:MaxGCPauseMillis 控制最大的垃圾收集停顿时间</li>
<li>XX:GCRatio 直接设置吞吐量的大小</li>
</ul>
<h4 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a><strong>Parallel Old 收集器</strong></h4><p>是Parallel Scavenge收集器的老年代版本</p>
<p><strong>特点</strong>：多线程，采用<strong>标记-整理算法</strong>（老年代没有幸存区）</p>
<h4 id="响应时间优先"><a href="#响应时间优先" class="headerlink" title="响应时间优先"></a>响应时间优先</h4><ul>
<li>多线程</li>
<li>堆内存较大，多核CPU</li>
<li>尽可能让 <strong>单次STW时间变短</strong> （尽量不影响其他线程运行）</li>
</ul>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210501183233.png" srcset="/img/loading.gif"></p>
<p>2参数表示并行、并发执行gc线程数（并发一般1/4的并行，比如说1个gc，3个工作）</p>
<p>3参数因为运行时也可能产生垃圾，所以不能等到内存满了再gc，所以需要预留空间，参数为预留空间数（百分之六十五左右）</p>
<p>4参数重新标记阶段有可能新生代对象可能会引用老年代对象，所以需要扫描整个堆，这样性能影响大，设置参数可以重新标记前对新生代进行gc一次，再扫描；</p>
<h4 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h4><p>Concurrent Mark Sweep，一种以获取 <strong>最短回收停顿时间</strong> 为目标的 <strong>老年代</strong> 收集器</p>
<p> <strong>特点</strong> ：基于 <strong>标记-清除算法</strong> 实现。并发收集、低停顿，但是会产生内存碎片</p>
<p> <strong>应用场景</strong> ：适用于注重服务的响应速度，希望系统停顿时间最短，给用户带来更好的体验等场景下。如web程序、b/s服务</p>
<p> <strong>CMS收集器的运行过程分为下列4步：</strong> </p>
<p> <strong>初始标记</strong> ：标记GC Roots能直接到的对象。速度很快但是 <strong>仍存在Stop The World问题</strong> </p>
<p> <strong>并发标记</strong> ：进行GC Roots Tracing 的过程，找出存活对象且用户线程可并发执行</p>
<p> <strong>重新标记</strong> ：为了 <strong>修正并发标记期间</strong> 因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录。仍然存在Stop The World问题</p>
<p> <strong>并发清除</strong> ：对标记的对象进行清除回收（运行时候也可能产生垃圾，要等到下一次；所以需要预留空间）</p>
<p>CMS收集器的内存回收过程是与用户线程一起 <strong>并发执行</strong> 的，可以搭配 ParNew 收集器（多线程，新生代，复制算法）与 Serial Old 收集器（单线程，老年代，标记-整理算法）使用。</p>
<h3 id="4-4-G1"><a href="#4-4-G1" class="headerlink" title="4.4 G1"></a>4.4 G1</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>Garbage First</p>
<p>2004 论文发布<br>2009 JDK 6u14 体验<br>2012 JDK 7u4 官方支持<br>2017 JDK 9 默认</p>
<p>JDK 9以后默认使用，而且替代了CMS 收集器，也是并发的</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210501191028.png" srcset="/img/loading.gif"></p>
<p>适用场景：</p>
<ul>
<li>同时注重吞吐量和低延迟（响应时间），（Throughput）和（Low latency），默认的暂停目标是 200 ms</li>
<li>超大堆内存（内存大的），会将堆内存划分为多个<strong>大小相等</strong>的区域 <code>Region</code> </li>
<li>整体上是 <strong>标记-整理</strong> 算法，两个区域之间是 <strong>复制</strong> 算法</li>
</ul>
<p> <strong>相关参数</strong> ：JDK8 并不是默认开启的，所需要参数开启</p>
<div class="hljs"><pre><code class="hljs java">-XX:+UseG1GC
-XX:G1HeapRegionSize=size <span class="hljs-comment">// 区域大小 1 2 4 8 16.....</span>
-XX:MaxGCPauseMillis=time <span class="hljs-comment">// 设置暂停目标</span></code></pre></div>



<h4 id="1-垃圾回收阶段"><a href="#1-垃圾回收阶段" class="headerlink" title="1) 垃圾回收阶段"></a>1) 垃圾回收阶段</h4><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210501191227.png" srcset="/img/loading.gif" alt="img" style="zoom:50%;" />

<p>Young Collection：对<code>新生代</code>垃圾收集<br>Young Collection + Concurrent Mark：如果<code>老年代</code>内存到达一定的阈值了，新生代垃圾收集同时会执行一些并发的<code>标记</code>。<br>Mixed Collection：会对<code>新生代 + 老年代 + 幸存区</code>等进行混合收集，然后收集结束，会<code>重新进入新生代收集</code>。</p>
<h4 id="2-Young-Collection"><a href="#2-Young-Collection" class="headerlink" title="2) Young Collection"></a>2) Young Collection</h4><p> <strong>分区算法region</strong> </p>
<p>分代是按对象的生命周期划分，分区则是将堆空间划分连续几个不同小区间，每一个小区间独立回收，可以控制一次回收多少个小区间，方便控制 GC 产生的停顿时间</p>
<p>E：伊甸园 S：幸存区 O：老年代</p>
<ul>
<li><p>会STW</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210502165809.png" srcset="/img/loading.gif"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210502165921.png" srcset="/img/loading.gif"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210502165845.png" srcset="/img/loading.gif"></p>
</li>
</ul>
<h4 id="3-Young-Collection-CM"><a href="#3-Young-Collection-CM" class="headerlink" title="3) Young Collection + CM"></a>3) Young Collection + CM</h4><p>CM指的是并发标记</p>
<ul>
<li>在 Young GC 时会 <strong>对 GC Root 进行初始标记</strong>  （标记根对象，并发指的是从根出发找到）</li>
<li>在老年代 <strong>占用堆内存的比例</strong> 达到阈值时，对进行并发标记 <code>（不会STW）</code>，阈值可以根据用户来进行设定</li>
</ul>
<div class="hljs"><pre><code class="hljs java">XX:InitiatingHeapOccupancyPercent=percent （默认<span class="hljs-number">45</span>%）</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210502170242.png" srcset="/img/loading.gif"></p>
<h4 id="4-Mixed-Collection"><a href="#4-Mixed-Collection" class="headerlink" title="4) Mixed Collection"></a>4) Mixed Collection</h4><p>会对E S O 进行 <strong>全面的回收</strong> </p>
<ul>
<li>最终标记 （Remark）会STW</li>
<li> <strong>拷贝</strong> 存活 （Evacuation）会STW</li>
</ul>
<div class="hljs"><pre><code class="hljs java">-XX:MaxGCPauseMills:xxx 用于指定最长的停顿时间</code></pre></div>

<p> <strong>问</strong> ：为什么有的老年代被拷贝了，有的没拷贝？</p>
<p>因为指定了最大停顿时间，如果对所有老年代都进行回收，耗时可能过高。为了保证时间不超过设定的停顿时间，会 <strong>回收最有价值的老年代</strong> （回收后，能够得到更多内存）</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210502170445.png" srcset="/img/loading.gif"></p>
<h4 id="5-Full-GC"><a href="#5-Full-GC" class="headerlink" title="5) Full GC"></a>5) Full GC</h4><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210502170927.png" srcset="/img/loading.gif"></p>
<p>串行和并行老年代full gc</p>
<p>CMS和G1在老年代内存不足时（老年代所占内存超过阈值）</p>
<ul>
<li>如果垃圾产生速度慢于垃圾回收速度，不会触发Full GC，还是并发地进行清理</li>
<li>如果垃圾产生速度快于垃圾回收速度，便会触发Full GC</li>
</ul>
<h4 id="6-Young-Collection-跨代引用"><a href="#6-Young-Collection-跨代引用" class="headerlink" title="6) Young Collection 跨代引用"></a>6) Young Collection 跨代引用</h4><ul>
<li><p>新生代回收的 <code>跨代引用</code> （老年代引用新生代）问题</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210502170759.png" srcset="/img/loading.gif"></p>
</li>
<li><p>卡表与 <code>Remembered Set</code></p>
<ul>
<li>Remembered Set 存在于E中，用于保存新生代对象对应的脏卡<ul>
<li>脏卡：O被划分为多个区域（一个区域512K），如果该区域引用了新生代对象，则该区域被称为脏卡</li>
</ul>
</li>
</ul>
</li>
<li><p>在引用变更时通过post-write barried (写屏障) + dirty card queue（脏卡队列）</p>
</li>
<li><p>concurrent refinement threads （脏卡更新线程）更新 Remembered Set</p>
</li>
</ul>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210502171127.png" srcset="/img/loading.gif"></p>
<h4 id="6-重新标记-Remark"><a href="#6-重新标记-Remark" class="headerlink" title="6) 重新标记 Remark"></a>6) 重新标记 Remark</h4><p>重新标记阶段</p>
<p>在垃圾回收时，收集器处理对象的过程中</p>
<ul>
<li><p>pre-write barrier + satb_mark_queue</p>
</li>
<li><p>并发标记时，对象处理状态</p>
<p>黑色：已被处理，需要保留的 ，与引用在引用他们</p>
<p>灰色：正在处理中的，最终还有引用，则变黑</p>
<p>白色：还未处理的，最后有引用的存活，没有则回收</p>
</li>
</ul>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210502171930.png" srcset="/img/loading.gif"></p>
<p>但是在 <strong>并发标记过程中</strong> ，有可能A被处理了以后未引用C，但该处理过程还未结束，在处理过程结束之前A引用了C，这时就会用到remark</p>
<p>过程如下</p>
<ul>
<li>之前C未被引用，这时A引用了C(对象引用发生改变)，就会给C加一个写屏障，写屏障的指令会被执行，将C放入一个队列当中，并将C变为 <code>处理中</code> 状态 (灰色)</li>
</ul>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210502172327.png" srcset="/img/loading.gif"></p>
<ul>
<li>在 <strong>并发标记</strong> 阶段结束以后，重新标记阶段会STW，然后将放在该队列中的对象 <code>重新处理</code> ，发现有强引用引用它，就会处理它(变黑)</li>
</ul>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210502172151.png" srcset="/img/loading.gif"></p>
<h4 id="7-JDK-8u20-字符串去重"><a href="#7-JDK-8u20-字符串去重" class="headerlink" title="7) JDK 8u20 字符串去重"></a>7) JDK 8u20 字符串去重</h4><p><code>过程</code> </p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210502172841.png" srcset="/img/loading.gif"></p>
<ul>
<li>将所有新分配的字符串（底层是char[]）放入一个队列</li>
<li>当 <code>新生代回收时</code> ，G1并发检查是否有重复的字符串</li>
<li>如果字符串的值一样，就让他们 <strong>引用同一个字符串对象</strong> </li>
<li>注意，其与String.intern的区别<ul>
<li><code>intern</code>关注的是 <code>字符串对象</code></li>
<li><code>字符串去重</code> 关注的是 <code>char[]</code> </li>
<li>在JVM内部，使用了 <code>不同的字符串标</code></li>
</ul>
</li>
</ul>
<p><code>优点与缺点</code> </p>
<ul>
<li>节省了大量内存</li>
<li>新生代回收时间略微增加，导致略微多占用CPU</li>
</ul>
<div class="hljs"><pre><code class="hljs java">-XX:+UseStringDeduplication</code></pre></div>



<h4 id="8-JDK-8u40-并发标记类卸载"><a href="#8-JDK-8u40-并发标记类卸载" class="headerlink" title="8) JDK 8u40 并发标记类卸载"></a>8) JDK 8u40 并发标记类卸载</h4><p>在 <code>并发标记阶段结束以后</code> ，就能知道哪些类不再被使用。如果一个 <code>类加载器的所有类都不在使用</code> ，则卸载它所加载的所有类。</p>
<div class="hljs"><pre><code class="hljs java">-XX:+ClassUnloadingWithConcurrentMark 默认启用</code></pre></div>



<h4 id="9-JDK-8u60-回收巨型对象"><a href="#9-JDK-8u60-回收巨型对象" class="headerlink" title="9) JDK 8u60 回收巨型对象"></a>9) JDK 8u60 回收巨型对象</h4><ul>
<li>一个对象大于region的一半时，就称为 <code>巨型对象</code></li>
<li>G1 <strong>不会对巨型对象进行拷贝</strong> </li>
<li>回收时 <strong>被优先考虑</strong> </li>
<li>G1会跟踪老年代所有incoming引用，如果老年代incoming引用为0的巨型对象就可以在新生代垃圾回收时处理掉</li>
</ul>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210502173510.png" srcset="/img/loading.gif"></p>
<h4 id="10-JDK-9-并发标记起始时间的调整"><a href="#10-JDK-9-并发标记起始时间的调整" class="headerlink" title="10) JDK 9 并发标记起始时间的调整"></a>10) JDK 9 并发标记起始时间的调整</h4><ul>
<li>并发标记必须在堆空间占满前完成( <code>防止跟不上垃圾产生速度</code> )，否则退化为 FulGC</li>
<li>JDK 9 之前需要使用 -XX:InitiatingHeapOccupancyPercent</li>
<li>JDK 9 可以动态调整<ul>
<li>-XX:InitiatingHeapOccupancyPercent 用来设置初始值</li>
<li>进行数据采样并动态调整</li>
<li>总会添加一个安全的空挡空间</li>
</ul>
</li>
</ul>
<h2 id="5、GC调优"><a href="#5、GC调优" class="headerlink" title="5、GC调优"></a>5、GC调优</h2><h3 id="调优领域"><a href="#调优领域" class="headerlink" title="调优领域"></a>调优领域</h3><ul>
<li>内存</li>
<li>锁竞争</li>
<li>CPU占用</li>
<li>IO</li>
<li>GC</li>
</ul>
<h3 id="确定目标"><a href="#确定目标" class="headerlink" title="确定目标"></a>确定目标</h3><p>低延迟(web)/高吞吐量(科学领域计算)？ 选择合适的GC</p>
<ul>
<li>CMS G1 ZGC （低延迟）</li>
<li>ParallelGC （高吞吐量）</li>
<li>Zing （超低延迟）</li>
</ul>
<h3 id="最快的GC是不发生GC"><a href="#最快的GC是不发生GC" class="headerlink" title="最快的GC是不发生GC"></a>最快的GC是不发生GC</h3><p>首先排除减少因为自身编写的代码而引发的内存问题</p>
<ul>
<li>查看Full GC前后的内存占用，考虑以下几个问题<ul>
<li>数据是不是太多？</li>
<li>数据表示是否太臃肿<ul>
<li>对象图</li>
<li>对象大小</li>
</ul>
</li>
<li>是否存在内存泄漏</li>
</ul>
</li>
</ul>
<h3 id="新生代调优"><a href="#新生代调优" class="headerlink" title="新生代调优"></a>新生代调优</h3><ul>
<li><p>新生代的特点</p>
<ul>
<li>所有的new操作分配内存都是非常廉价的<ul>
<li>TLAB thread-local allocation buffer</li>
<li>每个线程用线程私有的伊甸园区</li>
</ul>
</li>
<li>死亡对象回收零代价</li>
<li>大部分对象用过即死（朝生夕死）</li>
<li>MInor GC 所用时间远小于Full GC</li>
</ul>
</li>
<li><p>新生代内存越大越好么？</p>
<ul>
<li><p>不是</p>
<ul>
<li><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210503165355.png" srcset="/img/loading.gif"></li>
<li>新生代内存太小：频繁触发Minor GC，会STW，会使得吞吐量下降</li>
<li>新生代内存太大：老年代内存占比有所降低，会更频繁地触发Full GC。而且触发Minor GC时，清理新生代所花费的时间会更长</li>
</ul>
</li>
<li><p>新生代内存设置能容纳 <code>[并发量*(请求-响应)]</code> 的数据为宜</p>
</li>
<li><p>晋升阈值配置得当，让长时间存活对象尽快晋升</p>
</li>
</ul>
</li>
</ul>
<h3 id="幸存区调优"><a href="#幸存区调优" class="headerlink" title="幸存区调优"></a>幸存区调优</h3><ul>
<li>幸存区需要能够保存 <strong>当前活跃对象</strong>+<strong>需要晋升的对象</strong></li>
<li>晋升阈值配置得当，让长时间存活的对象尽快晋升</li>
</ul>
<h3 id="老年代调优"><a href="#老年代调优" class="headerlink" title="老年代调优"></a>老年代调优</h3><p>以 CMS 为例</p>
<ul>
<li>CMS 的老年代内存越大越好（避免浮动垃圾产生并发失败）</li>
<li>先尝试不做调优，如果没有 Full GC 那么已经…，否则先尝试调优新生代</li>
<li>观察发生 Full GC 时老年代内存占用，将老年代内存预设调大 1/4 ~ 1/3<br>-XX:CMSInitiatingOccupancyFraction=percent</li>
</ul>
<h3 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h3><ul>
<li>案例1 Full GC 和 Minor GC频繁<ul>
<li>可能是新生代太小，增大空间，再让阈值提高</li>
</ul>
</li>
<li>案例2 请求高峰期发生 Full GC，单次暂停时间特别长 （CMS）<ul>
<li>比较慢的在 <code>重新标记</code> （会扫描整个堆内存），定位重新标记</li>
<li>在重新标记前把一些新生代的对象回收一下</li>
</ul>
</li>
<li>案例3 老年代充裕情况下，发生 Full GC （CMS jdk1.7）<ul>
<li>jdk1.8有元空间，以前是永久代</li>
</ul>
</li>
</ul>
<h1 id="类加载和字节码技术"><a href="#类加载和字节码技术" class="headerlink" title="类加载和字节码技术"></a>类加载和字节码技术</h1><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504100558.png" srcset="/img/loading.gif"></p>
<h2 id="1、类文件结构"><a href="#1、类文件结构" class="headerlink" title="1、类文件结构"></a>1、类文件结构</h2><p>一个简单的 HelloWorld.java</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// 二进制字节码（类基本信息，常量池，类方法定义，包含了虚拟机指令）</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorld</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;hello world&quot;</span>);
    &#125;
&#125;</code></pre></div>

<p>执行 <code>javac -parameters -d . HelloWorld.java</code></p>
<p>parameters会保留方法中参数的名称信息，编译为 HelloWorld.class 后是这个样子的：</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504101314.png" srcset="/img/loading.gif"></p>
<p>od -t xC HelloWorld.class </p>
<p>根据JVM规范， <strong>类文件结构</strong> 如下</p>
<div class="hljs"><pre><code class="hljs java">ClassFile&#123;
    u4             magic
    u2             minor_version;    
    u2             major_version;    
    u2             constant_pool_count;     <span class="hljs-comment">// 常量池信息</span>
    cp_info        constant_pool[constant_pool_count-<span class="hljs-number">1</span>];    
    u2             access_flags;    <span class="hljs-comment">// 访问修饰（公共、私有）</span>
    u2             this_class;    <span class="hljs-comment">// 包名类名</span>
    u2             super_class;   <span class="hljs-comment">// 父类信息</span>
    u2             interfaces_count;     <span class="hljs-comment">// 接口信息</span>
    u2             interfaces[interfaces_count];   
    u2             fields_count;    <span class="hljs-comment">// 成员、静态变量信息</span>
    field_info     fields[fields_count];   
    u2             methods_count;    <span class="hljs-comment">// 成员、静态方法信息</span>
    method_info    methods[methods_count];    
    u2             attributes_count;    <span class="hljs-comment">// 附加属性信息</span>
    attribute_info attributes[attributes_count];
&#125;</code></pre></div>

<h3 id="魔数"><a href="#魔数" class="headerlink" title="魔数"></a>魔数</h3><p>u4 magic</p>
<p>对应字节码文件的0~3个字节</p>
<p>0000000  <strong>ca fe ba be</strong>  00 00 00 34 00 23 0a 00 06 00 15 09</p>
<h3 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h3><p>u2 minor_version; 小版本号</p>
<p>u2 major_version; 主版本号</p>
<p>0000000 ca fe ba be  <strong>00 00 00 34</strong>  00 23 0a 00 06 00 15 09</p>
<p>34H = 52，代表JDK8</p>
<h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504102530.png" srcset="/img/loading.gif"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504102543.png" srcset="/img/loading.gif"></p>
<p>具体参考pdf</p>
<h3 id="访问标识和继承信息"><a href="#访问标识和继承信息" class="headerlink" title="访问标识和继承信息"></a>访问标识和继承信息</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504103232.png" srcset="/img/loading.gif"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504103244.png" srcset="/img/loading.gif"></p>
<h3 id="Filed-成员变量"><a href="#Filed-成员变量" class="headerlink" title="Filed 成员变量"></a>Filed 成员变量</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504103500.png" srcset="/img/loading.gif"></p>
<h3 id="Method-信息"><a href="#Method-信息" class="headerlink" title="Method 信息"></a>Method 信息</h3><h4 id="lt-init-gt-函数"><a href="#lt-init-gt-函数" class="headerlink" title="&lt; init &gt; 函数"></a>&lt; init &gt; 函数</h4><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504103811.png" srcset="/img/loading.gif"> </p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504103659.png" srcset="/img/loading.gif"></p>
<p>红色具体分类：</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504103857.png" srcset="/img/loading.gif"></p>
<h4 id="lt-main-gt-函数"><a href="#lt-main-gt-函数" class="headerlink" title="&lt; main &gt;函数"></a>&lt; main &gt;函数</h4><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504105009.png" srcset="/img/loading.gif"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504105036.png" srcset="/img/loading.gif"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504105057.png" srcset="/img/loading.gif"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504105439.png" srcset="/img/loading.gif"></p>
<h3 id="附加属性"><a href="#附加属性" class="headerlink" title="附加属性"></a>附加属性</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504105516.png" srcset="/img/loading.gif"></p>
<p>参考文献<br><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html</a></p>
<h2 id="2、字节码指令"><a href="#2、字节码指令" class="headerlink" title="2、字节码指令"></a>2、字节码指令</h2><h3 id="2-1-入门"><a href="#2-1-入门" class="headerlink" title="2.1 入门"></a>2.1 入门</h3><p>接着上一节，研究一下两组字节码指令，一个是<br><code>public cn.itcast.jvm.t5.HelloWorld()</code> ; 构造方法的字节码指令</p>
<div class="hljs"><pre><code class="hljs js">2a b7 <span class="hljs-number">00</span> <span class="hljs-number">01</span> b1</code></pre></div>

<ol>
<li><p>2a =&gt; aload_0(this) 加载 slot 0 的局部变量，即 this，做为下面的 invokespecial 构造方法调用的参数</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504105925.png" srcset="/img/loading.gif"></p>
</li>
<li><p>b7 =&gt; invokespecial 预备调用构造方法，哪个方法呢？</p>
</li>
<li><p>00 01 引用常量池中 #1 项，即【 Method java/lang/Object.”&lt; init &gt;”:()V 】</p>
</li>
<li><p>b1 表示返回</p>
</li>
</ol>
<p>另一个是 <code>public static void main(java.lang.String[]);</code> 主方法的字节码指令</p>
<div class="hljs"><pre><code class="hljs js">b2 <span class="hljs-number">00</span> <span class="hljs-number">02</span> <span class="hljs-number">12</span> <span class="hljs-number">03</span> b6 <span class="hljs-number">00</span> <span class="hljs-number">04</span> b1</code></pre></div>

<ol>
<li>b2 =&gt; getstatic 用来加载静态变量，哪个静态变量呢？</li>
<li>00 02 引用常量池中 #2 项，即【Field java/lang/System.out:Ljava/io/PrintStream;】</li>
<li>12 =&gt; ldc 加载参数，哪个参数呢？</li>
<li>03 引用常量池中 #3 项，即 【String hello world】</li>
<li>b6 =&gt; invokevirtual 预备调用成员方法，哪个方法呢？</li>
<li>00 04 引用常量池中 #4 项，即【Method java/io/PrintStream.println:(Ljava/lang/String;)V】</li>
<li>b1 表示返回</li>
</ol>
<p>请参考<br><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5</a></p>
<h3 id="2-2-javap-工具"><a href="#2-2-javap-工具" class="headerlink" title="2.2 javap 工具"></a>2.2 javap 工具</h3><p>Oracle 提供了 <strong>javap</strong> 工具来反编译 class 文件</p>
<div class="hljs"><pre><code class="hljs js">javap -v xxx.class</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504110755.png" srcset="/img/loading.gif"></p>
<p>常量池：</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504110837.png" srcset="/img/loading.gif"></p>
<p>方法：</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504111014.png" srcset="/img/loading.gif"></p>
<h3 id="2-3-图解方法执行流程"><a href="#2-3-图解方法执行流程" class="headerlink" title="2.3 图解方法执行流程"></a>2.3 图解方法执行流程</h3><h4 id="1-原始java代码"><a href="#1-原始java代码" class="headerlink" title="1) 原始java代码"></a>1) 原始java代码</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 演示 字节码指令 和 操作数栈、常量池的关系</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3_1</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;
        <span class="hljs-keyword">int</span> b = Short.MAX_VALUE + <span class="hljs-number">1</span>;
        <span class="hljs-keyword">int</span> c = a + b;
        System.out.println(c);
    &#125;
&#125;</code></pre></div>

<h4 id="2-编译后的字节码文件"><a href="#2-编译后的字节码文件" class="headerlink" title="2) 编译后的字节码文件"></a>2) 编译后的字节码文件</h4><div class="hljs"><pre><code class="hljs java">qiukedeMacBook-Pro-<span class="hljs-number">2</span>:class03 qiuke$ javap -v Demo3_1.class 
Classfile /Users/qiuke/Desktop/ideaProject/jvm/src/com/qiuke/jvm/class03/Demo3_1.class
  Last modified <span class="hljs-number">2021</span>-<span class="hljs-number">5</span>-<span class="hljs-number">4</span>; size <span class="hljs-number">454</span> bytes
  MD5 checksum 4d2c98439aed862544493fafae9889f5
  Compiled from <span class="hljs-string">&quot;Demo3_1.java&quot;</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">com</span>.<span class="hljs-title">qiuke</span>.<span class="hljs-title">jvm</span>.<span class="hljs-title">class03</span>.<span class="hljs-title">Demo3_1</span></span>
  minor version: 0
  major version: <span class="hljs-number">52</span>
  flags: ACC_PUBLIC, ACC_SUPER
Constant pool:
   #1 = Methodref          #7.#16         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V
   #2 = Class              #17            // java/lang/Short
   #3 = Integer            32768
   #4 = Fieldref           #18.#19        // java/lang/System.out:Ljava/io/PrintStream;
   #5 = Methodref          #20.#21        // java/io/PrintStream.println:(I)V
   #6 = Class              #22            // com/qiuke/jvm/class03/Demo3_1
   #7 = Class              #23            // java/lang/Object
   #8 = Utf8               &lt;init&gt;
   #9 = Utf8               ()V
  #10 = Utf8               Code
  #11 = Utf8               LineNumberTable
  #12 = Utf8               main
  #13 = Utf8               ([Ljava/lang/String;)V
  #14 = Utf8               SourceFile
  #15 = Utf8               Demo3_1.java
  #16 = NameAndType        #8:#9          // &quot;&lt;init&gt;&quot;:()V
  #17 = Utf8               java/lang/Short
  #18 = Class              #24            // java/lang/System
  #19 = NameAndType        #25:#26        // out:Ljava/io/PrintStream;
  #20 = Class              #27            // java/io/PrintStream
  #21 = NameAndType        #28:#29        // println:(I)V
  #22 = Utf8               com/qiuke/jvm/class03/Demo3_1
  #23 = Utf8               java/lang/Object
  #24 = Utf8               java/lang/System
  #25 = Utf8               out
  #26 = Utf8               Ljava/io/PrintStream;
  #27 = Utf8               java/io/PrintStream
  #28 = Utf8               println
  #29 = Utf8               (I)V
&#123;
  <span class="hljs-keyword">public</span> com.qiuke.jvm.class03.Demo3_1();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">1</span>, args_size=<span class="hljs-number">1</span>
         <span class="hljs-number">0</span>: aload_0
         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V
         <span class="hljs-number">4</span>: <span class="hljs-keyword">return</span>
      LineNumberTable:
        line <span class="hljs-number">6</span>: <span class="hljs-number">0</span>

  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(java.lang.String[])</span></span>;
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">4</span>, args_size=<span class="hljs-number">1</span>
         <span class="hljs-number">0</span>: bipush        <span class="hljs-number">10</span>
         <span class="hljs-number">2</span>: istore_1
         3: ldc           #3                  // int 32768
         <span class="hljs-number">5</span>: istore_2
         <span class="hljs-number">6</span>: iload_1
         <span class="hljs-number">7</span>: iload_2
         <span class="hljs-number">8</span>: iadd
         <span class="hljs-number">9</span>: istore_3
        10: getstatic     #4                  // Field java/lang/System.out:Ljava/io/PrintStream;
        <span class="hljs-number">13</span>: iload_3
        14: invokevirtual #5                  // Method java/io/PrintStream.println:(I)V
        <span class="hljs-number">17</span>: <span class="hljs-keyword">return</span>
      LineNumberTable:
        line <span class="hljs-number">8</span>: <span class="hljs-number">0</span>
        line <span class="hljs-number">9</span>: <span class="hljs-number">3</span>
        line <span class="hljs-number">10</span>: <span class="hljs-number">6</span>
        line <span class="hljs-number">11</span>: <span class="hljs-number">10</span>
        line <span class="hljs-number">12</span>: <span class="hljs-number">17</span>
&#125;
SourceFile: <span class="hljs-string">&quot;Demo3_1.java&quot;</span>
</code></pre></div>

<h4 id="3-常量池加载入运行时常量池"><a href="#3-常量池加载入运行时常量池" class="headerlink" title="3) 常量池加载入运行时常量池"></a>3) 常量池加载入运行时常量池</h4><p>运行时常量池也属于方法区，只不过这里单独提出来了</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504112138.png" srcset="/img/loading.gif"></p>
<p>范围内跟随方法的字节码指令存在一起，一旦超过了数值范围，存储在常量池中。</p>
<h4 id="4-方法字节码载入方法区"><a href="#4-方法字节码载入方法区" class="headerlink" title="4) 方法字节码载入方法区"></a>4) 方法字节码载入方法区</h4><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504112613.png" srcset="/img/loading.gif"></p>
<h4 id="5-main-线程开始运行，分配栈帧内存"><a href="#5-main-线程开始运行，分配栈帧内存" class="headerlink" title="5) main 线程开始运行，分配栈帧内存"></a>5) main 线程开始运行，分配栈帧内存</h4><p>（stack=2，locals=4） 对应操作数栈有2个空间（每个空间4个字节），局部变量表中有4个槽位</p>
<p>绿色局部变量表，蓝色操作数栈</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504112539.png" srcset="/img/loading.gif"></p>
<h4 id="6-执行引擎开始执行字节码"><a href="#6-执行引擎开始执行字节码" class="headerlink" title="6) 执行引擎开始执行字节码"></a>6) 执行引擎开始执行字节码</h4><p> <strong>bipush 10</strong> </p>
<ul>
<li><p>将一个 <code>byte</code> 压入操作数栈</p>
<p>（其长度会<code>补齐 4 个字节</code>），类似的指令还有</p>
<ul>
<li>sipush 将一个 short 压入操作数栈（其长度会补齐 4 个字节）</li>
<li>ldc 将一个 int 压入操作数栈</li>
<li>ldc2_w 将一个 long 压入操作数栈（ <strong>分两次压入</strong> ，因为 long 是 8 个字节）</li>
<li>这里小的数字都是和字节码指令存在一起， <strong>超过 short 范围的数字存入了常量池</strong> </li>
</ul>
</li>
</ul>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504112934.png" srcset="/img/loading.gif"></p>
<p> <strong>istore 1</strong> </p>
<p>将<code>操作数栈栈顶元素弹出，放入局部变量表的slot 1</code>中</p>
<p>对应代码中的</p>
<div class="hljs"><pre><code class="hljs java">a = <span class="hljs-number">10</span></code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504113100.png" srcset="/img/loading.gif"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504113112.png" srcset="/img/loading.gif"></p>
<p> <strong>ldc #3</strong> </p>
<ul>
<li>读取运行时常量池中#3，即32768(超过short最大值范围的数会被放到运行时常量池中)，将其加载到<code>操作数栈中</code></li>
<li>注意 Short.MAX_VALUE 是 32767，所以 32768 = Short.MAX_VALUE + 1 实际是在编译期间计算好的</li>
</ul>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504113840.png" srcset="/img/loading.gif"></p>
<p> <strong>istore 2</strong> </p>
<p>将操作数栈中的元素弹出，放到局部变量表的2号位置</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504113904.png" srcset="/img/loading.gif"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504113917.png" srcset="/img/loading.gif"></p>
<p> <strong>iload1 iload2</strong> </p>
<p>将局部变量表中1号位置和2号位置的元素放入操作数栈中</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">int</span> c = a + b</code></pre></div>



<ul>
<li>因为只能在操作数栈中执行运算操作</li>
</ul>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504114024.png" srcset="/img/loading.gif"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504114049.png" srcset="/img/loading.gif"></p>
<p> <strong>iadd</strong> </p>
<p>将操作数栈中的两个元素 <strong>弹出栈</strong> 并相加，结果在压入操作数栈中</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504114130.png" srcset="/img/loading.gif"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504114141.png" srcset="/img/loading.gif"></p>
<p> <strong>istore 3</strong> </p>
<p>将操作数栈中的元素弹出，放入局部变量表的3号位置</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504114211.png" srcset="/img/loading.gif"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504114220.png" srcset="/img/loading.gif"></p>
<p> <strong>getstatic #4</strong> </p>
<p>在运行时常量池中找到#4，发现是一个对象</p>
<p>在堆内存中找到该对象，并将其 <strong>引用</strong> 放入操作数栈中</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504114256.png" srcset="/img/loading.gif"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504114307.png" srcset="/img/loading.gif"></p>
<p> <strong>iload 3</strong> </p>
<p>将局部变量表中3号位置的元素压入操作数栈中</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504114343.png" srcset="/img/loading.gif"></p>
<p> <strong>invokevirtual 5</strong> </p>
<p>找到常量池 #5 项，定位到<code>方法区 java/io/PrintStream.println:(I)V 方法</code></p>
<p>生成新的栈帧（分配 locals、stack等）</p>
<p>传递参数，执行新栈帧中的字节码</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504114542.png" srcset="/img/loading.gif"></p>
<p>执行完毕，弹出栈帧</p>
<p>清除 main 操作数栈内容</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504114628.png" srcset="/img/loading.gif"></p>
<p> <strong>return</strong><br>完成 main 方法调用，弹出 main 栈帧，程序结束</p>
<h3 id="2-4-分析a"><a href="#2-4-分析a" class="headerlink" title="2.4 分析a++"></a>2.4 分析a++</h3><h4 id="1-代码"><a href="#1-代码" class="headerlink" title="1) 代码"></a>1) 代码</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 从字节码角度分析　a++  相关题目</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3_2</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;
        <span class="hljs-keyword">int</span> b = a++ + ++a + a--;
        System.out.println(a);
        System.out.println(b);
    &#125;
&#125;</code></pre></div>

<h4 id="2-字节码"><a href="#2-字节码" class="headerlink" title="2) 字节码"></a>2) 字节码</h4><div class="hljs"><pre><code class="hljs java">Code:
      stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">1</span>
         <span class="hljs-number">0</span>: bipush        <span class="hljs-number">10</span>
         <span class="hljs-number">2</span>: istore_1
         <span class="hljs-number">3</span>: iload_1
         <span class="hljs-number">4</span>: iinc          <span class="hljs-number">1</span>, <span class="hljs-number">1</span>
         <span class="hljs-number">7</span>: iinc          <span class="hljs-number">1</span>, <span class="hljs-number">1</span>
        <span class="hljs-number">10</span>: iload_1
        <span class="hljs-number">11</span>: iadd
        <span class="hljs-number">12</span>: iload_1
        <span class="hljs-number">13</span>: iinc          <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>
        <span class="hljs-number">16</span>: iadd
        <span class="hljs-number">17</span>: istore_2
        18: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;
        <span class="hljs-number">21</span>: iload_1
        22: invokevirtual #3                  // Method java/io/PrintStream.println:(I)V
        25: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;
        <span class="hljs-number">28</span>: iload_2
        29: invokevirtual #3                  // Method java/io/PrintStream.println:(I)V
        <span class="hljs-number">32</span>: <span class="hljs-keyword">return</span>
</code></pre></div>

<h4 id="3-分析"><a href="#3-分析" class="headerlink" title="3) 分析"></a>3) 分析</h4><ul>
<li>注意 iinc 指令是直接在局部变量 slot（<code>局部变量槽位</code>） 上进行运算</li>
<li>a++ 和 ++a 的区别是先执行 iload 还是 先执行 iinc<ul>
<li>a++ 先load再inc，++a先inc再load</li>
</ul>
</li>
</ul>
<p>bipush 10</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504115518.png" srcset="/img/loading.gif"></p>
<p>iStore 1</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504115543.png" srcset="/img/loading.gif"></p>
<p>Iload 1</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504115624.png" srcset="/img/loading.gif"></p>
<p>iinc 1, 1 (对哪个槽位自增，自增多少)；直接在局部变量表中发生</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504115639.png" srcset="/img/loading.gif"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504115714.png" srcset="/img/loading.gif"></p>
<p>发现a++ 和 ++a分别对应</p>
<p>iload_1</p>
<p>iinc 1, 1</p>
<p>iinc 1, 1</p>
<p>iload_ 1</p>
<p>iload_1</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504115947.png" srcset="/img/loading.gif"></p>
<p>iadd</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504120029.png" srcset="/img/loading.gif"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504120046.png" srcset="/img/loading.gif"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504120103.png" srcset="/img/loading.gif"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504120121.png" srcset="/img/loading.gif"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504120139.png" srcset="/img/loading.gif"></p>
<h3 id="2-5-条件判断指令"><a href="#2-5-条件判断指令" class="headerlink" title="2.5 条件判断指令"></a>2.5 条件判断指令</h3><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504120438.png" srcset="/img/loading.gif"></p>
<p>几点说明：</p>
<ul>
<li>byte，short，char 都会按 int 比较，因为操作数栈都是 4 字节</li>
<li>goto 用来进行跳转到指定行号的字节码</li>
</ul>
<blockquote>
<p>以上比较指令中没有 long，float，double 的比较，那么它们要比较怎么办？<br>参考 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html#jvms-6.5.lcmp">https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html#jvms-6.5.lcmp</a></p>
</blockquote>
<h4 id="1-源码"><a href="#1-源码" class="headerlink" title="1) 源码"></a>1) 源码</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3_3</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">if</span>(a == <span class="hljs-number">0</span>) &#123;
            a = <span class="hljs-number">10</span>;
        &#125; <span class="hljs-keyword">else</span> &#123;
            a = <span class="hljs-number">20</span>;
        &#125;
    &#125;
&#125;</code></pre></div>

<h4 id="2-字节码-1"><a href="#2-字节码-1" class="headerlink" title="2) 字节码"></a>2) 字节码</h4><div class="hljs"><pre><code class="hljs java">Code:
  stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">2</span>, args_size=<span class="hljs-number">1</span>
     <span class="hljs-number">0</span>: iconst_0 <span class="hljs-comment">// -1 至 5 之间的数字用iconst</span>
     <span class="hljs-number">1</span>: istore_1
     <span class="hljs-number">2</span>: iload_1
     <span class="hljs-number">3</span>: ifne          <span class="hljs-number">12</span> <span class="hljs-comment">// ！= 0</span>
     <span class="hljs-number">6</span>: bipush        <span class="hljs-number">10</span>
     <span class="hljs-number">8</span>: istore_1
     <span class="hljs-number">9</span>: goto          <span class="hljs-number">15</span>
    <span class="hljs-number">12</span>: bipush        <span class="hljs-number">20</span>
    <span class="hljs-number">14</span>: istore_1
    <span class="hljs-number">15</span>: <span class="hljs-keyword">return</span>
</code></pre></div>



<h3 id="2-6-循环控制指令"><a href="#2-6-循环控制指令" class="headerlink" title="2.6 循环控制指令"></a>2.6 循环控制指令</h3><h4 id="1-源码-1"><a href="#1-源码-1" class="headerlink" title="1) 源码"></a>1) 源码</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3_4</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span> (a &lt; <span class="hljs-number">10</span>) &#123;
            a++;
        &#125;
    &#125;
&#125;</code></pre></div>

<h4 id="2-字节码-2"><a href="#2-字节码-2" class="headerlink" title="2) 字节码"></a>2) 字节码</h4><div class="hljs"><pre><code class="hljs java">Code:
  stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">2</span>, args_size=<span class="hljs-number">1</span>
     <span class="hljs-number">0</span>: iconst_0
     <span class="hljs-number">1</span>: istore_1
     <span class="hljs-number">2</span>: iload_1
     <span class="hljs-number">3</span>: bipush        <span class="hljs-number">10</span>
     <span class="hljs-number">5</span>: if_icmpge     <span class="hljs-number">14</span>
     <span class="hljs-number">8</span>: iinc          <span class="hljs-number">1</span>, <span class="hljs-number">1</span>
    <span class="hljs-number">11</span>: goto          <span class="hljs-number">2</span>
    <span class="hljs-number">14</span>: <span class="hljs-keyword">return</span>
</code></pre></div>

<p>dowhile:</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504121456.png" srcset="/img/loading.gif"></p>
<p>for</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504121538.png" srcset="/img/loading.gif"></p>
<blockquote>
<p>注意<br>比较 while 和 for 的字节码，你发现它们是一模一样的，殊途也能同归</p>
</blockquote>
<h4 id="3-练习-x-0"><a href="#3-练习-x-0" class="headerlink" title="3) 练习 x= 0"></a>3) 练习 x= 0</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3_6_1</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span> (i &lt; <span class="hljs-number">10</span>) &#123;
            x = x++;
            i++;
        &#125;
        System.out.println(x); <span class="hljs-comment">// 0</span>
    &#125;
&#125;</code></pre></div>

<div class="hljs"><pre><code class="hljs java">Code:
     stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">1</span> <span class="hljs-comment">//操作数栈分配2个空间，局部变量表分配3个空间</span>
        <span class="hljs-number">0</span>: iconst_0 <span class="hljs-comment">//准备一个常数0</span>
        <span class="hljs-number">1</span>: istore_1 <span class="hljs-comment">//将常数0放入局部变量表的1号槽位 i=0</span>
        <span class="hljs-number">2</span>: iconst_0 <span class="hljs-comment">//准备一个常数0</span>
        <span class="hljs-number">3</span>: istore_2 <span class="hljs-comment">//将常数0放入局部变量的2号槽位 x=0 </span>
        <span class="hljs-number">4</span>: iload_1    <span class="hljs-comment">//将局部变量表1号槽位的数放入操作数栈中</span>
        <span class="hljs-number">5</span>: bipush        <span class="hljs-number">10</span> <span class="hljs-comment">//将数字10放入操作数栈中，此时操作数栈中有2个数</span>
        <span class="hljs-number">7</span>: if_icmpge     <span class="hljs-number">21</span> <span class="hljs-comment">//比较操作数栈中的两个数，如果下面的数大于上面的数，就跳转到21。这里的比较是将两个数做减法。因为涉及运算操作，所以会将两个数弹出操作数栈来进行运算。运算结束后操作数栈为空</span>
       <span class="hljs-number">10</span>: iload_2    <span class="hljs-comment">//将局部变量2号槽位的数放入操作数栈中，放入的值是0</span>
       <span class="hljs-number">11</span>: iinc          <span class="hljs-number">2</span>, <span class="hljs-number">1</span> <span class="hljs-comment">//将局部变量2号槽位的数加1，自增后，槽位中的值为1</span>
       <span class="hljs-number">14</span>: istore_2 <span class="hljs-comment">//将操作数栈中的数放入到局部变量表的2号槽位，2号槽位的值又变为了0</span>
       <span class="hljs-number">15</span>: iinc          <span class="hljs-number">1</span>, <span class="hljs-number">1</span> <span class="hljs-comment">//1号槽位的值自增1</span>
       <span class="hljs-number">18</span>: goto          <span class="hljs-number">4</span> <span class="hljs-comment">//跳转到第4条指令</span>
       21: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;
       <span class="hljs-number">24</span>: iload_2
       25: invokevirtual #3                  // Method java/io/PrintStream.println:(I)V
       <span class="hljs-number">28</span>: <span class="hljs-keyword">return</span>
</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504122713.png" srcset="/img/loading.gif"></p>
<p>x值先放到操作数栈是0，x在局部变量表自增变成1，但是又把操作数栈的0赋值给了局部变量x，循环完了还是0</p>
<h3 id="2-7-构造方法"><a href="#2-7-构造方法" class="headerlink" title="2.7 构造方法"></a>2.7 构造方法</h3><h4 id="1-lt-cinit-gt-V"><a href="#1-lt-cinit-gt-V" class="headerlink" title="1. &lt; cinit &gt;()V"></a>1. &lt; cinit &gt;()V</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3_8_1</span> </span>&#123;
    
    <span class="hljs-keyword">static</span> &#123;
        i = <span class="hljs-number">20</span>;
    &#125;
 
    <span class="hljs-keyword">static</span> &#123;
        i = <span class="hljs-number">30</span>;
    
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span>;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        System.out.println(Demo3_8_1.i);
    &#125;
&#125;</code></pre></div>

<p>编译器会按<code>从上至下的顺序</code>，收集所有 static 静态代码块和静态成员赋值的代码，合并为一个特殊的方<br>法 &lt; cinit &gt;()V ：</p>
<div class="hljs"><pre><code class="hljs java">Code:
  stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">0</span>, args_size=<span class="hljs-number">0</span>
     <span class="hljs-number">0</span>: bipush        <span class="hljs-number">20</span>
     2: putstatic     #3                  // Field i:I
     <span class="hljs-number">5</span>: bipush        <span class="hljs-number">30</span>
     7: putstatic     #3                  // Field i:I
    <span class="hljs-number">10</span>: bipush        <span class="hljs-number">10</span>
    12: putstatic     #3                  // Field i:I
    <span class="hljs-number">15</span>: <span class="hljs-keyword">return</span>
</code></pre></div>

<p>&lt; cinit &gt;()V 方法会在类加载的初始化阶段被调用</p>
<h4 id="2-lt-init-gt-V"><a href="#2-lt-init-gt-V" class="headerlink" title="2. &lt; init &gt;()V"></a>2. &lt; init &gt;()V</h4><p>编译器会按 <strong>从上至下</strong> 的顺序，收集所有 {} 代码块和成员变量赋值的代码，  <strong>形成新的构造方法</strong>  ，但  <strong>原始构造方法</strong>  内的代码 <strong>总是在后</strong> </p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3_8_2</span> </span>&#123;


    <span class="hljs-keyword">private</span> String a = <span class="hljs-string">&quot;s1&quot;</span>;

    &#123;
        b = <span class="hljs-number">20</span>;
    &#125;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> b = <span class="hljs-number">10</span>;

    &#123;
        a = <span class="hljs-string">&quot;s2&quot;</span>;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Demo3_8_2</span><span class="hljs-params">(String a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.a = a;
        <span class="hljs-keyword">this</span>.b = b;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        Demo3_8_2 d = <span class="hljs-keyword">new</span> Demo3_8_2(<span class="hljs-string">&quot;s3&quot;</span>, <span class="hljs-number">30</span>);
        System.out.println(d.a);
        System.out.println(d.b);
    &#125;
&#125;</code></pre></div>

<div class="hljs"><pre><code class="hljs ruby">s3
<span class="hljs-number">30</span></code></pre></div>

<p>生成新的构造，给a赋值s1，给b赋值20，给b赋值10，给a赋值s2，最后执行构造方法this.a = a….</p>
<div class="hljs"><pre><code class="hljs java">Code:
     stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">3</span>
        <span class="hljs-number">0</span>: aload_0
        1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V
        <span class="hljs-number">4</span>: aload_0
        5: ldc           #2                  // String s1
        7: putfield      #3                  // Field a:Ljava/lang/String;
       <span class="hljs-number">10</span>: aload_0
       <span class="hljs-number">11</span>: bipush        <span class="hljs-number">20</span>
       13: putfield      #4                  // Field b:I
       <span class="hljs-number">16</span>: aload_0
       <span class="hljs-number">17</span>: bipush        <span class="hljs-number">10</span>
       19: putfield      #4                  // Field b:I
       <span class="hljs-number">22</span>: aload_0
       23: ldc           #5                  // String s2
       25: putfield      #3                  // Field a:Ljava/lang/String;
       <span class="hljs-comment">//原始构造方法在最后执行</span>
       <span class="hljs-number">28</span>: aload_0
       <span class="hljs-number">29</span>: aload_1
       30: putfield      #3                  // Field a:Ljava/lang/String;
       <span class="hljs-number">33</span>: aload_0
       <span class="hljs-number">34</span>: iload_2
       35: putfield      #4                  // Field b:I
       <span class="hljs-number">38</span>: <span class="hljs-keyword">return</span>
</code></pre></div>



<h3 id="2-8-方法调用"><a href="#2-8-方法调用" class="headerlink" title="2.8 方法调用"></a>2.8 方法调用</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo5</span> </span>&#123;
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Demo5</span><span class="hljs-params">()</span> </span>&#123;&#125;
  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;&#125;
  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> </span>&#123;&#125;
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span> </span>&#123;&#125;
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test4</span><span class="hljs-params">()</span> </span>&#123;&#125;

  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
    Demo5 demo5 = <span class="hljs-keyword">new</span> Demo5();
    demo5.test1();
    demo5.test2();
    demo5.test3();
    Demo5.test4();
  &#125;
&#125;</code></pre></div>

<p>不同方法在调用时，对应的虚拟机指令有所区别</p>
<div class="hljs"><pre><code class="hljs java">Code:
     stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">2</span>, args_size=<span class="hljs-number">1</span>
        0: new           #2                  // class com/qiuke/jvm/class03/Demo3_9
        <span class="hljs-number">3</span>: dup
        4: invokespecial #3                  // Method &quot;&lt;init&gt;&quot;:()V
        <span class="hljs-number">7</span>: astore_1
        <span class="hljs-number">8</span>: aload_1
        9: invokespecial #4                  // Method test1:()V
       <span class="hljs-number">12</span>: aload_1
       13: invokespecial #5                  // Method test2:()V
       <span class="hljs-number">16</span>: aload_1
       17: invokevirtual #6                  // Method test3:()V
       <span class="hljs-number">20</span>: aload_1
       <span class="hljs-number">21</span>: pop
       22: invokestatic  #7                  // Method test4:()V
       25: invokestatic  #7                  // Method test4:()V
       <span class="hljs-number">28</span>: <span class="hljs-keyword">return</span>
</code></pre></div>

<ul>
<li>new 是 <strong>创建【对象】</strong> ，给对象分配堆内存，执行成功会将【对象引用】压入操作数栈</li>
<li>dup 是赋值操作数栈栈顶的内容，本例即为【对象引用】，为什么需要两份引用呢，一个是要配<br>合 invokespecial 调用该对象的构造方法 “&lt; init &gt;”:()V （会消耗掉栈顶一个引用），另一个要<br>配合 astore_1 赋值给局部变量</li>
<li>最终方法（final），私有方法（private），构造方法都是由 <code>invokespecial</code> 指令来调用，属于<code>静 态绑定</code>，在字节码指令生成的时候就知道如何找到哪个类的哪个方法<ul>
<li>普通成员方法是由 <code>invokevirtual</code> 调用，属于<code>动态绑定，即支持多态</code></li>
</ul>
</li>
<li>成员方法与静态方法调用的另一个区别是，执行方法前<code>是否需要【对象引用】</code></li>
<li>比较有意思的是 d.test4(); 是通过【对象引用】调用一个静态方法，可以看到在调用<br><code>invokestatic</code> 之前<code>执行了 pop 指令，把【对象引用】从操作数栈弹掉了</code></li>
<li>还有一个执行 invokespecial 的情况是<code>通过 super 调用父类方法</code></li>
</ul>
<h3 id="2-9-多态原理"><a href="#2-9-多态原理" class="headerlink" title="2.9 多态原理"></a>2.9 多态原理</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 演示多态原理，注意加上下面的 JVM 参数，禁用指针压缩</span>
<span class="hljs-comment"> * -XX:-UseCompressedOops -XX:-UseCompressedClassPointers</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3_10</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(Animal animal)</span> </span>&#123;
        animal.eat();
        System.out.println(animal.toString());
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;
        test(<span class="hljs-keyword">new</span> Cat());
        test(<span class="hljs-keyword">new</span> Dog());
        System.in.read();
    &#125;
&#125;

<span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;我是&quot;</span> + <span class="hljs-keyword">this</span>.getClass().getSimpleName();
    &#125;
&#125;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;啃骨头&quot;</span>);
    &#125;
&#125;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;吃鱼&quot;</span>);
    &#125;
&#125;</code></pre></div>

<h4 id="1-运行代码"><a href="#1-运行代码" class="headerlink" title="1) 运行代码"></a>1) 运行代码</h4><p>停在 System.in.read() 方法上，这时运行 jps 获取进程 id</p>
<h4 id="2-运行HSDB工具"><a href="#2-运行HSDB工具" class="headerlink" title="2) 运行HSDB工具"></a>2) 运行HSDB工具</h4><p>进入 JDK 安装目录，执行</p>
<div class="hljs"><pre><code class="hljs js">java -cp ./lib/sa-jdi.jar sun.jvm.hotspot.HSDB</code></pre></div>

<p>进入图形界面 attach 进程 id</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504130417.png" srcset="/img/loading.gif"></p>
<h4 id="3-查找"><a href="#3-查找" class="headerlink" title="3) 查找"></a>3) 查找</h4><p>打开 Tools -&gt; Find Object By Query</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504130501.png" srcset="/img/loading.gif"></p>
<p>输入 <code>select d from cn.itcast.jvm.t3.bytecode.Dog d</code> 点击 <code>Execute</code> 执行</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504130602.png" srcset="/img/loading.gif"></p>
<h4 id="4）查看对象内存结构"><a href="#4）查看对象内存结构" class="headerlink" title="4）查看对象内存结构"></a>4）查看对象内存结构</h4><p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504130748.png" srcset="/img/loading.gif"></p>
<p>点击超链接可以看到对象的内存结构，此对象没有任何属性，因此只有对象头的 16 字节，前 8 字节是<br>MarkWord，后 8 字节就是对象的 Class 指针<br>但目前看不到它的实际地址</p>
<p>可以通过 Windows -&gt; Console 进入命令行模式，执行</p>
<div class="hljs"><pre><code class="hljs js">mem <span class="hljs-number">0x00000001299b4978</span> <span class="hljs-number">2</span></code></pre></div>

<p>mem 有两个参数，参数 1 是对象地址，参数 2 是查看 2 行（即 16 字节）<br>结果中第二行 0x000000001b7d4028 即为 Class 的内存地址</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504131204.png" srcset="/img/loading.gif"></p>
<p>再次打开inspector输入内存地址</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504131514.png" srcset="/img/loading.gif"></p>
<h4 id="5-查看类的-vtable"><a href="#5-查看类的-vtable" class="headerlink" title="5) 查看类的 vtable"></a>5) 查看类的 vtable</h4><p>找虚方法表vtable：</p>
<p>内存地址 + 1B8就是vtable位置</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504132151.png" srcset="/img/loading.gif"></p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504132217.png" srcset="/img/loading.gif"></p>
<p>Tools -&gt; Class Browser 输入 Dog 查找，可以得到相同的结果</p>
<p>无论通过哪种方法，都可以找到 Dog Class 的 vtable 长度为 6，意思就是 Dog 类有 6 个虚方法（多态<br>相关的，final，static 不会列入）<br>那么这 6 个方法都是谁呢？从 Class 的起始地址开始算，偏移 0x1b8 就是 vtable 的起始地址，进行计<br>算得到：</p>
<div class="hljs"><pre><code class="hljs js">mem <span class="hljs-number">0x000000001b7d41e0</span> <span class="hljs-number">6</span>
<span class="hljs-number">0x000000001b7d41e0</span>: <span class="hljs-number">0x000000001b3d1b10</span>
<span class="hljs-number">0x000000001b7d41e8</span>: <span class="hljs-number">0x000000001b3d15e8</span>
<span class="hljs-number">0x000000001b7d41f0</span>: <span class="hljs-number">0x000000001b7d35e8</span>
<span class="hljs-number">0x000000001b7d41f8</span>: <span class="hljs-number">0x000000001b3d1540</span>
<span class="hljs-number">0x000000001b7d4200</span>: <span class="hljs-number">0x000000001b3d1678</span>
<span class="hljs-number">0x000000001b7d4208</span>: <span class="hljs-number">0x000000001b7d3fa8</span></code></pre></div>

<h4 id="6-验证方法地址"><a href="#6-验证方法地址" class="headerlink" title="6) 验证方法地址"></a>6) 验证方法地址</h4><p>通过 Tools -&gt; Class Browser 查看每个类的方法定义，比较可知</p>
<div class="hljs"><pre><code class="hljs js">Dog - public <span class="hljs-keyword">void</span> eat() @<span class="hljs-number">0x000000001b7d3fa8</span>
Animal - public java.lang.String toString() @<span class="hljs-number">0x000000001b7d35e8</span>;
<span class="hljs-built_in">Object</span> - protected <span class="hljs-keyword">void</span> finalize() @<span class="hljs-number">0x000000001b3d1b10</span>;
<span class="hljs-built_in">Object</span> - public boolean equals(java.lang.Object) @<span class="hljs-number">0x000000001b3d15e8</span>;
<span class="hljs-built_in">Object</span> - public native int hashCode() @<span class="hljs-number">0x000000001b3d1540</span>;
<span class="hljs-built_in">Object</span> - protected native java.lang.Object clone() @<span class="hljs-number">0x000000001b3d1678</span>;</code></pre></div>

<p>发现：</p>
<p>eat() 方法是 Dog 类自己的</p>
<p>对比Animal类：</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504133348.png" srcset="/img/loading.gif"></p>
<p>对比Object类</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504133437.png" srcset="/img/loading.gif"></p>
<h4 id="7-小结"><a href="#7-小结" class="headerlink" title="7) 小结"></a>7) 小结</h4><p>因为普通成员方法需要在运行时才能确定具体的内容，所以虚拟机需要调用 <strong>invokevirtual</strong> 指令</p>
<p>在执行invokevirtual指令时，经历了以下几个步骤</p>
<ul>
<li>先通过栈帧中对象的引用找到对象</li>
<li>分析对象头，找到对象实际的Class</li>
<li>Class结构中有 <strong>vtable</strong> </li>
<li>查询vtable找到方法的具体地址</li>
<li>执行方法的字节码</li>
</ul>
<h3 id="2-10-异常处理"><a href="#2-10-异常处理" class="headerlink" title="2.10 异常处理"></a>2.10 异常处理</h3><h4 id="1-try-catch"><a href="#1-try-catch" class="headerlink" title="1) try-catch"></a>1) try-catch</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3_11_1</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">try</span> &#123;
            i = <span class="hljs-number">10</span>;
        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
            i = <span class="hljs-number">20</span>;
        &#125;
    &#125;
&#125;</code></pre></div>

<p>对应字节码：</p>
<div class="hljs"><pre><code class="hljs java">Code:
     stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">1</span>
        <span class="hljs-number">0</span>: iconst_0
        <span class="hljs-number">1</span>: istore_1
        <span class="hljs-number">2</span>: bipush        <span class="hljs-number">10</span>
        <span class="hljs-number">4</span>: istore_1
        <span class="hljs-number">5</span>: goto          <span class="hljs-number">12</span>
        <span class="hljs-number">8</span>: astore_2
        <span class="hljs-number">9</span>: bipush        <span class="hljs-number">20</span>
       <span class="hljs-number">11</span>: istore_1
       <span class="hljs-number">12</span>: <span class="hljs-keyword">return</span>
     <span class="hljs-comment">//多出来一个异常表</span>
     Exception table:
        from    to  target type
            <span class="hljs-number">2</span>     <span class="hljs-number">5</span>     <span class="hljs-number">8</span>   Class java/lang/Exception <span class="hljs-comment">// 检测[2, 5) 行代码</span></code></pre></div>

<ul>
<li>可以看到多出来一个<code> Exception table</code> 的结构，[from, to) 是 <strong>前闭后开</strong> （也就是检测2~4行）的检测范围，一旦这个范围内的字节码执行出现异常，则通过 <code>type 匹配异常类型</code>，如果一致，进入 target 所指示行号</li>
<li>8行的字节码指令 astore_2 是将异常对象引用存入局部变量表的2号位置（为e）</li>
</ul>
<h4 id="2-多个catch块"><a href="#2-多个catch块" class="headerlink" title="2) 多个catch块"></a>2) 多个catch块</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3_11_2</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">try</span> &#123;
            i = <span class="hljs-number">10</span>;
        &#125; <span class="hljs-keyword">catch</span> (ArithmeticException e) &#123;
            i = <span class="hljs-number">30</span>;
        &#125; <span class="hljs-keyword">catch</span> (NullPointerException e) &#123;
            i = <span class="hljs-number">40</span>;
        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
            i = <span class="hljs-number">50</span>;
        &#125;
    &#125;

&#125;</code></pre></div>

<p>字节码：</p>
<div class="hljs"><pre><code class="hljs java">Code:
  stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">1</span>
     <span class="hljs-number">0</span>: iconst_0
     <span class="hljs-number">1</span>: istore_1
     <span class="hljs-number">2</span>: bipush        <span class="hljs-number">10</span>
     <span class="hljs-number">4</span>: istore_1
     <span class="hljs-number">5</span>: goto          <span class="hljs-number">26</span>
     <span class="hljs-number">8</span>: astore_2
     <span class="hljs-number">9</span>: bipush        <span class="hljs-number">30</span>
    <span class="hljs-number">11</span>: istore_1
    <span class="hljs-number">12</span>: goto          <span class="hljs-number">26</span>
    <span class="hljs-number">15</span>: astore_2
    <span class="hljs-number">16</span>: bipush        <span class="hljs-number">40</span>
    <span class="hljs-number">18</span>: istore_1
    <span class="hljs-number">19</span>: goto          <span class="hljs-number">26</span>
    <span class="hljs-number">22</span>: astore_2
    <span class="hljs-number">23</span>: bipush        <span class="hljs-number">50</span>
    <span class="hljs-number">25</span>: istore_1
    <span class="hljs-number">26</span>: <span class="hljs-keyword">return</span>
  Exception table:
     from    to  target type
         <span class="hljs-number">2</span>     <span class="hljs-number">5</span>     <span class="hljs-number">8</span>   Class java/lang/ArithmeticException
         <span class="hljs-number">2</span>     <span class="hljs-number">5</span>    <span class="hljs-number">15</span>   Class java/lang/NullPointerException
         <span class="hljs-number">2</span>     <span class="hljs-number">5</span>    <span class="hljs-number">22</span>   Class java/lang/Exception
</code></pre></div>

<ul>
<li>因为异常出现时， <strong>只能进入</strong>  Exception table 中 <strong>一个分支</strong> ，所以局部变量表 slot 2 位置 <strong>被共用</strong> </li>
</ul>
<h4 id="3-multicatch"><a href="#3-multicatch" class="headerlink" title="3) multicatch"></a>3) multicatch</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3_11_3</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        <span class="hljs-keyword">try</span> &#123;
            Method test = Demo3_11_3.class.getMethod(<span class="hljs-string">&quot;test&quot;</span>);
            test.invoke(<span class="hljs-keyword">null</span>);
        &#125; <span class="hljs-keyword">catch</span> (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;ok&quot;</span>);
    &#125;
&#125;</code></pre></div>

<p>字节码：</p>
<div class="hljs"><pre><code class="hljs java">Code:
  stack=<span class="hljs-number">3</span>, locals=<span class="hljs-number">2</span>, args_size=<span class="hljs-number">1</span>
     0: ldc           #2                  // class com/qiuke/jvm/class03/Demo3_11_3
     2: ldc           #3                  // String test
     <span class="hljs-number">4</span>: iconst_0
     5: anewarray     #4                  // class java/lang/Class
     8: invokevirtual #5                  // Method java/lang/Class.getMethod:(Ljava/lang/String;[Ljava/lang/Class;)Ljava/lang/reflect/Method;
    <span class="hljs-number">11</span>: astore_1
    <span class="hljs-number">12</span>: aload_1
    <span class="hljs-number">13</span>: aconst_null
    <span class="hljs-number">14</span>: iconst_0
    15: anewarray     #6                  // class java/lang/Object
    18: invokevirtual #7                  // Method java/lang/reflect/Method.invoke:(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;
    <span class="hljs-number">21</span>: pop
    <span class="hljs-number">22</span>: goto          <span class="hljs-number">30</span>
    <span class="hljs-number">25</span>: astore_1
    <span class="hljs-number">26</span>: aload_1
    27: invokevirtual #11                 // Method java/lang/ReflectiveOperationException.printStackTrace:()V
    <span class="hljs-number">30</span>: <span class="hljs-keyword">return</span>
  Exception table:
     from    to  target type
         <span class="hljs-number">0</span>    <span class="hljs-number">22</span>    <span class="hljs-number">25</span>   Class java/lang/NoSuchMethodException
         <span class="hljs-number">0</span>    <span class="hljs-number">22</span>    <span class="hljs-number">25</span>   Class java/lang/IllegalAccessException
         <span class="hljs-number">0</span>    <span class="hljs-number">22</span>    <span class="hljs-number">25</span>   Class java/lang/reflect/InvocationTargetException</code></pre></div>

<h4 id="4-finally"><a href="#4-finally" class="headerlink" title="4) finally"></a>4) finally</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3_11_4</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">try</span> &#123;
            i = <span class="hljs-number">10</span>;
        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
            i = <span class="hljs-number">20</span>;
        &#125; <span class="hljs-keyword">finally</span> &#123;
            i = <span class="hljs-number">30</span>;
        &#125;
    &#125;
&#125;</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504135807.png" srcset="/img/loading.gif"></p>
<p>可以看到 ﬁnally 中的代码被 <strong>复制了 3 份</strong> ，分别放入 <code>try 流程，catch 流程以及 catch剩余的异常类型</code>流程</p>
<p> <strong>注意</strong> ：虽然从字节码指令看来，每个块中都有finally块，但是finally块中的代码 <strong>只会被执行一次</strong> </p>
<h4 id="5-finally面试题"><a href="#5-finally面试题" class="headerlink" title="5) finally面试题"></a>5) finally面试题</h4><h5 id="1-finally中的return"><a href="#1-finally中的return" class="headerlink" title="1. finally中的return"></a>1. finally中的return</h5><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3</span> </span>&#123;
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
    <span class="hljs-keyword">int</span> i = Demo3.test();
        <span class="hljs-comment">//结果为20</span>
    System.out.println(i);
  &#125;

  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">int</span> i;
    <span class="hljs-keyword">try</span> &#123;
      i = <span class="hljs-number">10</span>;
      <span class="hljs-keyword">return</span> i;
    &#125; <span class="hljs-keyword">finally</span> &#123;
      i = <span class="hljs-number">20</span>;
      <span class="hljs-keyword">return</span> i;
    &#125;
  &#125;
&#125;</code></pre></div>

<p>对应字节码</p>
<div class="hljs"><pre><code class="hljs java">Code:
     stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">0</span>
        <span class="hljs-number">0</span>: bipush        <span class="hljs-number">10</span>
        <span class="hljs-number">2</span>: istore_0
        <span class="hljs-number">3</span>: iload_0
        <span class="hljs-number">4</span>: istore_1  <span class="hljs-comment">//暂存返回值</span>
        <span class="hljs-number">5</span>: bipush        <span class="hljs-number">20</span>
        <span class="hljs-number">7</span>: istore_0
        <span class="hljs-number">8</span>: iload_0
        <span class="hljs-number">9</span>: ireturn  <span class="hljs-comment">//ireturn会返回操作数栈顶的整型值20</span>
       <span class="hljs-comment">//如果出现异常，还是会执行finally块中的内容，没有抛出异常</span>
       <span class="hljs-number">10</span>: astore_2
       <span class="hljs-number">11</span>: bipush        <span class="hljs-number">20</span>
       <span class="hljs-number">13</span>: istore_0
       <span class="hljs-number">14</span>: iload_0
       <span class="hljs-number">15</span>: ireturn  <span class="hljs-comment">//这里没有athrow了，也就是如果在finally块中如果有返回操作的话，且try块中出现异常，会吞掉异常！</span>
     Exception table:
        from    to  target type
            <span class="hljs-number">0</span>     <span class="hljs-number">5</span>    <span class="hljs-number">10</span>   any</code></pre></div>

<ul>
<li>由于 ﬁnally 中的 <strong>ireturn</strong> 被插入了所有可能的流程，因此返回结果肯定以ﬁnally的为准</li>
<li>至于字节码中第 2 行，似乎没啥用，且留个伏笔，看下个例子</li>
<li>跟上例中的 ﬁnally 相比，发现 <strong>没有 athrow 了</strong> ，这告诉我们：如果在 ﬁnally 中出现了 return，会 <strong>吞掉异常</strong> </li>
<li>所以 <strong>不要在finally中进行返回操作</strong> </li>
</ul>
<h5 id="2-finally中出现异常但有return"><a href="#2-finally中出现异常但有return" class="headerlink" title="2. finally中出现异常但有return"></a>2. finally中出现异常但有return</h5><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3</span> </span>&#123;
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
      <span class="hljs-keyword">int</span> i = Demo3.test();
      <span class="hljs-comment">//最终结果为20</span>
      System.out.println(i);
   &#125;

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;
      <span class="hljs-keyword">int</span> i;
      <span class="hljs-keyword">try</span> &#123;
         i = <span class="hljs-number">10</span>;
         <span class="hljs-comment">//这里应该会抛出异常</span>
         i = i/<span class="hljs-number">0</span>;
         <span class="hljs-keyword">return</span> i;
      &#125; <span class="hljs-keyword">finally</span> &#123;
         i = <span class="hljs-number">20</span>;
         <span class="hljs-keyword">return</span> i;
      &#125;
   &#125;
&#125;</code></pre></div>

<p>会发现打印结果为20，并未抛出异常</p>
<h5 id="3-finally-return的影响"><a href="#3-finally-return的影响" class="headerlink" title="3. finally return的影响"></a>3. finally return的影响</h5><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo4</span> </span>&#123;
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
    <span class="hljs-keyword">int</span> i = Demo4.test();
    System.out.println(i); <span class="hljs-comment">// 10</span>
  &#125;

  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span>;
    <span class="hljs-keyword">try</span> &#123;
      <span class="hljs-keyword">return</span> i;
    &#125; <span class="hljs-keyword">finally</span> &#123;
      i = <span class="hljs-number">20</span>;
    &#125;
  &#125;
&#125;</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504151738.png" srcset="/img/loading.gif"></p>
<p>原来就是把要返回的值先保存到局部变量中，返回前再load到栈中返回</p>
<h3 id="2-11-synchronized"><a href="#2-11-synchronized" class="headerlink" title="2.11 synchronized"></a>2.11 synchronized</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo5</span> </span>&#123;
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
    <span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span>;
    Lock lock = <span class="hljs-keyword">new</span> Lock();
    <span class="hljs-keyword">synchronized</span> (lock) &#123;
      System.out.println(i);
    &#125;
  &#125;
&#125;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Lock</span></span>&#123;&#125;</code></pre></div>

<div class="hljs"><pre><code class="hljs java">Code:
     stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">5</span>, args_size=<span class="hljs-number">1</span>
        <span class="hljs-number">0</span>: bipush        <span class="hljs-number">10</span>
        <span class="hljs-number">2</span>: istore_1
        3: new           #2                  // class com/nyima/JVM/day06/Lock
        <span class="hljs-number">6</span>: dup <span class="hljs-comment">//复制一份，放到操作数栈顶，用于构造函数消耗</span>
        7: invokespecial #3                  // Method com/nyima/JVM/day06/Lock.&quot;&lt;init&gt;&quot;:()V
       <span class="hljs-number">10</span>: astore_2 <span class="hljs-comment">//剩下的一份放到局部变量表的2号位置</span>
       <span class="hljs-number">11</span>: aload_2 <span class="hljs-comment">//加载到操作数栈</span>
       <span class="hljs-number">12</span>: dup <span class="hljs-comment">//复制一份，放到操作数栈，用于加锁时消耗</span>
       <span class="hljs-number">13</span>: astore_3 <span class="hljs-comment">//将操作数栈顶元素弹出，暂存到局部变量表的三号槽位。这时操作数栈中有一份对象的引用</span>
       <span class="hljs-number">14</span>: monitorenter <span class="hljs-comment">//加锁</span>
       <span class="hljs-comment">//锁住后代码块中的操作    </span>
       15: getstatic     #4                  // Field java/lang/System.out:Ljava/io/PrintStream;
       <span class="hljs-number">18</span>: iload_1
       19: invokevirtual #5                  // Method java/io/PrintStream.println:(I)V
       <span class="hljs-comment">//加载局部变量表中三号槽位对象的引用，用于解锁    </span>
       <span class="hljs-number">22</span>: aload_3    
       <span class="hljs-number">23</span>: monitorexit <span class="hljs-comment">//解锁</span>
       <span class="hljs-number">24</span>: goto          <span class="hljs-number">34</span>
       <span class="hljs-comment">//异常操作    </span>
       <span class="hljs-number">27</span>: astore        <span class="hljs-number">4</span>
       <span class="hljs-number">29</span>: aload_3
       <span class="hljs-number">30</span>: monitorexit <span class="hljs-comment">//解锁</span>
       <span class="hljs-number">31</span>: aload         <span class="hljs-number">4</span>
       <span class="hljs-number">33</span>: athrow
       <span class="hljs-number">34</span>: <span class="hljs-keyword">return</span>
     <span class="hljs-comment">//可以看出，无论何时出现异常，都会跳转到27行，将异常放入局部变量中，并进行解锁操作，然后加载异常并抛出异常。      </span>
     Exception table:
        from    to  target type
           <span class="hljs-number">15</span>    <span class="hljs-number">24</span>    <span class="hljs-number">27</span>   any
           <span class="hljs-number">27</span>    <span class="hljs-number">31</span>    <span class="hljs-number">27</span>   any</code></pre></div>

<p>如果是：</p>
<div class="hljs"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
    Object lock = <span class="hljs-keyword">new</span> Object();
    <span class="hljs-keyword">synchronized</span> (lock) &#123;
        System.out.println(<span class="hljs-string">&quot;ok&quot;</span>);
    &#125;
&#125;</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210504152231.png" srcset="/img/loading.gif"></p>
<h2 id="3、编译期间处理"><a href="#3、编译期间处理" class="headerlink" title="3、编译期间处理"></a>3、编译期间处理</h2><p>所谓的 <strong>语法糖</strong> ，其实就是指 java 编译器把 <em>.java 源码编译为 \</em>.class 字节码的过程中， <strong>自动生成</strong> 和 <strong>转换</strong> 的一些代码，主要是为了减轻程序员的负担，算是 java 编译器给我们的一个额外福利</p>
<p> <strong>注意</strong> ，以下代码的分析，借助了 javap 工具，idea 的反编译功能，idea 插件 jclasslib 等工具。另外， 编译器转换的 <strong>结果直接就是 class 字节码</strong> ，只是为了便于阅读，给出了 几乎等价 的 java 源码方式，并不是编译器还会转换出中间的 java 源码，切记。</p>
<h3 id="3-1-默认构造器"><a href="#3-1-默认构造器" class="headerlink" title="3.1 默认构造器"></a>3.1 默认构造器</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Candy1</span> </span>&#123;

&#125;</code></pre></div>

<p>经过编译期优化后</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Candy1</span> </span>&#123;
   <span class="hljs-comment">//这个无参构造器是java编译器帮我们加上的</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Candy1</span><span class="hljs-params">()</span> </span>&#123;
      <span class="hljs-comment">//即调用父类 Object 的无参构造方法，即调用 java/lang/Object.&quot; &lt;init&gt;&quot;:()V</span>
      <span class="hljs-keyword">super</span>();
   &#125;
&#125;</code></pre></div>

<h3 id="3-2-自动拆装箱"><a href="#3-2-自动拆装箱" class="headerlink" title="3.2 自动拆装箱"></a>3.2 自动拆装箱</h3><p><code>基本类型和其包装类型的相互转换</code>过程，称为<code>拆装箱</code></p>
<p>在JDK 5以后，它们的转换可以在编译期自动完成</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo2</span> </span>&#123;
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
      Integer x = <span class="hljs-number">1</span>;
      <span class="hljs-keyword">int</span> y = x;
   &#125;
&#125;<span class="hljs-comment">//这段代码在 JDK 5 之前是无法编译通过的，必须改写成下面:</span></code></pre></div>

<div class="hljs"><pre><code class="hljs java">
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo2</span> </span>&#123;
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
      <span class="hljs-comment">//基本类型赋值给包装类型，称为装箱</span>
      Integer x = Integer.valueOf(<span class="hljs-number">1</span>);
      <span class="hljs-comment">//包装类型赋值给基本类型，称谓拆箱</span>
      <span class="hljs-keyword">int</span> y = x.intValue();
   &#125;
&#125;</code></pre></div>

<h3 id="3-3-泛型集合取值"><a href="#3-3-泛型集合取值" class="headerlink" title="3.3 泛型集合取值"></a>3.3 泛型集合取值</h3><p>泛型也是在 JDK 5 开始加入的特性，但 java 在 <strong>编译泛型代码后</strong> 会执行 <strong>泛型擦除</strong> 的动作，即泛型信息在编译为字节码之后就 <strong>丢失</strong> 了，实际的类型都当做了 <strong>Object</strong> 类型来处理：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3</span> </span>&#123;
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
      List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
      list.add(<span class="hljs-number">10</span>);<span class="hljs-comment">// 实际调用的是 List.add(Object e)</span>
      Integer x = list.get(<span class="hljs-number">0</span>);<span class="hljs-comment">// 实际调用的是 Object obj = List.get(int index);</span>
   &#125;
&#125;</code></pre></div>

<p>所以在取值时，编译器真正生成的字节码中，还要额外做一个类型转换的操作：</p>
<p>查看字节码：</p>
<div class="hljs"><pre><code class="hljs java">Code:
    stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">1</span>
       0: new           #2                  // class java/util/ArrayList
       <span class="hljs-number">3</span>: dup
       4: invokespecial #3                  // Method java/util/ArrayList.&quot;&lt;init&gt;&quot;:()V
       <span class="hljs-number">7</span>: astore_1
       <span class="hljs-number">8</span>: aload_1
       <span class="hljs-number">9</span>: bipush        <span class="hljs-number">10</span>
      11: invokestatic  #4                  // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer; // 基本类型包装
        
      <span class="hljs-comment">//这里进行了泛型擦除，实际调用的是add(Objcet o)</span>
      14: invokeinterface #5,  2            // InterfaceMethod java/util/List.add:(Ljava/lang/Object;)Z

      <span class="hljs-number">19</span>: pop
      <span class="hljs-number">20</span>: aload_1
      <span class="hljs-number">21</span>: iconst_0
      <span class="hljs-comment">//这里也进行了泛型擦除，实际调用的是get(Object o)   </span>
      22: invokeinterface #6,  2            // InterfaceMethod java/util/List.get:(I)Ljava/lang/Object;
<span class="hljs-comment">//这里进行了类型转换，将Object转换成了Integer</span>
      27: checkcast     #7                  // class java/lang/Integer
      <span class="hljs-number">30</span>: astore_2
      <span class="hljs-number">31</span>: <span class="hljs-keyword">return</span></code></pre></div>

<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// 需要将 Object 转为 Integer</span>
Integer x = (Integer)list.get(<span class="hljs-number">0</span>);</code></pre></div>

<p>如果前面的 x 变量类型修改为 int 基本类型那么最终生成的字节码是：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// 需要将 Object 转为 Integer, 并执行拆箱操作</span>
<span class="hljs-keyword">int</span> x = ((Integer)list.get(<span class="hljs-number">0</span>)).intValue();</code></pre></div>

<p>擦除的是字节码上的泛型信息，可以看到 LocalVariableTypeTable 仍然保留了方法参数泛型的信息</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210508084303.png" srcset="/img/loading.gif"></p>
<p>使用反射，仍然能够获得这些信息：</p>
<p>(局部变量无法通过反射信息拿到，方法参数、返回值带的信息才能被反射拿到)</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Set&lt;Integer&gt; <span class="hljs-title">test</span><span class="hljs-params">(List&lt;String&gt; list, Map&lt;Integer, Object&gt; map)</span> </span>&#123;
&#125;</code></pre></div>

<div class="hljs"><pre><code class="hljs java">Method test = Candy3.class.getMethod(<span class="hljs-string">&quot;test&quot;</span>, List.class, Map.class);
Type[] types = test.getGenericParameterTypes();
  <span class="hljs-keyword">for</span> (Type type : types) &#123;
  <span class="hljs-keyword">if</span> (type <span class="hljs-keyword">instanceof</span> ParameterizedType) &#123;
    ParameterizedType parameterizedType = (ParameterizedType) type;
    System.out.println(<span class="hljs-string">&quot;原始类型 -&quot;</span> + parameterizedType.getRawType());
    Type[] arguments = parameterizedType.getActualTypeArguments();
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arguments.length; i++) &#123;
      System.out.printf(<span class="hljs-string">&quot;泛型参数[%d] - %s\n&quot;</span>, i, arguments[i]);
    &#125;
  &#125;
&#125;</code></pre></div>

<div class="hljs"><pre><code class="hljs java">原始类型 - <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">java</span>.<span class="hljs-title">util</span>.<span class="hljs-title">List</span></span>
泛型参数[0] - class java.lang.String
原始类型 - <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">java</span>.<span class="hljs-title">util</span>.<span class="hljs-title">Map</span></span>
泛型参数[0] - class java.lang.Integer
泛型参数[<span class="hljs-number">1</span>] - <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">java</span>.<span class="hljs-title">lang</span>.<span class="hljs-title">Object</span></span></code></pre></div>

<h3 id="3-4-可变参数"><a href="#3-4-可变参数" class="headerlink" title="3.4 可变参数"></a>3.4 可变参数</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Candy4</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(String... args)</span> </span>&#123;
        String[] array = args; <span class="hljs-comment">// 直接赋值</span>
        System.out.println(array);
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        foo(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>);
    &#125;
&#125;</code></pre></div>

<p>可变参数  <strong>String…</strong>  args 其实是一个  <strong>String[]</strong>  args ，从代码中的赋值语句中就可以看出来。 同 样 java 编译器会在编译期间将上述代码变换为：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Candy4</span> </span>&#123;
   <span class="hljs-keyword">public</span> Candy4 &#123;&#125;
  
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(String[] args)</span> </span>&#123;
      String[] arr = args;
      System.out.println(arr.length);
   &#125;

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
      foo(<span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>&#125;);
   &#125;
&#125;</code></pre></div>

<p> <strong>注意</strong> ，如果调用的是foo()，即未传递参数时，<code>等价代码为foo(new String[]&#123;&#125;)</code>，创建了一个空数组，而不是直接传递的null</p>
<h3 id="3-5-foreach"><a href="#3-5-foreach" class="headerlink" title="3.5 foreach"></a>3.5 foreach</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Candy5_1</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        <span class="hljs-keyword">int</span>[] array = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;; <span class="hljs-comment">// 数组赋初值的简化写法也是语法糖哦</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> e : array) &#123;
            System.out.println(e);
        &#125;
    &#125;
&#125;</code></pre></div>

<p>编译器会帮我们转换为</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Candy5_1</span> </span>&#123;
    <span class="hljs-keyword">public</span> Candy5_1 &#123;&#125;

  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
    <span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;arr.length; ++i) &#123;
      <span class="hljs-keyword">int</span> x = arr[i];
      System.out.println(x);
    &#125;
  &#125;
&#125;</code></pre></div>

<p> <strong>如果是集合使用foreach</strong> </p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Candy5_2</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);
        <span class="hljs-keyword">for</span> (Integer i : list) &#123;
            System.out.println(i);
        &#125;
    &#125;
&#125;</code></pre></div>

<p>集合要使用foreach，需要该集合类实现了 <strong>Iterable接口</strong> ，因为集合的遍历需要用到 <strong>迭代器Iterator</strong> </p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo5</span> </span>&#123;
    <span class="hljs-keyword">public</span> Demo5 &#123;&#125;
    
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
      List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);
      <span class="hljs-comment">//获得该集合的迭代器</span>
      Iterator&lt;Integer&gt; iterator = list.iterator();
      <span class="hljs-keyword">while</span>(iterator.hasNext()) &#123;
         Integer x = iterator.next();
         System.out.println(x);
      &#125;
   &#125;
&#125;</code></pre></div>

<h3 id="3-6-switch字符串"><a href="#3-6-switch字符串" class="headerlink" title="3.6 switch字符串"></a>3.6 switch字符串</h3><p>从 JDK 7 开始，switch 可以作用于字符串和枚举类，这个功能其实也是语法糖</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo6</span> </span>&#123;
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
      String str = <span class="hljs-string">&quot;hello&quot;</span>;
      <span class="hljs-keyword">switch</span> (str) &#123;
         <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;hello&quot;</span> :
            System.out.println(<span class="hljs-string">&quot;h&quot;</span>);
            <span class="hljs-keyword">break</span>;
         <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;world&quot;</span> :
            System.out.println(<span class="hljs-string">&quot;w&quot;</span>);
            <span class="hljs-keyword">break</span>;
         <span class="hljs-keyword">default</span>:
            <span class="hljs-keyword">break</span>;
      &#125;
   &#125;
&#125;</code></pre></div>

<blockquote>
<p>注意 switch 配合 String 和枚举使用时，变量不能为null，原因分析完语法糖转换后的代码应当自<br>然清楚</p>
</blockquote>
<p>在编译器中执行的操作</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo6</span> </span>&#123;
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Demo6</span><span class="hljs-params">()</span> </span>&#123;
      
   &#125;
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
      String str = <span class="hljs-string">&quot;hello&quot;</span>;
      <span class="hljs-keyword">int</span> x = -<span class="hljs-number">1</span>;
      <span class="hljs-comment">//通过字符串的hashCode+value来判断是否匹配</span>
      <span class="hljs-keyword">switch</span> (str.hashCode()) &#123;
         <span class="hljs-comment">//hello的hashCode</span>
         <span class="hljs-keyword">case</span> <span class="hljs-number">99162322</span> :
            <span class="hljs-comment">//再次比较，因为字符串的hashCode有可能相等</span>
            <span class="hljs-keyword">if</span>(str.equals(<span class="hljs-string">&quot;hello&quot;</span>)) &#123;
               x = <span class="hljs-number">0</span>;
            &#125;
            <span class="hljs-keyword">break</span>;
         <span class="hljs-comment">//world的hashCode</span>
         <span class="hljs-keyword">case</span> <span class="hljs-number">11331880</span> :
            <span class="hljs-keyword">if</span>(str.equals(<span class="hljs-string">&quot;world&quot;</span>)) &#123;
               x = <span class="hljs-number">1</span>;
            &#125;
            <span class="hljs-keyword">break</span>;
         <span class="hljs-keyword">default</span>:
            <span class="hljs-keyword">break</span>;
      &#125;

      <span class="hljs-comment">//用第二个switch在进行输出判断</span>
      <span class="hljs-keyword">switch</span> (x) &#123;
         <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:
            System.out.println(<span class="hljs-string">&quot;h&quot;</span>);
            <span class="hljs-keyword">break</span>;
         <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:
            System.out.println(<span class="hljs-string">&quot;w&quot;</span>);
            <span class="hljs-keyword">break</span>;
         <span class="hljs-keyword">default</span>:
            <span class="hljs-keyword">break</span>;
      &#125;
   &#125;
&#125;</code></pre></div>

<p>过程说明：</p>
<ul>
<li><p>在编译期间，单个的switch被分为了两个</p>
<ul>
<li>第一个用来匹配字符串，并给x赋值<ul>
<li>字符串的匹配用到了字符串的hashCode，还用到了equals方法</li>
<li>使用hashCode是为了提高比较效率，使用equals是防止有hashCode冲突（如BM和C.）</li>
</ul>
</li>
<li>第二个用来根据x的值来决定输出语句</li>
</ul>
</li>
<li><p>可以看到，执行了两遍 switch，第一遍是根据字符串的 <code>hashCode 和 equals</code> 将字符串的转换为相应<br><code>byte 类型</code>，第二遍才是利用 byte 执行进行比较。</p>
</li>
<li><p>为什么第一遍时必须既比较 hashCode，又利用 equals 比较呢？hashCode 是为了提高效率，减少可<br>能的比较；而 <code>equals 是为了防止 hashCode 冲突</code>，例如 BM 和 C. 这两个字符串的hashCode值都是<br>2123 ，如果有如下代码：</p>
</li>
</ul>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">choose</span><span class="hljs-params">(String str)</span> </span>&#123;
        <span class="hljs-keyword">switch</span> (str) &#123;
            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;BM&quot;</span>: &#123;
                System.out.println(<span class="hljs-string">&quot;h&quot;</span>);
                <span class="hljs-keyword">break</span>;
            &#125;
            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;C.&quot;</span>: &#123;
                System.out.println(<span class="hljs-string">&quot;w&quot;</span>);
                <span class="hljs-keyword">break</span>;
            &#125;
        &#125;
    &#125;</code></pre></div>

<p>会被优化为</p>
<p>" srcset="/img/loading.gif<img src=""></p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Candy6_2</span></span>&#123;
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Candy6_2</span><span class="hljs-params">()</span></span>&#123; &#125;
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">choose</span><span class="hljs-params">(String str)</span></span>&#123;
        <span class="hljs-keyword">byte</span> x=-<span class="hljs-number">1</span>;
        <span class="hljs-keyword">switch</span>(str.hashCode())&#123;
            <span class="hljs-keyword">case</span> <span class="hljs-number">2123</span>: <span class="hljs-comment">// hashCode 值可能相同，需要进一步用 equals 比较</span>
                <span class="hljs-keyword">if</span>(str.equals(<span class="hljs-string">&quot;C. &quot;</span>)) &#123;
                    x=<span class="hljs-number">1</span>;
                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(str.equals(<span class="hljs-string">&quot;BM&quot;</span>))&#123;
                    x=<span class="hljs-number">0</span>;
                &#125;
<span class="hljs-keyword">default</span>:
        <span class="hljs-keyword">switch</span>(x)&#123;
            <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:
                System.out.println(<span class="hljs-string">&quot;h&quot;</span>);
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:
                System.out.println(<span class="hljs-string">&quot;w&quot;</span>);
        &#125;
        &#125;
        &#125;
        &#125;</code></pre></div>

<h3 id="3-7-switch枚举"><a href="#3-7-switch枚举" class="headerlink" title="3.7 switch枚举"></a>3.7 switch枚举</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Sex</span> </span>&#123;
    MALE, FEMALE;
&#125;
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Candy7</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(Sex sex)</span> </span>&#123;
        <span class="hljs-keyword">switch</span> (sex) &#123;
            <span class="hljs-keyword">case</span> MALE:
                System.out.println(<span class="hljs-string">&quot;男&quot;</span>); <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> FEMALE:
                System.out.println(<span class="hljs-string">&quot;女&quot;</span>); <span class="hljs-keyword">break</span>;
        &#125;
    &#125;
&#125;</code></pre></div>

<p>转化为</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo7</span> </span>&#123;
   <span class="hljs-comment">/**     </span>
<span class="hljs-comment">    * 定义一个合成类（仅 jvm 使用，对我们不可见）     </span>
<span class="hljs-comment">    * 用来映射枚举的 ordinal 与数组元素的关系     </span>
<span class="hljs-comment">    * 枚举的 ordinal 表示枚举对象的序号，从 0 开始     </span>
<span class="hljs-comment">    * 即 MALE 的 ordinal()=0，FEMALE 的 ordinal()=1     </span>
<span class="hljs-comment">    */</span> 
   <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> $<span class="hljs-title">MAP</span> </span>&#123;
      <span class="hljs-comment">//数组大小即为枚举元素个数，里面存放了case用于比较的数字</span>
      <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] map = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2</span>];
      <span class="hljs-keyword">static</span> &#123;
         <span class="hljs-comment">//ordinal即枚举元素对应所在的位置，MALE为0，FEMALE为1</span>
         map[SEX.MALE.ordinal()] = <span class="hljs-number">1</span>;
         map[SEX.FEMALE.ordinal()] = <span class="hljs-number">2</span>;
      &#125;
   &#125;

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
      SEX sex = SEX.MALE;
      <span class="hljs-comment">//将对应位置枚举元素的值赋给x，用于case操作</span>
      <span class="hljs-keyword">int</span> x = $MAP.map[sex.ordinal()];
      <span class="hljs-keyword">switch</span> (x) &#123;
         <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:
            System.out.println(<span class="hljs-string">&quot;man&quot;</span>);
            <span class="hljs-keyword">break</span>;
         <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:
            System.out.println(<span class="hljs-string">&quot;woman&quot;</span>);
            <span class="hljs-keyword">break</span>;
         <span class="hljs-keyword">default</span>:
            <span class="hljs-keyword">break</span>;
      &#125;
   &#125;
&#125;

<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">SEX</span> </span>&#123;
   MALE, FEMALE;
&#125;</code></pre></div>



<h3 id="3-8-枚举类"><a href="#3-8-枚举类" class="headerlink" title="3.8 枚举类"></a>3.8 枚举类</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">SEX</span> </span>&#123;
   MALE, FEMALE;
  <span class="hljs-comment">// 本质Class， 里面两个实例对象</span>
&#125;</code></pre></div>

<p>转换后的代码</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sex</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Enum</span>&lt;<span class="hljs-title">Sex</span>&gt; </span>&#123;   
   <span class="hljs-comment">//对应枚举类中的元素</span>
 
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Sex MALE;    
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Sex FEMALE;    
   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Sex[] $VALUES;
   
    <span class="hljs-keyword">static</span> &#123;       
      <span class="hljs-comment">//调用构造函数，传入枚举元素的值及ordinal</span>
      MALE = <span class="hljs-keyword">new</span> Sex(<span class="hljs-string">&quot;MALE&quot;</span>, <span class="hljs-number">0</span>);    
        FEMALE = <span class="hljs-keyword">new</span> Sex(<span class="hljs-string">&quot;FEMALE&quot;</span>, <span class="hljs-number">1</span>);   
        $VALUES = <span class="hljs-keyword">new</span> Sex[]&#123;MALE, FEMALE&#125;; 
   &#125;
  
   <span class="hljs-comment">//调用父类中的方法</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Sex</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> ordinal)</span> </span>&#123;     
        <span class="hljs-keyword">super</span>(name, ordinal);    
    &#125;
   
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Sex[] values() &#123;  
        <span class="hljs-keyword">return</span> $VALUES.clone();  
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Sex <span class="hljs-title">valueOf</span><span class="hljs-params">(String name)</span> </span>&#123; 
        <span class="hljs-keyword">return</span> Enum.valueOf(Sex.class, name);  
    &#125; 
   
&#125;</code></pre></div>



<h3 id="3-9-try-with-resources"><a href="#3-9-try-with-resources" class="headerlink" title="3.9 try-with-resources"></a>3.9 try-with-resources</h3><p>JDK 7 开始新增了对需要关闭的资源处理的特殊语法，‘try-with-resources’</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">try</span>(资源变量 = 创建资源对象) &#123;
  
&#125; <span class="hljs-keyword">catch</span>() &#123;

&#125;</code></pre></div>

<p>其中资源对象需要实现 <code>AutoCloseable 接口</code>，例如 InputStream 、 OutputStream 、 Connection 、 Statement 、 ResultSet 等接口都实现了 AutoCloseable ，使用 try-with- resources <code>可以不用写 finally 语句块，编译器会帮助生成关闭资源代码</code>，例如：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Candy9</span> </span>&#123; 
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
    <span class="hljs-keyword">try</span>(InputStream is = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;d:\\1.txt&quot;</span>))&#123; 
      System.out.println(is); 
    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123; 
      e.printStackTrace(); 
    &#125; 
  &#125; 
&#125;</code></pre></div>

<p>会被转换为：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Candy9</span> </span>&#123; 
    
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Candy9</span><span class="hljs-params">()</span> </span>&#123; &#125;
   
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123; 
        <span class="hljs-keyword">try</span> &#123;
            InputStream is = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;d:\\1.txt&quot;</span>);
            Throwable t = <span class="hljs-keyword">null</span>; 
            <span class="hljs-keyword">try</span> &#123;
                System.out.println(is); 
            &#125; <span class="hljs-keyword">catch</span> (Throwable e1) &#123; 
                <span class="hljs-comment">// t 是我们代码出现的异常 </span>
                t = e1; 
                <span class="hljs-keyword">throw</span> e1; 
            &#125; <span class="hljs-keyword">finally</span> &#123;
                <span class="hljs-comment">// 判断了资源不为空 </span>
                <span class="hljs-keyword">if</span> (is != <span class="hljs-keyword">null</span>) &#123; 
                    <span class="hljs-comment">// 如果我们代码有异常</span>
                    <span class="hljs-keyword">if</span> (t != <span class="hljs-keyword">null</span>) &#123; 
                        <span class="hljs-keyword">try</span> &#123;
                            is.close(); 
                        &#125; <span class="hljs-keyword">catch</span> (Throwable e2) &#123; 
                            <span class="hljs-comment">// 如果 close 出现异常，作为被压制异常添加</span>
                            t.addSuppressed(e2); 
                        &#125; 
                    &#125; <span class="hljs-keyword">else</span> &#123; 
                        <span class="hljs-comment">// 如果我们代码没有异常，close 出现的异常就是最后 catch 块中的 e </span>
                        is.close(); 
                    &#125; 
                &#125; 
            &#125; 
        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;
            e.printStackTrace(); 
        &#125; 
    &#125;
&#125;</code></pre></div>

<p>为什么要设计一个 <code>addSuppressed(Throwable e) （添加被压制异常）</code>的方法呢？是为了防止异常信息的丢失（想想 try-with-resources 生成的 fianlly 中如果抛出了异常）：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test6</span> </span>&#123; 
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123; 
    <span class="hljs-keyword">try</span> (MyResource resource = <span class="hljs-keyword">new</span> MyResource()) &#123; 
      <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>/<span class="hljs-number">0</span>; 
    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123; 
      e.printStackTrace(); 
    &#125; 
  &#125; 
&#125;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyResource</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AutoCloseable</span> </span>&#123; 
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123; 
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">&quot;close 异常&quot;</span>); 
  &#125; 
&#125;</code></pre></div>

<div class="hljs"><pre><code class="hljs ruby">java.lang.<span class="hljs-symbol">ArithmeticException:</span> / by zero 
  at test.Test6.main(Test6.<span class="hljs-symbol">java:</span><span class="hljs-number">7</span>) 
  <span class="hljs-symbol">Suppressed:</span> java.lang.<span class="hljs-symbol">Exception:</span> close 异常 
    at test.MyResource.close(Test6.<span class="hljs-symbol">java:</span><span class="hljs-number">18</span>) 
    at test.Test6.main(Test6.<span class="hljs-symbol">java:</span><span class="hljs-number">6</span>)
/<span class="hljs-regexp">/ 防止资源类自己的异常丢失</span></code></pre></div>

<h3 id="3-10-方法重写时的桥接方法"><a href="#3-10-方法重写时的桥接方法" class="headerlink" title="3.10 方法重写时的桥接方法"></a>3.10 方法重写时的桥接方法</h3><p>我们都知道，方法重写时对返回值分两种情况：</p>
<ul>
<li>父子类的返回值完全一致</li>
<li>子类返回值可以是父类返回值的子类（比较绕口，见下面的例子）</li>
</ul>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123; 
  <span class="hljs-function"><span class="hljs-keyword">public</span> Number <span class="hljs-title">m</span><span class="hljs-params">()</span> </span>&#123; 
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; 
  &#125; 
&#125;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> </span>&#123; 
  <span class="hljs-meta">@Override</span> 
  <span class="hljs-comment">// 子类 m 方法的返回值是 Integer 是父类 m 方法返回值 Number 的子类  </span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">m</span><span class="hljs-params">()</span> </span>&#123; 
    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>; 
  &#125; 
&#125;
</code></pre></div>

<p>对于子类，java 编译器会做如下处理：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> </span>&#123; 
  <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">m</span><span class="hljs-params">()</span> </span>&#123; 
    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>; 
  &#125;
  <span class="hljs-comment">// 此方法才是真正重写了父类 public Number m() 方法 </span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> synthetic bridge Number <span class="hljs-title">m</span><span class="hljs-params">()</span> </span>&#123; 
    <span class="hljs-comment">// 调用 public Integer m() </span>
    <span class="hljs-keyword">return</span> m(); 
  &#125; 
&#125;</code></pre></div>

<p>其中桥接方法比较特殊，仅对 java 虚拟机可见，并且与原来的 public Integer m() 没有命名冲突，可以<br>用下面反射代码来验证：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        <span class="hljs-keyword">for</span>(Method m : B.class.getDeclaredMethods()) &#123;
            System.out.println(m);
        &#125;
    &#125;</code></pre></div>

<p>结果：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> java.lang.Integer cn.ali.jvm.test.B.m()
<span class="hljs-keyword">public</span> java.lang.Number cn.ali.jvm.test.B.m()</code></pre></div>

<h3 id="3-11-匿名内部类"><a href="#3-11-匿名内部类" class="headerlink" title="3.11 匿名内部类"></a>3.11 匿名内部类</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Candy10</span> </span>&#123;
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
      Runnable runnable = <span class="hljs-keyword">new</span> Runnable() &#123;
         <span class="hljs-meta">@Override</span>
         <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;
            System.out.println(<span class="hljs-string">&quot;running...&quot;</span>);
         &#125;
      &#125;;
   &#125;
&#125;</code></pre></div>

<p>转换后的代码</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Candy10</span> </span>&#123;
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
      <span class="hljs-comment">// 用额外创建的类来创建匿名内部类对象</span>
      Runnable runnable = <span class="hljs-keyword">new</span> Candy10$<span class="hljs-number">1</span>();
   &#125;
&#125;

<span class="hljs-comment">// 创建了一个额外的类，实现了 Runnable 接口</span>
<span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Candy10</span>$1 <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;
   <span class="hljs-keyword">public</span> Candy10$<span class="hljs-number">1</span>() &#123;&#125;

   <span class="hljs-meta">@Override</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;
      System.out.println(<span class="hljs-string">&quot;running...&quot;</span>);
   &#125;
&#125;</code></pre></div>

<p>引用局部变量的匿名内部类，源代码：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Candy11</span> </span>&#123; 
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> x)</span> </span>&#123; 
    Runnable runnable = <span class="hljs-keyword">new</span> Runnable() &#123; 
      <span class="hljs-meta">@Override</span> 
      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;   
        System.out.println(<span class="hljs-string">&quot;ok:&quot;</span> + x); 
      &#125; 
    &#125;; 
  &#125; 
&#125;</code></pre></div>

<p>转换后代码：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// 额外生成的类 </span>
<span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Candy11</span>$1 <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123; 
  <span class="hljs-keyword">int</span> val$x; 
  Candy11$<span class="hljs-number">1</span>(<span class="hljs-keyword">int</span> x) &#123; 
    <span class="hljs-keyword">this</span>.val$x = x; 
  &#125;
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123; 
    System.out.println(<span class="hljs-string">&quot;ok:&quot;</span> + <span class="hljs-keyword">this</span>.val$x); 
  &#125; 
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Candy11</span> </span>&#123; 
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> x)</span> </span>&#123; 
    Runnable runnable = <span class="hljs-keyword">new</span> Candy11$<span class="hljs-number">1</span>(x); 
  &#125; 
&#125;</code></pre></div>

<p>匿名内部类将这个局部变量的传入到匿名内部类中，以成员变量的形式存在，值传递有构造函数完成。保存线程安全;</p>
<p>注意：这同时解释了为什么匿名内部类引用局部变量时，局部变量必须是 final 的：因为在创建 Candy11$1 对象时，将 x 的值赋值给了 Candy11$1 对象的 值后，如果不是 final 声明的 x 值发生了改变，匿名内部类则值不一致。</p>
<h2 id="4、类加载阶段"><a href="#4、类加载阶段" class="headerlink" title="4、类加载阶段"></a>4、类加载阶段</h2><h3 id="1-加载"><a href="#1-加载" class="headerlink" title="1) 加载"></a>1) 加载</h3><ul>
<li>将类的字节码载入方法区（1.8后为元空间，在本地内存中）中，内部采用 C++ 的<code>instanceKlass</code>描述 java 类，它的重要 ﬁeld 有：<ul>
<li> <code>_java_mirror</code> 即 java 的类镜像，例如对 String 来说，它的镜像类就是 String.class，作用是把 klass 暴露给 java 使用 (桥梁)</li>
<li>_super 即父类</li>
<li>_ﬁelds 即成员变量</li>
<li>_methods 即方法</li>
<li>_constants 即常量池</li>
<li>_class_loader 即类加载器</li>
<li>_vtable 虚方法表</li>
<li>_itable 接口方法</li>
</ul>
</li>
<li>如果这个类还有父类没有加载， <strong>先加载父类</strong> </li>
<li>加载和链接可能是 <strong>交替运行</strong> 的</li>
</ul>
<blockquote>
<p><strong>注意</strong></p>
<ul>
<li>instanceKlass 这样的【元数据】是存储在<code>方法区</code>（1.8 后的元空间内），但 _java_mirror 是存储在<code>堆中</code></li>
<li>可以通过前面介绍的 HSDB 工具查看</li>
</ul>
</blockquote>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210508161739.png" srcset="/img/loading.gif"></p>
<ul>
<li>instanceKlass保存在 <strong>方法区</strong> 。JDK 8以后，方法区位于元空间中，而元空间又位于本地内存中</li>
<li>_java_mirror则是保存在 <strong>堆内存</strong> 中</li>
<li>InstanceKlass和*.class(JAVA镜像类)互相保存了对方的地址</li>
<li>类的对象在对象头(每个实例对象16字节对象头，8字节对应对象的class地址)中保存了*.class的地址。让对象可以通过其找到方法区中的instanceKlass，从而获取类的各种信息</li>
</ul>
<h3 id="2-链接"><a href="#2-链接" class="headerlink" title="2)  链接"></a>2)  链接</h3><h4 id="1-验证"><a href="#1-验证" class="headerlink" title="1. 验证"></a>1. 验证</h4><p>验证类是否符合 JVM规范，安全性检查<br>用 UE 等支持二进制的编辑器修改 HelloWorld.class 的魔数，在控制台运行</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210508162241.png" srcset="/img/loading.gif"></p>
<h4 id="2-准备"><a href="#2-准备" class="headerlink" title="2. 准备"></a>2. 准备</h4><p>为 static 变量分配空间，设置默认值</p>
<ul>
<li>static变量在 <code>JDK 7以前是存储与instanceKlass末尾</code>。但在<code>JDK 7以后就存储在_java_mirror末尾</code>了</li>
<li>static变量在分配空间和赋值是在两个阶段完成的。<code>分配空间在准备阶段完成</code>，<code>赋值在初始化阶段完成</code></li>
<li>如果 static 变量是 ﬁnal 的 <strong>基本类型</strong> ，以及 <strong>字符串常量</strong> ，那么编译阶段值就确定了， <strong>赋值在准备阶段完成</strong> </li>
<li>如果 static 变量是 ﬁnal 的，但属于 <strong>引用类型</strong> ，那么赋值也会在 <strong>初始化阶段完成</strong> </li>
</ul>
<h4 id="3-解析"><a href="#3-解析" class="headerlink" title="3. 解析"></a>3. 解析</h4><p>将常量池中的符号引用解析为直接引用</p>
<ul>
<li>未解析时，常量池中的看到的对象仅是符号，未真正的存在于内存中</li>
</ul>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Code_22_AnalysisTest</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, IOException </span>&#123;
        ClassLoader classLoader = Code_22_AnalysisTest.class.getClassLoader();
        Class&lt;?&gt; c = classLoader.loadClass(<span class="hljs-string">&quot;cn.ali.jvm.test.C&quot;</span>);
        <span class="hljs-comment">// 只会进行类C的加载，不会对D初始化</span>
        <span class="hljs-comment">// new C(); 这时候才会触发初始化，间接让D初始化</span>
        System.in.read();
    &#125;
&#125;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> </span>&#123;
    D d = <span class="hljs-keyword">new</span> D();
&#125;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">D</span> </span>&#123;

&#125;</code></pre></div>

<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210508163525.png" srcset="/img/loading.gif"></p>
<p>打开hsdb连接进程id</p>
<p>找不到类D</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210508163613.png" srcset="/img/loading.gif"></p>
<p>点进类C</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210508163709.png" srcset="/img/loading.gif"></p>
<p>显示为“未经解析的类”</p>
<p>这时候我们 <code>添加new操作</code></p>
<ul>
<li>解析以后，会将常量池中的符号引用解析为直接引用<ul>
<li>可以看到，此时已加载并解析了类C和类D</li>
</ul>
</li>
</ul>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210508163824.png" srcset="/img/loading.gif"></p>
<p>找到类C：</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210508163839.png" srcset="/img/loading.gif"></p>
<h3 id="3-初始化阶段"><a href="#3-初始化阶段" class="headerlink" title="3) 初始化阶段"></a>3) 初始化阶段</h3><p>初始化阶段就是 <strong>执行类构造器clinit()方法的过程</strong> ，虚拟机会保证这个类的『构造方法』的线程安全</p>
<ul>
<li>clinit()方法是由编译器自动收集类中的所有类变量的 <strong>赋值动作和静态语句块</strong> （static{}块）中的语句合并产生的</li>
</ul>
<h4 id="1-lt-cinit-gt-v-方法"><a href="#1-lt-cinit-gt-v-方法" class="headerlink" title="1. &lt; cinit &gt;()v 方法"></a>1. &lt; cinit &gt;()v 方法</h4><p> <strong>注意</strong> </p>
<p>编译器收集的顺序是由语句在源文件中 <strong>出现的顺序决定</strong> 的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它 <strong>之后</strong> 的变量，在前面的静态语句块 <strong>可以赋值，但是不能访问</strong> ，如</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210508164206.png" srcset="/img/loading.gif"></p>
<h4 id="2-发生时机"><a href="#2-发生时机" class="headerlink" title="2. 发生时机"></a>2. 发生时机</h4><p> <strong>类的初始化的懒惰的</strong> ，以下情况会初始化</p>
<ul>
<li>main 方法所在的类，总会被首先初始化</li>
<li>首次访问这个类的<code>静态变量或静态方法</code>时</li>
<li>子类初始化，如果父类还没初始化，会引发</li>
<li><code>子类访问父类的静态变量</code>，只会触发父类的初始化</li>
<li>Class.forName</li>
<li>new 会导致初始化</li>
</ul>
<p>以下情况不会初始化</p>
<ul>
<li>访问类的<code>static ﬁnal</code>静态常量（基本类型和字符串）</li>
<li>类对象.class 不会触发初始化</li>
<li>创建该类对象的<code>数组</code></li>
<li>类加载器的.loadClass方法</li>
<li>Class.forNamed的参数2为false时</li>
</ul>
<p> <strong>验证类是否被初始化，可以看改类的静态代码块是否被执行</strong> </p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Load3</span> </span>&#123;
    <span class="hljs-keyword">static</span> &#123;
        System.out.println(<span class="hljs-string">&quot;main init&quot;</span>);
    &#125; <span class="hljs-comment">// main方法所在类的 Load3 ，会被初始化，static会被运行</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, IOException </span>&#123;
<span class="hljs-comment">//        // 1. 静态常量不会触发初始化</span>
          System.out.println(B.b);
<span class="hljs-comment">//        // 2. 类对象.class 不会触发初始化</span>
          System.out.println(B.class);
<span class="hljs-comment">//        // 3. 创建该类的数组不会触发初始化</span>
          System.out.println(<span class="hljs-keyword">new</span> B[<span class="hljs-number">0</span>]);
        <span class="hljs-comment">// 4. 不会初始化类 B，但会加载 B、A</span>
        ClassLoader cl = Thread.currentThread().getContextClassLoader();
        cl.loadClass(<span class="hljs-string">&quot;cn.itcast.jvm.t3.load.B&quot;</span>);
<span class="hljs-comment">//        // 5. 不会初始化类 B，但会加载 B、A</span>
        ClassLoader c2 = Thread.currentThread().getContextClassLoader();
        Class.forName(<span class="hljs-string">&quot;cn.itcast.jvm.t3.load.B&quot;</span>, <span class="hljs-keyword">false</span>, c2);
        System.in.read();


<span class="hljs-comment">//        // 1. 首次访问这个类的静态变量或静态方法时会初始化</span>
          System.out.println(A.a);
<span class="hljs-comment">//        // 2. 子类初始化，如果父类还没初始化，会引发</span>
          System.out.println(B.c);
<span class="hljs-comment">//        // 3. 子类访问父类静态变量，只触发父类初始化</span>
          System.out.println(B.a);
<span class="hljs-comment">//        // 4. 会初始化类 B，并先初始化类 A</span>
          Class.forName(<span class="hljs-string">&quot;cn.itcast.jvm.t3.load.B&quot;</span>);


    &#125;
&#125;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">static</span> &#123;
        System.out.println(<span class="hljs-string">&quot;a init&quot;</span>);
    &#125;
&#125;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> </span>&#123;
    <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">double</span> b = <span class="hljs-number">5.0</span>;
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> c = <span class="hljs-keyword">false</span>;
    <span class="hljs-keyword">static</span> &#123;
        System.out.println(<span class="hljs-string">&quot;b init&quot;</span>);
    &#125;
&#125;</code></pre></div>



<h3 id="4-练习"><a href="#4-练习" class="headerlink" title="4) 练习"></a>4) 练习</h3><p>从字节码分析，使用 a，b，c 这三个常量是否会导致 E 初始化</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Load4</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        System.out.println(E.a);<span class="hljs-comment">// no</span>
        System.out.println(E.b);<span class="hljs-comment">// no</span>
        System.out.println(E.c);<span class="hljs-comment">// 包装类型, 会初始化</span>

    &#125;
&#125;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">E</span> </span>&#123;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String b = <span class="hljs-string">&quot;hello&quot;</span>;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Integer c = <span class="hljs-number">20</span>;  <span class="hljs-comment">// Integer.valueOf(20)</span>
    <span class="hljs-keyword">static</span> &#123;
        System.out.println(<span class="hljs-string">&quot;init E&quot;</span>);
    &#125;
&#125;</code></pre></div>

<p>懒汉单例：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Load9</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        Singleton.getInstance();
    &#125;

&#125;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;&#125;

  <span class="hljs-comment">// 静态内部类是为了可以访问外部类资源</span>
  <span class="hljs-comment">// 静态内部类初始化过程：静态代码块、静态变量赋值的时候，加载器保证初始化线程安全</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LazyHolder</span></span>&#123;
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton SINGLETON = <span class="hljs-keyword">new</span> Singleton();
        <span class="hljs-keyword">static</span> &#123;
            System.out.println(<span class="hljs-string">&quot;lazy holder init&quot;</span>);
        &#125;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> LazyHolder.SINGLETON;
    &#125;
&#125;</code></pre></div>

<p>以上的实现特点是：</p>
<ul>
<li>懒惰实例化</li>
<li>初始化时的线程安全是有保障的</li>
</ul>
<h2 id="5、类加载器"><a href="#5、类加载器" class="headerlink" title="5、类加载器"></a>5、类加载器</h2><p>以JDK 8为例</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>加载的类</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Bootstrap ClassLoader（启动类加载器）</td>
<td>JAVA_HOME/jre/lib</td>
<td>无法直接访问(cpp)</td>
</tr>
<tr>
<td>Extension ClassLoader(拓展类加载器)</td>
<td>JAVA_HOME/jre/lib/ext</td>
<td>上级为Bootstrap，<strong>显示为null</strong></td>
</tr>
<tr>
<td>Application ClassLoader(应用程序类加载器)</td>
<td>classpath</td>
<td>上级为Extension</td>
</tr>
<tr>
<td>自定义类加载器</td>
<td>自定义</td>
<td>上级为Application</td>
</tr>
</tbody></table>
<p>Java虚拟机设计团队有意把类加载阶段中的 <strong>“通过一个类的全限定名来获取描述该类的二进制字节流”</strong> 这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需的类。实现这个动作的代码被称为 <strong>“类加载器”</strong> （ClassLoader）</p>
<p>类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远超类加载阶段</p>
<p>对于任意一个类，都必须由加载它的 <strong>类加载器</strong> 和这个 <strong>类本身</strong> 一起共同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个<code>独立的类名称空间</code>。这句话可以表达得更通俗一些： <strong>比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义</strong> ，否则，即使这两个类来源于同一个Class文件，被同一个Java虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等</p>
<h3 id="1-启动类加载器"><a href="#1-启动类加载器" class="headerlink" title="1) 启动类加载器"></a>1) 启动类加载器</h3><p>用 Bootstrap 类加载器加载类：</p>
<p>可通过在控制台输入指令，使得类被启动类加器加载</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">F</span> </span>&#123;
    <span class="hljs-keyword">static</span> &#123;
        System.out.println(<span class="hljs-string">&quot;bootstrap F init&quot;</span>);
    &#125;
&#125;</code></pre></div>

<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Load5_1</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException </span>&#123;
        Class&lt;?&gt; aClass = Class.forName(<span class="hljs-string">&quot;com.qiuke.jvm.class03.load.F&quot;</span>);
        System.out.println(aClass.getClassLoader()); <span class="hljs-comment">// AppClassLoader  ExtClassLoader</span>
    &#125;
&#125;</code></pre></div>

<p>执行：</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210508172848.png" srcset="/img/loading.gif"></p>
<div class="hljs"><pre><code class="hljs java">qiukedeMacBook-Pro-<span class="hljs-number">2</span>:jvm qiuke$ java -Xbootclasspath/a:. com.qiuke.jvm.class03.load.Load5_1
bootstrap F init
<span class="hljs-keyword">null</span></code></pre></div>

<ul>
<li>-Xbootclasspath 表示设置 bootclasspath</li>
<li>其中 /a:. 表示将当前目录追加至 bootclasspath 之后</li>
<li>可以用这个办法替换核心类<ul>
<li>java -Xbootclasspath:&lt; new bootclasspath &gt;</li>
<li>java -Xbootclasspath/a:&lt;后追加路径&gt;</li>
<li>java -Xbootclasspath/p:&lt;前追加路径&gt;</li>
</ul>
</li>
</ul>
<h3 id="2-扩展类的加载器"><a href="#2-扩展类的加载器" class="headerlink" title="2) 扩展类的加载器"></a>2) 扩展类的加载器</h3><p>如果 classpath 和 JAVA_HOME/jre/lib/ext 下有同名类，加载时会使用<code>拓展类加载器加载</code>。当应用程序类加载器发现拓展类加载器已将该同名类加载过了，则不会再次加载。</p>
<p>上述一样的代码demo</p>
<div class="hljs"><pre><code class="hljs java">bootstrap F init
sun.misc.Launcher$AppClassLoader@18b4aac2</code></pre></div>

<p>如果写一个同名的类</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">F</span> </span>&#123;
    <span class="hljs-keyword">static</span> &#123;
        System.out.println(<span class="hljs-string">&quot;Extension F init&quot;</span>);
    &#125;
&#125;</code></pre></div>

<p>打个 jar 包</p>
<div class="hljs"><pre><code class="hljs ruby">jar -cvf my.jar com.qiuke.jvm.class03.load.F.<span class="hljs-keyword">class</span>
已添加清单
正在添加: com.qiuke.jvm.class03.load.F.CLASS(输入 = <span class="hljs-number">481</span>) (输出 = <span class="hljs-number">322</span>)(压缩了 <span class="hljs-number">33</span>%)</code></pre></div>

<p>将 jar 包拷贝到 JAVA_HOME/jre/lib/ext<br>重新执行 Load5_2<br>输出</p>
<div class="hljs"><pre><code class="hljs ruby">ext G init
sun.misc.Launcher$ExtClassLoader<span class="hljs-variable">@29453f4</span>4</code></pre></div>



<h3 id="3-双亲委派模式"><a href="#3-双亲委派模式" class="headerlink" title="3) 双亲委派模式"></a>3) 双亲委派模式</h3><p>所谓的双亲委派，就是指调用类加载器的 loadClass 方法时，查找类的规则</p>
<blockquote>
<p>双亲翻译为上级更合体，没有继承关系</p>
</blockquote>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="hljs-keyword">boolean</span> resolve)
    <span class="hljs-keyword">throws</span> ClassNotFoundException
&#123;
    <span class="hljs-keyword">synchronized</span> (getClassLoadingLock(name)) &#123;
        <span class="hljs-comment">// 1.首先查找该类是否已经被该类加载器加载过了</span>
        Class&lt;?&gt; c = findLoadedClass(name);
        <span class="hljs-comment">//如果没有被加载过</span>
        <span class="hljs-keyword">if</span> (c == <span class="hljs-keyword">null</span>) &#123;
            <span class="hljs-keyword">long</span> t0 = System.nanoTime();
            <span class="hljs-keyword">try</span> &#123;
                <span class="hljs-comment">// 2. 有上级，委派上级</span>
                <span class="hljs-comment">//看是否被它的上级加载器加载过了 Extension的上级是Bootstarp，但它显示为null</span>
                <span class="hljs-keyword">if</span> (parent != <span class="hljs-keyword">null</span>) &#123;
                    c = parent.loadClass(name, <span class="hljs-keyword">false</span>);
                &#125; <span class="hljs-keyword">else</span> &#123;
                    <span class="hljs-comment">// 3. 没有上级，委派bootstrap</span>
                    <span class="hljs-comment">//看是否被启动类加载器加载过</span>
                    c = findBootstrapClassOrNull(name);
                &#125;
            &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;
                <span class="hljs-comment">// ClassNotFoundException thrown if class not found</span>
                <span class="hljs-comment">// from the non-null parent class loader</span>
                <span class="hljs-comment">//捕获异常，但不做任何处理</span>
            &#125;

            <span class="hljs-keyword">if</span> (c == <span class="hljs-keyword">null</span>) &#123;
                <span class="hljs-comment">//4. 如果还是没有找到，先让拓展类加载器调用findClass方法去找到该类，如果还是没找到，就抛出异常</span>
                <span class="hljs-keyword">long</span> t1 = System.nanoTime();
                c = findClass(name);

                <span class="hljs-comment">// 5. 记录时间</span>
                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);
                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
                sun.misc.PerfCounter.getFindClasses().increment();
            &#125;
        &#125;
        <span class="hljs-keyword">if</span> (resolve) &#123;
            resolveClass(c);
        &#125;
        <span class="hljs-keyword">return</span> c;
    &#125;
&#125;</code></pre></div>



<p>逐步分析：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Load5_3</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException </span>&#123;
        System.out.println(Load5_3.class.getClassLoader());
        Class&lt;?&gt; aClass = Load5_3.class.getClassLoader().loadClass(<span class="hljs-string">&quot;cn.itcast.jvm.t3.load.H&quot;</span>);
        System.out.println(aClass.getClassLoader());

    &#125;
&#125;</code></pre></div>

<ol>
<li><p>sun.misc.Launcher$AppClassLoader //1 处， 开始查看已加载的类，结果没有</p>
</li>
<li><p>sun.misc.Launcher$AppClassLoader // 2 处，委派上级<br>sun.misc.Launcher$ExtClassLoader.loadClass()</p>
</li>
<li><p>sun.misc.Launcher$ExtClassLoader // 1 处，查看已加载的类，结果没有</p>
</li>
<li><p>委派上级sun.misc.Launcher$BootstrapClassLoader.loadClass()</p>
</li>
<li><p>BootstrapClassLoader 是在 JAVA_HOME/jre/lib 下找 H 这个类，显然没有</p>
</li>
<li><p>sun.misc.Launcher$ExtClassLoader // 4 处，调用自己的 findClass 方法，是在<br>JAVA_HOME/jre/lib/ext 下找 H 这个类，<code>显然没有(抛异常)</code>，回到 sun.misc.Launcher$AppClassLoader<br>的 // 2 处</p>
</li>
<li><p>继续执行到 sun.misc.Launcher$AppClassLoader // 4 处，调用它自己的 findClass 方法，在<br>classpath 下查找，找到了</p>
</li>
</ol>
<p>总体：先往上找有没有已经加载，再从最上层往下加载</p>
<h3 id="4-线程上下文类加载器"><a href="#4-线程上下文类加载器" class="headerlink" title="4) 线程上下文类加载器"></a>4) 线程上下文类加载器</h3><p>我们在使用 JDBC 时，都需要加载 Driver 驱动，不知道你注意到没有，不写</p>
<div class="hljs"><pre><code class="hljs java">Class.forName(<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>)</code></pre></div>

<p>也是可以让 <code>com.mysql.jdbc.Driver</code> 正确加载的，你知道是怎么做的吗？<br>让我们追踪一下源码：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DriverManager</span> </span>&#123;
  <span class="hljs-comment">// 注册驱动的集合</span>
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> CopyOnWriteArrayList&lt;DriverInfo&gt; registeredDrivers
  = <span class="hljs-keyword">new</span> CopyOnWriteArrayList&lt;&gt;();
  <span class="hljs-comment">// 初始化驱动</span>
  <span class="hljs-keyword">static</span> &#123;
    loadInitialDrivers();
    println(<span class="hljs-string">&quot;JDBC DriverManager initialized&quot;</span>);
&#125;</code></pre></div>

<p>先不看别的，看看 DriverManager 的类加载器：</p>
<div class="hljs"><pre><code class="hljs java">System.out.println(DriverManager.class.getClassLoader());</code></pre></div>

<p>打印 null，表示它的类加载器是 Bootstrap ClassLoader，会到 JAVA_HOME/jre/lib 下搜索类，但<br>JAVA_HOME/jre/lib 下显然没有 mysql-connector-java-5.1.47.jar 包，这样问题来了，在<br>DriverManager 的静态代码块中，怎么能正确加载 com.mysql.jdbc.Driver 呢？<br>继续看 loadInitialDrivers() 方法：</p>
<ol>
<li>使用ServiceLoader机制加载驱动</li>
<li>使用 jdbc.drivers 定义的驱动名加载驱动</li>
</ol>
<p>先看 2）发现它最后是使用 <code>Class.forName</code> 完成类的加载和初始化，关联的是<code>应用程序类加载器</code>，因此<br>可以顺利完成类加载<br>再看 1）它就是大名鼎鼎的<code> Service Provider Interface （SPI）</code><br>约定如下，在 jar 包的 META-INF/services 包下，以接口全限定名名为文件，文件内容是实现类名称</p>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20210510100657.png" srcset="/img/loading.gif"></p>
<p>这样就可以使用</p>
<div class="hljs"><pre><code class="hljs java">ServiceLoader&lt;接口类型&gt; allImpls = ServiceLoader.load(接口类型.class);
Iterator&lt;接口类型&gt; iter = allImpls.iterator();
<span class="hljs-keyword">while</span>(iter.hasNext()) &#123;
iter.next();
&#125;</code></pre></div>

<p>来得到实现类，体现的是【面向接口编程+解耦】的思想，在下面一些框架中都运用了此思想：</p>
<ul>
<li><p>JDBC</p>
</li>
<li><p>Servlet 初始化器</p>
</li>
<li><p>Spring 容器</p>
</li>
<li><p>Dubbo（对 SPI 进行了扩展）</p>
<p>接着看 ServiceLoader.load 方法：</p>
</li>
</ul>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;S&gt; <span class="hljs-function">ServiceLoader&lt;S&gt; <span class="hljs-title">load</span><span class="hljs-params">(Class&lt;S&gt; service)</span> </span>&#123;
<span class="hljs-comment">// 获取线程上下文类加载器</span>
ClassLoader cl = Thread.currentThread().getContextClassLoader();
<span class="hljs-keyword">return</span> ServiceLoader.load(service, cl);
&#125;</code></pre></div>

<p>线程上下文类加载器是<code>当前线程使用的类加载器</code>，默认就是<code>应用程序类加载器</code>，它内部又是由<br>Class.forName 调用了线程上下文类加载器完成类加载，具体代码在 ServiceLoader 的内部类<br>LazyIterator 中：</p>
<h3 id="5-自定义类加载器"><a href="#5-自定义类加载器" class="headerlink" title="5) 自定义类加载器"></a>5) 自定义类加载器</h3><blockquote>
<p>使用场景</p>
</blockquote>
<ul>
<li>想加载非 classpath 随意路径中的类文件</li>
<li>通过接口来使用实现，希望解耦时，常用在框架设计</li>
<li>这些类希望予以隔离，不同应用的同名类都可以加载，不冲突，常见于 tomcat 容器</li>
</ul>
<blockquote>
<p>步骤</p>
</blockquote>
<ul>
<li>继承 ClassLoader 父类</li>
<li>要遵从双亲委派机制，重写 ﬁndClass 方法<ul>
<li>不是重写 loadClass 方法，否则不会走双亲委派机制</li>
</ul>
</li>
<li>读取类文件的字节码</li>
<li>调用父类的 deﬁneClass 方法来加载类</li>
<li>使用者调用该类加载器的 loadClass 方法</li>
</ul>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClassLoader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ClassLoader</span> </span>&#123;

    <span class="hljs-meta">@Override</span> <span class="hljs-comment">// name 就是类名称</span>
    <span class="hljs-keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;
        String path = <span class="hljs-string">&quot;e:\\myclasspath\\&quot;</span> + name + <span class="hljs-string">&quot;.class&quot;</span>;

        <span class="hljs-keyword">try</span> &#123;
            ByteArrayOutputStream os = <span class="hljs-keyword">new</span> ByteArrayOutputStream();
            Files.copy(Paths.get(path), os);

            <span class="hljs-comment">// 得到字节数组</span>
            <span class="hljs-keyword">byte</span>[] bytes = os.toByteArray();

            <span class="hljs-comment">// byte[] -&gt; *.class</span>
            <span class="hljs-keyword">return</span> defineClass(name, bytes, <span class="hljs-number">0</span>, bytes.length);

        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;
            e.printStackTrace();
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ClassNotFoundException(<span class="hljs-string">&quot;类文件未找到&quot;</span>, e);
        &#125;
    &#125;
&#125;</code></pre></div>

<h3 id="6-破坏双亲委派模式"><a href="#6-破坏双亲委派模式" class="headerlink" title="6) 破坏双亲委派模式"></a>6) 破坏双亲委派模式</h3><ul>
<li>双亲委派模型的第一次“被破坏”其实发生在双亲委派模型出现之前——即JDK1.2面世以前的“远古”时代<ul>
<li>建议用户重写findClass()方法，在类加载器中的loadClass()方法中也会调用该方法</li>
</ul>
</li>
<li>双亲委派模型的第二次“被破坏”是由这个模型自身的缺陷导致的<ul>
<li>如果有基础类型又要调用回用户的代码，此时也会破坏双亲委派模式</li>
</ul>
</li>
<li>双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求而导致的<ul>
<li>这里所说的“动态性”指的是一些非常“热”门的名词：代码热替换（Hot Swap）、模块热部署（Hot Deployment）等</li>
</ul>
</li>
</ul>
<h2 id="6、运行期优化"><a href="#6、运行期优化" class="headerlink" title="6、运行期优化"></a>6、运行期优化</h2><h3 id="1-即时编译"><a href="#1-即时编译" class="headerlink" title="1) 即时编译"></a>1) 即时编译</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JIT1</span> </span>&#123;

    <span class="hljs-comment">// -XX:+PrintCompilation -XX:-DoEscapeAnalysis</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">200</span>; i++) &#123;
            <span class="hljs-keyword">long</span> start = System.nanoTime();
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">1000</span>; j++) &#123;
                <span class="hljs-keyword">new</span> Object();
            &#125;
            <span class="hljs-keyword">long</span> end = System.nanoTime();
            System.out.printf(<span class="hljs-string">&quot;%d\t%d\n&quot;</span>,i,(end - start));
        &#125;
    &#125;
&#125;</code></pre></div>

<p>时间逐渐减小；</p>
<p>JVM 将执行状态分成了<code> 5 个层次：</code></p>
<ul>
<li>0层：<code>解释执行</code>，用<code>解释器</code>将字节码翻译为机器码</li>
<li>1层：使用 C1 <strong>即时编译器</strong> 编译执行（不带 proﬁling）</li>
<li>2层：使用 C1 即时编译器编译执行（带基本的profiling）</li>
<li>3层：使用 C1 即时编译器编译执行（带完全的profiling）</li>
<li>4层：使用 C2 即时编译器编译执行</li>
</ul>
<blockquote>
<p> proﬁling 是指在运行过程中收集一些程序执行状态的数据，例如【方法的调用次数】，【循环的 回边次数】等</p>
</blockquote>
<h4 id="即时编译器（JIT）与解释器的区别"><a href="#即时编译器（JIT）与解释器的区别" class="headerlink" title="即时编译器（JIT）与解释器的区别"></a>即时编译器（JIT）与解释器的区别</h4><ul>
<li>解释器<ul>
<li>将字节码 <strong>解释</strong> 为机器码，下次即使遇到相同的字节码，仍会执行重复的解释</li>
<li>是将字节码解释为针对所有平台都通用的机器码</li>
</ul>
</li>
<li>即时编译器<ul>
<li>将一些字节码 <strong>编译</strong> 为机器码， <strong>并存入 Code Cache</strong> ，下次遇到相同的代码，直接执行，无需再编译</li>
<li>根据平台类型，<code>生成平台特定的机器码</code></li>
</ul>
</li>
</ul>
<p>对于大部分的不常用的代码，我们无需耗费时间将其编译成机器码，而是采取解释执行的方式运行；另一方面，对于仅占据小部分的<code>热点代码</code>，我们则可以将其编译成机器码，以达到理想的运行速度。 执行效率上简单比较一下 Interpreter &lt; C1 &lt; C2，总的目标是<code>发现热点代码（hotspot名称的由来）</code>，并优化这些热点代码</p>
<h4 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h4><p>刚才的一种优化手段称之为【逃逸分析】，发现新建的对象是否逃逸。简单来讲就是，Java Hotspot 虚拟机可以分析新创建对象的使用范围，并决定是否在 Java 堆上分配内存的一项技术。可以使用 -XX:-<br>DoEscapeAnalysis 关闭逃逸分析，再运行刚才的示例观察结果</p>
<p>参考资料：<a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/12/vm/java-hotspot-virtual-machine">https://docs.oracle.com/en/java/javase/12/vm/java-hotspot-virtual-machine</a><br>performance-enhancements.html#GUID-D2E3DC58-D18B-4A6C-8167-4A1DFB4888E4</p>
<p>  <strong>全局逃逸（GlobalEscape）</strong>  </p>
<ul>
<li>即一个对象的作用范围逃出了当前方法或者当前线程，有以下几种场景：<ul>
<li>对象是一个静态变量</li>
<li>对象是一个已经发生逃逸的对象</li>
<li>对象作为当前方法的返回值</li>
</ul>
</li>
</ul>
<p> <strong>参数逃逸（ArgEscape）</strong> </p>
<ul>
<li>即一个对象被作为方法参数传递或者被参数引用，但在调用过程中不会发生全局逃逸，这个状态是通过被调方法的字节码确定的</li>
</ul>
<p> <strong>没有逃逸</strong> </p>
<ul>
<li>即方法中的对象没有发生逃逸</li>
</ul>
<p><strong>逃逸分析优化</strong></p>
<p>针对上面第三点，当一个对象 <strong>没有逃逸</strong> 时，可以得到以下几个虚拟机的优化</p>
<p> <strong>锁消除</strong> </p>
<p>我们知道线程同步锁是非常牺牲性能的，当编译器确定当前对象只有当前线程使用，那么就会移除该对象的同步锁</p>
<p>例如，StringBuffer 和 Vector 都是用 synchronized 修饰线程安全的，但大部分情况下，它们都只是在当前线程中用到，这样编译器就会优化移除掉这些锁操作</p>
<p>锁消除的 JVM 参数如下：</p>
<ul>
<li>开启锁消除：-XX:+EliminateLocks</li>
<li>关闭锁消除：-XX:-EliminateLocks</li>
</ul>
<p>锁消除在 JDK8 中都是默认开启的，并且锁消除都要建立在逃逸分析的基础上</p>
<p> <strong>标量替换</strong> </p>
<p>首先要明白标量和聚合量， <strong>基础类型</strong> 和 <strong>对象的引用</strong> 可以理解为<strong>标量</strong>，它们不能被进一步分解。而能被进一步分解的量就是聚合量，比如：对象</p>
<p>对象是聚合量，它又可以被进一步分解成标量，将其成员变量分解为分散的变量，这就叫做 <strong>标量替换</strong> 。</p>
<p>这样，如果一个对象没有发生逃逸，那压根就不用创建它，只会在栈或者寄存器上创建它用到的成员标量，节省了内存空间，也提升了应用程序性能</p>
<p>标量替换的 JVM 参数如下：</p>
<ul>
<li>开启标量替换：-XX:+EliminateAllocations</li>
<li>关闭标量替换：-XX:-EliminateAllocations</li>
<li>显示标量替换详情：-XX:+PrintEliminateAllocations</li>
</ul>
<p>标量替换同样在 JDK8 中都是默认开启的，并且都要建立在逃逸分析的基础上</p>
<p> <strong>栈上分配</strong> </p>
<p>当对象没有发生逃逸时，该 <strong>对象</strong> 就可以通过标量替换分解成成员标量分配在 <strong>栈内存</strong> 中，和方法的生命周期一致，随着栈帧出栈时销毁，减少了 GC 压力，提高了应用程序性能</p>
<h4 id="方法内联"><a href="#方法内联" class="headerlink" title="方法内联"></a>方法内联</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">square</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> i)</span> </span>&#123;
<span class="hljs-keyword">return</span> i * i;
&#125;</code></pre></div>

<div class="hljs"><pre><code class="hljs java">System.out.println(square(<span class="hljs-number">9</span>));</code></pre></div>

<p>如果发现 square 是热点方法，并且长度不太长时，会进行内联，所谓的内联就是把方法内代码拷贝、<br>粘贴到调用者的位置：</p>
<div class="hljs"><pre><code class="hljs java">System.out.println(<span class="hljs-number">9</span> * <span class="hljs-number">9</span>);</code></pre></div>

<p>还能够进行常量折叠（constant folding）的优化</p>
<p>内联函数就是在程序编译时，编译器将程序中出现的内联函数的调用表达式用内联函数的函数体来直接进行替换</p>
<p>C++是否为内联函数由自己决定，Java由 <strong>编译器决定</strong> 。Java不支持直接声明为内联函数的，如果想让他内联，你只能够向编译器提出请求: 关键字 <strong>final修饰</strong> 用来指明那个函数是希望被JVM内联的，如</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span> </span>&#123;  
        <span class="hljs-comment">// to do something  </span>
&#125;</code></pre></div>

<p>总的来说，一般的函数都不会被当做内联函数，只有声明了final后，编译器才会考虑是不是要把你的函数变成内联函数</p>
<p>JVM内建有许多运行时优化。首先 <strong>短方法</strong> 更利于JVM推断。流程更明显，作用域更短，副作用也更明显。如果是长方法JVM可能直接就跪了。</p>
<p>第二个原因则更重要： <strong>方法内联</strong> </p>
<p>如果JVM监测到一些 <strong>小方法被频繁的执行</strong> ，它会把方法的调用替换成方法体本身，如：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">add4</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x1, <span class="hljs-keyword">int</span> x2, <span class="hljs-keyword">int</span> x3, <span class="hljs-keyword">int</span> x4)</span> </span>&#123; 
    <span class="hljs-comment">//这里调用了add2方法</span>
        <span class="hljs-keyword">return</span> add2(x1, x2) + add2(x3, x4);  
    &#125;  

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">add2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x1, <span class="hljs-keyword">int</span> x2)</span> </span>&#123;  
        <span class="hljs-keyword">return</span> x1 + x2;  
    &#125;</code></pre></div>

<p>方法调用被替换后</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">add4</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x1, <span class="hljs-keyword">int</span> x2, <span class="hljs-keyword">int</span> x3, <span class="hljs-keyword">int</span> x4)</span> </span>&#123;  
      <span class="hljs-comment">//被替换为了方法本身</span>
        <span class="hljs-keyword">return</span> x1 + x2 + x3 + x4;  
    &#125;</code></pre></div>


            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/JVM/">JVM</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2020/12/14/Nowcoder%20Community%20Code%20Review/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Nowcoder Community Code Review</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/12/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">
                        <span class="hidden-mobile">设计模式</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments">
                
                

              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":200})
    NProgress.start()
    document.addEventListener('DOMContentLoaded', function() {
      window.NProgress && window.NProgress.inc();
    })
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.staticfile.org/jquery/3.5.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.staticfile.org/tocbot/4.12.0/tocbot.min.js" ></script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>





  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      var inputArea = document.querySelector("#local-search-input");
      inputArea.onclick = function () {
        searchFunc(path, 'local-search-input', 'local-search-result');
        this.onclick = null
      }
    })()
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>



<!-- hexo injector body_end start -->
  <script src="/js/custom.js"></script>
<!-- hexo injector body_end end --></body>
</html>
