

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/imgfavicon.jpg">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  <title>设计模式 - Blog</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.1.2/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.5","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"copy_btn":true,"image_zoom":{"enable":true},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.2.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Fluid</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax=true
         style="background: url('https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/imgdefault.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="设计模式">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2020-12-01 15:32" pubdate>
        2020年12月1日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      6.2k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      82
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">设计模式</h1>
            
            <div class="markdown-body">
              <h1 id="设计模式七大原则"><a href="#设计模式七大原则" class="headerlink" title="设计模式七大原则"></a>设计模式七大原则</h1><h2 id="设计模式的目的"><a href="#设计模式的目的" class="headerlink" title="设计模式的目的"></a>设计模式的目的</h2><blockquote>
<p>编写软件过程中, 程序员面临着来自 <strong><em>耦合性</em></strong>, <strong><em>内聚性</em></strong>, 以及 <strong><em>可维护性</em></strong>, <strong><em>可扩展性</em></strong>, <strong><em>重用性</em></strong>, <strong><em>灵活性</em></strong> 等多方面的挑战, 设计模式是为了让 <strong><em>程序(软件)</em></strong>具有更好的:</p>
</blockquote>
<ol>
<li><p> 代码重用性 (即:相同功能的代码，不用多次编写)</p>
</li>
<li><p> 可读性 (即:编程规范性, 便于其他程序员的阅读和理解)</p>
</li>
<li><p> 可扩展性 (即:当需要增加新的功能时，非常的方便，称为可维护)</p>
</li>
<li><p> 可靠性 (即:当我们增加新的功能后，对原来的功能没有影响)</p>
</li>
<li><p>使程序呈现 <strong><em>高内聚，低耦合</em></strong>的特性</p>
<p> <strong>分享金句</strong>: </p>
<p>设计模式包含了面向对象的精髓，“懂了设计模式，你就懂了面向对象分析和设计(OOA/D)的精要”</p>
<p>Scott Mayers 在其巨著《Effective C++》就曾经说过:C++老手和 C++新手的区别就是前者手背上有很多伤疤</p>
</li>
</ol>
<h2 id="设计模式七大原则-1"><a href="#设计模式七大原则-1" class="headerlink" title="设计模式七大原则"></a>设计模式七大原则</h2><blockquote>
<p>设计模式原则，其实就是 <strong><em>程序员在编程时，应当遵守的原则</em></strong>，也是各种设计模式的基础(即:设计模式为什么这样设计的依据)</p>
</blockquote>
<p>设计模式常用的七大原则有:</p>
<ol>
<li><p>单一职责原则</p>
</li>
<li><p>接口隔离原则</p>
</li>
<li><p>依赖倒转(倒置)原则 </p>
</li>
<li><p>里氏替换原则</p>
</li>
<li><p>开闭原则</p>
</li>
<li><p>迪米特法则</p>
</li>
<li><p>合成复用原则</p>
</li>
</ol>
<h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>​        对类来说的，即一个类应该 <strong><em>只负责一项职责</em></strong>。如类 A 负责两个不同职责:职责 1，职责 2。当职责 1 需求变更 而改变 A 时，可能造成职责 2 执行错误，所以需要将类 A 的 <strong><em>粒度分解</em></strong>为 A1，A2</p>
<h4 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h4><p>以交通工具案例讲解</p>
<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201201195254.png" srcset="/img/loading.gif" alt="test" style="zoom:50%;" />

<p>//  交通工具类<br>// 方式 1<br>// 1)在方式 1 的 run 方法中，违反了 <strong><em>单一职责原则</em></strong><br>// 2)解决的方案非常的简单，根据交通工具运行方法不同，分解成不同类即可</p>
<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201201195739.png" srcset="/img/loading.gif" alt="解耦后" style="zoom:50%;" />

<p>// 方案 2 的分析<br>// 1. 遵守单一职责原则<br>// 2. 但是这样做的改动很大，即将类分解，同时修改客户端 </p>
<p> 改进:直接修改 Vehicle 类，改动的代码会比较少=&gt;方案 3</p>
<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201201200149.png" srcset="/img/loading.gif" alt="方案3" style="zoom:50%;" />

<p>​    // 方式 3 的分析</p>
<p>​    //  1. 这种修改方法没有对原来的类做大的修改，只是增加方法<br>   //   2. 这里虽然没有在类这个级别上遵守单一职责原则，但是在方法级别上，仍然是遵守单一职责</p>
<pre><code>#### 单一职责原则注意事项和细节</code></pre>
<blockquote>
<p>  方法数量足够少，可以在方法级别保持单一职责原则</p>
</blockquote>
<ol>
<li> 降低类的复杂度，一个类只负责一项职责。</li>
<li> 提高类的可读性，可维护性</li>
<li> 降低变更引起的风险</li>
<li> 通常情况下，*<strong>我们应当遵守单一职责原则***，只有 *</strong>逻辑足够简单，才可以在代码级违反单一职责原则***;只有类中方法数量足够少，可以在方法级别保持单一职责原则</li>
</ol>
<h3 id="接口隔离原则-Interface-Segregation-Principle"><a href="#接口隔离原则-Interface-Segregation-Principle" class="headerlink" title="接口隔离原则(Interface Segregation Principle)"></a>接口隔离原则(Interface Segregation Principle)</h3><h4 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h4><ol>
<li><p>客户端不应该依赖它不需要的接口，即 <strong>一个类对另一个类的依赖应该建立在最小的接口</strong>上</p>
<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201201201726.png" srcset="/img/loading.gif" alt="接口隔离原则" style="zoom: 50%;" />

</li>
</ol>
<p>B、D代表实现</p>
<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201201203605.png" srcset="/img/loading.gif" alt="接口实现" style="zoom:50%;" />

<p>​    3.     类A通过接口Interface1依赖类B，类C通过接口Interface1依赖类D，如果接口Interface1对于类A和类C</p>
<p>来说不是最小接口，那么类 B 和类 D 必须去实现他们不需要的方法。 </p>
<p>​    4.    按隔离原则应当这样处理:</p>
<p>​    将接口  **Interface1 拆分为独立的几个接口(这里我们拆分成 3 个接口)**，类 A 和类 C 分别与他们需要的接口建立 依赖关系。也就是采用接口隔离原则</p>
<h4 id="应用实例-1"><a href="#应用实例-1" class="headerlink" title="应用实例"></a>应用实例</h4><ol>
<li>实现方案1+分析说明</li>
</ol>
<pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Interface1</span></span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operation1</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operation2</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operation3</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operation4</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operation5</span><span class="hljs-params">()</span></span>;
&#125;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Interface1</span></span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation1</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;B&quot;</span> + <span class="hljs-number">1</span>);
    &#125;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation2</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;B&quot;</span> + <span class="hljs-number">2</span>);
    &#125;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation3</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;B&quot;</span> + <span class="hljs-number">3</span>);
    &#125;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation4</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;B&quot;</span> + <span class="hljs-number">4</span>);
    &#125;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation5</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;B&quot;</span> + <span class="hljs-number">5</span>);
    &#125;
&#125;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">D</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Interface1</span></span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation1</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;D&quot;</span> + <span class="hljs-number">1</span>);
    &#125;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation2</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;D&quot;</span> + <span class="hljs-number">2</span>);
    &#125;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation3</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;D&quot;</span> + <span class="hljs-number">3</span>);
    &#125;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation4</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;D&quot;</span> + <span class="hljs-number">4</span>);
    &#125;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation5</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;D&quot;</span> + <span class="hljs-number">5</span>);
    &#125;
&#125;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123; <span class="hljs-comment">// A类通过接口Interface1 依赖(使用)B类 但是只会用到1,2,3方法</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">depend1</span><span class="hljs-params">(Interface1 i)</span> </span>&#123;
        i.operation1();
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">depend2</span><span class="hljs-params">(Interface1 i)</span> </span>&#123;
        i.operation2();
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">depend3</span><span class="hljs-params">(Interface1 i)</span> </span>&#123;
        i.operation3();
    &#125;
&#125;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> </span>&#123; <span class="hljs-comment">// C类通过接口Interface1 依赖(使用)D类 但是只会用到1,4,5方法</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">depend1</span><span class="hljs-params">(Interface1 i)</span> </span>&#123;
        i.operation1();
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">depend4</span><span class="hljs-params">(Interface1 i)</span> </span>&#123;
        i.operation4();
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">depend5</span><span class="hljs-params">(Interface1 i)</span> </span>&#123;
        i.operation5();
    &#125;
&#125;</code></pre>

<h4 id="应传统方法的问题和使用接口隔离原则改进"><a href="#应传统方法的问题和使用接口隔离原则改进" class="headerlink" title="应传统方法的问题和使用接口隔离原则改进"></a>应传统方法的问题和使用接口隔离原则改进</h4><ol>
<li><p>类A通过接口Interface1依赖类B，类C通过接口Interface1依赖类D，如果接口Interface1对于类A和类C</p>
<p>来说不是最小接口，那么类 B 和类 D 必须去实现他们不需要的方法</p>
</li>
<li><p>将接口 <strong>Interface1</strong>拆分为独立的几个接口，类A和类C分别与他们需要的接口建立依赖关系。也就是采用接口 隔离原则</p>
<p>接口Interface1中出现的方法，根据实际情况拆分为三个接口</p>
</li>
</ol>
<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201201204019.png" srcset="/img/loading.gif" alt="原理" style="zoom:50%;" />

<img src="../../Library/Application Support/typora-user-images/image-20201201204856491.png" srcset="/img/loading.gif" alt="解耦后" style="zoom:50%;" />

<pre><code class="hljs java"><span class="hljs-comment">// 接口 1</span>
<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Interface1</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operation1</span><span class="hljs-params">()</span></span>; &#125;
<span class="hljs-comment">// 接口 2</span>
<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Interface2</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operation2</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operation3</span><span class="hljs-params">()</span></span>; &#125;
<span class="hljs-comment">// 接口 3</span>
<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Interface3</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operation4</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operation5</span><span class="hljs-params">()</span></span>;
&#125;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Interface1</span>, <span class="hljs-title">Interface2</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation1</span><span class="hljs-params">()</span> </span>&#123; System.out.println(<span class="hljs-string">&quot;B 1&quot;</span>);&#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation2</span><span class="hljs-params">()</span> </span>&#123; System.out.println(<span class="hljs-string">&quot;B 1&quot;</span>);&#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation3</span><span class="hljs-params">()</span> </span>&#123; System.out.println(<span class="hljs-string">&quot;B 3&quot;</span>);&#125;
&#125;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">D</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Interface1</span>, <span class="hljs-title">Interface3</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation1</span><span class="hljs-params">()</span> </span>&#123; System.out.println(<span class="hljs-string">&quot;D 1&quot;</span>);&#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation4</span><span class="hljs-params">()</span> </span>&#123; System.out.println(<span class="hljs-string">&quot;D 4&quot;</span>);&#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation5</span><span class="hljs-params">()</span> </span>&#123; System.out.println(<span class="hljs-string">&quot;D 5&quot;</span>);&#125;
&#125;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123; <span class="hljs-comment">// A 类通过接口 Interface1,Interface2 依赖(使用) B 类，但是只会用到 1,2,3 方法 public void depend1(Interface1 i) &#123;</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">depend1</span><span class="hljs-params">(Interface1 i)</span> </span>&#123; i.operation1(); &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">depend2</span><span class="hljs-params">(Interface2 i)</span> </span>&#123; i.operation2(); &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">depend3</span><span class="hljs-params">(Interface2 i)</span> </span>&#123; i.operation3(); &#125;
&#125;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> </span>&#123; <span class="hljs-comment">// C 类通过接口 Interface1,Interface3 依赖(使用) D 类，但是只会用到 1,4,5 方法 public void depend1(Interface1 i) &#123;</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">depend1</span><span class="hljs-params">(Interface1 i)</span> </span>&#123; i.operation1(); &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">depend4</span><span class="hljs-params">(Interface3 i)</span> </span>&#123; i.operation4(); &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">depend5</span><span class="hljs-params">(Interface3 i)</span> </span>&#123; i.operation5(); &#125;
&#125;</code></pre>

<pre><code class="hljs java">A a = <span class="hljs-keyword">new</span> A();
a.depend1(<span class="hljs-keyword">new</span> B()); <span class="hljs-comment">// A类通过接口去依赖B类</span>
a.depend2(<span class="hljs-keyword">new</span> B());
a.depend3(<span class="hljs-keyword">new</span> B());

C c = <span class="hljs-keyword">new</span> C();
c.depend1(<span class="hljs-keyword">new</span> D()); <span class="hljs-comment">// C类通过接口去依赖D类</span>
c.depend4(<span class="hljs-keyword">new</span> D());
c.depend5(<span class="hljs-keyword">new</span> D());</code></pre>



<h3 id="依赖倒转原则-Dependence-Inversion-Principle"><a href="#依赖倒转原则-Dependence-Inversion-Principle" class="headerlink" title="依赖倒转原则(Dependence Inversion Principle)"></a>依赖倒转原则(Dependence Inversion Principle)</h3><h4 id="基本介绍-2"><a href="#基本介绍-2" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>依赖倒转原则(Dependence Inversion Principle)是指:</p>
<ol>
<li><p> 高层模块不应该依赖低层模块，二者都应该依赖其抽象(抽象类、接口都可以)</p>
</li>
<li><p> <strong><em>抽象不应该依赖细节，细节应该依赖抽象</em></strong></p>
</li>
<li><p> 依赖倒转(倒置)的中心思想是 <strong><em>面向接口编程</em></strong></p>
</li>
<li><p> 依赖倒转原则是基于这样的设计理念:相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架 构比以细节为基础的架构要稳定的多。在 java 中，抽象指的是接口或抽象类，细节就是具体的实现类</p>
</li>
<li><p>使用 <strong><em>接口或抽象类</em></strong>的目的是制定好 <strong><em>规范</em></strong>，而不涉及任何具体的操作，把 <strong><em>展现细节的任务交给他们的实现类</em></strong>去完成</p>
<h4 id="应用实例-2"><a href="#应用实例-2" class="headerlink" title="应用实例"></a>应用实例</h4></li>
</ol>
<p>请编程完成 Person 接收消息 的功能。</p>
<ol>
<li>实现方案1+分析说明</li>
</ol>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DependecyInversion1</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        Person person = <span class="hljs-keyword">new</span> Person();
        person.receive(<span class="hljs-keyword">new</span> Email());
    &#125;
&#125;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Email</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getInfo</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;电子邮件信息: hello,world&quot;</span>; &#125;
&#125;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receive</span><span class="hljs-params">(Email email )</span> </span>&#123; System.out.println(email.getInfo()); &#125;
&#125;</code></pre>

<pre><code class="hljs java"><span class="hljs-comment">//  方式 1 分析</span>
<span class="hljs-number">1.</span> 简单，比较容易想到
<span class="hljs-number">2.</span> 如果我们获取的对象是 微信，短信等等，则新增类，同时 Perons 也要增加相应的接收方法
<span class="hljs-number">3.</span> 解决思路:引入一个抽象的接口 IReceiver, 表示接收者, 这样 Person 类与接口 IReceiver 发生依赖</code></pre>

<ol start="2">
<li>实现方案2+分析说明</li>
</ol>
<pre><code class="hljs java"><span class="hljs-comment">// 定义接口</span>
<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IReceiver</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getInfo</span><span class="hljs-params">()</span></span>;
&#125;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EmailImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IReceiver</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getInfo</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;电子邮件信息: hello,world&quot;</span>;
    &#125;
&#125;
<span class="hljs-comment">//增加微信</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WeiXin</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IReceiver</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getInfo</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;微信信息: hello,ok&quot;</span>;
    &#125;
&#125;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PersonNew</span> </span>&#123;
    <span class="hljs-comment">//这里我们是对接口的依赖</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receive</span><span class="hljs-params">(IReceiver receiver )</span> </span>&#123;
        System.out.println(receiver.getInfo());
    &#125;
&#125;</code></pre>



<h4 id="依赖关系传递的三种方式和应用案例"><a href="#依赖关系传递的三种方式和应用案例" class="headerlink" title="依赖关系传递的三种方式和应用案例"></a>依赖关系传递的三种方式和应用案例</h4><blockquote>
<p>接口传递</p>
</blockquote>
<pre><code class="hljs java"><span class="hljs-comment">// 方式1：通过接口传递实现依赖</span>
<span class="hljs-comment">// 开关的接口</span>
<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IOpenAndClose</span> </span>&#123;
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">open</span><span class="hljs-params">(ITV tv)</span></span>; <span class="hljs-comment">//抽象方法，接收接口</span>
&#125;

<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ITV</span> </span>&#123; <span class="hljs-comment">//ITV接口</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">play</span><span class="hljs-params">()</span></span>;
&#125;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OpenAndClose</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IOpenAndClose</span></span>&#123;
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">open</span><span class="hljs-params">(ITV tv)</span></span>&#123;
   tv.play();
   &#125;
&#125;

<span class="hljs-comment">// 如何使用?</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChangHong</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ITV</span> </span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">play</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;打开changhong TV&quot;</span>);
    &#125;
&#125;
<span class="hljs-comment">// 使用</span>
ChangHong changHong = <span class="hljs-keyword">new</span> ChangHong();
OpenAndClose openAndClose = <span class="hljs-keyword">new</span> OpenAndClose();
openAndClose.open(changHong);</code></pre>

<blockquote>
<p>构造方法传递 </p>
</blockquote>
<pre><code class="hljs java"><span class="hljs-comment">// 方式2：通过构造方法依赖传递</span>
 <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IOpenAndClose</span> </span>&#123;
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">open</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//抽象方法</span>
 &#125;
 <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ITV</span> </span>&#123; <span class="hljs-comment">//ITV接口</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">play</span><span class="hljs-params">()</span></span>;
 &#125;
 <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OpenAndClose</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IOpenAndClose</span></span>&#123;
   <span class="hljs-keyword">public</span> ITV tv; 
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">OpenAndClose</span><span class="hljs-params">(ITV tv)</span></span>&#123; <span class="hljs-comment">//构造器</span>
      <span class="hljs-keyword">this</span>.tv = tv;
   &#125;
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">open</span><span class="hljs-params">()</span></span>&#123;
   <span class="hljs-keyword">this</span>.tv.play();
   &#125;
 &#125;

<span class="hljs-comment">// 如何使用？</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChangHong</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ITV</span> </span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">play</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;打开changhong TV&quot;</span>);
    &#125;
&#125;
<span class="hljs-comment">// 使用：</span>
ChangHong changHong = <span class="hljs-keyword">new</span> ChangHong();
OpenAndClose openAndClose = <span class="hljs-keyword">new</span> OpenAndClose(changHong);
openAndClose.open();</code></pre>

<blockquote>
<p>setter 方式传递</p>
</blockquote>
<pre><code class="hljs java"><span class="hljs-comment">// 方式3：setter方法实现</span>
<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IOpenAndClose</span> </span>&#123;
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">open</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 抽象方法</span>

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setTv</span><span class="hljs-params">(ITV tv)</span></span>;
&#125;

<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ITV</span> </span>&#123; <span class="hljs-comment">// ITV接口</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">play</span><span class="hljs-params">()</span></span>;
&#125;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OpenAndClose</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IOpenAndClose</span> </span>&#123;
   <span class="hljs-keyword">private</span> ITV tv;

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setTv</span><span class="hljs-params">(ITV tv)</span> </span>&#123;
      <span class="hljs-keyword">this</span>.tv = tv;
   &#125;

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">open</span><span class="hljs-params">()</span> </span>&#123;
      <span class="hljs-keyword">this</span>.tv.play();
   &#125;
&#125;

<span class="hljs-comment">// 如何使用？</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChangHong</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ITV</span> </span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">play</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;打开changhong TV&quot;</span>);
    &#125;
&#125;
        ChangHong changHong = <span class="hljs-keyword">new</span> ChangHong();
        OpenAndClose openAndClose = <span class="hljs-keyword">new</span> OpenAndClose();
        openAndClose.setTv(changHong);
        openAndClose.open();</code></pre>



<h4 id="依赖倒转原则的注意事项和细节"><a href="#依赖倒转原则的注意事项和细节" class="headerlink" title="依赖倒转原则的注意事项和细节"></a>依赖倒转原则的注意事项和细节</h4><ol>
<li>  低层模块尽量都要有抽象类或接口，或者两者都有，程序稳定性更好.</li>
<li>   <strong><em>变量的声明类型尽量是抽象类或接口</em></strong>, 这样我们的变量引用和实际对象间，就存在一个 <strong><em>缓冲层</em></strong>，利于程序扩展和优化</li>
<li>  继承时遵循 <strong><em>里氏替换</em></strong>原则</li>
</ol>
<h3 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h3><h4 id="OO-中的继承性的思考和说明"><a href="#OO-中的继承性的思考和说明" class="headerlink" title="OO 中的继承性的思考和说明"></a>OO 中的继承性的思考和说明</h4><ol>
<li>继承包含这样一层含义: <strong>父类中凡是已经实现好的方法，实际上是在设定规范和契约</strong>，虽然它不强制要求所有 的子类必须遵循这些契约，但是如果子类对这些已经实现的方法任意修改，就会对整个继承体系造成破坏。</li>
<li> <strong>继承在给程序设计带来便利的同时，也带来了弊端</strong>。比如使用继承会给程序带来 <strong>侵入性</strong>，程序的可移植性降低， <strong>增加对象间的耦合性</strong>，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且 父类修改后，所有涉及到子类的功能都有可能产生故障</li>
<li>问题提出: <strong>在编程中，如何正确的使用继承?</strong> =&gt;  <strong>里氏替换原则</strong></li>
</ol>
<h4 id="基本介绍-3"><a href="#基本介绍-3" class="headerlink" title="基本介绍"></a>基本介绍</h4><ol>
<li>里氏替换原则(LiskovSubstitutionPrinciple)在1988年，由麻省理工学院的以为姓里的女士提出的。</li>
<li>如果对每个类型为T1的对象o1，都有类型为T2的对象o2，使得以T1定义的所有程序P在所有的对象o1都 代换成 o2 时，程序 P 的行为没有发生变化，那么类型 T2 是类型 T1 的子类型。换句话说， <strong><em>所有引用基类的地 方必须能透明地使用其子类的对象</em></strong>。</li>
<li>在使用继承时，遵循里氏替换原则，在 <strong><em>子类中尽量不要重写父类的方法</em></strong>。</li>
<li>里氏替换原则告诉我们，继承实际上让两个类耦合性增强了，在适当的情况下，可以通过 <strong><em>聚合，组合，依赖</em></strong>来解决问题。</li>
</ol>
<h4 id="一个程序引出的问题和思考"><a href="#一个程序引出的问题和思考" class="headerlink" title="一个程序引出的问题和思考"></a>一个程序引出的问题和思考</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Liskov1</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        A a = <span class="hljs-keyword">new</span> A();
        System.out.println(<span class="hljs-string">&quot;11-3=&quot;</span> + a.func1(<span class="hljs-number">11</span>, <span class="hljs-number">3</span>));
        System.out.println(<span class="hljs-string">&quot;1-8=&quot;</span> + a.func1(<span class="hljs-number">1</span>, <span class="hljs-number">8</span>));
        System.out.println(<span class="hljs-string">&quot;-----------------------&quot;</span>);
        B b = <span class="hljs-keyword">new</span> B();
        System.out.println(<span class="hljs-string">&quot;11-3=&quot;</span> + b.func1(<span class="hljs-number">11</span>, <span class="hljs-number">3</span>));<span class="hljs-comment">//这里本意是求出 11-3</span>
        System.out.println(<span class="hljs-string">&quot;1-8=&quot;</span> + b.func1(<span class="hljs-number">1</span>, <span class="hljs-number">8</span>));
        <span class="hljs-comment">// 1-8</span>
        System.out.println(<span class="hljs-string">&quot;11+3+9=&quot;</span> + b.func2(<span class="hljs-number">11</span>, <span class="hljs-number">3</span>));
    &#125;
&#125;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;
    <span class="hljs-comment">// 返回两个数的差</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">func1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num1, <span class="hljs-keyword">int</span> num2)</span> </span>&#123; <span class="hljs-keyword">return</span> num1 - num2; &#125;
&#125;
<span class="hljs-comment">// B 类继承了 A</span>
<span class="hljs-comment">// 增加了一个新功能:完成两个数相加,然后和 9 求和</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> </span>&#123;
    <span class="hljs-comment">//这里，重写了 A 类的方法, 可能是无意识</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">func1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123; <span class="hljs-keyword">return</span> a + b; &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">func2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123; <span class="hljs-keyword">return</span> func1(a, b) + <span class="hljs-number">9</span>; &#125;
&#125;</code></pre>



<h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><ol>
<li><p>我们发现原来运行正常的相减功能发生了错误。原因就是 <strong><em>类B无意中重写了父类的方法，造成原有功能出现错误</em></strong>。在实际编程中，我们常常会通过重写父类的方法完成新的功能，这样写起来虽然简单，但整个继承体系的复用性会比较差。特别是运行多态比较频繁的时候</p>
</li>
<li><p>通用的做法是: <strong><em>原来的父类和子类都继承一个更通俗的基类，原有的继承关系去掉，采用依赖，聚合，组合等 关系代替</em></strong>.</p>
</li>
</ol>
<pre><code class="hljs java"><span class="hljs-comment">//创建一个更加基础的基类</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span> </span>&#123;
    <span class="hljs-comment">//把更加基础的方法和成员写到 Base 类</span>
&#125;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Base</span></span>&#123;
    <span class="hljs-comment">// 返回两个数的差</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">func1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num1, <span class="hljs-keyword">int</span> num2)</span> </span>&#123; <span class="hljs-keyword">return</span> num1 - num2; &#125;
&#125;
<span class="hljs-comment">// 增加了一个新功能:完成两个数相加,然后和 9 求和</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Base</span> </span>&#123;
    <span class="hljs-comment">//如果 B 需要使用 A 类的方法,使用组合关系</span>
    <span class="hljs-keyword">private</span> A a = <span class="hljs-keyword">new</span> A();
    <span class="hljs-comment">//我们仍然想使用 A 的方法</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">func3</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.a.func1(a, b)&#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">func1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123; <span class="hljs-keyword">return</span> a + b; &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">func2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123; <span class="hljs-keyword">return</span> func1(a, b) + <span class="hljs-number">9</span>; &#125;
&#125;</code></pre>



<h3 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h3><h4 id="基本介绍-4"><a href="#基本介绍-4" class="headerlink" title="基本介绍"></a>基本介绍</h4><ol>
<li><p>开闭原则(OpenClosedPrinciple)是编程中 <strong><em>最基础、最重要</em></strong>的设计原则</p>
</li>
<li><p> 一个软件实体如类，模块和函数应该对 <strong><em>扩展开放(对提供方)，对修改关闭(对使用方)</em></strong>。用抽象构建框架，用实</p>
</li>
</ol>
<p>现扩展细节。</p>
<ol start="3">
<li><p> 当软件需要变化时，尽量 <strong>通过扩展</strong>软件实体的行为来实现变化，而不是 <strong>通过修改</strong>已有的代码来实现变化。</p>
</li>
<li><p>编程中遵循其它原则，以及使用设计模式的目的就是遵循开闭原则。</p>
</li>
</ol>
<h4 id="应用实例-3"><a href="#应用实例-3" class="headerlink" title="应用实例"></a>应用实例</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ocp</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        GraphicEditor graphicEditor = <span class="hljs-keyword">new</span> GraphicEditor();
        graphicEditor.drawShape(<span class="hljs-keyword">new</span> Rectangle());
        graphicEditor.drawShape(<span class="hljs-keyword">new</span> Circle());
        graphicEditor.drawShape(<span class="hljs-keyword">new</span> Triangle());
    &#125;

&#125;

<span class="hljs-comment">//绘图类</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GraphicEditor</span> </span>&#123;
    <span class="hljs-comment">//接受Shape对象 根据m_type绘制图像</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">drawShape</span><span class="hljs-params">(Shape s)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (s.m_type == <span class="hljs-number">1</span>)
            drawRectangle(s);
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s.m_type == <span class="hljs-number">2</span>)
            drawCircle(s);
    &#125;
    
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">drawRectangle</span><span class="hljs-params">(Shape r)</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot; 矩形 &quot;</span>);
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">drawCircle</span><span class="hljs-params">(Shape r)</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot; 圆形 &quot;</span>);
    &#125;
&#125;

<span class="hljs-comment">//Shape类 基类</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Shape</span> </span>&#123;
    <span class="hljs-keyword">int</span> m_type;
&#125;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Shape</span> </span>&#123;
    Rectangle() &#123;
        <span class="hljs-keyword">super</span>.m_type = <span class="hljs-number">1</span>;
    &#125;
&#125;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Shape</span> </span>&#123;
    Circle() &#123;
        <span class="hljs-keyword">super</span>.m_type = <span class="hljs-number">2</span>;
    &#125;
&#125;</code></pre>

<p> 问题出在, 如果要新增一个, 需要修改许多:</p>
<pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Triangle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Shape</span> </span>&#123;
    Triangle() &#123;
        <span class="hljs-keyword">super</span>.m_type = <span class="hljs-number">3</span>;
    &#125;
&#125;
<span class="hljs-comment">// 如果新增 则需要</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">drawTriangle</span><span class="hljs-params">(Shape r)</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;  &quot;</span>);
    &#125;
<span class="hljs-comment">// 还需要</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">drawShape</span><span class="hljs-params">(Shape s)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (s.m_type == <span class="hljs-number">1</span>)
            drawRectangle(s);
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s.m_type == <span class="hljs-number">2</span>)
            drawCircle(s);
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s.m_type == <span class="hljs-number">3</span>)
            drawTriangle(s);
&#125;</code></pre>

<ol>
<li><p>优点是比较好理解，简单易操作。</p>
</li>
<li><p>缺点是 <strong>违反了设计模式的ocp原则</strong>，即对扩展开放(提供方)，对修改关闭(使用方)。即当我们给类增加新功能的时候，尽量不修改代码，或者尽可能少修改代码.</p>
</li>
<li><p>比如我们这时要新增加一个图形种类三角形，我们需要做如上修改，修改的地方较多</p>
</li>
</ol>
<h4 id="改进的思路分析"><a href="#改进的思路分析" class="headerlink" title="改进的思路分析"></a>改进的思路分析</h4><p>思路:把创建 <strong>Shape</strong> 类做成抽象类，并提供一个抽象的 <strong>draw</strong> 方法，让子类去实现即可，这样我们有新的图形 种类时，只需要让新的图形类继承 Shape，并实现 draw 方法即可，使用方的代码就不需要修 -&gt; 满足了开闭原则</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ocp</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;

        GraphicEditor graphicEditor = <span class="hljs-keyword">new</span> GraphicEditor();
        graphicEditor.drawShape(<span class="hljs-keyword">new</span> Rectangle());
        graphicEditor.drawShape(<span class="hljs-keyword">new</span> Circle());
        graphicEditor.drawShape(<span class="hljs-keyword">new</span> Triangle());
        graphicEditor.drawShape(<span class="hljs-keyword">new</span> OtherGraphic());
    &#125;

&#125;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GraphicEditor</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">drawShape</span><span class="hljs-params">(Shape s)</span> </span>&#123;
        s.draw();
    &#125;


&#125;

<span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Shape</span> </span>&#123;
    <span class="hljs-keyword">int</span> m_type;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span></span>;
&#125;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Shape</span> </span>&#123;
    Rectangle() &#123;
        <span class="hljs-keyword">super</span>.m_type = <span class="hljs-number">1</span>;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot; 矩形 &quot;</span>);
    &#125;
&#125;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Shape</span> </span>&#123;
    Circle() &#123;
        <span class="hljs-keyword">super</span>.m_type = <span class="hljs-number">2</span>;
    &#125;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot; 圆形 &quot;</span>);
    &#125;
&#125;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Triangle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Shape</span> </span>&#123;
    Triangle() &#123;
        <span class="hljs-keyword">super</span>.m_type = <span class="hljs-number">3</span>;
    &#125;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-comment">// TODO Auto-generated method stub</span>
        System.out.println(<span class="hljs-string">&quot; 三角形 &quot;</span>);
    &#125;
&#125;


<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OtherGraphic</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Shape</span> </span>&#123;
    OtherGraphic() &#123;
        <span class="hljs-keyword">super</span>.m_type = <span class="hljs-number">4</span>;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-comment">// TODO Auto-generated method stub</span>
        System.out.println(<span class="hljs-string">&quot; 其他 &quot;</span>);
    &#125;
&#125;</code></pre>



<h3 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h3><h4 id="基本介绍-5"><a href="#基本介绍-5" class="headerlink" title="基本介绍"></a>基本介绍</h4><ol>
<li>一个对象应该对其他对象 <strong>保持最少的了解</strong></li>
<li>类与类关系越密切，耦合度越大</li>
<li>迪米特法则(DemeterPrinciple)又叫 <strong>最少知道原则</strong>，即一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类不管多么复杂，都尽量 <strong>将逻辑封装在类的内部</strong>。对外除了提供的 public 方法，不对外泄露任何信息</li>
<li>迪米特法则还有个更简单的定义: <strong>只与直接的朋友通信</strong></li>
<li>直接的朋友:每个对象都会与其他对象有 <strong>耦合关系</strong>，只要两个对象之间有耦合关系，我们就说这两个对象之间 是朋友关系。耦合的方式很多，依赖，关联，组合，聚合等。其中，我们称出现 <strong>成员变量，方法参数，方法返 回值中的类</strong>为直接的朋友，而出现在 <strong>局部变量中的类不是直接的朋友</strong>。也就是说，陌生的类最好不要以局部变 量的形式出现在类的内部。</li>
</ol>
<h4 id="应用实例-4"><a href="#应用实例-4" class="headerlink" title="应用实例"></a>应用实例</h4><ol>
<li><p>有一个学校，下属有各个学院和总部，现要求打印出学校总部员工ID和学院员工的id </p>
</li>
<li><p>编程实现上面的功能, 看代码演示</p>
</li>
<li><p>代码演示</p>
</li>
</ol>
<pre><code class="hljs java"><span class="hljs-comment">//迪米特法则</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demeter1</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        SchoolManager schoolManager = <span class="hljs-keyword">new</span> SchoolManager();
        schoolManager.printAllEmployee(<span class="hljs-keyword">new</span> CollegeManager());
    &#125;

&#125;
<span class="hljs-comment">// 学校总部员工</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span> </span>&#123;
    <span class="hljs-keyword">private</span> String id;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(String id)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.id = id;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> id;
    &#125;
&#125;

<span class="hljs-comment">// 学院员工</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CollegeEmployee</span> </span>&#123;
    <span class="hljs-keyword">private</span> String id;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(String id)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.id = id;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> id;
    &#125;
&#125;

<span class="hljs-comment">// 管理学院员工类</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CollegeManager</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;CollegeEmployee&gt; <span class="hljs-title">getAllEmployee</span><span class="hljs-params">()</span> </span>&#123;
        List&lt;CollegeEmployee&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;CollegeEmployee&gt;();
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;
            CollegeEmployee emp = <span class="hljs-keyword">new</span> CollegeEmployee();
            emp.setId(<span class="hljs-string">&quot;学校员工id= &quot;</span> + i);
            list.add(emp);
        &#125;
        <span class="hljs-keyword">return</span> list;
    &#125;
&#125;
<span class="hljs-comment">// 管理学校员工类</span>
<span class="hljs-comment">//分析 SchoolManager 类的直接朋友类有哪些 Employee、CollegeManager </span>
<span class="hljs-comment">//CollegeEmployee 不是 直接朋友 而是一个陌生类，这样违背了 迪米特法则</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SchoolManager</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Employee&gt; <span class="hljs-title">getAllEmployee</span><span class="hljs-params">()</span> </span>&#123;
        List&lt;Employee&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Employee&gt;();

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;
            Employee emp = <span class="hljs-keyword">new</span> Employee();
            emp.setId(<span class="hljs-string">&quot;学院员工id= &quot;</span> + i);
            list.add(emp);
        &#125;
        <span class="hljs-keyword">return</span> list;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printAllEmployee</span><span class="hljs-params">(CollegeManager sub)</span> </span>&#123;
                <span class="hljs-comment">//分析问题</span>
                <span class="hljs-comment">//1. 这里的 CollegeEmployee 不是 SchoolManager 的直接朋友 </span>
        <span class="hljs-comment">//2. CollegeEmployee 是以局部变量方式出现在 SchoolManager</span>
        <span class="hljs-comment">//3. 违反了 迪米特法则</span>
        List&lt;CollegeEmployee&gt; list1 = sub.getAllEmployee();
        System.out.println(<span class="hljs-string">&quot;------------学院总部------------&quot;</span>);
        <span class="hljs-keyword">for</span> (CollegeEmployee e : list1) &#123;
            System.out.println(e.getId());
        &#125;
        List&lt;Employee&gt; list2 = <span class="hljs-keyword">this</span>.getAllEmployee();
        System.out.println(<span class="hljs-string">&quot;------------学校总部------------&quot;</span>);
        <span class="hljs-keyword">for</span> (Employee e : list2) &#123;
            System.out.println(e.getId());
        &#125;
    &#125;
&#125;</code></pre>

<h4 id="应用实例改进"><a href="#应用实例改进" class="headerlink" title="应用实例改进"></a>应用实例改进</h4><ol>
<li><p>前面设计的问题在于SchoolManager中，<strong>CollegeEmployee</strong>类并不是<strong>SchoolManager</strong>类的直接朋友(分析) </p>
</li>
<li><p>按照迪米特法则，应该避免类中出现这样非直接朋友关系的耦合</p>
</li>
</ol>
<pre><code class="hljs java"><span class="hljs-comment">//迪米特法则</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demeter1</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        SchoolManager schoolManager = <span class="hljs-keyword">new</span> SchoolManager();

        schoolManager.printAllEmployee(<span class="hljs-keyword">new</span> CollegeManager());
    &#125;

&#125;
<span class="hljs-comment">// 学校总部员工</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span> </span>&#123;
    <span class="hljs-keyword">private</span> String id;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(String id)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.id = id;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> id;
    &#125;
&#125;

<span class="hljs-comment">// 学院员工</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CollegeEmployee</span> </span>&#123;
    <span class="hljs-keyword">private</span> String id;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(String id)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.id = id;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> id;
    &#125;
&#125;

<span class="hljs-comment">// 管理学院员工类</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CollegeManager</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;CollegeEmployee&gt; <span class="hljs-title">getAllEmployee</span><span class="hljs-params">()</span> </span>&#123;
        List&lt;CollegeEmployee&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;CollegeEmployee&gt;();
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;
            CollegeEmployee emp = <span class="hljs-keyword">new</span> CollegeEmployee();
            emp.setId(<span class="hljs-string">&quot;学校员工id= &quot;</span> + i);
            list.add(emp);
        &#125;
        <span class="hljs-keyword">return</span> list;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printAllCollegeEmployee</span><span class="hljs-params">()</span></span>&#123;
        <span class="hljs-comment">// 将输出转移到CollegeManager类中</span>
        List&lt;CollegeEmployee&gt; list1 = <span class="hljs-keyword">this</span>.getAllEmployee();
        System.out.println(<span class="hljs-string">&quot;------------学院总部------------&quot;</span>);
        <span class="hljs-keyword">for</span> (CollegeEmployee e : list1) &#123;
            System.out.println(e.getId());
        &#125;
    &#125;
&#125;
<span class="hljs-comment">// 管理学校员工类</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SchoolManager</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Employee&gt; <span class="hljs-title">getAllEmployee</span><span class="hljs-params">()</span> </span>&#123;
        List&lt;Employee&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Employee&gt;();

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;
            Employee emp = <span class="hljs-keyword">new</span> Employee();
            emp.setId(<span class="hljs-string">&quot;学院员工id= &quot;</span> + i);
            list.add(emp);
        &#125;
        <span class="hljs-keyword">return</span> list;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printAllEmployee</span><span class="hljs-params">(CollegeManager sub)</span> </span>&#123;
        <span class="hljs-comment">// 将输出转移到CollegeManager类中</span>
        sub.printAllCollegeEmployee();
        List&lt;Employee&gt; list2 = <span class="hljs-keyword">this</span>.getAllEmployee();
        System.out.println(<span class="hljs-string">&quot;------------学校总部------------&quot;</span>);
        <span class="hljs-keyword">for</span> (Employee e : list2) &#123;
            System.out.println(e.getId());
        &#125;
    &#125;
&#125;</code></pre>

<h4 id="迪米特法则注意事项和细节"><a href="#迪米特法则注意事项和细节" class="headerlink" title="迪米特法则注意事项和细节"></a>迪米特法则注意事项和细节</h4><ol>
<li>迪米特法则的核心是 <strong>降低类之间的耦合</strong></li>
<li>但是注意:由于每个类都减少了不必要的依赖，因此迪米特法则 <strong>只是要求降低类间(对象间)耦合关系，并不是要求完全没有依赖关系</strong></li>
</ol>
<h3 id="合成复用原则-Composite-Reuse-Principle"><a href="#合成复用原则-Composite-Reuse-Principle" class="headerlink" title="合成复用原则(Composite Reuse Principle)"></a>合成复用原则(Composite Reuse Principle)</h3><h4 id="基本介绍-6"><a href="#基本介绍-6" class="headerlink" title="基本介绍"></a>基本介绍</h4><blockquote>
<p>原则是尽量使用合成/聚合的方式，而不是使用继承</p>
</blockquote>
<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201202110642.png" srcset="/img/loading.gif" alt="不使用继承" style="zoom:50%;" />



<h4 id="设计原则核心思想"><a href="#设计原则核心思想" class="headerlink" title="设计原则核心思想"></a>设计原则核心思想</h4><ol>
<li><p>找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。 </p>
</li>
<li><p>针对 <strong>接口编程</strong>，而不是针对实现编程。</p>
</li>
<li><p>为了交互对象之间的 <strong>松耦合设计而努力</strong></p>
</li>
</ol>
<h2 id="UML-基本介绍"><a href="#UML-基本介绍" class="headerlink" title="UML 基本介绍"></a>UML 基本介绍</h2><ul>
<li><p>UML——Unified modeling language UML (统一建模语言)，是一种用于软件系统分析和设计的语言工具，它用 于帮助软件开发人员进行思考和记录思路的结果</p>
</li>
<li><p>UML 本身是一套符号的规定，就像数学符号和化学符号一样，这些符号用于描述软件模型中的各个元素和他 们之间的关系，比如类、接口、实现、泛化、依赖、组合、聚合等，如右图:</p>
</li>
</ul>
<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201202111756.png" srcset="/img/loading.gif" alt="test" style="zoom:50%;" />

<h3 id="类图—依赖关系-Dependence"><a href="#类图—依赖关系-Dependence" class="headerlink" title="类图—依赖关系(Dependence)"></a>类图—依赖关系(Dependence)</h3><blockquote>
<p>只要是在类中用到了对方，那么他们之间就存在依赖关系。如果没有对方，连编绎都通过不了。</p>
</blockquote>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201202112951.png" srcset="/img/loading.gif" alt="依赖"></p>
<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201202113519.png" srcset="/img/loading.gif" alt="依赖关系" style="zoom:50%;" />

<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PersonServiceBean</span> </span>&#123;
<span class="hljs-keyword">private</span> PersonDao personDao;<span class="hljs-comment">//类 public void save(Person person)&#123;&#125;</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> IDCard <span class="hljs-title">getIDCard</span><span class="hljs-params">(Integer personid)</span></span>&#123;&#125; <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">modify</span><span class="hljs-params">()</span></span>&#123;
Department department = <span class="hljs-keyword">new</span> Department(); &#125;
&#125;
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PersonDao</span></span>&#123;&#125; 
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IDCard</span></span>&#123;&#125; 
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;&#125; 
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Department</span></span>&#123;&#125;</code></pre>

<pre><code class="hljs plain">1) 类中用到了对方
2) 如果是类的成员属性 
3) 如果是方法的返回类型 
4) 是方法接收的参数类型 
5) 方法中使用到</code></pre>

<h3 id="类图—泛化关系-generalization"><a href="#类图—泛化关系-generalization" class="headerlink" title="类图—泛化关系(generalization)"></a>类图—泛化关系(generalization)</h3><blockquote>
<p>泛化关系实际上就是继承关系，他是依赖关系的特例</p>
</blockquote>
<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201202113350.png" srcset="/img/loading.gif" alt="依赖关系" style="zoom:50%;" />

<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201202113543.png" srcset="/img/loading.gif" alt="泛化关系" style="zoom:50%;" />

<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DaoSupport</span></span>&#123;
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">save</span><span class="hljs-params">(Object entity)</span></span>&#123; &#125;
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delete</span><span class="hljs-params">(Object id)</span></span>&#123;
&#125;
&#125;
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PersonServiceBean</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Daosupport</span></span>&#123; &#125;</code></pre>

<pre><code class="hljs dns"><span class="hljs-number">1</span>) 泛化关系实际上就是继承关系
<span class="hljs-number">2</span>) 如果<span class="hljs-keyword">A</span>类继承了B类，我们就说<span class="hljs-keyword">A</span>和B存在泛化关系</code></pre>



<h3 id="类图—实现关系-Implementation"><a href="#类图—实现关系-Implementation" class="headerlink" title="类图—实现关系(Implementation)"></a>类图—实现关系(Implementation)</h3><p>实现关系实际上就是 <strong>A</strong> 类实现 <strong>B</strong> 接口，他是 <strong>依赖关系的特例</strong></p>
<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201202113728.png" srcset="/img/loading.gif" alt="实现关系" style="zoom:50%;" />

<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201202113745.png" srcset="/img/loading.gif" alt="实现关系" style="zoom:50%;" />

<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">PersonService</span> </span>&#123;
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delete</span><span class="hljs-params">(Interger id)</span></span>;
&#125;
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PersonServiceBean</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">PersonService</span> </span>&#123; <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delete</span><span class="hljs-params">(Interger id)</span></span>&#123;&#125;
&#125;</code></pre>

<h3 id="类图—关联关系-Association"><a href="#类图—关联关系-Association" class="headerlink" title="类图—关联关系(Association)"></a>类图—关联关系(Association)</h3><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201202113841.png" srcset="/img/loading.gif" alt="关联关系" style="zoom:67%;" />

<h3 id="类图—聚合关系-Aggregation"><a href="#类图—聚合关系-Aggregation" class="headerlink" title="类图—聚合关系(Aggregation)"></a>类图—聚合关系(Aggregation)</h3><h4 id="基本介绍-7"><a href="#基本介绍-7" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>聚合关系(Aggregation)表示的是整体和部分的关系，整体与部分可以分开。聚合关系是关联关系的特例，所以他具有 <strong>关联的导航性与多重性</strong>。</p>
<p>如:一台电脑由键盘(keyboard)、显示器(monitor)，鼠标等组成;组成电脑的各个配件是可以从电脑上分离出来 的，使用带空心菱形的实线来表示:</p>
<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201202114201.png" srcset="/img/loading.gif" alt="聚合" style="zoom:50%;" />

<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201202114230.png" srcset="/img/loading.gif" alt="聚合" style="zoom:50%;" />

<h3 id="类图—组合关系-Composition"><a href="#类图—组合关系-Composition" class="headerlink" title="类图—组合关系(Composition)"></a>类图—组合关系(Composition)</h3><h4 id="基本介绍-8"><a href="#基本介绍-8" class="headerlink" title="基本介绍"></a>基本介绍</h4><blockquote>
<p>组合关系:也是整体与部分的关系，但是整体与部分 <strong><em>不可以分开</em></strong>。</p>
</blockquote>
<p>再看一个案例:在程序中我们定义实体:Person 与 IDCard、Head, 那么 Head 和 Person 就是 组合，IDCard 和 Person 就是聚合。</p>
<p>但是如果在程序中 Person 实体中定义了对 IDCard 进行级联删除，即删除 Person 时连同 IDCard 一起删除，那 么 IDCard 和 Person 就是组合了.</p>
<pre><code class="hljs java">
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;
    <span class="hljs-keyword">private</span> IDCard card; 
    <span class="hljs-keyword">private</span> Head head = <span class="hljs-keyword">new</span> Head(); <span class="hljs-comment">// 注意区别</span>

&#125;</code></pre>



<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201202114443.png" srcset="/img/loading.gif" alt="组合" style="zoom:50%;" />

<p>如果把聚合案例代码改成:</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Computer</span> </span>&#123;
<span class="hljs-keyword">private</span> Mouse mouse = <span class="hljs-keyword">new</span> Mouse(); <span class="hljs-comment">//鼠标可以和 computer 不能分离 </span>
<span class="hljs-keyword">private</span> Moniter moniter = <span class="hljs-keyword">new</span> Moniter();<span class="hljs-comment">//显示器可以和 Computer 不能分离</span>
&#125;</code></pre>



            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/11/27/Java%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">
                        <span class="hidden-mobile">java并发编程 学习笔记</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":200})
    NProgress.start()
    document.addEventListener('DOMContentLoaded', function() {
      window.NProgress && window.NProgress.inc();
    })
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.staticfile.org/jquery/3.5.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.staticfile.org/tocbot/4.12.0/tocbot.min.js" ></script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>





  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      var inputArea = document.querySelector("#local-search-input");
      inputArea.onclick = function () {
        searchFunc(path, 'local-search-input', 'local-search-result');
        this.onclick = null
      }
    })()
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>



</body>
</html>
