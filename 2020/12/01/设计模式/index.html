

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/imgfavicon.jpg">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  <title>设计模式 - Blog</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.1.2/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.5","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"copy_btn":true,"image_zoom":{"enable":true},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.2.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Fluid</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax=true
         style="background: url('https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/imgdefault.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="设计模式">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2020-12-01 15:32" pubdate>
        2020年12月1日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      8.4k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      108
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">设计模式</h1>
            
            <div class="markdown-body">
              <h1 id="设计模式七大原则"><a href="#设计模式七大原则" class="headerlink" title="设计模式七大原则"></a>设计模式七大原则</h1><h2 id="设计模式的目的"><a href="#设计模式的目的" class="headerlink" title="设计模式的目的"></a>设计模式的目的</h2><blockquote>
<p>编写软件过程中, 程序员面临着来自 <strong><em>耦合性</em></strong>, <strong><em>内聚性</em></strong>, 以及 <strong><em>可维护性</em></strong>, <strong><em>可扩展性</em></strong>, <strong><em>重用性</em></strong>, <strong><em>灵活性</em></strong> 等多方面的挑战, 设计模式是为了让 <strong><em>程序(软件)</em></strong>具有更好的:</p>
</blockquote>
<ol>
<li><p> 代码重用性 (即:相同功能的代码，不用多次编写)</p>
</li>
<li><p> 可读性 (即:编程规范性, 便于其他程序员的阅读和理解)</p>
</li>
<li><p> 可扩展性 (即:当需要增加新的功能时，非常的方便，称为可维护)</p>
</li>
<li><p> 可靠性 (即:当我们增加新的功能后，对原来的功能没有影响)</p>
</li>
<li><p>使程序呈现 <strong><em>高内聚，低耦合</em></strong>的特性</p>
<p> <strong>分享金句</strong>: </p>
<p>设计模式包含了面向对象的精髓，“懂了设计模式，你就懂了面向对象分析和设计(OOA/D)的精要”</p>
<p>Scott Mayers 在其巨著《Effective C++》就曾经说过:C++老手和 C++新手的区别就是前者手背上有很多伤疤</p>
</li>
</ol>
<h2 id="设计模式七大原则-1"><a href="#设计模式七大原则-1" class="headerlink" title="设计模式七大原则"></a>设计模式七大原则</h2><blockquote>
<p>设计模式原则，其实就是 <strong><em>程序员在编程时，应当遵守的原则</em></strong>，也是各种设计模式的基础(即:设计模式为什么这样设计的依据)</p>
</blockquote>
<p>设计模式常用的七大原则有:</p>
<ol>
<li><p>单一职责原则</p>
</li>
<li><p>接口隔离原则</p>
</li>
<li><p>依赖倒转(倒置)原则 </p>
</li>
<li><p>里氏替换原则</p>
</li>
<li><p>开闭原则</p>
</li>
<li><p>迪米特法则</p>
</li>
<li><p>合成复用原则</p>
</li>
</ol>
<h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>​        对类来说的，即一个类应该 <strong><em>只负责一项职责</em></strong>。如类 A 负责两个不同职责:职责 1，职责 2。当职责 1 需求变更 而改变 A 时，可能造成职责 2 执行错误，所以需要将类 A 的 <strong><em>粒度分解</em></strong>为 A1，A2</p>
<h4 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h4><p>以交通工具案例讲解</p>
<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201201195254.png" srcset="/img/loading.gif" alt="test" style="zoom:50%;" />

<p>//  交通工具类<br>// 方式 1<br>// 1)在方式 1 的 run 方法中，违反了 <strong><em>单一职责原则</em></strong><br>// 2)解决的方案非常的简单，根据交通工具运行方法不同，分解成不同类即可</p>
<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201201195739.png" srcset="/img/loading.gif" alt="解耦后" style="zoom:50%;" />

<p>// 方案 2 的分析<br>// 1. 遵守单一职责原则<br>// 2. 但是这样做的改动很大，即将类分解，同时修改客户端 </p>
<p> 改进:直接修改 Vehicle 类，改动的代码会比较少=&gt;方案 3</p>
<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201201200149.png" srcset="/img/loading.gif" alt="方案3" style="zoom:50%;" />

<p>​    // 方式 3 的分析</p>
<p>​    //  1. 这种修改方法没有对原来的类做大的修改，只是增加方法<br>   //   2. 这里虽然没有在类这个级别上遵守单一职责原则，但是在方法级别上，仍然是遵守单一职责</p>
<pre><code>#### 单一职责原则注意事项和细节</code></pre>
<blockquote>
<p>  方法数量足够少，可以在方法级别保持单一职责原则</p>
</blockquote>
<ol>
<li> 降低类的复杂度，一个类只负责一项职责。</li>
<li> 提高类的可读性，可维护性</li>
<li> 降低变更引起的风险</li>
<li> 通常情况下， <strong>我们应当遵守单一职责原则</strong>，只有  <strong>逻辑足够简单，才可以在代码级违反单一职责原则</strong>;只有类中方法数量足够少，可以在方法级别保持单一职责原则</li>
</ol>
<h3 id="接口隔离原则-Interface-Segregation-Principle"><a href="#接口隔离原则-Interface-Segregation-Principle" class="headerlink" title="接口隔离原则(Interface Segregation Principle)"></a>接口隔离原则(Interface Segregation Principle)</h3><h4 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h4><ol>
<li><p>客户端不应该依赖它不需要的接口，即 <strong>一个类对另一个类的依赖应该建立在最小的接口</strong>上</p>
<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201201201726.png" srcset="/img/loading.gif" alt="接口隔离原则" style="zoom: 50%;" />

</li>
</ol>
<p>B、D代表实现</p>
<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201201203605.png" srcset="/img/loading.gif" alt="接口实现" style="zoom:50%;" />

<p>​    3.     类A通过接口Interface1依赖类B，类C通过接口Interface1依赖类D，如果接口Interface1对于类A和类C</p>
<p>来说不是最小接口，那么类 B 和类 D 必须去实现他们不需要的方法。 </p>
<p>​    4.    按隔离原则应当这样处理:</p>
<p>​    将接口  Interface1 拆分为独立的几个接口(这里我们拆分成 3 个接口)，类 A 和类 C 分别与他们需要的接口建立 依赖关系。也就是采用接口隔离原则</p>
<h4 id="应用实例-1"><a href="#应用实例-1" class="headerlink" title="应用实例"></a>应用实例</h4><ol>
<li>实现方案1+分析说明</li>
</ol>
<pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Interface1</span></span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operation1</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operation2</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operation3</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operation4</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operation5</span><span class="hljs-params">()</span></span>;
&#125;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Interface1</span></span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation1</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;B&quot;</span> + <span class="hljs-number">1</span>);
    &#125;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation2</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;B&quot;</span> + <span class="hljs-number">2</span>);
    &#125;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation3</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;B&quot;</span> + <span class="hljs-number">3</span>);
    &#125;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation4</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;B&quot;</span> + <span class="hljs-number">4</span>);
    &#125;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation5</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;B&quot;</span> + <span class="hljs-number">5</span>);
    &#125;
&#125;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">D</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Interface1</span></span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation1</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;D&quot;</span> + <span class="hljs-number">1</span>);
    &#125;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation2</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;D&quot;</span> + <span class="hljs-number">2</span>);
    &#125;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation3</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;D&quot;</span> + <span class="hljs-number">3</span>);
    &#125;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation4</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;D&quot;</span> + <span class="hljs-number">4</span>);
    &#125;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation5</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;D&quot;</span> + <span class="hljs-number">5</span>);
    &#125;
&#125;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123; <span class="hljs-comment">// A类通过接口Interface1 依赖(使用)B类 但是只会用到1,2,3方法</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">depend1</span><span class="hljs-params">(Interface1 i)</span> </span>&#123;
        i.operation1();
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">depend2</span><span class="hljs-params">(Interface1 i)</span> </span>&#123;
        i.operation2();
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">depend3</span><span class="hljs-params">(Interface1 i)</span> </span>&#123;
        i.operation3();
    &#125;
&#125;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> </span>&#123; <span class="hljs-comment">// C类通过接口Interface1 依赖(使用)D类 但是只会用到1,4,5方法</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">depend1</span><span class="hljs-params">(Interface1 i)</span> </span>&#123;
        i.operation1();
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">depend4</span><span class="hljs-params">(Interface1 i)</span> </span>&#123;
        i.operation4();
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">depend5</span><span class="hljs-params">(Interface1 i)</span> </span>&#123;
        i.operation5();
    &#125;
&#125;</code></pre>

<h4 id="应传统方法的问题和使用接口隔离原则改进"><a href="#应传统方法的问题和使用接口隔离原则改进" class="headerlink" title="应传统方法的问题和使用接口隔离原则改进"></a>应传统方法的问题和使用接口隔离原则改进</h4><ol>
<li><p>类A通过接口Interface1依赖类B，类C通过接口Interface1依赖类D，如果接口Interface1对于类A和类C</p>
<p>来说不是最小接口，那么类 B 和类 D 必须去实现他们不需要的方法</p>
</li>
<li><p>将接口 <strong>Interface1</strong>拆分为独立的几个接口，类A和类C分别与他们需要的接口建立依赖关系。也就是采用接口 隔离原则</p>
<p>接口Interface1中出现的方法，根据实际情况拆分为三个接口</p>
</li>
</ol>
<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201201204019.png" srcset="/img/loading.gif" alt="原理" style="zoom:50%;" />

<img src="../../Library/Application Support/typora-user-images/image-20201201204856491.png" srcset="/img/loading.gif" alt="解耦后" style="zoom:50%;" />

<pre><code class="hljs java"><span class="hljs-comment">// 接口 1</span>
<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Interface1</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operation1</span><span class="hljs-params">()</span></span>; &#125;
<span class="hljs-comment">// 接口 2</span>
<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Interface2</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operation2</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operation3</span><span class="hljs-params">()</span></span>; &#125;
<span class="hljs-comment">// 接口 3</span>
<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Interface3</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operation4</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operation5</span><span class="hljs-params">()</span></span>;
&#125;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Interface1</span>, <span class="hljs-title">Interface2</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation1</span><span class="hljs-params">()</span> </span>&#123; System.out.println(<span class="hljs-string">&quot;B 1&quot;</span>);&#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation2</span><span class="hljs-params">()</span> </span>&#123; System.out.println(<span class="hljs-string">&quot;B 1&quot;</span>);&#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation3</span><span class="hljs-params">()</span> </span>&#123; System.out.println(<span class="hljs-string">&quot;B 3&quot;</span>);&#125;
&#125;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">D</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Interface1</span>, <span class="hljs-title">Interface3</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation1</span><span class="hljs-params">()</span> </span>&#123; System.out.println(<span class="hljs-string">&quot;D 1&quot;</span>);&#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation4</span><span class="hljs-params">()</span> </span>&#123; System.out.println(<span class="hljs-string">&quot;D 4&quot;</span>);&#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation5</span><span class="hljs-params">()</span> </span>&#123; System.out.println(<span class="hljs-string">&quot;D 5&quot;</span>);&#125;
&#125;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123; <span class="hljs-comment">// A 类通过接口 Interface1,Interface2 依赖(使用) B 类，但是只会用到 1,2,3 方法 public void depend1(Interface1 i) &#123;</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">depend1</span><span class="hljs-params">(Interface1 i)</span> </span>&#123; i.operation1(); &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">depend2</span><span class="hljs-params">(Interface2 i)</span> </span>&#123; i.operation2(); &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">depend3</span><span class="hljs-params">(Interface2 i)</span> </span>&#123; i.operation3(); &#125;
&#125;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> </span>&#123; <span class="hljs-comment">// C 类通过接口 Interface1,Interface3 依赖(使用) D 类，但是只会用到 1,4,5 方法 public void depend1(Interface1 i) &#123;</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">depend1</span><span class="hljs-params">(Interface1 i)</span> </span>&#123; i.operation1(); &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">depend4</span><span class="hljs-params">(Interface3 i)</span> </span>&#123; i.operation4(); &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">depend5</span><span class="hljs-params">(Interface3 i)</span> </span>&#123; i.operation5(); &#125;
&#125;</code></pre>

<pre><code class="hljs java">A a = <span class="hljs-keyword">new</span> A();
a.depend1(<span class="hljs-keyword">new</span> B()); <span class="hljs-comment">// A类通过接口去依赖B类</span>
a.depend2(<span class="hljs-keyword">new</span> B());
a.depend3(<span class="hljs-keyword">new</span> B());

C c = <span class="hljs-keyword">new</span> C();
c.depend1(<span class="hljs-keyword">new</span> D()); <span class="hljs-comment">// C类通过接口去依赖D类</span>
c.depend4(<span class="hljs-keyword">new</span> D());
c.depend5(<span class="hljs-keyword">new</span> D());</code></pre>



<h3 id="依赖倒转原则-Dependence-Inversion-Principle"><a href="#依赖倒转原则-Dependence-Inversion-Principle" class="headerlink" title="依赖倒转原则(Dependence Inversion Principle)"></a>依赖倒转原则(Dependence Inversion Principle)</h3><h4 id="基本介绍-2"><a href="#基本介绍-2" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>依赖倒转原则(Dependence Inversion Principle)是指:</p>
<ol>
<li><p> 高层模块不应该依赖低层模块，二者都应该依赖其抽象(抽象类、接口都可以)</p>
</li>
<li><p> <strong><em>抽象不应该依赖细节，细节应该依赖抽象</em></strong></p>
</li>
<li><p> 依赖倒转(倒置)的中心思想是 <strong><em>面向接口编程</em></strong></p>
</li>
<li><p> 依赖倒转原则是基于这样的设计理念:相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架 构比以细节为基础的架构要稳定的多。在 java 中，抽象指的是接口或抽象类，细节就是具体的实现类</p>
</li>
<li><p>使用 <strong><em>接口或抽象类</em></strong>的目的是制定好 <strong><em>规范</em></strong>，而不涉及任何具体的操作，把 <strong><em>展现细节的任务交给他们的实现类</em></strong>去完成</p>
<h4 id="应用实例-2"><a href="#应用实例-2" class="headerlink" title="应用实例"></a>应用实例</h4></li>
</ol>
<p>请编程完成 Person 接收消息 的功能。</p>
<ol>
<li>实现方案1+分析说明</li>
</ol>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DependecyInversion1</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        Person person = <span class="hljs-keyword">new</span> Person();
        person.receive(<span class="hljs-keyword">new</span> Email());
    &#125;
&#125;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Email</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getInfo</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;电子邮件信息: hello,world&quot;</span>; &#125;
&#125;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receive</span><span class="hljs-params">(Email email )</span> </span>&#123; System.out.println(email.getInfo()); &#125;
&#125;</code></pre>

<pre><code class="hljs java"><span class="hljs-comment">//  方式 1 分析</span>
<span class="hljs-number">1.</span> 简单，比较容易想到
<span class="hljs-number">2.</span> 如果我们获取的对象是 微信，短信等等，则新增类，同时 Perons 也要增加相应的接收方法
<span class="hljs-number">3.</span> 解决思路:引入一个抽象的接口 IReceiver, 表示接收者, 这样 Person 类与接口 IReceiver 发生依赖</code></pre>

<ol start="2">
<li>实现方案2+分析说明</li>
</ol>
<pre><code class="hljs java"><span class="hljs-comment">// 定义接口</span>
<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IReceiver</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getInfo</span><span class="hljs-params">()</span></span>;
&#125;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EmailImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IReceiver</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getInfo</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;电子邮件信息: hello,world&quot;</span>;
    &#125;
&#125;
<span class="hljs-comment">//增加微信</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WeiXin</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IReceiver</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getInfo</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;微信信息: hello,ok&quot;</span>;
    &#125;
&#125;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PersonNew</span> </span>&#123;
    <span class="hljs-comment">//这里我们是对接口的依赖</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receive</span><span class="hljs-params">(IReceiver receiver )</span> </span>&#123;
        System.out.println(receiver.getInfo());
    &#125;
&#125;</code></pre>



<h4 id="依赖关系传递的三种方式和应用案例"><a href="#依赖关系传递的三种方式和应用案例" class="headerlink" title="依赖关系传递的三种方式和应用案例"></a>依赖关系传递的三种方式和应用案例</h4><blockquote>
<p>接口传递</p>
</blockquote>
<pre><code class="hljs java"><span class="hljs-comment">// 方式1：通过接口传递实现依赖</span>
<span class="hljs-comment">// 开关的接口</span>
<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IOpenAndClose</span> </span>&#123;
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">open</span><span class="hljs-params">(ITV tv)</span></span>; <span class="hljs-comment">//抽象方法，接收接口</span>
&#125;

<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ITV</span> </span>&#123; <span class="hljs-comment">//ITV接口</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">play</span><span class="hljs-params">()</span></span>;
&#125;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OpenAndClose</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IOpenAndClose</span></span>&#123;
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">open</span><span class="hljs-params">(ITV tv)</span></span>&#123;
   tv.play();
   &#125;
&#125;

<span class="hljs-comment">// 如何使用?</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChangHong</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ITV</span> </span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">play</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;打开changhong TV&quot;</span>);
    &#125;
&#125;
<span class="hljs-comment">// 使用</span>
ChangHong changHong = <span class="hljs-keyword">new</span> ChangHong();
OpenAndClose openAndClose = <span class="hljs-keyword">new</span> OpenAndClose();
openAndClose.open(changHong);</code></pre>

<blockquote>
<p>构造方法传递 </p>
</blockquote>
<pre><code class="hljs java"><span class="hljs-comment">// 方式2：通过构造方法依赖传递</span>
 <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IOpenAndClose</span> </span>&#123;
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">open</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//抽象方法</span>
 &#125;
 <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ITV</span> </span>&#123; <span class="hljs-comment">//ITV接口</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">play</span><span class="hljs-params">()</span></span>;
 &#125;
 <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OpenAndClose</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IOpenAndClose</span></span>&#123;
   <span class="hljs-keyword">public</span> ITV tv; 
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">OpenAndClose</span><span class="hljs-params">(ITV tv)</span></span>&#123; <span class="hljs-comment">//构造器</span>
      <span class="hljs-keyword">this</span>.tv = tv;
   &#125;
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">open</span><span class="hljs-params">()</span></span>&#123;
   <span class="hljs-keyword">this</span>.tv.play();
   &#125;
 &#125;

<span class="hljs-comment">// 如何使用？</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChangHong</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ITV</span> </span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">play</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;打开changhong TV&quot;</span>);
    &#125;
&#125;
<span class="hljs-comment">// 使用：</span>
ChangHong changHong = <span class="hljs-keyword">new</span> ChangHong();
OpenAndClose openAndClose = <span class="hljs-keyword">new</span> OpenAndClose(changHong);
openAndClose.open();</code></pre>

<blockquote>
<p>setter 方式传递</p>
</blockquote>
<pre><code class="hljs java"><span class="hljs-comment">// 方式3：setter方法实现</span>
<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IOpenAndClose</span> </span>&#123;
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">open</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 抽象方法</span>

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setTv</span><span class="hljs-params">(ITV tv)</span></span>;
&#125;

<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ITV</span> </span>&#123; <span class="hljs-comment">// ITV接口</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">play</span><span class="hljs-params">()</span></span>;
&#125;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OpenAndClose</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IOpenAndClose</span> </span>&#123;
   <span class="hljs-keyword">private</span> ITV tv;

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setTv</span><span class="hljs-params">(ITV tv)</span> </span>&#123;
      <span class="hljs-keyword">this</span>.tv = tv;
   &#125;

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">open</span><span class="hljs-params">()</span> </span>&#123;
      <span class="hljs-keyword">this</span>.tv.play();
   &#125;
&#125;

<span class="hljs-comment">// 如何使用？</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChangHong</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ITV</span> </span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">play</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;打开changhong TV&quot;</span>);
    &#125;
&#125;
        ChangHong changHong = <span class="hljs-keyword">new</span> ChangHong();
        OpenAndClose openAndClose = <span class="hljs-keyword">new</span> OpenAndClose();
        openAndClose.setTv(changHong);
        openAndClose.open();</code></pre>



<h4 id="依赖倒转原则的注意事项和细节"><a href="#依赖倒转原则的注意事项和细节" class="headerlink" title="依赖倒转原则的注意事项和细节"></a>依赖倒转原则的注意事项和细节</h4><ol>
<li>  低层模块尽量都要有抽象类或接口，或者两者都有，程序稳定性更好.</li>
<li>   <strong><em>变量的声明类型尽量是抽象类或接口</em></strong>, 这样我们的变量引用和实际对象间，就存在一个 <strong><em>缓冲层</em></strong>，利于程序扩展和优化</li>
<li>  继承时遵循 <strong><em>里氏替换</em></strong>原则</li>
</ol>
<h3 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h3><h4 id="OO-中的继承性的思考和说明"><a href="#OO-中的继承性的思考和说明" class="headerlink" title="OO 中的继承性的思考和说明"></a>OO 中的继承性的思考和说明</h4><ol>
<li>继承包含这样一层含义: <strong>父类中凡是已经实现好的方法，实际上是在设定规范和契约</strong>，虽然它不强制要求所有 的子类必须遵循这些契约，但是如果子类对这些已经实现的方法任意修改，就会对整个继承体系造成破坏。</li>
<li> <strong>继承在给程序设计带来便利的同时，也带来了弊端</strong>。比如使用继承会给程序带来 <strong>侵入性</strong>，程序的可移植性降低， <strong>增加对象间的耦合性</strong>，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且 父类修改后，所有涉及到子类的功能都有可能产生故障</li>
<li>问题提出: <strong>在编程中，如何正确的使用继承?</strong> =&gt;  <strong>里氏替换原则</strong></li>
</ol>
<h4 id="基本介绍-3"><a href="#基本介绍-3" class="headerlink" title="基本介绍"></a>基本介绍</h4><ol>
<li>里氏替换原则(LiskovSubstitutionPrinciple)在1988年，由麻省理工学院的以为姓里的女士提出的。</li>
<li>如果对每个类型为T1的对象o1，都有类型为T2的对象o2，使得以T1定义的所有程序P在所有的对象o1都 代换成 o2 时，程序 P 的行为没有发生变化，那么类型 T2 是类型 T1 的子类型。换句话说， <strong><em>所有引用基类的地 方必须能透明地使用其子类的对象</em></strong>。</li>
<li>在使用继承时，遵循里氏替换原则，在 <strong><em>子类中尽量不要重写父类的方法</em></strong>。</li>
<li>里氏替换原则告诉我们，继承实际上让两个类耦合性增强了，在适当的情况下，可以通过 <strong><em>聚合，组合，依赖</em></strong>来解决问题。</li>
</ol>
<h4 id="一个程序引出的问题和思考"><a href="#一个程序引出的问题和思考" class="headerlink" title="一个程序引出的问题和思考"></a>一个程序引出的问题和思考</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Liskov1</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        A a = <span class="hljs-keyword">new</span> A();
        System.out.println(<span class="hljs-string">&quot;11-3=&quot;</span> + a.func1(<span class="hljs-number">11</span>, <span class="hljs-number">3</span>));
        System.out.println(<span class="hljs-string">&quot;1-8=&quot;</span> + a.func1(<span class="hljs-number">1</span>, <span class="hljs-number">8</span>));
        System.out.println(<span class="hljs-string">&quot;-----------------------&quot;</span>);
        B b = <span class="hljs-keyword">new</span> B();
        System.out.println(<span class="hljs-string">&quot;11-3=&quot;</span> + b.func1(<span class="hljs-number">11</span>, <span class="hljs-number">3</span>));<span class="hljs-comment">//这里本意是求出 11-3</span>
        System.out.println(<span class="hljs-string">&quot;1-8=&quot;</span> + b.func1(<span class="hljs-number">1</span>, <span class="hljs-number">8</span>));
        <span class="hljs-comment">// 1-8</span>
        System.out.println(<span class="hljs-string">&quot;11+3+9=&quot;</span> + b.func2(<span class="hljs-number">11</span>, <span class="hljs-number">3</span>));
    &#125;
&#125;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;
    <span class="hljs-comment">// 返回两个数的差</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">func1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num1, <span class="hljs-keyword">int</span> num2)</span> </span>&#123; <span class="hljs-keyword">return</span> num1 - num2; &#125;
&#125;
<span class="hljs-comment">// B 类继承了 A</span>
<span class="hljs-comment">// 增加了一个新功能:完成两个数相加,然后和 9 求和</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> </span>&#123;
    <span class="hljs-comment">//这里，重写了 A 类的方法, 可能是无意识</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">func1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123; <span class="hljs-keyword">return</span> a + b; &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">func2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123; <span class="hljs-keyword">return</span> func1(a, b) + <span class="hljs-number">9</span>; &#125;
&#125;</code></pre>



<h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><ol>
<li><p>我们发现原来运行正常的相减功能发生了错误。原因就是 <strong><em>类B无意中重写了父类的方法，造成原有功能出现错误</em></strong>。在实际编程中，我们常常会通过重写父类的方法完成新的功能，这样写起来虽然简单，但整个继承体系的复用性会比较差。特别是运行多态比较频繁的时候</p>
</li>
<li><p>通用的做法是: <strong><em>原来的父类和子类都继承一个更通俗的基类，原有的继承关系去掉，采用依赖，聚合，组合等 关系代替</em></strong>.</p>
</li>
</ol>
<pre><code class="hljs java"><span class="hljs-comment">//创建一个更加基础的基类</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span> </span>&#123;
    <span class="hljs-comment">//把更加基础的方法和成员写到 Base 类</span>
&#125;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Base</span></span>&#123;
    <span class="hljs-comment">// 返回两个数的差</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">func1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num1, <span class="hljs-keyword">int</span> num2)</span> </span>&#123; <span class="hljs-keyword">return</span> num1 - num2; &#125;
&#125;
<span class="hljs-comment">// 增加了一个新功能:完成两个数相加,然后和 9 求和</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Base</span> </span>&#123;
    <span class="hljs-comment">//如果 B 需要使用 A 类的方法,使用组合关系</span>
    <span class="hljs-keyword">private</span> A a = <span class="hljs-keyword">new</span> A();
    <span class="hljs-comment">//我们仍然想使用 A 的方法</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">func3</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.a.func1(a, b)&#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">func1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123; <span class="hljs-keyword">return</span> a + b; &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">func2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123; <span class="hljs-keyword">return</span> func1(a, b) + <span class="hljs-number">9</span>; &#125;
&#125;</code></pre>



<h3 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h3><h4 id="基本介绍-4"><a href="#基本介绍-4" class="headerlink" title="基本介绍"></a>基本介绍</h4><ol>
<li><p>开闭原则(OpenClosedPrinciple)是编程中 <strong><em>最基础、最重要</em></strong>的设计原则</p>
</li>
<li><p> 一个软件实体如类，模块和函数应该对 <strong><em>扩展开放(对提供方)，对修改关闭(对使用方)</em></strong>。用抽象构建框架，用实</p>
</li>
</ol>
<p>现扩展细节。</p>
<ol start="3">
<li><p> 当软件需要变化时，尽量 <strong>通过扩展</strong>软件实体的行为来实现变化，而不是 <strong>通过修改</strong>已有的代码来实现变化。</p>
</li>
<li><p>编程中遵循其它原则，以及使用设计模式的目的就是遵循开闭原则。</p>
</li>
</ol>
<h4 id="应用实例-3"><a href="#应用实例-3" class="headerlink" title="应用实例"></a>应用实例</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ocp</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        GraphicEditor graphicEditor = <span class="hljs-keyword">new</span> GraphicEditor();
        graphicEditor.drawShape(<span class="hljs-keyword">new</span> Rectangle());
        graphicEditor.drawShape(<span class="hljs-keyword">new</span> Circle());
        graphicEditor.drawShape(<span class="hljs-keyword">new</span> Triangle());
    &#125;

&#125;

<span class="hljs-comment">//绘图类</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GraphicEditor</span> </span>&#123;
    <span class="hljs-comment">//接受Shape对象 根据m_type绘制图像</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">drawShape</span><span class="hljs-params">(Shape s)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (s.m_type == <span class="hljs-number">1</span>)
            drawRectangle(s);
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s.m_type == <span class="hljs-number">2</span>)
            drawCircle(s);
    &#125;
    
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">drawRectangle</span><span class="hljs-params">(Shape r)</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot; 矩形 &quot;</span>);
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">drawCircle</span><span class="hljs-params">(Shape r)</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot; 圆形 &quot;</span>);
    &#125;
&#125;

<span class="hljs-comment">//Shape类 基类</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Shape</span> </span>&#123;
    <span class="hljs-keyword">int</span> m_type;
&#125;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Shape</span> </span>&#123;
    Rectangle() &#123;
        <span class="hljs-keyword">super</span>.m_type = <span class="hljs-number">1</span>;
    &#125;
&#125;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Shape</span> </span>&#123;
    Circle() &#123;
        <span class="hljs-keyword">super</span>.m_type = <span class="hljs-number">2</span>;
    &#125;
&#125;</code></pre>

<p> 问题出在, 如果要新增一个, 需要修改许多:</p>
<pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Triangle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Shape</span> </span>&#123;
    Triangle() &#123;
        <span class="hljs-keyword">super</span>.m_type = <span class="hljs-number">3</span>;
    &#125;
&#125;
<span class="hljs-comment">// 如果新增 则需要</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">drawTriangle</span><span class="hljs-params">(Shape r)</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;  &quot;</span>);
    &#125;
<span class="hljs-comment">// 还需要</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">drawShape</span><span class="hljs-params">(Shape s)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (s.m_type == <span class="hljs-number">1</span>)
            drawRectangle(s);
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s.m_type == <span class="hljs-number">2</span>)
            drawCircle(s);
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s.m_type == <span class="hljs-number">3</span>)
            drawTriangle(s);
&#125;</code></pre>

<ol>
<li><p>优点是比较好理解，简单易操作。</p>
</li>
<li><p>缺点是 <strong>违反了设计模式的ocp原则</strong>，即对扩展开放(提供方)，对修改关闭(使用方)。即当我们给类增加新功能的时候，尽量不修改代码，或者尽可能少修改代码.</p>
</li>
<li><p>比如我们这时要新增加一个图形种类三角形，我们需要做如上修改，修改的地方较多</p>
</li>
</ol>
<h4 id="改进的思路分析"><a href="#改进的思路分析" class="headerlink" title="改进的思路分析"></a>改进的思路分析</h4><p>思路:把创建 <strong>Shape</strong> 类做成抽象类，并提供一个抽象的 <strong>draw</strong> 方法，让子类去实现即可，这样我们有新的图形 种类时，只需要让新的图形类继承 Shape，并实现 draw 方法即可，使用方的代码就不需要修 -&gt; 满足了开闭原则</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ocp</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;

        GraphicEditor graphicEditor = <span class="hljs-keyword">new</span> GraphicEditor();
        graphicEditor.drawShape(<span class="hljs-keyword">new</span> Rectangle());
        graphicEditor.drawShape(<span class="hljs-keyword">new</span> Circle());
        graphicEditor.drawShape(<span class="hljs-keyword">new</span> Triangle());
        graphicEditor.drawShape(<span class="hljs-keyword">new</span> OtherGraphic());
    &#125;

&#125;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GraphicEditor</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">drawShape</span><span class="hljs-params">(Shape s)</span> </span>&#123;
        s.draw();
    &#125;


&#125;

<span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Shape</span> </span>&#123;
    <span class="hljs-keyword">int</span> m_type;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span></span>;
&#125;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Shape</span> </span>&#123;
    Rectangle() &#123;
        <span class="hljs-keyword">super</span>.m_type = <span class="hljs-number">1</span>;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot; 矩形 &quot;</span>);
    &#125;
&#125;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Shape</span> </span>&#123;
    Circle() &#123;
        <span class="hljs-keyword">super</span>.m_type = <span class="hljs-number">2</span>;
    &#125;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot; 圆形 &quot;</span>);
    &#125;
&#125;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Triangle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Shape</span> </span>&#123;
    Triangle() &#123;
        <span class="hljs-keyword">super</span>.m_type = <span class="hljs-number">3</span>;
    &#125;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-comment">// TODO Auto-generated method stub</span>
        System.out.println(<span class="hljs-string">&quot; 三角形 &quot;</span>);
    &#125;
&#125;


<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OtherGraphic</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Shape</span> </span>&#123;
    OtherGraphic() &#123;
        <span class="hljs-keyword">super</span>.m_type = <span class="hljs-number">4</span>;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-comment">// TODO Auto-generated method stub</span>
        System.out.println(<span class="hljs-string">&quot; 其他 &quot;</span>);
    &#125;
&#125;</code></pre>



<h3 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h3><h4 id="基本介绍-5"><a href="#基本介绍-5" class="headerlink" title="基本介绍"></a>基本介绍</h4><ol>
<li>一个对象应该对其他对象 <strong>保持最少的了解</strong></li>
<li>类与类关系越密切，耦合度越大</li>
<li>迪米特法则(DemeterPrinciple)又叫 <strong>最少知道原则</strong>，即一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类不管多么复杂，都尽量 <strong>将逻辑封装在类的内部</strong>。对外除了提供的 public 方法，不对外泄露任何信息</li>
<li>迪米特法则还有个更简单的定义: <strong>只与直接的朋友通信</strong></li>
<li>直接的朋友:每个对象都会与其他对象有 <strong>耦合关系</strong>，只要两个对象之间有耦合关系，我们就说这两个对象之间 是朋友关系。耦合的方式很多，依赖，关联，组合，聚合等。其中，我们称出现 <strong>成员变量，方法参数，方法返 回值中的类</strong>为直接的朋友，而出现在 <strong>局部变量中的类不是直接的朋友</strong>。也就是说，陌生的类最好不要以局部变 量的形式出现在类的内部。</li>
</ol>
<h4 id="应用实例-4"><a href="#应用实例-4" class="headerlink" title="应用实例"></a>应用实例</h4><ol>
<li><p>有一个学校，下属有各个学院和总部，现要求打印出学校总部员工ID和学院员工的id </p>
</li>
<li><p>编程实现上面的功能, 看代码演示</p>
</li>
<li><p>代码演示</p>
</li>
</ol>
<pre><code class="hljs java"><span class="hljs-comment">//迪米特法则</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demeter1</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        SchoolManager schoolManager = <span class="hljs-keyword">new</span> SchoolManager();
        schoolManager.printAllEmployee(<span class="hljs-keyword">new</span> CollegeManager());
    &#125;

&#125;
<span class="hljs-comment">// 学校总部员工</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span> </span>&#123;
    <span class="hljs-keyword">private</span> String id;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(String id)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.id = id;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> id;
    &#125;
&#125;

<span class="hljs-comment">// 学院员工</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CollegeEmployee</span> </span>&#123;
    <span class="hljs-keyword">private</span> String id;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(String id)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.id = id;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> id;
    &#125;
&#125;

<span class="hljs-comment">// 管理学院员工类</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CollegeManager</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;CollegeEmployee&gt; <span class="hljs-title">getAllEmployee</span><span class="hljs-params">()</span> </span>&#123;
        List&lt;CollegeEmployee&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;CollegeEmployee&gt;();
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;
            CollegeEmployee emp = <span class="hljs-keyword">new</span> CollegeEmployee();
            emp.setId(<span class="hljs-string">&quot;学校员工id= &quot;</span> + i);
            list.add(emp);
        &#125;
        <span class="hljs-keyword">return</span> list;
    &#125;
&#125;
<span class="hljs-comment">// 管理学校员工类</span>
<span class="hljs-comment">//分析 SchoolManager 类的直接朋友类有哪些 Employee、CollegeManager </span>
<span class="hljs-comment">//CollegeEmployee 不是 直接朋友 而是一个陌生类，这样违背了 迪米特法则</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SchoolManager</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Employee&gt; <span class="hljs-title">getAllEmployee</span><span class="hljs-params">()</span> </span>&#123;
        List&lt;Employee&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Employee&gt;();

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;
            Employee emp = <span class="hljs-keyword">new</span> Employee();
            emp.setId(<span class="hljs-string">&quot;学院员工id= &quot;</span> + i);
            list.add(emp);
        &#125;
        <span class="hljs-keyword">return</span> list;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printAllEmployee</span><span class="hljs-params">(CollegeManager sub)</span> </span>&#123;
                <span class="hljs-comment">//分析问题</span>
                <span class="hljs-comment">//1. 这里的 CollegeEmployee 不是 SchoolManager 的直接朋友 </span>
        <span class="hljs-comment">//2. CollegeEmployee 是以局部变量方式出现在 SchoolManager</span>
        <span class="hljs-comment">//3. 违反了 迪米特法则</span>
        List&lt;CollegeEmployee&gt; list1 = sub.getAllEmployee();
        System.out.println(<span class="hljs-string">&quot;------------学院总部------------&quot;</span>);
        <span class="hljs-keyword">for</span> (CollegeEmployee e : list1) &#123;
            System.out.println(e.getId());
        &#125;
        List&lt;Employee&gt; list2 = <span class="hljs-keyword">this</span>.getAllEmployee();
        System.out.println(<span class="hljs-string">&quot;------------学校总部------------&quot;</span>);
        <span class="hljs-keyword">for</span> (Employee e : list2) &#123;
            System.out.println(e.getId());
        &#125;
    &#125;
&#125;</code></pre>

<h4 id="应用实例改进"><a href="#应用实例改进" class="headerlink" title="应用实例改进"></a>应用实例改进</h4><ol>
<li><p>前面设计的问题在于SchoolManager中，<strong>CollegeEmployee</strong>类并不是<strong>SchoolManager</strong>类的直接朋友(分析) </p>
</li>
<li><p>按照迪米特法则，应该避免类中出现这样非直接朋友关系的耦合</p>
</li>
</ol>
<pre><code class="hljs java"><span class="hljs-comment">//迪米特法则</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demeter1</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        SchoolManager schoolManager = <span class="hljs-keyword">new</span> SchoolManager();

        schoolManager.printAllEmployee(<span class="hljs-keyword">new</span> CollegeManager());
    &#125;

&#125;
<span class="hljs-comment">// 学校总部员工</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span> </span>&#123;
    <span class="hljs-keyword">private</span> String id;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(String id)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.id = id;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> id;
    &#125;
&#125;

<span class="hljs-comment">// 学院员工</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CollegeEmployee</span> </span>&#123;
    <span class="hljs-keyword">private</span> String id;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(String id)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.id = id;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> id;
    &#125;
&#125;

<span class="hljs-comment">// 管理学院员工类</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CollegeManager</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;CollegeEmployee&gt; <span class="hljs-title">getAllEmployee</span><span class="hljs-params">()</span> </span>&#123;
        List&lt;CollegeEmployee&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;CollegeEmployee&gt;();
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;
            CollegeEmployee emp = <span class="hljs-keyword">new</span> CollegeEmployee();
            emp.setId(<span class="hljs-string">&quot;学校员工id= &quot;</span> + i);
            list.add(emp);
        &#125;
        <span class="hljs-keyword">return</span> list;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printAllCollegeEmployee</span><span class="hljs-params">()</span></span>&#123;
        <span class="hljs-comment">// 将输出转移到CollegeManager类中</span>
        List&lt;CollegeEmployee&gt; list1 = <span class="hljs-keyword">this</span>.getAllEmployee();
        System.out.println(<span class="hljs-string">&quot;------------学院总部------------&quot;</span>);
        <span class="hljs-keyword">for</span> (CollegeEmployee e : list1) &#123;
            System.out.println(e.getId());
        &#125;
    &#125;
&#125;
<span class="hljs-comment">// 管理学校员工类</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SchoolManager</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Employee&gt; <span class="hljs-title">getAllEmployee</span><span class="hljs-params">()</span> </span>&#123;
        List&lt;Employee&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Employee&gt;();

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;
            Employee emp = <span class="hljs-keyword">new</span> Employee();
            emp.setId(<span class="hljs-string">&quot;学院员工id= &quot;</span> + i);
            list.add(emp);
        &#125;
        <span class="hljs-keyword">return</span> list;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printAllEmployee</span><span class="hljs-params">(CollegeManager sub)</span> </span>&#123;
        <span class="hljs-comment">// 将输出转移到CollegeManager类中</span>
        sub.printAllCollegeEmployee();
        List&lt;Employee&gt; list2 = <span class="hljs-keyword">this</span>.getAllEmployee();
        System.out.println(<span class="hljs-string">&quot;------------学校总部------------&quot;</span>);
        <span class="hljs-keyword">for</span> (Employee e : list2) &#123;
            System.out.println(e.getId());
        &#125;
    &#125;
&#125;</code></pre>

<h4 id="迪米特法则注意事项和细节"><a href="#迪米特法则注意事项和细节" class="headerlink" title="迪米特法则注意事项和细节"></a>迪米特法则注意事项和细节</h4><ol>
<li>迪米特法则的核心是 <strong>降低类之间的耦合</strong></li>
<li>但是注意:由于每个类都减少了不必要的依赖，因此迪米特法则 <strong>只是要求降低类间(对象间)耦合关系，并不是要求完全没有依赖关系</strong></li>
</ol>
<h3 id="合成复用原则-Composite-Reuse-Principle"><a href="#合成复用原则-Composite-Reuse-Principle" class="headerlink" title="合成复用原则(Composite Reuse Principle)"></a>合成复用原则(Composite Reuse Principle)</h3><h4 id="基本介绍-6"><a href="#基本介绍-6" class="headerlink" title="基本介绍"></a>基本介绍</h4><blockquote>
<p>原则是尽量使用合成/聚合的方式，而不是使用继承</p>
</blockquote>
<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201202110642.png" srcset="/img/loading.gif" alt="不使用继承" style="zoom:50%;" />



<h4 id="设计原则核心思想"><a href="#设计原则核心思想" class="headerlink" title="设计原则核心思想"></a>设计原则核心思想</h4><ol>
<li><p>找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。 </p>
</li>
<li><p>针对 <strong>接口编程</strong>，而不是针对实现编程。</p>
</li>
<li><p>为了交互对象之间的 <strong>松耦合设计而努力</strong></p>
</li>
</ol>
<h2 id="UML-基本介绍"><a href="#UML-基本介绍" class="headerlink" title="UML 基本介绍"></a>UML 基本介绍</h2><ul>
<li><p>UML——Unified modeling language UML (统一建模语言)，是一种用于软件系统分析和设计的语言工具，它用 于帮助软件开发人员进行思考和记录思路的结果</p>
</li>
<li><p>UML 本身是一套符号的规定，就像数学符号和化学符号一样，这些符号用于描述软件模型中的各个元素和他 们之间的关系，比如类、接口、实现、泛化、依赖、组合、聚合等，如右图:</p>
</li>
</ul>
<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201202111756.png" srcset="/img/loading.gif" alt="test" style="zoom:50%;" />

<h3 id="类图—依赖关系-Dependence"><a href="#类图—依赖关系-Dependence" class="headerlink" title="类图—依赖关系(Dependence)"></a>类图—依赖关系(Dependence)</h3><blockquote>
<p>只要是在类中用到了对方，那么他们之间就存在依赖关系。如果没有对方，连编绎都通过不了。</p>
</blockquote>
<p><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201202112951.png" srcset="/img/loading.gif" alt="依赖"></p>
<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201202113519.png" srcset="/img/loading.gif" alt="依赖关系" style="zoom:50%;" />

<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PersonServiceBean</span> </span>&#123;
<span class="hljs-keyword">private</span> PersonDao personDao;<span class="hljs-comment">//类 public void save(Person person)&#123;&#125;</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> IDCard <span class="hljs-title">getIDCard</span><span class="hljs-params">(Integer personid)</span></span>&#123;&#125; <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">modify</span><span class="hljs-params">()</span></span>&#123;
Department department = <span class="hljs-keyword">new</span> Department(); &#125;
&#125;
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PersonDao</span></span>&#123;&#125; 
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IDCard</span></span>&#123;&#125; 
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;&#125; 
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Department</span></span>&#123;&#125;</code></pre>

<pre><code class="hljs plain">1) 类中用到了对方
2) 如果是类的成员属性 
3) 如果是方法的返回类型 
4) 是方法接收的参数类型 
5) 方法中使用到</code></pre>

<h3 id="类图—泛化关系-generalization"><a href="#类图—泛化关系-generalization" class="headerlink" title="类图—泛化关系(generalization)"></a>类图—泛化关系(generalization)</h3><blockquote>
<p>泛化关系实际上就是继承关系，他是依赖关系的特例</p>
</blockquote>
<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201202113350.png" srcset="/img/loading.gif" alt="依赖关系" style="zoom:50%;" />

<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201202113543.png" srcset="/img/loading.gif" alt="泛化关系" style="zoom:50%;" />

<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DaoSupport</span></span>&#123;
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">save</span><span class="hljs-params">(Object entity)</span></span>&#123; &#125;
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delete</span><span class="hljs-params">(Object id)</span></span>&#123;
&#125;
&#125;
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PersonServiceBean</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Daosupport</span></span>&#123; &#125;</code></pre>

<pre><code class="hljs dns"><span class="hljs-number">1</span>) 泛化关系实际上就是继承关系
<span class="hljs-number">2</span>) 如果<span class="hljs-keyword">A</span>类继承了B类，我们就说<span class="hljs-keyword">A</span>和B存在泛化关系</code></pre>



<h3 id="类图—实现关系-Implementation"><a href="#类图—实现关系-Implementation" class="headerlink" title="类图—实现关系(Implementation)"></a>类图—实现关系(Implementation)</h3><p>实现关系实际上就是 <strong>A</strong> 类实现 <strong>B</strong> 接口，他是 <strong>依赖关系的特例</strong></p>
<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201202113728.png" srcset="/img/loading.gif" alt="实现关系" style="zoom:50%;" />

<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201202113745.png" srcset="/img/loading.gif" alt="实现关系" style="zoom:50%;" />

<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">PersonService</span> </span>&#123;
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delete</span><span class="hljs-params">(Interger id)</span></span>;
&#125;
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PersonServiceBean</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">PersonService</span> </span>&#123; <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delete</span><span class="hljs-params">(Interger id)</span></span>&#123;&#125;
&#125;</code></pre>

<h3 id="类图—关联关系-Association"><a href="#类图—关联关系-Association" class="headerlink" title="类图—关联关系(Association)"></a>类图—关联关系(Association)</h3><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201202113841.png" srcset="/img/loading.gif" alt="关联关系" style="zoom:67%;" />

<h3 id="类图—聚合关系-Aggregation"><a href="#类图—聚合关系-Aggregation" class="headerlink" title="类图—聚合关系(Aggregation)"></a>类图—聚合关系(Aggregation)</h3><h4 id="基本介绍-7"><a href="#基本介绍-7" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>聚合关系(Aggregation)表示的是整体和部分的关系，整体与部分可以分开。聚合关系是关联关系的特例，所以他具有 <strong>关联的导航性与多重性</strong>。</p>
<p>如:一台电脑由键盘(keyboard)、显示器(monitor)，鼠标等组成;组成电脑的各个配件是可以从电脑上分离出来 的，使用带空心菱形的实线来表示:</p>
<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201202114201.png" srcset="/img/loading.gif" alt="聚合" style="zoom:50%;" />

<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201202114230.png" srcset="/img/loading.gif" alt="聚合" style="zoom:50%;" />

<h3 id="类图—组合关系-Composition"><a href="#类图—组合关系-Composition" class="headerlink" title="类图—组合关系(Composition)"></a>类图—组合关系(Composition)</h3><h4 id="基本介绍-8"><a href="#基本介绍-8" class="headerlink" title="基本介绍"></a>基本介绍</h4><blockquote>
<p>组合关系:也是整体与部分的关系，但是整体与部分 <strong><em>不可以分开</em></strong>。</p>
</blockquote>
<p>再看一个案例:在程序中我们定义实体:Person 与 IDCard、Head, 那么 Head 和 Person 就是 组合，IDCard 和 Person 就是聚合。</p>
<p>但是如果在程序中 Person 实体中定义了对 IDCard 进行级联删除，即删除 Person 时连同 IDCard 一起删除，那 么 IDCard 和 Person 就是组合了.</p>
<pre><code class="hljs java">
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;
    <span class="hljs-keyword">private</span> IDCard card; 
    <span class="hljs-keyword">private</span> Head head = <span class="hljs-keyword">new</span> Head(); <span class="hljs-comment">// 注意区别</span>

&#125;</code></pre>



<img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201202114443.png" srcset="/img/loading.gif" alt="组合" style="zoom:50%;" />

<p>如果把聚合案例代码改成:</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Computer</span> </span>&#123;
<span class="hljs-keyword">private</span> Mouse mouse = <span class="hljs-keyword">new</span> Mouse(); <span class="hljs-comment">//鼠标可以和 computer 不能分离 </span>
<span class="hljs-keyword">private</span> Moniter moniter = <span class="hljs-keyword">new</span> Moniter();<span class="hljs-comment">//显示器可以和 Computer 不能分离</span>
&#125;</code></pre>



<h2 id="设计模式介绍"><a href="#设计模式介绍" class="headerlink" title="设计模式介绍"></a>设计模式介绍</h2><ol>
<li>设计模式是程序员在面对同类软件工程设计问题所总结出来的有用的经验， <strong>模式不是代码</strong>，而是某类问题的通 用解决方案， <strong>设计模式(Design pattern)代表了最佳的实践</strong>。这些解决方案是众多软件开发人员经过相当长的 一段时间的试验和错误总结出来的。</li>
<li>设计模式的本质 <strong>提高软件的维护性，通用性和扩展性，并降低软件的复杂度</strong>。</li>
<li>&lt;&lt;设计模式&gt;&gt; 是经典的书，作者是 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides Design(俗称 “四人组 GOF”)</li>
<li>设计模式并 <strong>不局限于某种语言</strong>，java，php，c++ 都有设计模式.</li>
</ol>
<h2 id="设计模式类型"><a href="#设计模式类型" class="headerlink" title="设计模式类型"></a>设计模式类型</h2><blockquote>
<p>设计模式分为三种类型，共 <strong>23</strong> 种</p>
</blockquote>
<ol>
<li><p>创建型模式: <strong><em>单例模式</em></strong>、抽象工厂模式、原型模式、建造者模式、 <strong><em>工厂模式</em></strong>。</p>
</li>
<li><p>结构型模式:适配器模式、桥接模式、 <strong><em>装饰模式</em></strong>、组合模式、外观模式、享元模式、 <strong><em>代理模式</em></strong>。</p>
</li>
<li><p>行为型模式:模版方法模式、命令模式、访问者模式、迭代器模式、 <strong><em>观察者模式</em></strong>、中介者模式、备忘录模式、 解释器模式(Interpreter 模式)、状态模式、策略模式、职责链模式(责任链模式)。</p>
</li>
</ol>
<p>注意: <strong>不同的书籍上对分类和名称略有差别</strong></p>
<h1 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h1><h2 id="单例设计模式介绍"><a href="#单例设计模式介绍" class="headerlink" title="单例设计模式介绍"></a>单例设计模式介绍</h2><blockquote>
<p>所谓类的单例设计模式, 就是 **采取一定的方法保证在整个的软件系统中, 对某一个类只能存在一个对象实例, 并且该类只提供一个取得其对象实例的方法(静态方法)**。</p>
</blockquote>
<p>​       比如 Hibernate 的 SessionFactory，它充当数据存储源的代理，并负责创建 Session 对象。SessionFactory 并不是 轻量级的，一般情况下，一个项目通常只需要一个 SessionFactory 就够，这是就会使用到单例模式。</p>
<h2 id="单例设计模式八种方式"><a href="#单例设计模式八种方式" class="headerlink" title="单例设计模式八种方式"></a>单例设计模式八种方式</h2><p><strong>1) 饿汉式(静态常量)</strong></p>
<p><strong>2) 饿汉式(静态代码块)</strong></p>
<ol start="3">
<li><p>懒汉式(线程不安全)</p>
</li>
<li><p>懒汉式(线程安全，同步方法) </p>
</li>
<li><p>懒汉式(线程不安全，同步代码块) </p>
</li>
</ol>
<p> <strong>6) 双重检查</strong></p>
<p> <strong>7) 静态内部类</strong></p>
<p> <strong>8) 枚举</strong></p>
<h3 id="饿汉式-静态常量"><a href="#饿汉式-静态常量" class="headerlink" title="饿汉式(静态常量)"></a>饿汉式(静态常量)</h3><ol>
<li>构造器私有化 (防止 new )</li>
<li>类的内部创建对象</li>
<li>向外暴露一个静态的公共方法。getInstance </li>
</ol>
<p>代码实现:</p>
<pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 饿汉式(静态常量)实现单例模式</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonTest</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        Singleton singleton1 = Singleton.getInstance();
        Singleton singleton2 = Singleton.getInstance();
        System.out.println(singleton1 == singleton2); <span class="hljs-comment">// true</span>
        System.out.println(<span class="hljs-string">&quot;singleton1.hashCode():&quot;</span>+singleton1.hashCode());
        System.out.println(<span class="hljs-string">&quot;singleton2.hashCode():&quot;</span>+singleton2.hashCode());
        <span class="hljs-comment">//singleton1.hashCode():1639705018</span>
        <span class="hljs-comment">//singleton2.hashCode():1639705018</span>
    &#125;
&#125;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span></span>&#123;
    <span class="hljs-comment">// 1. 构造器私有化</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span></span>&#123;&#125;
    <span class="hljs-comment">// 2. 本类内部创建对象实例</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton instance = <span class="hljs-keyword">new</span> Singleton();
    <span class="hljs-comment">// 3. 提供公有的静态方法返回实例对象</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;
        <span class="hljs-keyword">return</span> instance;
    &#125;
&#125;</code></pre>

<ol>
<li><p>优点:这种写法比较简单，就是在 <strong>类装载的时候就完成实例化</strong>。 <strong>避免了线程同步问题</strong>。</p>
</li>
<li><p>缺点:在类装载的时候就完成实例化，<strong>没有达到LazyLoading的效果</strong>。如果从始至终从未使用过这个实例，则</p>
<p>会造成内存的浪费</p>
</li>
<li><p>这种方式基于classloder机制避免了多线程的同步问题，不过，instance在类装载时就实例化，在单例模式中大多数都是调用 getInstance 方法，但是 <strong>导致类装载的原因有很多种</strong>，因此不能确定有其他的方式(或者其他的静态方法)导致类装载，这时候初始化 instance 就 <strong>没有达到 lazy loading 的效果</strong></p>
</li>
</ol>
<p>结论:这种单例模式 <strong><em>可用</em></strong>，可能造成 <strong><em>内存浪费</em></strong></p>
<h3 id="饿汉式-静态代码块"><a href="#饿汉式-静态代码块" class="headerlink" title="饿汉式(静态代码块)"></a>饿汉式(静态代码块)</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonTest</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        Singleton singleton1 = Singleton.getInstance();
        Singleton singleton2 = Singleton.getInstance();
        System.out.println(singleton1 == singleton2); <span class="hljs-comment">// true</span>
        System.out.println(<span class="hljs-string">&quot;singleton1.hashCode():&quot;</span>+singleton1.hashCode());
        System.out.println(<span class="hljs-string">&quot;singleton2.hashCode():&quot;</span>+singleton2.hashCode());
        <span class="hljs-comment">//singleton1.hashCode():1639705018</span>
        <span class="hljs-comment">//singleton2.hashCode():1639705018</span>
    &#125;
&#125;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span></span>&#123;
    <span class="hljs-comment">// 1.构造器私有化</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span></span>&#123;&#125;
    <span class="hljs-comment">// 2.类中创建对象事例</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;
    <span class="hljs-keyword">static</span> &#123;
        <span class="hljs-comment">// 静态代码块中创建事例</span>
        instance = <span class="hljs-keyword">new</span> Singleton();
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> instance;&#125;
&#125;</code></pre>

<ol>
<li>这种方式和上面的方式其实类似，只不过将类实例化的过程放在了静态代码块中，也是在类装载的时候，就执行静态代码块中的代码，初始化类的实例。优缺点和上面是一样的。</li>
</ol>
<p>结论:这种单例模式可用，但是可能造成内存浪费</p>
<h3 id="懒汉式-线程不安全"><a href="#懒汉式-线程不安全" class="headerlink" title="懒汉式(线程不安全)"></a>懒汉式(线程不安全)</h3><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 懒汉式(线程不安全写法)</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonTest</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        Singleton singleton1 = Singleton.getInstance();
        Singleton singleton2 = Singleton.getInstance();
        System.out.println(singleton1 == singleton2); <span class="hljs-comment">// true</span>
        System.out.println(<span class="hljs-string">&quot;singleton1.hashCode():&quot;</span>+singleton1.hashCode());
        System.out.println(<span class="hljs-string">&quot;singleton2.hashCode():&quot;</span>+singleton2.hashCode());
        <span class="hljs-comment">// singleton1.hashCode():1639705018</span>
        <span class="hljs-comment">// singleton2.hashCode():1639705018</span>
    &#125;
&#125;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span></span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span></span>&#123;&#125;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;

    <span class="hljs-comment">// 构造一个静态方法, 当用到该方法时, 才创建实例</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;
        <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>)&#123;
            instance = <span class="hljs-keyword">new</span> Singleton();
        &#125;
        <span class="hljs-keyword">return</span> instance;
    &#125;
&#125;</code></pre>

<ol>
<li><p>起到了 <strong>LazyLoading</strong>的效果，但是只能在 <strong>单线程</strong>下使用。</p>
</li>
<li><p>如果在多线程下，一个线程进入了if(singleton==null)判断语句块，还未来得及往下执行，另一个线程也通过</p>
<p>了这个判断语句，这时便会产生 <strong>多个实例</strong>。所以在多线程环境下不可使用这种方式 </p>
</li>
</ol>
<p>​   结论:在实际开发中，<strong>不要使用这种方式</strong>.</p>
<h3 id="懒汉式-线程安全，同步方法"><a href="#懒汉式-线程安全，同步方法" class="headerlink" title="懒汉式(线程安全，同步方法)"></a>懒汉式(线程安全，同步方法)</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span></span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span></span>&#123;&#125;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;
        <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>)&#123;
            instance = <span class="hljs-keyword">new</span> Singleton();
        &#125;
        <span class="hljs-keyword">return</span> instance;
    &#125;
&#125;</code></pre>

<ol>
<li><p><strong>解决了线程安全问题</strong></p>
</li>
<li><p><strong>效率太低</strong>了，每个线程在想获得类的实例时候，执行getInstance()方法 <strong>都要进行同步</strong>。而其实这个方法只执行一次实例化代码就够了，后面的想获得该类实例，直接 return 就行了。方法进行同步效率太低 </p>
<p>结论:在实际开发中，<strong>不推荐使用这种方式</strong></p>
</li>
</ol>
<h3 id="懒汉式-线程不安全，同步代码块"><a href="#懒汉式-线程不安全，同步代码块" class="headerlink" title="懒汉式(线程不安全，同步代码块)"></a>懒汉式(线程不安全，同步代码块)</h3><img src="https://blogimgurl.oss-cn-hangzhou.aliyuncs.com/img20201202150123.png" srcset="/img/loading.gif" alt="无效" style="zoom:50%;" />

<p>​   在这里加入synchronized无效, 无法解决线程安全问题, 一个线程进入了if(singleton==null)判断语句块, 还未来得及往下执行, 另一个线程也通过了这个判断语句, 这时便会产生 <strong>多个实例</strong>。</p>
<h3 id="双重检查"><a href="#双重检查" class="headerlink" title="双重检查"></a>双重检查</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span></span>&#123;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Singleton instance;
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span></span>&#123;&#125;
    <span class="hljs-comment">// 提供一个静态代码块，双重检查，解决线程安全问题，同时解决懒加载问题</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;
        <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>)&#123;
            <span class="hljs-keyword">synchronized</span> (Singleton.class)&#123;
                <span class="hljs-keyword">if</span>(instance == <span class="hljs-keyword">null</span>)&#123;
                    instance = <span class="hljs-keyword">new</span> Singleton();
                &#125;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> instance;
    &#125;
&#125;</code></pre>

<ol>
<li>Double-Check 概念是多线程开发中常使用到的，如代码中所示，我们进行了两次 if (singleton == null)检查，这 样就可以保证线程安全了。</li>
<li>这样，实例化代码只用执行一次，后面再次访问时，判断if(singleton==null)，直接return实例化对象，也避免的反复进行方法同步.</li>
<li><strong>线程安全; 延迟加载;效率较高</strong></li>
</ol>
<p>结论:在实际开发中， <strong>推荐使用这种单例设计模式</strong></p>
<h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><blockquote>
<p>JVM装载类的时候线程是安全的</p>
</blockquote>
<pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span></span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span></span>&#123;&#125;
    <span class="hljs-comment">// 写一个静态内部类，该类中有一个静态属性Singleton</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonInstance</span></span>&#123;
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton INSTANCE = <span class="hljs-keyword">new</span> Singleton();
    &#125;
    <span class="hljs-comment">// 提供一个静态公有方法，返回SingletonInstance.INSTANCE</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;
        <span class="hljs-keyword">return</span> SingletonInstance.INSTANCE;
    &#125;
&#125;</code></pre>

<ol>
<li><p>这种方式采用了 <strong>类装载的机制</strong>来保证初始化实例时只有一个线程。(因为类装载是线程安全的)</p>
</li>
<li><p>  <strong>静态内部类方式在Singleton类被装载时并不会立即实例化</strong>，而是在需要实例化时， <strong>调用getInstance方法</strong>， <strong>才会装载 SingletonInstance 类</strong>，从而完成 Singleton 的实例化。</p>
</li>
<li><p> 类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM帮助我们保证了线程的安全性，在类进行   初始化时，别的线程是无法进入的。</p>
</li>
<li><p> 优点: <strong>避免了线程不安全，利用静态内部类特点实现延迟加载，效率高</strong></p>
</li>
<li><p> 结论: <strong>推荐</strong>使用.</p>
</li>
</ol>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Singleton</span></span>&#123;
    INSTANCE;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayOK</span><span class="hljs-params">()</span></span>&#123;
        System.out.println(<span class="hljs-string">&quot;ok!&quot;</span>);
    &#125;
&#125;</code></pre>

<p>使用:</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
    Singleton instance = Singleton.INSTANCE;
    Singleton instance2 = Singleton.INSTANCE;
    System.out.println(instance == instance2);
    System.out.println(instance.hashCode());
    System.out.println(instance2.hashCode());
    instance.sayOK(); 
&#125;</code></pre>

<ol>
<li><p> 这 <strong>借助JDK1.5中添加的枚举</strong>来实现单例模式。不仅能 <strong>避免多线程同步问题，而且还能防止反序列化重新创建 新的对象</strong>。</p>
</li>
<li><p> 这种方式是<strong>EffectiveJava</strong>作者<strong>JoshBloch</strong>提倡的方式</p>
</li>
</ol>
<p>​    结论: <strong>推荐</strong>使用</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/11/27/Java%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">
                        <span class="hidden-mobile">java并发编程 学习笔记</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":200})
    NProgress.start()
    document.addEventListener('DOMContentLoaded', function() {
      window.NProgress && window.NProgress.inc();
    })
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.staticfile.org/jquery/3.5.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.staticfile.org/tocbot/4.12.0/tocbot.min.js" ></script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>





  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      var inputArea = document.querySelector("#local-search-input");
      inputArea.onclick = function () {
        searchFunc(path, 'local-search-input', 'local-search-result');
        this.onclick = null
      }
    })()
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>



</body>
</html>
